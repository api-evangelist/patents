---
title: Subbuffer objects
abstract: A method and an apparatus for a parallel computing program using subbuffers to perform a data processing task in parallel among heterogeneous compute units are described. The compute units can include a heterogeneous mix of central processing units (CPUs) and graphic processing units (GPUs). A system creates a subbuffer from a parent buffer for each of a plurality of heterogeneous compute units. If a subbuffer is not associated with the same compute unit as the parent buffer, the system copies data from the subbuffer to memory of that compute unit. The system further tracks updates to the data and transfers those updates back to the subbuffer.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08723877&OS=08723877&RS=08723877
owner: Apple Inc.
number: 08723877
owner_city: Cupertino
owner_country: US
publication_date: 20100928
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","FIELD OF INVENTION","BACKGROUND","SUMMARY OF THE DESCRIPTION","DETAILED DESCRIPTION"],"p":["Applicant claims the benefit of priority of prior, provisional application Ser. No. 61\/346,866, filed May 20, 2010, the entirety of which is incorporated by reference.","The present invention relates generally to data parallel computing. More particularly, this invention relates to managing subbuffer objects associated with a buffer in a heterogeneous multi-compute unit environment.","As GPUs continue to evolve into high performance parallel computing devices, more and more applications are written to perform data parallel computations in GPUs similar to general purpose computing devices. Today, these applications are designed to run on specific GPUs using vendor specific interfaces. Thus, these applications are not able to leverage processing resources of CPUs even when both GPUs and CPUs are available in a data processing system. Nor can processing resources be leveraged across GPUs from different vendors where such an application is running.","However, as more and more CPUs embrace multiple cores to perform data parallel computations, more and more processing tasks can be supported by either CPUs and\/or GPUs whichever are available. Traditionally, GPUs and CPUs are configured through separate programming environments that are not compatible with each other. Most GPUs require dedicated programs that are vendor specific. As a result, it is very difficult for an application to leverage processing resources of both CPUs and GPUs, for example, leveraging processing resources of GPUs with data parallel computing capabilities together with multi-core CPUs.","In addition, CPUs and GPUs use separate memory address spaces. The memory buffer needs to be allocated and copied in GPU memory for the GPU to process data. If an application wants the CPU and one or more GPUs to operate on regions of a data buffer, the application needs to manage allocation and copying of data from appropriate regions of the buffer that is to be shared between CPU and GPU or across GPUs. Therefore, there is a need in modern data processing systems to have a heterogeneous mix of CPUs and GPUs sharing a buffer.","A method and an apparatus for a parallel computing program using subbuffers to perform a data processing task in parallel among heterogeneous compute units are described. The compute units can include a heterogeneous mix of central processing units (CPUs) and graphic processing units (GPUs). A system creates a subbuffer from a parent buffer for each of a plurality of heterogeneous compute units. If a subbuffer is not associated with the same compute unit as the parent buffer, the system copies data from the subbuffer to memory of that compute unit. The system further tracks updates to the data and transfers those updates back to the subbuffer.","Other features of the present invention will be apparent from the accompanying drawings and from the detailed description that follows.","A method and an apparatus for data parallel computing on multiple processors using subbuffers created from a parent buffer is described herein. In the following description, numerous specific details are set forth to provide thorough explanation of embodiments of the present invention. It will be apparent, however, to one skilled in the art, that embodiments of the present invention may be practiced without these specific details. In other instances, well-known components, structures, and techniques have not been shown in detail in order not to obscure the understanding of this description.","Reference in the specification to \u201cone embodiment\u201d or \u201can embodiment\u201d means that a particular feature, structure, or characteristic described in connection with the embodiment can be included in at least one embodiment of the invention. The appearances of the phrase \u201cin one embodiment\u201d in various places in the specification do not necessarily all refer to the same embodiment.","The processes depicted in the figures that follow, are performed by processing logic that comprises hardware (e.g., circuitry, dedicated logic, etc.), software (such as is run on a general-purpose computer system or a dedicated machine), or a combination of both. Although the processes are described below in terms of some sequential operations, it should be appreciated that some of the operations described may be performed in different order. Moreover, some operations may be performed in parallel rather than sequentially.","A Graphics Processing Unit (GPU) may be a dedicated graphics processor implementing highly efficient graphics operations, such as 2D, 3D graphics operation and\/or digital video related functions. A GPU may include special (programmable) hardware to perform graphics operations, e.g. blitter operations, texture mapping, polygon rendering, pixel shading and vertex shading. GPUs are known to fetch data from a frame buffer and to blend pixels together to render an image back into the frame buffer for display. GPUs may also control the frame buffer and allow the frame buffer to be used to refresh a display, e.g. a CRT or LCD display Either a CRT or an LCD display is a short persistence display that requires refresh at a rate of at least 20 Hz (e.g. every 1\/30 of a second, the display is refreshed with data from a frame buffer). Usually, GPUs may take graphics processing tasks from CPUs coupled with the GPUs to output raster graphics images to display devices through display controllers. References in the specification to \u201cGPU\u201d may be a graphics processor or a programmable graphics processor as described in \u201cMethod and Apparatus for Multithreaded Processing of Data In a Programmable Graphics Processor\u201d, Lindholdm et al., U.S. Pat. No. 7,015,913, and \u201cMethod for Deinterlacing Interlaced Video by A Graphics Processor\u201d, Swan et al., U.S. Pat. No. 6,970,206, which are hereby incorporated by reference.","In one embodiment, a plurality of different types of processors, such as CPUs or GPUs may perform data parallel processing tasks for one or more applications concurrently to increase the usage efficiency of available processing resources in a data processing system. Processing resources of a data processing system may be based on a plurality of physical computing devices, such as CPUs or GPUs. A physical computing device may include one or more compute units. In one embodiment, data parallel processing tasks (or data parallel tasks) may be delegated to a plurality types of processors, for example, CPUs or GPUs capable of performing the tasks. A data parallel task may require certain specific processing capabilities from a processor. Processing capabilities may be, for example, dedicated texturing hardware support, double precision floating point arithmetic, dedicated local memory, stream data cache, or synchronization primitives. Separate types of processors may provide different yet overlapping groups of processing capabilities. For example, both CPU and GPU may be capable of performing double precision floating point computation. In one embodiment, an application is capable of leveraging either a CPU or a GPU, whichever is available, to perform a data parallel processing task.","In another embodiment, the system can allocate a parent buffer and further subdivide this parent buffer into multiple subbuffers. If the compute unit for the subbuffer is the same compute unit as the one associated with the parent buffer, that compute unit accesses the subbuffer data using pointers. If the compute unit for the subbuffer is different than the compute unit for the parent buffer, the system copies the data from the subbuffer to memory local to the compute unit for the subbuffer. Furthermore, the system tracks updates to the copied data and transfers the updated data back to the subbuffer.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 1","b":["100","100","100","117","115","113","101","117"]},"In one embodiment, the hosting systems  may support a software stack. The software stack can include software stack components such as applications , a compute platform layer , e.g. an OpenCL (Open Computing Language) platform, a compute runtime layer , a compute compiler  and compute application libraries . An application  may interface with other stack components through API calls. One or more threads may be running concurrently for the application  in the hosting systems . The compute platform layer  may maintain a data structure, or a computing device data structure, storing processing capabilities for each attached physical computing device. In one embodiment, an application may retrieve information about available processing resources of the hosting systems  through the compute platform layer . An application may select and specify capability requirements for performing a processing task through the compute platform layer . Accordingly, the compute platform layer  may determine a configuration for physical computing devices to allocate and initialize processing resources from the attached CPUs  and\/or GPUs  for the processing task. In one embodiment, the compute platform layer  may generate one or more logical computing devices for the application corresponding to one or more actual physical computing devices configured.","The compute runtime layer  may manage the execution of a processing task according to the configured processing resources for an application , for example, based on one or more logical computing devices. In one embodiment, executing a processing task may include creating a compute program object representing the processing task and allocating memory resources, e.g. for holding executables, input\/output data etc. An executable loaded for a compute program object may be a compute program executable. A compute program executable may be included in a compute program object to be executed in a compute processor or a compute unit, such as a CPU or a GPU. The compute runtime layer  may interact with the allocated physical devices to carry out the actual execution of the processing task. In one embodiment, the compute runtime layer  may coordinate executing multiple processing tasks from different applications according to run time states of each processor, such as CPU or GPU configured for the processing tasks. The compute runtime layer  may select, based on the run time states, one or more processors from the physical computing devices configured to perform the processing tasks. Performing a processing task may include executing multiple threads of one or more executables in a plurality of physical computing devices concurrently. In one embodiment, the compute runtime layer  may track the status of each executed processing task by monitoring the run time execution status of each processor.","The runtime layer may load one or more executables as compute program executables corresponding to a processing task from the application . In one embodiment, the compute runtime layer  automatically loads additional executables required to perform a processing task from the compute application library . The compute runtime layer  may load both an executable and its corresponding source program for a compute program object from the application  or the compute application library . A source program for a compute program object may be a compute program source. A plurality of executables based on a single compute program source may be loaded according to a logical computing device configured to include multiple types and\/or different versions of physical computing devices. In one embodiment, the compute runtime layer  may activate the compute compiler  to online compile a loaded source program into an executable optimized for a target processor, e.g. a CPU or a GPU, configured to execute the executable.","An online compiled executable may be stored for future invocation in addition to existing executables according to a corresponding source program. In addition, the executables may be compiled offline and loaded to the compute runtime  using API calls. The compute application library  and\/or application  may load an associated executable in response to library API requests from an application. Newly compiled executables may be dynamically updated for the compute application library  or for the application . In one embodiment, the compute runtime  may replace an existing compute program executable in an application by a new executable online compiled through the compute compiler  for a newly upgraded version of computing device. The compute runtime  may insert a new executable online compiled to update the compute application library . In one embodiment, the compute runtime  may invoke the compute compiler  when loading an executable for a processing task. In another embodiment, the compute compiler  may be invoked offline to build executables for the compute application library . The compute compiler  may compile and link a compute kernel program to generate a compute program executable. In one embodiment, the compute application library  may include a plurality of functions to support, for example, development toolkits and\/or image processing. Each library function may correspond to a compute program source and one or more compute program executables stored in the compute application library  for a plurality of physical computing devices.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 2","b":["205","1","1","205","203"]},"A computing device may include one or more compute processors or compute units such as Processor_  and Processor_L . A local memory may be coupled with a compute processor. Local memory, shared among threads in a single thread group running in a compute processor, may be supported by the local memory coupled with the compute processor. Multiple threads from across different thread groups, such as thread   and thread N , may share a compute memory object, such as a stream, stored in a computing device memory  coupled to the computing device . A computing device memory  may include a global memory and a constant memory. A global memory may be used to allocate compute memory objects, such as streams. A compute memory object may include a collection of data elements that can be operated on by a compute program executable. A compute memory object may represent an image, a texture, a frame-buffer, an array of a scalar data type, an array of a user-defined structure, buffer, subbuffer, or a variable, etc. A constant memory may be read-only memory storing constant variables frequently used by a compute program executable.","In one embodiment, a local memory for a compute processor or compute unit may be used to allocate variables shared by all thread in a thread group or a thread group. A local memory may be implemented as a dedicated local storage, such as local shared memory  for Processor_ and local shared memory  for Processor_L. In another embodiment, a local memory for a compute processor may be implemented as a read-write cache for a computing device memory for one or more compute processors of a computing device, such as data cache  for compute processors ,  in the computing device . A dedicated local storage may not be shared by threads across different thread groups. If the local memory of a compute processor, such as Processor_  is implemented as a read-write cache, e.g. data cache , a variable declared to be in the local memory may be allocated from the computing device memory  and cached in the read-write cache, e.g. data cache  that implements the local memory. Threads within a thread group may share local variables allocated in the computing device memory  when, for example, neither a read-write cache nor dedicated local storage are available for the corresponding computing device. In one embodiment, each thread is associated with a private memory to store thread private variables that are used by functions called in the thread. For example, private memory   may not be seen by threads other than thread  .","Furthermore, in one embodiment, compute device memory  includes a buffer  that is used to store data used by the processor_ -processor_L . Buffer  can be a one dimensional buffer, two-dimensional image, three-dimensional image, or other type of buffer as known in the art. In one embodiment, the compute device  stores data to be operated on by the processors (e.g., processor_ -processor_L ) in buffer . For example and in one embodiment, the buffer can store an array of data, a two-dimensional image, a three-dimensional image, etc., and\/or other data as known in the art. In one embodiment, data between the buffer  and other memory in system  (private memory , , local shared memory , , data cache , etc.) can be transfer using any method known in the art for inter-memory data transfer (direct PCIe transfer, asynchronous direct memory access, etc.)",{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 3","FIG. 1","FIG. 1"],"b":["303","305","301","303","103","101","301","1","305","311","117","115","141","307","303","307","1","305","311","141","309","301"]},{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 4","FIG. 2","FIG. 4"],"b":["408","223","408","402","408","408","410","410","412","410","412","410","412","410","412","410","412","412","410","402","412","410"]},"In one embodiment, each compute unit A-D is associated with one of the subbuffers A-D of buffer . In one embodiment, each of these compute units A-D use the data for the compute task assigned to each compute unit. Each of the compute units can read and\/or write data to the corresponding subbuffer A-D. For example and in one embodiment, compute unit A uses to subbuffer A, compute unit B uses to subbuffer B, compute unit C uses to subbuffer C, and compute unit D uses to subbuffer D. In this embodiment, to access the data in the subbuffers A-D, the compute units A-D would provide the corresponding pointer A-D and an offset to the desired region of the subbuffer -D. The offsets can be an array index, two-dimensional reference, three-dimensional reference, etc. Buffer  structure is further described in  below.","In one embodiment, each subbuffer is created by a function call and providing a buffer pointer and subbuffer size value. Creating a subbuffer is further described in  below.","In one embodiment, a compute unit A-D transfers data from the corresponding subbuffer A-D to the private memory A-D of that compute unit A-D. In one embodiment, the private memory A-D is memory that is local to the compute unit (e.g., private memory -M , private memory -N , local shared memory  and , and\/or data cache  as illustrated in ). In one embodiment, the compute unit A-D transfers the data over a bus coupling the compute units A-D and the memory that contains buffer . For example and in one embodiment, the coupling bus is a Peripheral Component Interface-type bus (PCI, PCI-Express (PCIe), etc.) and the transfer mechanism is a PCI direct memory transfer.",{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 5","FIG. 5"],"b":["502","500","500","502","500","500","502","504","502","500","502","502"]},{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 6","FIG. 6","FIG. 6"],"b":["600","602","600","602","600","600","600","600","602","602","602"]},{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 7","FIG. 7","FIG. 7"],"b":["700","702","700","702","700","700","500","600","700","700"]},{"@attributes":{"id":"p-0048","num":"0047"},"figref":["FIG. 8","FIG. 1","FIG. 1"],"b":["800","800","800","100","1","101","141","117","115"]},"At block , in one embodiment, the processing logic of process  may build a data structure (or a computing device data structure) representing multiple physical computing devices associated with one or more corresponding capabilities. Each physical computing device may be attached to the processing system performing the processing logic of process . Capabilities or compute capabilities of a physical computing device, such as CPU or GPU, may include whether the physical computing device support a processing feature, a memory accessing mechanism, a named extension or associated limitations. A processing feature may be related to dedicated texturing hardware support, double precision floating point arithmetic or synchronization support (e.g. mutex).","Capabilities of a computing device may include a type indicating processing characteristics or limitations associated with a computing device. An application may specify a type of required computing device or query the type of a specific computing device using APIs. Examples of different types of computing devices are shown in the following table:",{"@attributes":{"id":"p-0051","num":"0050"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["cl_device_type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["CL_DEVICE_TYPE_CPU","A computing device that "]},{"entry":[{},"is the host processor. The "]},{"entry":[{},"host processor runs the"]},{"entry":[{},"OpenCL implementations and "]},{"entry":[{},"is a single or multi-core CPU."]},{"entry":["CL_DEVICE_TYPE_GPU","A computing device that "]},{"entry":[{},"is a GPU. By this we mean "]},{"entry":[{},"that the device can also be"]},{"entry":[{},"used to accelerate a 3D API "]},{"entry":[{},"such as OpenGL or DirectX."]},{"entry":["CL_DEVICE_TYPE_ACCELERATOR","Dedicated computing acceler-"]},{"entry":[{},"ators (for example the IBM "]},{"entry":[{},"CELL Blade). These devices "]},{"entry":[{},"communicate with the host"]},{"entry":[{},"processor using a peripheral"]},{"entry":[{},"interconnect such as PCIe."]},{"entry":["CL_DEVICE_TYPE_DEFAULT","The default computing "]},{"entry":[{},"device in the system."]},{"entry":["CL_DEVICE_TYPE_ALL","All computing devices "]},{"entry":[{},"available in the system."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Additionally, capabilities of a computing device may include, for example, configuration values as shown in the following table:",{"@attributes":{"id":"p-0053","num":"0052"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["cl_device_info","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["CL_DEVICE_TYPE","The computing device type. Currently"]},{"entry":[{},"supported values are:"]},{"entry":[{},"CL_DEVICE_TYPE_CPU,"]},{"entry":[{},"CL_DEVICE_TYPE_GPU,"]},{"entry":[{},"CL_DEVICE_TYPE_ACCELERATOR,"]},{"entry":[{},"CL_DEVICE_TYPE_DEFAULT or a"]},{"entry":[{},"combination of the above."]},{"entry":["CL_DEVICE_VENDOR_ID","A unique device vendor identifier. An"]},{"entry":[{},"example of a unique device identifier"]},{"entry":[{},"could be the PCIe ID."]},{"entry":["CL_DEVICE_MAX_COMPUTE_UNITS","The number of parallel compute cores"]},{"entry":[{},"on the computing device. The"]},{"entry":[{},"minimum value is 1."]},{"entry":["CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS","Maximum dimensions that specify the"]},{"entry":[{},"global and local work-item IDs used by"]},{"entry":[{},"the data parallel execution model."]},{"entry":["CL_DEVICE_MAX_WORK_ITEM_SIZES","Maximum number of work-items that"]},{"entry":[{},"can be specified in each dimension of"]},{"entry":[{},"the work-group."]},{"entry":["CL_DEVICE_MAX_WORK_GROUP_SIZE","Maximum number of work-items in a"]},{"entry":[{},"work-group executing a kernel using the"]},{"entry":[{},"data parallel execution model."]},{"entry":["CL_DEVICE_PREFERRED_VECTOR_WIDTH_CHAR","Preferred native vector width size for"]},{"entry":["CL_DEVICE_PREFERRED_VECTOR_WIDTH_SHORT","built-in scalar types that can be put into"]},{"entry":["CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT","vectors. The vector width is defined as"]},{"entry":["CL_DEVICE_PREFERRED_VECTOR_WIDTH_LONG","the number of scalar elements that can"]},{"entry":["CL_DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT","be stored in the vector."]},{"entry":["CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE",{}]},{"entry":["CL_DEVICE_MAX_CLOCK_FREQUENCY","Maximum configured clock frequency"]},{"entry":[{},"of the device in MHz."]},{"entry":["CL_DEVICE_ADDRESS_BITS","The default compute device address"]},{"entry":[{},"space size specified as an unsigned"]},{"entry":[{},"integer value in bits, for example, 32 or"]},{"entry":[{},"64 bits."]},{"entry":["CL_DEVICE_MAX_MEM_ALLOC_SIZE","Max size of memory object allocation"]},{"entry":[{},"in bytes. The minimum value is max"]},{"entry":[{},"(\u00bcof CL_DEVICE_GLOBAL_MEM_SIZE,"]},{"entry":[{},"128 * 1024 * 1024)"]},{"entry":["CL_DEVICE_IMAGE_SUPPORT","Is CL_TRUE if images are supported by"]},{"entry":[{},"the computing device and CL_FALSE"]},{"entry":[{},"otherwise."]},{"entry":["CL_DEVICE_MAX_READ_IMAGE_ARGS","Max number of simultaneous image"]},{"entry":[{},"objects that can be read by a kernel."]},{"entry":["CL_DEVICE_MAX_WRITE_IMAGE_ARGS","Max number of simultaneous image"]},{"entry":[{},"objects that can be written to by a"]},{"entry":[{},"kernel."]},{"entry":["CL_DEVICE_IMAGE2D_MAX_WIDTH","Max width of 2D image in pixels. The"]},{"entry":[{},"minimum value is 8192."]},{"entry":["CL_DEVICE_IMAGE2D_MAX_HEIGHT","Max height of 2D image in pixels. The"]},{"entry":[{},"minimum value is 8192."]},{"entry":["CL_DEVICE_IMAGE3D_MAX_WIDTH","Max width of 3D image in pixels. The"]},{"entry":[{},"minimum value is 2048."]},{"entry":["CL_DEVICE_IMAGE3D_MAX_HEIGHT","Max height of 3D image in pixels. The"]},{"entry":[{},"minimum value is 2048 if"]},{"entry":[{},"CL_DEVICE_IMAGE_SUPPORT is"]},{"entry":[{},"CL_TRUE."]},{"entry":["CL_DEVICE_IMAGE3D_MAX_DEPTH","Max depth of 3D image in pixels. The"]},{"entry":[{},"minimum value is 2048."]},{"entry":["CL_DEVICE_MAX_SAMPLERS","Maximum number of samplers that can"]},{"entry":[{},"be used in a kernel. The minimum"]},{"entry":[{},"value may be 16."]},{"entry":["CL_DEVICE_MAX_PARAMETER_SIZE","Max size in bytes of the arguments that"]},{"entry":[{},"can be passed to a kernel. The"]},{"entry":[{},"minimum value is 256."]},{"entry":["CL_DEVICE_MEM_BASE_ADDR_ALIGN","Describes the alignment in bits of the"]},{"entry":[{},"base address of any allocated memory"]},{"entry":[{},"object."]},{"entry":["CL_DEVICE_MIN_DATA_TYPE_ALIGN_SIZE","The smallest alignment in bytes which"]},{"entry":[{},"can be used for any data type."]},{"entry":["CL_DEVICE_SINGLE_FP_CONFIG","Describes single precision floating-"]},{"entry":[{},"point capability of the device. This is a"]},{"entry":[{},"bit-field that describes one or more of"]},{"entry":[{},"the following values:"]},{"entry":[{},"CL_FP_DENORM - denorms are supported"]},{"entry":[{},"CL_FP_INF_NAN - INF and quiet NaNs are"]},{"entry":[{},"supported."]},{"entry":[{},"CL_FP_ROUND_TO_NEAREST - round to"]},{"entry":[{},"nearest even rounding mode supported"]},{"entry":[{},"CL_FP_ROUND_TO_ZERO - round to zero"]},{"entry":[{},"rounding mode supported"]},{"entry":[{},"CL_FP_ROUND_TO_INF - round to +ve and"]},{"entry":[{},"\u2212ve infinity rounding modes supported"]},{"entry":[{},"CL_FP_FMA - IEEE754-2008 fused multiply-"]},{"entry":[{},"add is supported."]},{"entry":[{},"The mandated minimum floating-point"]},{"entry":[{},"capability is:"]},{"entry":[{},"CL_FP_ROUND_TO_NEAREST |"]},{"entry":[{},"CL_FP_INF_NAN."]},{"entry":["CL_DEVICE_GLOBAL_MEM_CACHE_TYPE","Type of global memory cache"]},{"entry":[{},"supported. Valid values are:"]},{"entry":[{},"CL_NONE,"]},{"entry":[{},"CL_READ_ONLY_CACHE and"]},{"entry":[{},"CL_READ_WRITE_CACHE."]},{"entry":["CL_DEVICE_GLOBAL_MEM_CACHELINE_SIZE","Size of global memory cache line in"]},{"entry":[{},"bytes."]},{"entry":["CL_DEVICE_GLOBAL_MEM_CACHE_SIZE","Size of global memory cache in bytes."]},{"entry":["CL_DEVICE_GLOBAL_MEM_SIZE","Size of global device memory in bytes."]},{"entry":["CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE","Max size in bytes of a constant buffer"]},{"entry":[{},"allocation. The minimum value is 64 KB."]},{"entry":["CL_DEVICE_MAX_CONSTANT_ARGS","Max number of arguments declared"]},{"entry":[{},"with the _constant qualifier in a kernel."]},{"entry":[{},"The minimum value is 8."]},{"entry":["CL_DEVICE_LOCAL_MEM_TYPE","Type of local memory supported. For"]},{"entry":[{},"example, this can be set to CL_LOCAL"]},{"entry":[{},"implying dedicated local memory"]},{"entry":[{},"storage such as SRAM, or CL_GLOBAL."]},{"entry":["CL_DEVICE_LOCAL_MEM_SIZE","Size of local memory arena in bytes."]},{"entry":["CL_DEVICE_ERROR_CORRECTION_SUPPORT","Is CL_TRUE if the device implements"]},{"entry":[{},"error correction for the memories,"]},{"entry":[{},"caches, registers etc. in the device. Is"]},{"entry":[{},"CL_FALSE if the device does not"]},{"entry":[{},"implement error correction."]},{"entry":["CL_DEVICE_PROFILING_TIMER_RESOLUTION","Describes the resolution of device"]},{"entry":[{},"timer. This is measured in"]},{"entry":[{},"nanoseconds."]},{"entry":["CL_DEVICE_ENDIAN_LITTLE","Is CL_TRUE if the computing device is"]},{"entry":[{},"a little endian device and CL_FALSE"]},{"entry":[{},"otherwise."]},{"entry":["CL_DEVICE_AVAILABLE","Is CL_TRUE if the device is available"]},{"entry":[{},"and CL_FALSE if the device is not"]},{"entry":[{},"available."]},{"entry":["CL_DEVICE_COMPILER_AVAILABLE","Is CL_FALSE if the implementation"]},{"entry":[{},"does not have a compiler available to"]},{"entry":[{},"compile the program source."]},{"entry":[{},"Is CL_TRUE if the compiler is available."]},{"entry":[{},"This can be CL_FALSE for the"]},{"entry":[{},"embedded platform profile only."]},{"entry":["CL_DEVICE_EXECUTION_CAPABILITIES","Describes the execution capabilities of"]},{"entry":[{},"the device. This is a bit-field that"]},{"entry":[{},"describes one or more of the following"]},{"entry":[{},"values:"]},{"entry":[{},"CL_EXEC_KERNEL - The computing"]},{"entry":[{},"device can execute computing kernels."]},{"entry":[{},"CL_EXEC_NATIVE_KERNEL - The"]},{"entry":[{},"computing device can execute native"]},{"entry":[{},"kernels."]},{"entry":[{},"The mandated minimum capability is:"]},{"entry":[{},"CL_EXEC_KERNEL."]},{"entry":["CL_DEVICE_QUEUE_PROPERTIES","Describes the command-queue"]},{"entry":[{},"properties supported by the device."]},{"entry":[{},"This is a bit-field that describes one or"]},{"entry":[{},"more of the following values:"]},{"entry":[{},"CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE"]},{"entry":[{},"CL_QUEUE_PROFILING_ENABLE"]},{"entry":[{},"The mandated minimum capability is:"]},{"entry":[{},"CL_QUEUE_PROFILING_ENABLE."]},{"entry":["CL_DEVICE_PLATFORM","The platform associated with this"]},{"entry":[{},"device."]},{"entry":["CL_DEVICE_NAME","Device name string."]},{"entry":["CL_DEVICE_VENDOR","Vendor name string."]},{"entry":["CL_DRIVER_VERSION","Computing software driver version"]},{"entry":[{},"string in the form"]},{"entry":[{},"major_number.minor_number."]},{"entry":["CL_DEVICE_PROFILE1","Computing profile string. Returns the"]},{"entry":[{},"profile name supported by the device."]},{"entry":[{},"The profile name returned can be one of"]},{"entry":[{},"the following strings:"]},{"entry":[{},"FULL_PROFILE - if the device supports"]},{"entry":[{},"the computing specification"]},{"entry":[{},"(functionality defined as part of the core"]},{"entry":[{},"specification and does not require any"]},{"entry":[{},"extensions to be supported)."]},{"entry":[{},"EMBEDDED_PROFILE - if the device"]},{"entry":[{},"supports the computing embedded"]},{"entry":[{},"profile."]},{"entry":["CL_DEVICE_VERSION","Computing version string. Returns the"]},{"entry":[{},"computing version supported by the"]},{"entry":[{},"device."]},{"entry":["CL_DEVICE_EXTENSIONS","A string of optional features supported."]},{"entry":[{},"The list of extension names returned"]},{"entry":[{},"currently can include one or more of"]},{"entry":[{},"the following approved extension"]},{"entry":[{},"names:"]},{"entry":[{},"cl_khr_fp64"]},{"entry":[{},"cl_khr_select_fprounding_mode"]},{"entry":[{},"cl_khr_global_int32_base_atomics"]},{"entry":[{},"cl_khr_global_int32_extended_atomics"]},{"entry":[{},"cl_khr_local_int32_base_atomics"]},{"entry":[{},"cl_khr_local_int32_extended_atomics"]},{"entry":[{},"cl_khr_int64_base_atomics"]},{"entry":[{},"cl_khr_int64_extended_atomics"]},{"entry":[{},"cl_khr_3d_image_writes"]},{"entry":[{},"cl_khr_byte_addressable_store"]},{"entry":[{},"cl_khr_fp16"]},{"entry":[{},"cl_khr_gl_sharing"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":"1 The platform profile returns the profile that is implemented by the OpenCL framework. If the platform profile returned is FULL_PROFILE, the OpenCL framework will support devices that are FULL_PROFILE and may also support devices that are EMBEDDED_PROFILE. The compiler must be available for all devices i.e. CL_DEVICE_COMPILER_AVAILABLE is CL_TRUE. If the platform profile returned is EMBEDDED_PROFILE, then devices that are only EMBEDDED_PROFILE are supported."}]}}}}},"A memory accessing mechanism for a physical processing device may be related to a type of variable cache (e.g., no support, read-only, or read-write), a type of compute memory object cache, size of cache support, a dedicated local memory support or associated limitations. Memory accessing limitations may include a maximum number of compute memory objects that can be simultaneously read or written by a compute program executable, a maximum number of compute memory objects that can be allocated, or a maximum size along a dimension of a multi-dimensional compute memory object, for example, a maximum width of a compute memory object for a 2D (two-dimensional) image. A system application of the data processing system may update the data structure in response to attaching a new physical computing device to a data processing system. In one embodiment, the capabilities of a physical computing device may be predetermined. In another embodiment, a system application of the data processing system may discover a newly attached physical processing device during run time. The system application may retrieve the capabilities of the newly discovered physical computing device to update the data structure representing the attached physical computing devices and their corresponding capabilities.","According to one embodiment, the processing logic of process  may receive a compute capability requirement from an application at block . The application may send the compute capability requirement to a system application by calling APIs. The system application may correspond to a platform layer of a software stack in a hosting system for the application. In one embodiment, a compute capability requirement may identify a list of required capabilities for requesting processing resources to perform a task for the application. In one embodiment, the application may require the requested processing resources to perform the task in multiple threads concurrently. In response, the processing logic of process  may select a group of physical computing devices from attached physical computing devices at block . The selection may be determined based on a matching between the compute capability requirements against the compute capabilities stored in the capability data structure. In one embodiment, the processing logic of process  may perform the matching according to a hint provided by the capability requirement.","The processing logic of process  may determine a matching score according to the number of compute capabilities matched between a physical computing device and the compute capability requirement. In one embodiment, the processing logic of process  may select multiple physical computing devices with highest matching scores. In another embodiment, the processing logic of process  may select a physical computing device if each capability in the capability requirement is matched. The processing logic of process  may determine multiple groups of matching physical computing devices at block . In one embodiment, each group of matching physical computing devices is selected according to a load balancing capability of each device. At block , in one embodiment, the processing logic of process  may generate a computing device identifier for each group of physical computing devices selected at block . The processing logic of process  may return one or more of the generated computing device identifiers back to the application through the calling APIs. An application may choose which processing resources to employ for performing a task according to the computing device identifiers. In one embodiment, the processing logic of process  may generate at most one computing device identifier at block  for each capability requirement received.","At block , in one embodiment, the processing logic of process  may allocate resources to initialize a logical computing device for a group of physical computing devices selected at block  according to a corresponding computing device identifier. A logical computing device may be a computing device group including one or more physical computing devices. The processing logic of process  may perform initializing a logical computing device in response to API requests from an application which has received one or more computing device identifiers according to the selection at block .","The processing logic of process  may create a context object on the logical computing device for an application at block . Commands that operate on compute memory object, compute program objects and\/or compute program executables for a context object may be executed in-order (e.g. synchronously) or out of order (e.g. asynchronously) according to parameters specified in API requests when creating the context object. Profiling commands that operate on compute memory objects, compute programs or compute kernels may be enabled for a context object using API requests. In one embodiment, a context object is associated with one application thread in a hosting system running the application. Multiple threads performing processing tasks in one logical computing device or across different logical computing devices concurrently may be based on separate context objects.","In one embodiment, the processing logic of process  may be based on multiple APIs including clCreateContext, clRetainContext and clReleaseContext. The API clCreateContext creates a compute context. A compute context may correspond to a compute context object. The API clRetainContext increments the number of instances using a particular compute context identified by a context as an input argument to clRetainContext. The API clCreateContext does an implicit retain. This is useful for third-party libraries, which typically get a context passed to them by the application. However, it is possible that the application may delete the context without informing the library. Allowing multiple instances to attach to a context and release from a context solves the problem of a compute context being used by a library no longer being valid. If an input argument to clRetainContext does not correspond to a valid compute context object, clRetainContext returns CU_INVALID_CONTEXT. The API clReleaseContext releases an instance from a valid compute context. If an input argument to clReleaseContext does not correspond to a valid compute context object, clReleaseContext returns CU_INVALID_CONTEXT.",{"@attributes":{"id":"p-0060","num":"0059"},"figref":["FIG. 9","FIG. 1","FIG. 2"],"b":["900","900","109","901","900"]},"When allocating a compute memory object, the processing logic of process  may determine where the allocation should reside according to specifications in an API. For example, a compute memory object may be allocated out of a host memory, such as a host memory for the hosting systems  of  and\/or a computing device memory, such as a global memory or a constant memory  of . A compute memory object allocated in a host memory may need to be cached in a computing device memory. The processing logic of process  may asynchronously load data into allocated compute memory objects using non blocking API interfaces, e.g. based on generated event objects which include synchronization data indicating whether data has been loaded into a compute memory object. In one embodiment, the processing logic of process  may schedule memory access operations when reading from or writing to allocated compute memory objects. The processing logic of process  may map an allocated stream memory to form a logical address of an application. In one embodiment, the processing logic of process  may perform operations at block  based API requests from an application running in a host processor, such as applications  of .","At block , according to one embodiment, the processing logic of process  may create a compute program object for the logical computing device (e.g. a computing device group). A compute program object may include a group of compute kernels representing exported functions or entry points of a data parallel program. A compute kernel may include a pointer to a compute program executable that can be executed on a compute unit to perform a data parallel task (e.g. a function). Each compute kernel may be associated with a group of function arguments including compute memory objects or streams allocated for function inputs or outputs, such as the streams allocated at block .","The processing logic of process  may load a compute program binary and\/or a compute program source into the compute program object at block . A compute program binary may include bits that describe a compute program executable that will be run on a computing device. A compute program binary may be a compute program executable and\/or an intermediate representation of a compute program source to be converted into a compute program executable. In one embodiment, a compute program executable may include description data associated with, for example, the type of target physical computing devices (e.g. a GPU or a CPU), versions, and\/or compilation options or flags, such as a thread group sizes and\/or thread group dimensions. A compute program source may be the source code where a compute program executable is compiled from. The processing logic of process  may load multiple compute program executables corresponding to a compute program source at block . In one embodiment, the processing logic of process  may load a compute program executable from an application or through a compute library such as compute application library  of . A compute program executable may be loaded with the corresponding compute program source. The processing logic of process  may set up function arguments for a compute program object at block . In one embodiment, the processing logic of process  may perform operations at blocks ,  and  according to API requests from an application.","At block , the processing logic of process  may update an execution queue to execute the compute kernel object with a logical computing device. The processing logic of process  may execute a computer kernel in response to API calls with appropriate arguments to a compute runtime, e.g. compute runtime  of , from an application or a compute application library, such as applications  or compute application library  of . Executing a compute kernel may include executing a compute program executable associated with the compute kernel. In one embodiment, the processing logic of process  may generate a compute kernel execution instance to execute a compute kernel. API calls to a compute runtime, such as compute runtime  of , to execute a compute kernel may be asynchronous in nature. An execution instance may be identified by a compute event object that may be returned by a compute runtime, such as compute runtime  of . A compute kernel execution instance may be added to an execution queue to execute a compute kernel instance.","In one embodiment, API calls to a compute runtime to execute a compute kernel may include the number of threads that execute simultaneously in parallel on a compute processor as a thread group. An API call may include the number of compute processors to use. A compute kernel execution instance may include a priority value indicating a desired priority to execute the corresponding compute program executable. A compute kernel execution instance may also include an event object identifying a previous execution instance and\/or expected total number of threads and number of thread groups to perform the execution. The number of thread groups and total number of threads may be specified in the API calls. In one embodiment, an event object may indicate an execution order relationship between the execution instance that includes the event object and another execution instance identified by the event object. An execution instance including an event object may be required to be executed after another execution instance identified by the event object finishes execution. An event object may be referred to as a queue_after_event_object. Events and event dependencies are further described in  below. In one embodiment, an execution queue may include multiple compute kernel execution instances for executing corresponding compute program executables. One or more compute kernel execution instances for a compute program executable may be scheduled for execution in an execution queue. In one embodiment, the processing logic of process  may update the execution queue in response to API requests from an application. The execution queue may be hosted by the hosting data systems where the application is running.","At block , the processing logic of process  may select a compute kernel execution instance from the execution queue for execution. In one embodiment, the processing logic of process  may select more than one compute kernel execution instances to be executed concurrently according to the corresponding logical computing devices. The processing logic of process  may determine whether a compute kernel execution instance is selected from the execution queue based on its associated priority and dependency relationships with other execution instances in the execution queue. A compute kernel execution instance may be executed by executing its corresponding compute kernel object according to an executable loaded to the compute kernel object.","At block , in one embodiment, the processing logic of process  may select one of the plurality of executables loaded to the compute kernel object corresponding to the selected compute kernel instance for execution in a physical computing device associated with the logical computing device for the compute kernel object. The processing logic of process  may select more than one executables to be executed in more than one physical computing device in parallel for one compute kernel execution instance. The selection may be based on current execution statuses of the physical computing devices corresponding to the logical computing device associated with the selected compute kernel execution instance. An execution status of a physical computing device may include the number of threads running, the local memory usage level and the processor usage level (e.g. peak number of operations per unit time), etc. In one embodiment, the selection may be based on predetermined usage levels. In another embodiment, the selection may be based on the number of threads and number of thread groups associated with the compute kernel execution instance. The processing logic of process  may retrieve an execution status from a physical computing device. In one embodiment, the processing logic of process  may perform operations to select a compute kernel execution instance from the execution queue to execute at blocks   asynchronously to applications running in hosting systems.","At block , the processing logic of process  may check the execution status of a compute kernel execution instance scheduled for execution in the execution queue. Each execution instance may be identified by a unique compute event object. An event object may be returned to an application or a compute application library, such as application  or compute application library  of , which calls APIs to execute the execution instance, when the corresponding compute kernel execution instance was queued according to a compute runtime, such as the runtime  of . In one embodiment, the processing logic of process  may perform the execution status checking in response to API requests from an application. The processing logic of process  may determine the completion of executing a compute kernel execution instance by querying a status of the compute event object identifying the compute kernel execution instance. The processing logic of process  may wait until the execution of a compute kernel execution instance is complete to return to API calls from an application. The processing logic of process  may control processing execution instances reading and\/or writing from various streams based on compute event objects.","At block , according to one embodiment, the processing logic of process  may retrieve results of executing a compute kernel execution instance. Subsequently, the processing logic of process  may clean up processing resources allocated for executing the compute kernel execution instance. In one embodiment, the processing logic of process  may copy a stream memory holding results of executing a compute kernel executable into a local memory. The processing logic of process  may delete variable streams or image streams allocated at block . The processing logic of process  may delete a kernel event object for detecting when a compute kernel execution is completed. If each compute kernel execution instance associated with a specific compute kernel object has been completely executed, the processing logic of process  may delete the specific compute kernel object. In one embodiment, the processing logic of process  may perform operations at block  based on API requests initiated by an application.",{"@attributes":{"id":"p-0070","num":"0069"},"figref":["FIG. 10","FIG. 1","FIG. 1","FIG. 1"],"b":["1000","1000","1000","100","101","141","117","115"]},"In , process  creates a subbuffer for a compute unit, where the subbuffer is associated with a buffer. In one embodiment, process  creates a subbuffer from a currently allocated buffer. For example and in one embodiment, process  creates a subbuffer from an allocated buffer using the function call:",{"@attributes":{"id":"p-0072","num":"0071"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"right"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["cl_mem","clCreateSubBuffer ","(cl_mem buffer,"]},{"entry":[{},{},"cl_mem_flags flags,"]},{"entry":[{},{},"cl_buffer_create_type buffer_create_type,"]},{"entry":[{},{},"const void *buffer_create_info,"]},{"entry":[{},{},"cl_int *errcode_ret)"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},{"@attributes":{"id":"p-0073","num":"0072"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 3"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Subbuffer memory creation flags."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["cl_mem_flags","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["CL_MEM_READ_WRITE","This flag specifies that the memory "]},{"entry":[{},"object will be read and written "]},{"entry":[{},"by a kernel. This is the default."]},{"entry":["CL_MEM_WRITE_ONLY","This flags specifies that the"]},{"entry":[{},"memory object will be written"]},{"entry":[{},"but not read by a kernel."]},{"entry":["CL_MEM_READ_ONLY","This flag specifies that the memory "]},{"entry":[{},"object is a read-only memory object "]},{"entry":[{},"when used inside a kernel."]},{"entry":["CL_MEM_USE_HOST_PTR","This flag is valid only if host_ptr"]},{"entry":[{},"is not NULL. If specified, it "]},{"entry":[{},"indicates that the application"]},{"entry":[{},"wants the implementation to use"]},{"entry":[{},"memory referenced by host_ptr"]},{"entry":[{},"as the storage bits for the memory"]},{"entry":[{},"object. "]},{"entry":[{},"Implementations can be"]},{"entry":[{},"allowed to cache the buffer"]},{"entry":[{},"contents pointed to by host_ptr"]},{"entry":[{},"in device memory. This cached "]},{"entry":[{},"copy can be used when kernels "]},{"entry":[{},"are executed on a device. "]},{"entry":[{},"The result of OpenCL commands that"]},{"entry":[{},"operate on multiple buffer objects "]},{"entry":[{},"created with the same host_ptr or"]},{"entry":[{},"overlapping host regions is"]},{"entry":[{},"considered to be undefined."]},{"entry":["CL_MEM_ALLOC_HOST_PTR","This flag specifies that the "]},{"entry":[{},"application wants the "]},{"entry":[{},"implementation to allocate "]},{"entry":[{},"memory from host accessible "]},{"entry":[{},"memory. "]},{"entry":[{},"CL_MEM_ALLOC_HOST_PTR"]},{"entry":[{},"and CL_MEM_USE_HOST_PTR "]},{"entry":[{},"are mutually exclusive."]},{"entry":["CL_MEM_COPY_HOST_PTR","This flag is valid if host_ptr is not "]},{"entry":[{},"NULL. If specified, it indicates that "]},{"entry":[{},"the application wants the "]},{"entry":[{},"implementation to allocate memory "]},{"entry":[{},"for the memory object and copy the "]},{"entry":[{},"data from memory referenced by "]},{"entry":[{},"host_ptr. "]},{"entry":[{},"CL_MEM_COPY_HOST_PTR and"]},{"entry":[{},"CL_MEM_USE_HOST_PTR are "]},{"entry":[{},"mutually exclusive."]},{"entry":[{},"CL_MEM_COPY_HOST_PTR "]},{"entry":[{},"can be used with "]},{"entry":[{},"CL_MEM_ALLOC_HOST_PTR to"]},{"entry":[{},"initialize the contents of the "]},{"entry":[{},"cl_mem object allocated using host-"]},{"entry":[{},"accessible (e.g. PCIe) memory."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0074","num":"0073"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"center"}},"thead":{"row":{"entry":"TABLE 4"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"CL_BUFFER_CREATE_TYPE Values."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["cl_buffer_create_type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["CL_BUFFER_CREATE_TYPE_REGION","Create a buffer object that represents a"]},{"entry":[{},"specific region in buffer."]},{"entry":[{},"buffer_create_info is a pointer to the"]},{"entry":[{},"following structure:"]},{"entry":[{},"typedef struct"]},{"entry":[{},"_cl_buffer_region {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"size_t origin;"]},{"entry":[{},"size_t size;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} cl_buffer_region;"]},{"entry":[{},"(origin, size) defines the offset and size in"]},{"entry":[{},"bytes in buffer."]},{"entry":[{},"If buffer is created with"]},{"entry":[{},"CL_MEM_USE_HOST_PTR, the host_ptr"]},{"entry":[{},"associated with the buffer object returned is"]},{"entry":[{},"host_ptr + origin."]},{"entry":[{},"The buffer object returned references the data"]},{"entry":[{},"store allocated for buffer and points to a"]},{"entry":[{},"specific region given by (origin, size) in this"]},{"entry":[{},"data store."]},{"entry":[{},"CL_INVALID_VALUE is returned in"]},{"entry":[{},"errcode_ret if the region specified by (origin,"]},{"entry":[{},"size) is out of bounds in buffer."]},{"entry":[{},"CL_MISALIGNED_SUB_BUFFER_OFFSET is"]},{"entry":[{},"returned in errcode_ret if there are no devices"]},{"entry":[{},"in context associated with buffer for which the"]},{"entry":[{},"origin value is aligned to the"]},{"entry":[{},"CL_DEVICE_MEM_BASE_ADDR_ALIGN"]},{"entry":[{},"value."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"At block , process  determines if the compute unit for the subbuffer is the same compute unit as the parent buffer. For example and in one embodiment, process  determines that the subbuffer is created for a CPU. If the compute unit is different, process  copies the data to the private memory of the compute unit associated with the subbuffer. For example and in one embodiment, if the compute unit is a GPU and the compute unit associated with the buffer is a CPU, process  would copy the data associated with the subbuffer into the memory of the GPU. Referring back to , process  would copy the data from one of the subbuffers (e.g., subbuffer A) into the memory of the GPU (e.g., private memory A of compute unit A). If the compute units are the same for subbuffer and the buffer, process  uses pointers to access the data in the subbuffer at block . For example and in one embodiment, process  would use pointer A to access data in subbuffer A as described in  above. Because process  is using pointers to access the data and does not need to update data that is changed, process  ends at .","On the other hand, if process  has copied the data into the private memory of the compute unit associated with the subbuffer, process  tracks updates to the data in the private memory of that compute unit. For example and in one embodiment at block . Based on the tracked updates, process  sends the updates to the parent buffer at block . While in one embodiment, process  sends the updates at once, in alternate embodiment, process  sends the updates in a different fashion (e.g., periodically sends updates, automatically sends updates, etc.).","In addition to creating, using, and\/or managing subbuffers for compute units, system  can use events to synchronize operations of a context as described above with reference to . In one embodiment, an event object encapsulates that status of an operation such as a command. In this embodiment, these objects can be used to synchronize operations in a context. In addition, system  can use event wait lists to control when a particular command begins execution. An event wait list is a list of event objects.  is a flow diagram illustrating one embodiment of a process  to execute callbacks associated with events that have internal and external dependencies. In one embodiment, a callback is used to report events (e.g., errors, etc.) that occur within a context. As described above with reference to , a context is created with one or more compute units and is used to manage objects such as command-queues, memory, program, kernel objects and for executing kernels on one or more compute units specified in the context.","Exemplary process  may be performed by a processing logic that may comprise hardware (circuitry, dedicated logic, etc.), software (such as is run on a dedicated machine), or a combination of both. For example, process  may be performed in accordance with the system  of  in a data processing system hosted by the hosting systems . The data processing system may include a host processor hosting a platform layer, such as compute platform layer  of , and multiple physical computing devices attached to the host processor, such as CPUs  and GPUs  of .","Process  registers an event to run a callback with a context, where the event has external dependencies at block . In one embodiment, an event can have internal, external, and\/or no dependencies. An event with an internal dependency means that before the callback associated with the event can be executed, the internal dependency is to be resolved. In one embodiment, the internal dependency is a system recognized event, such as a kernel execution command or managing commands (e.g., read, write, map, copy commands on memory objects). An external dependency is a user defined event and this external dependency should be resolved before the callback can be executed. For example and in one embodiment, a user defined event can allow applications to enqueue commands that wait on the user event to finish before the enqueued command is executed by the corresponding compute unit. In another embodiment, a user event object can be used to report an application specific error condition. In one embodiment, event dependencies can be stored in an event wait list.","At block , process  receives notification that the registered event has occurred. In one embodiment, process  receives notification of the event by invoking a function that waits for events. At block , process  determines if the registered event has any unresolved internal events. For example and in one embodiment, process  determines if an event wait list associated with the registered event has any internal dependencies. If there are any internal dependencies, process  delays execution of the callback at block . In one embodiment, process  delays execution until the internal dependencies are resolved. For example and in one embodiment, resolving a dependency can include waiting for a command associated with a dependent event to complete.","If there are no internal dependency for the registered event, process  determines if the registered event has any external dependencies at block . For example and in one embodiment, process  determines if an event wait list associated with the registered event has any external dependencies. If there are any external dependencies, process  delays execution of the callback at block . In one embodiment, process  delays execution until the external dependencies are resolved. For example and in one embodiment, resolving a dependency can include waiting for a command associated with a dependent event to complete.",{"@attributes":{"id":"p-0082","num":"0081"},"figref":["FIG. 12","FIG. 12"],"b":["1202","1202","1202","1204","1202","1202","1202","1202","1204","1202","1204","1202","1202","1204","1202","1202","1204","1202","1202","1204"]},{"@attributes":{"id":"p-0083","num":"0082"},"figref":["FIG. 13","FIG. 1"],"b":["1300","1301","1303","1300","131","1305"]},{"@attributes":{"id":"p-0084","num":"0083"},"figref":["FIGS. 14A-14C","FIG. 1","FIG. 8","FIG. 9","FIG. 8","FIG. 9"],"b":["1400","1400","101","1400","1400","1400","1400","800","900","1401","800","811","900","901"]},"Turning now to , processing operations to allocate and load array memory objects may be performed by the processing logic of process  at block  of . The processing operation to create a compute program object  may be performed by the processing logic of process  at block  of . Processing operation  may load a compute program source, such as example  of , to the compute program object created. Processing operation  may explicitly build a compute program executable from the loaded compute program source. In one embodiment, processing operation  may load an already built compute program executable to the created compute program object. Subsequently, processing operation  may create a compute kernel object pointing to the built compute program executable for scheduling an execution on a computing device.","Turing now to , in one embodiment, processing operation  may attach variables and compute memory objects as function arguments for the created compute kernel object. Processing operation  may be performed by the processing logic of process  at block  of . Processing operation  may execute the created compute kernel object. In one embodiment, processing operation  may be performed by the processing logic of process  at block  of . Processing operation  may cause an execution queue to be updated with a compute kernel execution instance corresponding to the created compute kernel object. Processing operation  may synchronously wait for a completion of executing the create compute kernel object. In one embodiment, processing operation  may retrieve a result from executing the compute kernel object. Subsequently, processing operations  may clean up allocated resources for executing the compute kernel object, such as an event object, the created compute kernel object and the allocated memories. In one embodiment, processing operation  may be performed asynchronously based on whether a kernel event object is set. Processing operation  may be performed by process  at block  of .",{"@attributes":{"id":"p-0087","num":"0086"},"figref":["FIG. 15","FIG. 1","FIG. 15"],"b":["1500","1500"]},"As shown in , the computer system , which is a form of a data processing system, includes a bus  which is coupled to a microprocessor(s) , such as CPUs and\/or GPUs, a ROM (Read Only Memory) , volatile RAM  and a non-volatile memory . The microprocessor  may retrieve the instructions from the memories , ,  and execute the instructions using Cache  to perform operations described above. The bus  interconnects these various components together and also interconnects these components , , , and  to a display controller and display device  and to peripheral devices such as input\/output (I\/O) devices which may be mice, keyboards, modems, network interfaces, printers and other devices which are well known in the art. Typically, the input\/output devices  are coupled to the system through input\/output controllers . The volatile RAM (Random Access Memory)  is typically implemented as dynamic RAM (DRAM) which requires power continually in order to refresh or maintain the data in the memory. The display controller coupled with a display device  may optionally include one or more GPUs to process display data. Optionally, GPU memory  may be provided to support GPUs included in the display device .","The mass storage  is typically a magnetic hard drive or a magnetic optical drive or an optical drive or a DVD RAM or a flash memory or other types of memory systems which maintain data (e.g. large amounts of data) even after power is removed from the system. Typically, the mass storage  will also be a random access memory although this is not required. While  shows that the mass storage  is a local device coupled directly to the rest of the components in the data processing system, it will be appreciated that the present invention may utilize a non-volatile memory which is remote from the system, such as a network storage device which is coupled to the data processing system through a network interface such as a modem or Ethernet interface or wireless networking interface. The bus  may include one or more buses connected to each other through various bridges, controllers and\/or adapters as is well known in the art.","Portions of what was described above may be implemented with logic circuitry such as a dedicated logic circuit or with a microcontroller or other form of processing core that executes program code instructions. Thus processes taught by the discussion above may be performed with program code such as machine-executable instructions that cause a machine that executes these instructions to perform certain functions. In this context, a \u201cmachine\u201d may be a machine that converts intermediate form (or \u201cabstract\u201d) instructions into processor specific instructions (e.g., an abstract execution environment such as a \u201cvirtual machine\u201d (e.g., a Java Virtual Machine), an interpreter, a Common Language Runtime, a high-level language virtual machine, etc.), and\/or, electronic circuitry disposed on a semiconductor chip (e.g., \u201clogic circuitry\u201d implemented with transistors) designed to execute instructions such as a general-purpose processor and\/or a special-purpose processor. Processes taught by the discussion above may also be performed by (in the alternative to a machine or in combination with a machine) electronic circuitry designed to perform the processes (or a portion thereof) without the execution of program code.","An article of manufacture may be used to store program code, for example, including multiple tokens. An article of manufacture that stores program code may be embodied as, but is not limited to, one or more memories (e.g., one or more flash memories, random access memories (static, dynamic or other)), optical disks, CD-ROMs, DVD ROMs, EPROMs, EEPROMs, magnetic or optical cards or other type of machine-readable media suitable for storing electronic instructions. Program code may also be downloaded from a remote computer (e.g., a server) to a requesting computer (e.g., a client) by way of data signals embodied in a propagation medium (e.g., using a communication link (e.g., a network connection)).","The preceding detailed descriptions are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the tools used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here, and generally, conceived to be a self-consistent sequence of operations leading to a desired result. The operations are those requiring physical manipulations of physical quantities. Usually, though not necessarily, these quantities take the form of electrical or magnetic signals capable of being stored, transferred, combined, compared, and otherwise manipulated. It has proven convenient at times, principally for reasons of common usage, to refer to these signals as bits, values, elements, symbols, characters, terms, numbers, or the like.","It should be kept in mind, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussion, it is appreciated that throughout the description, discussions utilizing terms such as \u201cprocessing\u201d or \u201ccomputing\u201d or \u201ccalculating\u201d or \u201cdetermining\u201d or \u201cdisplaying\u201d or \u201ccopying\u201d or \u201ctracking\u201d or \u201csending\u201d or the like, refer to the action and processes of a computer system, or similar electronic computing device, that manipulates and transforms data represented as physical (electronic) quantities within the computer system's registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage, transmission or display devices.","The present invention also relates to an apparatus for performing the operations described herein. This apparatus may be specially constructed for the required purpose, or it may comprise a general-purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium, such as, but is not limited to, any type of disk including floppy disks, optical disks, CD-ROMs, and magnetic-optical disks, read-only memories (ROMs), RAMs, EPROMs, EEPROMs, magnetic or optical cards, or any type of media suitable for storing electronic instructions, and each coupled to a computer system bus.","The processes and displays presented herein are not inherently related to any particular computer or other apparatus. Various general-purpose systems may be used with programs in accordance with the teachings herein, or it may prove convenient to construct a more specialized apparatus to perform the operations described. The required structure for a variety of these systems will be evident from the description below. In addition, the present invention is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the invention as described herein.","The foregoing discussion merely describes some exemplary embodiments of the present invention. One skilled in the art will readily recognize from such discussion, the accompanying drawings and the claims that various modifications can be made without departing from the spirit and scope of the invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention is illustrated by way of example and not limitation in the figures of the accompanying drawings, in which like references indicate similar elements and in which:",{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIGS. 14A-14C"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 15"}]},"DETDESC":[{},{}]}
