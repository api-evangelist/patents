---
title: Correlating queries issued by applications with their source lines and analyzing applications for problem determination and where used analysis
abstract: Provided are techniques for invoking with a processor executing on a computer a source code parser to obtain source information that includes a first location of an Application Programming Interface (API) call and parameters of the API call in source code of a client application, where the parameters the API call do not include query text for a query that is to be used to access a database; examining a stack trace to determine a second location of the API call in the stack trace; and deriving the query of the API call and a third location of the query in the source code by identifying the query in the stack trace at the location of the API call in the stack trace.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09020939&OS=09020939&RS=09020939
owner: International Business Machines Corporation
number: 09020939
owner_city: Armonk
owner_country: US
publication_date: 20090630
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","BRIEF SUMMARY","DETAILED DESCRIPTION","Additional Embodiment Details"],"p":["1. Field","Embodiments of the invention relate to correlating queries issued by applications with their source lines and analyzing applications for problem determination and where used analysis.","2. Description of the Related Art","Relational DataBase Management System (RDBMS) software may use a Structured Query Language (SQL) interface. The SQL interface has evolved into a standard language for RDBMS software and has been adopted as such by both the American National Standards Institute (ANSI) and the International Standards Organization (ISO).","An RDBMS uses relational techniques for storing and retrieving data in a relational database. Relational databases are computerized information storage and retrieval systems. Relational databases are organized into tables that consist of rows and columns of data. The rows may be called tuples or records or rows. A database typically has many tables, and each table typically has multiple rows and multiple columns.","Database applications (also referred to herein as \u201cclient applications\u201d) in an enterprise implement business logic and interact with data stored in databases. Up to now, how the database applications interact with the databases remains in the hands of a database application developer responsible for coding the database applications (i.e., to develop database source code). In a more rigorous environment, there are models that describe both the data and the database applications. A logical model may be produced that describes the data as the business sees the data, while a physical model may be produced that describes the data as stored. Further, an application model may be produced that documents the interaction between the database application and either the logical model or the physical model. These models serve to describe how the database application interacts with the data used by the business. Developers tasked with maintaining the database applications rely on these models to understand how the database applications are impacted as the database changes. Database administrators (DBAs) also rely on these models to optimize the database based on how the data is being used. More often than not, such application models are either out of date or incomplete. This makes the task of maintaining database applications difficult.","If a change to a database is required for some database applications, such as altering some of the database objects (e.g., tables and columns) or database schemas or adding new database objects or database schemas within the database, it becomes difficult to determine which database applications are affected and to determine the cost of modifying the database applications to use the changed or new database objects or database schemas. Such roadblocks often lead to database tables that reflect the need to minimize the impact to existing database applications rather than to reflect the needs of the business. Such databases become difficult to maintain and understand as the business needs evolve.","Thus, there is a need for a better way of gathering information about running database applications to make it easier for developers to understand how the database applications make use of the database and the extent of changes to be made to the database applications to use a different database schema.","Today, database application developers and DBAs face numerous pain points when trying to isolate poorly performing queries (e.g., SQL statements) or trying to determine the queries being issued against the database for audit purposes. Finding and making the correlation between the queries and the related JAVA\u00ae source code (of a JAVA\u00ae application, which may also be referred to as a JAVA\u00ae database application) is tedious and time-consuming (JAVA is a trademark of Sun Microsystems in the United States, other countries, or both). Often the way to understand how the database application accesses the database is to gather all the queries issued by the database application. It is especially burdensome when DBAs see problematic queries issued against the database and have to get help to find the database application that issued the problematic queries.","Correlating queries executed on the database to the actual lines of code triggering the queries includes gathering and wading through stack traces from database drivers and different data access components accessed by the database application. The process is repeated every time any problem occurs in the database application. The ability to correlate depends on the underlying components to provide appropriate stack traces and is a continuous burden on developers to add stack traces and keep them correct.","The DBA is also limited in identifying what JAVA\u00ae classes were issuing the queries due to the limited information found in the stack traces. Because the developers choose JAVA Database Connectivity (JDBC\u00ae) or a JDBC\u00ae-based framework, the DBA has limited tools to help the developer know what database applications the queries are coming from (JDBC is a trademark of Sun Microsystems in the United States, other countries, or both).","The correlation gets more complex with three-tier architectures and when frameworks are used. A three tier architecture may be described as further refining a client-server architecture into three separate layers: presentation, business logic, and data storage. The three tier architecture is different from a traditional two tier model in which the business logic and presentation layers are combined into a client layer. Applications using frameworks, such as a HIBERNATE\u00ae framework (which is an Object Relational Mapping (ORM) framework for JAVA\u00ae applications) or a JAVA\u00ae Persistence API (JPA) framework, generate queries on the fly, and it is difficult for the developer to trace back a particular query (or set of queries) to the query language of the framework that generated the query, even when the JAVA\u00ae source code is available (HIBERNATE is a trademark of Red Hat, Inc. Software Foundation in the United States, other countries, or both). When the JAVA\u00ae source code is not available, it is even more difficult. Therefore, if an end user, developer, or DBA complains about a poorly performing query, it may be a large effort to try and locate that query in the originating JAVA\u00ae source code.","In addition, there is no easy way to gain insight into which database objects were referenced by which parts of a JAVA\u00ae application. Team members working on different parts of the database application do not have a way to gain insight into what queries the other parts of the database application would be issuing to the database. Developers do not have information about all the queries issued by a certain JAVA\u00ae class. In addition, on the database side, schemas are continuously changing as part of the database application development process. The inability to gain insight into how much the change would impact the database application makes such changes risky. Developers and DBAs cannot easily work together to understand the impact of such changes. Because of this, the complicated process of determining the impact of a change slows down development, resulting in delays for delivering a final product, or perhaps even resulting in the decision not to make changes because of such delays.","Thus, there is need for understanding the relationship between queries and their source code for both DBAs and developers alike.","Provided are a method, computer program product, and system for invoking with a processor executing on a computer a source code parser to obtain source information that includes a first location of an Application Programming Interface (API) call and parameters of the API call in source code of a client application, where the parameters of the API call do not include query text for a query that is to be used to access a database; examining a stack trace to determine a second location of the API call in the stack trace; and deriving the query of the API call and a third location of the query in the source code by identifying the query in the stack trace at the location of the API call in the stack trace.","Provided are a method, computer program product, and system for setting, with a processor executing on a computer, one or more breakpoints in source code of a client application based on locations of Application Programming Interface (API) calls in the source code; and, while running the client application through a debugger, upon reaching each of the one or more breakpoints, identifying one or more debugger rules associated with a query at a breakpoint; in response to determining that conditions of the one or more debugger rules are satisfied, obtaining a stack trace before the query makes a call to a database; and deriving query text of the query and a location of the query in source code of the client application.","Provided are a method, computer program product, and system for retrieving the correlator results and generating user interface views using the correlator results, wherein the user interface views provide at least one of: a view showing the query in the database and the query in the source code, a view showing database schemas and database objects that the query uses, a view showing queries per class, a view showing the queries used by each database object in the database, a view showing how queries are run, a view for exporting data, and a view showing performance information of execution count and execution time for each of the queries.","In the following description, reference is made to the accompanying drawings which form a part hereof and which illustrate several embodiments of the invention. It is understood that other embodiments may be utilized and structural and operational changes may be made without departing from the scope of the invention.",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 1","b":["100","160","100","110","120","110","160","110","112","114","116","118","114","112","116","112","170","160","114","112"]},"Although the client applications  and server applications  are shown at the same computer , the client applications  may execute at a different computer coupled to computer . In certain embodiments, client applications  are database applications. Each client application  may be said to be implemented from source code in a high level programming language (e.g., the JAVA\u00ae programming language or the C++ programming language).","The development environment  includes a query parser . The query parser  breaks up a query into individual parts (e.g., columns and tables) to gain understanding of database tables and columns referenced by the query.","The repository  that stores data of the client applications  includes one or more databases . The database  also stores correlator results  (generated by the correlator ), analyzer results  (generated by the analyzer ), one or more database schema , source information , one or more stack traces , one or more database objects  (e.g., tables and columns) and debugger rules . A stack trace  may be generated by running a client application  through the debugger  or using another tool that generates the stack trace.","The development environment  includes a correlator  that correlates queries issued by client applications  with their source lines in the source code. The correlator  analyzes the source code to identify source information  (e.g., locations of API calls in the source code that access the database) and stack traces  of execution of the source code to correlate queries issued by the API calls with the location of the API calls in the source code. The source information  includes the API calls and the locations of the API calls in the source code. In certain embodiments, the source information  includes, for each API call, a file name, a line number, the API call, and parameters for the API call. If a parameter is a full query, the source information  also includes the query. If a parameter is a program expression that would result in a query during runtime, the source information  does not have the complete query. The stack trace  may be said to include stack information including the API call, parameters of the API call, and the application call path. An application call path details how the API is called within the client application . For example, if within a client application , function A calls function B, which then calls the API, the stack trace  includes information about function A, function B, and the API call.","The development environment  also includes a debugger . The debugger  uses the source information  to generate breakpoints in the source code and uses debugger rules  to determine at what point after a breakpoint to take a copy of the stack trace  while running the client application . A stack trace may be described as a collection of information that indicates where an invocation of an API call originates in the source code.","The development environment includes an analyzer . The analyzer  analyzes the client application  for problem determination and where used analysis (\u201cwhere used\u201d analysis may be described as referring to a process that determines where a database table or database column is being used in the client applications ).","The repository  may comprise an array of storage devices, such as Direct Access Storage Devices (DASDs), Just a Bunch of Disks (JBOD), Redundant Array of Independent Disks (RAID), virtualization device, etc.","Embodiments analyze how queries access database objects  and deduce the relationship between the database objects  and source code, thus providing insight into how different client applications make use of the database objects.","There are different ways to gain insight into a running client application . In certain embodiments, the client application  is written using database access API calls, and no changes are made to the existing client application  to work with the correlator  and the debugger . That is, embodiments describe techniques for handling existing client applications  without changing the source code of the client applications  (e.g., without adding new API calls to the source code). Certain embodiments of the correlator  and debugger  focus on client applications  that use the JAVA\u00ae programming language, but embodiments apply to any programming language (including procedural programming languages).","Merely to enhance understanding, an example will be provided to show how the correlator  generates correlator results . Some development environments have built-in parsers for the source code.","For example, the source code parser  in the development environment  outputs a searchable index  identifying where API calls to the database  are used in the source code. The correlator  constructs a query to find the locations in the source code where the API calls to the database  are used. For JDBC\u00ae applications, the correlator  looks for the API calls listed in Set A in the searchable index  (and these API calls may also be referred to as methods):","Set A\n\n","The API calls listed in Set A are the calls a JAVA\u00ae application may make to issue queries against the database . In certain embodiments, by locating the source code location where the API calls are made and by examining the source lines, the correlator  is able to determine the query calls made by the client application  to the database . For example, the correlator  might find the following source code, Code A:","Code A\n\n","The correlator  may use a search function to locate Code A using the searchable index  as something to do with the call to java.sql.Connection::prepareStatement. With this information, the correlator  jumps directly to the line in the source code at which the API call is made, and the correlator  invokes the source code parser  to parse Code A to obtain Query A issued by the client application  at this line:","Query A\n\n","Query A selects data from the FIRSTNME and LASTNAME columns from an EMPLOYEE table. The correlator  has Query A issued by the client application  and the source information  identifying the location in the source code of the API call for Query A. In some embodiments, the correlator  is then able to identify that Query A is called from the location in the source code of the API call. The correlator  stores correlator results  in the repository . The correlator results include the query, tables and columns used in the query, and the location in the source code where the query is used. In certain embodiments, the correlator  invokes the query parser  to parse the query and to determine the tables and columns used in the query. That is, the correlator  may also invoke the query parser  to parse the query so as to understand the database objects  used by the query. For Query A, the query parser  informs the correlator  that Query A uses columns FIRSTNME and LASTNAME from the table EMPLOYEE. The correlator  then stores the source code location, including line number, the query, and that the query makes use of the FIRSTNME and LASTNAME columns into the repository  for further analysis.","In such cases, whenever there is a change request for the EMPLOYEE table, the FIRSTNME column or the LASTNAME column, the repository  may be queried to gather dependency information for the client application  that makes use of the FIRSTNME and LASTNAME columns or the table EMPLOYEE. The dependency information for a query identifies tables and columns used by the query. For the query to run properly, a particular table and columns may be referenced, and so the query is said to be dependent on the particular table and columns that the query references. The dependency information from the repository  may be used to direct developers to the source code line that issues the query. The developer may then accurately assess the impact of the proposed change to the client application .","Sometimes, the source code at the location of the API call may not have enough information to enable the correlator  to derive the query used. For example, the following is Source Line A:","Source Line A\n\n","With Source Line A, the query statement is not available until the client application  is run and the functions getColumns( ) and getTable( ) are called to complete the query statement. The correlator  cannot just use the source information  to identify the query. Therefore, an alternative is used to capture the query used by the client application  when the client application  runs (i.e., executes). The correlator  knows that the \u201cexecuteQuery\u201d API call is located at line  of the source code (from the source information ). In certain embodiments, by installing a wrapper around the JDBC\u00ae connection used to issue the query, correlator  may capture a snapshot of the stack trace as the client application  issues a call to the database . For example, the correlator  captures Stack Trace A shown in the form of an Extensible Markup Language (XML) fragment:",{"@attributes":{"id":"p-0056","num":"0065"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Stack Trace A"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<prepareSql>SELECT DEPTNO, DEPTNAME, MGRNO, ADMRDEPT,"},{"entry":"LOCATION FROM DEPARTMENT<\/prepareSql>"},{"entry":"\u2002<traceInfo>"},{"entry":"\u2003<traceEntry classFile=\u201cStatementProxyHandler\u201d"},{"entry":"\u2003\u2003containingPkg=\u201ccom.ibm.pdq.runtime.internal.wrappers.db2\u201d"},{"entry":"\u2003\u2003fileName=\u201cUnknown Source\u201d isNative=\u201cfalse\u201d lineNo=\u201c\u201d"},{"entry":"\u2003\u2003\u2003\u2003method=\u201cexecuteQuery\u201d\/>"},{"entry":"\u2003<traceEntry classFile=\u201cDepartmentJDBCSample\u201d"},{"entry":"\u2003containingPkg=\u201cdatabase\u201d"},{"entry":"\u2003fileName=\u201cDepartmentJDBCSample.java\u201d isNative=\u201cfalse\u201d"},{"entry":"\u2003lineNo=\u201c85\u201d"},{"entry":"\u2003\u2003\u2003\u2003method=\u201crun2\u201d\/>"},{"entry":"\u2002<traceEntry classFile=\u201cDepartmentJDBCSample\u201d"},{"entry":"\u2003containingPkg=\u201cdatabase\u201d fileName=\u201cDepartmentJDBCSample.java\u201d"},{"entry":"\u2003\u2003\u2003\u2003isNative=\u201cfalse\u201d lineNo=\u201c19\u201d method=\u201cmain\u201d\/>"},{"entry":"<\/traceInfo>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Stack Trace A describes an API that has a parameter of a query statement identified by the prepareSQL XML element. Stack Trace A furthers identifies the API call originating at line  within the DepartmentJDBCSample source file, calling line  within the same DepartmentJDBCSamplejava file, and finally ending within an unknown file making a call to executeQuery.","After the correlator  has used source code parser  that parses the client application  that includes Source Line A at line  within source file DepartmentJDBCSamplejava, the correlator  searches through the stack traces  stored in the repository  for matches to line  of file DepartmentJDBCSamplejava. Upon finding the entry within Stack Trace A, the correlator  associates the query \u201cSELECT DEPTNO, DEPTNAME, MGRNO, ADMRDEPT, LOCATION FROM DEPARTMENT\u201d with the API call at line . By combining information gathered from source code parser  and the stack trace , the correlator  is able to derive the query statement issued by Source line A.","Thus, within the stack trace , the correlator  may derive that the query issued by the API call goes through the path of source line  to source line  and ends up at a class called StatementProxyHandler when the client application  finally issues the \u201cexecuteQuery\u201d API call. The correlator  further processes the query and the stack trace to generate the dependency information after the query has been captured. This dependency information is stored in the repository  as correlator results . Then, a developer (or other user) may retrieve the correlator results  to understand how the DEPARTMENT table is being used by the client application .","The above Stack Trace A also illustrates a need to further narrow the stack trace  to eliminate information unrelated to the client application developer, such as internal classes used by other vendors that the client application developer has no access to. For example, it may be seen from the class package \u201ccom.ibm.pdq.runtime.internal.wrappers.db2\u201d that the client application query does not originate from this class. Embodiments introduce a mechanism of filtering to remove noise from the stack trace . By comparing the package names with some known package names that may be filtered, the correlator  may reduce the noise in the stack trace. For example, by registering to the correlator  that package names starting with com.ibm are to be removed, the correlator  may reduce the stack trace to Stack Trace B:",{"@attributes":{"id":"p-0061","num":"0070"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Stack Trace B"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<traceInfo>"},{"entry":"\u2002<traceEntry classFile=\u201cDepartmentJDBCSample\u201d"},{"entry":"\u2003\u2003containingPkg=\u201cdatabase\u201d"},{"entry":"\u2003\u2003fileName=\u201cDepartmentJDBCSample.java\u201d isNative=\u201cfalse\u201d"},{"entry":"\u2003\u2003lineNo=\u201c85\u201d"},{"entry":"\u2003\u2003\u2003\u2003method=\u201crun2\u201d\/>"},{"entry":"\u2002<traceEntry classFile=\u201cDepartmentJDBCSample\u201d"},{"entry":"\u2003\u2003containingPkg=\u201cdatabase\u201d fileName=\u201cDepartmentJDBCSample.java\u201d"},{"entry":"\u2003\u2003\u2003\u2003isNative=\u201cfalse\u201d lineNo=\u201c19\u201d method=\u201cmain\u201d\/>"},{"entry":"<\/traceInfo>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"In certain embodiments, while the correlator  is able to remove some (e.g., well-known) packages from the stack trace, there are still stack traces within the client application  that cannot be reduced further since they all share the same package. In certain embodiments, drilling deeper into removing classes may not help with intra-class calls.","Since the API call comes from the client application , the stack trace contains entries from within the client application . By looking at the stack trace information along with the API locations from the source code parser  output, embodiments extract from the stack trace the location in the source code where the query calls takes place, eliminating all the other entries that are unrelated to the application. Thus, by intersecting the source information  and the stack trace information, the correlator  pinpoints the location in the source code where the query call takes place. The intersection between the stack trace information and the source information  provides the locations of the query calls.","In certain embodiments, the correlator  does not just examine the class names with use of the stack trace to find the location because, at least for JAVA\u00ae calls, java.sql.Connection is an interface name, and the stack trace contains information about the class that implements the interface without providing the interface name. For example, the following is Stack Trace C:",{"@attributes":{"id":"p-0065","num":"0074"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Stack Trace C"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"traceEntry classFile=\u201cStatementProxyHandler\u201d"]},{"entry":[{},"\u2003\u2003containingPkg=\u201ccom.ibm.pdq.runtime.internal.wrappers.db2\u201d"]},{"entry":[{},"\u2003\u2003fileName=\u201cUnknown Source\u201d isNative=\u201cfalse\u201d lineNo=\u201c\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003method=\u201cexecuteQuery\u201d\/>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In Stack Trace C, the target of the executeQuery API call is a class called StatementProxyHandler, not java.sql.Connection. Without the interface name in the stack trace , it is not possible to identify java.sql.Connection from the stack trace . By intersecting the source information  with the stack trace information, the correlator  reveals the JAVA\u00ae interface of the target (StatementProxyHandler).",{"@attributes":{"id":"p-0067","num":"0076"},"figref":"FIG. 2","b":["130","180","182","112","170","200","130","114","180","112","170","112","170","170","114","112","170","130","112","170"]},"In block , the correlator  stores source information  in the repository . In certain alternative embodiments, the source code parser  may store the source information .","In block , the correlator  examines the stack trace  to identify locations of the API calls in the stack trace. The correlator  has the locations of the API calls in the source information . Then, the correlator  examines the stack trace  whenever a call to the database  happens. Then, by examining the stack trace  of the client application  during the API call, the correlator  determines information about the path the client application  has taken to issue the API call. Information about the path the client application  takes to the database provides a pointer to a location in the client application  at which the API call is made and where changes may be made to use a different database schema  or database objects.","In block , the correlator  derives query text of the queries (e.g., SQL statement text, such as a SELECT statement) issued by the API calls and the locations of the queries in the source code by identifying the queries in the stack trace at the locations of the API calls in the stack trace. In particular, the correlator  uses an intersection of the locations of the API calls and paths from stack trace that identify locations of API calls to identify the queries. In block , the correlator  invokes the query parser  to parse the queries to identify database objects. In block , the correlator  stores correlator results  in the repository . In certain embodiments, for each API call, the correlator results  identify the source file of the client application , source code location (i.e., line number) where the API call occurs in the source code, and parameters of the API call, where one of the parameters is the query text. The correlator results  may also include the database objects  which the query makes use of. In block , analysis may be performed on the correlator results  by, for example, the analyzer . In certain embodiments, the analysis of block  includes retrieving the correlator results  and providing user interface views to allow analysis of the correlator results .","In certain embodiments, the correlator  generates correlator results  by running the client application  through the debugger . When the client application  is run in the debugger , the debugger  retrieves the stack trace information for each API call. The debugger examines the stack trace  prior to the API call to the database  to gather information about the client applications  for further analysis. The information gathered includes the call stack, parameters used in the API call, and the source file and line number of the API call.","With the debugger , source code stack information is revealed on every API call. The debugger  sets breakpoints in the source code based on the source information  to stop on every API call to the database  to take the stack trace information. The debugger  gathers correlator results  (i.e., information) similar to the information generated by intersecting the source information and the stack trace information.","Consider the API call in Source Line A (which is repeated here for ease of reference):","Source Line A\n\n","When the debugger  stops at a breakpoint corresponding to the API call in Source Line A, the stack trace  does not reveal enough information about the actual query being issued because the construction of the query has not begun yet. In this example, multiple function calls (e.g., getColumns( ), getTable( ), and the concatenation of the strings) have to happen before the API call to executeQuery is made. With embodiments, the debugger  does those calls and stops right before the call to executeQuery and then generates a stack trace (i.e., takes a snapshot of the stack).","Embodiments introduce a rule based debugger guidance system to guide the debugger  to perform the calls, stop before the call to executeQuery, and take the snapshot. Since a developer knows what the stack should look like when the API call takes place, the developer may establish the debugger rules  for the debugger . The debugger  uses the debugger rules  to identify when to stop when conditions in the debugger rules  are met. In certain embodiments, many API calls to database  are standardized, and the debugger rules  for the API calls may be pre-programmed into the debugger , saving developers the need to define the debugger rules .","In certain embodiments, different types of API calls are associated with different sets of rules. An infrastructure is set up by the debugger  to decide which set of rules (or sets of rules) to follow depending on the type of API call in the breakpoint. This allows the debugger  to traverse any kind of API call and stop at the desirable location through matching of the stack frame instead of relying on source line numbers.","For example, to find the call before the executeQuery API call, it is known:\n\n","By setting these rules, the developer can direct the debugger  to step into and return to the breakpoint until the rules are satisfied. When the rules are satisfied, the debugger  knows it is stopping right before the actual call to executeQuery is to take place and may record the stack information.","Examples of debugger rules  are provided merely to enhance understanding of the embodiments. The following is example Debugger Rule 1:","Debugger Rule 1\n\n","The correlator  finds that the Debugger Rule 1 rule is met if the debugger  is about to execute the query statement listed in Code A:","Code A\n\n","The following is example Debugger Rule 2:","Debugger Rule 2\n\n","Debugger Rule 2 may be used for Source Line A:","Source Line A\n\n","For Source Line A, the correlator  guides the debugger  to pause, step through the code to call getColumns( ) and getTable( ) (since at that point the parameter type is not java.lang.String yet) until both the getColumns( ) and getTable( ) functions are called and the result concatenated with the \u201cSELECT\u201d string to form the actual string that matches the java.lang.String type. Then the correlator  pauses to make a copy of the stack trace and retrieves the parameter.","Embodiments also enhance conditional breakpoints. The debugger  may rely on setting the breakpoint based on the source information  (e.g., line numbers). In certain embodiments, the debugger  allows the use of conditional breakpoints that may be attached to the breakpoints that are based on the source information . Some developers (especially developers not familiar with the client application ) find it difficult to determine where to set these breakpoints.","By automatically locating the locations in which breakpoints may be set using the source information  and by attaching rules to these breakpoints, embodiments allow users to set breakpoints based on the query text that they wish to stop at. For example, the following is Query A (which is repeated here for ease of reference):","Query A\n\n","Query B\n\n",{"@attributes":{"id":"p-0093","num":"0116"},"figref":"FIG. 3","b":["130","140","112","170","300","130","180","170","130","180","302","130","112","140","304","130","306","318"]},"In block , the correlator  identifies one or more debugger rules . In block , the correlator  determines whether the conditions of the one or more debugger rules  have been satisfied. If so, processing continues to block , otherwise, processing continues to block . In block , once the one or more debugger rules  are satisfied, the correlator  obtains a stack trace just before a API call to the database . In block , the correlator  derives query text of the query (e.g., SQL statement text, such as a SELECT statement) that is issued against the database  and locations of the query in the source code. In block , the correlator  invokes the query parser  to parse the query to identify database objects. In block , the correlator  stores correlator results  that include information from the stack trace. In certain embodiments, for each API call, the correlator results  identify the source file of the client application , source code location (i.e., line number) where the API call occurs, and parameters, where one of the parameters is the query text. The correlator results  may also include the database objects  which the query makes use of. From block , processing continues to block .","In block , the debugger  continues running the client application  until either a breakpoint is reached, in which case processing continues to block , or the client application  execution is complete.","The correlator results  gathered by the correlator  and debugger  are stored in the repository  and be used later on for monitoring and problem determination.","Thus, embodiments provide the correlator  and the debugger  to associate queries with lines of the source code. Such an association may be used to determine the interaction between the client application  and the underlying database . When the underlying database schema  needs to be changed, a developer may quickly use this information to determine how much each client application  needs to be changed and the extent of the impact.","Using the searchable index , the correlator  may locate places in the client application  where an interaction with the database  takes place. In certain embodiments, by installing a listener on the JDBC\u00ae interaction between the client application  and the database , the correlator  obtains stack information during the query call and determines possible locations within the source code where the API calls take place. By using the searchable index , the correlator  singles out the location from the stack trace where the most relevant source location is for a particular API call.","When running the client application  through the debugger , a developer is able to provide debugger rules  for the debugger  to guide the debugger  through stepping through the source code, providing precise information about the location of the API call and the call parameters.","The correlator  and debugger  contribute to enhancing understanding of the client application  without having to rely on manual techniques of documentation.","In certain embodiments, the correlator results  are stored in a relational form (for ease of query) and are used when a problem occurs. Thus, given a query, embodiments locate the client application  that generates this query by searching the repository .","The correlator  and debugger  work on existing client applications  without requiring any changes to the client applications . Developers may use tools that implement these embodiments for existing client applications . The correlator results  also reflect the current state of the client applications , not any manually written application model or documentation that could be already be outdated by recent undocumented changes. This gives developers accurate knowledge about client applications  and enables developers to be confident in making changes to the source code as business needs evolve and database objects  change.","Embodiments also provide the analyzer  and UI generator . The analyzer  may be applied to any client application  (e.g., a JAVA\u00ae database application, using plain JDBC\u00ae or a framework, hence the benefits are available to the JAVA\u00ae database application developer and DBA community). Certain examples of embodiments of the analyzer  focus on client applications  that use the JAVA\u00ae programming language, but embodiments apply to any programming language (including procedural programming languages).","Embodiments connect the ability to gain insight into the queries in a client application , the source code location of the queries, and the database objects  that are used by the queries. The analyzer  performs a combination of complex analysis to connect this information in a meaningful way that may answer the following Set of Questions:","Set of Questions\n\n","Typically, deep knowledge of JAVA\u00ae client applications and databases is needed to provide such information integrated within a development tool. To make this information available within the development environment, embodiments collect the information before the client application  has gone into production (e.g., at development time), as opposed to dependency on stack traces created after client application  execution.",{"@attributes":{"id":"p-0107","num":"0137"},"figref":"FIG. 4","b":["150","118","400","150","112","112"]},"The analyzer  performs complex analysis using JAVA\u00ae models (which represent the JAVA\u00ae application), query models (which represent the query (e.g., a parse tree), source code parser , query parser , database models, XML parsers, Web Services Description Language parsers to scrub information from artifacts such as JAVA\u00ae client applications, web services, and routines (e.g., procedures and User Defined Functions (UDFs)). Not only is the source code analyzed for any queries that are hardcoded, the source code is also combined with dynamic analysis information collected by running the application to ensure that queries that are constructed at execution time are collected as well.","In certain embodiments, the analyzer  performs complex analysis to combine the results of source information  from static analysis (i.e., without running the client application ) and intersects the source information  with the stack trace  produced by the dynamic analysis to provide further accuracy in the source code location for each query.","In block , the analyzer  identifies database objects  used by the queries. In certain embodiments, each query collected is analyzed with the query model and the query parser  to identify which database objects  the query uses.","In block , the analyzer  stores the collective information as analyzer results  in the repository .","In block , the UI generator  in the development environment  generates user interface views (further described with reference to ) using the analyzer results  to allow analysis of the analyzer results . That is, the UI generator  presents information to a user in UI views to enable the Set of Questions (listed above), as well as other questions, to be answered in a productive, intuitive, and usable way.","In certain alternative embodiments, the analyzer  retrieves the correlator results , and the UI generator  generates user interface views (further described with reference to ) using the correlator results  to allow analysis of the correlator results . Embodiments provide integrated tools (e.g., the correlator , the debugger , the analyzer , and the UI generator ) that provide the analyzer results  within the development environment  to further reduce the gap while developing queries in the JAVA\u00ae application within the JAVA\u00ae development environment  reduce gap while developing queries in the JAVA\u00ae programming language within the JAVA\u00ae environment.","The integrated tools add value not only to developers who gain insight into the database objects  used by the queries, but also to DBAs and other roles outside of development, to gain knowledge about where the queries (which are potentially performing badly as reported by database performance tools) are located in the source code. Embodiments provide advanced integration between the queries and the JAVA\u00ae application that will benefit problem determination of poorly performing queries.","Embodiments focus on the use of various techniques (i.e., static analysis, source code indexing (creating the searchable index ), dynamic analysis, and instrumentation), sometimes in combination, to assist developers in problem determination and where used analysis, leading to higher productivity for developers.","Static analysis allows developers to understand source code without having to run the client application. For example, with dataflow analysis, developers may understand the relationship between variable declarations and usages. The developers may also make guesses to expressions that could be generated by drilling deeper on how the expressions may be formed. Such static analysis helps examine client applications.","As to source code indexing, it is customary to index source code to make it easy for developers to find their way around large number of source files. For instance, the source code parser  enables developers to find JAVA\u00ae classes and API calls within their workspace. Workspace may be described as a place where client applications  are located in the development environment . These types of analysis may be used to locate queries in client applications .","As to dynamic analysis, such as the JAVA\u00ae programming language, it is possible to perform introspection of the client application  while the client application  is running. Introspection may be described as obtaining the stack trace  from the client application  as the client application  is running. There are also tools, such as debugging API tools (e.g., debugger ), which help developers debug at the source level.","Traditional instrumentation often requires changes to the source code. The JAVA\u00ae programming language has made it easier to do byte code instrumentation. Byte code instrumentation is a technique that allows modifying the client application  while the client application  is running, without requiring changes to the source code. This, for example, allows pure JAVA\u00ae profilers to profile source code by dynamically inserting calls to the profiler on routines during application loads. A profiler may be described as allowing tuning to obtain performance data from the client application .","To answer the first question in the Set of Questions (\u201cWhere are the one or more queries located in the source code?\u201d), the analyzer  employs multiple strategies to extract the queries within the client application  since no single technique works best for the different ways in which the client application  may make use of the queries. The first strategy is to employ static analysis. Given a language, such as the JAVA\u00ae programming language, the analyzer  leverages the JAVA\u00ae model to shallow parse the source code to build up a list of API calls. A shallow parse may be described as a process for extracting enough information from the source code to obtain the API call and the parameters of the API call (without trying to understand the relationship between variables, call chains, etc., in this stage). In certain embodiments, the analyzer  invokes the source code parser  to do this. Whether the client application  is a JDBC\u00ae application or is using frameworks, such as JPA or Hibernate, there are standard API calls (e.g., the API calls in Set A above) that the client application  will use to issue queries. Using source code indexing, the analyzer  searches amongst the source code for the standard API calls. For example, the analyzer  searches for the locations where a prepareStatement call is made on a Connection. Once the source location that issues one of these interfaces is located, the analyzer  uses static analysis to analyze the source code. For example, the following is a JAVA\u00ae Code Fragment:","JAVA\u00ae Code Fragment\n\n","Given the JAVA\u00ae Code Fragment located using this static analysis, the analyzer  extracts (e.g., by invoking the source code parser ) the query text directly from the argument list of the JAVA\u00ae Code Fragment. Deeper analysis may be performed for more complex expressions. For example, the following is Statement A:","Statement A\n\n","For statement A, the analyzer  performs data flow analysis to correlate the query to the string defined in a statement before. In come cases, static analysis may work for more complex expressions such as Statement B:","Statement B\n\n","Sometimes the query is not determined by static analysis alone. For example, queries that are read from files or constructed dynamically through complex logic may be easier to intercept at run time. In such cases, dynamic analysis instrumentation may be used. For example, the analyzer  intercepts the query through multiple means:\n\n","In certain embodiments, dynamic analysis does not change source code for the analysis.","With both static and dynamic analysis, embodiments gain insight into the relationship between the source code and the query. Embodiments compose a user interface (UI, also referred to as a Graphical User Interface (GUI)) linking the query with the source code, if the source code is available. The information is precise enough to link to the source file and the correct line number at which the query is located. For example, double-clicking or using menus from each query point takes the user to the line of source code. If the source code is not available, dynamic analysis results pointed to the .class file information. When using frameworks that use object query languages in the client application , but that depend on the framework to create the query at execution time, the line of source code triggering the generation of the query is shown. For example, in a JPA case, the query generated by the commit API call points back to the commit( ) in the source code.",{"@attributes":{"id":"p-0129","num":"0167"},"figref":["FIG. 5","FIG. 5","FIGS. 5A","FIG. 5","FIG. 5C"],"b":["500","5","5","5","500","510","520"]},"Embodiments allow JAVA\u00ae Persistence API Language queries (JPAQL) (i.e., an object query language for the framework JAVA\u00ae Persistence API) in source code. JPAQL is a type of query. Queries to the database  are supported whether they are in object query language (e.g., JPAQL) or standard query language (e.g., SQL).","The static and dynamic analysis techniques work on any type of client applications , including iBATIS\/Spring types of frameworks that contain a well defined interface in which queries are issued to the database . By creating relationships between the client application source and the resulting queries, embodiments show developers how their client applications  affect the database . This is educational for users of ORM frameworks, such as JPA or Hibernate, because the framework hides the query from the developers.","During problem determination, when presented with queries from DBAs, application developers sometimes go back to the client application  to locate which line causes the problem. Embodiments provide a mapping between the query and the source code that makes the problem determination task simpler.","Beyond mapping the source code and the queries, the captured queries are also used to show the relationship between web services and queries in a web environment. In certain embodiments, capture is done in two places: 1) at the entry point of the web service and 2) at the site in which queries are issued. Using instrumentation, embodiments instrument a web services call to retrieve the URL and the resulting query generated, providing a view between web services and the database actions.","To answer the second question in the Set of Questions (\u201cWhat are the one or more queries issued by a certain JAVA\u00ae class?\u201d), further analysis is performed on the information gathered with source code indexing. With information gathered by both static and dynamic analysis, embodiments further break down the information into queries used per JAVA\u00ae class. This information is available with or without source code availability when using frameworks or JDBC\u00ae.",{"@attributes":{"id":"p-0135","num":"0173"},"figref":["FIG. 6","FIG. 6"],"b":["600","600","610","620","630"]},{"@attributes":{"id":"p-0136","num":"0174"},"figref":"FIG. 7","b":["700","700","710","720","730"]},"To answer the third question in the Set of Questions (\u201cFor each query, what are the database schema  and database objects  (e.g., tables and columns) that the query uses?\u201d), embodiments perform dependency analysis to enable users to understand how the database schema  is used by the source code. To facilitate the understanding of how each query is used, embodiments parse each query with the appropriate query parser  for the individual databases . Embodiments provide the result through the user interface.",{"@attributes":{"id":"p-0138","num":"0176"},"figref":"FIG. 8","b":["800","176","186","800","810"]},"To answer the fourth question in the Set of Questions (\u201cFor each database schema  or table used by the client application , what are the one or more queries issued by the client application ?\u201d), embodiments use dependency analysis with dynamic analysis to present the user with a view based on how the database schema  is accessed regardless of the client application . By gathering up the dependency information of the queries that access an individual table or column, embodiments build up a view of how database objects  are used. Developers may use this view to predict the amount of changes for an upcoming database change.  illustrates a user interface view  showing queries used by each database object  in accordance with certain embodiments. In the user interface view , the database tab  has been selected by a user.","To answer the fifth question in the Set of Questions (\u201cDoes the query execute producing the results as expected?\u201d), embodiments provide tools as part of the UI generator  or analyzer  that allow execution of queries. Queries with any parameters may be executed by providing the values in the user interface. The user may select rollback or commit for each sample run. The user may filter out query columns to view to select a maximum number of rows to be retrieved. Embodiments remember parameter values across query executions. Embodiments show results in query execution views. Providing this extensive functionality is useful, especially in the case of frameworks where there is no visibility to the queries from the source code.  illustrates a user interface view  showing how queries may be run with a \u201cRun query menu\u201d in accordance with certain embodiments.  is illustrated with , B, C, and D. In user interface view , a \u201cRun SQL\u201d menu  (FIG. D)has been selected by a user, parameters are provided by the user through a \u201cSpecify Host Variable Values\u201d box , and data output  () is shown.","To answer the sixth question in the Set of Questions (\u201cHow does the query perform?), embodiments run query tuning tools for each query to allow the user to view the performance of the query and to enable the user to make changes proactively at design time, thus avoiding issues in production. With query tuning tools for each database vendor, embodiments provide seamless integration.  illustrates a user interface view  showing the performance of a query with a \u201cLaunch Visual Explain\u201d menu in accordance with certain embodiments.  is illustrated with , B, C, and D. In user interface view , a \u201cLaunch Visual Explain\u201d menu  has been selected by a user.","To answer the seventh question (\u201cWhat are the one or more queries issued by the client application ?\u201d), embodiments have knowledge in JAVA\u00ae data models and JAVA\u00ae database applications to scrub the queries from the client applications  based on JDBC or any proprietary framework. Embodiments perform analysis to get a full list of the queries and save to metadata, which is shown in  (e.g., \u201cExport SQL to File . . . \u201d menu).  is illustrated with , B, C, and D.","Embodiments have visibility into queries in the client application  and export the queries into a query file. Exporting allows sharing the queries with other members (such as a DBA who may then optimize the queries proactively), which enables developing higher quality client applications , especially when using frameworks in which client applications  do not provide insight into the queries in the source code but generate the queries at runtime. Thus, embodiments help problem determination and where used analysis.  illustrates a user interface view  for exporting data in accordance with certain embodiments.","In terms of performance analysis, embodiments provide user interface views that display the queries in the client application , and embodiments present developers with performance data in the context of the client application . Some database performance monitor applications gather queries and their performance data, but have no way to trace the queries back to the client application . By gathering the metadata about the client application , including the queries the client application  issued and the relationship of the queries back to the client application , embodiments join the information with the performance data gathered by a database monitoring application to provide user interface view .  provides a user interface view  with performance information in accordance with certain embodiments.  is illustrated with , B, C, and D. The user interface view  includes, for each query, an execution count  () and an execution time  ().","Thus, instead of providing just a set of queries and their performance data, embodiments show the performance data in the context of the client application . At a glance, the developer may locate queries that are most expensive to run and where they are in the client application . If refactoring of the tables is required, the developer may assess the impact by switching to the user interface view to see how many queries access the table.","Thus, embodiments provide integrated tools to solve industry pain points and to provide unique value towards improving productivity for numerous roles involved in client application development such as developer, DBA, support personnel etc.","As will be appreciated by one skilled in the art, aspects of the present invention may be embodied as a system, method or computer program product. Accordingly, aspects of the present invention may take the form of an entirely hardware embodiment, an entirely software embodiment (including firmware, resident software, micro-code, etc.) or an embodiment combining software and hardware aspects that may all generally be referred to herein as a \u201ccircuit,\u201d \u201cmodule\u201d or \u201csystem.\u201d Furthermore, aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium(s) having computer readable program code embodied thereon.","Any combination of one or more computer readable medium(s) may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be, for example, but not limited to, an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system, apparatus, or device, or any suitable combination of the foregoing. More specific examples (a non-exhaustive list) of the computer readable storage medium would include the following: an electrical connection having one or more wires, a portable computer diskette, a hard disk, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM or Flash memory), an optical fiber, a portable compact disc read-only memory (CD-ROM), an optical storage device, a magnetic storage device, or any suitable combination of the foregoing. In the context of this document, a computer readable storage medium may be any tangible medium that may contain, or store a program for use by or in connection with an instruction execution system, apparatus, or device.","A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein, for example, in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms, including, but not limited to, electromagnetic, optical, or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that may communicate, propagate, or transport a program for use by or in connection with an instruction execution system, apparatus, or device.","Program code embodied on a computer readable medium may be transmitted using any appropriate medium, including but not limited to wireless, wireline, optical fiber cable, RF, etc., or any suitable combination of the foregoing.","Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages, including an object oriented programming language such as JAVA\u00ae, Smalltalk, C++ or the like and conventional procedural programming languages, such as the \u201cC\u201d programming language or similar programming languages. The program code may execute entirely on the user's computer, partly on the user's computer, as a stand-alone software package, partly on the user's computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario, the remote computer may be connected to the user's computer through any type of network, including a local area network (LAN) or a wide area network (WAN), or the connection may be made to an external computer (for example, through the Internet using an Internet Service Provider).","Aspects of the present invention are described below with reference to flowchart illustrations and\/or block diagrams of methods, apparatus (systems) and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and\/or block diagrams, and combinations of blocks in the flowchart illustrations and\/or block diagrams, may be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer, special purpose computer, or other programmable data processing apparatus to produce a machine, such that the instructions, which execute via the processor of the computer or other programmable data processing apparatus, create means for implementing the functions\/acts specified in the flowchart and\/or block diagram block or blocks.","These computer program instructions may also be stored in a computer readable medium that may direct a computer, other programmable data processing apparatus, or other devices to function in a particular manner, such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function\/act specified in the flowchart and\/or block diagram block or blocks.","The computer program instructions may also be loaded onto a computer, other programmable data processing apparatus, or other devices to cause a series of operational steps to be performed on the computer, other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions\/acts specified in the flowchart and\/or block diagram block or blocks.","The code implementing the described operations may further be implemented in hardware logic or circuitry (e.g., an integrated circuit chip, Programmable Gate Array (PGA), Application Specific Integrated Circuit (ASIC), etc.",{"@attributes":{"id":"p-0156","num":"0194"},"figref":"FIG. 14","b":["1400","100","1400","1400","1402","1404","1420","1404","1404","1405","1406"]},"Input\/Output (I\/O) devices ,  (including but not limited to keyboards, displays, pointing devices, etc.) may be coupled to the system either directly or through intervening I\/O controllers .","Network adapters  may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems, cable modem and Ethernet cards are just a few of the currently available types of network adapters .","The system architecture  may be coupled to storage  (e.g., a non-volatile storage area, such as magnetic disk drives, optical disk drives, a tape drive, etc.). The storage  may comprise an internal storage device or an attached or network accessible storage. Computer programs  in storage  may be loaded into the memory elements  and executed by a processor  in a manner known in the art.","The system architecture  may include fewer components than illustrated, additional components not illustrated herein, or some combination of the components illustrated and additional components. The system architecture  may comprise any computing device known in the art, such as a mainframe, server, personal computer, workstation, laptop, handheld computer, telephony device, network appliance, virtualization device, storage controller, etc.","The flowchart and block diagrams in the figures illustrate the architecture, functionality, and operation of possible implementations of systems, methods and computer program products according to various embodiments of the present invention. In this regard, each block in the flowchart or block diagrams may represent a module, segment, or portion of code, which comprises one or more executable instructions for implementing the specified logical function(s). It should also be noted that, in some alternative implementations, the functions noted in the block may occur out of the order noted in the figures. For example, two blocks shown in succession may, in fact, be executed substantially concurrently, or the blocks may sometimes be executed in the reverse order, depending upon the functionality involved. It will also be noted that each block of the block diagrams and\/or flowchart illustration, and combinations of blocks in the block diagrams and\/or flowchart illustration, may be implemented by special purpose hardware-based systems that perform the specified functions or acts, or combinations of special purpose hardware and computer instructions.","The foregoing description of embodiments of the invention has been presented for the purposes of illustration and description. It is not intended to be exhaustive or to limit the embodiments to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. It is intended that the scope of the embodiments be limited not by this detailed description, but rather by the claims appended hereto. The above specification, examples and data provide a complete description of the manufacture and use of the composition of the embodiments. Since many embodiments may be made without departing from the spirit and scope of the embodiments, the embodiments reside in the claims hereinafter appended or any subsequently-filed claims, and their equivalents."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 5","FIG. 5","FIGS. 5A"],"b":["5","5","5"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 10","FIG. 10","FIGS. 10A"],"b":["10","10","10"]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 11","FIG. 11","FIGS. 11A"],"b":["11","11","11"]},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 12","FIG. 12","FIGS. 12A"],"b":["12","12","12"]},{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 13","FIG. 13","FIGS. 13A"],"b":["13","13","13"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 14"}]},"DETDESC":[{},{}]}
