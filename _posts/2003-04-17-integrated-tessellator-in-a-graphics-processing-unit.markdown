---
title: Integrated tessellator in a graphics processing unit
abstract: An integrated graphics pipeline system is provided for graphics processing. Such system includes a tessellation module that is positioned on a single semiconductor platform for receiving data for tessellation purposes. Tessellation refers to the process of decomposing either a complex surface such as a sphere or surface patch into simpler primitives such as triangles or quadrilaterals, or a triangle into multiple smaller triangles. Also included on the single semiconductor platform is a transform module adapted to transform the tessellated data from a first space to a second space. Coupled to the transform module is a lighting module which is positioned on the single semiconductor platform for performing lighting operations on the data received from the transform module. Also included is a rasterizer coupled to the lighting module and positioned on the single semiconductor platform for rendering the data received from the lighting module.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06906716&OS=06906716&RS=06906716
owner: NVIDIA Corporation
number: 06906716
owner_city: Santa Clara
owner_country: US
publication_date: 20030417
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","DISCLOSURE OF THE INVENTION","DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["The present application is a continuation application of application entitled \u201cIntegrated Tessellator in a Graphics Processing Unit\u201d which was filed Nov. 21, 2000 under Ser. No. 09\/718,890 now U.S. Pat. No. 6,597,356, which is a continuation-in-part of applications entitled \u201cSystem, Method and Article of Manufacture for Decomposing Surfaces using Guard Curves and Reversed Stitching\u201d which was filed Aug. 31, 2000 under Ser. No. 09\/652,866 now U.S. Pat. No. 6,624,811; \u201cSystem, Method and Article of Manufacture for Fractional Tessellation during Graphics Processing\u201d which was filed Sep. 5, 2000 under Ser. No. 09\/655,103 now U.S. Pat. No. 6,504,537; and \u201cSystem, Method and Article of Manufacture for Rendering Triangular Patches using Hardware Equipped for Handling Quadrilateral Patches\u201d which was filed Sep. 5, 2000 under Ser. No. 09\/655,105 now U.S. Pat. No. 6,704,010, and which are all incorporated herein by reference in their entirety. The present application is further related to an application entitled \u201cA Transform, Lighting and Rasterization System Embodied on a Single Semiconductor Platform\u201d which was filed Dec. 6, 1999 under Ser. No. 09\/454,516; and which is incorporated herein by reference in its entirety.","The present invention relates generally to graphics processors and, more particularly, to graphics pipeline systems including tessellation, transform, lighting and rasterization modules.","Three dimensional graphics are central to many applications. For example, computer aided design (CAD) has spurred growth in many industries where computer terminals, cursors, CRT's and graphics terminals are replacing pencil and paper, and computer disks and tapes are replacing drawing vaults. Most, if not all, of these industries have a great need to manipulate and display three-dimensional objects. This has lead to widespread interest and research into methods of modeling, rendering, and displaying three-dimensional objects on a computer screen or other display device. The amount of computations needed to realistically render and display a three-dimensional graphical object, however, remains quite large and true realistic display of three-dimensional objects have largely been limited to high end systems. There is, however, an ever-increasing need for inexpensive systems that can quickly and realistically render and display three dimensional objects.","One industry that has seen a tremendous amount of growth in the last few years is the computer game industry. The current generation of computer games is moving to three-dimensional graphics in an ever increasing fashion. At the same time, the speed of play is being driven faster and faster. This combination has fueled a genuine need for the rapid rendering of three-dimensional graphics in relatively inexpensive systems. In addition to gaming, this need is also fueled by e-commerce applications, which demand increased multimedia capabilities.","Rendering and displaying three-dimensional graphics typically involves many calculations and computations. For example, to render a three dimensional object, a set of coordinate points or vertices that define the object to be rendered must be formed. Vertices can be joined to form polygons that define the surface of the object to be rendered and displayed. Once the vertices that define an object are formed, the vertices must be transformed from an object or model frame of reference to a world frame of reference and finally to two-dimensional coordinates that can be displayed on a flat display device. Along the way, vertices may be rotated, scaled, eliminated or clipped because they fall outside the viewable area, lit by various lighting schemes, colorized, and so forth. Thus the process of rendering and displaying a three-dimensional object can be computationally intensive and may involve a large number of vertices.","A general system that implements such a pipelined system is illustrated in Prior Art FIG. . In this system, a data source  generates a stream of expanded vertices, often interpreted as triangles. The data source may also produce higher level descriptions such as spheres, cylinders, or general curved surfaces. These higher level primitives\/descriptions may be approximated by a plurality of triangles before processing by the remainder of the graphics pipeline.","Initially, the vertices are tessellated by a tessellation module . Tessellation refers to the process of decomposing a complex surface such as a sphere into simpler primitives such as triangles or quadrilaterals. These tessellated vertices are then passed through a pipelined graphic system  via vertex memory . Thereafter, the vertices are transformed and lit by a transformation module  and a lighting module , respectively, and further clipped and set-up for rendering by a rasterizer , thus generating rendered primitives that are displayed on a display device .","During operation, the tessellation module  is adapted to use patches or other higher level descriptions to calculate vertices and form triangles. The transform module  may be used to perform scaling, rotation, and projection of a set of three dimensional vertices from their local or model coordinates to the two dimensional window that will be used to display the rendered object. The lighting module  sets the color and appearance of a vertex based on various lighting schemes, light locations, ambient light levels, materials, and so forth. The rasterization module  rasterizes or renders vertices that have previously been transformed and\/or lit. The rasterization module  renders the object to a rendering target which can be a display device or intermediate hardware or software structure that in turn outputs the rendered data.","When manufacturing graphics processing systems, there is a general need to increase the speed of the various graphics processing components, while minimizing costs. In general, integration is often employed to increase the speed of a system. Integration refers to the incorporation of different processing modules on a single integrated circuit. With such processing modules communicating in a microscopic semiconductor environment, as opposed to external buses, speed is vastly increased.","Such increase in speed can contribute to overcoming many shortcomings in current graphic pipeline implementations. For example, the quality of computer graphics is currently limited by the ability of the graphic pipeline to execute transform operations. In particular, transform performance dictates how finely software developers may tessellate three-dimensional objects created, how many objects are put in a scene, and how sophisticated the three-dimensional world itself can be. This creates a classic performance-versus-quality trade-off for the software developer because finer tessellation will result in more polygons and slower performance, but with the reward of higher quality.","Integration is often limited, however, by a cost of implementing and manufacturing multiple processing modules on a single chip. In the realm of graphics processing, any attempt to integrate the various modules for increased speed would be cost prohibitive. The reason for this increase in cost is that the required integrated circuit would be of a size that is simply too expensive to be feasible.","This size increase is due mainly to the complexity of the various engines. High performance transform and lighting engines alone are very intricate and are thus expensive to implement on-chip, let alone implement with any additional functionality. Further, conventional rasterizers are multifaceted with the tasks of clipping, rendering, etc. making any cost-effective attempt to combine such module with the transform and lighting modules nearly impossible.","There is therefore a need for tessellation, transform, lighting, and rasterization modules having a design that allows cost-effective integration.","An integrated graphics pipeline system is provided for graphics processing. Such system includes a tessellation module that is positioned on a single semiconductor platform for receiving data for tessellation purposes. Tessellation refers to the process of decomposing either a complex surface such as a sphere or surface patch into simpler primitives such as triangles or quadrilaterals, or a triangle into multiple smaller triangles. Further included on the single semiconductor platform is a transform module adapted to transform the tessellated data from a first space to a second space. Coupled to the transform module is a lighting module which is also positioned on the single semiconductor platform for performing lighting operations on the data received from the transform module. Also included is a rasterizer coupled to the lighting module and positioned on the single semiconductor platform for rendering the data received from the lighting module.","With the foregoing integration, improved performance is achieved thus overcoming many of the shortcomings of non-integrated systems. For example, the combined tessellation and transform integration affords improved quality by way of finer tessellations. Applications can thus take advantage of this and other capabilities by invoking the corresponding feature associated with the single semiconductor platform via a standard interface.","These and other advantages of the present invention will become apparent upon reading the following detailed description and studying the various figures of the drawings.",{"@attributes":{"id":"p-0076","num":"0075"},"figref":["FIG. 1","FIG. 1A","FIG. 1A","FIG. 1A"],"b":["51","51","53","51","51","51","59","50","59","52","54","58","55","58","51","57","56","55"]},"In one embodiment, each of the foregoing modules is situated on a single semiconductor platform in a manner that will be described hereinafter in greater detail. In the present description, the single semiconductor platform may refer to a sole unitary semiconductor-based integrated circuit or chip. It should be noted that the term single semiconductor platform may also refer to multi-chip modules with increased connectivity which simulate on-chip operation, and make substantial improvements over utilizing a conventional CPU and bus implementation.","During operation, the tessellation module  is adapted to use patches or any other higher level descriptions, i.e. primitives, etc., to calculate vertices. The vertex cache  may be used to store geometric descriptions such as patch coefficients for use and reuse by the tessellation module . The VAB  is included for gathering and maintaining a plurality of vertex attribute states such as position, normal, colors, texture coordinates, etc.","Attribute settings to be affected by the tessellation module  may be defined by any desired application program interface. The VAB  is the source for those vertex components not provided by the tessellation module . These components may be constant across the tessellated primitive.","When tessellation is commenced, the contents of the VAB  are used to update the I-Buffers  with the current vertex attributes that are not to be provided by the tessellation module . The tessellation module  then writes the remainder of the vertex components into the I-Buffers , which are then read by the transform module . More information regarding the I-Buffers  will be set forth during reference to FIG. .","As such, completed vertices are processed by the transform module  and then sent to the lighting module . The transform module  generates vectors for the lighting module  to light. The output of the lighting module  is stored in the vertex file . The vertex file , in turn, feeds vertices to the primitive assembly module  to form triangles and quads (decomposed into 2 triangles) for use by the set-up module . The set-up module  then conducts calculations for setting up primitives in preparation for rasterization. It should be noted that, in one interpretation, the set-up module  may be construed as handling the duties of the primitive assembly module .","As shown in , the tessellation module  is capable of directing the primitive assembly module  to form triangles. In operation, the tessellation module  is thereby able to optimize vertex reuse, as will be set forth hereinafter in greater detail.","Thereafter, the rasterization module  carries out rasterization of the primitives. It should be noted that the transform and lighting modules  and  might only stall on the command level such that a command is always finished once started. Further information regarding the foregoing components will be set forth hereinafter in greater detail.","With the foregoing integration, improved performance is achieved thus overcoming many of the shortcomings of non-integrated systems. Applications may take advantage of the various hardware features of the present invention by invoking such features via a standard interface.","Such an interface may give developers a single set of APIs (application programming interfaces) that provides such developers With improved access to the features of the hardware set forth herein. This may be accomplished by the use of a hardware abstraction layer that uses software drivers to communicate between application software and the various hardware features set forth in the present description. As a result, developers can write a single version of a product that utilizes the interface without worrying about the specifics of the various hardware features of the present invention.","The interface may further provide developers with tools that take advantage of the various hardware features set forth in the present description. It may automatically determine the hardware capabilities, and set the parameters of the application to match. Still yet, the interface may contain a library of components that developers can draw on to create the underlying elements of an application. This library simplifies the development process by giving programmers a large group of pre-existing interfaces and elements to use in their products.","The components that make up the interface thus provide a flexible platform that is designed to get the most out of advances in technology. An example of such components includes special drivers that can be generated in association with the hardware of the present invention, and which ensure that one gets the most out of the advances set forth herein.","As such, a standardized programming interface is provided for application developers to interface with the various hardware features set forth in the present description. Further, a method is thereby provided to expose the functionality of the hardware to application developers in a standardized way. Such standardized programming interface may provide a more unified and readily supportable way for making applications and hardware work together. One example of an interface with features similar to those set forth hereinabove includes MICROSOFT DIRECTX.","In one embodiment, the present invention includes a hardware implementation that at least partially employs Open Graphics Library (OpenGL\u00ae) and D3D\u2122 transform and lighting pipelines. OpenGL\u00ae is the computer industry's standard application program interface (API) for defining 2-D and 3-D graphic images. With OpenGL\u00ae, an application can create the same effects in any operating system using any OpenGL\u00ae-adhering graphics adapter. OpenGL\u00ae specifies a set of commands or immediately executed functions. Each command directs a drawing action or causes special effects.","The various features associated with the modules shown in  will now be set forth. The specific manner in which the tessellation module  and other related components operate will be set forth later in the present description beginning with reference to Table 19.",{"@attributes":{"id":"p-0091","num":"0090"},"figref":"FIG. 2","b":["50","50","200","204","202","50","204"]},"The VAB  is adapted for receiving and storing a plurality of possible vertex attribute states via the data bits . In use after such data bits , or vertex data, is received and stored in VAB , the vertex data is outputted from VAB  to a graphics-processing module, namely the transform module . Further, the command bits  are passed by VAB  for determining a manner in which the vertex data is inputted to VAB  in addition to other processing which will be described in greater detail with reference to FIG. A. Such command bits  are received from a command bit source such as a microcontroller, CPU, data source or any other type of source which is capable of generating command bits .","Further, mode bits  are passed which are indicative of the status of a plurality of modes of process operations. As such, mode bits  are adapted for determining a manner in which the vertex data is processed in the subsequent graphics-processing modules. Such mode bits  are received from a command bit source such as a microcontroller, CPU, data source or any other type of source which is capable of generating mode bits .","It should be noted that the various functions associated with VAB  may be governed by way of dedicated hardware, software or any other type of logic. In various embodiments, 64, 128, 256 or any other number of mode bits  may be employed.","The VAB  also functions as a gathering point for the 64 bit data that needs to be converted into a 128-bit format. The VAB  input is 64 bits\/cycle and the output is 128 bits\/cycle. In other embodiments, VAB  may function as a gathering point for 128-bit data, and VAB  input may be 128 bits\/cycle or any other combination. The VAB  further has reserved slots for a plurality of vertex attributes that are all EEEE 32 bit floats. The number of such slots may vary per the desires of the user. Table 1 illustrates exemplary vertex attributes employed by the present invention.",{"@attributes":{"id":"p-0096","num":"0095"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Position:","x, y, z, w"]},{"entry":[{},"Diffuse Color:","r, g, b, a"]},{"entry":[{},"Specular Color:","r, g, b"]},{"entry":[{},"Fog:","f"]},{"entry":[{},"Texture0:","s, t, r, q"]},{"entry":[{},"Texture1:","s, t, r, q"]},{"entry":[{},"Normal:","nx, ny, nz"]},{"entry":[{},"Skin Weight:","w"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"During operation, VAB  may operate assuming that the x,y data pair is written before the z,w data pair since this allows for defaulting the z,w pair to (0.0,1.0) at the time of the x,y write. This may be important for default components in OpenGL\u00ae and D3D\u2122. It should be noted that the position, texture0, and texture1 slots default the third and fourth components to (0.0,1.0). Further, the diffuse color slot defaults the fourth component to (1.0) and the texture slots default the second component to (0.0).","The VAB  includes still another slot  used for assembling the data bits  that may be passed into or through the transform and lighting module  and , respectively, without disturbing the data bits . The data bits  in the slot  can be in a floating point or integer format. As mentioned earlier, the data bits  of each vertex has an associated set of mode bits  representative of the modes affecting the processing of the data bits . These mode bits  are passed with the data bits  through the transform and lighting modules  and , respectively, for purposes that will be set forth hereinafter in greater detail.","In one embodiment, there may be  valid VAB, transform, and lighting commands received by VAB .  is a chart illustrating the various commands that may be received by VAB  in accordance with one embodiment of the present invention. It should be understood that all load and read context commands, and the passthrough command shown in the chart of  transfer one data word of up to 128 bits or any other size.","Each command of  may contain control information dictating whether each set of data bits  is to be written into a high double word or low double word of one VAB address. In addition, a 2-bit write mask may be employed for providing control to the word level. Further, there may be a launch bit that informs VAB controller that all of the data bits  are present for a current command to be executed.","Each command has an associated stall field that allows a look-up to find information on whether the command is a read command in that it reads context memory or is a write command in that it writes context memory. By using the stall field of currently executing commands, the new command may be either held off in case of conflict or allowed to proceed.","In operation, VAB  can accept one input data word up to 128 bits (or any other size) per cycle and output one data word up to 128 bits (or any other size) per cycle. For the load commands, this means that it may take two cycles to load the data into VAB  to create a 128-bit quad-word and one cycle to drain it. For the scalar memories in the lighting module , it is not necessary to accumulate a full quad-word, and these can be loaded in one cycle\/address. For one vertex, it can take up to 14 cycles to load the 7 VAB slots while it only takes 7 cycles to drain them. It should be noted, however, that it is only necessary to update the vertex state that changes between executing vertex commands. This means that, in one case, the vertex position may be updated taking 2 cycles, while the draining of the vertex data takes 7 cycles. It should be noted that only 1 cycle may be required in the case of the x,y position.",{"@attributes":{"id":"p-0103","num":"0102"},"figref":"FIG. 2B","b":["50","210","50"]},"In use the vertex attributes are stored in VAB  upon the receipt thereof in operation . Further, each set of stored vertex attributes is transferred to a corresponding one of a plurality of input buffers of the transform module . The received set of vertex attributes is also monitored in order to determine whether a received vertex attribute has a corresponding vertex attribute of a different set currently stored in VAB , as indicated in operation .","Upon it being determined that a stored vertex attribute corresponds to the  received vertex attribute in decision , the stored vertex attribute is outputted to the corresponding input buffer of the transform module  out of order. See operation . Immediately upon the stored vertex attribute being outputted, the corresponding incoming vertex attribute may take its place in VAB . If no correspondence is found, however, each set of the stored vertex attributes may be transferred to the corresponding input buffer of the transform module  in accordance with a regular predetermined sequence. Note operation .","It should be noted that the stored vertex attribute might not be transferred in the aforementioned manner if it has an associated launch command. Further, in order for the foregoing method to work properly, the bandwidth of an output of VAB  must be at least the bandwidth of an input of VAB .",{"@attributes":{"id":"p-0107","num":"0106"},"figref":"FIG. 2C","b":["2","50","230","204","50"]},"Also included is a first multiplexer  having an output coupled to the read address terminal of VAB  and a second clock-controlled buffer . A first input of the first multiplexer  is coupled to the write address terminal of VAB  while a second input of the first multiplexer  is coupled to an output of a second multiplexer . A logic module  is coupled between the first and second multiplexers  and , the write address terminal of VAB , and an output of the second clock-controlled buffer .","In use the logic module  serves to determine whether an incoming vertex attribute is pending to drain in VAB . In one embodiment, this determination may be facilitated by monitoring a bit register that indicates whether a vertex attribute is pending or not. If it is determined that the incoming vertex attribute does have a match currently in VAB , the logic module  controls the first multiplexer  in order to drain the matching vertex attribute so that the incoming vertex attribute may be immediately stored in its place. On the other hand, if it is determined that the incoming vertex attribute does not have a match currently in VAB , the logic module  controls the first multiplexer  such that VAB  is drained and the incoming vertex attribute is loaded sequentially or in some other predetermined order, per the input of the second multiplexer  which may be updated by the logic module .","As a result, there is no requirement for VAB  to drain multiple vertex attributes before a new incoming vertex attribute may be loaded. The pending vertex attribute forces out the corresponding VAB counterpart if possible, thus allowing it to proceed. As a result, VAB  can drain in an arbitrary order. Without this capability, it would take 7 cycles to drain VAB  and possibly 14 more cycles to load it. By overlapping the loading and draining, higher performance is achieved. It should be noted that this is only possible if an input buffer is empty and VAB  can drain into input buffers of the transform module .",{"@attributes":{"id":"p-0111","num":"0110"},"figref":"FIG. 3","b":["50","202","202","52","54","202","202"]},"In one embodiment, the active light bits (LIS) of  may be contiguous. Further, the pass-through bit (VPAS) is unique in that when it is turned on, the vertex data is passed through with scale and bias, and no transforms or lighting is done. Possible mode bits  used when VPAS is true are the texture divide bits (TDV0,1), and foggen bits (used to extract fog value in D3D\u2122). VPAS is thus used for pre-transformed data, and TDV0,1 are used to deal with a cylindrical wrap mode in the context of D3D\u2122.",{"@attributes":{"id":"p-0113","num":"0112"},"figref":"FIG. 4","b":["52","50","400","400","400","400","50"]},"In one embodiment, a bit might be designated for each attribute of each input buffer  to indicate whether data has changed since the previous instance that the input buffer  was loaded. By this design, each input buffer  might be loaded only with changed data.","The transform module  is further connected to 6 output vertex buffers  in the lighting module . The output buffers include a first buffer , a second buffer , and a third buffer . As will become apparent hereinafter, the contents, i.e. position, texture coordinate data, etc., of the third buffer  are not used in the lighting module . The first buffer  and second buffer  are both, however, used for inputting lighting and color data to the lighting module . Two buffers are employed since the lighting module is adapted to handle two read inputs. It should be noted that the data might be arranged so as to avoid any problems with read conflicts, etc.","Further coupled to the transform module  is context memory  and micro-code ROM memory . The transform module  serves to convert object space vertex data into screen space, and to generate any vectors required by the lighting module . The transform module  also does processes skinning and texture coordinates. In one embodiment, the transform module  might be a 128-bit design processing 4 floats in parallel, and might be optimized for doing 4 term dot products.",{"@attributes":{"id":"p-0117","num":"0116"},"figref":"FIG. 4A","b":["52","52","410","202"]},"As shown in , the method of executing multiple threads includes determining a current thread to be executed in operation . This determination might be made by identifying a number of cycles that a graphics-processing module requires for completion of an operation, and tracking the cycles. By tracking the cycles, each thread can be assigned to a cycle, thus allowing determination of the current thread based on the current cycle. It should be noted, however, that such determination might be made in any desired manner that is deemed effective.","Next, in operation , an instruction associated with a thread to be executed during a current cycle is retrieved using a corresponding program counter number. Thereafter, the instruction is executed on the graphics-processing module in operation .","In one example of use, the instant method includes first accessing a first instruction, or code segment, per a first program counter. As mentioned earlier, such program counter is associated with a first execution thread. Next, the first code segment is executed in the graphics-processing module. As will soon become apparent, such graphics-processing module might take the form of an adder, a multiplier, or any other functional unit or combination thereof.","Since the graphics-processing module requires more than one clock cycle to complete the execution, a second code segment might be accessed per a second program counter immediately one clock cycle after the execution of the first code segment. The second program counter is associated with a second execution thread, wherein each of the execution threads process a unique vertex.","To this end, the second code segment might begin execution in the graphics-processing module prior to the completion of the execution of the first code segment in the graphics-processing module. In use the graphics-processing module requires a predetermined number of cycles for every thread to generate an output. Thus, the various steps of the present example might be repeated for every predetermined number of cycles.","This technique offers numerous advantages over the prior art. Of course, the functional units of the present invention are used more efficiently. Further, the governing code might be written more efficiently when the multiple threading scheme is assumed to be used.","For example, in the case where the graphics-processing module includes a multiplier that requires three clock cycles to output an answer, it would be necessary to include two no operation commands between subsequent operations such as a=b*c and d=e*a, since \u201ca\u201d would not be available until after the three clock cycles. In the present embodiment, however, the code might simply call d=e*a immediately subsequent a=b*c, because it can be assumed that such code will be executed as one of three execution threads that are called once every three clock cycles.",{"@attributes":{"id":"p-0125","num":"0124"},"figref":["FIG. 4B","FIG. 4A"],"b":["450","452","456","454","459"]},"In order to accommodate a situation where at least two of the foregoing processing modules are used in tandem, at least one code segment delay  is employed between the graphics-processing modules. In the case where a three-thread framework is employed, a three-clock cycle code segment delay  is used. In one embodiment, the code segment delay  is used when a multiplication instruction is followed by an addition instruction. In such case, the addition instruction is not executed until three clock cycles after the execution of the multiplication instruction in order to ensure that time has elapsed which is sufficient for the multiplier  to generate an output.","After the execution of each instruction, the program counter  of the current execution thread is updated and the program counter of the next execution thread is called by module  in a round robin sequence to access an associated instruction. It should be noted that the program counters might be used in any fashion including, but not limited to incrementing, jumping, calling and returning, performing a table jump, and\/or dispatching. Dispatching refers to determining a starting point of code segment execution based on a received parameter. Further, it important to understand that the principles associated with the present multiple thread execution framework might also be applied to the lighting module  of the graphics-processing pipeline of the present invention.","In the case where a three-thread framework is employed, each thread is allocated one input buffer and one output buffer at any one time. This allows loading of three more commands with data while processing three commands. The input buffers and output buffers are assigned in a round robin sequence in a manner that will be discussed later with reference to .","The execution threads are thus temporally and functionally interleaved. This means that each function unit is pipelined into three stages and each thread occupies one stage at any one time. In one embodiment, the three-threads might be set to always execute in the same sequence, i.e. zero then one then three. Conceptually, the threads enter a function unit at t=clock modulo-three. Once a function unit starts work, it takes three cycles to deliver the result (except the ILU that takes six), at which time the same thread is again active.",{"@attributes":{"id":"p-0130","num":"0129"},"figref":["FIG. 5","FIG. 4"],"b":["52","400","50"]},"A memory logic unit (MLU)  has a first input coupled to an output of input buffers . As an option, the output of MLU  might have a feedback loop  coupled to the first input thereof.","Also provided is an arithmetic logic unit (ALU)  having a first input coupled to an output of MLU . The output of ALU  further has a feedback loop  connected to the second input thereof Such feedback loop  may further have a delay  coupled thereto. Coupled to an output of ALU  is an input of a register unit . It should be noted that the output of register unit  is coupled to the first and second inputs of MLU .","An inverse logic unit (ILU)  is provided including an input coupled to the output of ALU  for performing an inverse or an inverse square root operation. In an alternate embodiment, ILU  might include an input coupled to the output of register unit .","Further included is a conversion, or smearing, module  coupled between an output of ILU  and a second input of MLU . In use the conversion module  serves to convert scalar vertex data to vector vertex data. This is accomplished by multiplying the scalar data by a vector so that the vector operators such as the multiplier and\/or adder may process it. For example, a scalar A, after conversion, may become a vector (A,A,A,A). In an alternate embodiment, the smearing module  might be incorporated into the multiplexers associated with MLU , or any other component of the present invention. As an option, a register  might be coupled between the output of ILU  and an input of the conversion unit . Further, such register  might be threaded.","Memory  is coupled to the second input of MLU  and the output of ALU . In particular, memory  has a read terminal coupled to the second input of MLU . Further, memory  has a write terminal coupled to the output of ALU .","The memory  has stored therein a plurality of constants and variables for being used in conjunction with the input buffer , MLU , ALU , register unit , ILU , and the conversion module  for processing the vertex data. Such processing might include transforming object space vertex data into screen space vertex data, generating vectors, etc.","Finally, an output converter  is coupled to the output of ALU . The output converter  serves for being coupled to a lighting module  via output buffers  to output the processed vertex data thereto. All data paths except for the ILU might be designed to be 128 bits wide or other data path Widths may be used.",{"@attributes":{"id":"p-0138","num":"0137"},"figref":["FIG. 6","FIG. 5"],"b":["500","52","500","52","600"]},"MLU  of transform module  is capable of multiplying two four component vectors in three different ways, or pass one four component vector. MLU  is capable of performing multiple operations. Table 2 illustrates such operations associated with MLU  of transform module .",{"@attributes":{"id":"p-0140","num":"0139"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["CMLU_MULT","o[0] = a[0] * b[0], o[1] = a[1] * b[1],"]},{"entry":[{},"o[2] = a[2] * b[2], o[3] = a[3] * b[3]"]},{"entry":["CMLU_MULA","o[0] = a[0] * b[0], o[1] = a[1] * b[1],"]},{"entry":[{},"o[2] = a[2] * b[2], o[3] = a[3]"]},{"entry":["CMLU_MULB","o[0] = a[0] * b[0], o[1] = a[1] * b[1],"]},{"entry":[{},"o[2] = a[2] * b[2], o[3] = b[3]"]},{"entry":["CMLU_PASA","o[0] = a[0], o[1] = a[1], o[2] = a[2], o[3] = a[3]"]},{"entry":["CMLU_PASB","o[0] = b[0], o[1] = b[1], o[2] = b[2], o[3] = b[3]"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Possible A and B inputs are shown in Table 3.",{"@attributes":{"id":"p-0142","num":"0141"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 3"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"MA_M","MLU"]},{"entry":[{},"MA_V","Input Buffer"]},{"entry":[{},"MA_R","RLU (shared with MB_R)"]},{"entry":[{},"MB_I","ILU"]},{"entry":[{},"MB_C","Context Memory"]},{"entry":[{},"MB_R","RLU (shared with MA_R)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Table 4 illustrates a vector rotate option capable of being used for cross products.",{"@attributes":{"id":"p-0144","num":"0143"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 4"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"MR_NONE","No change"]},{"entry":[{},"MR_ALBR","Rotate A[XYZ] vector left, B[XYZ] vector right"]},{"entry":[{},"MR_ARBL","Rotate A[XYZ] vector right, B[XYZ] vector left"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0145","num":"0144"},"figref":["FIG. 7","FIG. 5"],"b":["504","52","504","52","700","504","52","504","52"]},{"@attributes":{"id":"p-0146","num":"0145"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 5"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CALU_ADDA","o[0] = a[0] + b[0], o[1] = a[1] + b[1],"]},{"entry":[{},{},"o[2] = a[2] + b[2], o[3] = a[3]"]},{"entry":[{},"CALU_ADDB","o[0] = a[0] + b[0], o[1] = a[1] + b[1],"]},{"entry":[{},{},"o[2] = a[2] + b[2], o[3] = b[3]"]},{"entry":[{},"CALU_SUM3B","o[0123] = b[0] + b[1] + b[2]"]},{"entry":[{},"CALU_SUM4B","o[0123] = b[0] + b[1] + b[2] + b[3]"]},{"entry":[{},"CALU_SMRB0","o[0123] = b[0]"]},{"entry":[{},"CALU_SMRB1","o[0123] = b[1]"]},{"entry":[{},"CALU_SMRB2","o[0123] = b[2]"]},{"entry":[{},"CALU_SMRB3","o[0123] = b[3]"]},{"entry":[{},"CALU_PASA","o[0] = a[0], o[1] = a[1], o[2] = a[2],"]},{"entry":[{},{},"o[3] = a[3]"]},{"entry":[{},"CALU_PASB","o[0] = b[0], o[1] = b[1], o[2] = b[2],"]},{"entry":[{},{},"o[3] = b[3]"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0147","num":"0146"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["CALU_SMRB2","o[0123] = b[2]"]},{"entry":["CALU_SMRB3","o[0123] = b[3]"]},{"entry":["CALU_PASA","o[0] = a[0], o[1] = a[1], o[2] = a[2], o[3] = a[3]"]},{"entry":["CALU_PASB","o[0] = b[0], o[1] = b[1], o[2] = b[2], o[3] = b[3]"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Table 6 illustrates the A and B inputs of ALU  of transform module .",{"@attributes":{"id":"p-0149","num":"0148"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 6"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"AA_A","ALU (one instruction delay)"]},{"entry":[{},"AA_C","Context Memory"]},{"entry":[{},"AB_M","MLU"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"It is also possible to modify the sign bits of the A and B input by effecting no change, negation of B, negation of A, absolute value A,B. It should be noted that when ALU  outputs scalar vertex data, this scalar vertex data is smeared across the output in the sense that each output represents the scalar vertex data. The pass control signals of MLU  and ALU  are each capable of disabling all special value handling during operation.",{"@attributes":{"id":"p-0151","num":"0150"},"figref":["FIG. 8","FIG. 5"],"b":["510","52","510","800","802","802"]},"In one embodiment of the present invention, the vector register file  is threaded. That is, there are three copies of the vector register file  and each thread has its own copy. In one embodiment, each copy contains eight registers, each of which might be 128 bits in size and store four floats. The vector register file  is written from ALU  and the output is fed back to MLU . The vector register file  has one write and one read per cycle.","In operation, it is also possible to individually mask a write operation to each register component. The vector register file  exhibits zero latency when the write address is the same as the read address due to a bypass path  from the input to the output. In this case, unmasked components would be taken from the registers and masked components would be bypassed. The vector register file  is thus very useful for building up vectors component by component, or for changing the order of vector components in conjunction with the ALU SMR operations (See Table 5). Temporary results might be also stored in the vector register file .",{"@attributes":{"id":"p-0154","num":"0153"},"figref":["FIG. 9","FIG. 5"],"b":["512","52","512","52"]},{"@attributes":{"id":"p-0155","num":"0154"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]},{"entry":[{},"Reciprocal"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Reciprocal (1\/D)","Square-root (1\/D{circumflex over (\u2009)}(1\/2))"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"x+ 1 = x(2 \u2212 x* D)","x= (1\/2) * x(3 \u2212 x* D)"]},{"entry":["1)","table look up for x(seed)","table look up for x(seed)"]},{"entry":[{},"x","x* x"]},{"entry":["2)","1iteration: multiply-add","1iteration: multiply-add"]},{"entry":[{},"2 \u2212 x* D","3 \u2212 x* D"]},{"entry":["3)","1iteration: multiply","1iteration: multiply"]},{"entry":[{},"x(2 \u2212 x* D)","(1\/2) * x(3 \u2212 x* D)"]},{"entry":["4)","2iteration: no-op pass","2iteration: square"]},{"entry":[{},"x+ 1","x"]},{"entry":["5)","2iteration: multiply-add","2iteration: multiply-add"]},{"entry":[{},"2 \u2212 x* D","3 \u2212 x* D"]},{"entry":["6)","2 iteration: multiply","2iteration: multiply"]},{"entry":[{},"x(2 \u2212 x* D)","(1\/2) * x* D"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"As shown, the two processes are similar, affording a straightforward design. It should be noted that the iterations might be repeated until a threshold precision is met.","In operation, ILU  performs two basic operations including an inverse operation and inverse square root operation. Unlike the other units, it requires six cycles to generate the output. The input is a scalar, and so is the output. As set forth earlier, the threaded holding register  at ILU  output is relied upon to latch the result until the next time a valid result is generated. Further, the scalar output is smeared into a vector before being fed into MLU . The inverse unit  uses look-up tables and a two pass Newton-Raphson iteration to generate IEEE (Institute of Electrical and Electronics Engineers) outputs accurate to within about 22 mantissa bits. Table 7 illustrates the various operations that might be performed by ILU  of transform module .",{"@attributes":{"id":"p-0158","num":"0157"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 7"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CILU_INV","o = 1.0\/a"]},{"entry":[{},"GILU_ISQ","o = 1.0\/sqrt(a)"]},{"entry":[{},"GILU_CINV","o = 1.0\/a (with range clamp)"]},{"entry":[{},"CILU_NOP","no output"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The foregoing range clamp inversion operation of Table 7 might be used to allow clipping operations to be handled by rasterization module . Coordinates arc transformed directly into screen space that can result in problems when the homogeneous clip space w is near 0.0. To avoid multiplying by 1.0\/0.0 in the perspective divide, the 1\/w calculation is clamped to a minimum and a maximum exponent.","In use the context memory  as shown in  reads and writes only using quad-words. The memory can be read by MLU  or ALU  each cycle, and can be written by ALU . Only one memory read is allowed per cycle. If a read is necessary, it is done at the start of an instruction and then pipelined down to ALU  three cycles later. Context memory  need not necessarily be threaded.",{"@attributes":{"id":"p-0161","num":"0160"},"figref":["FIG. 10","FIG. 5","FIG. 4"],"b":["518","52","518","54","402","54"]},"Data swizzling is useful when generating vectors. Such technique allows the generation of a distance vector (1,d,d*d) without penalty when producing a vector. The distance vector is used for fog, point parameter and light attenuation. This is done with an eye vector and light direction vectors. Table 8 illustrates the various operations associated with such vectors. It should be noted that, in the following table, squaring the vector refers to d=dot[(x,y,z), (x,y,z)], and storing din the w component of (x,y,z).",{"@attributes":{"id":"p-0163","num":"0162"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 8"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"1. Square the vector \u2003(x, y, z, d * d) (output d * d to VBUF, 1.0 to"},{"entry":"\u2003VBUF)"},{"entry":"2. Generate inverse sqrt of d * d (1\/d)"},{"entry":"3. Normalize vector \u2003(x\/d, y\/d, z\/d, d) (output x\/d, y\/d, z\/d to WBUF,"},{"entry":"\u2003d to VBUF)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"It should be noted that the math carried out in the present invention might not always be IEEE compliant. For example, it might be assumed that \u201c0\u201d multiplied by any number renders \u201c0.\u201d This is particularly beneficial when dealing with the equations such as d=d*1\/(d), where d=0. Without making the foregoing assumption, such equation would afford an error, thus causing problems in making related computations.",{"@attributes":{"id":"p-0165","num":"0164"},"figref":["FIG. 11","FIG. 5"],"b":["52","500"]},{"@attributes":{"id":"p-0166","num":"0165"},"figref":["FIG. 12","FIG. 5","FIG. 12"],"b":["1200","52","1200","52","1202","50"]},"Also included is memory  capable of storing code segments that each are adapted to carry out the process operations in accordance with the status of the modes. A sequencing module  is coupled between memory  and a control vector module  which is in turn coupled to buffer  for identifying a plurality of addresses in memory  based on a control vector derived from mode bits . The sequencing module  is further adapted for accessing the addresses in memory  for retrieving the code segments that might be used to operate transform module  to transfer data to an output buffer .",{"@attributes":{"id":"p-0168","num":"0167"},"figref":"FIG. 13","b":["1200","52","12","1200","1320","202","202"]},"Then, in operation , pluralities of addresses are then identified in memory based on mode bits . Such addresses are then accessed in the memory in operation  for retrieving code segments that each are adapted to carry out the process operations in accordance with the status of the modes. The code segments are subsequently executed with a transform or lighting module for processing vertex data. Note operation .",{"@attributes":{"id":"p-0170","num":"0169"},"figref":["FIG. 14","FIGS. 4A and 4B"],"b":["1206","1200","52","12","1430","202","1430"]},"Once the current execution thread is selected, a corresponding group of mode bits  are decoded in operation . Upon mode bits  being decoded in operation , a control vector is afforded which includes a plurality of bits each of which indicate whether a particular code segment is to be accessed in ROM  for processing the corresponding vertex data.","Upon determining whether a code segment should be accessed in ROM  and executed, a pointer operation  increments the current thread pointer to start the next execution thread to obtain a second group mode bits  to continue a similar operation. This might be continued for each of the threads in a round robin sequence.","Once the control vector has been formed for a particular group of mode bits , a priority encoder operation  determines, or identifies, a next \u201c1\u201d or enabled, bit of the control vector. If such a bit is found, the priority encoder operation  produces an address in ROM  corresponding to the enabled bit of the control vector for execution purposes.","Upon returning to the initial group of mode bits  after handling the remaining threads, and after the mode bits have been decoded and the control vector is again available, a masking operation  might be used to mask the previous \u201c1\u201d, or enabled, bit that was identified earlier. This allows analysis of all remaining bits after mask operation .","The foregoing process might be illustrated using the following tables. Table 9 shows a plurality of equations that might be executed on subject vertex data.",{"@attributes":{"id":"p-0176","num":"0175"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 9"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"R = \u2003(a\u2003\u2003\u2003\u2002)"]},{"entry":[{},"R = \u2003(a + \u2003\u2003d*e\u2003)"]},{"entry":[{},"R = \u2003(a + b*c + \u2003\u2002f)"]},{"entry":[{},"R = \u2003(a + b*c + d*e\u2003)"]},{"entry":[{},"R = 1.0\/(a\u2003\u2003\u2003\u2002)"]},{"entry":[{},"R = 1.0\/(a + \u2003\u2003d*e\u2003)"]},{"entry":[{},"R = 1.0\/(a + b*c + \u2003\u2002f)"]},{"entry":[{},"R = 1.0\/(a + b*c + d*e\u2003)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"As shown, there are four possibilities of products that might be summed in addition to an inverse operation (a, b*c, d*e, f, and 1\/x). Next, mode fields might be defined. Table 10 illustrates a pair of mode fields, mode.y and mode.z, each having assigned thereto a predetermined set of the operations of Table 9.",{"@attributes":{"id":"p-0178","num":"0177"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 10"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"mode.y[4] 0: R = a"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"1: R = a + d*e"]},{"entry":[{},"2: R = a + b*c + f"]},{"entry":[{},"3: R = a + b*c + d*e"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"mode.z[2] 0: R = R"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"1: R = 1.0\/R"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Thereafter, each of the operations might be positioned in memory with an associated address. Table 11 illustrates a plurality of memory addresses each having an associated operation. Also shown is a set of control vector definitions.",{"@attributes":{"id":"p-0180","num":"0179"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ROM[0]: R = a"]},{"entry":[{},"ROM[1]: R = R + b*c"]},{"entry":[{},"ROM[2]: R = R + d*e"]},{"entry":[{},"ROM[3]: R = R + f"]},{"entry":[{},"ROM[4]: R = 1.0\/R"]},{"entry":[{},"cv[0] = 1;"]},{"entry":[{},"cv[1] = (mode.y==2 \u2225 mode.y==3) ? 1 : 0;"]},{"entry":[{},"cv[2] = (mode.y==1 \u2225 mode.y==3) ? 1 : 0;"]},{"entry":[{},"cv[3] = (mode.y==2) ? 1:0;"]},{"entry":[{},"cv[4] = (mode.z==1) ? 1:0;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Table 12 illustrates the execution of an example.",{"@attributes":{"id":"p-0182","num":"0181"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 12"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"R = a+d*e corresponds to:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"mode.y = 1;"]},{"entry":[{},"mode.z = 0;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},{"@attributes":{"id":"p-0183","num":"0182"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"cv[0] = 1;"},{"entry":"cv[1] = 0;"},{"entry":"cv[2] = 1;"},{"entry":"cv[3] = 0;"},{"entry":"cv[4] = 0;"},{"entry":"execution"},{"entry":"first cycle:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"cv[0] is TRUE so execute ROM[0]"]},{"entry":[{},"more TRUE values in control vector, so do not terminate"]},{"entry":[{},"program"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"second cycle:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"cv[1] is FALSE so keep looking"]},{"entry":[{},"cv[2] is TRUE so execute ROM[2]"]},{"entry":[{},"no more TRUE values in control vector, so terminate"]},{"entry":[{},"program"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"As such, sequencer  of transform module  steps through a threaded control vector which is derived from threaded mode bits , and executes every ROM address whose corresponding control vector bit is set to \u201cTRUE\u201d. The control vector has the same length as the ROM. The sequencer  is capable of stepping through an arbitrary control vector at the rate of one \u201c1\u201d, or enabled bit per a predetermined number of cycles. Commands that do not use mode bits  might be executed by on-the-fly micro-code generation due to the simplicity thereof.","By representing such statuses by way of a unique string of mode bits , it is unnecessary to execute a plurality of if-then clauses in the graphics-processing hardware to determine the statuses of the various operations. Improved performance is thereby afforded. Conceptually, it is as if the if clauses in a program language had been moved to sequencer  which in turn instantly skips instructions with a \u201cFALSE\u201d condition, as indicated by mode bits .","As indicated earlier, code segments are stored in the ROM which are capable of handling the various statuses of the operations identified by the mode bits. In one embodiment a separate code segment might be retrieved for handling each operation indicated by the mode bits. In the alternative, a single comprehensive code segment might be written for handling each or some combinations of operations that are possible. It should be noted, however, that generating such large code segments for each combination of operations requires additional code space, and it therefore might be beneficial to modularize the code segments for only commonly used combinations of operations.","Since mode bits  do not change once the vertex commences execution, the control vector generation might only have to be done once per vertex before entering the sequencer. Exceptions to this might arise in some cases, however, such as lighting where operations might be repeated. When the last vertex instruction is found, an end of sequence (EOS) signal might be asserted. This in turn might be used to change the status of the input and output buffers, and to allow the start of the next command in a manner that will be set forth during reference to . It should be noted that the EOS signal is pipeline delayed for release of the destination buffer similar to the manner in which the instructions are handled. See FIG. B.",{"@attributes":{"id":"p-0188","num":"0187"},"figref":"FIG. 14A","b":["1440","1442"]},"In yet another functional aspect , vector vertex data is masked, thereby converted to scalar vertex data, after which it is stored in memory, i.e. register logic unit, for the purpose of generating vector vertex data. In still yet another functional aspect , scalar vertex data is extracted by a vector processing module, i.e. adder, multiplier, etc., which in turn is processed by a scalar processing module, i.e. inverse logic unit, which renders scalar vertex data. This scalar vertex data is converted again into vector vertex data.",{"@attributes":{"id":"p-0190","num":"0189"},"figref":["FIG. 14B","FIG. 14A","FIG. 14C"],"b":["1451","52","5","1444","1446","4","1453","14"]},"Multiplexers might accomplish the extraction of the scalar vertex data from the vector vertex data in the functional modules of . Such multiplexers might also be responsible for any data swizzling that might be required before processing by the various functional modules. In one embodiment, the multiplexers might be capable of passing and rotating vector vertex data, and rely on other graphics-processing modules such as an ALU for other processing. In yet another embodiment, the multiplexers might be capable of arbitrarily rearranging attributes independently without penalty.",{"@attributes":{"id":"p-0192","num":"0191"},"figref":"FIG. 14D","b":"1470"},"Subsequently, in operation , a sum of a plurality of products is then calculated with each product being calculated by the multiplication of the vertex data, one of the matrices and the weight corresponding to the matrix. Such sum of products is then outputted in operation  for additional processing.","In summary, the following sum of products might be calculated:","\u2003for 1 \u2003\u2003Equation #1","where",{"@attributes":{"id":"p-0195","num":"0000"},"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":["v=inputted vertex data","w=weight value","M=matrix","x=number of matrices","v\u2032=vertex data for output to a processing module\n\nfor i=1 \u2003\u2003Equation #2 \n\nwhere\n","n=inputted vertex data (normal vector)","w=weight value","I=inverted matrix (inverse transpose matrix)","x=number of inverted matrices","n\u2032=vertex data for output to a processing module (normal vector)\n\n, \u00d8]\u2032+1\/()*[(), (), (), 1]\u2032\u2003\u2003Equation #3\n\nwhere\n","v\u2033=C*v\u2032","v\u2032=sum of products from Equation #1","C=[S, S, S, 1]\u2032*P","P=projection matrix","v=screen vector for display purposes","O=viewport offset","S=viewport scale"]}}}},"It should be noted that there are many ways to represent the weights wset forth hereinabove. For example, in Equations #1 and #2 above, it might be said that i=1 . . . (x\u22121), leaving w(wwhere i=x) to be calculated by the equation 1\u2212\u03a3w. By representing the weights win this way, it is ensured that all of the weights w sum to 1.","In one embodiment, the matrices might include model view matrices (M), and the sum of products (v\u2032) might be outputted for additional processing by a lighting operation. See Equation #1. This sum of products (v\u2032) might also be used to generate another sum of products (v) for display purposes by using a composite matrix (C). See Equation #3. Still yet, the matrices might include inverse matrices (I) and the vertex data might include normal vector data (n). In such case, the additional processing might include a lighting operation. See Equation #2.",{"@attributes":{"id":"p-0198","num":"0213"},"figref":"FIG. 15","b":["54","54","402","52","408","54","1501","54","1500","1502"]},"The lighting module  is adapted for handling lighting in addition to fog and point parameters. In use lighting module  controls the buffer bypass pathway , and calculates the diffuse, point size, and specular output colors as well as the fog value. It should be noted that lighting module  employs the same mode bits  as transform module .","The lighting module  further requires less precision with respect to transform module , and therefore processes 22 bit floating point values (1.8.13 format) organized in tri-words. Since the data of third buffer  is 128 bits, it utilizes bypass pathway  around lighting module . The lighting module  is event driven and simultaneously executes three threads in a manner similar to transform module  as was set forth earlier with reference to . It should be noted that lighting module  might require command launch approval from an outside source.",{"@attributes":{"id":"p-0201","num":"0216"},"figref":["FIG. 16","FIG. 15"],"b":["54","402","402","404","406","408","404","406","408","52","408","54","1608"]},"Further included is a MLU  having a first input coupled to an output of first input buffer  and a second input coupled to an output of second input buffer . The output of MLU  has a feedback loop  coupled to the second input thereof. An arithmetic logic unit (ALU)  has a first input coupled to an output of second input buffer . ALU  further has a second input coupled to an output of MLU . An output of ALU  is coupled to the output of lighting module . It should be noted that the output of ALU  and the output of the third input buffer  are coupled to the output of lighting module  by way of multiplexer .","Next provided is a first register unit  having an input coupled to the output of ALU  and an output coupled to the first input of ALU . A second register unit  has an input coupled to the output of ALU . Also, such second register  has an output coupled to the first input and the second input of MLU .","A lighting logic unit (LLU)  is also provided having a first input coupled to the output of ALU , a second input coupled to the output of the first input buffer , and an output coupled to the first input of MLU . It should be noted that the second input of LLU  is coupled to the output of the first input buffer  via a delay . Further, the output of LLU  is coupled to the first input of MLU  via a first-in first-out register unit . As shown in , the output of LLU  is also coupled to the first input of MLU  via a conversion module . In operation, such conversion module  is adapted for converting scalar vertex data to vector vertex data in a manner similar to that of transform module .","Finally, memory  is coupled to at least one of the inputs of MLU  and the output of arithmetic logic unit . In particular, memory  has a read terminal coupled to the first and the second input of MLU . Further, memory  has a write terminal coupled to the output of ALU .","The memory has stored therein a plurality of constants and variables for being used in conjunction with input buffers , MLU , ALU , first register unit , second register unit , and LLU  for processing the vertex data.",{"@attributes":{"id":"p-0207","num":"0222"},"figref":["FIG. 17","FIG. 16"],"b":["1610","54","1610","54","1700","1610","1610","54"]},{"@attributes":{"id":"p-0208","num":"0223"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 13"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ZMLU_MULT","o[0] = a[0]*b[0], o[1] = a[1]*b[1], o[2] = a[2]*b[2]"]},{"entry":["ZMLU_PASA","o[0] = a[0], o[1] = a[1], o[2] = a[2]"]},{"entry":["ZMLU_PASB","o[0] = b[0], o[1] = b[1], o[2] = b[2]"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Table 14 illustrates the possible A and B inputs of MLU  of lighting module .",{"@attributes":{"id":"p-0210","num":"0225"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 14"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"MA_V","VBUFFER"]},{"entry":[{},"MA_L","LLU"]},{"entry":[{},"MA_R","RLU[2,3] (shared with MB_R)"]},{"entry":[{},"MA_C","Context memory (shared with MB_C)"]},{"entry":[{},"MB_M","MLU"]},{"entry":[{},"MB_W","WBUFFER"]},{"entry":[{},"MB_R","RLU[2,3] (shared with MA_R)"]},{"entry":[{},"MB_C","Context memory (shared with MA_C)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0211","num":"0226"},"figref":["FIG. 18","FIG. 16"],"b":["1614","54","1614","1800","1614","1614","54"]},{"@attributes":{"id":"p-0212","num":"0227"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 15"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ZALU_ADD","o[0] = a[0]+b[0], o[1] = a[1]+b[1], o[2] = a[2]+b[2]"]},{"entry":["ZALU_SUM3B","o[012] = b[0] + b[1] + b[2]"]},{"entry":["ZALU_PASA","o[0] = a[0], o[1] = a[1], o[2] = a[2]"]},{"entry":["ZALU_PASB","o[0] = b[0], o[1] = b[1], o[2] = b[2]"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Table 16 illustrates the possible A and B inputs to ALU  of lighting module .",{"@attributes":{"id":"p-0214","num":"0229"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 16"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"AA_W","WBUFFER"]},{"entry":[{},"AA_R","RLU[0,1]"]},{"entry":[{},"AB_M","MLU"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0215","num":"0230"},"figref":["FIG. 19","FIG. 16"],"b":["1618","1620","54","1618","1620","1900","1902","1902"]},"Register units  and  of lighting module  are split into two registers for ALU  and two registers for MLU . In one embodiment, the registers are threaded. The register units  and  exhibit zero latency when a write address is the same as a read address due to a bypass path from the input to the outputs.",{"@attributes":{"id":"p-0217","num":"0232"},"figref":["FIG. 20","FIG. 16"],"b":["1622","54","1622","54","1622"]},"The flag register is used to implement the conditional parts of the lighting equations. The outputs are an ambient, diffuse, and specular coefficient. The scalar memories contain variables used for the specular approximations and constants. The first location of each memory contains 1.0 (for ctx and ctx) and 0.0 (for ctx- and ctx). In one embodiment, these are hardwired and do not need to be loaded.","In use LLU  fundamentally implements the equation: (x+L)\/(M*x+N). This equation is used to approximate a specular lighting term. The inputs to LLU  are from ALU  of lighting module  and are the dot products used in the lighting equations. As set forth earlier, with respect to , there is an output FIFO  between LLU  and MLU  which buffers coefficients until MLU  needs them. In one embodiment, such FIFO  might be threaded along with delays  and , and registers  and . Due to possible color material processing, it is unknown when the diffuse and specular outputs are consumed by MLU .","There is specially adapted hardware for dealing with the diffuse output alpha component since lighting module  only deals with R,G,B components. Such specially adapted hardware is capable of outputting two types of alpha components, namely vtx color\u00f8\u03b1[Tbuffer], and stored ctx \u03b1[Ctx store]. The choice between the foregoing alpha components is governed by mode bits .","In operation, LLU  calculates ambient (Ca), diffuse (Cde), and specular (Cs) coefficients of lighting. These coefficients are then multiplied with the ambient, diffuse, and specular colors to generate a light's contribution to the vertex color. Table 16A includes a list of inputs received by LLU  and the calculations carried out to generate the ambient (Ca), diffuse (Cde), and specular (Cs) coefficients of lighting. It should be noted that any desired hardware configuration might be employed to implement LLU . In one embodiment, the specific configuration shown in  might be employed.",{"@attributes":{"id":"p-0222","num":"0237"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 16A"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Input definitions:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"n = normal vector","(from transform engine)"]},{"entry":[{},"e = normalized eye vector","(from transform engine)"]},{"entry":[{},"l = normalized light vector","(from transform engine)"]},{"entry":[{},"s = spotlight vector*light vector","(from transform engine)"]},{"entry":[{},"D = distance vector (1,d,d*d)","(from transform engine)"]},{"entry":[{},"h = half angle vector","(from lighting engine)"]},{"entry":[{},"K = attenuation constant","(from context memory)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"vector (K0,K1,K2) "]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"The LLU might receive the following scalar data in carrying out its"},{"entry":"calculations:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"n*l","(from MLU\/ALU)"]},{"entry":[{},"n*h","(from MLU\/ALU)"]},{"entry":[{},"K*D","(from MLU\/ALU)"]},{"entry":[{},"s","(from transform engine)"]},{"entry":[{},"power0","(material exponent from ctx0-3 memory)"]},{"entry":[{},"power1","(spotlight exponent from ctx0-3 memory)"]},{"entry":[{},"range","(from ctx0-3 memory)"]},{"entry":[{},"cutoff","(from ctx0-3 memory)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Infinite Light"},{"entry":"LLU Calculations:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Ca = 1.0"]},{"entry":[{},"Cd = n*l"]},{"entry":[{},"Cs = (n*h){circumflex over (\u2009)}power0"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Local Light"},{"entry":"LLU Calculations:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"att = 1.0\/(K*D)"]},{"entry":[{},"Ca = att"]},{"entry":[{},"Cd = att*(n*l)"]},{"entry":[{},"Cs = att*((n*h){circumflex over (\u2009)}power0)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Spot Light"},{"entry":"LLU Calculations:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"att = (s{circumflex over (\u2009)}power1)\/(K*D)"]},{"entry":[{},"Ca = att"]},{"entry":[{},"Cd = att*(n*l)"]},{"entry":[{},"Cs = att*((n*h){circumflex over (\u2009)}power0)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"As set forth above, the mode bits controlling the vertex sequencer might not necessarily be changed by the vertex data itself or by any results derived from vertex data. To allow vertex data to modify vertex processing, LLU  employs a flag register  is provided. Setting bits to TRUE in this flag register allows clamping to 0.0 of calculation results if a flag is specified in the output control of the calculation. Another use of the flag register  would be in setting a write mask for register writes.","The flag register  is provided in LLU  for performing the if\/then\/else clamping to 0.0 in the lighting equations at no performance penalty. The sign bit of various operands might set the flags. Table 16B illustrates the manner in which the flags in flag register  are set and the resulting clamping.",{"@attributes":{"id":"p-0225","num":"0240"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 16B"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Infinite Light"},{"entry":"LLU Calculations:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Dflag = sign bit of (n*l)"]},{"entry":[{},"Sflag = sign bit of (n*h)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Clamp:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Ca = (0",") ? 0 : Ca;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Cd = (Dflag",") ? 0 : Cd;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Cs = (Dflag | Sflag) ? 0 : Cs;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Local Light"},{"entry":"LLU Calculations:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Rflag = sign bit of (range-d)"]},{"entry":[{},"Dflag = sign bit of (n*l)"]},{"entry":[{},"Sflag = sign bit of (n*h)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Clamp:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Ca = (Rflag",") ? 0 : Ca;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Cd = (Rflag | Dflag",") ? 0 : Cd;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Cs = (Rflag | Dflag | Sflag) ? 0 : Cs;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Spot Light"},{"entry":"LLU Calculations:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Cflag = sign bit of (s-cutoff)"]},{"entry":[{},"Rflag = sign bit of (range-d)"]},{"entry":[{},"Dflag = sign bit of (n*l)"]},{"entry":[{},"Sflag = sign bit of (n*h)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Clamp:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Ca = (Cflag | Rflag",") ? 0 : Ca;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Cd = (Cflag | Rflag | Dflag",") ? 0 : Cd;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Cs = (Cflag | Rflag | Dflag | Sflag) ? 0 : Cs;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0226","num":"0241"},"figref":["FIG. 21","FIG. 16"],"b":["1623","54","1623","0"]},"When LLU  outputs a scalar value to MLU  where it gets smeared into a tri-word, it specifies a mask for the flag register. If the register & mask is true, 0.0 replaces the output. Table 17 illustrates the various flags of  to be used in outputting ambient, diffuse, and specular attributes.",{"@attributes":{"id":"p-0228","num":"0243"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 17"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Ambient Mask:","\u2003\u2009\u2009\u2009C,R,\u2002U"]},{"entry":[{},"Diffuse Mask:","D,\u2009\u2009\u2009C,R,\u2002U"]},{"entry":[{},"Specular Mask:","D,S,C,R,T,U"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The approximation used for the specular term can go negative where the actual cos (theta)**n would go to 0.0. As a result, it is necessary to perform a clamping operation. For this, the T, U flags are used. Table 18 illustrates various operations of which a functional logic unit (FLU)  of LLU  is capable. Note FIG. .",{"@attributes":{"id":"p-0230","num":"0245"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 18"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ZFLU_INV","o = 1\/a","\u2009(mantissa accuracy - 12 bits)"]},{"entry":[{},"ZFLU_ISQ","o = 1\/sqrt(a)","(mantissa accuracy - 6 bits)"]},{"entry":[{},"ZFLU_PASS","o = a"]},{"entry":[{},"ZFLU_PASS1","o = 1.0"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ZFLU_MIN1","o = (a < 1.0) ? a : 1.0"]},{"entry":[{},"ZFLU_NOP","o = 0.0"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0231","num":"0246"},"figref":["FIG. 22","FIG. 16"],"b":["54","54"]},{"@attributes":{"id":"p-0232","num":"0247"},"figref":["FIG. 23","FIG. 16"],"b":["2300","54","2300","54","2302","202","1502"]},"A sequencing module  is coupled between memory  and buffer  for identifying a plurality of addresses in memory  based on a control vector  derived from the mode bits. The sequencing module  is further adapted for accessing the addresses in memory  for retrieving the code segments that might be used to operate lighting module .","The sequencer  of lighting module  is similar to that of transform module . In operation, sequencer  of lighting module  steps through a threaded control vector that is derived from threaded mode bits  and executes every ROM address whose corresponding control vector bit is set to \u201c1\u201d. The control vector has the same number of bits as the ROM has words. The sequencer  can step through an arbitrary control vector at the rate of a single \u201c1\u201d or enabled bit per a predetermined number of cycles for every thread. Commands that do not use mode bits  are executed by on-the-fly micro-code generation. The main difference between sequencer  of lighting module  and sequencer  of transform module  is that sequencer  of lighting module  can loop back and execute the lighting code up to eight times.","The sequencer  of lighting module  has a light counter that starts at zero for each new vertex and increments by one at the end of the micro-code sequence. If the LIS field of mode bits  contains a \u201c1\u201d in the matching bit field, sequencer  goes back and starts over at the beginning of the lighting micro-code block. This continues until a zero is found in the LIS field or eight lights have been done. Color accumulation is done by incrementing (per light) the ALU registers that store the diffuse and specular color. Automatic memory address indexing is done using the light counter to fetch the correct parameters for each light.",{"@attributes":{"id":"p-0236","num":"0251"},"figref":"FIG. 24","b":["52","54","2420"]},"Subsequently, in operation , an empty buffer of a second set of buffers is identified also based on a round robin sequence. The transform module  is coupled between the first set of buffers and the second set of buffers. When the empty buffer of the second set of buffers is identified, the vertex data is processed in transform module and outputted from transform module to the identified empty buffer of the second set of buffers. Note operations  and .","Similarly, an empty buffer of a third set of buffers, or slots or spaces in memory, are identified based on a round robin sequence in operation . The lighting module  is coupled between the second set of buffers and the third set of buffers. When the empty buffer of the third set of buffers is identified, the vertex data is processed in the lighting module, as indicated in operation . The vertex data is subsequently outputted from lighting module  to the identified empty buffer of the third set of buffers. See operation . It should be noted that the number of buffers, or slots in memory, is flexible and might be changed.",{"@attributes":{"id":"p-0239","num":"0254"},"figref":"FIG. 25","b":["52","54","24","400","52","404","406","404","406","54","2550"]},"In order carry out the method set forth in , the slots of memory  and the buffers of the first and second set are each assigned a unique identifier upon initially receiving vertex data. Further, a current state of each buffer is tracked. Such state might include an allocated state, a valid state, an active state, or a done state.","The allocated state indicates that a buffer\/slot is already allocated to receive an output of the previous graphics-processing module, i.e. transform module or lighting module. When a write pointer is scanning the buffers\/slots in the round robin sequence, a buffer\/slot in the allocated state cause such write pointer to increment to the next buffer or slot.","If a buffer\/slot is in the valid state, the buffer\/slot is available for receiving vertex data. On the other hand, the active state indicates that a buffer\/slot is currently in an execution state, or receiving vertex data. This active status is maintained until a thread is done after which a read pointer increments, thus placing the buffer\/slot back in the valid state. It should be noted that the first set of buffers  are only capable of being in the valid state since there is no previous graphics-processing module to allocate them.","An example of a sequence of states will now be set forth. Upon receiving vertex data in one of the first set of buffers  and a new set of command bits , such buffer is placed in the valid state, after which one of the second set of buffers ,  is placed in the allocated state in anticipation of the output of transform module .","If none of the second set of buffers ,  is available for allocation, the vertex data in the buffer of the first set  can not be processed. Further, a check might be done to determine whether the code segments to be executed will interfere with any other code segments that are to be simultaneously run. If so, the vertex data in the buffer of the first set  will not be processed and a stall condition initiated.","After one of the second set of buffers ,  is placed in the allocated state, the buffer of the first set  is placed in the active state. When transform module  is finished execution, the buffer of the second set ,  is read and then placed in the valid state. These state changes are similarly executed during the transfer of vertex data between the second set ,  and the slots of memory .",{"@attributes":{"id":"p-0246","num":"0261"},"figref":"FIG. 25A","b":["56","57","58","56","56"]},{"@attributes":{"id":"p-0247","num":"0262"},"figref":"FIG. 26","b":["57","56","57","61","62","64"]},"With continuing reference to , output formatting section  handles converting the internal floating point format of edge slopes and edge values into integer formats suitable for the rasterizer since the rasterizer operates only with integer values. Of course, in alternate embodiments, the rasterizer might use a floating point thus obviating the need for output formatting section .","In operation, output formatting section  executes a block floating point conversion. As is well known, with a given number, i.e. 2.34 e, floating point format tracks a mantissa (2.34) and an exponent (10) thereof. Block floating point conversion essentially manipulates the decimal place of the mantissas of incoming data such that the exponents are the same. To this end, the exponent need not be handled in rasterizer module .",{"@attributes":{"id":"p-0250","num":"0265"},"figref":"FIG. 26A","b":["57","56","25","56","2600","57","2601","2600","2602","2604"]},"The slopes  are used to generate coefficients for line equations of the edges of the primitive  to be used during rasterization. The slopes  might, for example, be calculated by using equations #4 and #5 shown below.\n\nslope\n\nslope\u2003\u2003Equations #4 and #5\n\n","It should be noted that the slopes might also be calculated using the coordinates of the vertices by employing a simple rotation operation or the like.","The starting position  indicates a starting point for area rasterization that will be set forth hereinafter in greater detail. The starting value  is equal to the area of the shaded triangle shown in FIG. A and is also used during the area-based rasterization process. Such starting value  is selected so that stepping the raster position about the screen while adding the slope at each step will equal zero exactly when the raster position is on the edge. Calculation of the starting value  might be accomplished using Equation #6 below:\n\nstarting_value=slope*()+slope*()\u2003\u2003Equation #6\n\nwhere\n\n","It should be understood that the foregoing values might also be calculated for other types of primitives. For example, in the case of a line, an extra slope must be calculated for the four-sided bounding box. Such slope can be easily calculated by taking the reciprocal of the slope of an opposite side of the bounding box. In addition to the extra slope calculation, it is noted that another starting value needs to be calculated in the case of the line primitive.",{"@attributes":{"id":"p-0255","num":"0274"},"figref":["FIG. 27","FIG. 26A"],"b":["56","57","56","2700","2601"]},"Thereafter, in operation , the line equation coefficients are modified if any primitive vertex(es) has a negative W-coordinate. Additional information regarding this process will be set forth hereinafter in greater detail with reference to FIG. .","It should be noted that set-up module  of rasterizer module  also computes a bounding box of the primitive. For most triangles, the bounding box includes the minimum and maximum values of the three vertexes. For lines, the four parallelogram corners of the bounding box are calculated. For triangles or lines that have a vertex with a negative W-coordinate, an area that is to be drawn extends beyond the convex hull of the vertices.","One of the commands of OpenGL\u00ae is a scissor rectangle which defines a boundary outside of which is not to be drawn. The set-up module  of rasterizer module  calculates the intersection of the bounding box and the scissor rectangle. Since the scissor rectangle is a rectangle, four additional line equations are afforded. It should be noted that the line equations associated with the scissor rectangle have a trivial form, i.e. horizontal or vertical.","Furthermore, in 3-D space, the near plane and far plane are parallel and at right angles to the line of sight. In the case of the primitive being a triangle, three vertexes are included which define a plane that might have any orientation. The intersections of the plane of the primitive and the near and far planes include two lines with two associated line equations.","Accordingly, each primitive has a total of nine or ten line equations depending on whether it takes the form of a triangle or a line, respectively. Again, in the case of the triangle, such line equations include the three line equations which define the triangle, the four line equations defining the bounding box and the two line equations which define the intersections of the plane in which the primitive resides, and near and far planes.","With continuing reference to , the process progresses in operation  by positioning a plurality of points on or near the primitive. The starting position  dictates such positioning, as shown in FIG. A. Such points define an enclosed convex region and reside at corners of the convex region.  illustrates such sense points  that enclose convex region , e.g. a rectangle. In one embodiment, such rectangle might be 8\u00d72 pixels in size. Further, the points might be initially positioned to enclose a top vertex of the primitive. As an option, this might be accomplished using truncation.","Once the primitive is positioned, the process is continued by traversal module  which begins in operation  by processing rows of the primitive in a manner set forth below. After the processing of each row, it is determined whether a jump position has been found in decision . A jump position is a starting position for processing the next row and will be described hereinafter in greater detail. If it is determined in decision  that a jump position has been found, the sense points that define the convex region are moved thereto in operation . If, however, it is determined that a jump position has not been found, the process is ended. It should be noted that, in an alternate embodiment, columns, diagonals or any other type of string might be processed in operation  instead of rows.",{"@attributes":{"id":"p-0263","num":"0282"},"figref":"FIG. 28","b":["2706","27","2800","2801","2802","2802"]},"Next, the line equations are evaluated at the points of the convex region, e.g. rectangle, in operation . The evaluation includes determining if the points reside in the primitive. Such determination as to whether the points reside in the primitive might include determining whether the evaluation of each of the line equations renders a positive value or a negative value at each of the sense points.","The line equations can be formulated to be positive inside the primitive and negative outside. Inclusive edges, for which pixels that lie exactly on the edge should be drawn, evaluate to zero and might be treated as positive. Exclusive edges, which should not be drawn, can be made negative by initially subtracting a value of one from the starting line equation value. Thus pixels on exclusive edges evaluate to a negative value (\u22121) instead of a positive zero. This permits the sense point interpretation to ignore the inclusive\/exclusive policy and just test the line equation sign.","After the line equations are evaluated at the points, it is determined whether a current position of the sense points constitutes a jump position in decision . It should be noted that a jump position is stored only if the two bottom sense points are not both outside an edge. If it is determined in decision  that a jump position has been found, the jump position is calculated and stored (or replaces a previously stored jump position if existent) in operation . If not, however, operation  is skipped.","With continuing reference to , it is then determined in decision  whether leftmost sense points are both outside an edge of the primitive. Again, this process entails determining whether the evaluation of the line equations at both of the leftmost sense points renders positive or negative values. In particular, upon computation of the coefficients of the nine or ten edge equations at the pertinent sense points, nine or ten values are rendered that have nine or ten sign bits. To determine if the current side is completely outside any edge, for example, the present invention AND's the ten sign bits from the two sense points together. If any bit(s) survive, then both points are outside that edge.","If it is determined that the leftmost sense points are not both outside an edge of the primitive, it is concluded that there still remains further portions of the primitive to be considered in the leftward direction, and the sense points are moved left in operation . If it is determined in decision  that both leftmost sense points are indeed outside the edge of the primitive, it is concluded that there no longer remains further portions of the primitive to be considered in the leftward direction. Next, in decision , it is determined whether there is a snap location that resulted from operation .","If it is determined in decision  that a snap location does not exist, the process is done. If, however, a snap location does exist, the sense points are moved to the snap location in operation . Thereafter, operations similar to those of operations - are executed to map a right side of the primitive. This begins in operation  by the line equations being evaluated at the points of the convex region.","After the line equations are evaluated at the points, it is determined whether a current position of the sense points constitutes a jump position in decision . If it is determined in decision  that a jump position has been found, the jump position is calculated and stored in operation . If not, however, operation  is skipped.","With continuing reference to , it is then determined in decision  whether rightmost sense points are both outside an edge of the primitive. If it is determined that the rightmost sense points are not both outside an edge of the primitive, it is concluded that there still remains further portions of the primitive in the rightward direction to be considered, and the sense points are moved right in operation . If it is determined in decision  that both rightmost sense points are outside the edge of the primitive, it is concluded that there no longer remains further portions of the primitive to be considered in the rightward direction, and the instant process is done.",{"@attributes":{"id":"p-0272","num":"0291"},"figref":"FIGS. 28A and 28B","b":["2850","2800"]},"To avoid stepping in a repeating loop, the present invention thus employs an overall direction of movement during rasterization. The initial implementation proceeds top-down, visiting every convex region on a row before stepping down to the next. By processing rows top-down as well as never stepping right then left or left then right, loops are thus avoided.","An example of the foregoing process might be shown with reference to the polygon-defining points, P, P, P and P of FIG. A. In operation, pairs of adjacent sense points can be examined to determine whether stepping in their direction would be productive. For example, if both P and P in  were outside of an edge of a polygon, but P and\/or P are not, then clearly the drawable inside region lies to the left, not to the right. Thus the sense points should not move right. Conversely, if both P and P are inside all the edges, then there is a drawable area just beyond P and P, and stepping right is appropriate. Indeed, if P and P were not outside the same edge or edges, stepping right would be productive. This same logic applies to stepping upwards guided by P and P, or stepping left guided by P and P, or stepping downwards based on P and P.","The foregoing process thus moves, or steps, the convex region defined by the points around the inside of the primitive, using sense points as a guide. Since the convex region defined by the points might be large, many pixels might be tested simultaneously. During use, if all sense points are inside all edges of the primitive, then all the enclosed pixels must be drawable (assuming a convex primitive). A significant advantage is afforded by testing the corners, namely the ability of proving an arbitrary area of the primitive is inside, outside or split. Only in the latter case do the individual pixels in the convex region defined by the points need to be tested. In such case, the pixels in the convex region defined by the points might be tested one-by-one or by another method in order to determine whether they reside in the primitive. Furthermore, the sense points might reduce the amount of further testing required by defining which edges(s) split the area and which do not.",{"@attributes":{"id":"p-0276","num":"0295"},"figref":"FIG. 29","b":["2706","27","2900","2900","2902","2804","28"]},"With continuing reference to , it is subsequently determined in decision  as to whether sense points of a first side of the rectangle are both outside an edge of the primitive. If not, the sense points are moved or stepped in the first direction in operation . Upon it being determined that the sense points of the first side of the rectangle are both outside an edge of the primitive, it is then determined in decision  whether the points can be moved downwardly or, in other words, whether the current position constitutes a jump position. If so, a jump position is calculated and stored in operation  after which the process is done.","On the other hand, if it is determined in decision  that the previous movement was in a first direction, operations similar to those of operation - are carried out. In particular, the line equations are evaluated at the points of the convex region, e.g. a rectangle, in operation . It is then determined in decision  as to whether sense points of a second side of the rectangle are both outside an edge of the primitive. If not, the sense points are moved or stepped in the second direction in operation . Upon it being determined that the sense points of the second side of the rectangle are both outside an edge of the primitive, it is then determined in decision  whether the points can be moved downwardly or, in other words, whether the current position constitutes a jump position. If so, a jump position is calculated and stored in operation  after which the process is done.",{"@attributes":{"id":"p-0279","num":"0298"},"figref":"FIG. 29A","b":"29"},"Generating pixels that are near recently previously generated pixels is important when recent groups of pixels and\/or their corresponding texture values are kept in memories of a limited size. The boustrophedonic sequence more often finds the pixels or texture values already loaded into such memories, and therefore repeating the memory load occurs less often.","As an option, at least one boundary might be used which divides the primitive into a plurality of portions prior to rasterization. In operation, the points might be moved in each of the portions separately. Further, the points might be moved through an entirety of a first one of the portions before being moved in a second one of the portions.",{"@attributes":{"id":"p-0282","num":"0301"},"figref":["FIG. 30","FIG. 30","FIG. 27"],"b":"3000"},"With continuing reference to , an additional decision  follows the completion of every portion of the primitive. In particular, it is determined in decision  whether a start position of an adjacent portion was found in operation . If so, the convex region defined by the sense points is moved to a start position of an adjacent portion of the primitive in operation  and operations - are repeated for the new portion of the primitive. Further information relating to the determination of the start position in operation  will be set forth in greater detail during reference to FIG. .",{"@attributes":{"id":"p-0284","num":"0303"},"figref":"FIG. 31A","b":"30"},{"@attributes":{"id":"p-0285","num":"0304"},"figref":["FIG. 31","FIG. 29"],"b":["3006","30","3118","3121","3118","3120"]},"In operations  and , starting positions of adjacent portions of the primitive are sought and stored when it is determined in decisions  and  that any sense points of the convex region have passed any boundary, respectively. As shown in , such starting positions  are each defined as being the topmost point of a portion of the primitive existent beyond a boundary. By storing this position, a starting point is provided when the process is repeated for the adjacent boundary-defined portion of the primitive.","It should be noted that operations  and  are both performed while processing the first portion of the primitive. While not expressly shown in , only a first one of such operations is performed when processing portions to the left of the first portion, while only a second one of such operation is performed when processing portions to the right of the first portion. In other words, when processing portions to the left of the first portion, starting positions are only determined when a leftmost boundary of the currently processed portion has been exceeded. Similarly, when processing portions to the right of the first portion, starting positions are only determined when a rightmost boundary of the currently processed portion has been exceeded.","Using boundaries during rasterization solves a very critical problem during pipeline processing. If a primitive is very wide, the storage associated with the pixels of a single row might not fit in a limited-size memory. Rasterization with boundaries divides the triangle into limited-width rows (or columns), and generates all the pixels within such a portion before moving on to the next portion.","For example, even if a triangle is 100 pixels wide, a limited-size pixel or texture memory might only hold information for the previous 20 pixels. Constraining the pixel sequence to stay within ten-pixel-wide vertical portions allows all the pixels on the previous and current rows to fit in the memory. This means that a boustrophedonic sequence within a boundary-defined portion would always have the previous pixel on the current row (if any) in the memory, as well as the pixels in the row above (if any) in the memory as well.","Most underlying memory systems transfer blocks of data with a certain overhead per block. Small accesses to the memory system are penalized heavily by this overhead. In order to be efficient, larger accesses are employed and the rest of the block is maintained in case it might be used next. Beyond that, a cache memory system keeps a plurality of these recent blocks, increasing the probability that memory accesses can be avoided.","The boustrophedonic sequence of the present invention exploits the single-retained-block concept when it reverses and handles pixels immediately below one end of the current line. Further, the boustrophedonic sequence exploits cache when it limits rasterization to portions of a particular size. Specifically, two scanlines within a portion should fit in the cache, so throughout the second scanline, benefits might be incurred from cache storage of the first scanline.","There is no constraint on the sequence or number of boundary-defined portions. Although the present description uses the example of vertical portions and a horizontal boustrophedonic pattern, similar principles might extend to horizontal portions, vertical boustrophedonic patterns or even to diagonal portions and patterns. In one embodiment, the length of the strings (e.g. rows, columns, diagonals, etc.) might be each limited to be less than a dimension of the primitive along which the string resides.",{"@attributes":{"id":"p-0293","num":"0312"},"figref":"FIG. 32","b":["2702","27"]},"As shown in , a primitive is first received that is defined by a plurality of vertices. Each of such vertices includes a W-value. Upon the receipt of the primitive, the set-up module serves to define lines that characterize the primitive based on the vertices. Note operation .","The W-values are then analyzed in decision . As shown, if one of the W-values is negative, a line equation for a line opposite the vertex having the negative value is flipped in operation . In other words, the coefficients of the line equation are multiplied by \u22121. Further, if two of the W-values are negative, line equations for lines connecting the vertex having a positive W-value and each of the vertexes having negative W-values are flipped in operation . If three of the W-values are negative, a cull condition  occurs where the present invention culls the triangle. Still yet, if none of the W-values are negative, no additional action is taken.",{"@attributes":{"id":"p-0296","num":"0315"},"figref":["FIGS. 32A-33","FIG. 32A"]},{"@attributes":{"id":"p-0297","num":"0316"},"figref":"FIG. 32B"},{"@attributes":{"id":"p-0298","num":"0317"},"figref":["FIG. 33","FIGS. 27-32"]},"The present invention is thus capable of handling all three of the foregoing cases. If part of the triangle is beyond the near and\/or far plane, it draws only the portion within those planes. If the triangle has one or two negative Z vertexes, only the correct +Z portion is drawn.","Even if all vertexes are off-screen, and the triangle extends from behind the eye to beyond the far plane, whatever pixels are inside the triangle and on the screen and have Z between the near and far limits. The present invention ensures that little time is wasted exploring bad pixels. This is possible because all clipping, by screen edge or the near or far plane, always results in a convex region on-screen which can be explored easily.","A problem sometimes arises when the starting point is not inside the area to be filled. This can occur if the top vertex is off-screen or is clipped by the near or far plane. In this case, the traversal stage must search for the top point of the drawn region, starting from above. It can do this efficiently by being guided by the signs of the triangle edge slopes and the Z slope. It can test the triangle line equations to discover it is outside the drawn region and why. When it knows what edge(s) and\/or Z limit it is outside of, it knows what direction(s) to step that brings it closer to that edge or limit. By moving horizontally in preference to vertically (when there is a choice), searching for the drawn region guarantees it finds the top drawable pixel if there is one. This problem also occurs with external (\u2212W) triangles that open up. In this case, the drawn area extends above all three vertexes.","In one embodiment of the present invention, traversal proceeds from top to bottom of the triangle. The starting point is the top vertex of the triangle if none have a negative W-value and the top vertex is in the scissor rectangle. Otherwise, a point on the top of the scissor rectangle is chosen. Since traversal always begins within the scissor rectangle and never ventures out of it, only the portion of the triangle within the scissor rectangle is ever drawn, even if the area enclosed by the edges extends far beyond the scissor rectangle. In, this way, simple scissor rectangle-edge clipping is effected.","Descriptions will now be set forth regarding the tessellation module  and other related components of FIG. A. Table 19 illustrates the various commands that may be outputted by the tessellation module  and received by the primitive assembly module . Of course, this list of commands set forth in Table 19 is for illustrative purposes only, and should not be construed as limiting in any manner. To this end, the tessellation module  controls the manner and fashion in which triangles are formed (efficiently) from the stream of vertices it produces.",{"@attributes":{"id":"p-0304","num":"0323"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 19"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"NO_PRIM"]},{"entry":[{},"STRIP"]},{"entry":[{},"FAN"]},{"entry":[{},"LOAD"]},{"entry":[{},"USE"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In use, the tessellation module  of  is adapted to simply pass the inputted data when disabled, and output tessellated data when enabled. When tessellation commences, the NO_PRIM command is sent to the primitive assembly module . As such, the tessellation module  is capable of utilizing the vertex file  to temporarily store incoming vertices in vertex file locations as instructed, without producing any triangles. During operation, the tessellation module  may evaluate any primitive, triangle, polynomial, subdivision, etc. The outputted data is used to form triangles to approximate the primitive being tessellated by sending the NO_PRIM, STRIP, FAN, LOAD, and USE commands to the primitive assembly module .",{"@attributes":{"id":"p-0306","num":"0325"},"figref":"FIG. 34","b":["3400","51","0","22","55","52","54"]},"For example, data representing a first row of vertices may be loaded into the vertex file  in response to the execution of the LOAD command. During the processing of the following rows, the STRIP and FAN commands may be used to form triangles from the vertices computed by the tessellation module , and subsequently processed by the transform and lighting modules  and . Further, various vertices stored in the vertex file  may be retrieved and reused using the USE command.","Logic in the tessellation module  thus produces a stream of commands that control the primitive assembly module  and cause it to form triangles from the stream of vertices produced by the tessellation module .","As an option, a mode bit may be used in association with the STRIP and FAN commands to indicate a clockwise or counterclockwise function. Because of the order in which the vertices are produced, it is necessary to draw both clockwise and counter-clockwise triangle fans. Note FIG. . The individual triangle fans are highlighted, as is the order in which the vertices are used by the primitive assembly module  to form triangles. The vertices are produced in a fixed order due to the characteristics of evaluation algorithms used. In general, it is important that primitive assembly module  be flexible in this respect. In other words, it should be able to receive vertices in an order dictated by other algorithms, e.g. tessellation algorithms.","Table 20 illustrates an exemplary set of commands that may be outputted from the tessellation module  to the primitive assembly module  for generating the data in FIG. .",{"@attributes":{"id":"p-0311","num":"0330"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 20"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"no prim"]},{"entry":[{},"load 0 (v0)"]},{"entry":[{},"load 1"]},{"entry":[{},"load 2"]},{"entry":[{},"load 3"]},{"entry":[{},"load 4"]},{"entry":[{},"load 5"]},{"entry":[{},"load 6"]},{"entry":[{},"load 7"]},{"entry":[{},"load 8"]},{"entry":[{},"ccwfan"]},{"entry":[{},"load 9"]},{"entry":[{},"use 0"]},{"entry":[{},"use 1"]},{"entry":[{},"ccwfan"]},{"entry":[{},"load 0 (v10)"]},{"entry":[{},"use 1"]},{"entry":[{},"use 2"]},{"entry":[{},"use 3"]},{"entry":[{},"load 1 (v11)"]},{"entry":[{},"ccwfan"]},{"entry":[{},"use 1"]},{"entry":[{},"use 3"]},{"entry":[{},"use 4"]},{"entry":[{},"use 5"]},{"entry":[{},"load 2 (v12)"]},{"entry":[{},"ccwfan"]},{"entry":[{},"use 2"]},{"entry":[{},"use 5"]},{"entry":[{},"use 6"]},{"entry":[{},"use 7"]},{"entry":[{},"load 3 (v13)"]},{"entry":[{},"ccwfan"]},{"entry":[{},"use 3"]},{"entry":[{},"use 7"]},{"entry":[{},"use 8 cwfan"]},{"entry":[{},"use 9"]},{"entry":[{},"load 4 (v14)"]},{"entry":[{},"load 5 (v15)"]},{"entry":[{},"use 0"]},{"entry":[{},"cwfan"]},{"entry":[{},"use 0"]},{"entry":[{},"use 5"]},{"entry":[{},"load 6 (v16)"]},{"entry":[{},"load 7 (v17)"]},{"entry":[{},"use 1"]},{"entry":[{},"cwfan"]},{"entry":[{},"use 1"]},{"entry":[{},"use 7"]},{"entry":[{},"load 8 (v18)"]},{"entry":[{},"load 9 (v19)"]},{"entry":[{},"use 2"]},{"entry":[{},"cwfan"]},{"entry":[{},"use 2"]},{"entry":[{},"use 9"]},{"entry":[{},"load 0 (v20)"]},{"entry":[{},"load 1 (v21)"]},{"entry":[{},"use 3"]},{"entry":[{},"cwfan"]},{"entry":[{},"use 3"]},{"entry":[{},"use 1"]},{"entry":[{},"load 2 (v22)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"As shown, the FAN command connects a first vertex with a plurality of other vertices that are indicated by the LOAD and USE commands. Again, the USE command may be executed whenever a vertex has already been loaded into the vertex file  using the LOAD command.",{"@attributes":{"id":"p-0313","num":"0332"},"figref":"FIG. 35","b":["3500","0"]},"With the foregoing integration, the combined tessellation and transform integration may afford improved quality by way of finer tessellations. At least two things make the finer tessellation possible. For example, there is reduced bandwidth from a host since the triangles are generated on-chip and don't have to travel along a bus from the host. Further, the tessellation module  uses the vertices very efficiently, generating more than one triangle per vertex transformed. This allows one to get more out of transform performance. Applications can thus take advantage of these and other capabilities by invoking the corresponding feature associated with the single semiconductor platform via a standard interface, as set forth earlier.",{"@attributes":{"id":"p-0315","num":"0334"},"figref":"FIGS. 36-41","b":["51","1"]},{"@attributes":{"id":"p-0316","num":"0335"},"figref":"FIG. 36","b":["3649","3650","3652","3656","3649"]},{"@attributes":{"id":"p-0317","num":"0336"},"figref":"FIG. 37","b":["3700","3701","3700","3703","3702","3704","3703","3705"]},"Circumnavigating the interior mesh  is a plurality of surrounding meshes  which are defined along sides of the interior mesh . The surrounding meshes  serve to accommodate for any change of tessellation, or discontinuity, between the interior mesh  and the perimeter of the surface . In addition to the surrounding mesh , there are meshes  crossing the interior of the patch, which also border regular mesh . These meshes permit the number of rows\/columns in the interior meshes , to be varied (increased\/decreased) without popping. The meshes  are a fraction of the height\/width of the rows\/columns of .","In one embodiment, the interior sides  of the surrounding meshes  each include a number of segments  equal to the corresponding predetermined number of rows or columns of the interior mesh . It should be noted that the segments  are defined as portions of the strip curves  situated between the vertices . Further, the exterior sides  of the surrounding meshes  each include a plurality of equally sized segments  and at least one fractional segment  that is a fraction of the equally sized segments .","With this configuration, a pattern of triangles is used that permits the number of triangles to be varied continuously from frame to frame while accommodating incremental evaluation techniques such as forward differencing. The scheme permits new vertices to be introduced (removed) at existing vertices, thus avoiding popping. Further, the independent tessellation factors permit applications to avoid cracking. Because the tessellation pattern is symmetric, no gaps can occur if equal tessellation factors are specified.","The foregoing description has been focused on a single interior mesh  with four surrounding meshes . In another aspect of the present invention, the interior mesh  and the surrounding meshes  may define one of a plurality of equally sized and shaped portions  of the surface . Also, the fractional segments  of each of the portions  may be positioned adjacent a midpoint  of a side of the surface . As an option, a width  of the surrounding meshes  may be equal to a width  of the rows or columns of the interior mesh . Note FIG. .",{"@attributes":{"id":"p-0322","num":"0341"},"figref":"FIG. 38","b":["37","3800","3710","3701","3700"]},"Next, in operation , the surface is divided into four (4) quadrants.  illustrates the surface  prior to being divided into quadrants in accordance with operation  of FIG. . As shown, each of the sides of the surface  is defined as A, B, C, and D; and the vertical and horizontal dimensions of the surface  are defined as E and F, respectively.  illustrates the surface  after being divided into quadrants in accordance with operation  of FIG. . It should be noted that the surface  is divided at the parametric midpoints to generate quadrants , , , and .","With continuing reference to , the quadrants defined in operation  are then labeled in operation .  illustrates the labeling of the quadrants in accordance with operation  of FIG. . As shown, quadrant  includes sides designated as A\/, F\/, D\/ and E\/ which correspond to their length with respect to the corresponding sides\/dimensions of the surface  set forth in FIG. A. In a similar manner, quadrant  includes sides designated as E\/, F\/, D\/ and C\/. Quadrants  and  may be labeled in a similar manner. It should be noted that the direction of rendering may optionally be defined at this point. Specifically, tessellation and rendering are designated to occur along each side in a direction toward a midpoint of a side of the surface  (for exterior sides A, B, C, D), or toward a center of the surface  (for interior sides E, F). Note the direction of arrows in FIG. C.","Subsequently, in operation  of , the tessellation pattern is defined based on the input specifications and the labeling of operation . In particular, the vertex arrangement of the interior mesh  is uniformly defined simply by the number of rows and columns indicated by the input specifications received in operation . Further, the tessellation pattern of the sides of each quadrant is defined by determining a number of the equally sized segments  and a length of the fractional segment .","In the case of quadrant  of , the number of equally sized segments  is determined by calculating an integer component of each side. For example, in the case of side A, the number of segments associated therewith is Int(A). Further, the length of the fractional segment  is determined by calculating the fractional component of each side, Frac(A)=A\u2212Int(A). Similar calculations may be made for each side of each quadrant. Also, such values may be verified by utilizing Equation #1 set forth below.\n\n()*1+[Frac()]\/1 \u2003\u2003Equation #1\n",{"@attributes":{"id":"p-0327","num":"0346"},"figref":"FIG. 38D","b":["3705","3714","3716","3716"]},"With the vertices  and segments ,  of the interior mesh  and the sides of the quadrant defined, the vertices are stitched in operation  of FIG. . This is carried out by starting at an end vertex of a side of the interior mesh , where the end vertex is situated opposite the fractional segment . The vertices of the interior mesh and the exterior side of the surface  are then connected, or \u201cstitched,\u201d in a zigzag manner.",{"@attributes":{"id":"p-0329","num":"0348"},"figref":["FIGS. 38E","FIGS. 38E and 38F","FIG. 38G"],"b":["38","38","3706","3714","3716","3700","3850","3851","3851","3706","3714","3716","3700"]},{"@attributes":{"id":"p-0330","num":"0349"},"figref":"FIG. 39","b":["3900","3700","3706","3700","3900","3700","3900","3700","3902","3900","3904","3700"]},"Further, the exterior sides of the surrounding meshes  may each include two or more (preferably an even number) fractional segments  that are a fraction of the equally sized segments. Unlike the previous embodiment, the fractional segments may be positioned at both ends of the exterior sides of the surrounding meshes . The present embodiment thus affords one single interior mesh  as opposed to the multiple interior meshes  of the previous embodiment of FIG. . Any discrepancies are then handled by the transition mesh .",{"@attributes":{"id":"p-0332","num":"0351"},"figref":"FIG. 40","b":["4000","4000","37"]},"It should be noted that the present invention may be implemented in even and odd parity. By even and odd parity, it is meant that there are either always an even number of segments on an external side, or an odd number of segments. In the case of an even number the number of rows and columns of the interior mesh is fractional albeit strictly rows and columns. In the odd parity case, there is also a regular mesh on the interior, also fractional. In the even parity case, the fractional rows\/columns cross the center. In the odd case the fractional rows is at the perimeter of the regular mesh.",{"@attributes":{"id":"p-0334","num":"0353"},"figref":"FIG. 41","b":"4100"},{"@attributes":{"id":"p-0335","num":"0354"},"figref":"FIGS. 42-50","b":["51","1"]},{"@attributes":{"id":"p-0336","num":"0355"},"figref":"FIG. 42","b":["4200","4200","4201","4201"]},"A vertex memory  is coupled to the transform and lighting module  for storing vertices of the primitives that have been processed by the transform and lighting module . As is well known to those of ordinary skill, the vertex memory  enables reuse of calculated or transformed vertices in order to afford accelerated operation. Coupled to the vertex memory  is a primitive assembly unit  that assembles the primitives in preparation for a rendering using a rasterizer (not shown).",{"@attributes":{"id":"p-0338","num":"0357"},"figref":"FIG. 42A","b":["4200","42","4200","4205","4206","4208","4206","4210","4211","4210","4212","4214","4216","4211","4218","42"]},"For integrating guard curves into the forward differencing procedure, start and end guard curve memory banks  are coupled between the input  and the second set of multiplexers . By this structure, the forward differencing engine  is capable of operating on four polynomials in parallel. It should be noted that there is a polynomial for each vertex component, and there may actually be many polynomials active with the parallel adder evaluating four at a time. Normally, the four polynomials evaluated in parallel correspond to x, y, z and w position components or s, t, r and q texture components.","In operation, the forward differencing engine  initiates four floating point additions every clock, and stores the result in one of the addends . The next level of granularity of operation is the-evaluation of a vertex which is permitted to vary polynomially. During use, the memory banks  contain the forward difference coefficients corresponding to each of vertex components that are varying. In one embodiment, a 64-bit register (not shown) may be used to program the configuration of the memory banks , determine the exact method to evaluate a vertex, specify the destination of each vertex component, and determine the ultimate position of each vertex component within an output vertex (not shown).",{"@attributes":{"id":"p-0341","num":"0360"},"figref":["FIG. 42B","FIGS. 42 and 42A"],"b":["4250","4206","4220","42"]},"The forward differencing engines  and  of  are adapted to calculate normal and position values during operation. In various alternate embodiments, other vertex component values, i.e. colors, texture, etc., may be handled by the present invention. Normal values are computed by the forward differencing engine  and normalized by a transform and lighting module . The normal values are computed by evaluating the parametric partial derivatives of the surface patch, and calculating a cross product thereof. Exemplary pseudo-code for vertex and normal calculation is shown in Table 21 below. It should be noted that in various alternate embodiments, partials need not necessarily be evaluated.",{"@attributes":{"id":"p-0343","num":"0362"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 21"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"ComputeVertexAndPartials () {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"coefIndex = 0;"]},{"entry":[{},"\/\/is the normal present?"]},{"entry":[{},"if (ComputeNormal) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/write the current partial derivative"]},{"entry":[{},"CrossProductPu = Bank [coefIndex];"]},{"entry":[{},"For (j = 0; j < Degree[0]; j++) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Bank [coefIndex] += Bank[coefIndex+1];"]},{"entry":[{},"coefIndex++;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"\/\/ step past the constant coefficient"]},{"entry":[{},"coeffIndex++;"]},{"entry":[{},"\/\/write the other current partial"]},{"entry":[{},"CrossProductPv = Bank[coefIndex];"]},{"entry":[{},"\/\/ one lower than first"]},{"entry":[{},"For (j = 0; j < Degree[0] \u22121; j++) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Bank[coefIndex] += Bank[coefIndex+1]"]},{"entry":[{},"CoefIndex++;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"\/\/ step past the constant coefficient"]},{"entry":[{},"coefIndex++;"]},{"entry":[{},"\/\/ set so next vertex component is \u201c2\u201d"]},{"entry":[{},"start = 1;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} else {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"start = 0;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"\/\/for each possible vertex component"]},{"entry":[{},"for (i = start; i < NUMBER_OF_COMPONENTS; i++) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ write out the current value"]},{"entry":[{},"IBuff[IBuffLoc[i]] = Bank[coefIndex];"]},{"entry":[{},"\/\/ compute the new component"]},{"entry":[{},"for (j = 0; j < Degree[i]; j++) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Bank[coefIndex] += Bank[coefIndex+1];"]},{"entry":[{},"coefIndex++;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"\/\/ step past the constant coefficient"]},{"entry":[{},"coefIndex++;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0344","num":"0363"},"figref":"FIG. 43","b":["4300","4302","4300","4302","4300"]},"As shown in , the guard curve  along the right edge of the left-hand patch is identical to the strip curve  along the left edge of the right-hand patch. When a strip is tessellated, the first and last vertex positions of the strip are overwritten by the values computed from the guard curves , thus guaranteeing that adjacent tessellations match exactly.",{"@attributes":{"id":"p-0346","num":"0365"},"figref":["FIG. 44","FIG. 43","FIGS. 43 and 43A"],"b":["4400","4300","4402","4302","4404","4302"]},"Next, at least one guard curve  associated with the patch is generated in operation . The guard curve  is positioned along ends of the strip curves  and in a second predetermined direction that is perpendicular with respect to the first predetermined direction in parameter space. Such guard curve  prevents vertex mismatches when tessellating curved surfaces into triangles in the manner set forth during reference to FIG. . During some use, two guard curves  may be consistently used for each patch, as shown in FIG. .",{"@attributes":{"id":"p-0348","num":"0367"},"figref":["FIG. 45","FIG. 5"],"b":["4510","43","4510"]},"As shown in , the reversed strip curve  differs from the guard curves of  in that it is not perpendicular to the strip curves. While the guard curves overwrite values already computed by the strip curves, the reversed strip curves directly compute all values\/vertex components and no overwriting necessarily occurs.","As shown in , each of the strip curves  of the surface patch  may be optionally broken up into a plurality of segments . It should be noted that a size of the segments  are determined based on a size of the vertex memory  of the graphics pipeline system. For example, if the vertex memory  were capable of handling 20 vertices, the strip curves  would be broken up into 20 segments . Further, the segments  are started at a starting point  of the associated evaluation direction of the strip curve  such that any fractional segment  is positioned adjacent an ending point  of the associated evaluation direction. A similar process is executed for the guard curve .","In order to afford optimum tessellation, the vertices of the strip curve  adjacent to the reversed strip curve  are loaded into the vertex memory  differently than those of the reversed strip curve . In particular, the vertices associated with each of the strip curves  are each loaded in a first predetermined order . In contrast, the vertices associated with the reversed strip curves  are each loaded in a second predetermined order . It should be understood that the position and normal values are merged with the strip curves  before transform and lighting, and only a single position is transformed.",{"@attributes":{"id":"p-0352","num":"0371"},"figref":"FIG. 46","b":["4202","4600","4602","4600","4202","4602","4600","4603","4202","4603","4600","4202"]},"Further, a length  of the guard curves  is determined based on a size of a vertex memory  into which vertices of the primitives are loaded.","Specifically, the length  of the guard curve  is set such that each vertex of the guard curve  fits within the vertex memory . As such, the guard curves  are handled in a manner similar to that of the strip curves  such that a side of a surface patch may include a plurality of collinear guard curves .","The technique set forth in  thus defines multiple \u201cswaths\u201d  to accommodate situations where there are more vertices in a row than will fit in the vertex memory . In , the patch is rendered in four swaths . The coefficients of the strip curves  are computed by the host and then evaluated by the forward differencing engine . The values at the heads of the strip curves  are computed as the result of iteration in the forward differencing engine . The values at the tails of the strip curves  are computed by the host, likely the result of iterating curve definitions one to the next.","As a result, the values at the heads of the strip curves  are not equal to their logical equivalents at the tails of the next strip curve . Again, the host may supply a guard curve  to evaluate along the start and end of the strip curves . It should also be noted that because a guard curve can correspond to a strip curve, a guard curve may only generate as many vertices as can a strip curve. It is this constraint that results in a swath  being broken into multiple swatches .",{"@attributes":{"id":"p-0357","num":"0376"},"figref":["FIGS. 47-50","FIGS. 47-48"],"b":["4800","4802","4804","4802"]},{"@attributes":{"id":"p-0358","num":"0377"},"figref":["FIG. 49","FIG. 50"],"b":["4900","4804","4902","4800"]},"The present invention thus uses a consistent direction of edge traversal of a patch by performing the floating-point operations in the same order. This results in the avoidance of pixel dropouts and rendering artifacts. Consistency is required to guarantee the same values are generated for points on an edge shared by two patches that abut. The consistency requirement forces the introduction of additional commands\/primitives, and transition regions in patches that would otherwise not require them; a patch with a \u201creversed\u201d edge requires a transition. The direction of traversal of an edge must be determined from the edge definition itself.","The present invention thus ensures that the floating point calculations are done on the same processor. For example, an Intel\u00ae PentiumIII\u00ae will not necessarily calculate the same result as computed by the floating point adder of the present invention. In one embodiment, the host may compute forward difference curve coefficients, and the ASIC may evaluate curves and stitch them together. As such, the ASIC may have some, but little, notion of a patch. It should be understood that the calculations may be carried out on any application specific or software-governed hardware per the desires of the user.",{"@attributes":{"id":"p-0361","num":"0380"},"figref":"FIGS. 51-53","b":["51","1"]},{"@attributes":{"id":"p-0362","num":"0381"},"figref":"FIG. 51","b":["5100","5100","5102","5103","5104","5106","5103","5103","5104","5106"]},"With continuing reference to , coupled to the quadrilateral patch tessellator  is the patch conversion module . In operation, the patch conversion module  is adapted for converting triangular patches into a form suitable for being rendered using a graphics pipeline adapted to render quadrilateral patches. In particular, the patch conversion module  converts the triangular patches into a plurality of quadrilateral patches that the quadrilateral patch tessellator  is equipped to handle.","The conversion, or reparameterization, of the triangular patches is such that all of the geometric properties of the original patch are preserved. Further the reparameterization is free of the problematic singularities required by some prior art techniques. It should also be noted that the triangular patches are characterized using polynomials of various degrees. In one embodiment, the conversion may also leave the degree of the patches unchanged, i.e. it does not increase. By way of example, the reparameterization may be characterized as follows: Given a triangular patch, T(u, v), the variables u and v are replaced using the expressions: \n\n\nIt should be noted that if the parameter value pair (0,0),(0,1),(1,0),(1,1) are substituted for s and t, the expected parameter value pairs for u and v are as follows: (0,0),(0,1\/2),(1\/2,0),(1\/3\/,1\/3).\n",{"@attributes":{"id":"p-0365","num":"0384"},"figref":["FIG. 52","FIG. 51"],"b":["5200","5102","5202","5204","5103","5206"]},{"@attributes":{"id":"p-0366","num":"0385"},"figref":"FIG. 53","b":["5200","52","5300","5302","5302"]},"As an option, one corner  of each quadrilateral patch  may be positioned at a midpoint of a side of the triangular patch . Further, one corner of each quadrilateral patch  may be positioned at a centroid  of the triangular patch . It should be understood that in various other embodiments, the corners may be positioned in any desired location. Further, the number of quadrilateral patches may vary per the desires of the user.","One constraint that may be imposed on the boundaries of the quadrilateral patches  is that they form a convex region of four sides, each of which is a straight line in the parameter space of the triangular patch . As an option, each side of the quadrilateral patches  may be linear in parameter space. Further, in one embodiment, a single vertex may be situated on the interior of the triangle, and one vertex on each of the three sides of the triangular patch . Note FIG. .","While various embodiments have been described above, it should be understood that they have been presented by way of example only, and not limitation. Thus, the breadth and scope of a preferred embodiment should not be limited by any of the above-described exemplary embodiments, but should be defined only in accordance with the following claims and their equivalents."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing and other aspects and advantages are better understood from the following detailed description of a preferred embodiment of the invention with reference to the drawings, in which:",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 2C","FIG. 2B"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 4A"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 4B","FIG. 4A"]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 6","FIG. 5"]},{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 7","FIG. 5"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 8","FIG. 5"]},{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 9","FIG. 5"]},{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 10","FIG. 5"]},{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 11","FIG. 5"]},{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 12","FIG. 5"]},{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 13","FIG. 12"]},{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 14","FIG. 12"]},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 14A"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 14B","FIG. 14A","FIG. 5"],"b":"1451"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 14C","FIG. 14A"],"b":"1453"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 14D","FIG. 12"]},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 16","FIG. 15"]},{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 17","FIG. 16"]},{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 18","FIG. 16"]},{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 19","FIG. 16"]},{"@attributes":{"id":"p-0048","num":"0047"},"figref":["FIG. 20","FIG. 16"]},{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 21","FIG. 16"]},{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 22","FIG. 16"]},{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 23","FIG. 16"]},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 25","FIG. 24"]},{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 25A","FIG. 1B"]},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIG. 26A","FIG. 26"]},{"@attributes":{"id":"p-0057","num":"0056"},"figref":["FIG. 27","FIG. 26"]},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 27A"},{"@attributes":{"id":"p-0059","num":"0058"},"figref":["FIG. 28","FIG. 27"],"b":"2706"},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 28A"},{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 28B"},{"@attributes":{"id":"p-0062","num":"0061"},"figref":["FIG. 29","FIG. 27"],"b":"2706"},{"@attributes":{"id":"p-0063","num":"0062"},"figref":["FIG. 29A","FIG. 29"]},{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0065","num":"0064"},"figref":["FIG. 31","FIG. 30"],"b":"3006"},{"@attributes":{"id":"p-0066","num":"0065"},"figref":["FIG. 31A","FIGS. 30 and 31"]},{"@attributes":{"id":"p-0067","num":"0066"},"figref":["FIG. 32","FIG. 27"],"b":"2702"},{"@attributes":{"id":"p-0068","num":"0067"},"figref":["FIG. 32A","FIG. 32"]},{"@attributes":{"id":"p-0069","num":"0068"},"figref":["FIG. 32B","FIG. 32"]},{"@attributes":{"id":"p-0070","num":"0069"},"figref":["FIG. 33","FIG. 32"]},{"@attributes":{"id":"p-0071","num":"0070"},"figref":["FIG. 34","FIG. 1A"]},{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 35"},{"@attributes":{"id":"p-0073","num":"0072"},"figref":["FIGS. 36-41","FIG. 1A"]},{"@attributes":{"id":"p-0074","num":"0073"},"figref":["FIGS. 42-50","FIG. 1A"]},{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIGS. 51-53","b":"1"}]},"DETDESC":[{},{}]}
