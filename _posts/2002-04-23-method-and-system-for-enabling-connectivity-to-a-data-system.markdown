---
title: Method and system for enabling connectivity to a data system
abstract: A method and system that provides filtered data from a data system. In one embodiment the system includes an API (application programming interface) and associated software modules to enable third party applications to access an enterprise data system. Administrators are enabled to select specific user interface (UI) objects, such as screens, views, applets, columns and fields to voice or pass-through enable via a GUI that presents a tree depicting a hierarchy of the UI objects within a user interface of an application. An XSLT style sheet is then automatically generated to filter out data pertaining to UI objects that were not voice or pass-through enabled. In response to a request for data, unfiltered data are retrieved from the data system and a specified style sheet is applied to the unfiltered data to return filtered data pertaining to only those fields and columns that are voice or pass-through enabled.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07058890&OS=07058890&RS=07058890
owner: Siebel Systems, Inc.
number: 07058890
owner_city: San Mateo
owner_country: US
publication_date: 20020423
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE ILLUSTRATED EMBODIMENTS","LISTING 1","LISTING 2","LISTING 3","EXEMPLARY SERVER COMPUTER SYSTEM","APPENDIX"],"p":["The present application is based on a provisional application entitled \u201cMETHOD AND SYSTEM FOR ENABLING VOICE CONNECTIVITY TO A DATA SYSTEM,\u201d Ser. No. 60\/356,713, filed on Feb. 13, 2002, the benefit of the filing date of which is claimed under 35 U.S.C. \u00a7119(e).","1. Field of the Invention","The present invention relates to data systems in general, and an interface to provide filtered data from a data system in particular. In one embodiment, the interface facilitates voice access to a data system.","2. Background Information","Recently, the development of new technologies in the telephony and speech recognition areas has enabled data systems to be accessed via voice (e.g., spoken verbal input). Such voice-enabled data systems let users navigate to request a particular piece of data or a related set of data using voice commands, and then \u201creads back\u201d the data to the user. These types of data systems are widely used in information systems in various industries, including banking, insurance, investments, etc.","In general, in order to provide voice access to a data system, a complete voice interface has to be developed from scratch. This typically involves integrating various hardware and software components, such as telephony interfaces, multi-channel access equipment, speech recognition software, text-to-speech (TTS) software and hardware, and other related components. In addition, a dedicated application must be written to interact with the various hardware and software components, and to provide interface and navigation facilities for voice access. This can be a very daunting task, requiring a team of IT professionals that are savvy in many specialized areas.","Several vendors now provide integrated voice-access systems that handle the voice-to-computer aspects of a voice-enabled data system. For example, these integrated systems handle telephony connectivity to a phone network, perform speech recognition to convert voice commands and verbalized data requests to a computer-readable form (e.g., ASCII text or binary text form), and handle the TTS functions.","Although these integrated voice-access systems provide a lot of the workload, they still require an application program to enable access to the data system. Typically, the application program is data-system specific, requiring specific navigation and database queries to be written. As a result, the inner-workings of the data system need to be known in detail.","In view of the foregoing, it would be advantageous to provide an \u201cinterface\u201d that would enable data system vendors and third parties to easily integrate voice access to existing data systems by using an integrated voice-access system combined with an application program that is much simpler to implement and doesn't require all of the inner-workings of the data system to be known.","In addition to voice access systems, there are many other instances in which it would be advantageous to access selected data sets from within data systems. For example, many data systems provided integrated access interfaces, such as client user interfaces, to enable users to access data stored in the data system via a client computer connected to the data system via a computer network. Generally, these client user interfaces are provided by the data system vendor, and generally provide a limited, predetermined set of user interface objects, such as screens, lists and forms. In contrast, a third party vendor or business enterprise may desire to build a customized user interface for the data system. To facilitate such implementations, it would be advantageous to provide a mechanism to retrieve filtered data from data systems.","A method and system that provides filtered data from a data system. In one embodiment the system includes an API (application programming interface) and associated software modules to enable third party applications, such as voice applications, to access an enterprise data system. Administrators are enabled to select specific user interface (UI) objects, such as screens, views, applets, columns and fields to voice or pass-through enable via a graphical user interface (GUI). The GUI presents a tree depicting a hierarchy of the UI objects within a user interface of an application that is used to access a data system. An XSLT style sheet is then automatically generated to filter out data pertaining to UI objects that were not voice or pass-through enabled. The third party application accesses the data system using a data query request and one of the data system's existing interfaces, such as an HTTP or HTTPS interface, a COM interface, or a Java interface. In response to the request, unfiltered data are retrieved from the data system and a specified style sheet is applied to the unfiltered data to return filtered data pertaining to only those UI objects that are voice or pass-through enabled.","A system and method for providing filtered data from a data system is described in detail herein. In the following description, numerous specific details are disclosed, such as exemplary software and system architectures, to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize, however, that the invention can be practiced without one or more of the specific details, or with other methods, components, etc. In other instances, well-known structures or operations are not shown or described in detail to avoid obscuring aspects of various embodiments of the invention.","Reference throughout this specification to \u201cone embodiment\u201d or \u201can embodiment\u201d means that a particular feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus, the appearances of the phrases \u201cin one embodiment\u201d or \u201cin an embodiment\u201d in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore, the particular features, structures, or characteristics may be combined in any suitable manner in one or more embodiments.","The present invention provides a system and method for providing filtered data from a data system to a requesting component, such as a third party application. In the following discussion, details of embodiments pertaining to a voice access system are disclosed. The voice access system is used to illustrate a general data system access architecture in accordance with the invention. Accordingly, the use of the principles and teachings of the invention are not to be limited to voice access systems, but may be applied to any application or system outside of a data system that desires to receive filtered data from the data system.","A high-level architecture  in accordance with one embodiment of the invention is shown in . At the center of architecture  is a mobile connector interface  that enables third parties (referred to herein as \u201capplication vendors\u201d) to develop applications  that enable users  to access data stored in an enterprise data system .","In one embodiment, mobile connector interface  provides a mechanism for interacting with enterprise data system  via XML (extended markup language) data in accordance with predefined protocol and data formats that define parameters pertaining to the transferred XML data. These data include incoming XML data , which typically comprise XML data prescribing a data request that is received by enterprise data system , and outgoing XML data , which typically comprises XML data pertaining to data returned in response to the data request by enterprise data system .","In one embodiment, enterprise data system  includes an application server , which logically represents a collection of (generally) distributed software components and modules that define the business logic to enable external systems and users to access various data stored in a database  that hosts the data for the enterprise data system based on a pre-defined set of interfaces. Further details of the software components and modules corresponding to application server  are described below.","Typically, the enterprise data system will provide various means to access the data that it stores, such as client connections, as will be understood by those skilled in the database\/data system arts. Ideally, it is desired to enable voice access to the enterprise system in a manner that is substantially transparent to it. In one embodiment, each connection provided by the mobile connector appears to the enterprise data system as a \u201cnormal\u201d client connection, and as such, does not require any changes to the core software components that support the enterprise data system.","In one embodiment, software corresponding these core software components that control normal operations of enterprise data system  (i.e., operations involving interaction with the enterprise data system outside of voice access operations) can be logically structured as a multi-layered architecture , as shown in . In one embodiment, the logical multi-layered architecture provides a platform for common services  to support various applications that implement the architecture. These services may be logically partitioned into a user interface layer , an object manager layer , a data manager layer , and a data exchange layer .","In one embodiment, user interface layer  provides the screens, views, and applets that make up various user interfaces that are rendered on client machines that connect to the enterprise data system via a computer network based client connection to enable users of those client machines to interact with the enterprise data system. Generally, user interface layer  may be configured to support various types of clients, including traditional connected clients, remote clients, thin clients over an Intranet, Java thin clients on non-Windows-based operating systems, and HTML clients over the Internet, etc.","Object manager layer  is designed to manage one or more sets of business rules or business concepts associated with one or more applications and to provide the interface between user interface layer  and data manager layer . In one embodiment, the business rules or concepts can be represented as business objects. In one embodiment, the business objects may be designed as configurable software representations of the various business rules or concepts applicable to the data services provided by the embodiments of the invention described herein, as explained below in further detail.","Data manager layer  is designed to maintain logical views of underlying data stored in one or more databases  (e.g., database ) corresponding to a data storage layer , while allowing the object manager to function independently of the underlying data structures or tables in which data are stored. In one embodiment, the data manager provides certain database query functions, such as generation of structure query language (SQL) in real time to access the data. In one embodiment, data manager  is designed to operate on object definitions  stored in a repository file  corresponding to a database schema used to implement the data model for the system, as described in further detail below. Generally, the data exchange layer is designed to handle the interactions with one or more specific target databases and provide the interface between the data manager and those databases, via either generic (e.g., Open Database Connectivity (ODBC)) or native (e.g., Oracle Connection Interface (OCI)) database interface protocols.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 3","FIG. 3"],"b":["70","72","74","56","58","76","62"]},"In one embodiment, presentation services  may be designed and configured to support various types of clients and may provide them with user interface screens, views and applets. In one embodiment, application services  may include business logic services and database interaction services. In one embodiment, business logic services provide the class and behaviors of business objects and business components implemented by the application services. In one embodiment, database interaction services may be designed and configured to take the user interface (UI) request for data from a business component and generate the appropriate database commands (e.g., SQL queries, etc.) to satisfy the request. For example, the data interaction services may be used to translate a call for data into RDBMS-specific SQL statements.","A multi-layer architecture illustrating the relationships between business objects, business components, and database tables is shown in . A business object  sifting at the top layer passes various data access requests to business components , , and  to retrieve data pertaining to the business object from a database . For example, business object  may pertain to a contact object and business components , , and  are used to access data in a database  pertaining to contacts.","In one aspect, business components are objects that span data from one or more physical database tables and calculated values by referencing a base table and explicitly joining and linking other tables, including intersection tables, as depicted by tables - and -, each of which include a plurality of records . As explained in further detail below, each business component contains information for mapping to various data stored in those tables. More specifically, these mappings are between a requested object, such as a subject, and information pertaining to that object that are stored in the database table(s) to which the business component corresponds. In one embodiment, database schema information stored in repository file  is used by the business components in determining their table mappings.","A block diagram of a logical structure of a business component in accordance with one embodiment of the present invention is shown in . Each business component (e.g., , , ) may include a set of properties  that pertain to the respective business component (e.g., NAME, which specifies the logical name of the business component, TABLE NAME, which specifies the actual name of the underlying table, etc.). A business component also includes a set of fields , each of which may have a set of associated attributes or properties . For example, a field may include a NAME property that identifies the name of the field, a COLUMN NAME property that identifies the column of the underlying table to which the respective field is mapped, etc.","A high-level architecture  in accordance when an exemplary voice access system implementation of the invention is shown in . In this implementation a voice application A uses mobile connector interface  to enable users to verbally access data stored in an enterprise data system  via a phone . In further detail, a user of phone  is connected to a voice infrastructure component  via a phone network , such as a wireless phone network, land-line phone network, or the combination of the two. The voice infrastructure includes various hardware and software components that enable users to interact with voice application A via voice commands. Typically, these components will include a telephony interface , an automated speech recognition (ASR) component , and a text-to-speech (TTS) component . In one embodiment, voice application A uses a standard application programming interface  that enables the voice application to interact with voice infrastructure  using a predefine set of commands and data protocols specific to various voice access products. At present, several vendors provide voice access products that provide operations and services corresponding to voice infrastructure , including Avaya corporation (formerly Lucent) (telephony interfaces\/PXB switching) and Nuance corporation, Salt Lake City, Utah (speech recognition software).","The specific details and inner-workings of the voice infrastructure are beyond the scope of the invention. For the purpose of implementing architecture , it is assumed that an integrated voice access system will be deployed and\/or the IT professionals who implement the system have sufficient knowledge and skill to set up the voice infrastructure using readily available hardware and software components, such as those described above.","An architecture  illustrating further details of mobile connector interface  and other related components is shown in . The mobile connector interface comprises two separate but related components, including a Metadata Builder  and an Update Support component . The Metadata Builder is an administrative tool that will generally be run during an initial installation and may be run again if the object definitions  stored in the repository file have changed. The Update Support component is a runtime component that is run at the discretion of voice application A, as explained below in further detail.","In addition to Metadata Builder  and Update Support component , architecture  further includes a Web engine , a reference or application vendor GUI (graphical user interface) component , a Siebel\u00ae COM or Java interface  and a HTTP(S) interface . Web engine  is used to provide an interface between voice application A and common services  via either Siebel\u00ae COM or Java interface  or HTTP(S) interface . In one embodiment, Web engine  provides an XML interface that enables application server  to receive incoming XML data  and send outgoing XML data .","The reference or application vendor GUI in combination with the metadata builder enables the application vendor to select which screens, views, applets, columns, and controls\/fields an application (e.g., voice application A) may access through appropriate XML queries that are submitted as incoming XML data  to Web engine . Further details of Metadata Builder  are shown in . At the core of the Metadata Builder is a Metadata Builder Engine , which includes a parser , and an extractor . Additional components include an XML builder  and a style sheet builder . In one embodiment, Metadata Builder  may be implemented as a business service that is managed by object manager .","With reference to , the process for selecting which UI objects to voice enable and for generating style sheets begins in a block  in which the application vender user (e.g., an administrator) opens reference or application vendor GUI , initiates the voice enable process, and selects an application the administrator would like to provide voice access to. Generally, the administrator will be presented with a user interface such as a dialog box or web page (both not shown) that enables the user to select an application to voice enable from among one or more applications that are supported by the enterprise data system.","Upon selection of the application, selection data  identifying the selected application is passed to metadata builder engine , which then invokes extractor  to traverse repository file  and extract metadata corresponding to the selected application's UI objects and definitions in a block . As described above, the repository file contains object definitions for the various objects corresponding to all of the applications in the enterprise data system, stored as metadata in a compiled format. Included in these object definitions are user interface object definitions and their relationships. An exemplary portion of a repository file is shown in . (It is noted that in one embodiment the repository file is actually stored in a compiled format rather than the ASCII text format shown in , which is used in the figure for clarity.)","In one embodiment, the user interface objects have a hierarchical relationship, as shown in , wherein the top level of the hierarchy corresponds to the entire enterprise data system, as depicted by an enterprise data system block . Each enterprise data system will include one or more applications , with each application  including a plurality of screen . In turn, each screen will include one or more views , with each view including one or more applets . Finally, each applet will include a plurality of columns and\/or fields\/controls , with each column corresponding to column in a list applet each field\/control typically comprising an edit control on a detail form (i.e., entry) applet that is either mapped to a column in a database table or a list of values that are either predefined, or generated at run-time based on current data in the enterprise data system.","A rendered user interface  that graphically depicts the UI object hierarchy of  is shown in . User interface  includes a screen bar  corresponding to screens  that enables a user to select a screen the user desires to view. For example, in the illustrated user interface these screens include a \u201cHome\u201d screen , an \u201cOpportunities\u201d screen , and \u201cAccounts\u201d screen , a \u201cContacts\u201d screen , an \u201cActivities\u201d Screen , a \u201cCalendar\u201d screen , a \u201cQuotes\u201d screen , a \u201cForecasts\u201d screen , and a \u201cRevenues\u201d Screen . Activation of the tab having the screen name causes the application to render the selected screen and navigate the user to the application \u201cdomain\u201d corresponding to the selected screen.","As discussed above, each screen includes one or more applets. Under common user interface terminology, applets would generally fall into the form category. Applets generally have two formats: list applets and form applets. A list applet contains a tabular list of data including multiple rows and data columns similar to that shown in an Account list applet .A form applet typically includes a plurality of fields containing data pertaining to a particular \u201crecord,\u201d wherein the record will often correspond to a selected row in an accompanying list applet. Form applets are also referred to as detail applets and entry applets. For example, an Account entry applet  includes a \u201cName\u201d field , and \u201cAddress Line \u201d field , and \u201cAddress Line \u201d field , a \u201cZip\u201d field , a \u201cMain Phone #\u201d field , a \u201cCity\u201d field , a \u201cState\u201d field , a \u201cCounty\u201d field , an \u201cAccount Type\u201d filed , a \u201cStatus\u201d filed , an \u201cIndustries\u201d field , a \u201cTerritories\u201d field , and \u201cAccount Team\u201d field  and a \u201cParent\u201d field . Generally, each field will have a corresponding edit control, which typically will comprise an edit box or a dropdown control from which a user may select from a predetermined list of values. In some instances, a dialog picklist control  may also be provided that enables a user to select from list of options via a dialog box that is populated with the list using a run-time query.","In many instances, applets may be linked via a parent-child type relationship. For example, Account list applet  is a parent of Account entry applet , which includes a plurality of tabs  to enable a user to enter or view information specific to the name on each tab and the currently selected account record. For example, the currently selected account is \u201cA & W Gifts and Flowers,\u201d and a user could enter information concerning contacts for this account by activating a \u201cContacts\u201d tab , which would bring up a Contacts form including a plurality of fields pertaining to contact information (not shown).","Returning to the flowchart of , in a block  parser  builds an application representation  comprising an internal representation of the selected application's screens, views, applets, columns, and fields\/controls based on the corresponding user interface object definition metadata that was extracted in block , as depicted by application representation . In one embodiment, the application representation comprises a hierarchical tree structure of the object definitions extracted by the extractor. In exemplary application representation occupies the left-hand portion of . Each node in the hierarchical tree stores data corresponding to an application representation object. The object may be an application object, screen object, view object, applet object, etc. After getting the object definition from the extractor, the parser will convert the object to an application representation object and store it in a node of the hierarchical tree structure. This is repeated for all objects until the tree is filled.","Next, in a block  metadata builder engine  invokes XML builder  to build an XML data tree  corresponding to application representation , and returns the XML data tree to reference or application vendor GUI  in a block . To perform this operation, the XML builder traverses the hierarchical tree and builds an XML representation for it. The reference or application vendor GUI parses the XML data tree and renders a selection tree  in a window or frame similar to that shown in . In general, the selection tree will have a hierarchy similar to the user interface hierarchy of the application, as defined by application representation .","In one embodiment, the reference GUI comprises a plurality of ASP (Active Server Page) web pages that use an ActiveX data control to get access to the voice metadata builder. In this embodiment, the ASP creates the ActiveX control, gains access to the voice metadata builder, starts the XML extraction to get the XML object definition, renders the HTML for the reference GUI, returns subscription XML data for UI components to voice enable and\/or provide voice update support for, triggers the creation of style sheets, and allows loading and saving existing subscriptions. In one embodiment, the ActiveX DataControl is used to create selection tree , wherein the ActiveX DataControl enables the window to have functionality similar to the Microsoft Windows Explorer file management tool. For example, objects corresponding to screens, views and applets are displayed with adjacent file icons, including open file icons  and closed file icons , while column and field\/control objects are displayed with adjacent document icons .Additionally, activation of an expansion control  causes data pertaining to a closed folder to be expanded, while activating a collapse control  causes data corresponding to an opened folder to be collapsed (i.e., removed from view).","As shown in , a \u201cSubscribe for UI\u201d checkbox  and a \u201cSubscribe for Grammar\u201d checkbox  is displayed below each opened screen, view, applet, and column\/field\/control object. Accordingly, in a block , the administrator selects appropriate checkboxes to identify which views, applets, and columns\/fields\/controls the administrator would like to subscribe to have voice enabled and\/or provide grammar update support for. Subscription data  pertaining to the selected UI objects and checked options are then submitted back to metadata builder engine  in a block  along with a request to voice enable and\/or provide grammar update support for the selected UI objects. An exemplary set of subscription data is shown in the right-hand portion of . Finally, in a block , the metadata builder engine invokes style sheet builder  to create style sheets  based on the application representation and the subscription data.","Based on the UI objects selected to be voice-enabled, the style sheet builder will generate an XSLT (extensible Style sheet Language Transformation) style sheet, which will filter the unselected elements from the original XML data in a result set returned by the enterprise data system such that only data pertaining to voice-enabled UI objects are returned to voice application A. An exemplary style sheet layout and logic contained when each style sheet template is shown in . As the name implies, XSLT is an XML-based language used to create style sheets that are used to transform XML documents into other types of documents and to format the output of XML documents. XSLT became a W3C Recommendation in November, 1999; the specification can be found at http:\/\/www.w3.org\/TR.xslt.","XSLT style sheets are built on structures called templates. A template specifies what to look for in an input document, called the source tree, and what to put into an output document, called the result tree. XSLT style sheets are also composed of XSLT elements, which generally include the <xls:style sheet>, <xls:template>, <xsl:value-of:>, <xls:output>, <xls:element>, <xls:attribute>, <xls:attribute-set>and <xsl:text>elements. The XSLT elements also include conditional elements, such as <xsl:if>, <xsl:choose>, elements and loop elements such as the <xsl:for-each>element. All of these elements will be familiar to those skilled in the XSLT style sheet art.","Initially, each style sheet will include a set of templates corresponding to respective UI object hierarchy positions, including an application processing template, a screen processing template, a view processing template, an applet processing template, and a LIST template. If the applet is a list applet, the set of templates will further include an RS_HEADER template and a COLUMN template; if the applet is an entry applet (i.e., multi-field form), the set of templates will include an RS_DATA template, a ROW template and a FIELD template. The purpose of each template is to filter out unwanted data at each hierarchy level of the XML source tree document, as will be explained below in further detail.","With reference to the flowchart of  in view of the XSLT style sheet layout of , the generation of XSLT style sheets proceeds as follows. The process begins in a block  in which the style sheet is initialized. In accordance with one embodiment of the invention, each XSLT style sheet will include substantially the same layout and logic at the beginning of the style sheet. This will include an XSLT header section , and application template , and a screen template . The application template will include a code block  that copies all of the values in the source tree document at the application level to the result tree document, and a decision block  in which a determination is made to whether a screen level exists in the source tree document. If it does, screen template  is called in a block . If the screen level doesn't exist in the source tree document, the process exits.","The code blocks in the screen template are substantially similar to those in the application template. First, style sheet code corresponding to a block  is used to copy all of the values at the screen level of the hierarchy to the result tree document. In a decision block , a determination is made to whether a view level exists in the source tree. If it does, view template  is called in a block . If it does not, the process exits.","In a block  of  the tree nodes of the application representation are traversed, beginning with the root of the tree (i.e., the application level\u2014note the application representation tree will look somewhat like an upside-down real tree, so the root is at the top of the application representation in ). As depicted by start and end blocks  and , the operations enclosed between these two loop end points are performed on each node as the application representation tree is traversed.","In accordance with one embodiment of the invention, a style sheet is created for each view. Accordingly, in a decision block , a determination is made to whether the node corresponds to a selected view (i.e., a view that is selected to be voice-enabled via the subscription data). For example, supposed that the current node being processed corresponds to a Sales Accounts View  node in the application representation of . Since the corresponding subscription data indicates that this is a view that is selected to be voice-enabled, the answer to the decision block is YES (TRUE), and the logic proceeds to a block  in which a new style sheet is created using a base view style sheet template. This new view template will have a layout similar to a view template  shown in , will include a code block  containing logic that is used to copy all values pertaining to the view level to the result tree, and an applet template routing section  that is used to route the XSLT processing to an appropriate template as identified in the source tree. (It is noted that applet template routing section  will initially be empty, as explained in further detail below.) The logic then loops back to start loop block  to begin processing the next node.","If the answer to decision block  is NO (FALSE), the logic proceeds to a decision block  in which a determination is made to whether the node corresponds to a selected applet. For example, suppose that the current node is a More Info Account Entry Applet node  in the application representation. This node is marked as being selected to be voice-enabled, resulting in a YES result to decision block  and leading to a block  in which a new applet and child template set is generated, including an applet template, and a list template. Each applet template will include substantially the same logic that includes specific references pertaining to that applet template. In one embodiment each template has a name that specifically references the node corresponding to the template. For example, a Contacts Accounts Entry Applet Template  corresponding to a Contacts Accounts Entry node  is shown in . This template includes a code block  containing logic to copy all of the values pertaining to the Contacts Accounts Entry Applet in the source tree to the target tree. The template further includes a code section pertaining to a decision block  through which a determination can be made to whether the source tree document includes a list level. The template also includes a code block  that contains logic to call an appropriate list template (in this case a Contacts Account Entry Applet List template ). (It is noted that for simplicity Contacts Account Entry Applet List template  is used in conjunction with both the Accounts List applet and the Contact Account Entry Applet. It will be understood that in actual practice a separate List template would be provided for each applet.)","Each List template will include a code block  containing logic to copy all values pertaining to the list level of the source tree document. As discussed above, if an applet is a list applet, an RS_Header and a column template are added, as depicted by an Account List Applet RS_HEADER template  and an Accounts LIST Applet Column template . In contrast, if the applet is an entry applet than an RS_DATA template, row template, and field template are created, as depicted by a Contacts Account Entry Applet RS_DATA template , a Contacts Account Entry Applet ROW template , and a Contacts Account Entry Applet Field Template . Accordingly, each list template will include a code section corresponding to a decision block  by which a determination is made to whether and RS_DATA level exists in the source tree document, and\/or a code section corresponding to a decision block  by which a determination can be made to whether an RS_HEADER level exists in the source tree document. If the answer to decision block  is TRUE, the logic flows to a code block  in which an appropriate RS_DATA template is called. If the answer to decision block  is TRUE, the logic flows to a code block  in which an appropriate RS_HEADER template is called.","As depicted by Account List Applet RS_Header template , each RS_Header template includes a code block  containing logic to copy all of the values pertaining to the applet level from the source tree to the result tree. A code section pertaining to a decision block  is also provided that is used to determine whether an appropriate column template exists in the source tree document. If it does, the logic proceeds to a code block  in which the appropriate column template is called.","As depicted by Account List Applet Column template , each column template will include a code block  that includes logic to filter out all data at the column level that does not pertain to columns that were marked to be voice enabled for the applet that is being currently processed. For example, in code block , logic is included to filter out data in all columns of the Account List Applet except for a new column, a Name column, and a Main Phone# column. When a Column template is initially generated, the filtering logic corresponding to code block  will be empty.","As depicted by Contacts Account Entry Applet RS_DATA template , each RS_DATA template includes a code block  that contains logic to copy all of the values pertaining to the RS_DATA level in the source tree. Each RS_DATA template also includes a code section corresponding to a decision block  by which a determination is made to whether a Row level exists in the source tree. Each RS_DATA template further includes a code block  that is used to call an appropriate Row template corresponding to the Row level.","Each Row template includes a code block  containing logic to copy all values pertaining to the Row level of the source tree, as depicted in Contacts Account Entry Applet Row template . Each Row template also includes a code section corresponding to a decision block  by which a determination is made to whether a Field level exists in the source tree. Each Row template further includes a code block  that is used to call an appropriate Field template corresponding to the Row level.","In a manner similar to the column template discussed above, each field template includes a code block  containing logic to filter out all data at the field level that does not pertain to fields that were marked to be voice enabled for the applet that is being currently processed. For example, in code block , logic is included to filter out data in all fields of the Contacts Account Entry Applet except for a Last Name column, a First Name column, a Work Phone column, a Street Address  column, a Street Address  column, a City column, a State column, and a Country column. When a Column template is initially generated, the logic corresponding to code block  will be empty.","Returning to the flowchart of , the next operation is performed in a block , wherein branch logic is created in the \u201cparent\u201d view template for the current applet. Generally, this branch logic will be contained within an applet template routing section  and comprise a choose block containing a list of test conditions. Each of these test conditions is depicted in view template  as a decision block  and a call block . For example, the test conditions in applet template routing section  pertain to applet nodes , , , , and  in the application representation of . Generally, if a test condition is determined to be TRUE, the applet template corresponding to the test condition is called.","Upon completion of block , the logic loops back to process the next node, which would be a name column\/field node . This node would be processed in the manner discussed below, along with all of the other field nodes of the More Info Account Entry applet. The processing would then address Activities Account Entry applet node  (and subsequently its field nodes), followed by Assets Account Entry applet node  (and subsequently its field nodes) followed by an Attachments Account Entry applet node  (and subsequently its field nodes). As discussed above, an appropriate set of applet and child templates would be created for each applet node in block , and an appropriate portion of template branch logic will be added to the parent view template for these applets.","Now suppose that a Contacts Account Entry applet node  is encountered. After processing this node, the next node to be encountered is a Personal Title column\/field node . In this instance, the answers to both decision block  and  would be NO, and the logic would proceed to a decision block  in which a determination is made whether the node corresponds to a selected column or field. Since the Personal Title field node is marked as not selected, the answer to decision block  is NO, and the logic loops back to process the next node, which is a Last Name field node . This time, when the logic reaches decision block  the result is YES (since this UI object was selected to be voice-enabled), and the logic proceeds to a block . In this block, XSLT code is added to the column and\/or field template child of the current applet (as applicable) to enable data corresponding to the column or field to be filtered through. For example, this logic might be similar to that shown in code block  for a Column template, or that shown in code block  for a Field template.","In one embodiment, addition filter conditions are concatenated onto a first filter condition for other column or field objects corresponding to the current applet upon subsequent processing of the applets child column and field nodes as those nodes are encountered. For example, in the application representation of , each of the Last Name, First Name, Phone #, Street Address , Street Address , State City and Country fields have been selected to be voice-enabled. As a result, appropriate filter logic would be added to allow data pertaining to these fields to be filtered through at the Field level.","The operations and logic described above for the flowchart of  are further repeated until all of the nodes in the application representation have been processed. The net result is that in accordance with one embodiment of the invention there will be a separate style sheet created for each view, and each view will include child templates corresponding to one or more applets that are contained within that view. The style sheet builder is also used to build style sheets for the voice update support component , as described below.","Exemplary Enterprise Data System","In one embodiment, enterprise data system  comprises a Siebel\u00ae 7 enterprise data system and Web engine  comprises a Siebel\u00ae Web Engine (SWE). Under the Siebel\u00ae 7 architecture, the SWE provides an XML interface to enable third party applications to access a Siebel\u00ae enterprise data system. Siebel\u00ae 7 supports open system architecture through XML pages that are generated by the Siebel\u00ae Web Engine as applications can make a request through a web-server, Java Data Bean or ActiveX Data Control.","In order to support different implementations of voice application that vendors develop, the XML interface generates the definition of user interfaces and user data in XML format, which will then be sent to the vendor's voice application. The voice application will use this information to format its voice page and present that page to its voice users via internal operations such as TTS. In response to verbal navigation commands and data request, the voice application will then format a next request based on a current user navigation context and submit it via an appropriately configured XML document back to the Siebel\u00ae Web Engine. Throughout the remainder of this specification, SWE XML interface access examples will be provided using an HTTP request format. It is important to note that similar access features are also available through an equivalent COM or JDB (Java data bean).","XML Page Content","The XML page output is based on the application definitions, including application, screen, view, applet, and columns\/fields\/controls, that are defined in a repository. In accordance with the Siebel\u00ae enterprise data system architecture, administrators are enabled to customize their enterprise data system implementations to fit their needs such that each implementation will be unique, and customer can change. The XML interface defines XML tags in the XML pages to support various types of user interfaces that are presented to different type of users, including HTML and WML dat.","Generally, each XML output page  that is sent back to voice application A contains the following sections:","1. The Supported Version of XML and Encoding Information","This information is appended in all XML pages.","2. Application Information","This information is appended in all XML pages. It describes the application name, such as Siebel\u00ae Sales Enterprise, that the voice application is connected to and interacting with.","3. User Agent Markup","This information is appended to all XML pages. It describes the default markup language that is supported and is based on user-agent in the http header request header.","4. Active Screen, View and Applets Definition and User Data","This information is generated by default. If application only wants this information, it can add SWEDataOnly=TRUE in the http request. This section contains current active screen and view information and also applets and the record (user data) information defined in that view.","XML User Data","This section gives a detailed description of the outbound XML tags contained in an XML page  that is returned to voice application A in response to a request for user data (e.g., via a user operating phone ). To retrieve data, voice application A sends a request having a format described below to Web engine . The request contains UI object specific information, such as screen, view, and applet identifiers, and specifies as style sheet to use when filtering the returned dataset. The request may also include additional parameters that are specific to the Siebel\u00ae Web Engine. A table listing some of these parameters and the effect of such parameters is contained in the attached appendix. For example, if the voice application only wants data returned without UI information, the user can specify that the SWEDataOnly parameter is set to TRUE in the request. When this parameter is set, the returned XML contains only data tags and does not contain any UI Navigation elements like menu drop downs, page tabs etc. In contrast, if the SWEDataOnly is not set to TRUE (default value), then in addition to the data, the user data returned includes data pertaining to the screen, applet and view the data resides in. For instance, the user data for the Contacts screen would have information pertaining to the SCREEN, VIEW, and APPLET the data is retrieved from in addition to the actual user contact data.","The sample XML provided herein represents XML data for the Contacts Screen. An HTTP request made to Web engine  SWE to retrieve data pertaining to the Contacts screen may have the following format:","http:\/\/localhost\/sales\/start.swe?","SWECmd=GotoPageTab&SWEScreen=Contacts+Screen&SWEGetDataOnly=TRUE","The http:\/\/localhost\/sales\/start.swe? Parameter specifies the Internet URL address for the Web engine. The parameters in the second line correspond to specific commands that instruct the Web engine what data is desired based on a navigation context within the application\u2014in this case the contacts screen. As discussed above, the last parameter specifies that only data pertaining to appropriate UI objects are to be returned.","In general, a typical XML page that is returned by the Web engine in response to a data request will have a format shown in  (when the SWEDataOnly=TRUE argument is used). As will be recognized by those skilled in the XML art, the XML page includes nested pairs of XML tags that are used to define a format for the returned data. Each pair of tags defines a level in the hierarchy of the XML tree. Detailed examples of various portions of the XML page are shown in , , and .","With reference to , the first element in the XML page will be an application element  that identifies the name of the application. The next element comprises a user agent element  that provides information about the user agent or the browser type that made the XML or HTML request. A screen element  appears next, which is contained inside of the application element tag pairs. This element gives information about the name and title for the currently active screen.","The next element is a view element . Similar to the screen element, the view element describes the name and title of the currently active view. An applet element  is contained inside the view. In addition to returning an applet name  and applet title , the applet element includes a MODE attribute , a NO_INSERT attribute , NO_MERGE attribute , a NO_DELETE attribute , a NO_UPDATE attribute , a NO_EXEC_QUERY . The MODE attribute describes what mode the applet is in. It can either be in an EDIT mode or BASE mode. The former means that the applet allows modification, deletion, creation and querying of records. The latter means that the applet is read only and cannot be modified.","The NO_INSERT, NO_MERGE, NO_DELETE, NO_UPDATE, NO_EXEC_QUERY attributes provide a filter to what specific edit mode operations are possible for the applet. If any of these attributes are TRUE then that particular operation is not possible. For instance, if the NO_INSERT attribute is TRUE then new records cannot be inserted onto this applet. The voice application can tailor the voice commands based on these attributes. For instance, if the NO_EXEC_QUERY attribute is set to FALSE for an applet, this indicates that the Voice application should be able to query for a contact using that applet.","Another attribute included in the applet element is a CLASS attribute . This attribute specifies the C++ class the applet belongs to. For instance, in the illustrated example the CLASS attribute has a value of CSSFrameListBase, which identifies it as a List applet under the Siebel\u00ae 7.0 architecture.","A ROW_COUNTER attribute  provides an indication of the number of data records returned. A \u201c+\u201d at the end of the attribute value indicates that there are more records than that returned by the current XML page. One of the ways to get all the data would be to check for the ROW_COUNTER attribute and see if it contains a \u201c+\u201d. If it does, then submit the prior data request to the Web engine repeatedly until the ROW_COUNTER attribute no longer ends with a \u201c+\u201d.","It is possible to retrieve a large number of rows via a single request by setting the SWESetRowCnt parameter in the HTTP request. Caution should be used when setting this parameters, as a large value may generate a delayed response since data pertaining to the number of rows provided by the parameter must be retrieved, converted into an XML format, and appended to the XML page.","In addition the HTTP route, XML pages that return only data may also be retreived via the Siebel\u00ae Data Bean and ActiveX Controls via calls to methods provided by the underlying business components (i.e., the business components corresponding to object manager ). This way, specific columns can be activated directly, thus limiting the returns to specified data.","RS Header, Column","The next XML element of importance is the RS_HEADER element . As shown in further detail in , this element contains one or more COLUMN elements  that provide column details for the underlying data records. Each column element includes a NAME attribute , and a DISPLAY_NAME attribute , that respectively provide information about the name and display name of the column on the list applet. A DATATYPE attribute  describes what kind of data type the column represents. If the DATATYPE corresponds to a text type of data, a TEXT_LENGTH attribute  may be provided. For instance, a phone number might have a data type of \u201cphone\u201d and an email might have a data type of \u201cemail\u201d or \u201ccharacter.\u201d","A REQUIRED attribute  defines whether the column is a required column or not. This information is useful when creating new records. The voice application can determine what field information is mandatory by looking at this attribute. A FORMAT attribute  is an important attribute that the voice application can use to determine the format of the data. For the Date data type this attribute will contain the acceptable Date Format (e.g., as shown in the middle column element of ). For revenue and other price related fields this attribute will have the format for the dollar amount. The voice application can use this to get or display the right information back to the user.","A CALCULATED attribute  specifies that the column is not a database column but rather contains a value that is calculated using a mathematical expressions or similar calculation. A FIELD attribute  provides the name of the FIELD element the column refers to. The FIELD element (described below) contains the actual data. Typically, voice application A might make use of both the FIELD and COLUMN elements to get more information on the data. A READ_ONLY attribute  specifies whether the column is editable or just read only.","RS Data, Row, Field","The next important XML element is an RS_DATA element . This element contains the XML tags that hold the actual data. An example of an RS_DATA element is shown in .","A ROW element  identifies the Row id of the data in the attribute ROW_ID. This information is very useful in querying for a particular row of data and getting the detailed information for that row. For instance, if the voice application wanted a particular row, e.g. 12-WFJ4D, on the Contacts Screen, the XML request would look something like the following:",{"@attributes":{"id":"p-0119","num":"0118"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"http:\/\/localhost\/sales\/start.swe?"},{"entry":"SWECmd=InvokeMethod&SWEMethod=DrillDown&SWEView=Visible+Contact+List+View&SW"},{"entry":"ESetMarkup=XML&SWEApplet=Contact+List+Applet&SWERowId=12-"},{"entry":"WFJ4D&SWEField=Last+Name"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"A SELECTED attribute  indicates that the particular row is selected on the User Interface. FIELD elements  holds the actual data for the row. Each FIELD element includes a NAME attribute  that provides the name of the Business Component field corresponding to the element. This information is useful in determining what fields to query on while fetching a particular row id. In the URL of LISTING 2 the SWEField parameter is queried on the Last Name of the contact. Each FIELD element also includes a VARIABLE attribute  value that corresponds to the name of the column to which the field is mapped to.","Retrieving Detailed Information About the Data","As discussed above, the RS_HEADER section holds detailed information about each data column. For instance, if the voice application wants to detect if a particular column holds a phone number then it should lookup the DATATYPE attribute in the COLUMN element (under the RS_HEADER section) and then get the data from the FIELD element. The FIELD attribute of the COLUMN element gives a link to the FIELD element, which holds the actual data. It is recommended not to use the field attributes in the RS_DATA section for data type detection, as this information is not guaranteed to be a constant. This might change if the object definition, field names in this case, are changed.","Voice Access Process Using the Mobile Connector","With reference to the flowchart of , a voice data access process in accordance with the software and hardware architectures for the systems described herein begins in a block  in which a user verbalizes a voice request via a voice application user interface. Generally, the voice application user interface operations are enabled in large part via voice infrastructure  and is therefore outside the scope of the invention, as discussed above; the operations of block  and a block  discussed below are included in the flowchart to illustrate how a complete voice access would be performed.","In a block , the voice application transforms the voice request into an XML query (i.e., data request) and sends the query as an XML document  to Web engine  via either the Siebel\u00ae COM or Java interface, or through Web server  using HTTP. For example, suppose the user desires to retrieve information pertaining to a particular contact from within the Contacts Accounts Entry Applet having a last name of \u201cJones,\u201d and the applicable style sheet is named \u201cSales_Accounts_stylesheet\u201d Using HTTP, the XML query would look something like the following:",{"@attributes":{"id":"p-0124","num":"0123"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"301pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"http:\/\/localhost\/applicationname\/start.swe?"},{"entry":"SWECmd=GotoView&SWEView=Sales+Accounts&SWESetMarkup=XML&SWEApplet=Contacts"},{"entry":"+Accounts+Entry+Applet&SWEDataOnly=TRUE&SWEXslStyleSheet=Sales_Accounts_stylesheet"},{"entry":"&Last+Name=Jones"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In the foregoing example and other examples discussed above, the XML query comprises a concatenated list of Siebel\u00ae Web Engine commands, methods and arguments that informs the Siebel\u00ae Web Engine what data is wanted and how that data is to be provided back to the requester. In general, the Web engine needs to know a navigation context for the request data, such as the screen, view, applet, and columns or fields from which the data may be accessed. In addition to the navigation context data, the input XML document should also include the name of a style sheet that is to be applied to filter the returned data. In one embodiment, this is provided in a SWEXslStyleSheet argument. In accordance with one embodiment discussed above, a style sheet is created for each view in a given application. As a result, the style sheet corresponding to the view of the desired navigation context should be used to filter data in the output XML document.","Upon receiving the XML query, in a block  the Web engine parses the XML document to identify the navigation context corresponding to where the data may be accessed, along with any particular data location information, such as a rowed. This information is then passed on to the object manager to service the request. The object manager then formulates an appropriate SQL query, executes the SQL query against database , and returns data corresponding to the query's result set to the Web engine in a block . The Web engine the generates an XML document corresponding to the result set in a block  based, in part, on any applicable Siebel\u00ae Web Engine parameters that were provided in the incoming XMLwere provided in the incoming XML query. For example, if the SWEDataOnly argument is set to TRUE, the Web engine will filter out all of the UI content corresponding to the result set.","At this point the mobile connector applies the specified style sheet to the XML document to filter out all data except data pertaining to any voice-enabled columns or fields in accordance with the current request. For example, in response to the XML query in LIST 3, the Web engine would create an XML document containing all of the contact information for all contacts with a last name of \u201cJones.\u201d","At this point, the mobile connector then applies the identified style sheet to the XML document to filter out all the data that corresponds to columns and\/or fields that were not selected to be voice-enabled for the current navigation context (i.e., current SCREEN, VIEW, and APPLET. Since the style sheet is an XSLT style sheet, one of several well-known prewritten software modules that implement an appropriate XSLT style sheet processing algorithm may be used.","As discussed above, the original XML document submitted to be transformed via the XSLT style sheet is the source tree, while the resulting transformed (i.e., filtered) document comprises the result tree. To produce the result tree, the algorithm traverses the XSLT style sheet based on conditional logic contained in the style sheet, copying data from the source tree to the result tree when a corresponding copy element is encountered.","For example, returning to the style sheet of , the algorithm would begin at XLST header  and continue sequentially through the various style sheet templates using appropriate branching conditions. The first style sheet template that is encountered is application template , which corresponds to the \u201cAPPLICATION\u201d level of the source tree document. As discussed above, the XML document that is output from the Web engine after the style sheet is applied will have a format similar to that shown in . The source tree document will have a similar format. Accordingly, the \u201cAPPLICATION\u201d level is identified by the <APPLICATION . . . > tag. In block  all of the values pertaining to the application level are copied to the result tree document. For example, data pertaining to the APPLICATION NAME will be copied to the result tree.","Next, in decision block  it is determined that a Screen level exists in the source tree, and screen template  is called in code block . This causes the processing to jump to screen template .","In a manner similar to Application template , in the Screen template all of values pertaining to the Screen level are copied to the result tree in block , and a determination is made in decision block  to whether a View level exists in the source tree. For source trees having a structure similar to that shown in , the answer to decision block  will be true, causing View template  to be called in block .","In View template , things get a little more interesting. Since the selected style sheet will correspond to the current view, all of the view information is copied to the result tree in block , such as the views name and title. The processing will then flow to applet template routing section , wherein the test conditions corresponding to decision blocks  are evaluated. In the current example, the applet is the Contacts Account Entry Applet, which has a corresponding test condition defined in a decision block . In response to a TRUE result for decision block , code pertaining to a block  will be executed, causing the processing to jump to Contacts Account Entry Applet template .","At the start of this template, all of the applet information is copied to the result tree in block , leading to decision block , which will determine that the source tree includes a List level. Contacts Account Entry Applet List Template  is then called in block . In the Contacts Account Entry Applet List Template, data pertaining to the list level (this will usually include just the <LIST> and <\/LIST> tags) is copied to the result tree, and an RS_DATA test condition corresponding to decision block  is encountered. If this condition is TRUE, which will be the case when field data is sought, the processing jumps to Contacts Account Entry Applet RS_Data template  via code block . In this template, all values pertaining to the RS_DATA level in the source tree is copied to the result tree in block , and then a determination is made in decision block  that a Row level exists in the source tree. Accordingly, Contacts Account Entry Applet Row template  is called in block , causing the style sheet processing to advance to the Contacts Account Entry Applet Row template.","In this template, all values pertaining to the Row level of the source tree are copied in block  to the result tree, and it is determined in decision block  that a Field level exists in the source tree. Accordingly, Contacts Account Entry Applet Field template  is called via block .","The Contacts Account Entry Applet Field template is different than the previous templates that were encountered. Rather than copy all of the data to the result tree, the logic in code block  says to copy data in the source tree pertaining to the \u201cLast Name,\u201d \u201cFirst Name,\u201d \u201cWork Phone#,\u201d \u201cStreet Address ,\u201d \u201cStreet Address ,\u201d \u201cCity,\u201d \u201cState,\u201d and \u201cCountry\u201d fields to the result tree; the data in all of the other fields of the field templates parent applet will not be copied to the result tree, and thus will be filtered out.","Suppose that it was desired to retrieve data pertaining to the Account List Applet  in the application representation of . Since the Application, Screen, and View are the same for this applet as they were for More Info Account Entry applet , the processing would proceed in the same manner as discussed above until reaching Contacts Account Entry Applet List Template . In this instance, the result of decision block  will be NO (FALSE), and the logic will proceed to decision block , which will produce a YES (TRUE) result since a source tree corresponding to a list applet will include an RS_HEADER level. As a result, the style sheet processing will jump to Account List Applet RS_HEADER template  via code block , wherein the values pertaining to the RS_HEADER level would be copied from the source tree to the result tree in block . Next, in decision block  it would be determined that a Column level exists in the source tree. The result of this condition would be TRUE, causing the processing to finally jump to Account List Applet Column template , which contains a filter that will only allow data pertaining to the New, Name, and Main Phone # columns to be copied to the result tree.","Voice Update Support","The purpose of voice update support module  is to support grammar update for the voice application. The grammars are words or patterns of words that are listened for by a speech recognizer and other grammar processors that are part of the voice infrastructure and\/or the voice application. The speech recognizer uses grammars to know what the user said and then passes the information to the voice application for further processing. In one respect, grammar fields are basically the subset of list columns defined in a list applet. For example, as the voice application is in the state of looking up an account, the voice user can say an account name and the speech recognizer will use the account name list that the voice user would normally view if he or she was connected to the enterprise data system via an HTML client as the grammar to understand what the voice user said. Then the voice application uses this account name to format the request and send it to the Siebel\u00ae Web Engine to get the detailed information of that account.","In order to support this paradigm, grammar data corresponding to various data columns must be accessible to voice application A. Preferably, this will be done by periodically retrieving data pertaining to those data columns from the enterprise data system via the mobile connector (or via another access means, such as a backend connection directly to database ), and storing the retrieved data in a manner that is useable by the voice application and\/or voice infrastructure  as grammar data. For example, the grammar data may be stored in a local (to the voice application) database. The specific implementation details for storing and accessing the grammar data will be familiar to those skilled in the voice access system arts and are outside the scope of the invention.","Voice update support module  supports dynamic grammar updates through exporting user data in XML format to the voice application. The output is generated by Web engine  based on the view and applet specified in the XML query request and uses grammar stylesheets to filter out information that is not required as grammars. The grammar style sheets are generated in the same manner as discussed above with reference to the voice style sheets, except that in this instance the selections in the Grammar Update Enable column of the application representation are used rather than the values in the Voice Enable column. The voice application can periodically check if there is any new\/updated data (also refered to as \u201cdelta\u201d data) which are used for grammar, and retrieve the delta changes if desired.","The retrieval of grammar information means getting the data of the subset of the list columns in the applet to which the update is to apply. This may be implemented with a new SWE method, GetVoiceGrammer, to retrieve the delta data that is based on the specified view and applet and the last update time that the periodic update was performed for that view and applet and use an appropriate grammar stylesheet (e.g., pertaining to the view) to filter the output for data only pertaining to grammars.","In one embodiment, the request parameters to web engine  for Voice Update Support should include the following information:","a. SWE Command Name, required","a. SWE Method Name, required","b. View Name, required","c. Applet Name, required","d. Last Update Time, optional","For example if a voice application submits the command with the parameters below to the Web Engine:","SWECmd=InvokeMethod","SWEMethod=GetVoiceGrammar&","SWEView=Account List View&","SWEApplet=Account List Applet&","LastUpdate=Jan. 15, 2001","Where","GetVoiceGrammar is a new command in the set of SWE commands;","SWEView specifies the view name;","SWEApplet specifies the applet names that have grammar fields defined;","LastUpdate specifies the last update time that the delta is based on;.","the SWE will return the list of account names that have been updated or added since Jan. 15, 2001. If the information of LastUpdate parameter is not provided, the voice update support module will return all grammar data pertaining to the view and applet.","In one embodiment, the output will be in XML format using the same output DTD (data type definition) normally implemented but it will contain only partial UI information. In case of an error during processing, the output will include the error message in an <ERROR> tag.","With reference to the flowchart of , an typical grammar update process will proceed as follows. In a block  the voice application determines which views and applets it wants to update grammar data for and formulates one or more XML queries requesting these data and send to the Web engine via the COM or Java interface or through the Web server using HTTP. Each request is accompanied with the name of the grammar style sheet that is to be appled and last update information, if applicable.","In response to receiving the XML query request, the Web engine parses the XML in a block  and passes on appropriate data to the object manager to service the request. The object manager then returns a result set corresponding to the request to the Web engine in a block . In a manner similar to that discussed above, the web engine generates an XML source tree document corresponding to the result set in a block , which is filtered by the voice update support component by using the specified grammar style sheet in a block  to produce an XML result tree that only includes data pertaining to columns and fields that were marked for update previously as defined by the grammar style sheet. The web engine then sends the filtered data as an XML document back to the voice application in a block , and the voice application updates its grammar database in a block .","Exemplary System Infrastructure","An exemplary system infrastructure  by which various embodiments of the invention described herein may be implemented is shown in . The enterprise data system side of system infrastructure  uses a well-known N-tier architecture, wherein one or more physical machines occupy each tier in the architecture. These tiers include a database tier, depicted by a database server , and application server tier, depicted by an application server , and a web server tier, depicted by a web server . Each of the machines in the N-tier architecture are linked in communication via a local area network (LAN) . Database server  is used to run an RDBMS (relation database management system) database server software component that hosts database . The RDBMS database server software will typically comprise a SQL database server that may be provided by one of several vendors, including Oracle (Oracle Enterprise and ), Microsoft (SQL Server 7 or 2000), IBM (DB), Sybase, or Informix. All of the components depicted in the block corresponding to application server  may be run in the application server tier. Optionally, all or a portion of the software associated with Web engine  may be run on web server .","On the voice application side, the architecture includes a voice application server  on which voice application A is run. The voice application server is linked to web server  via a computer network , such as a LAN, a WAN (wide area network) or via the Internet. Generally, the voice application server will be connected to another server that is part of voice infrastructure  via a LAN or the same machine may be used for both voice infrastructure operations and for serving the voice application. If the Siebel\u00ae COM or Java interface  is implemented, the client side of this software will typically be run on voice application server . If Web server  is used, software corresponding to this component may be run on the voice application server or a separate web server machine linked to the voice application server via a LAN (not shown).","As discussed above with reference to , in one embodiment reference or application vendor GUI  is supported by Web pages that are served to a client  via computer network . Alternative, the application vendor may create their own GUI () based on a language that supports the generation of interactive graphical user interfaces, such as C, C++, or Java, in which case the GUI component may be directly connected to application server  via a LAN or WAN connection (not shown).","The foregoing embodiments disclose particular details that are suitable for using the invention in connection with voice access systems. This is not meant to be limiting. For example, the architecture of the system enables an external application or system to access filtered data from data systems, such as an enterprise data system; the voice access system embodiments discussed above correspond to a particular implementation of the system, wherein the filtered data are used for voice access purposes. In instances in which filtered data are desired to be retrieved from a data system, rather than selecting UI objects to be voice-enabled, the system would permit users to select UI objects to be \u201cpass-through\u201d enabled (i.e., data pertaining to pass-through enabled UI objects would pass through the data filter mechanism), and corresponding subscription data would be generated in the same manner discussed above. An exemplary result of such subscription data is shown in . From the external application's or system's standpoint, the operations for interacting with the data system via the mobile connector would appear substantially identical, whether the filtered data was ultimately used in a voice access system or for any other purpose.","The same is true for data updates. The principles and teachings disclosed in the exemplary implementation discussed above concerning grammar building and updating for use in a voice access system may be applied to other data building and updates implementations as well. In such instances, the user interfaces provided by the system or application vendor should reflect the type of data being updated. For example, in the GUI shown in , the \u201cSubscribe for Grammar\u201d labels might be replaced with \u201cSubscribe for Update\u201d or something similar to inform the user what is being selected for update. Accordingly, the subscription data would correspond to the data contained in the \u201cUpdate Enable\u201d column of .","With reference to , a generally conventional computer server  is illustrated, which is suitable for use in connection with practicing the present invention. For example, computer server  may be used for running application server software modules and components, including object manager , data manager , Web engine , voice update support , and voice metadata builder . The same or preferably a separate computer server of similar architecture may be used to host database . Similarly, the same or preferably a separate computer server of similar architecture may be used for Web server .Examples of computer systems that may be suitable for these purposes include stand-alone and enterprise-class servers operating UNIX-based and LINUX-based operating systems, as well as servers running the Windows NT or Windows 2000 Server operating systems.","Computer server  includes a chassis  in which is mounted a motherboard (not shown) populated with appropriate integrated circuits, including one or more processors  and memory (e.g., DIMMs or SIMMs) , as is generally well known to those of ordinary skill in the art. A monitor  is included for displaying graphics and text generated by software programs and program modules that are run by the computer server. A mouse  (or other pointing device) may be connected to a serial port (or to a bus port or USB port) on the rear of chassis , and signals from mouse  are conveyed to the motherboard to control a cursor on the display and to select text, menu options, and graphic components displayed on monitor  by software programs and modules executing on the computer. In addition, a keyboard  is coupled to the motherboard for user entry of text and commands that affect the running of software programs executing on the computer. Computer server  also includes a network interface card (NIC) , or equivalent circuitry built into the motherboard to enable the server to send and receive data via a network .","File system storage corresponding to the invention may be implemented via a plurality of hard disks  that are stored internally within chassis , and\/or via a plurality of hard disks that are stored in an external disk array  that may be accessed via a SCSI card  or equivalent SCSI circuitry built into the motherboard. Optionally, disk array  may be accessed using a Fibre Channel link using an appropriate Fibre Channel interface card (not shown) or built-in circuitry.","Computer server  generally may include a compact disk-read only memory (CD-ROM) drive  into which a CD-ROM disk may be inserted so that executable files and data on the disk can be read for transfer into memory  and\/or into storage on hard disk . Similarly, a floppy drive  may be provided for such purposes. Other mass memory storage devices such as an optical recorded medium or DVD drive may also be included. The machine instructions comprising the software program that causes processor(s)  to implement the functions of the present invention that have been discussed above will typically be distributed on floppy disks  or CD-ROMs  (or other memory media) and stored in one or more hard disks  until loaded into memory  for execution by processor(s) . Optionally, the machine instructions may be loaded via network  as a carrier wave file.","Although the present invention has been described in connection with a preferred form of practicing it and modifications thereto, those of ordinary skill in the art will understand that many other modifications can be made to the invention within the scope of the claims that follow. Accordingly, it is not intended that the scope of the invention in any way be limited by the above description, but instead be determined entirely by reference to the claims that follow.","TABLE 1 provides and exemplary set of Siebel\u00ae Web Engine (SWE) commands that enable access to a Siebel\u00ae Enterprise Data System via an HTTP XML request. TABLE 2 provides various SWE methods that may be used to access the Siebel\u00ae Enterprise Data System via an HTTP XML request. TABLE 3 includes parameters that may be provided for the SWE commands and methods in an HTTP request to control the form and content of a returned XML document.",{"@attributes":{"id":"p-0174","num":"0173"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Command","Description","Required Arguments","Optional Arguments"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["GotoPageTab","Go to a Siebel screen.","SWEScreen\u2014name of","None"]},{"entry":[{},"Will show the default","the screen"]},{"entry":[{},"view for the screen."]},{"entry":["GotoView","Go to a Siebel View. If","SWEView\u2014name of the","SWEKeepContext\u2014if"]},{"entry":[{},"the SWEPPostnApplet","view.","TRUE, keeps the"]},{"entry":[{},"and SWEPostnRowID",{},"current business object"]},{"entry":[{},"arguments are specified,",{},"context, when"]},{"entry":[{},"it will execute a search",{},"requesting to a view"]},{"entry":[{},"for the specified rowID in",{},"based on the same"]},{"entry":[{},"the specified applet. If",{},"business object."]},{"entry":[{},"SWEQMApplet and",{},"SWEPostnApplet\u2014"]},{"entry":[{},"SWEQMMethod",{},"name of the applet on"]},{"entry":[{},"arguments are specified,",{},"which the search"]},{"entry":[{},"it will invoke the method",{},"should executed."]},{"entry":[{},"after going to the view.",{},"SWEPostnRowId\u2014row"]},{"entry":[{},{},{},"Id to search for."]},{"entry":[{},{},{},"SWEQMApplet\u2014name"]},{"entry":[{},{},{},"of the QueueMethod"]},{"entry":[{},{},{},"applet. This is the"]},{"entry":[{},{},{},"applet where the"]},{"entry":[{},{},{},"method specified in"]},{"entry":[{},{},{},"SWEQMMethod"]},{"entry":[{},{},{},"should be invoked after"]},{"entry":[{},{},{},"going to the view."]},{"entry":[{},{},{},"SWEQMMethod\u2014name"]},{"entry":[{},{},{},"of the QueueMethod"]},{"entry":[{},{},{},"method. The method to"]},{"entry":[{},{},{},"be invoked."]},{"entry":[{},{},{},"SWEQMArgs\u2014"]},{"entry":[{},{},{},"arguments of the"]},{"entry":[{},{},{},"QueueMethod method."]},{"entry":["InvokeMethod","Invoke a method on an","SWEMethod\u2014name of the","SWEService\u2014name of"]},{"entry":[{},"applet, a business","method.","the business service to"]},{"entry":[{},"service, a business",{},"invoke the method."]},{"entry":[{},"component, or the SWE",{},"SWEBusComp\u2014name"]},{"entry":[{},"application.",{},"of the business"]},{"entry":[{},"The optional",{},"component to invoke"]},{"entry":[{},"SWEService,",{},"the method."]},{"entry":[{},"SWEBusComp, and",{},"SWEApplet\u2014name of"]},{"entry":[{},"SWEApplet arguments",{},"the applet to invoke the"]},{"entry":[{},"are used to specify the",{},"method."]},{"entry":[{},"Siebel object on which"]},{"entry":[{},"the method should be"]},{"entry":[{},"invoked."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0175","num":"0174"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Method","Description","Required Arguments","Optional Arguments"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["CopyRecord","Performs initialization","None","None"]},{"entry":[{},"then calls CopyRecord"]},{"entry":[{},"on the business"]},{"entry":[{},"component."]},{"entry":["CreateRecord","Performs initialization,","None","None"]},{"entry":[{},"then calls NewRecord on"]},{"entry":[{},"the business"]},{"entry":[{},"component."]},{"entry":["Drilldown","Drilldown on the field as","SWEField: Specify the","None"]},{"entry":[{},"specified in the","name of the applet field"]},{"entry":[{},"argument SWEField.","that you want to drilldown"]},{"entry":[{},{},"on. The drilldown"]},{"entry":[{},{},"information is specified in"]},{"entry":[{},{},"the repository."]},{"entry":["EditRocord","Edit a record.","None","SWESeq: Specify the"]},{"entry":[{},{},{},"sequence number of"]},{"entry":[{},{},{},"the Edit template to"]},{"entry":[{},{},{},"show. You can have"]},{"entry":[{},{},{},"many Edit templates for"]},{"entry":[{},{},{},"an applet in Siebel"]},{"entry":[{},{},{},"Tools, each identified"]},{"entry":[{},{},{},"by the sequence"]},{"entry":[{},{},{},"number."]},{"entry":["ExecuteQuery","Execute a query. The","None","List of arguments with"]},{"entry":[{},"query spec of the fields",{},"name and value, where"]},{"entry":[{},"is specified in the list of",{},"the name specifies the"]},{"entry":[{},"arguments.",{},"field name and the"]},{"entry":[{},{},{},"value specifies the field"]},{"entry":[{},{},{},"query spec. Will set"]},{"entry":[{},{},{},"field query spec before"]},{"entry":[{},{},{},"executing the query."]},{"entry":["GotoView","Go to a Siebel view.","SWETargetView\u2014name","SWEKeepContext\u2014if"]},{"entry":[{},"If the SWEPostnApplet","of the view.","TRUE, keep the current"]},{"entry":[{},"and SWEPostnRowId",{},"business objects if"]},{"entry":[{},"arguments are specified,",{},"going to a view that"]},{"entry":[{},"will execute a search for",{},"uses the same"]},{"entry":[{},"the specified rowed in",{},"business object."]},{"entry":[{},"the specified applet.",{},"SWEPostnApplet,"]},{"entry":[{},{},{},"name of the applet that"]},{"entry":[{},{},{},"the search should be"]},{"entry":[{},{},{},"executed on."]},{"entry":[{},{},{},"SWEPostnRowId\u2014"]},{"entry":[{},{},{},"rowId to search for."]},{"entry":[{},{},{},"SWEQMApplet\u2014name"]},{"entry":[{},{},{},"of QueueMethod"]},{"entry":[{},{},{},"applet. This is the"]},{"entry":[{},{},{},"applet where the"]},{"entry":[{},{},{},"method (as specified in"]},{"entry":[{},{},{},"SWEQMMethod)"]},{"entry":[{},{},{},"should be invoked after"]},{"entry":[{},{},{},"going to the view."]},{"entry":[{},{},{},"SWEQMMethod\u2014name"]},{"entry":[{},{},{},"of the QueueMethod"]},{"entry":[{},{},{},"method. The method to"]},{"entry":[{},{},{},"be invoked."]},{"entry":[{},{},{},"SWEQMArgs\u2014"]},{"entry":[{},{},{},"arguments of the"]},{"entry":[{},{},{},"QueueMethod method."]},{"entry":["NewRecord","If the applet has an","None","None"]},{"entry":[{},"association applet, show"]},{"entry":[{},"the association popup"]},{"entry":[{},"applet. Otherwise, create"]},{"entry":[{},"a new record."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0176","num":"0175"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Query Parameter","Description","Usage","Example"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["SWEGetApplet","This parameter is used","1. SWEGetApplet=<n","1. SWEGetApplet=A"]},{"entry":[{},"to filter the outbound",{"sup":"\u2003"},{"sup":"\u2003"}]},{"entry":[{},"XML document so only","2. <ARG","2. <ARG"]},{"entry":[{},"the applet named as the",{"sup":"\u2003"},{"sup":"\u2003"}]},{"entry":[{},"value of the parameter",{"sup":"\u2003"},{"sup":"\u2003"}]},{"entry":[{},"will be allowed in the",{"sup":"\u2003"},{"sup":"\u2003"}]},{"entry":[{},"output. All other"]},{"entry":[{},"document content will be"]},{"entry":[{},"discarded."]},{"entry":["SWESetMarkup","Temporarily set the","1. SWESetMarkup=<n","1. SWESetMarkup"]},{"entry":[{},"markup language to use",{"sup":"\u2003"},{"sup":"\u2003"}]},{"entry":[{},"in the output document.",{"sup":"\u2003"},"2. <ARG"]},{"entry":[{},{},"2. <ARG",{"sup":"\u2003"}]},{"entry":[{},{},{"sup":"\u2003"},{"sup":"\u2003"}]},{"entry":[{},{},{"sup":"\u2003"},{"sup":"\u2003"}]},{"entry":[{},{},{"sup":"\u2003"}]},{"entry":["SWESetRowCnt","Temporarily set the","1. SWESetRowCnt=<","1. SWESetRowCnt"]},{"entry":[{},"workset size or row",{"sup":"\u2003"},{"sup":"\u2003"}]},{"entry":[{},"number of list applets in","2. <ARG","2. <ARG"]},{"entry":[{},"the view.",{"sup":"\u2003"},{"sup":"\u2003"}]},{"entry":[{},{},{"sup":"\u2003"},{"sup":"\u2003"}]},{"entry":[{},{},{"sup":"\u2003"},{"sup":"\u2003"}]},{"entry":["SWESetNoTempl","Disable the use of","1. SWESetNoTempl={","1. SWESetNoTem"]},{"entry":[{},"templates during the",{"sup":"\u2003"},{"sup":"\u2003"}]},{"entry":[{},"generation of the","2. <ARG","2. <ARG"]},{"entry":[{},"outbound document.",{"sup":"\u2003"},{"sup":"\u2003"}]},{"entry":[{},{},{"sup":"\u2003"},{"sup":"\u2003"}]},{"entry":[{},{},{"sup":"\u2003"},{"sup":"\u2003"}]},{"entry":["SWEDataOnly","Discard all UI content","1. SWEDataOnly={TR","1. SWEDataOnly="]},{"entry":[{},"(including anchors) if set",{"sup":"\u2003"},{"sup":"\u2003"}]},{"entry":[{},"to TRUE.","2. <ARG","2. <ARG"]},{"entry":[{},{},{"sup":"\u2003"},{"sup":"\u2003"}]},{"entry":[{},{},{"sup":"\u2003"},{"sup":"\u2003"}]},{"entry":[{},{},{"sup":"\u2003"},{"sup":"\u2003"}]},{"entry":["SWEXslStyleSheet","Specify the name of the","1. SWEXslStyleSheet","1. SWEXslStyleSh"]},{"entry":[{},"XSLT stylesheet to use",{"sup":"\u2003"},{"sup":"\u2003"}]},{"entry":[{},"to perform the XSLT on",{"sup":"\u2003"},"2. <ARG"]},{"entry":[{},"the XML output",{"sup":"\u2003"},{"sup":"\u2003"}]},{"entry":[{},"document.",{"sup":"\u2003"},{"sup":"\u2003"}]},{"entry":[{},{},{"sup":"\u2003"},{"sup":"\u2003"}]},{"entry":[{},{},"2. <ARG"]},{"entry":[{},{},{"sup":"\u2003"}]},{"entry":[{},{},{"sup":"\u2003"}]},{"entry":[{},{},{"sup":"\u2003"}]},{"entry":[{},{},{"sup":"\u2003"}]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}}],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing aspects and many of the attendant advantages of this invention will become more readily appreciated as the same becomes better understood by reference to the following detailed description, when taken in conjunction with the accompanying drawings, wherein:",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 6","FIG. 1"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 12","FIG. 11"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 12A","FIG. 12"]},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 14A\u2013C"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 17","FIG. 16"]},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 23","FIG. 22"]}]},"DETDESC":[{},{}]}
