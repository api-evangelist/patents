---
title: Software framework and development platform for multi-sensor systems
abstract: The disclosed software framework and development platform facilitates software development for multi-sensor systems. In some implementations, developers can select a sensor board that includes a desired combination of sensor devices. The sensor board can be coupled to a development board that includes a target processor and other circuitry to facilitate development and testing of a system that includes the target processor and the sensors. Various software support tools are provided including an Application Programming Interface (API) that provides API abstractions for software drivers for the sensors on the sensor board. By using the abstractions of the API, a software developer does not have to write code (“glue”) to interact with the various software drivers. Additionally, the API provides access to a variety of software library functions for performing data scaling, unit conversion and mathematical functions and algorithms.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08869095&OS=08869095&RS=08869095
owner: Atmel Corporation
number: 08869095
owner_city: San Jose
owner_country: US
publication_date: 20110517
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","Exemplary Development Platform"],"p":["This application claims priority to U.S. Provisional Application No. 61\/422,084, filed on Dec. 10, 2010, entitled \u201cSoftware Framework and Development Platform for Multi-Sensor Systems,\u201d the entire contents of which are incorporated by reference.","This subject matter is generally related to software development, and more particularly to software frameworks and development platforms for multi-sensor systems.","Many modern mobile devices (e.g., smart phones, electronic tablets) include a suite of sensors to support applications that require inertial and environmental sensor data. Inertial data can be provided by onboard accelerometers, gyro sensors and magnetometers. Environment data can be provided by temperature, pressure, proximity and ambient light sensors. Inertial and environmental sensors can be provided as integrated circuit chips by a number of manufacturers. Thus, it is common for a single device to include sensors from a variety of manufacturers. Each sensor can include its own software driver to allow program code running on an application processor (e.g., a microcontroller) to interact with the sensor, such as requesting sensor data or programming the sensor.","Since the sensor device manufacturers sell their devices to many customers, the sensor devices typically provide raw data to allow the customer's software applications to process the raw data as desired. Application developers must perform further processing on the raw data (e.g., scaling and units conversion) which requires additional processing cycles from the application processor.","The disclosed software framework and development platform facilitates software development for multi-sensor systems. In some implementations, developers can select a sensor board that includes a desired combination of sensor devices. The sensor board can be coupled to a development board that includes a target processor and other circuitry to facilitate development and testing of a system that includes the target processor and the sensors. Various software support tools are provided including an Application Programming Interface (API) that provides API abstractions for software drivers for the sensors. By using the API abstractions, a software developer does not have to write code (\u201cglue\u201d) to interact with the various software drivers. Additionally, the API abstractions provide easy access to a variety of software library functions for performing data scaling, unit conversion and mathematical functions and algorithms.","Particular embodiments of the invention can be implemented to realize one or more of the following advantages: 1) rapid and efficient software development for multi-sensor systems, 2) reduced software development costs, and 3) an easy interface to sensors and standard API definition to application software.",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1","b":["100","100","102","104"]},"Development board  can include target processor , board controller , digital ports -, data memory  (e.g., flash memory), analog port , programming port , serial port  (e.g., USB), general purpose I\/O port  (GPIO) and touch slider interface .","Target processor  is the processor that is storing and executing the software that is being developed or tested using developer board . Board controller  controls the functions of developer board , including power management, I\/O ports and peripherals, bus management, memory management and any other functions that are related to development board . Board controller  can execute operating system code for performing the various developer board functions. Digital ports , provide a digital interface to developer board  to various digital devices and peripherals. Analog port  provides an analog interface to developer board  for various analog devices and peripherals. Programming port  provides an interface to developer board  that allows another computing device to load program code into development board  for execution by target processor . Serial port  provides a serial communications interface (e.g., USB) to developer board . General purpose I\/O (GPIO) port provides a general interface port to development board  for external devices and peripherals. Touch slider interface  provides an interface to developer board  for touch slider input. Other development boards may include more or fewer components.","Sensor board  can include interface  for interfacing with developer board . Sensor board  includes sensors . Sensors  can be any combination of sensor devices selected by the developer. Sensors can be inertial sensors, where sensor is an accelerometer, sensor is a gyro sensor, and sensor is a magnetometer. Some sensor boards may include environment sensors, including temperature sensors, pressure sensors and light sensors. Still other sensor boards may include a combination of inertial sensors and environment sensors.","Each of these sensor devices can be integrated circuit chips provided by different manufacturers. Multiple sensors can be provided in single integrated circuit package (e.g., accelerometer and gyro combination). Each sensor device can provides raw sensor data through a dedicated software driver developed for that particular sensor. The dedicated software driver provides a low-level API for allowing the user to request raw sensor data. Application program code can access these software drivers through a high-level API that provides abstractions for the software drivers, thus adding a layer of transparency to the software drivers. This additional level of transparency can simplify the development of the application program code by reducing the amount of knowledge the developer needs about the software drivers to interface with the sensors. With the high-level API no sensor-specific code is required for the application. Using the high-level API, applications can be used with different hardware platforms with no source code modification. The high-level API is discussed in more detail in reference to .",{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 2","FIG. 1"],"b":["200","200","202","204","206","204","208","104","200"]},"In the example architecture , there is a mix of inertial and environmental sensors in hardware . This results in drivers and API abstractions in driver layer  for each of the sensors as shown in . Software library functions in software library function layer  will access the software drivers using the API abstractions. Some examples of software library functions can be scaling, unit conversion, mathematical calculations or algorithms or any other desired function that can be beneficial to an application. The sensors shown in  are not an exhaustive list and other types of sensors can be supported in a similar manner.","In some implementations, a software framework can be provided in driver layer . Software framework is an abstraction that includes common code for providing generic functionality which can be selectively overridden or specialized by user code, thus providing specific functionality. The software framework can include reusable abstractions of code wrapped in the API, and may contain distinguishing features that separate them from other software library functions.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 3","FIG. 2"],"b":["300","300","302"]},"Process  identifies a target sensor for providing sensor data (). Process  checks to see if raw sensor data was requested (). If raw sensor data is requested, process  requests the raw sensor data from the target sensor (), receives the raw data from the target sensor (), and returns the raw sensor data to the calling application (). If raw sensor data is not requested, process  requests the raw data from the target sensor (), receives the raw sensor data from the target sensor (), processes the raw data (), and returns the processed raw sensor data to the calling application (). Processing raw data () can include data scaling, conversion or calculating mathematical formulas or algorithms using the raw data.","Using the high-level API, an acceleration reading sequence can have the following form:",{"@attributes":{"id":"p-0023","num":"0022"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"#include \u201csensor.h\u201d"},{"entry":"sensor_t accel_dev;\u2003\u2003\u2003\u2002\u2009\/\/ accelerometer device descriptor"},{"entry":"vector_data_t accel_data;\u2003\/\/ acceleration data from device"},{"entry":"sensor_attach (&accel_dev, SENSOR_TYPE_ACCELEROMETER,"},{"entry":"0, 0);"},{"entry":"accel_data.scaled = true;\u2003\u2002\u2009\/\/ read values in milli-g's"},{"entry":"sensor_get_acceleration (&accel_dev, &accel_data);"},{"entry":"app_x_value = accel_data.axis.x;\u2003\u2002\u2009\/\/ 3-axis acceleration data in user"},{"entry":"application"},{"entry":"app_y_value=accel_data.axis.y;"},{"entry":"app_z_value=accel_data.axis.z;"},{"entry":"app_read_time = accel_data.timestamp.\u2003\u2003\/\/timestamp in"},{"entry":"microseconds"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In this example, the API call sensor_attach ( ) and the sensor descriptor accel_dev can be used to identify the accelerometer as the target sensor. Raw accelerometer data can be requested by the calling application program by setting accel_data.scaled=true. This will result in raw acceleration data in milli-g's to be returned to the calling application program. The API function call sensor_get_acceleration ( ) can be used to get the acceleration data and return the acceleration data in the three fields of the accel_data structure.","The API can use two basic structured data types to return sensor data. The first data type is vector_data_t. This data type can be used for 3-axis sensing devices (e.g., accelerometer, gyro) or other readings that return three values (e.g., compass heading). The three values can be returned in three separate data fields (e.g., 32-bit signed integers). The second data type is scalar_t. This data type can be used to return one-dimensional measurements (e.g., temperature, pressure).","Other sensors have a similar reading sequence. For example, a gyro sensor can have a reading sequence in the following form:",{"@attributes":{"id":"p-0027","num":"0026"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"#include \u201csensor.h\u201d"},{"entry":"sensor_t gyro_dev;\u2003\u2003\u2003\/\/ gyro device descriptor"},{"entry":"vector_data_t gyro_data;\u2003\/\/ rotation data from device"},{"entry":"sensor_attach (&gyro_dev, SENSOR_TYPE_GYROSCOPE, 0, 0);"},{"entry":"gyro_data.scaled = true;\u2003\u2002\u2009\/\/ read values in milli-g's"},{"entry":"sensor_get_gyro (&gyro_dev, &gyro_data);"},{"entry":"app_x_value = gyro data.axis.x;\u2003\u2003\/\/3-axis gyro data in user application"},{"entry":"app_y_value=gyro_data.axis.y;"},{"entry":"app_z_value=gyro_data.axis.z;"},{"entry":"app_read_time = gyro_data.timestamp.\u2003\u2003\/\/timestamp in microseconds"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Many sensor devices can provide temperature data as a secondary output value. The temperature data can be used internally in the device for temperature compensation. An exemplary temperature reading sequence for a gyroscope can have the following form:",{"@attributes":{"id":"p-0029","num":"0028"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["#include \u201csensor.h\u201d",{}]},{"entry":["sensor_t gyro_dev;","\/\/ gyro device descriptor"]},{"entry":["scalar_data_t temp_data;","\/\/ temperature data from device"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"sensor_attach (&gyro_dev, SENSOR_TYPE_GYROSCOPE, 0, 0);"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["temp_data.scaled = true;","\/\/ read values in degrees Celsius"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"sensor_get_temperature (&gyro_dev, &temp_data);"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["app_temp_value = temperature;","\/\/temperature in user"]},{"entry":[{},"application"]},{"entry":["app_read_time = accel_data.timestamp.","\/\/timestamp in microseconds"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"In some implementations, API calls can provide mathematical functions or algorithms. For example, an API call for compass heading involves gathering 3-axis magnetic sensor measurements X, Y, Z, and using an accelerometer gravitational acceleration to measure tilt angles roll (\u03b8) and pitch (\u03a6). The X and Y magnetic sensor measurements can be rotated into a horizontal level plane defined by vectors Xand Yusing equations [1] and [2]:\n\ncos(\u03a6)+sin(\u03b8)*sin(\u03a6)\u2212cos(\u03b8)sin(\u03a6), \u2003\u2003[1 ]\n\ncos(\u03b8)+sin(\u03b8). \u2003\u2003[2]\n","Azimuth can be computed from equations [1] and [2] using equation [3]:",{"@attributes":{"id":"p-0032","num":"0031"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mi":"Azimuth","mo":"=","mrow":{"mrow":{"msup":{"mi":"tan","mrow":{"mo":"-","mn":"1"}},"mo":"\u2061","mrow":{"mo":["(",")"],"mfrac":{"msub":[{"mi":["Y","H"]},{"mi":["X","H"]}]}}},"mo":"."}}},{"mrow":{"mo":["[","]"],"mn":"3"}}]}}}}},"A magnetic heading calculation sequence can have the following form:",{"@attributes":{"id":"p-0034","num":"0033"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"#include \u201csensor.h\u201d"},{"entry":"sensor_t compass_dev;\u2003\u2003\u2003\u2003\u2003\u2002\u2009\/\/ compass device descriptor"},{"entry":"vector_data_t temp_data;\u2003\u2002\u2009\/\/ heading data from device"},{"entry":"sensor_attach (&compass_dev, SENSOR_TYPE_COMPASS, 0, 0);"},{"entry":"compass_data.scaled = true;\u2003\/\/ read values in degrees and microTesla"},{"entry":"sensor_get_heading (&compass_dev, &compass_data);"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["app_heading = compass_data.field.heading;","\/\/0 to 360 deg in"]},{"entry":[{},"user application"]},{"entry":["app_inclination = compass_data.field.inclination","\/\/\u221290 to 90 deg in"]},{"entry":[{},"user application"]},{"entry":["app_field_strength = compass_data.field.strength","\/\/ micro Tesla"]},{"entry":["app_read_time = compass_data.timestamp;","\/\/timestamp in"]},{"entry":[{},"microseconds"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 4","FIG. 1","FIG. 2"],"b":["400","400","402","404","406","410","412","414","416","418","420","412","422","426","424","414","416","418","420","410","404","410","402"]},"While this document contains many specific implementation details, these should not be construed as limitations on the scope of what may be claimed, but rather as descriptions of features that may be specific to particular embodiments. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable sub combination. Moreover, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a sub combination or variation of a sub combination."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0010","num":"0009"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 4","FIG. 1","FIG. 2"]}]},"DETDESC":[{},{}]}
