---
title: Method and apparatus for configurable mapping between data stores and data structures and a generalized client data model using heterogeneous, specialized storage
abstract: A flexibly adaptable, i.e., configurable and/or extensible, asset management system is disclosed for processing and querying assets, representing data. The system comprises three layers: a Client Application layer, for manipulating and browsing assets, an Asset Manager Server layer, for providing programming interface services specific for assets types, such as storing, querying, and retrieving assets representing data to and from a Data Store, representing the third layer. The Asset Manager Server layer further provides communication services to support the Client Application layer and file transfer between the Client Application layer and the Asset Manager Server layer. The Asset Manager Server includes several configurable and/or extensible modules, including a Client Adapter module, a Schema Adapter module and a Resources module.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06917939&OS=06917939&RS=06917939
owner: International Business Machines Corporation
number: 06917939
owner_city: Armonk
owner_country: US
publication_date: 19981223
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO PROVISIONAL APPLICATION","CROSS REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT"],"p":["This application claims priority from U.S. Provisional Application No. 60\/086,382, entitled \u201cDigital Library With Architecture Guide,\u201d filed on May 22, 1998, by William J. Baer, Pedro Jacob Jr., I-Ming Kao, Jan L. Murray, Deidra S. Picciano, Jerry D. Robertson III, and James A. Willey, which is incorporated by reference herein.","This application is also related to the following applications, filed on the same day as the present application:","U.S. Pat. No. 6,366,916, entitled \u201cA Configurable And Extensible System For Deploying Asset Management Functions To Client Applications\u201d to William J. Baer, I-Ming Kao, Pedro Jacob, Janet L. Murray, Deidra S. Picciano, Jerry D. Robertson and James A. Willey;","Ser. No. 09\/219,934, Pending entitled \u201cMethod And Apparatus For Using Classes, Encapsulating Data With Its Behaviors, For Transferring Between Databases And Client Applications And For Enabling Application To Adapt To Specific Constraints Of The Data\u201d to William J. Baer, I-Ming Kao, Pedro Jacob, Janet L. Murray, Deidra S. Picciano and Jerry D. Robertson; and","Ser. No. 09\/220,291, Pending entitled \u201cMethod And Apparatus For Dynamically Customizing And Extending Functions Of A Server Program To Enable And Restrict Functions Of The Server\u201d to William J. Baer, I-Ming Kao, Pedro Jacob, Janet L. Murray, Deidra S. Picciano and Jerry D. Robertson.","1. Field of the Invention","The present invention relates in general to asset management, and in particular to a flexibly adaptable, i.e. configurable and\/or extensible, system for deploying asset management functions to client applications. The present invention further relates to other features of an asset management system, including encapsulating data with its behaviors for transferring information between databases and client applications and enabling client applications to adapt to specific constraints of the data, dynamically customizing and extending functions of a server program to enable and restrict functions of the server, and configurably mapping between data stores and data structures, thereby providing a generalized client data model.","2. Description of the Related Art","Assets, which represent data, must be properly managed for their value to be maximized. These assets may represent data in the form of text, full-motion video, audio, graphics, or images, for example. Regardless of the asset form, asset solutions are needed having sufficient storage capacity, scalability and sophisticated searching techniques.","Assets can be stored in physical storage devices, for example, in various searchable databases. Most existing database applications provide searching and manipulation capabilities for only a specific asset or data type for a specific database. However, such existing applications lack the flexibility to be imported to different databases or to handle different asset or data types. At the same time, creation of the assets can be accomplished for a specific client problem in existing applications, but cannot be expanded to cover a generic situation.","For example, U.S. Pat. No. 5,745,754 to Lagarde et al., an example of an existing system, teaches a system for querying databases located on multiple platforms, processing data obtained, and presenting processed data to a client. The system includes an application-processing agent (web server), which performs tasks in a distributed environment based on received requests from the client. However, Lagarde et al. does not provide the flexibility of the present invention.","As the development of modern digital media continues, the volume of assets is growing rapidly. This rapid increase in assets requires the development of efficient asset management technology through integration of the technologies of information capture, storage management and search and retrieval.","To overcome the limitations in the prior art described above, and to solve various problems that will become apparent upon reading and understanding of the present invention, the present invention provides a method, apparatus, and article of manufacture for computer-implemented management of assets in an object oriented environment.","In accordance with the present invention, a flexibly adaptable, i.e., configurable and\/or extensible, asset management system is disclosed for processing and manipulating assets, representing data. The system comprises three layers: a Client Application layer, for manipulating and browsing assets, an Asset Manager Server layer, for providing programming interface services specific to assets types, such as storing, querying, and retrieving assets representing data. The data is stored in a Data Store, representing the third layer of the system. The Asset Manager Server layer also provides communication services to support the Client Application layer and file transfer between the Client Application layer and the Asset Manager Server layer.","The Asset Manager Server layer includes several configurable modules, including a Client Adapter module, a Schema Adapter module and a Resources module.","An object of the present invention is to provide a framework that generalizes many existing techniques and provides a configurable and\/or extensible asset management system, which is reusable for different client applications and data types.","Another object of the invention is to provide a system having a configurable Asset Manager Server.","A further object of the invention is to provide a system using classes, encapsulating data with its behaviors, for transferring data between databases and client applications.","Yet a further object of the invention is to provide a system capable of dynamically customizing and extending functions of an Asset Manager Server program.","Yet another object of the invention is to provide a system capable of configurably mapping between Data Stores and data structures.","In the following description of the preferred embodiment, reference is made to the accompanying drawings which form a part hereof, and which show by way of illustration a specific embodiment of the invention. It is to be understood by those of ordinary skill in this technological field that other embodiments may be utilized, as structural changes may be made without departing from the scope of the present invention. For example, while the following discussion is presented in the context of a Java\u00ae (a registered trademark of Sun Microsystems Inc.) based implementation, the present invention is not so limited.","I. Overall Architecture",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 1","b":["10","10","20","30","40"]},"The Client Application layer  allows a user to interact with AMS . With this configuration, a user need not know of the details or even the existence of the Data Store layer . The Client Application layer  consists of an Asset Manager Client (AMC) , allowing the user to manipulate and browse assets, and an Asset Manager System administrator tool (AMSAT)  for maintaining and configuring the AMS .","An asset is defined to be a set of related data, or meta data, for a document or an objec and\/or the actual data itself. It is the assets which provide the Client Application with an easy to use interface for manipulating data without the Client Application needing to know where or how the data is actually stored. The set of related data may consist of relational data, files, references to files from indexing engines, or any other combination of data types. Each asset has an associated asset type used by the system  to identify a particular mapping between the assets and the actual data stored. In other words, different asset types will have different mappings. Specific details of the components of the system  and their respective functions will be discussed below.","Turning to , the AMC  provides the user with a user interface , an application programming interface (API), with which the user interacts. In one example, the user interface may include four modules: a logon module , incorporating functions needed to logon to\/logoff from the AMS ; a query module  housing functions needed to query the AMS for assets; a results module  providing functions needed to browse results returned by a query applied to the AMS ; and an edit module  incorporating functions needed to manipulate (add, update, delete, and retrieve, for example) assets. The AMC  also includes a server connection , which provides the connection between the AMS  and the user interface  of AMC .","Referring now to , the AMSAT  of Client Application  is designed to allow a particular user, a system administrator, to manipulate the configuration of the AMS . Modules within AMS  which can be configured, including Schema Adapters, Client Adapters, Plug-ins and external services, will be discussed in further detail below. The AMSAT  provides the system administrator with a user interface  and allows the system administrator to configure the AMS  through system administration module . The AMSAT further includes a server connection , similar to server connection  in the AMC, providing a connection between the AMS  and the user interface  of AMSAT .",{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 4","FIG. 4"],"b":["30","10","30","40","30","20","20","30","30","300","301","302","20","300","300","301","30"]},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 5","b":["10","40","40","40","401","403","403","401","30","40","400","30","403","403","400","40","402","401","403","402","302","30","4"]},"Referring now to , each of the three layers presented above communicate with each other as shown. For example, when a user issues a query from the Client Application , flow of control passes from the AMC  through the AMS  to the Data Store  and back.","II. The Asset Manager Server","Referring back to , the AMS  includes the Client Adapter module , the Schema Adapter module , and the Resources module . The details of each of these modules will now be discussed.","A. The Client Adapter Module","The Client Adapter module  provides much of the functionality needed to interact with the Client Application . More specifically, the Client Adapter module  provides the interfaces used by the Client Application  to interact with the AMS . The Client Adapter module  further acts as a bridge between the Schema Adapter module  and the Client Application . Finally, the Client Adapter module  also utilizes the Resources module  to accomplish tasks required by the Client Application .","Referring to , the Client Adapter module  includes one or more Client Adapters. The Client Adapters may constitute Java\u00ae classes that encapsulate data and a related set of functionality and also function as an API to the AMS . As a result, the Client Application  contacts the Client Adapters when prompted by the user to communicate with the AMS . In one example, the Client Adapter module  may contain four Client Adapters: query , results , edit , and system administrator . However, according to the present invention, any number of Client Adapters can be added to or deleted from the Client Adapter module , thereby providing for the configurability of the AMS","In the example illustrated in , the system administrator  Client Adapter performs system administration tasks and provides a communication link between the AMS and the AMSAT . The other Client Adapters, query , results , and edit , interact with the AMC  and with the Schema Adapter module .",{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 7","FIGS. 1"],"b":["2","4","5"]},"In , the components above the dashed line can be found in the Client Application ( in FIG. ). User interface  corresponds to user interface  of FIG. . Master Client Adapter  and logon Client Adapter  correspond generally to functions provided by server connection  of FIG. . Master server adapter  corresponds generally to functions provided by server connection  of FIG.  and by AMS  of FIG. . Master server  provides connectivity functions between AMS  of FIG.  and server connection  of FIG. . New Client Adapter  corresponds to a Client Adapter in Client Adapter module  in FIG.  and new schema controller  corresponds to a specific Schema Adapter in Schema Adapter module  of FIG. . Data Store  corresponds to Data Store  of FIG. . Plug-in factory  and Plug-in container  correspond to the Plug-ins module  in FIG. .","Additionally, in the following examples, terminology which will be used is defined as follows. A method is defined as a function executed in the system . An interface consists of a group of functions or methods. An argument is a parameter of a function. A subclass is used to extend an abstract class or interface to modify the interface of the abstract class in some way. An API is a specific type of interface consisting of a group of functions.","Furthermore, in each of the four examples presented below, it is assumed that a new file or data type, Microsoft\u00ae Word\u2122, is to be supported. As noted earlier, the present invention is applicable to a variety of asset or data types, not to be limited by the following example. Finally, in the four examples presented herein, the code sections are written in Java\u00ae. However, other code implementations of the present invention are possible.","B. Example: Creating and Adding New Client Adapters","In accordance with the present invention, the system  is configurable and\/or extensible. The configurability and\/or extensibility is provided, in part, by the ability to construct and add new ones of the Client Adapters to the Client Adapter module . The configurable and\/or extensible system of the present invention provides the benefit of dynamic APIs between the Client Application  and the AMS . Additionally, the system of the present invention allows new ones of Client Application  to be connected to the AMS  by implementing new Client Adapters. As Client Adapters are added, the AMS  provides new functionality to the Client Application . Correspondingly, as Client Adapters are removed, the AMS  provides reduced functionality to the Client Application .","New Client Adapters may created and added in accordance with the following steps:","i. Define User Interactions with the AMS;","ii. Define an API encapsulating new functionality;","iii. Define the Client Adapter Load Time Interface;","iv. Define the Client Adapter Run Time Interface.","Each of these steps will now be discussed in detail.","i. Define the User Interactions with the AMS","Prior to defining the API for a new Client Adapter, the way in which a user will be interacting with the AMS, i.e., how the Client Adapter will be used, should be defined. Generally, a user interface is already available for manipulating (add, update, delete and retrieving) as well as querying Word\u2122 documents. Thus, in the present example, the user may want additional interfaces to add, update, delete, retrieve and query Word\u2122 documents based on a number of properties defined in Word\u2122 format. For example, the user may wish that each paragraph from a document be extracted and placed into IBM's Text Miner\u2122 product. This will allow the user to perform free text queries on the paragraphs. In addition, the user may wish to have available information regarding the number of paragraphs and pages in each Word\u2122 file. The text of the paragraphs, number of paragraphs and the number of pages are referred to as properties of the Word\u2122 file.","ii. Define an API Encapsulating the New Functionality","Taking the retrieve interface as an example of new functionality which is desired by a user, an API needs to be defined which encapsulates this new functionality. This involves creating functions for retrieving an asset from the Data Store to the Client Application. Suppose the retrieve process is defined by the following function.\n\n","This function returns an asset of type Object using an argument, anAssetID, to define a unique identifier of the asset to be retrieved. The remaining interfaces, add, update, delete and query, may be similarly implemented.","Once an interface has been defined, the retrieveAsset function is also defined. This function will be used by the Client Application to retrieve data from the AMS. However, at this point, the AMS knows nothing about this function. The following step describes how this function is registered with the AMS.","iii. Define the Client Adapter Load Time Interface","Referring to , the new Client Adapter  is loaded when the Master Server  is started. There are a number of methods executed during this loading process. These load time methods are responsible for constructing a communication between the Master Server , Client Adapter  and Schema Adapter (or Schema Controller) . At load time the Master Server  calls the method, setServer on the Client Adapter . The Client Adapter  retains a handle to the Master Server  so that future calls can be made to the Master Server  from the Client Adapter . Each Client Adapter  is uniquely identified by an ID and given a descriptive name. Two methods, getViewID and getName, are defined on the Client Adapter  and are called by the Master Server  during the loading process. The newSession method will be described later. The Master Server  calls these two methods and builds a directory of all Client Adapters  in the system, thereby registering the Client Adapters . The IDLAbstractClientAdapterI interface is defined to be:",{"@attributes":{"id":"p-0067","num":"0067"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public interface IDLAbstractClientAdapterI extendsjava.io.Serializable"},{"entry":"{"},{"entry":"void setServer(IDLMasterServerI AMS);"},{"entry":"int get ViewID( );"},{"entry":"String getName( );"},{"entry":"Object newSession(IDLActiveUserInfoI aNewSessionInfo) throws"},{"entry":"RemoteException;"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"iv. Define the Client Adapter Run Time Interface","Before defining the steps necessary to construct a run time interface, a description of the run time relationships between the Client Application and AMS will be provided. Referring to , at load time the Master Client Adapter  is informed of the New Client Adapter  by the Master Server . Likewise at load time the Master Server informs the new Client Adapter  of any new Schema Controllers  and vice versa. Once the load registration is completed, methods\/functions can be called between these objects.",{"@attributes":{"id":"p-0070","num":"0070"},"figref":"FIG. 8","b":["705","705","701","710","702"]},"In this example, there is only one instance of any given Client Adapter  loaded at load time. Therefore, there is only one instance of a Client Adapter class in the system. This is not to say that there is only one Client Adapter in the system at a time, but rather only one instance of a particular class. Due to the fact there is only one instance of a Client Adapter class in this example, the Client Adapter must establish session connections to support multiple Client Applications logged on concurrently. This session information is stored in an IDLSessionInfoI interface.","After the logon method  has completed, the Master Client Adapter  sends a newSession method  to the Client Adapter  to retrieve a new instance of the IDLSessionInfoI interface. The Master Client Adapter  or something else on the Client Application is responsible for storing the new instance of IDLSessionInfoI. This IDLSessionInfoI instance is then passed as the first argument to all future run time methods on the Client Adapter . In the present Word\u2122 example, the retrieveAsset run time method was defined above. If the Master Client Adapter  received a request from the Client Application to retrieve an asset, the Master Client Adapter  calls the retrieveAsset method  providing the instance of IDLSessionInfo returned in the newSession method as well as the AssetType the Client Application is attempting to retrieve. The AssetType is another required argument for all run time methods in this example because each Client Adapter can have m Schema Controllers it can communicate with. Each Schema Controller is identified by this AssetType argument.","Similar to the Client Adapter, the Schema Controller has only one instance per class. Therefore, the Schema Controller also needs a session information concept so concurrent users can be supported in this example. The IDLSCSessionI provides the Schema Controllers session information. Each IDLSessionInfoI retains a group of IDLSCSessionIs, so existing sessions can be reused by other run time methods. Once the method retrieveAsset  is received by the Client Adapter , the Client Adapter  is responsible for looking through the group of IDLSCSessionIs  to see if one already exists for the AssetType provided. If so, that IDLSCSessionI is used as the first argument into the Schema Controller . In other words, the retrieveAsset method  is called with the existing IDLSCSessionI instance residing in the IDLSessinoInfoI. If there is not an existing IDLSCSessionI defined for the AssetType then the newRetrieveSession method  is called with an argument of DBSessions. The DBSessions is provided in the IDLSessionInfoI. The newRetrieveSession method returns a new instance of IDLSCSessionI to the Client Adapter . The Client Adapter  adds this new instance to the IDLSessionInfoI and proceeds to call the retrieveAsset  with this instance of IDLSCSessinoInfoI.","To construct a new Client Adapter , a developer or user should construct an interface that subclasses the IDLAbstractClientAdapterI interface. The new functions provided by the new Client Adapter  are defined in this interface. Continuing with the Word\u2122 example, the retrieveAsset function is defined having the following signature:\n\n","The following three arguments should be added to the signature for an adequate Client Adapter: IDLSessionInfoI, AssetType and actionPath. The actionPath argument provides the context for a Plug-in that will be returned later. These three arguments are added and the new Client Adapter Interface is defined as follows:",{"@attributes":{"id":"p-0076","num":"0077"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Public interface IDLRetrieveClientAdapterI extends"},{"entry":"IDLAbstractClientAdapterI"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Object retrieveAsset(IDLSessionInfoI aSessionInfo, String"]},{"entry":[{},"anAssetType,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"IDLAssetIDI anAssetID, String actionPath) throws RemoteException;"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The first and second arguments: asessionInfo and anAssetType provide concurrent user and multiple Schema Adapter support. The IDLAssetIDI is the argument needed in the original retrieveAsset function, and actionPath defines the Action Path of the Plug-in. Plug-ins will be discussed in further detail below. The Action Path defines the type of object returned in the Object field to the Client Application and is passed on to the retrieveAsset method defined below in the Schema Adapter example.","The Client Adapter interface is now defined. Below are the definitions of the IDLSessionInfoI and IDLActionUserInfoI that are used frequently by the Client Adapter in providing its services.","The IDLActiveUserInfoI interface is defined to be:",{"@attributes":{"id":"p-0080","num":"0081"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public interface IDLActive UserlnfoI extends java.io.Serializable"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int getuserID( );"]},{"entry":[{},"String getUserName( );"]},{"entry":[{},"String getOrigin( );"]},{"entry":[{},"Dictionary getDBSessions( );"]},{"entry":[{},"Vector getActiveClientSessions( );"]},{"entry":[{},"String getUID( );"]},{"entry":[{},"void addActiveClientSession(IDLSessionInfoI aSessionlnfo);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The IDLSessionInfoI interface is defined to be:",{"@attributes":{"id":"p-0082","num":"0083"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public interface IDLSessionInfoI"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"IDLActive UserInfoI getUserInfo( );"]},{"entry":[{},"int getViewID( );"]},{"entry":[{},"Hashtable getActiveSessions( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The getActiveSessions method defined on the IDLSessionInfoI is notable. When this method is called by the Client Adapter, a hashtable is returned. The hashtable contains the AssetTypes as keys and the IDLSCSessionI as values. This is the method needed by the Client Adapter to search for existing IDLSCSessionI prior to calling methods  or , as discussed above.","C. The Schema Adapter Module","Returning to , the Schema Adapter module  includes one or more Schema Adapters, where each Schema Adapter maps the Data Store  schema into assets of a particular asset type via an object oriented representation suitable for the Client Application . Each Schema Adapter may be a Java\u00ae class implementing high-level data requests to work with the particular asset type supported. Having detailed knowledge about the database model of the particular asset type, the Schema Adapter translates the high-level data requests to database requests applicable to the asset type.","Generally, one Schema Adapter corresponds to each asset type supported within the system . However, it is possible to have two or more Schema Adapters corresponding to a single asset type, where each of the two or more Schema Adapters stores data in a different manner. In one example, the Schema Adapter module  may include a Schema Adapter  to support documents in Word\u2122 format, the asset type being MSWord. It is to be understood by those of ordinary skill in the art that, due to the configurable structure of the AMS , other Schema Adapters required by different asset types supported by the AMS  may be implemented within the Schema Adapter module .","D. Example: Creating and Adding New Schema Adapters","The configurability and extensibility of the present invention is further demonstrated by the ability to create and add new ones of the Schema Adapters in accordance with the following procedures.","In the following example, while a Schema Adapter may contain many Schema Controllers, only a single Schema Controller is used. Thus, in the following example, the terms Schema Adapter and Schema Controller will be used interchangeably.","A Schema Controller defines the communication between the AMS and the Data Store. Further, a Schema Controller is responsible for implementing the interfaces defined by the Client Adapters. Often a new Schema Controller is constructed for the purpose of supporting database operations for a new type of Asset (e.g. AssetType=MSWord). An AssetType is a placeholder for a file type. Another reason for constructing a new Schema Controller is to support a new schema for an existing type of Asset (e.g. AssetType=MSWord_Optimized). In the first case, a new file type, Word\u2122, is to be supported, whereas in the second case, an asset type, Word\u2122, has been previously constructed but the new Schema Controller defines an optimized query that is different from the first case.","New Schema Controllers are created and added in accordance with the following steps:","i. Choose Asset Type(s) for the Schema Controller;","ii. Define the User Interactions with the AMS;","iii. Choose the Data Store(s) for the Asset Type(s);","iv. Define the Schema Controller Load Time Interface;","v. Use the User Interactions to define the Schema Controller Run Time Interface;","vi. Implement a parser for the Asset Type(s) if necessary.","Each of these steps will now be discussed in detail.","i. Choosing Asset Type(s) for the Schema Controller","In this example, and as described above, suppose a user requests a new type of file to be stored into a digital library or some other Data Store. Furthermore, suppose this file is of type Word\u2122. Word\u2122 files store the content of a text document and the meta-data describing font size, color and typeface of each word in the document. This meta data also describes the page breaks, paragraph starting points, etc. The user's request may be satisfied by creating a new Asset Type, MSWord. This Asset Type defines the Schema Controller about to be constructed.","ii. Define the User Interactions with the AMS","Prior to defining the interfaces for the Schema Controller, the uses of the Schema Controller should be defined. As presented above, this is done by defining how the user will interact with the AMS. As discussed in the Client Adapter example above, a user may want to add, update, delete, retrieve and query Word\u2122 documents on a number of properties defined in Word\u2122 format. These properties of the MSWord file may include the text of the paragraphs, number of paragraphs and the number of pages.","After defining the properties the user may be interested in storing and querying those properties. A data model for storing this information can be constructed. From the previous discussion, a simple data model might be:\n\n","Both the Client Application interaction and the data model definition will be used to define the Schema Controller interface as well as define how to implement the interface.","iii. Choose the Data Store(s) for the Asset Type(s)","The next step is to choose the Data Stores that will be used to store and query the data. In the present example, the user may choose IBM's Digital Library\u00ae, IBM's DB2\u2122 and IBM's Text Miner\u2122 as three Data Stores. The usage of these three Data Stores becomes transparent to the user, as will become apparent.","iv. Define the Schema Controller Load Time Interface","Referring to , the Schema Controller  is dynamically loaded by the AMS at run time. During the dynamic loading process, the Schema Controller  registers with the AMS. This registration process consists of identifying those Client Adapter interfaces implemented by the Schema Controller . This is accomplished via the IDLSchemaControllerI interface. The Schema Controller  must subclass\/implement (using Java\u00ae, for example) this interface. At load time, the methods defined below are executed. The result of this execution is that the proper Client Adapters  are informed of the new Schema Controller's  presence by the Master Server .",{"@attributes":{"id":"p-0109","num":"0116"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public interfoce IDLSchemaControllerI"]},{"entry":[{},"{"]},{"entry":[{},"void setServer(IDLMasterServerI AMS) throws RemoteException;"]},{"entry":[{},"String getSchemaControllerName( ) throws RemoteException;"]},{"entry":[{},"int getSchemaControllerID( ) throws RemoteException;"]},{"entry":[{},"Vector getSchemaControllerAssetsTypes( ) throws RemoteException;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Each Schema Controller  is assigned a unique name and ID, which are returned by the methods getSchemaControllerName and getSchemaControllerID respectively. The setServer method saves a handle to the Master Server  for later use by the Schema Controller . The getSchemaControllerAssetsTypes method defines the Client Adapters  a Schema Controller  is associated with. This is accomplished through the vector returned by the getSchemaControllerAssetsTypes method. This vector contains one or more instances of IDLAssetTypeJ.",{"@attributes":{"id":"p-0111","num":"0118"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public class IDLAssetTypeJ"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public String getName( );"]},{"entry":[{},"public void setName(String asName);"]},{"entry":[{},"public int getID( );"]},{"entry":[{},"public void setID(int aiID);"]},{"entry":[{},"public boolean is ViewSupported(int aiViewID);"]},{"entry":[{},"public String getViewSchemaController(int aiViewID);"]},{"entry":[{},"public void addViewSchemaController(int aiViewID, String"]},{"entry":[{},"asSubController);"]},{"entry":[{},"public Hashtable getAllSupportedViews( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The getName and getID methods answer the sender with the unique name and ID of the specified Asset Type respectively. The setName and setID methods set the name and ID returned by the getName and getID methods. The isViewSupported method returns a boolean depicting whether or not a Client Adapter  is supported by a Schema Controller  for the specified Asset Type. The getViewSchemaController, addViewSchemaController and getAllSupportedViews methods manipulate and query the Client Adapters  supported by a Schema Controller  for the specified Asset Type. The getViewSchemaController method answers the sender with the name of the Schema Controller  given a specific Client Adapter identifier. The addViewSchemaController method populates the list of Client Adapter identifier\/Server Controller name pairs. The getAllSupportedViews method answers the sender with a hashtable. This hashtable contains the Client Adapter identifiers as its keys and the Schema Controller name as its values.","The Schema Controller name and ID are different than the name and ID assigned to an Asset Type. In this example the Asset Type is \u201cMSWord\u201d. A unique name and ID for the Asset Type is \u201cMSWord\u201d and 20 respectively. A Schema Controller name and ID is \u201cMicrosoft Word1\u201d and 5 respectively. By separating the concept of data types being stored (Asset Type) from the manner in which it is stored (Schema Controller), a great deal of flexibility is provided. Other configurations could be:\n\n","Based on these configurations the relationship between Asset Types and Schema Controllers  is m to m.","The IDLAssetTypeJ instances are initialized by Schema Controllers . These instances define the Client Adapters  supported by each Schema Controller . The simple case has one object in the getSchemaControllerAssetsTypes vector, meaning the Schema Controller  supports one Asset Type. However, it is quite possible for a more complex Schema Controller to support several Asset Types.","For the Schema Controller  to create and populate an instance of IDLAssetTypeJ, it must know the unique identifier for the Client Adapter . This is accomplished by querying the AMS. A pointer to the AMS is stored in the Schema Controller  by the setServer method. Once a Schema Controller  is registered, its run time interface can be exercised to accomplish tasks for the Client Application.","v. Define the Schema Controller Run Time Interface","The next step is to define the Schema Controller run time interface(s). As discussed above, in this example, it is assumed that the user wishes to add, update, delete, retrieve and query Word\u2122 files. The Client Application separates these five functions into five separate windows. Therefore, five Client Adapters  can be implemented: AddCA, UpdateCA, DeleteCA, RetrieveCA and QueryCA. The Schema Controller  is responsible for implementing the methods defined on each of these five Client Adapters . Thus, the Schema Controller  must subclass\/implement (using Java\u00ae, for example) these five interfaces.","To better understand the API of the Schema Controller , initially, the communication between the Client Adapter  and the Schema Controller  will be reviewed. In the Client Adapter example, discussed above, the newSession method defined for the Client Adapter  was discussed. The implementation of newSession produces an instance of IDLSessionInfoJ that is returned to the Client Adapter . This instance retains all of the IDLSCSessionInfoJ instances that are constructed by the Schema Controller  newxxxSession methods. These methods will be discussed later. The IDLSCSessionInfoJ instances provide the Schema Controller  with context information allowing the Schema Controller  to complete the requested task for the proper AMS session. This context information often appears as Data Store logins. In other words, handles to active connections to Data Stores (e.g. DB2\u00ae, Text Miner\u2122, digital library). Data Store logins are also discussed below.","The newSession has a single argument, aSessionInfo, containing the Data Store logins. These are used to create the AMS session, IDLSessionInfo. The IDLSCSessionInfoJ that is produced by the Schema Controller  also retains the Data Store logins. In the present example, all methods on the Client Adapter  and Schema Controller  are state-less. That is, the session state must be passed as an argument for each call. The IDLSessionInfoI and IDLSCSessionInfoI are used to pass the state information to the Client Adapter  and Schema Controller  respectively. The Client Adapter  must send session information to the Schema Controller  in each method call. The convention is to make session information the first argument in all Schema Controller methods.","In this example, the newSession method does not logon to the Data Store, but rather expects the Data Store connections to be previously connected. Other implementations of Client Adapters  and Schema Controllers  may defer logon till the execution of the newSession method.","In the present examples, one Schema Controller  interface interacts with the Client Adapter . The IDLSCSessionI interface defines the Schema Controller  state information and is the first argument for all Schema Controller methods. This interface is populated by the Schema Controller , but can be queried by the Client Adapter .",{"@attributes":{"id":"p-0123","num":"0133"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public interface IDLSCSessionI extends java.io.Serializable"]},{"entry":[{},"{"]},{"entry":[{},"int getViewID( );"]},{"entry":[{},"int getSessionID( );"]},{"entry":[{},"Dictionary getDBSession( );"]},{"entry":[{},"Hashtable getProperties( );"]},{"entry":[{},"void setProperty(String asPropertyName, Object aoValue);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Instances of objects implementing the IDLSCSessionI interface are constructed when a newxxxSession is executed on the Schema Controller . Where xxx is the name of the session type (e.g. Query, Add, Update, Delete, Retrieve). The getViewID method returns the unique identifier of the Client Adapter  responsible for this interface. The getSessionID method returns the unique identifier of the IDLSCSession instance. The getDBSession method returns a dictionary. This dictionary was passed to the newxxxsession call and populated in this instance. The getProperties and setProperty methods query and manipulate a hashtable of properties respectively. This hashtable is used to store state information specific to a Schema Controller .","In the present Word\u2122 example, the Schema Controller  implements six interfaces: AddSC, UpdateSC, DeleteSC, RetrieveSC, QuerySC and IDLSchemaControllerI. IDLSchemaControllerI was previously defined. Below, the RetrieveSC interface will be defined. The remainder of the interfaces can be similarly defined. In the retrieve scenario, the user of the client application wishes to retrieve the assets they have previously stored. Typically a user will query the Data Store to locate the asset of interest to them. This asset is identified by a unique identifier, IDLAssetIDI. The method, newRetrieveAsset, constructs a new AMS session for the client application request. This allows multiple users concurrent access to the Schema Controller  implementing this interface, where each user has a unique session with the Schema Controller .",{"@attributes":{"id":"p-0126","num":"0136"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"{"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"IDLSCSessionI newRetrieveSession(Dictionary aDBSessions) throws"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"RemoteException;"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Object retrieveAsset(IDLSCSessionI aSessionInfo, IDLAssetIDI"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"anAssetID, String actionPath) throws RemoteException;"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Two services have been constructed in the AMS to aid a developer in defining the five interfaces, as well as implementing them. Plug-ins and DataStore objects are available via the external services portion of the AMS. Plug-ins are used to share information between the Client Application and Schema Adapter. This can be either returning data to a Client Application or to update or add data to the Data Store. The DataStore objects define standardized Data Store operations (login, logoff, etc.).","When returning data to a Client Application from the Schema Adapter, a developer should decide what type of Plug-in to use. Both the Client Application and Schema Adapter should be developed with a specific Plug-in interface or set of Plug-in interfaces in mind. A Plug-in can be implemented as any Java\u00ae class implementing a specific Java\u00ae interface.","The Master Server  manages a list of Plug-in templates, which are dynamically loaded at run time. The set of Plug-in templates is dependent on which Schema Controllers  are loaded and what Plug-ins are needed by the loaded Schema Controllers . The Master Server  provides a method, getPlug-in, which automatically creates an instance of a specified Plug-in template (Java\u00ae class). The Plug-in template is specified using a Domain and an Action Path. The Domain is discussed in detail in the Plug-in example, but basically defines the data type (e.g. String, int, long, etc.) supported by the Plug-in. The Action Path defines the context of the Plug-in, which is usually defined by the Client Application.","By specifying Plug-in templates via the Domain and Action Path, a great amount of flexibility is enabled between the Client Application and Schema Adapter. For example, suppose it is desired to have two types of Client Applications, a Console Application and a Windows\u00ae Application, communicate with the same Schema Controller. The Console Application presents data in a textual form, whereas the Windows\u00ae Application presents the data in a graphical way using Windows\u00ae. This results in the need for different Plug-ins templates, depending on which Client Application is requesting information. The Console Application passes an Action Path, TEXT, to the Schema Controller. The Schema Controller uses this Action Path and the Domain embedded into both the Schema Controller and Client Application to determine which Plug-in template to create an instance of. In this case, the getPlug-in method is called on the Master Server with the domain String and Action Path TEXT and an instance of classJava.lang.String is returned. This class is easily returned to a console application and displayed.","The Windows\u00ae Application passes an Action Path, GUI, to the Schema Controller. In this case the Master Server getPlug-in method returns an instance of java.awt.Label. This instance can be shown directly into a spread sheet grid in a Windows\u00ae application.","It is possible, and sometimes necessary, for the Client Application to pass a piece of the Action Path to the Schema Adapter and then have the Schema Controller complete the path. A simple example would be to make the first piece of the Action Path describe the context for which the Client Application plans on using the Plug-in, such as \u201cGUI\u201d. This is then added to by the Schema Controller to request an appropriate \u201cGUI\u201d control for the data. So for a piece of data that is being display that is just a string, the Domain would be String and the full Action Path would be \u201cGUI_LABEL\u201d. When a new Plug-in template is added to the Master Server, it needs to be configured and given an Action Path before it can be used.","The newly created object that is returned by the Master Server is actually a container object that is used to wrap the Plug-in instances. Often times, the Schema Controller or Client Application will need to set values within a Plug-in instance prior to passing the instance. Each Plug-in instance contains a Domain and a Value. The Domain of the instance contains all the values this instance can hold, whereas the Value field is the actual value of this instance. The interface for getting\/setting the Domain and Value fields will be defined in the Plug-in example, presented below. Note that the Domain of the Plug-in instance is different than the Domain of the Plug-in template discussed previously.","DataStore services provide the connection to the Data Store. Often this connection requires a handle or login to allow manipulation of data in that store. This being the case, the newxxxSession method takes a dictionary of such objects to facilitate using the Data Store. The Schema Controller must look up the Data Store object needed and retrieve the object from the hashtable. When creating a Schema Controller, if a Data Store login type does not exist for the Data Store planned on being used, then one must be created. This is done by subclassing the interface:",{"@attributes":{"id":"p-0135","num":"0145"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public interface IDLDBLoganTypeI"]},{"entry":[{},"{"]},{"entry":[{},"Object logon(Dictionary adParams) throws IDLLogonFailedJ;"]},{"entry":[{},"void logoff(Object aoSession) throws IDLLogoffFailedJ;"]},{"entry":[{},"Vector getParams( );"]},{"entry":[{},"String getName( );"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The getName method returns the unique name of this Data Store. This value is looked up by the Schema Controller. The getParams method returns a vector of the parameters needed to logon in the logon method. The logon method should take a dictionary of the parameters to logon and their corresponding values. This method should then return the object that will be used by Schema Controllers to communicate with the Data Store. The logoff method takes the object produced by the logon method and performs a logoff from the Data Store. By using this mechanism the Data Store connections are transparent to the Client Application. The System Administrator of the AMS and the developer of the Schema Adapter are the only places where knowledge of the Data Stores being used is needed.","vi. Implement a Parser for the Asset Type(s)","Some Asset Types require a parser to extract properties and their values from a file or stream. In this example, the MSWord file contains paragraphs, page counts, fonts, etc. So as to avoid having the user enter this information when adding an MSWord file to the Data Store, a parser may be constructed to automatically extract the property information from the file. Each parser may be different and is dependent on factors such as which platform the client\/server are on, what file type is being manipulated and many others. Most parsers will be exercised during the adding of the asset into the Data Store. This is because the parser is used to populate the Data Store.","The opposite of a parser, also known as an importer, is an exporter. An exporter is used to construct a file from the data in the Data Store. This is rarely required since the purpose of Digital Library is to store files, but there exist situations where users wish to change data within the Data Store and have it reflected within the file. If a user wished to change a paragraph within an MSWord file within the AMS Client Application and have it reflected in the MSWord file, an exporter would have to transfer the data in the Data Store to the MSWord file. This would often times appear in the retrieveAssel method.","E. The Resources Module","As shown in , the Resources module  includes one or more Plug-ins  and one or more External Services adapters . The Resources module  holds all the available producible Plug-ins for the entire system . Plug-ins  are structures used for transferring data between the AMS  and the Client Application . In one implementation of the present invention, the Plug-ins  may be Java\u00ae classes used to encapsulate property values with associated behaviors sent from the AMS  to the AMC  and shown to the user. In other words, a Plug-in may be a class defining an instance returning data from a database using object oriented classes. Each Plug-in configuration requires specified property types and Action Paths. A property type represents the type of Data Stored in a digital library  part of the Data Store  (shown in FIG. ), for example. In conjunction with the property type, an Action Path identifies the specific Plug-in for client requests. Multiple Action Paths can be defined for each Plug-in, and multiple property types can be associated with each Action Path. The query , results , and edit  Client Adapters use Plug-ins  to transfer information to the AMC  of the Client Application . At the same time, the AMC  uses Plug-ins  to display and edit the property values received from the AMS . When the user is editing the values using the edit function  (shown in ) of the user interface , Plug-ins  are called to return updated values from the AMC  to the AMS . Plug-ins  may be created for a windowing environment, and may also be non-visual, containing information to perform the required functions of transferring data between different components of system .","When the user wants to query the system , for example, the AMC  sends a request to a Client Adapter in the Client Adapter module  using a property name and an Action Path. The Client Adapter contacts a Schema Adapter within the Schema Adapter module . The Schema Adapter module  of the AMS  retrieves a property type based on the property name and uses the request, the property type, and the Action Path to identify and request a specific Plug-in in the Resources module . Finally, the Schema Adapter module  within the AMS  produces an instance of the Plug-in produced by the Resources module , initializes that particular instance, and sends the instantiated Plug-in to the AMC  via the Client Adapter module .","The External Services adapters  of the Resources module  may be used to establish a connection with the Data Store  and function as a link between the Schema Adapter module  and the Data Store . Among other features, the External Services adapters  incorporate the DataStore services, discussed above in the Schema Adapter example, to logon to and logoff from the Data Store  and facilitate communication with the Data Store . The AMS  uses External Services adapters  required by the asset types supported within the AMS .","F. Example: Creating and Adding New Plug-ins","The configurability and extensibility of the present invention is further demonstrated through the ability to create and add new ones of the Plug-ins in accordance with the following procedures.","Before learning how to construct a new Plug-in, it is helpful to understand how the components shown in  work together. The Master Server  manages a list of Plug-in templates via the Plug-in Factory  (part of the Plug-ins module  of FIG. ). These Plug-in templates are dynamically loaded when the Master Server  is started. The set of Plug-in templates may be configured by a System Administrator. This set should encompass all the Plug-in templates required by the loaded Schema Controllers.","The Schema Controller  calls the Master Server's  method, getPlug-in, which automatically creates a remote Plug-in Container . This remote Plug-in Container is of a specified Plug-in template (Java\u00ae class). The Plug-in template is specified using a Domain and an Action Path. The Domain defines the data type (e.g. String, int, long, etc.) the Plug-in supports. As discussed above, the Action Path defines the context of the Plug-in. The first portion of the Action Path is usually defined by the Client Application and the remainder of the Action Path may be filled out by the Schema Controller . As discussed above, the third argument of the retrieveAsset method is the Action Path. This provides the Client Application with the opportunity to pass the beginning of the Action Path to the Schema Controller .",{"@attributes":{"id":"p-0148","num":"0158"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Public interface IDLRetrieveSCI"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"IDLSCSessionI newRetrieveSession(Dictionary aDBSessions) throws"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"RemoteException;"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Object retrieveAsset(IDLSCSessionI aSessionInfo, IDLAssetIDI"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"anAssetID, String actionPath) throws RemoteException;"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"After the remote Plug-in Container  is constructed by the Master Server , it is returned to the Schema Controller . The Schema Controller  sets the domain and value of the remote Plug-in Container  and returns it to the Client Adapter .","In the AMS of this example, the Java\u00ae communications class library, Remote Method Invocation (RMI), is being used to pass remote objects between distributed virtual machines. Due to performance reasons specific to RMI, a local representation is constructed in the Client Application of the remote Plug-in Container. These local representations are known as Local Plug-ins (not shown).","Now, the steps for creating and adding new Plug-ins will be discussed:\n\n","i. Choose a Plug-in Template","As discussed above, when returning data to a Client Application from the Schema Adapter, a developer should decide what type of Plug-in to use. Both the Client Application and Schema Adapter should be developed with a specific Plug-in interface or set of Plug-in interfaces in mind. A Plug-in can be implemented as any Java\u00ae class implementing a Java\u00ae interface, for example.","Continuing with the Word\u2122 example, assume that the Client Application is a Windows NT\u00ae application that displays the results of a user's queries in a grid. This grid, which is implemented as a Java\u00ae AWT grid control, uses Java\u00ae class, NdLabel, to display cells. Therefore, a subclass of the NdLabel is chosen as the Plug-in template. A subclass of NdLabel is chosen because NdLabel (implement interfaces, etc.) needs to be changed, as will be seen below.","Also, the domain and value of the Plug-in template should be defined. In the present example, numerous properties (e.g. number of paragraphs, etc.) are returned using the Ndlabel class. In the case of the number of paragraphs, the domain is a set of numbers, whereas the paragraph itself is just a set of text. Thus, each property has a different domain, but they all can be represented as strings. Therefore, the NdLabel template domain can be defined to a blank String and the Value is a blank String.","ii. Choose the Domain of Plug-in instance","The domain of the Plug-in instance is more specific than the template. This is because at compile time it is known what property a Plug-in instance is being applied to. In the Word\u2122 example, one of the properties is the number of paragraphs for a document. Assuming the minimum for the number of paragraphs is 0 and the maximum is 1000, the domain for NdLabel instance is string representations of integers between 0 and 1000. The Schema Controller uses the Data Stored in the Data Store to fill out the value of the NdLabel instance prior to returning it to the Client Adapter.","iii. Implement the Get\/Set Methods for the Plug-in","Writing a Plug-in in the present example involves implementing one Java\u00ae class. This class will define the behavior for the Plug-in, but to work in the AMS it must also implement the Java\u00ae interface:",{"@attributes":{"id":"p-0160","num":"0174"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public interface IDLValuePlug-inI"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"IDLContainerI getAllSupportedDomains( ) throws RemoteException;"]},{"entry":[{},"IDLContainerI getDomain( ) throws RemoteException;"]},{"entry":[{},"void setDomain(IDLContainerI aDomainContainer) throws"]},{"entry":[{},"RemoteException,"]},{"entry":[{},"IDLContainerI getPlug-in Value( ) throws RemoteException;"]},{"entry":[{},"void setPlug-in Value(IDLContainerI aValueContainer) throws"]},{"entry":[{},"RemoteException;"]},{"entry":[{},"public void update( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The method getAllSupportedDomains returns an object of type IDLContainerI. This object is quite similar to the class Vector, defined in Java\u00ae, in that it contains an ordered set of objects. This method returns all of the different domains a specified Plug-in template can support. For example, a Textfield can support Strings, Integers, Floats, etc. The interface Plug-in.IDL ValuePlug-inConstanisI provides a common set of these types that are already defined as constants. Each template domain is added to the IDLContainerI as a string.","The method getDomain also returns an IDLContainerI. This method is used to return the domain of the Plug-in instance. In some cases, the Plug-in will be given a set of choices as its domain. An example of this would be a Listbox.","The method getDomain is used to define the domain of the Plug-in instance. Often times this method is called by the Schema Controller or Client Adapter. An example is a Textfield that is configured with an Integer domain. This allows the Textfield Plug-in to ignore or generate errors for any input that is not numeric. The Domain can also be a set of things as in the case of a Listbox.","Calling getPlug-in Value results in the Plug-in instance returning the value set by setPlug-inValue. In some cases, this could be a set of things such as for a multi-select Listbox. The method setPlug-inValue sets the Plug-in instance value. This value is retrieved via the getPlug-in Value method. The update method is used to inform the Plug-in that its contents are to be sent back to the server from the client for processing.","iv. Implement the RMI Local\/Remote Methods for the Plug-ins","As discussed previously, the AMS makes use of Java's\u00ae RMI for purposes of distributing the Client Application and Server. Due to the nature of RMI, local copies of the remote Plug-in Container are constructed on the Client Application. An interface, IDLValuePlug-inStubI, defines the methods necessary for the Client Application to construct a local copy of the remote Plug-in Container. Each Plug-in template should implement this interface.",{"@attributes":{"id":"p-0167","num":"0181"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public interface IDLValuePlug-inStubI extends java.io.Serializable"]},{"entry":[{},"{"]},{"entry":[{},"Object createLocalPI(boolean abValueSet);"]},{"entry":[{},"void update( );"]},{"entry":[{},"Object getRemotePIContainer( );"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Referring to , the getRemotePIContainer method answers the sender with an instance of the remote Plug-in Container . This method is called by the Schema Controller  after the getPlug-in method is sent to the Master Server . The Schema Controller  calls the setPlug-in Value and setDomain methods on the remote Plug-in Container . The remote Plug-in Container  returns the remote Plug-in Container  to the Client Adapter . The Client Adapter  calls the createLocalPI method to construct the local Plug-in (not shown) on the Client Application. The Client Adapter  returns the object which is produced by that method to the Client Application, and also maintains the connection between the local Plug-in (not shown) and the remote Plug-in Container .","III. Example: Operation in the Overall Architecture","While portions of the operation in the overall architecture have been provided above, the following discussion provides a more complete system view of an exemplary operation.","Referring to , the Client Application contains the following services, previously discussed, which facilitate communication with the AMS: Master Client Adapter , Logon Client Adapter  and Master Server Adapter  facilitating. Each of these services is embedded in the Client Application. When creating a new Client Adapter , for example, interfaces for Client Adapter  and Schema Controller  must be defined.","The Logon Client Adapter  is provided by default. This Adapter  is used to establish the connection between the Client Application and the AMS. In a typical usage scenario, the Client Application sends a newSession method to the Master Client Adapter . The argument of the newSession method is a unique identifier used in locating a particular Client Adapter. In this case, the Client Application is requesting the Logon Client Adapter , which is returned to the Client Application. When the Client Application is started, the Logon Client Adapter  may be the only Client Adapter loaded.","The Client Application then sends a logon message to the Logon Client Adapter which in turn constructs the Master Server Adapter  and an instance of IDLActiveUserInfo. The IDLActiveUserInfo interface does not appear in , but it is a unique definition representing the Client Application's connection to the AMS.","Next, the Client Application sends a getSessionTypes method to the Master Client Adapter . The Master Client Adapter  passes the getSessionTypes method on to the Master Server . The Master Server  returns a list of Client Adapters  to the Master Client Adapter  and then on to the Client Application. The Client Application sends a newSession message to the Master Server Adapter  providing the unique ID of the desired Client Adapter . The Master Client Adapter  registers the new Client Adapter .","The user, through the Client Application, can now call any of the new functions specified in the new Client Adapter . If a new function is called in the new Client Adapter , a query for example, the new Client Adapter  passes this request to the appropriate Schema Controller .","Once the Schema Controller  receives a request, it uses resources in the AMS to fulfill that request by connecting to the Data Store , where the request is processed in a relational database in the Data Store , for example. The relational database then processes the request and sends results back to the Schema Controller . The Schema Controller  then, already having requested an appropriate Plug-in  from the Plug-in Factory  for the data type being processed, populates the Plug-in  which is then forwarded back to the Client Adapter  and the Client Application. When a Client Application wishes to engage a different Client Adapter  or a new instance of an existing Client Adapter , it must send the newSession message and go through the same process as defined above.","The foregoing description of the preferred embodiment of the invention has been presented for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. It is intended that the scope of the invention be limited not by this detailed description, but rather by the claims appended hereto."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The above objects and advantages of the present invention will become more apparent by describing in detail preferred embodiments thereof with reference to the attached drawings in which like reference numbers represent corresponding parts throughout:",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 7","b":"1"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 8","FIG. 1"]}]},"DETDESC":[{},{}]}
