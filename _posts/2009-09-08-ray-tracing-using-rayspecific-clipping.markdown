---
title: Ray tracing using ray-specific clipping
abstract: Systems, methods, and computer readable media embodying such methods provide for allowing specification of per-ray clipping information that defines a sub-portion of a 3-D scene in which the ray should be traced. The clipping information can be specified as a clip distance from a ray origin, as an end value of a parametric ray definition, or alternatively the clipping information can be built into a definition of the ray to be traced. The clipping information can be used to check whether portions of an acceleration structure need to be traversed, as well as whether primitives should be tested for intersection. Other aspects include specifying a default object that can be returned as intersected when no primitive was intersected within the sub-portion defined for testing. Further aspects include allowing provision of flags interpretable by an intersection testing resource that control what the intersection testing resource does, and/or what information it reports after conclusion of testing of a ray.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08421801&OS=08421801&RS=08421801
owner: Caustic Graphics, Inc.
number: 08421801
owner_city: San Francisco
owner_country: US
publication_date: 20090908
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application claims priority from U.S. provisional application No. 61\/095,570, entitled \u201cRay Tracing Using Ray-Specific Clipping\u201d, and filed on Sep. 9, 2008, and from U.S. provisional application Nos. 61\/099,152, 61\/101,854, and 61\/172,453, filed respectively on Sep. 22, 2008, Oct. 1, 2008, and Apr. 24, 2009, and all entitled \u201cShader API for Non-Recursive Ray Tracing\u201d; all above-referenced applications are incorporated by reference in their entirety, for all purposes, herein.","1. Field","The following generally relates to computer graphics, and more particularly to accelerating rendering of 2-D representations of 3-D scenes using ray tracing.","2. Description of Related Art","Rendering photo-realistic 2-D images from 3-D scene descriptions with ray tracing is well-known in the computer graphics arts.","Ray tracing usually involves obtaining a scene description composed of geometric primitives, such as triangles, that describe surfaces of structures in the scene. The primitives can be associated with textures and other information that instructs a computer how light hitting that primitive should be affected by qualities of the primitive. In other words, a model of a physical environment is produced; the model may be designed to produce realistic results for conditions familiar to humans, or the model may be designed to achieve other results as desired. Ray tracing can produce photo-realistic images, including realistic shadow and lighting effects, because ray tracing can model the physical behavior of light interacting with elements of a scene. However, ray tracing is also known to be computationally intensive, and at present, even a state of the art graphics workstation requires a substantial amount of time to render a complicated scene using ray tracing, and real-time high quality and resolution rendering with ray tracing is still difficult to achieve.","Most practical scenes include sources of light (more generally, can be a model of any sort of energy source, for example, x-rays, infrared light, and the like). The light sources illuminate objects in the scene. Usually, a scene description reaches to a given extent, in that scenes are defined usually within some bounded area that can be identified by a scene boundary, which can also be known as a scene clip distance. Then, rays are emitted from a camera, or from other origins to test any number of conditions (e.g., is a particular point of an object in shadow of another object).","Such rays are traced in the scene until an intersection with a scene object, such as a primitive or a light source, is identified, or the ray has been traced to the scene boundary. Then, if there was an intersection with another primitive, further rays can be emitted for gather information about conditions at that intersection point. If a light source was intersected, then light energy from that light source can be determined to hit the origin of that ray. Various attributes of the light can be considered, such as its color and intensity.","All of the above describes a computer-based model of directed energy propagation through a scene having energy sources, and various objects that can have different qualities, such as different textures, colors, diffraction, and reflection properties, and the like. Thus, whether results obtained from such a model are as desired depends on precision and accuracy of the computation resources used to implement the model, including the hardware and how the hardware is being used by software. Methods and systems that allow either better results from a given amount of precision and accuracy or that allow a desired result with less computation are desirable, and some aspects of the following address such goals, and other improvements in ray-tracing systems.","Aspects include a method for ray tracing, such as ray tracing of 2-D representations of 3-D scenes. The method comprises instantiating a plurality of rays to be tested for intersection with geometric objects comprising scene primitives and elements of geometry acceleration data. The method comprises associating respective clipping information with each of the plurality of rays indicative of a maximum distance from a respective origin that each associated ray is to be traced. The method also comprises testing each ray of the plurality for intersection only with geometric objects within its maximum distance as specified by the clipping information. The method also comprises outputting a respective indication of any closest identified intersection between each ray and any tested scene primitive.","Aspects also include a system for rendering 2-D representations of 3-D scenes using ray tracing, which comprises a first processing resource configured with computer readable instructions for a shader routine. The shader routine is associated with a geometric shape identified during intersection testing of a 3-D scene composed of a plurality of geometric shapes, and the instructions for the shader routine, when executed, operable to instantiate a data structure having ray definition data. The ray definition data comprises data defining a sub-portion of the 3-D scene in which intersection testing for the ray is to be confined. The system also comprises an intersection testing resource operable to receive the data structure, to test the ray for intersection with geometric shapes composing the 3-D scene that are within the sub-portion of the 3-D scene, and to provide an indication of a nearest intersection, if any, between the ray and a shape composing the scene.","Further aspects include a computing resource for performing intersection testing operations useful in rendering 2-D images from 3-D scenes using ray tracing. The computing resource also comprises one or more interfaces operable for obtaining data representative of a ray to be intersection tested in a 3-D scene, and ray-specific clipping information. The ray-specific clipping information, with an origin of the ray, defines an extent over which intersection testing for that ray is to be confined. The interfaces also are for obtaining data defining a shape to be tested for intersection with the ray.","The computing resource also comprises intersection test limiting circuitry configured for determining whether the shape is within the extent of the ray to be tested, based on the obtained clipping information; and intersection testing circuitry configured for testing a shape for intersection with the ray responsive to the limiting circuitry determining that the shape is within the extent, and for outputting indications of a detected intersection between the shape and the ray. The circuitry can comprise general purpose hardware programmed with software, customized, or partially customized hardware, as well as combinations thereof. The circuitry also can be distributed among plural physical locations, as desired for any given implementation.","Further aspects include a method for rendering 2-D representations of 3-D scenes using ray tracing, the method comprises instantiating a plurality of rays to be intersected tested in a 3-D scene composed of primitives. The method also comprises associating respective clipping data with each of the plurality of rays. The method also comprises, for each ray, traversing an organization of elements of geometry acceleration data that respectively bound increasingly smaller group of the primitives to arrive at a final group of primitives to test for each ray, the traversing including determining whether a given element is within a maximum test distance obtainable from the clipping data. The method further comprises testing each ray for intersection with its final group of primitives and reporting intersection testing results that include a closest detected intersection for each ray.","Further aspects comprise a method useful in rendering 2-D representations of 3-D scenes using ray tracing. The method comprises receiving an indication that a first ray intersected a first primitive of a plurality of primitives composing a 3-D scene, and causing instantiation of a second ray having an origin proximate the intersection of the first ray and the first primitive, and associating with the second ray a clipping distance and a default intersection object. The method further comprises determining that the second ray does not intersect any primitive composing the scene between the origin of the second ray and a point along a direction of the second ray within the clipping distance, and responsive to the determining, returning an indication that the second ray intersected the default intersection object.","Still further aspects include a method for use in ray-tracing based rendering of 2-D representations based on geometric shapes located in 3-D space and comprising primitives, and elements of geometry acceleration data, which respectively bound selections of the primitives. The method comprises causing instantiation of a ray defined in part by origin data and a ray-specific clip distance independent of a scene clip distance; and testing the ray for intersection only with geometric shapes closer to the origin of the ray than the ray-specific clip distance.","Still further aspects comprise a computer readable media storing computer readable instructions for implementing a method useful in shading detected intersections between rays and geometric shapes in ray-tracing based 3-D scene rendering. The method comprises defining with first ray definition data, in a first compute resource configured for intersection shading, a first ray to be tested for intersection in a 3-D scene composed of geometric shapes. The ray definition data comprises an origin of the first ray, one or more flags, and an identifier that uniquely identifies the first ray from other rays that may be concurrently tested for intersection.","The method comprises storing the first ray definition data in a first memory and providing the identifier for the first ray to a second compute resource configured for testing rays for intersection with geometric shapes. The method also comprises retrieving, to the second compute resource, the first ray definition data from the first memory, and testing the first ray with at least one geometric shape. The method also comprises, responsive to detecting an intersection of the first ray with any of the geometric shapes, using the one or more flags to determine content of an output from the second compute resource.","Still further aspects also include a computer readable media storing computer readable instructions for implementing a method useful in shading detected intersections between rays and geometric shapes in ray-tracing based 3-D scene rendering. The method comprises accepting an intersection test request from a shader routine that identifies a ray to be intersection tested in a 3-D scene. The method also comprises obtaining from the intersection test request information indicative of a sub-portion of the scene in which intersection testing is to be confined, identifying selections of primitives composing the scene, and determining whether such selections of primitives are within the sub-portion of the scene prior to arranging for intersection testing of them with the identified ray.","Still further aspects include a computer readable media storing computer readable instructions for a shader implementing a method. The method comprises defining a ray to be intersection tested in a 3-D scene, selecting a ray-specific clipping distance for the ray. The clipping distance is distinct from a global clipping distance defined for the 3-D scene. The ray-specific clipping distance is selected to confine intersection testing for the ray between an origin of the ray to its clipping distance. The method also comprises arranging intersection testing for the ray using its ray-specific clipping distance.","The following description is presented to enable a person of ordinary skill in the art to make and use various aspects of the inventions. Descriptions of specific techniques, implementations and applications are provided only as examples. Various modifications to the examples described herein may be apparent to those skilled in the art, and the general principles defined herein may be applied to other examples and applications without departing from the scope of the invention.","For clarity in description, data for a certain type of object, e.g., a primitive (e.g., coordinates for three vertices of a triangle) is described simply as the object itself, rather than referring to the data for the object. For example, when referring to \u201cinstantiating a ray\u201d, it is to be understood that data representative of that ray is being produced, rather than a physical realization of that ray.","The following figures present examples of systems and portions thereof for rendering 2-D representations of 3-D scenes using ray tracing. Two principal components to such rendering are tracing rays to identify intersections and shading identified intersections. Generally, any of the functions or duties of any of the functional units may be implemented in multiple hardware units, or pieces of software, software subroutines, and may even be run on different computers. In some cases, such implementation is described more particularly, as it can bear on system function.","As introduced in the background, a 3-D scene needs to be converted into a 2-D representation for display on a 2-D screen. Such conversion can involve selecting a camera position, from which the scene is viewed. The camera position frequently represents a location of a viewer of the scene (e.g., a gamer, a person watching an animated film, origins for holographic image slices, and so on.) The 2-D representation is usually at a plane location between the camera and the scene, such that the 2-D representation comprises an array of pixels at a desired resolution. A color vector for each pixel is determined through rendering. During ray tracing, rays can be initially cast from the camera position to intersect the plane of the 2-D representation at a desired point, and then continue into the 3-D scene.","In some implementations here, a location at which a ray intersects the 2-D representation can be retained in a data structure associated with that ray. When an intersection for a camera ray is detected, further intersection testing must be done responsively to that intersection detection. For example, it must be determined what light hits that intersection point, which can include testing whether light sources are shadowed by another object. What needs to be done responsive to an intersection detection is at least partially determined by qualities of the surface of the shape intersected. For example, if a transparent material (e.g., glass) were intersected, then different rays may need to be emitted than if an opaque material were intersected. What happens when an intersection is detected is largely determined by computer code (which is conveniently referred to as a shader for that object), and other data associated with the object intersection.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 1","FIG. 1"]},"The depicted system comprises a geometry unit (not depicted), an intersection testing unit , an intersection processing unit , and a sample processing unit (not depicted), which can be implemented in hardware and\/or software as appropriate. Each of the geometry unit, intersection testing unit , intersection processing unit , and the sample processing unit can also be embodied on a video card or other external or internal computer system peripheral. A link  provides communication between ray data  and intersection testing unit . Intersection testing unit  receives geometric shape data from primitive & GAD storage  by a link. In some cases, primitive & GAD storage  can be implemented in a main memory storing other data, such as sample data, ray shading data  (e.g., shader routines), and texture data , which can be separate from ray data storage .","In , embodiments implementing any of the described units at least partially in software, computer-executable instructions representing unit functionality can be stored on recordable-type computer-readable, such as, for example, magnetic or optical disks, flash memory, USB devices, etc. Other features of , such as the links can be implemented in a variety of ways depending on the nature of the units identified. For example, if intersection testing unit  comprises a plurality of threads executing on one or more CPUs, then the link between ray data  and intersection testing unit  can comprise physical memory access resources of such CPU(s) and appropriate memory controller hardware\/firmware\/software to provide access to ray data storage .","Intersection testing unit  includes one or more individual test resources (a.k.a. test cells), which can test a geometric shape against a ray. Each test cell can produces testing results, which can include indications whether a given ray has intersected a given primitive. Generally, system components are designed to support unknown time-to-completion of a given, specific, ray test. In sum, the Intersection Testing Unit  has read access to the geometry memory, and has a queue of references to rays as inputs. As an output of intersection testing, each ray can be associated with a piece of geometry that it intersected first.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 2","FIG. 1"],"b":["102","109","102","109","102","109","203","109","102","202","102","203"]},{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 3A","FIG. 3A"]},"Because a scene can be composed of many (e.g., hundreds of thousands or millions, or more) of primitives, elements of GAD can be used to approximate boundaries for one or more primitives (or abstracting) in a scene to accelerate intersection testing by allowing groups of primitives to be identified for further testing (or excluded from further testing).","GAD elements generally include a geometric shape that encloses, in 3-D space, a respective collection of primitives, such that failure to intersect a surface of the geometric shape with a ray indicates that the ray also does not intersect any primitive bounded by the shape. GAD elements can comprise spheres, axis-aligned bounding boxes, kd-trees, octrees, and other sorts of bounding volume hierarchies. Since GAD elements primarily are useful in abstracting primitives for more quickly identifying intersections between rays and primitives, GAD elements preferably are shapes that can be easily tested for intersection with a ray.","In the example of , for generality, generally spherical (circular in 2-D) GAD element  is shown to bound primitives , , and , while generally spherical element  bounds a group of other GAD elements described below, which in turn directly bound portions of primitives. Continuing, element  bounds a primitive  from a triangle strip, as well as GAD elements  and . GAD element  in turn bounds triangle strip  and GAD element , which in turn bounds triangle strip . GAD element  bounds triangle strip . In a sense, GAD element  bounds all of the primitives also bounded by intervening elements , , and so on. However, bounding generally herein refers to a direct bounding, without further intervening elements of GAD.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 3B","FIG. 3B","FIG. 3A"],"b":"318"},"As alluded to above, GAD elements can be interrelated to each other.  illustrates such an interrelationship with the primitives and GAD elements of  with a graph  comprising nodes representing elements of GAD illustrated in , and connected by edges to other GAD elements of , and which ultimately bound primitives of . In particular, a root node  that can impliedly bound an extent of the scene (i.e., it can be viewed as bounding all the primitives in the scene); as evident from , root  need not be explicitly defined in the scene. Root  is connected by edges to GAD elements  and  (nodes). In turn, node  bounds primitives , , and . Returning to node , node  is connected to node , which is in turn connected to nodes  and . Primitive  is bounded directly by node  (i.e., GAD element ), while strip  is bounded by node  and strip  is bounded by node . Node  bounds node  which bounds strip .","As can be graph  shows relationships among the GAD elements used to bound primitives of , such that by starting at root , testing rays for intersection with GAD elements at different points in the graph allows narrowing of primitives that ultimately need to be tested for intersection with the ray or rays.","Thus, where a pair of elements is connected by an edge, the edge may indicate that one of the nodes has a different relative granularity than the other node, which can mean that one of the nodes connected by that edge bounds more or fewer primitives than the other node. In some cases, the graph can be hierarchical, such that there is a direction to the graph, and the graph can be traversed in order from parent nodes to child nodes, narrowing remaining bounded primitives along the way.","In some cases, the graph can have homogeneous GAD elements, such that if a given GAD element bounds other GAD elements (even though this graph is heterogeneous), the given GAD element also does not directly bound primitives (i.e., any primitives bounded by the given GAD element also would be bounded by one of the GAD elements bounded by the given primitive.) A graph of GAD elements can be constructed with a goal of maintaining some uniformity in a number of elements and\/or primitives bounded by another GAD element. A given scene can be subdivided until such a goal can be achieved.","Rays usually are defined using an origin in 3-D space for the ray, and a direction vector. However, other mechanisms can be used to represent equivalent data for a ray, for example, various mathematical transforms can be used to map such origin and direction information into another set of variables.","In any event, even though a ray conceptually originates from a given origin, which may be anywhere in the scene for some kinds of rays, it is often preferable not to begin intersection testing starting from a ray's origin. For one thing, it may not be easily apparent, when using some acceleration structures, in what GAD element the origin is to be found.","Therefore, it is often the case that ray testing begins at a beginning (root) of an acceleration structure and proceeds into the structure. This means that a ray may be tested against primitives out of an order that the ray conceptually would traverse the scene from its origin. So, in the following description, it is provided that there is a mechanism to determine, based on a ray having been determined to intersect a given GAD element, what other GAD elements should be tested next in response. In an example of a hierarchical graph, then the elements tested next generally would be child nodes of a tested node. However, other suitable ways can be provided, for example, a graph can be directed, but not strictly hierarchical.","Now turning to , there is shown an example of a data structure  for defining a ray that includes a ray identifier () that can be used to identify\/distinguish one ray from other rays currently being tested in the system. Data structure  also includes an origin , a direction , a clip distance , a default object  and one or more flags (). More details concerning these components of data structure  are provided below.",{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIG. 6","FIGS. 7-9","FIGS. 7-9"],"b":["600","500","600"]},"Method  includes a first step of instantiating  rays for intersection testing. Steps of method  that may be executed by shader code thus include instantiating rays , and associating  a respective clip distance with each ray (the shader can set a clip distance (), or otherwise determines an extent or sub-portion of the scene in which the ray is to be tested).","The clip distance here is a clip distance for a given ray that is settable independently of a tracing limitation that can apply generally, such as for example, an extent of the entire scene. The clip distance can be specified in a variety of ways. One way is providing an end point in 3-D space (e.g., another 3 tuple specifying an end point). If a ray were specified parametrically, then a maximum parameter size may be specified. Other ways for such clip distance also can be provided, so long as it can be determined, for each ray having an associated clip distance, where intersection testing involving that ray should cease, or otherwise be confined.","Thus, ray data structure  defines a sub-portion of a scene in which intersection testing for the ray specified by that data structure is to be confined. When a ray is 2-D, such a sub-portion can be a line segment. For example, a line segment can be the sub-portion of the scene, defined by a ray origin and a second 3-D point in the scene. So, an intersection testing resource can interpret the data in the data structure to cause avoidance of intersection testing of geometric objects, such as acceleration elements and\/or primitives, that are not within that scene sub-portion. For convenience, the term \u201cclip distance\u201d or \u201cclipping distance\u201d is used generally here, but it is to be understood that this terminology also refers to a more general concept of defining an extent or a subportion of a scene, and using that defined extent or subportion to discriminate as to whether a ray associated is to be tested only within or only without that extent or subportion.","In some cases, a data structure can contain information defining a plurality of rays. For example, in some situations, a shader may be programmed to test a number of points in a primitive for shadow by a light source. So, that shader may emit a number of rays having differing origins, but similar destinations. For example, a shader may parametrically define a number of rays, for example, to statistically sample a number of points (e.g., in Monte Carlo processes), and so in these situations, the data structure may contain parameters that can be used in defining a number of rays with differing origins but similar destinations. In these situations, the same default object could be provided for all the rays. In still other situations, the data structure can define a plurality of rays having a similar origin but different destinations. In these types of situations, a different default object could be provided for each different destination. These are merely examples of how different combinations of data to limit an extent of intersection testing for a ray in a 3-D scene can be implemented, as well as further extensions of providing one or more default objects that can be reported as intersected under different conditions.","It should be apparent from the usage of a separate clipping distance, or another way to limit an extent of testing for a given ray, that rays still can be defined that do not have a clipping distance and would be tested fully in the scene. So, in the context of systems and methods according to these examples and other aspects, there may be rays instantiated in the system that have respective clipping distances, and other rays that do not have any respective distance (other than a generalized scene clip distance, perhaps). Therefore, intersection testing implementations may provide functionality to determine which rays have a respective clip distance and which do not.","It also should be apparent that a distinct data structure embodying the portions of data structure  need not be provided in some implementations. Rather, any of the portions of data structure  can be provided by any suitable mechanism. For example, implementations may provide a utility (e.g., a procedure call, a function call, or the like) that allows a shader to request ray tracing of a specified ray only within a clip distance (more generally, a scene sub-portion). The utility can also be provided to accept other parameters from a shader, such as default objects and flags that are shown in data structure . Of course, such a utility could receive a reference, such as a memory location reference for a location of data structure  in a call from a shader instantiating such a utility. The utility also can be programmed to infer some of the data shown in data structure  from other data. For example, a shader can provide a default object identifier, and programming implementing the utility can infer a clip distance from the default object. The clip distance would be closer, and in some circumstances, slightly closer, to an origin of the ray to be tested than the default object.","Although a ray can have definition data separate from a clip distance, in some cases, a ray could be defined with a clip distance, by for example specifying two different points in space that define an origin and a maximum extent of testing along a line segment connecting the two points. Optionally (as indicated by dashed lines), the shader can specify a default shape () and set one or more flags (). As described with respect to previous figures, the default shape can be returned by an intersection tester as having been intersected, if no primitive within the clip distance was intersected, and upon further interpretation of any flags set. The shader can determine to set a flag that will cause an intersection testing resource to report the default shape intersection only under certain circumstances, or to report anything other than the default shape intersection under other circumstances. Then, the shader can submit (identified as communication ) the secondary ray (or any number of instantiated rays) for testing. In some examples, a ray can be associated with a clipping interval, where a ray be confined for testing either within or without that interval, which is specified as a subset of a normal extent of the ray.",{"@attributes":{"id":"p-0064","num":"0063"},"figref":["FIG. 7","FIG. 5"],"b":["700","625","600","625","705","710","715"]},"Method  continues with determining whether the ray is associated with a respective clip distance (), and if so, then it is determined whether the shape to be tested is within such clip distance (). If there is not a clip distance, or if the shape is within the clip distance, then the shape is tested (). If the shape is without the clip distance, then it is determined whether there is a default shape for the ray (), and if so, then the default shape can be returned as having been intersected by the ray (). If there is no default shape, then the method  returns , without reporting an intersection, since the shape was outside the clip distance, and no default shape was defined. Other variations on these steps are possible, in that other features, such as flags can be provided, and so behavior can vary based on the presence of such other data. Also, in implementations where rays always have clip distances and\/or default objects defined, then such determining steps can be excluded (e.g., such fields can be defined in such a way that they are interpreted as a non-limiting clip distance, or as a null shape, for example).","If the shape was tested (), then it is determined whether there was an intersection detected with a primitive (). In other words, method  is general to whether a given tested shape is a primitive or an acceleration element, but shaders generally do not need indications of intersections with acceleration elements, as these elements are only for accelerating an identification of an intersected primitive, so some way of distinguishing an intersection between these two shape types is provided.","Also, since most ray tracing implementations terminate a ray after a closest primitive intersection, only the closest detected intersection needs to be tracked in those implementations. So,  provides for determining whether a detected intersection is closer than any previously detected intersection. If so, then an indication of such intersection is stored (); such indication can include an identifier for the primitive intersected and\/or can be stored with the data structure defining the ray in the localized memory, transmitted to a shader, via intermediate processes, or the like. Then, if no intersection was detected (), if a detected intersection was not closest, or after , method  returns .","Method  may be appropriate for an implementation where computing resources can be reconfigured for intersection testing of any of a variety of shapes, including shapes used for acceleration structure and for primitives. For example, spheres or bounding boxes may be used for acceleration structure and triangles for primitives. However, it usually is the case that some elements of an acceleration structure are traversed for a given ray until some selection of primitives are identified for test (e.g., in the case of a kd-tree, 3 axis subdivisions of 3-D space can continue until a volume of space contains a small enough volume or small enough number of primitives to test them.","Therefore, another example method  that illustrates a separate traversal of an acceleration structure is shown. Method  can be entered, for example, from step , and can begin with receiving a ray identifier  (see .) Method  also can include traversing  an acceleration structure to identify primitives to test, and then testing  the primitives for intersection (method , below, shows an example of traversal  in more detail.) Then, it is determined () whether a primitive was intersected, and if not, then it is determined whether more testing () is needed. If there was a primitive intersection, then the intersection is recorded () or at least checked to see if it is the closest yet detected intersection, and then checking of more testing needed () is performed.","More testing may be needed where a ray has not yet been traversed through an entirety of the acceleration structure. For example, in a kd-tree, each ultimate subdivision that bounds a selection of primitives will have other sibling nodes that need to be checked, and potentially there may be other parts of the kd-tree waiting to be traversed as well. So, before an ultimate intersection determination is reported (i.e., before intersection testing of the entire scene is complete), it needs to be determined whether there is to be an intersection test, or there is an intersection test for each primitive of the scene.","If testing is finished, then it can be determined whether there was a recorded primitive intersection (), and if there was no primitive intersection, then there can be a determination as to whether to report a default shape intersection (). This provision can include accounting for whether a default shape is specified, and also whether there is a flag (see ) indicating whether an intersection with the default shape should be reported or not. If the determination indicates that the default shape should be returned as intersected, then such an indication can be returned (), and if not, then intersection testing is finished () for that ray. If a primitive was intersected, then a determination as to whether to report the intersection () also can be made. For example, a flag can be provided in a data structure for the ray that indicates under what conditions to report an intersection. If an intersection is to be reported, then a closest intersection (generally, the only one tracked) is returned (). Thereafter, or if no intersection is to be reported, then testing is finished (). The flag based determinations of method  also can be provided in the method .",{"@attributes":{"id":"p-0072","num":"0071"},"figref":["FIG. 9","FIG. 4","FIG. 8","FIG. 8","FIGS. 3A and 4"],"b":["900","900","805","910","400","405","340","343","910","340","343","405","915","920","930","925","900","815","900","935","900","940","910","315","318","344","368"]},"Now that an overview of methods shown in  have been described, an example relating more particularly to  is described. A camera ray  enters scene . In , this is represented by having ray  at root . Then, ray  can be tested for intersection with acceleration elements  and  (with the clip distance implementations of methods from ), and in this example, the clip distance allows such testing, and there is no intersection with , but there is with . So, then ray  is next tested for intersection with element , which it is found to intersect. Then, the triangle strip having triangle  is determined to be bounded by element , is tested, and found to be intersected by ray . The intersection is reported and a shader associated with primitive  is called. It determines to test ray  in the scene, and sets clip distance . Ray  is again traversed through the scene, and ultimately is tested for intersection with primitives of strip  and found to intersect. So, the clip distance was not reached for ray . Note that here, element  or element  and strip  might be tested, depending on an implementation and an order of testing.","If there were no intersection with primitive  and instead ray  intersected strip  at , and a shader can instantiate ray  with clip distance . Traversal for ray  can occur again in an order of root , element , element , element  and elements  and . However, no intersection is found in this case, and clip distance  is reached. Since clip distance  is reached, intersected with the light need not be explicitly checked. Thus if ray  were a shadow ray, it would be assumed that the origin of ray  were not in shadow of the light. In some aspects, the light or a primitive thereof can be returned as a default object intersected.","Thus, setting a ray specific clip distance, or another way to specify a sub-portion of a scene to test a ray in allows a narrowing of scene space to be tested for having such clipping specified. An example situation where such a feature may be useful is in the context of testing whether a given point is in shadow of a point light source. This application may be particularly useful because a ray may be specified for testing such shadowing, but due to machine imprecision, the ray may be determined to miss the light, even though it didn't hit any other primitive (i.e., even though the intention was to determine shadow from a light source, it is determined that the intersection point is in shadow, even though it isn't.) So, by providing a clip distance close to a light, once a ray gets close, then it can be determined that there is no primitive shadowing an intersection point. Also, more aggressive use of such clip distances can be used as desired.","As described above, modules of code, provided for shading ray intersections, can emit secondary rays to accomplish various tests, such as occlusion tests, when shading intersections. In these examples, such ray emission can include setting a custom clip distance for one or more rays, and setting a default object to be intersected, or a group of default objects, for a group of rays, and so on. An Application Programming Interface (API) can be provided for use by such shaders, which can make it easier to use such clipping functionality. For example, a ray emission function call can accept a clip distance definition, and a default object identification. By further example, a ray emission function call can accept a definition for a bundle of rays to be emitted, each with different clip distances, or default objects (and can infer clip distances from the objects). For example, the API can maintain state, such as locations of lights in a scene, and shaders emitting shadow rays can let the API determine what default objects should be assigned to rays designated as shadow rays when they are emitted. The data provided by or through the API can then be used during intersection testing to control how intersection testing is conducted. The U.S. provisional application Nos. 61\/099,152, 61\/101,854, and 61\/172,453, incorporated herein by reference, disclose various other API related aspects that can be used in conjunction with these disclosures, including systems and methods of providing such APIs that can also be used for providing an API for accessing ray-specific clipping functionality and options described herein.",{"@attributes":{"id":"p-0077","num":"0076"},"figref":["FIG. 10","FIG. 1"],"b":["1005","1008","1004","1004","1005","1011","1001","1005","1008","1001"]},"The compute resources - communicate with caches -(shown generally in the concept that there may be a private or semi-private cache for each compute resource provided in the system of ). Each such cache may store ray data -also indicated. Each cache -may be fed from secondary caches , , and , that may be less numerous than caches -, and which may be private or shared. In the example system of , L2 caches can be fed from L3 cache and\/or main memory , which can store both shape data  and ray data .","In sum, any of the functions, features, and other logic described herein can be implemented with a variety of computing resources. A computing resource can be a thread, a core, a processor, a fixed function processing element, and the like. Also, other functions which are not primarily the focus of the present invention, can be provided or implemented as a process, thread or task that can be localized to one computing resource or distributed among a plurality of computing resources (e.g., a plurality of threads distributed among a plurality of physical compute resources).","Likewise, computing resources being used for intersection test can also host other processes, such as shading processes that are used to shade intersections detected. By further example, if a core can support multiple threads, then a thread can be dedicated to shading while another thread can be dedicated to intersection processing.","Code for any method can be stored in computer readable media, such as solid-state drives, hard drives, CD-ROMs and other optical storage means, and in volatile and non-volatile memories such as SRAM and DRAM technology memories.","Computer-executable instructions comprise, for example, instructions and data which cause or otherwise configure a general purpose computer, special purpose computer, or special purpose processing device to perform a certain function or group of functions. The code can be used in programming modules of FPGAs, or used in determining layout of ASICs. The computer executable instructions may be, for example, binaries, intermediate format instructions such as assembly language, or source code."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The detailed description references the following figures:",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIGS. 3A and 3B","FIGS. 4-9"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 4","FIG. 3A"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 7","FIG. 6"]},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 8","FIG. 6"]},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
