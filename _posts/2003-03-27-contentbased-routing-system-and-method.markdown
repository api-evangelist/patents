---
title: Content-based routing system and method
abstract: Systems and methods for routing messages between applications in a network are disclosed. Messages are routed from a sending application to one or more receiving applications according to one or more routing rules. Each routing rule is used for determining the one or more receiving applications, and is associated with at least one routing object. The routing object is configured to associate the routing rule to the message based on content of the message. The routing objects are stored in a repository of design-time descriptions of the applications. The routing rules are stored in a directory of runtime descriptions of applications in the runtime landscape, and are accessed by a runtime engine for executing the routing.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07428597&OS=07428597&RS=07428597
owner: SAP AG
number: 07428597
owner_city: Walldorf
owner_country: DE
publication_date: 20030327
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application claims priority to U.S. Provisional Patent Application No. 60\/368,839, filed on Mar. 28, 2002.","The description below relates generally to computer communications, and more particularly to methods and systems for routing messages from sending applications to receiving applications.","In a collaborative software environment, in which networked software components share information, it is undesirable and inefficient to have a message-sending application always specify receivers of message data. In order to properly specify every receiver for each sending application, an administrator would need to know each receiver, configure it to receive messages, and specify it at least in a logical context in an outgoing message. For many applications, it is not important to know what receivers are present, but rather these applications simply broadcast messages to a network at large.","To require a sending application to specify all receivers, the application would have to be configured with a receiver determination logic. Further it is a waste of resources to read all data from the database to build up a message, only to find that no receiver is interested in the message.","This document discloses routing model systems and techniques. A routing model enables the administrator of a complex system landscape to define the message flow between systems from a business perspective. Without knowing the technical details of the system landscape, the administrator can specify that a sending system uses a specific outbound interface to call a specific inbound interface in a receiving system under certain conditions, i.e. the sender and receiver are logical systems like business systems or business partners, rather than technical systems.","In one aspect, a method of transmitting a message from a sending application to one or more receiving applications in a network is providing. The method includes the steps of receiving a message from the sending application, and routing the message to one or more receiving applications according to one or more routing rules for determining the one or more receiving applications. Each routing rule is associated with a routing object, and the routing object is configured to associate the routing rule to the message based on content of the message.","In another aspect, a method of determining receivers of a message from a sending application is provided in which it may be determined whether there are any receivers of a message prior to constructing, or assembling, the entire message by the sending application. The method includes storing a plurality of routing rules in a directory, where the routing rules include one or more routing objects for determining a receiver of the message. The method further includes the steps of providing an application programming interface (API) to the directory and determining, via the API and prior to construction of the message by the sending application, whether there are any receivers specified for the message.","A system for routing messages between applications in a network includes a repository storing design-time descriptions of routing criteria for the applications, a directory storing configuration-specific descriptions of routing criteria for a runtime network landscape, and a runtime engine configured to access information from the directory to route messages between the applications. The repository stores a plurality of routing objects, and each routing object is configured to determine one or more receiving applications of a message based on message content. The directory stores one or more routing rules, where each routing rule is associated with one or more routing objects. The runtime engine accesses the routing rules to route messages according thereto.","The systems and techniques described here relate to a message exchange protocol for reliably communicating data between applications in a heterogeneous system landscape. The protocol is optimally implemented in an exchange infrastructure configured to integrate and drive collaboration between various applications in the landscape using open standards and transport protocols such as HTTP.",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1","b":["100","100","110","102","104","102","105","102","104","102","104"]},"The XI  is a self-contained, modularized exchange platform for driving collaboration among the components , . The XI  includes a central integration repository and directory storing shared collaboration knowledge. The XI  supports open standards such as various standard markup languages like the extensible markup language (XML), web service description language (WSDL), and simple object access protocol (SOAP) to provide an abstraction of technical interfaces for the components , , and for message-based communications across heterogeneous component interfaces. The self-contained, modularized functions of the XI  can be provided as one or more Web services based on standard Internet technology, and therefore can be published, discovered, and accessed within a network of components ,  using open standards.",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2","b":["200","110","110","202","204","203","206","202","110","204","200","203","200","206"]},"The integration server  includes a runtime engine  that provides messaging and business process control at runtime for connecting services and managing the process flow of value chains. The integration server  also includes integration services  that typically require an application-specific implementation. Like the integration repository  and integration directory , the integration server  is configured for deployment within any existing system infrastructure. The integration server  is preferably a dedicated server that applies the shared collaboration knowledge of the integration directory  of the supported system landscape in a runtime collaboration environment. A runtime workbench  allows organizations or users to manage the reliable operation of the XI .","The XI  also includes various adapters  that provide connectivity between the integration server  and proprietary applications , Web-based services , and third party applications . The XI  can also include Web applications server  that provides Web-based applications programmed according to standard computing platforms using web-specific programming languages such as Java and ABAP, for instance. The Web applications server  also includes an instance of the runtime engine  for providing messaging and business process control between Web-based applications such as Java applications  and ABAP applications , and other components.","New interfaces for software components can be defined using an application component employing a proxy, which allows the interface for the software component to be implemented locally in the XI . Proxies make the communication technology stack transparent to applications, and present an application with a programming language-dependent interface. The proxies can be generated by a proxy generator  based on information stored on the integration repository . The proxy generator  uses the interface information described via a standard Web-based language such as WSDL and XSDL to create platform- and programming language-dependent code in the application development system. The communication logic can be implemented based on the proxy that represents the interface description of the respective development platform, such as Java, ABAP, and .NET for the web-based applications . The proxies convert platform-specific data types into XML and provide access to the component-specific local integration engine. On the outbound side, proxies are generated completely. Outbound proxies can be called via a service invocation provided by an application's developer. On the inbound side, only proxy skeletons need to be generated, as implemented by the receiving application.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 3","b":["202","203","204","214","202","232","234","236","238","230","202","240","203","230","202","202","110"]},"The business processes  can be implemented as extensible compound Web services executed using a business process engine . Each business process  is modeled centrally in the integration repository , and can defined to the detail of user interaction steps. A company or user designs each business process  according to its business needs, independently of the technical implementation. There may be several categories of business process templates: i.e. generic business processes, industry-specific processes, and company-specific processes, for example. Each process identifies the Web services that are needed and that must be interconnected. In one specific implementation, business processes  are defined using a graphical interface, and then stored in a standardized format like Business Process Modeling Language (BPML). The business process engine can then interpret these models and execute them to drive collaboration among software components.","Routing objects  are pointers that point to a specific part of a message. They are predefined criteria to determine potential receivers of messages that must be distributed between components and business partners during collaborative processing. Information about the routing objects is used for receiver determination. Mappings  define required transformations between message interfaces , message types, or data types in the integration repository . These transformations cover structural conversions and value mappings. Structural conversions are used for semantically equivalent types that are syntactically or structurally different, whereas value mapping may be used when an object is identified by different keys in multiple systems. In a specific implementation, a graphical mapping tool is provided to assist in mapping, and transforming data is based on the Extensible Stylesheet Language Transformation (XSLT) or Java code.","The integration repository  is the central point of entry for interface development, storage and retrieval, and includes interfaces  that describe all message interfaces of all software components in the system landscape. Accordingly, the interfaces  can be implemented on any software component using any technology. In one implementation, the interfaces  are based on WSDL. Message interfaces are made up of message types, which are in turn made up of data types. The data types can be described using XML Schema Definition Language (XSDL). An example of a data type is \u201caddress,\u201d which is used in the message type \u201cCreate PO\u201d and can be reused for the message type \u201cCreate Invoice.\u201d Interfaces  can be arranged according to any classification, such as inbound and outbound, or synchronous and asynchronous.","The components  represent component descriptions that include information about application components, as well as information relating to their dependencies on each other. In a specific implementation, the component descriptions are based on the standard Common Information Model (CIM) of the Distributed Management Taskforce. Since the integration repository  includes design-time information, only component-type information, independent of actual installation, is stored as components  in the system landscape directory . The component descriptions can be added using an API or interactively using a graphical user interface.","The integration directory  details information from the integration repository  that is specific to the configuration of each component as installed in the system. The configuration-specific collaboration descriptions of the integration directory  can be generated automatically from content in the integration repository  or manually by a user using a graphical user interface. In one implementation, the integration directory  is built on a Java platform and its content is represented via XML using open Internet standards. The integration repository  can be upgraded without affecting the integration directory  or any runtime collaborative processes. The user then decides which changes should be transferred to the integration directory , either as predetermined automatic upgrades or manually via graphical tools.","The integration directory  includes configuration-specific descriptions of business scenarios , business processes , routing rules , and executable mappings . The integration directory  also includes descriptions of active Web services , and active business partners . The integration directory  uses a description of the active system landscape  from the system landscape directory . The business scenarios  in the integration directory  represent the overall view of the interaction among interfaces and mappings  in the context of the actual configuration relevant for the specific implementation. The business processes  represents an executable description of all active business processes.","The routing rules  determine the receivers of a message on a business level. In one specific implementation, the content of a message is used as a routing rule . Other parameters may also be used. Relevant input parameters include the sender, the sender message type, the message to identify the receivers, and the receiver message type. The routing rules  can be described declaratively using XML Path Language (Xpath, i.e. by using a graphical tool) or can be coded in Java or use routing objects . The integration engine  at runtime accesses information on the routing rules .","The routing rules  may use logical terms to describe senders and receivers in order to separate them from the physical address provided by the Web services  described in the integration directory . The physical address can therefore be changed without changing business-oriented content. Mappings  in the integration directory  represent mappings required in the active system landscape, in contrast to the integration repository mappings  that contains all supported mappings. Some new entries however, such as a new sequence of mappings, can be made only in the integration directory  to address additional Web services for mapping, for example. The integration engine  accesses the integration directory mappings  at runtime.","Web services  describe interfaces implemented within the current active system landscape, as well as active Web services supported by described business partners . As such, information describing Web services  can be exchanged with UDDI-compatible directories or added manually. Each Web service  description also provides physical addressing details, access information, and other special attributes such as uniform resource locator (URL), protocol, and security information. In one implementation, the Web services  are described in WSDL, and SOAP and ebXML are used as messaging protocols. The integration engine  accesses information about the Web services  at runtime as well.","The system landscape  of the system landscape directory  describes the current system landscape that uses the XI . The system landscape  describes which components are installed and available on certain machines within the system, which instance or client was chosen, further information on the installed components, other system landscapes, and so on. The system landscape  description is based on an open architecture and can adhere to any widely accepted standard such as CIM. Thus, many proprietary and third party components can be configured to automatically register themselves in the system landscape  upon being installed within the actual system landscape. Access interfaces to the system landscape  description can be based on open standards as well, such as the Web-based Enterprise Management (WBEM) and SOAP standards.","Business partners  defines information for business partners of an enterprise, such as names, addresses, and URLs, but may also contain more detailed and sophisticated information. For instance, the business partners  may include a description of the message formats that can be directly received and processed, or of security protocols used for safe communications, or trading terms that are employed in the partnership. The kind of information stored in business partners  can be governed by enterprise-specific decisions of the enterprise using the XI .","The integration directory  and the runtime engine  form a collaborative runtime environment for executing collaborative business processes. The collaborative runtime environment provides all runtime components relevant for exchanging messages among the connected software components and business partners. The integration server  executes the collaborative runtime environment or Web application server , either of which can include an instance of the runtime engine  in accordance with informational resources provided by the integration directory .","The runtime engine , which exchanges all messages between the various interconnected components, includes two layers: an integration layer  and a messaging and transport layer (MTL) . The integration layer  includes a business process engine  executing centrally modeled business processes, a logical routing service  and a mapping service . The MTL  provides a physical address resolution service , a messaging and queuing service , a transport service  via HTTP, and a database . The integration services  in the integration server  can support the runtime engine . An MTL  is also included in each instantiation of the runtime engine  in Web applications servers , as well as in each adapter  of the adapter framework connecting to various software components. Each MTL  has a role in the execution of the EO protocol, as will be explained further below.","At runtime, business processes  are instantiated and executed by the business process engine , which executes the respective Web services described in Web services  independent of their location according to the business process model. The business process engine  is independent of the semantics of the executed business processes , and is configured as a mediator and facilitator for business processes  to interact with technical components of the runtime system landscape.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 4","b":["214","303","302","303","305","304","310","307","302","214","309","304","304","311","304"]},"With reference also to , for a given message the logical routing service  uses information on the sending application and the message interface to determine receivers and required interfaces by evaluating the corresponding routing rules, as shown at . The routing rules are part of the configuration-specific descriptions of the runtime system landscape provided by the integration directory , and can be implemented as Xpath expressions or Java code. The mapping service  determines the required transformations that depend on message, sender, and sender interface, as well as the receiver and receiver interface, at . In the case of asynchronous communication, even the message direction is determined to appropriately transform input, output, and fault messages.","After retrieving the required mapping from the integration directory , the mapping service  can either execute XSLT mappings or Java code (or any combination in a given sequence) to the content of the sent message. Below the integration layer, messaging, queuing, and transport services  move the message to the intended or required receiver(s). After the message is transformed into the format expected by each receiver, the physical address of the required receiver service and other relevant attributes are retrieved from the integration directory  and mapped to the message, at .","A queuing engine in the messaging and queuing service  stores ingoing, outgoing, erroneous, and work-in-progress messages persistently. The messaging layer of the runtime engine  provides queuing functions for the physical decoupling of application components and guarantees messages are delivered exactly once according to a protocol (i.e. the \u201cEO protocol\u201d). The transport service  enables the runtime engine  to act as both an HTTP client and server. The transport service  implements an HTTP client that enables outbound communication and an HTTP server that handles inbound communication by accepting incoming documents. Additional server functions can address situations in which the receiver has no HTTP server by supporting polling over HTTP.","A routing model defines the message flow regarding one or more business processes. It is a way of grouping messages, and is valid during a certain period of time. A routing relation defines a communication channel (i.e. sender, outbound interface, receiver, inbound interface) while the routing rule includes a test as to whether this channel will be used for a given message. A routing rule can be defined as a logical expression using routing objects. Alternatively, in specific implementations a routing rule is an Xpath expression scanning the message body, or JAVA coding receiving the message body and returning a Boolean.","The routing model is used to determine the receivers and the inbound interfaces for a given message being sent. A service called \u201clogical routing\u201d take places on one or more runtime engines , such as the integration engine or collaborative runtime environment. To improve performance, a routing model directory can be cached at runtime and distributed to all clients where logical routing will take place via remote access to the runtime engine. The routing model provides APIs to determine the receivers of a given outbound interface call before the data has been completely collected by the sending application. This enables the sending application to find out whether a message needs to be sent at all, prior to expending resources collecting the data.","According to a preferred implementation, there are two different target groups that use the routing model: application developers who design outbound interfaces, define routing object, and specify where to find the values for routing objects in their interface; and administrators who define the messaging between systems within their company, as well as messages exchanged with business partners.","In an implementation, there are three different groups of use cases: 1) development of the integration repository ; 2) configuration of the routing model; and 3) receiver determination at runtime (logical routing). In the first use case, the tasks of a system administrator is greatly simplified by identifying relevant routing objects  and specifying where to find them in their interfaces . For the next group of use cases, configuration of the routing model, administrators can configure a business process  that spans more than one system or product by defining the messages that are to be exchanged. An administrator can create a new routing model to group all messages relevant for a particular business process  and add routing relations for each message to be sent. The administrator can also create rules and assign them to the routing relations.","In a third group of use cases, the integration server  can use the routing model to determine the logical receivers of a given message. The integration server  passes the message including a specific header to the logical routing service  in the runtime engine . The runtime engine  checks the routing relations and their routing rules in all valid routing models for receivers, and adds the valid receivers to the message header.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 3","b":["402","402","404","406","408","408","410","412","412","410"]},"A routing relation  provides a communication channel between two systems: the messages created by a sender's outbound interface can be delivered to a receiver's inbound interface. Whether a given message instance is really distributed according to a routing relation  depends on the message body, i.e. the application data within the message, and will be determined by the associated routing rule(s) . It is possible to have more than one routing relation  with the same sender and outbound interface so that a message might be sent to several receivers. The sender and receiver can be specified according to any business scenario  or business process  from the integration directory . However, the routing relation  can also be defined using raw strings or raw interfaces.","Routing objects can be defined by the sending application to cover the most common criteria for receiver determination. Preferably, a GUI can be used to define routing rules  with routing objects, so instead of having to know a rather complex language such as Xpath or JAVA, a user can simply choose the appropriate routing objects. The GUI can be implemented as a thick client connected to the configuration server using RMI. The GUI enables the user to work either inside the company's LAN or behind a firewall. The GUI also enables an administrator to define the message flow between internal systems, as well as the message flow between internal systems and external components. Moreover, the GUI will enable the administrator to gain an overview of the message flow in an optimized presentation, such as messages sent or received by one system, messages regarding one business process, or an overview of the complete message flow.","To accomplish receiver determination, all information about routing relations  needs to be cached in all systems where logical routing will take place. Since the routing relation  will support a system landscape with more than one runtime engine, there must be consistency between cached directories, such that no matter which client uses the runtime APIs, the same set of receivers and interfaces will be returned for any message. Since all integration directories  cache the necessary information at runtime, a common concept can be employed to guarantee consistency between them.","Referring back to , the integration repository  includes routing objects  and routing object value extractors. Business partners such as customers can define their own routing objects , and relate them to any outbound interface  according to any business scenario . Routing objects  belong to a software component and can be defined by an application by a name, a description, and a global business entity or, if no global business entity is available, a simple data type.","Each routing object  can be used in more than one outbound interface , and so for each interface , it must be determined where to find the routing object's  value in corresponding XML messages. This information, called the routing object value extractor (ROVE), can be defined for the interface at design-time. The ROVE can relate a given outbound interface  to any routing object  with the same global business entity or simple data type, from the same or another software component. The runtime engine  operates on a persistent storage to execute the routing relations and routing rules , including used routing objects  and their corresponding ROVEs. The local storage should be kept consistent so that the same receivers can be determined on any runtime system.","When a message is passed to the routing model runtime by the integration server \/runtime engine , it contains a message body that includes application data, and a message header. The message header includes data used by the runtime engine  for logical routing, mapping, and physical routing. The sender and its outbound interface, as well as the receivers and their inbound interfaces, are parts of the header. The sender and outbound interface fields may already contain values, otherwise the receiver determination will exit with an exception.","The message header may take the form of at least one of the following scenarios: 1) no receiver specified; 2) exactly one receiver specified and the receiver is the runtime system; or 3) one or more receivers specified and none are the runtime system. The first case, where no receiver is specified, will likely be the most common situation. The routing model runtime will calculate the receivers and their inbound interfaces according to all valid routing relations, and write them into the message header. The second case where only the runtime system is specified occurs if the message has been sent by another integration server. The routing model runtime will calculate the receivers and their inbound interfaces according to all valid routing models, and will then replace the supplied receiver with the newfound receivers and their interfaces.","In the third case, where one or more receivers are specified and none of them are the runtime system, occurs if the receiver determination already took place, such as on the sending system in the integration engine or by the sending application itself for instance. The runtime engine will not perform receiver determination, but will simply accept the message receivers. However, in this case it could still happen that only the receiving systems are specified but not inbound interfaces for those receiving systems. In this situation, the routing model runtime will check the valid routing models and add the inbound interfaces for the specified receivers. If a routing relation cannot be found for a given receiver, the receiver determination will end with an exception. Another case, in which more than one receiver is specified, one of which is the runtime system, should not occur and is not supported by the routing model runtime. In the event this situation occurs, the receiver determination will end with an exception.","Some applications provide outbound interfaces with a large number of parameters. These applications typically support a \u201cpublish and subscribe\u201d function where copies of certain objects will be distributed to all interested systems. To avoid having to build a message for which no receiving system is interested, the integration directory offers API's to determine the receivers of a message before its data has been collected completely, according to the following process:","First, the application determines whether there is an interested receiving system at all (i.e. a routing relation with the local system as a sender of the application's outbound interface) and, if so, whether the rules for these relations are built on routing objects. Second, and optionally, if there are systems interested in the application's messages, the application can read the values of all routing objects supported by the outbound interface and ask the routing model directory for the receivers of a message containing these values. This second step should only be relevant for applications with large interfaces. The values of the routing objects are passed to the API directly instead of being extracted from the message body by an XML parser. The routing objects can also be defined by third parties, and the applications should contain an exit to read those values.","Although a few embodiments have been described in detail above, other modifications are possible. Other embodiments may be within the scope of the following claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["These and other aspects will now be described in detail with reference to the following drawings.",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
