---
title: Event logging application programming interface (API)
abstract: An event logging interface on a computer system is used to record an event when an application hosted by the computer system encounters the event. The event logging interface receives data pertaining to an event from the application. Using the event logging interface, the computer system determines a logical target of the event, and determines one or more physical destinations referenced by the logical target. The data is then dispatched to one of the physical destinations.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08997116&OS=08997116&RS=08997116
owner: Red Hat, Inc.
number: 08997116
owner_city: Raleigh
owner_country: US
publication_date: 20091112
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","DETAILED DESCRIPTION"],"p":["Embodiments of the present invention relate to event logging in a computer system, and more specifically, to an application programming interface (API) that facilitates the generation of event logging information.","Computer applications generate and submit logging information to record events (e.g., errors or warnings). Conventionally, applications write logging information to files, databases or the syslog. The syslog is a standard for sending log messages in an Internet Protocol (IP) network but is difficult to process due to lack of structure. Files often do not have a well-defined structure, too. Databases generally provide a fixed structure for logging information such as audit logs. However, data in the audit logs often varies significantly from one situation to another. Databases usually do not have a clear definition for each data field where the definition can apply to all possible situations. Therefore, a database may end up in a situation where half of the fields are empty and most of the data has to be jammed into a few fields.","Generally, conventional event logging techniques are unable to reliably extract information from free form strings. One of the problems in the existing logging interfaces is that they permit application to send event messages in free form. This lack of structure in the messages makes analysis of the log data stream extremely difficult to reliably interpret. With the various formats that are conventionally used for logging information, it is also difficult to collect the logging information, merge and forward it to a centralized remote location for compliance and forensic inspections.","Conventional event logging techniques are also unable to dispatch data to multiple destinations. An application developer can specify one destination for the data related to an event. However, in some scenarios, an application developer may wish to send the same event data to different destinations that serve different purposes (e.g., logging, debugging and audit). To send event data to different destinations for logging, debugging and audit trails, an application developer usually needs to deal with multiple different interfaces and multiple different ways of generating information from the application.","Additionally, conventional applications usually select a logging interface such as the syslog or files for convenience during the developmental time. As the development of the application matures, an application developer may want to change the logging destination to a more advanced alternative. An application developer may also want to write the logging information into a file that is human readable. Moreover, when a logging destination fails, an application developer may want to write the logging information into a backup destination. However, modifying an application to change its logging destination and data formatting can be time consuming and error prone.","Described herein is a method and system for event logging. In one embodiment, an event logging interface on a computer system receives data pertaining to an event from an application that is hosted by the computer system. Using the event logging interface, the computer system determines a target of the event, and determines one or more physical destinations referenced by the logical target. The data is then dispatched to one of the physical destinations.","In one embodiment, the event logging interface is implemented as an application programming interface (API), also referred to as an event logging API (ELAPI). The ELAPI is an interface to an application for receiving original structured event data from the application. The ELAPI abstracts an application from its actual logging destination. The actual logging destination can be a local file, syslog, database or a remote server location. The actual logging destination can be plugged into the ELAPI without any changes to the application. The ELAPI provides a configurable interface for sending event data into different destinations.","In one embodiment, the ELAPI accepts event data in the form of key-value pairs. The ELAPI allows an application to pass arbitrarily complex data to a logging destination. The data emitted from the application is a collection of key-value pairs (also referred to as \u201coriginal structured event data\u201d). The collection of key-value pairs is structured when the application creates it. The collection of key-value pairs is also \u201coriginal\u201d since it is the data emitted from the application, and the structured representation is not achieved by the ELAPI performing additional data parsing operations. The collections can be easily constructed, modified or nested, allowing reuse of the data in different events. For example, the information about a peer host or socket properties can often be reused in different events. The introduction of the key-value pairs resolves a problem in the existing logging interfaces, which is the lack of structure in the messages sent from the applications. The lack of structure makes analysis of the log data stream extremely difficult to reliably interpret.","The information logged by the ELAPI is complete and also human readable. In one embodiment, the ELAPI separates the data of the event from the actual presentation (i.e., formatting) of the message. Thus, the information logged by the ELAPI can contain much more data than the message presented to a user. The logging destinations that define human readable formats (e.g., a file) will receive the event data in the formatted, user readable form. Some logging destinations may receive the data and the formatting information separately. In those cases, the original structured event data can be easily converted into a human readable form at any moment when the user wants to inspect the event.","To improve the reliability of the logging destination, in one embodiment, the ELAPI allows defining multiple sinks (i.e., physical destinations) per logical target (\u201ctarget\u201d) of an event. The sinks can be linked in a failover order. If a first sink in the failover order returns an error, the ELAPI will automatically fail over to a next sink without returning an error.","In one embodiment, the ELAPI can also be used as a reporting tool. Event data can be sent to an output destination (e.g., a file) in different formats (e.g., Comma-Separated Values (CSV), Hypertext Markup Language (HTML), Extensible Markup Language (XML), etc.) to generate a report. Thus, the ELAPI can be used to create simple conversion tools that receive data in one format and output the data in another format.","In the following description, numerous details are set forth. It will be apparent, however, to one skilled in the art, that the present invention may be practiced without these specific details. In some instances, well-known structures and devices are shown in block diagram form, rather than in detail, in order to avoid obscuring the present invention.",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1","b":["100","100","100"]},"The computer system  may include a host OS  (e.g., Linux OS, Windows\u00ae OS, etc.) to manage system resources, including access to host hardware . Host hardware  includes a central processing unit (CPU) , memory  and other hardware components (e.g., I\/O devices ). The host hardware  is also coupled to data storage . The memory  may include volatile memory devices (e.g., random access memory (RAM)), non-volatile memory devices (e.g., flash memory), and\/or other types of memory devices. The data storage  may include mass storage devices, such as magnetic or optical storage based disks, tapes or hard drives.","According to one embodiment of the present invention, the computer system  may host a number of applications  to perform various tasks. During execution, an application  may encounter events that need to be recorded for logging, debugging, auditing or other purposes. For example, the application  may experience data loss at runtime, and may log information pertaining to the data loss for debugging purposes. The application  can send original structured event data, as a collection of key and value pairs, to an event logging module or logic, such as an event logging application programming interface (ELAPI) . The ELAPI  is an interface that allows applications to generate and send logging, tracing, audit, or other information to configurable destinations without knowing what its actual (i.e., physical) destinations of event data are. The physical destinations (e.g., syslogs, files or remote server locations) can be plugged into the ELAPI  and can be updated or configured as necessary, without any changes to the application. The event data can further be converted into a human readable format when requested by a user. The same event data can be presented, in more than one format, to application developers or other users as necessitated by the situations. As a result, the use of the ELAPI  significantly reduces the complexity of writing and developing an application.","In contrast, in a computer system without the ELAPI , an application developer would need to specify a logging destination (e.g., the syslog) within the application, and include application code that would format the original structured event data in accordance with the requirement of the destination. Information can be lost during data formatting and conversion. Further, tying an application with its physical destination would render it difficult to upgrade the destination at a later stage of application development. For example, as the development of an application matures, an application developer may want to change the logging destination from the syslog to a database. Changing the code in an application can be time consuming and error prone.","The implementation of the ELAPI  allows data reuse. An application developer may create an event template that includes a set of key-value pairs. The key-values pairs in the event template include common properties that do not change or rarely change during the execution of an application, or during the processing of a connection or a request. Instead of constructing the entire data set from an event each time, common data such as process ID, host name and IP address, severity and other attributes\/properties can be combined together into the event template. Thus, in one scenario where an actual event needs to be logged, an application developer needs to add only a couple specific attributes that are related to this particular event, and references the pre-created template that contains the common data. In an alternative scenario, the event data may be passed from an application to the ELAPI  as a collection key-value pairs without the use of an event template.","An example of using an event template is provided as follows. An application developer may determine that all of the \u201cerror\u201d events in an application have process ID, user ID, host name, time stamp, etc. The application developer may create a template that contains these fields (i.e., \u201cattributes\u201d or \u201cproperties\u201d). When an error event occurs, the developer can create an event using this template, plus additional error code to it. The developer does not need to specify any of the fields that he has already prepared in the template.","Some of the fields in a template can be auto-resolvable. For example, the time stamp value in the template can be initially set to 0, and can be automatically replaced by the actual time stamp when an event is generated.","Assume that an event consists of the properties of A, B, C, D, E, and F, and only E and F are specific to the event. A, B, C and D are common properties that do not change for the application as a whole, or in the context in which the events are created. The term \u201ccontext\u201d refers to a \u201cthread,\u201d \u201cconnection,\u201d \u201csession,\u201d or other properties that may be less long-lived than the application itself, but long-lived enough so that multiple events will be originated with the same set of properties. Examples of common properties of the context may include: thread ID or connection peer name, socket number, session ID, etc. Thus, an application developer may create a template T that captures the common properties A, B, C and D, and then log the template T with E and F.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 2","b":["107","107","210","107","107","107"]},"The ELAPI  further includes a dispatcher , which is an entity for holding targets (e.g., targets A-D) and sending event data to the targets. The dispatcher  contains target evaluation logic  for determining whether an event is to be logged into a target and which target is to be used. In one embodiment, a target can be linked to one or more sinks (e.g., sinks X, Y, Z, M and N), which are also referred to as \u201cphysical destinations\u201d of event data. Each sink is associated with a specific logging facility, such as a file, syslog, database, remote logging server etc. If a target is linked to multiple sinks, the multiple sinks can be chained in a failover order indicated by the dotted lines in .","In one embodiment, when the ELAPI  logs into a specific target (e.g., target A), the ELAPI  uses the first sink in the failover chain (e.g., sink X) linked to target A. If this sink returns an error and there is a next sink (e.g., sink Y) in the failover chain, the dispatcher  will automatically direct the event data from the target to the next sink without returning an error. If there are no available sinks in the chain (e.g., all of the sinks in the failover chain return an error), the ELAPI  will report the error to the application from which the event data was sent. The application has the responsibility to take a corresponding action to handle the error. In some embodiments, the same sink can be linked to different targets.","In one embodiment, the ELAPI  also includes a configuration file  that contains information about the targets and sinks. The information is used at runtime to determine the logical and physical destinations of event data. The configuration file  can be updated to indicate changes, additions and deletions to targets and sinks without a change to the application. In one embodiment, the configuration file  may be stored in a storage location (e.g., the memory  or the data storage ) that is accessible by the ELAPI .","With the use of the ELAPI , the targets and sinks can be reconfigured as necessary without a change to the application. An application developer can write code that identifies the logical destinations (\u201ctargets\u201d) for the events generated by his application. For each event, the application developer identifies whether the event is a debug message, a normal operational log message, a special audit log message (e.g., a critical identity-related change), etc. What is behind these \u201clogical\u201d targets does not matter for the application developer when developing the application. An administrator, who uses the application, can configure the sink chains that link to each of the targets and provide an actual meaning to these destinations. The administrator will be able to configure whatever he sees fit as physical destinations.","For example, an application developer may identify 3 different targets: LOG, AUDIT and DEBUG. Assume that the application developer decides to use ID 0001 (in binary representation) for LOG, 0010 for AUDIT and 0100 for DEBUG. If the application developer wants to send event data into two targets for the same event at the same time (e.g., LOG and AUDIT), a logical OR operation: 0001 OR 0010=0011 can be performed. The argument 0011 will be passed to the ELAPI . The ELAPI , in turn, uses the argument, the list of targets and their associated sink chains from the configuration file  to determine where to route the event data. Each target is identified in the configuration file  by its target identifier. If the AND operation of this target identifier and the argument value result in a non-zero value, the event target is identified and the event data will be routed to the corresponding sink chain. Thus, with the argument 0011, the target 0001 and 0010 can be identified as the logical destinations of the event. If a target with an identifier of 0011 is also configured in the configuration file , the target 0011 will also be identified as a logical destination of the event.","The implementation of targets provides great flexibility to the development and use of an application. An application typically sends different information into different logs, but sometimes it may be necessary to send the same event into different logs. The ELAPI  provides targets as a convenient feature that enables an application developer to specify more than one target within one logging operation. The ELAPI  also enables an administrator to change the ELAPI configuration in such a way that two events (which were supposed to go into two different destinations) can be sent into one sink. The administrator may want (for a short time) to send all of the event data into one file to see the whole picture in one place. This feature can be important for the administrator to troubleshoot some issue.","Further, with the use of the ELAPI , an application developer can plug in code that formats and writes the original structured event data to the syslog, files and remote server locations. For example a service can be written that collects event data from multiple ELAPI-enabled applications, filters the data, and then delivers the data to a central auditing server for storage and processing. The client for this service can be implemented as an ELAPI sink, and plugged into ELAPI-enabled applications central collection of the events without modifying the applications.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 3","FIG. 4","FIGS. 1 and 2"],"b":["300","300","400","300","107"]},"Referring to , in one embodiment, the method  begins when the ELAPI  receives original structured event data (\u201cevent data\u201d) from an application (block ). The application, when encounters an event, may call the ELAPI  and send the event data to the ELAPI . The event data may be passed to the ELAPI  as a collection of key-value pairs. The keys, also referred to as attributes, may include a time stamp, process ID (PID), hostname, etc. Keys may be defined and added by an application developer.","Upon receiving the event data, the ELAPI  identifies the target or targets of the event (block ). In one embodiment, each target maintained by the ELAPI  has a corresponding section in the configuration file . This section specifies the sinks that are linked to the target and includes a bit mask value associated with and identifying the target. When a caller (e.g., an application) calls the ELAPI  at runtime, the call may include a bit mask argument. The bit mask argument can be used to identify the target of the event. In one embodiment, the ELAPI  compares the bit mask argument with all of the bit mask values stored in the configuration file . The comparison can be performed with a logical AND operation as described above. The result of the logical AND operation identifies one or more specific targets. An error will be returned if the result does not identify any target. Once a target is identified, the ELAPI  identifies the sinks that are linked to the target in a failover order (block ). The ELAPI  will try to write into a sink that does not return an error. If a sink (e.g., the first sink) in the failover chain returns an error (block ), the ELAPI  will try the next sink (e.g., the second sink, the third sink, etc.) in the chain, until it finds a sink that does not return an error. If all of the sinks in the failover chain return an error, the ELAPI  will report the error to the application from which the event data was sent.","The ELAPI  writes the event data to the identified sink as a collection of key-value pairs (block ). The sink can format (e.g., serialize) the event data and writes into a file, syslog or some other physical destination (block ). The sink can convert the event data into human readable form, insert the event data into a database, or send the event data to a central location for storage, etc. The sink may convert the event data into different formats for different purposes. For example, the data may be formatted into a message for the syslog, or a HTML format for viewing by a user via a Web browser.","The ELAPI  provides an application the options of synchronous process and asynchronous processing. Asynchronous processing allows an application to perform other tasks without waiting idly for the event data to be written into a device (e.g., a memory or a disk). Sometimes the communication with another service or writing to a file (e.g., when writing to a file on the Network File System (NFS)) can cause an application to block for a significant period of time. To avoid blocking, the ELAPI  supports integration with a \u201cmain loop\u201d of an application. The \u201cmain loop\u201d is a function that waits for a trigger; e.g., a socket to become ready to read or write, a signal to arrive, or a timer to expire. The ELAPI  and its sink hook into the main loop to add its timers, sockets and\/or file descriptors, and to tell the main loop what is to be executed when specific triggers occur.","In one embodiment, the application and the ELAPI  exchange callbacks. The application passes to the ELAPI  one set of callbacks (\u201capplication callbacks\u201d) that the ELAPI  should use to talk to the main loop of the application. In return, the ELAPI  exposes another set of callbacks (\u201cELAPI callbacks\u201d) that the main loop should execute when the device is ready. It is the responsibility of the application developer to provide the implementation of the first set of callbacks (i.e., the application callbacks). These application callbacks will invoke the ELAPI callbacks to perform the actual writing to the device. When the ELAPI  wants to write data on a socket or file descriptor, it will execute the application callbacks to inform the main loop of the pending action. This pending action is queued by an event library that the application chooses to use for its main loop, and control will return to the application while the pending write is still enqueued. Thus, the application will not be blocked by the pending write, and can continue with its other tasks.","As soon as a trigger occurs (e.g., when the device is ready), the main loop of the application calls a corresponding ELAPI callback to perform an actual write operation to the device. If the actual write operation failed, the ELAPI callback can decide what to do next.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 4","b":"400"},"The exemplary computer system  includes a processing device , a main memory  (e.g., read-only memory (ROM), flash memory, dynamic random access memory (DRAM) such as synchronous DRAM (SDRAM) or Rambus DRAM (RDRAM), etc.), a static memory  (e.g., flash memory, static random access memory (SRAM), etc.), and a secondary memory  (e.g., a data storage device), which communicate with each other via a bus .","The processing device  represents one or more general-purpose processing devices such as a microprocessor, central processing unit, or the like. More particularly, the processing device  may be a complex instruction set computing (CISC) microprocessor, reduced instruction set computing (RISC) microprocessor, very long instruction word (VLIW) microprocessor, processor implementing other instruction sets, or processors implementing a combination of instruction sets. The processing device  may also be one or more special-purpose processing devices such as an application specific integrated circuit (ASIC), a field programmable gate array (FPGA), a digital signal processor (DSP), network processor, or the like. The processing device  is configured to execute the event logging logic  for performing the operations and steps discussed herein.","The computer system  may further include a network interface device . The computer system  also may include a video display unit  (e.g., a liquid crystal display (LCD) or a cathode ray tube (CRT)), an alphanumeric input device  (e.g., a keyboard), a cursor control device  (e.g., a mouse), and a signal generation device  (e.g., a speaker).","The secondary memory  may include a machine-readable storage medium (or more specifically a computer-readable storage medium)  on which is stored one or more sets of instructions (e.g., event logging logic ) embodying any one or more of the methodologies or functions described herein (e.g., the ELAPI  of ). The event logging logic  may also reside, completely or at least partially, within the main memory  and\/or within the processing device  during execution thereof by the computer system ; the main memory  and the processing device  also constituting machine-readable storage media. The event logging logic  may further be transmitted or received over a network  via the network interface device .","The machine-readable storage medium  may also be used to store the event logging logic  persistently. While the machine-readable storage medium  is shown in an exemplary embodiment to be a single medium, the term \u201cmachine-readable storage medium\u201d should be taken to include a single medium or multiple media (e.g., a centralized or distributed database, and\/or associated caches and servers) that store the one or more sets of instructions. The term \u201cmachine-readable storage medium\u201d shall also be taken to include any medium that is capable of storing or encoding a set of instructions for execution by the machine that cause the machine to perform any one or more of the methodologies of the present invention. The term \u201cmachine-readable storage medium\u201d shall accordingly be taken to include, but not be limited to, solid-state memories, and optical and magnetic media.","The computer system  may additionally include an event logging module  for implementing the functionalities of the ELAPI  of . The modules , components and other features described herein (for example in relation to ) can be implemented as discrete hardware components or integrated in the functionality of hardware components such as ASICS, FPGAs, DSPs or similar devices. In addition, the modules  can be implemented as firmware or functional circuitry within hardware devices. Further, the modules  can be implemented in any combination of hardware devices and software components.","Some portions of the detailed descriptions which follow are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here, and generally, conceived to be a self-consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually, though not necessarily, these quantities take the form of electrical or magnetic signals capable of being stored, transferred, combined, compared, and otherwise manipulated. It has proven convenient at times, principally for reasons of common usage, to refer to these signals as bits, values, elements, symbols, characters, terms, numbers, or the like.","It should be borne in mind, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise, as apparent from the following discussion, it is appreciated that throughout the description, discussions utilizing terms such as \u201creceiving\u201d, \u201cdetermining\u201d, \u201cdispatching\u201d, \u201cconverting\u201d, or the like, refer to the action and processes of a computer system, or similar electronic computing device, that manipulates and transforms data represented as physical (electronic) quantities within the computer system's registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage, transmission or display devices.","Embodiments of the present invention also relates to an apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes, or it may comprise a general purpose computer system selectively programmed by a computer program stored in the computer system. Such a computer program may be stored in a computer readable storage medium, such as, but not limited to, any type of disk including floppy disks, optical disks, CD-ROMs, and magnetic-optical disks, read-only memories (ROMs), random access memories (RAMs), EPROMs, EEPROMs, magnetic disk storage media, optical storage media, flash memory devices, other type of machine-accessible storage media, or any type of media suitable for storing electronic instructions, each coupled to a computer system bus.","The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein, or it may prove convenient to construct more specialized apparatus to perform the required method steps. The required structure for a variety of these systems will appear as set forth in the description below. In addition, the present invention is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the invention as described herein.","It is to be understood that the above description is intended to be illustrative, and not restrictive. Many other embodiments will be apparent to those of skill in the art upon reading and understanding the above description. Although the present invention has been described with reference to specific exemplary embodiments, it will be recognized that the invention is not limited to the embodiments described, but can be practiced with modification and alteration within the spirit and scope of the appended claims. Accordingly, the specification and drawings are to be regarded in an illustrative sense rather than a restrictive sense. The scope of the invention should, therefore, be determined with reference to the appended claims, along with the full scope of equivalents to which such claims are entitled."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention is illustrated by way of example, and not by way of limitation, and can be more fully understood with reference to the following detailed description when considered in connection with the figures in which:",{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
