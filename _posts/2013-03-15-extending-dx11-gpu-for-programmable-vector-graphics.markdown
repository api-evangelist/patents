---
title: Extending DX11 GPU for programmable vector graphics
abstract: The present disclosure provides for path rendering including receiving, with a graphics processing unit (GPU), data indicative of a path segment of a path to be rendered. The systems and methods render the path segment by performing a fill of the path segment, which includes tessellating the path segment into a first plurality of primitives including a triangle per primitive, storing a first plurality of primitives in a stencil buffer, and drawing a bounding box of the path segment and rendering the bounding box with a stencil test enabled. The systems and methods also stroke the path segment, including tessellating the path into a second plurality of primitives, re-tessellating the second plurality of primitives, cutting the second plurality of primitives according to a dash pattern, creating a cap at a location of a cut, and creating a triangulation of a stroke and rasterizing the stroke based on the triangulation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09330495&OS=09330495&RS=09330495
owner: QUALCOMM Incorporated
number: 09330495
owner_city: San Diego
owner_country: US
publication_date: 20130315
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application claims the benefit of U.S. Provisional Application No. 61\/681,498, filed Aug. 9, 2012; U.S. Provisional Application No. 61\/713,377, filed Oct. 12, 2012; U.S. Provisional Application No. 61\/723,274, filed Nov. 6, 2012, U.S. Provisional Application No. 61\/755,312, filed Jan. 22, 2013, U.S. Provisional Application No. 61\/755,359, filed Jan. 22, 2013, and U.S. Provisional Application No. 61\/755,391, filed Jan. 22, 2013, the entire content each of which is incorporated herein by reference.","This disclosure relates to techniques for graphics processing, and more particularly, to techniques for path rendering with a graphics processing unit.","Visual content for a display may be generated using path rendering techniques for vector graphics. Path rendering may refer to the rendering of two-dimensional (2D) vector graphics paths (alternatively referred to herein as \u201cpaths\u201d), each of which may include one or more path segments. When a path includes two or more path segments, the individual path segments may be of the same type or of different types. The types of path segments may include, for example, a line, an elliptic arc, a quadratic B\u00e9zier curve, and a cubic B\u00e9zier curve. In some examples, the path segment types may be defined in accordance with a standard vector graphics application programming interface (API), such as, e.g., the Open Vector Graphics (OpenVG) API.","Path rendering is typically implemented by a central processing unit (CPU). However, such an approach may be CPU-intensive, and may therefore limit the amount of CPU processing cycles available for other CPU tasks. Conventional techniques for vector graphics, including path rendering, may be implemented entirely in a CPU or partially in the CPU and partially in a GPU.","The present disclosure provides for systems and method of for path rendering including drawing a path segment, filling the path segment, including (1) tessellating the path into line segments, (2) rasterizing and scan-filling using a cell buffer, and (3) drawing a bounding box of the path using a fill color and a stencil from the cell buffer, and stroking the path segment, including (1) tessellating the path into line segments, (2) cutting the line segments according to a dash pattern, and (3) creating a triangulation of a stroke and rasterize the stroke.","In one example, the disclosure describes a method that includes receiving, with a graphics processing unit (GPU), data indicative of a path segment of a path to be rendered, rendering the path segment, with the GPU, by performing a fill of the path segment, filling the path segment including tessellating the path segment into a first plurality of primitives including a triangle per primitive, storing a first plurality of primitives in a stencil buffer, and drawing a bounding box of the path segment and rendering the bounding box with a stencil test enabled, and stroking the path segment, including tessellating the path into a second plurality of primitives, re-tessellating the second plurality of primitives, cutting the second plurality of primitives according to a dash pattern, creating a cap at a location of a cut, and creating a triangulation of a stroke and rasterizing the stroke based on the triangulation.","In another example, the disclosure an apparatus configured to perform graphics processing including a graphics processing unit configured to receive data indicative of a path segment of a path to be rendered, and render the path segment by performing a fill of the path segment, the fill including tessellate the path segment into a first plurality of primitives including a triangle per primitive, storing a first plurality of primitives in a stencil buffer, and draw a bounding box of the path segment and render the bounding box with a stencil test enabled, and stroke the path segment, including tessellate the path into a second plurality of primitives, re-tessellate the second plurality of primitives, cut the second plurality of primitives according to a dash pattern, create a cap at a location of a cut, create a triangulation of a stroke and rasterizing the stroke based on the triangulation.","In another example, the disclosure describes an apparatus including means for receiving data indicative of a path segment of a path to be rendered, means for rendering the path segment by performing a filling of the path segment, the means for filling the path segment, including means for tessellating the path segment into a first plurality of primitives including a triangle per primitive, means for storing a first plurality of primitives in a stencil buffer, and means for drawing a bounding box of the path segment and means for rendering the bounding box with a stencil test enabled, and means for stroking the path segment, including means for tessellating the path into a second plurality of primitives, means for re-tessellating the second plurality of primitives, means for cutting the second plurality of primitives according to a dash pattern, means for creating a cap at a location of a cut, and means for creating a triangulation of a stroke and rasterizing the stroke based on the triangulation.","In another example, the disclosure describes a computer-readable storage medium. The computer-readable storage medium having stored thereon instructions that upon execution cause one or more processors to receive data indicative of a path segment of a path to be rendered, and render the path segment by perform a fill of the path segment, the fill including tessellate the path segment into a first plurality of primitives including a triangle per primitive, storing a first plurality of primitives in a stencil buffer, and draw a bounding box of the path segment and render the bounding box with a stencil test enabled, and tessellating the path into a second plurality of primitives, re-tessellate the second plurality of primitives, cutting the second plurality of primitives according to a dash pattern, create a cap at a location of a cut, and creating a triangulation of a stroke and rasterizing the stroke based on the triangulation.","In one example, the disclosure describes a method that includes receiving, with a graphics processing unit (GPU), data indicative of a path segment of a path to be rendered, and rendering the path segment, with the GPU, by performing a fill of the path segment, filling the path segment including tessellating the path segment into a first plurality of primitives, rasterizing and scan-filling the path segment based on the first plurality of primitives using a cell buffer, and drawing a bounding box of the path segment and a stencil from the cell buffer.","The details of one or more examples are set forth in the accompanying drawings and the description below. Other features, objects, and advantages will be apparent from the description and drawings, and from the claims.","This disclosure is directed to techniques for using a graphics processing unit (GPU) to perform path rendering. Path rendering may refer to the rendering of two-dimensional (2D) vector graphics paths (alternatively referred to herein as \u201cpaths\u201d), each of which may include one or more path segments. When a path includes two or more path segments, the individual path segments may be of the same type or of different types. The types of path segments may include, for example, a line, an elliptic arc, a quadratic B\u00e9zier curve, and a cubic B\u00e9zier curve. In some examples, the path segment types may be defined in accordance with a standard vector graphics application programming interface (API), such as, e.g., the Open Vector Graphics (OpenVG) API.","As discussed above, conventional techniques for vector graphics, including path rendering, are implemented entirely in a CPU or partially in the CPU and partially in a GPU. Neither of these implementations allow for a single pass in the GPU. Additionally, neither implementation completely offloads vector graphics processing from the CPU. One is entirely based in the CPU, while the other uses both the CPU and the GPU.","As discussed, it can be undesirable to perform vector graphics processing in the CPU because such processing may be processor intensive and, accordingly, may limit the number of processing cycles in the CPU available to perform other functions. Additionally, in many cases, CPUs may consume more power when compared to GPUs. As many mobile devices may be battery powered, lower power consumption may be advantageous. Further, CPUs may not allow for as much parallel processing (e.g., for a comparable priced GPU). Generally, CPUs may also be more expensive when compared to GPUs.","Examples described herein provide systems and methods that may be applied to, for example, existing Microsoft DirectX11 compliant hardware (or equivalent hardware supporting tessellation), for example, by modifying the example system as described herein, to allow for path rendering which may be used in vector graphics processing. In an example, this disclosure provides for a single pass solution using the DirectX11 pipeline stages. Such an example may completely offload vector graphics processing from the CPU. Additionally, the disclosed techniques provide for programmable vector graphics processing as existing shader in the GPU and may be used to support other primitive types and joint\/end rules.","GPUs typically implement a three-dimensional (3D) graphics pipeline that is designed to be compliant with one or more 3D graphics APIs. Because the prevailing 3D graphics APIs in use today do not require that compliant devices support path rendering commands, modern GPUs often provide little to no hardware acceleration for path rendering commands. For example, a typical 3D graphics pipeline implemented in a modern GPU may include a rasterizer that is designed to rasterize low-order, non-curved, 3D graphics primitives (such as, e.g., points, lines and triangles), but is not capable of directly rendering curved path rendering primitives (such as, e.g., elliptic arcs and B\u00e9zier curves).","One approach for path rendering uses a GPU pipeline to provide partial GPU hardware acceleration for the execution of path rendering commands. Some examples may avoid pre-processing completely. In an example implementation a first vertex of a path may be used as the pivot point for filling. Additional hardware may be added to a GPU in a setup engine to compute minimum coordinates and maximum coordinates of path vertices. These minimum and maximum values may be used to determine the bounding box shape.","One approach for path rendering uses a modern 3D GPU pipeline to provide partial GPU hardware acceleration for the execution of path rendering commands. This approach involves preprocessing a path segment with a central processing unit (CPU) in order to convert the path segment into one or more low-order, non-curved, 3D graphics primitives that can be rasterized by the GPU. For example, a CPU may tessellate a curved path segment (e.g., an elliptical arc or a B\u00e9zier curve) into a set of relatively small triangles that approximates the curvature of the path segment, and may cause the set of triangles to be rendered using the GPU. Such an approach, however, may be CPU-intensive, and may therefore limit the amount of CPU processing cycles available for other CPU tasks. Moreover, in some cases, a relatively large amount of triangles may be needed to render the path segment at a desired level of detail. The relatively large amount of triangles may consume a significant amount of memory storage space when storing the data, and may consume a significant amount of memory bandwidth when transferring the data to the GPU.","Another approach for providing partial-to-total GPU hardware acceleration for the execution of path rendering commands may involve modifying the architecture of the GPU to support a dedicated, hardware-accelerated, path rendering pipeline. However, because the prevailing 3D graphics APIs (e.g., the Microsoft\u00ae DirectX 11 API) do not require a GPU architecture to include a dedicated path rendering pipeline, such an approach does not result in a cross-platform, hardware-accelerated, path rendering solution that would be guaranteed to be supported by all GPUs which are compliant with a particular 3D graphics API (e.g., the DirectX (DX) 11 API).","The path rendering techniques in this disclosure may provide a GPU hardware-accelerated path rendering solution where the GPU is configured to tessellate a received indication of a path segment into a plurality of line segments, and to render the tessellated line segments using a 3D graphics pipeline. By using the GPU to tessellate a path segment into line segments, the burden of preprocessing path segments is lifted from the CPU, thereby freeing up processing resources for other CPU tasks. Moreover, the GPU may, in some examples, utilize a highly-parallel, modern GPU tessellation architecture to perform the tessellation operations, which may, in some examples, allow the GPU to tessellate a path segment in a more efficient manner than the CPU. In addition, because the tessellation occurs in the GPU, rather than in the CPU, a multitude of tessellated primitives do not need to be stored in system memory and do not need to be passed from the CPU to the GPU, thereby reducing the memory footprint needed for path rendering as well as the memory bandwidth needed for path rendering.","Tessellating the path segment may include tessellating the path segment using a fixed-function tessellation engine of the GPU and a domain shader program executing on a shader unit of the GPU. Additionally, in an example, a cell buffer may be used. The cell buffer may be a memory that includes a number of cells. For example, the cell buffer may be a sixteen by sixteen grid of sub-pixels. One cell may represent one pixel in a final image. The cell buffer may contain a matrix of x*y cells, with one cell representing one pixel in a final image, each cell in the cell buffer storing winding counter information, and wherein the cell buffer is the same size as a frame buffer.","In one example, every cell in the cell buffer represents one pixel in the final image. Every cell may store a winding counter information. Cell buffer size may be as big as the frame buffer size, but memory requirements may limit some examples. Accordingly, the frame buffer may be split into a number (x*y) of tiles of pixels with the cell buffer size is x*y cells. A device may draw one tile at a time, and then carry the winding counter information on the last column (rightmost) to the next tile (the one to the right). If the current tile is the first one in a row, there is no previous tile, hence there is no carryover. For these tiles, rasterized lines may be clamped to the first column.","In some examples, the GPU may be configured to tessellate and render a path segment using a graphics architecture that is specified by a particular 3D graphics API, such as, e.g., the DirectX 11 API, without requiring any additional hardware components and\/or modifications to the graphics architecture. By utilizing only architectural features likely or guaranteed to be present by a particular 3D graphics API when performing path rendering in such examples, a cross-platform, hardware-accelerated, path rendering solution may be realized that is capable of being implemented on any device that is compliant with the 3D graphics API. For example, the techniques of this disclosure may, in some examples, provide a path rendering solution that is capable of being used on any DirectX 11 compliant graphics hardware. In some examples, some path rendering techniques (e.g., dashing and cusp handling) may be disabled in order to implement a DirectX 11 path rendering solution that utilizes the DirectX 11 architecture without any modifications.","Path rendering may be divided into two main operations: (1) filling a path segment and (2) stroking a path segment. In some examples, one or both of the filling and stroking operations may be performed to completely render a path. The filling operation may be configured to fill the interior region of a path segment with a specified fill color. The stroking operation may be configured to \u201cwiden\u201d the edges of a path segment by working outward perpendicularly to the path. In addition to the main operations, path rendering may also involve applying various types of end caps to the ends of a path, and applying various types of joins between the endpoints of interior path segments of a path to create a smooth path.","After a path segment has been tessellated, a GPU that implements the path rendering techniques of this disclosure may be configured to generate 3D geometry corresponding to the tessellated path segment that allows one or both of a fill area for the path segment and a stroke area for the path segment to be rendered by the GPU. The 3D geometry may include low-order, non-curved, 3D graphics primitives (e.g., triangles) that are capable of being rasterized by existing 3D rasterization engines. By rendering the fill areas and\/or stroke areas for a path segment based on the 3D geometry that is generated by a GPU from a plurality of tessellated line segments that approximate a path to be rendered, a 3D GPU pipeline may be used to provide either a 100% or a nearly 100% GPU solution for the execution of filling and stroking operations.","In some examples, to implement these methods in, for example, a DirectX11 pipeline architecture, or other similar 3D graphics pipelines, may be modified according to the techniques of this disclosure to include a number of extensions. For example, the DirectX11 pipeline may be modified to include a path primitive. The path primitive may allow the DirectX11 pipeline to process vector graphics by allowing for path rendering directly in a GPU implementing DirectX11 without using a separate CPU. For example, the path primitive may allow for filling, stroking, or both using the methods described herein.",{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 1","b":["2","2"]},"As illustrated in the example of , computing device  includes a user interface , a CPU , a memory controller , a memory , a graphics processing unit (GPU) , a GPU cache , a display interface , a display  and bus . User interface , CPU , memory controller , GPU  and display interface  may communicate with each other using bus . It should be noted that the specific configuration of buses and communication interfaces between the different components illustrated in  is merely exemplary, and other configurations of computing devices and\/or other graphics processing systems with the same or different components may be used to implement the techniques of this disclosure.","CPU  may comprise a general-purpose or a special-purpose processor that controls operation of computing device . A user may provide input to computing device  to cause CPU  to execute one or more software applications. The software applications that execute on CPU  may include, for example, an operating system, a word processor application, an email application, a spread sheet application, a media player application, a video game application, a graphical user interface application or another program. The user may provide input to computing device  via one or more input devices (not shown) such as a keyboard, a mouse, a microphone, a touch pad or another input device that is coupled to computing device  via user interface .","The software applications that execute on CPU  may include one or more graphics rendering instructions that instruct GPU  to cause the rendering of graphics data to display . In some examples, the software instructions may conform to a graphics application programming interface (API), such as, e.g., an Open Graphics Library (OpenGL\u00ae) API, an Open Graphics Library Embedded Systems (OpenGL ES) API, a Direct3D API, a DirectX API, a RenderMan API, a WebGL API, or any other public or proprietary standard graphics API. In order to process the graphics rendering instructions, CPU  may issue one or more graphics rendering commands to GPU  to cause GPU  to perform some or all of the rendering of the graphics data. In some examples, the graphics data to be rendered may include a list of graphics primitives, e.g., points, lines, triangles, quadralaterals, triangle strips, patches, etc. In further examples, the graphics data to be rendered may include one or more path rendering primitives, such as, e.g., a line segment, an elliptic arc, a quadratic B\u00e9zier curve, and a cubic B\u00e9zier curve.","The present disclosure provides for systems and method of for path rendering including drawing a path segment, filling the path segment, including (1) tessellating the path into line segments, (2) rasterizing and scan-filling using a cell buffer, and (3) drawing a bounding box of the path using a fill color and a stencil from the cell buffer; and stroking the path segment, including (1) tessellating the path into line segments, (2) cutting the line segments according to a dash pattern, and (3) creating a triangulation of a stroke and rasterize the stroke. In some examples, one or more of these functions may be performed by GPU . For example, in various implementations none of these are performed in the CPU.","Memory controller  facilitates the transfer of data going into and out of memory . For example, memory controller  may receive memory read requests and memory write requests from CPU  and\/or GPU , and service such requests with respect to memory  in order to provide memory services for the components in computing device . Memory controller  is communicatively coupled to memory . Although memory controller  is illustrated in the example computing device  of  as being a processing module that is separate from both CPU  and memory , in other examples, some or all of the functionality of memory controller  may be implemented on one or more of CPU , GPU , and memory .","Memory  may store program modules and\/or instructions that are accessible for execution by CPU  and\/or data for use by the programs executing on CPU . For example, memory  may store user applications and graphics data associated with the applications. Memory  may also store information for use by and\/or generated by other components of computing device . For example, memory  may act as a device memory for GPU  and may store data to be operated on by GPU  as well as data resulting from operations performed by GPU . For example, memory  may store any combination of path data, path segment data, surfaces, texture buffers, depth buffers, cell buffers, vertex buffers, frame buffers, or the like. In addition, memory  may store command streams for processing by GPU . For example, memory  may store path rendering commands, 3D graphics rendering commands, and\/or general-purpose GPU computing commands. Memory  may include one or more volatile or non-volatile memories or storage devices, such as, for example, random access memory (RAM), static RAM (SRAM), dynamic RAM (DRAM), synchronous dynamic random access memory (SDRAM), read-only memory (ROM), erasable programmable ROM (EPROM), electrically erasable programmable ROM (EEPROM), Flash memory, a magnetic data media or an optical storage media.","GPU  may be configured to execute commands that are issued to GPU  by CPU . The commands executed by GPU  may include graphics commands, draw call commands, GPU state programming commands, memory transfer commands, general-purpose computing commands, kernel execution commands, etc. The memory transfer commands may include, e.g., memory copy commands, memory compositing commands, and block transfer (blitting) commands.","In some examples, GPU  may be configured to perform graphics operations to render one or more graphics primitives to display . In such examples, when one of the software applications executing on CPU  requires graphics processing, CPU  may provide graphics data to GPU  for rendering to display  and issue one or more graphics commands to GPU . The graphics commands may include, e.g., draw call commands, GPU state programming commands, memory transfer commands, blitting commands, etc. The graphics data may include vertex buffers, texture data, surface data, etc. In some examples, CPU  may provide the commands and graphics data to GPU  by writing the commands and graphics data to memory , which may be accessed by GPU .","In further examples, GPU  may be configured to perform general-purpose computing for applications executing on CPU . In such examples, when one of the software applications executing on CPU  decides to off-load a computational task to GPU , CPU  may provide general-purpose computing data to GPU , and issue one or more general-purpose computing commands to GPU . The general-purpose computing commands may include, e.g., kernel execution commands, memory transfer commands, etc. In some examples, CPU  may provide the commands and general-purpose computing data to GPU  by writing the commands and graphics data to memory , which may be accessed by GPU .","GPU  may, in some instances, be built with a highly-parallel structure that provides more efficient processing of vector operations than CPU . For example, GPU  may include a plurality of processing elements that are configured to operate on multiple vertices, control points, pixels and\/or other data in a parallel manner. The highly parallel nature of GPU  may, in some instances, allow GPU  to render graphics images (e.g., GUIs and two-dimensional (2D) and\/or three-dimensional (3D) graphics scenes) onto display  more quickly than rendering the images using CPU . In addition, the highly parallel nature of GPU  may allow GPU  to process certain types of vector and matrix operations for general-purposed computing applications more quickly than CPU .","GPU  may, in some examples, be integrated into a motherboard of computing device . In other instances, GPU  may be present on a graphics card that is installed in a port in the motherboard of computing device  or may be otherwise incorporated within a peripheral device configured to interoperate with computing device . In further instances, GPU  may be located on the same microchip as CPU  forming a system on a chip (SoC). GPU  may include one or more processors, such as one or more microprocessors, application specific integrated circuits (ASICs), field programmable gate arrays (FPGAs), digital signal processors (DSPs), or other equivalent integrated or discrete logic circuitry.","In some examples, GPU  may be directly coupled to GPU cache . Thus, GPU  may read data from and write data to GPU cache  without necessarily using bus . In other words, GPU  may process data locally using a local storage, instead of off-chip memory. This allows GPU  to operate in a more efficient manner by eliminating the need of GPU  to read and write data via bus , which may experience heavy bus traffic. In some instances, however, GPU  may not include a separate cache, but instead utilize memory  via bus . GPU cache  may include one or more volatile or non-volatile memories or storage devices, such as, e.g., random access memory (RAM), static RAM (SRAM), dynamic RAM (DRAM), erasable programmable ROM (EPROM), electrically erasable programmable ROM (EEPROM), Flash memory, a magnetic data media or an optical storage media.","CPU  and\/or GPU  may store rendered image data in a frame buffer that is allocated within memory . The rendered image data may include rendered fill areas and stroke areas for a path segment to be rendered. Display interface  may retrieve the data from the frame buffer and configure display  to display the image represented by the rendered image data. In some examples, display interface  may include a digital-to-analog converter (DAC) that is configured to convert the digital values retrieved from the frame buffer into an analog signal consumable by display . In other examples, display interface  may pass the digital values directly to display  for processing.","Display  may include a monitor, a television, a projection device, a liquid crystal display (LCD), a plasma display panel, a light emitting diode (LED) array, a cathode ray tube (CRT) display, electronic paper, a surface-conduction electron-emitted display (SED), a laser television display, a nanocrystal display or another type of display unit. Display  may be integrated within computing device . For instance, display  may be a screen of a mobile telephone handset or a tablet computer. Alternatively, display  may be a stand-alone device coupled to computer device  via a wired or wireless communications link. For instance, display  may be a computer monitor or flat panel display connected to a personal computer via a cable or wireless link.","Bus  may be implemented using any combination of bus structures and bus protocols including first, second and third generation bus structures and protocols, shared bus structures and protocols, point-to-point bus structures and protocols, unidirectional bus structures and protocols, and bidirectional bus structures and protocols. Examples of different bus structures and protocols that may be used to implement bus  include, e.g., a HyperTransport bus, an InfiniBand bus, an Advanced Graphics Port bus, a Peripheral Component Interconnect (PCI) bus, a PCI Express bus, an Advanced Microcontroller Bus Architecture (AMBA) Advanced High-performance Bus (AHB), an AMBA Advanced Peripheral Bus (APB), and an AMBA Advanced eXentisible Interface (AXI) bus. Other types of bus structures and protocols may also be used.","According to this disclosure, GPU  may be configured to provide partial-to-total GPU-hardware acceleration for the execution of various path rendering commands. For example, CPU  may issue one or more path rendering commands to GPU , and GPU  may execute the path rendering commands. As one example, CPU  may issue to GPU  one or more path filling commands that instruct GPU  to perform a path filling operation, and GPU  may execute the path filling commands. As another example, CPU  may issue to GPU  one or more path stroking commands that instruct GPU  to perform a path stroking operation, and GPU  may execute the path stroking commands.","In some examples, GPU  may be configured to receive data indicative of a path segment of a path to be rendered, tessellate the path segment into a plurality of primitives, and render at least one of a fill area and a stroke area for the path segment based on the plurality of primitives. The GPU may render a fill area for the path segment when performing a fill operation, and may render a stroke area for the path segment when performing a stroke operation. The plurality of primitives, in some examples, may be a plurality of line segments.","In some examples, GPU  may use a two-pass rendering approach to perform a path filling operation. For example, as part of a first rendering pass, GPU  may receive data indicative of a path segment of a path to be rendered, tessellate the path segment into a plurality of line segments, and generate a plurality of triangle primitives based on the plurality of lines segments. GPU  may generate each of the plurality of triangle primitives based on a respective one of the plurality of line segments. GPU  may render each of the plurality of triangle primitives into a cell buffer such that the cell buffer stores data indicative of which pixels are inside of the fill area for the path segment. After rendering the primitives into the common cell buffer, GPU  may perform a second rendering pass. During the second rendering pass, GPU  may render one or more primitives that encompass the pixels that are inside the fill area for the path segment based on the data stored in the cell buffer and a fill color to generate a rasterized version of the fill area for the path segment. In this manner, GPU  may provide GPU-hardware acceleration for the performance of path filling operations.","To generate the plurality of triangle primitives, GPU  may, in some examples, generate the plurality of triangle primitives such that each of the triangle primitives has a common vertex that is common to (i.e., the same for) all of the triangle primitives for a path segment. In such examples, GPU  may generate the plurality of triangle primitives such that each of the triangle primitives has two additional vertices (i.e., two vertices in addition to the common vertex) that correspond to the endpoints of a respective one of the plurality of line segments. Each additional vertex may correspond to a respective one of the endpoints of a corresponding line segment.","To render each of the plurality of triangle primitives into a cell buffer, GPU  may use one of the following techniques. According to a first technique, GPU  may, for each of the plurality of triangle primitives, invert one or more values in stencil buffer  that correspond to the respective triangle primitive. According to a second technique, GPU  may, for each of the plurality of triangle primitives, increment one or more values in stencil buffer  that correspond to the respective triangle primitive if a vertex order for the respective triangle primitive is oriented in a clockwise direction.","In some cases, GPU  may be configured to use one or both of the following techniques to perform the path filling operation. According to a first technique, GPU  may tessellate the path segment into a plurality of line segments using a fixed-function tessellation engine of GPU  and a domain shader program executing on a programmable shader unit of GPU . According to as second technique, GPU  may generate the plurality of triangle primitives using a geometry shader program executing on a programmable shader unit of GPU . Using one or more of the tessellation engine, domain shader , and the geometry shader of GPU  to perform the path filling operation may allow the path filling operation to be performed, in some examples, using a GPU that is compliant with an on-chip, tessellation-enabled, 3D graphics API (e.g., the DX 11 API), without requiring modification of the API or modification of the graphics architecture specified by the API.","In further examples, GPU  may use a single-pass rendering approach to perform a path stroking operation. For example, GPU  may receive data indicative of a path segment of a path to be rendered, tessellate the path segment into a plurality of line segments, and generate a plurality of triangle primitives based on the plurality of lines segments. For each of the plurality of line segments, GPU  may generate one or more primitives (e.g., triangle primitives) that spatially correspond to a stroke area for the respective line segment, and render the one or more primitives for the respective line segment based on a stroke color to generate a rasterized version of the stroke area for the path segment. In this manner, GPU  may provide GPU-hardware acceleration for the performance of path stroking operations.","To generate one or more primitives (e.g., triangle primitives) that spatially correspond to a stroke area for the respective line segment, GPU  may, in some examples, generate a plurality of normal vertices for the respective line segment. Each of the normal vertices may be indicative of a normal vector that corresponds to a respective one of a plurality of points along the path segment. Each of the plurality of points along the path segment may correspond to a respective one of the endpoints of the respective line segment. GPU  may determine corner points of a stroke area for the respective line segment based on the plurality of normal vertices and a stroke width. GPU  may generate the one or more primitives that spatially correspond to the stroke area for the respective line segment based on the corner points of the stroke area.","In some cases, GPU  may use one or more of the following techniques to perform the path stroking operation. According to a first technique, GPU  may tessellate the path segment into a plurality of line segments using a fixed-function tessellation engine of GPU  and a domain shader program executing on a programmable shader unit of GPU . According to as second technique, GPU  may generate the one or more primitives using a geometry shader program executing on a programmable shader unit of GPU . According to a third technique, GPU  may generate the plurality of normal vertices using a domain shader program executing on a programmable shader unit of GPU . Using one or more of the tessellation engine, domain shader , and the geometry shader of GPU  to perform the path stroking operation may allow the path stroking operation to be performed, in some examples, using a GPU that is compliant with an on-chip, tessellation-enabled, 3D graphics API, such as, e.g., the DX 11 API, without requiring modification of the API or modification of the graphics architecture specified by the API.","The path rendering techniques described in this disclosure may be implemented in any of the components in computing device  illustrated in  including, e.g., CPU , GPU , and memory . In some examples, all or almost all of the path rendering techniques may be implemented in GPU  (e.g., in a graphics pipeline of GPU ). In additional examples, CPU  may implement techniques for configuring the state of the graphics pipeline and binding shader programs to the graphics pipeline to implement a path rendering pipeline in GPU  that performs the path rendering techniques of this disclosure. In further examples, CPU  may be configured to place data indicative of a path to be rendered into one or more buffers (e.g., one or more vertex buffers) that may be accessed by GPU  to render one or more paths.","In some examples, GPU  may be configured for (1) tessellating the path into line segments, (2) rasterizing and scan-filling using a cell buffer, and (3) drawing a bounding box of the path using a fill color and a stencil from the cell buffer; and stroking the path segment, including (1) tessellating the path into line segments, (2) cutting the line segments according to a dash pattern, and (3) creating a triangulation of a stroke and rasterize the stroke.","In some examples, a relatively large amount of data may need to be transferred to a graphics processing unit (GPU) to render the path segment at a desired level of detail. The relatively large amount of data may consume a significant amount of memory storage space when storing the data, and may consume a significant amount of memory bandwidth when transferring the data to the GPU.",{"@attributes":{"id":"p-0092","num":"0091"},"figref":["FIG. 2","FIG. 1","FIG. 2"],"b":["6","12","10","2","6","12","10","12","6","10","12","6","12","6","12","6","12","6"]},"CPU  is configured to execute software application , a graphics API , a GPU driver  and an operating system . Software application  may include one or more instructions that cause graphics images to be displayed and\/or one or more instructions that cause a non-graphics task (e.g., a general-purposed computing task) to be performed on GPU . Software application  may issue instructions to graphics API . Graphics API  may be a runtime service that translates the instructions received from software application  into a format that is consumable by GPU driver . GPU driver  receives the instructions from software application , via graphics API , and controls the operation of GPU  to service the instructions. For example, GPU driver  may formulate one or more commands , place the commands  into memory , and instruct GPU  to execute the commands . In some examples, GPU driver  may place the commands  into memory  and communicate with GPU  via operating system , e.g., via one or more system calls.","GPU  includes a command engine  and one or more processing units . In some examples, the one or more processing units  may form and\/or implement a 3D graphics rendering pipeline, e.g., a DX 11 graphics rendering pipeline (i.e., a 3D graphics pipeline that is compliant with the DX 11 graphics API. In one example in accordance with this disclosure may include a new primitive types supported in the GPU (line, quadratic\/cubic Bezier, elliptic arc). Different types of primitives should be able to be packed into the same vertex buffer, hence rendering them all in a single draw call. Dash pattern may be used as-is, new tessellator logic may be used to handle preprocessing the dash pattern. Having new primitive types and being able to pack different types of primitives into a single draw call will decrease the GPU input size, and significantly increase the performance because of vertex reuse. Creating joins\/caps at IA stage may require some hardware modifications. The resulting join primitives may be use many indices due to potential repeated knots. This may also require primitive type as a system generated value available in different shader stages.","Command engine  is configured to receive commands from CPU  (e.g., via memory ) and to cause GPU  to execute the commands. In response to receiving a state command, command engine  may be configured to set one or more state registers in GPU to particular values based on the state command, and\/or to configure one or more of the fixed-function processing units  based on the state command. In response to receiving a draw call command, command engine  may be configured to cause processing units  to render the geometry represented by vertices  in memory  based on data indicative of the type of path to be rendered, which may be contained in the vertex data structures of the vertex buffers to be rendered. Command engine  may also receive shader program binding commands, and load particular shader programs into one or more of the programmable processing units  based on the shader program binding commands.","Processing units  may include one or more processing units, each of which may be a programmable processing unit or a fixed-function processing unit. A programmable processing unit may include, for example, a programmable shader unit that is configured to execute one or more shader programs that are downloaded onto GPU  from CPU . A shader program, in some examples, may be a compiled version of a program written in a high-level shading language, such as, e.g., an OpenGL Shading Language (GLSL), a High Level Shading Language (HLSL), a C for Graphics (Cg) shading language, etc. In some examples, a programmable shader unit may include a plurality of processing units that are configured to operate in parallel, e.g., an SIMD pipeline. A programmable shader unit may have a program memory that stores shader program instructions and an execution state register, e.g., a program counter register that indicates the current instruction in the program memory being executed or the next instruction to be fetched. The programmable shader units in processing units  may include, for example, vertex shader units, pixel shader units, geometry shader units, hull shader units, domain shader units, compute shader units, and\/or unified shader units.","A fixed-function processing unit may include hardware that is hard-wired to perform certain functions. Although the fixed function hardware may be configurable, via one or more control signals for example, to perform different functions, the fixed function hardware typically does not include a program memory that is capable of receiving user-compiled programs. In some examples, the fixed function processing units in processing units  may include, for example, processing units that perform raster operations, such as, e.g., depth testing, scissors testing, alpha blending, etc.","In some examples, a stencil buffer  may be added to GPU  implementing, for example, the DirectX11 architecture In an example, output merger stage  may be configured to populate stencil buffer  such that stencil buffer  stores values which are indicative of a fill area for the path segment according to one or more stencil buffer filling techniques.","In other examples, a cell buffer that contains x*y cells may be used. A cell buffer may be added to GPU  implementing, for example, the DirectX11 architecture. Cell buffer may be a sixteen by sixteen grid of sub-pixels, e.g., x=y=16. One cell may represent one pixel in the final image, but cell name may be used to distinguish the cells and pixels as they store different information. In the example, each cell in cell buffer stores sixteen bytes of winding counter information. Cell buffer may be the size of the frame buffer, but normally the memory requirements of cell buffer would become too big. So the frame buffer may be split in to tiles of x*y pixels (and cells). This allows the drawing of the primitive one tile at a time.","Memory  may store path data  and one or more commands . In some examples, path data  may be stored as a plurality of vertices (or control points) in one or more vertex buffers allocated in memory . In some examples, the path data may be stored in a patch list data structure (e.g., a four control point patch list). Commands  may be stored in one or more command buffers (e.g., a ring buffer). CPU  (e.g., GPU driver  via operating system ) may place path data  and commands  into memory  for consumption by GPU . GPU  (e.g., command engine ) may retrieve and execute commands  stored in memory .","In examples where path data  is stored as vertices, the vertices may include one or more attributes that geometrically define a path to be rendered. For example, for a line, the vertices in the patch control list may include data indicative of coordinates for the endpoints of the line (e.g., (x0, y0) and (x1, y1)). For a cubic B\u00e9zier curve, the vertices in the patch control list may include data indicative of the coordinates of the four control points that define the curve (e.g., (x0, y0), (x1, y1), (x2, y2), (x3, y3)). For a quadratic B\u00e9zier curve, the vertices in the patch control list may include data indicative of coordinates for three control points instead of four control points. For elliptic arcs, the vertices in the patch control list may include data indicative of an endpoint parameterization of the elliptic arc or data indicative of a center parameterization of the elliptic arc.","CPU  may also place data indicative of the type of path to be rendered (i.e., \u201cpath type data\u201d) into one or more otherwise unused vertex coordinates in the vertex buffer. In some examples, the different path types may correspond to a set of path types that are defined by a vector graphics API and are available for use by software application . In some examples, the different path types may correspond to a set of path types that are defined by the OpenVG API.","In some cases, the one or more attributes that geometrically define the path to be rendered may be resolution-independent. In other words, the attributes that geometrically define the path may be independent of the amount of tessellation to be performed to render the path segment and\/or the amount of vertices to be generated to render the path segment.","Commands  may include one or more state commands and\/or one or more draw call commands. A state command may instruct GPU  to change one or more of the state variables in GPU , such as, e.g., the draw color, the fill color, the stroke color, etc. In some examples, the state commands may include path rendering state commands that are configured to set one or more state variables associated with rendering a path. For example, the state commands may include a paint mode command that is configured to indicate whether a path to be rendered is to be filled, stroked, or both. As another example, the state commands may include a fill color command that specifies a color to be used for filling operations and\/or a stroke color command that specifies a color to be used for stroking operations. As a further example, the state commands may specify one or more parameters for the stroke operation, such as, e.g., a stroke width, an end cap style (e.g., butt, round, square), a line join style (e.g., miter, round, bevel), a miter limit, etc. In some examples, in addition to or in lieu of using a state command to set one or more state parameters, the one or more of the state parameters may be set using one or more parameter values in a draw call command.","A draw call command may instruct GPU  to render the geometry defined by a group of one or more vertices (e.g., defined in a vertex buffer) stored in memory . In some examples, the draw call command may invoke GPU  to render all of the vertices  stored in a defined section (e.g., buffer) of memory . In other words, once GPU  receives the draw call command, control is passed to GPU  for rendering the geometry and primitives represented by the vertices in the defined section (e.g., buffer) of memory .","The draw call commands may include one or both of 3D draw call commands and path rendering draw call commands. For 3D rendering draw call commands, the geometry defined by the group of one or more vertices in the vertex buffer may correspond to one or more 3D graphics primitives to be rendered (e.g., points, lines, triangles, quadralaterals, triangle strips, patches, etc), and the 3D rendering draw call command may instruct GPU  to render the one or more 3D graphics primitives. For path rendering draw call commands, the geometry defined by the group of one or more vertices in the vertex buffer may correspond to one or more path primitives to be rendered (e.g., a line segment, an elliptic arc, a quadratic B\u00e9zier curve, and a cubic B\u00e9zier curve, etc), and the path rendering draw call command may instruct GPU  to render the one or more path primitives.","In some examples, the path rendering techniques described in this disclosure may be implemented in any of the components illustrated in  including, e.g., graphics API , GPU driver , command engine  and processing units . In some examples, all or almost all of the path rendering techniques may be implemented in a graphics pipeline in GPU  formed by processing units . In additional examples, software application , graphics API  and\/or GPU driver  of CPU  may implement techniques for configuring the state of the graphics pipeline and binding shader programs to the graphics pipeline to implement a path rendering pipeline in GPU  that performs the path rendering techniques of this disclosure. In further examples, software application , graphics API  and\/or GPU driver  of CPU  may be configured to place data indicative of a path to be rendered into one or more buffers (e.g., one or more vertex buffers) that may be accessed by GPU  to render one or more paths. In some examples, GPU  may be configured for (1) tessellating the path into line segments, (2) rasterizing and scan-filling using a cell buffer, and (3) drawing a bounding box of the path using a fill color and a stencil from the cell buffer.",{"@attributes":{"id":"p-0108","num":"0107"},"figref":["FIG. 3","FIG. 3"],"b":["42","44","46","48","50","52","54","56","58","60","48","50","52","62"]},"As illustrated in , many of the pipeline stages may also be communicatively coupled to resources block. The resources block may include memory resources such as buffers and textures. The remaining blocks indicate pipeline stages. The blocks with straight corners represent fixed-function pipeline stages, and the blocks with rounded corners represent programmable stages. Each of the programmable stages may be configured to execute a shader program of a particular type. For example, vertex shader  may be configured to execute a vertex shader program, hull shader  may be configured to execute a hull shader program, etc. Each of the different types of shader programs may execute either on a common shader unit of the GPU or on one or more dedicated shader units that are dedicated to executing shader programs of one or more particular types. Hull shader  stage, tessellator , and domain shader  stage may be collectively referred to as tessellation stages .","Additional background information regarding the general operation of the DirectX 11 graphics pipeline may be found at http:\/\/msdn.microsoft.com\/en-us\/library\/windows\/desktop\/ff476882%28v=vs.85%29.aspx, as of Nov. 26, 2012, and is hereby incorporated by reference. Further information regarding the general operation of the DirectX 11 graphics pipeline may be found in Zink et al., \u201cPractical Rendering & Computation with Direct3D 11,\u201d CRC Press (2011), the entire contents of which is incorporated herein by reference.","As illustrated in , in some examples, hull shader  converts elliptical arcs from an endpoint representation to a parametrical representation. The input assembly (IA) stage creates endcaps and joins. IA may create join primitives where two path segments meet. IA may also create starting and ending caps for open paths. An open path is a path that does not enclose a region. To successfully create a join, the join position and tangents of two path segments at the join position may be used. For a cap, the position and tangents at the first and last points of the path may be used. Tangents of path segments may be found by simply subtracting control points, however, in case of repeated control points, all control points may be processed to determine an endpoint tangent. In an example, IA may have to put both path segments' vertices into a join primitive. The worst case scenario may be where two cubic curves meet, each having 4 vertices (control points), 1 shared, so total of 7 vertices required for a join primitive from IA.","As discussed above, the two main path rendering operations are: (1) filling a path segment; and (2) stroking a path segment. Solutions for performing each of these operations with a graphics rendering pipeline (e.g., the DirectX 11 graphics pipeline) will now be described.","In an example, the path segment comprises a line and stroking comprises widening the line by thickening the line in two directions perpendicular to the line. Alternatively, the path segment comprises a curve and stroking further may include splitting the curve into line segments, determining a stroke width, and creating a pair of triangle strips positioned to widen at least one of the line segments.","An example system of this disclosure provides an approximately 100% GPU solution for path rendering. Using the current GPU architecture, (e.g., an architecture operating in accordance with DirectX11) this may be inefficient. Using a modified GPU architecture may provide for an efficient GPU solution for path rendering.","As used herein, a \u201cpath\u201d comprises a number of path segments, which may be, for example, a line, an elliptic arc, a quadratic B\u00e9zier, or a cubic B\u00e9zier curve. A B\u00e9zier curve is a type of parametric curve that can be scaled indefinitely. Additionally, a path may or may not be \u201cclosed.\u201d A closed path is one in which the last vertex of the path is connected to the first vertex of the path via a line and forms a closed shape. A path can overlap itself numerous times.","Path rendering can be divided into two main tasks, (1) filling and (2) stroking. In some examples, these tasks may be handled separately. Filling a path is defined as filling the interior region of a given path by the fill color. Stroking a path comprises \u201cwidening\u201d the edges of the path using a straight-line pen held perpendicularly to the path.","When filling a path, the interior region of a given path may be filled by a color. The interior region of a path may be defined using either of the odd-even or non-zero fill rules. The odd-even rule is an algorithm implemented in vector-based graphics software which determines how a graphical shape with more than one closed outline will be filled. The odd-even rule determines the \u201cinsideness\u201d of a point by drawing a ray from the point to infinity in any direction and counting the number of path segments from the given shape that the ray crosses. If this number is odd, the point is considered inside the curve and will be filled; if even, the point is considered outside the curve and will not be filled. Accordingly, an area inside a curve is an area that will be filled to form a shape and an area outside a curve is an area that will not be filled to form a shape (at least not for that particular shape). In two-dimensional computer graphics, the non-zero winding rule is a means of determining whether a given point falls within an enclosed curve.","Some examples may use pre-processing, while other examples may include no pre-processing. Centroid pivot point in pre-processing may give us a slight increase in filling performance over first vertex pivot point. Determining bounding box in the GPU may require some hardware modifications. Converting elliptic arcs to parametrical form in hull shader  will result in the conversion being done at every frame. An elliptic arc will need to go through hull shader conversion up to three times in a frame (arc itself, and two joins\/caps at arc endpoints).","Vertices may define a path consisting of a line segment, a cubic segment, another line segment and a quadratic segment. It may be a closed path (i.e. encloses a region). Some examples may make the following API draw call: (1) drawNonIndexedPrimType(numIndices=7, closed=true), (2) primitive types will be the following list: [line, cubic, line, quadratic], (3) IA will start generating primitives based on the primitive types. Since this is a closed path, there are no caps.","In an example, the output may be as follows: (1) PrimType, Indices; (2) line 0, 1; (3) Join_Line_Cubic 0, 1, 2, 3, 4; (4) Cubic 1, 2, 3, 4; (5) Join_Cubic_Line 1, 2, 3, 4, 5; (6) Line 4, 5; (7) Join_Line_Quadratic 4, 5, 6, 0; (8) Quadratic 5, 6, 0; (9) Join_Quadratic_Line 5, 6, 0, 1. Since we have 4 different types of path segments (line, quadratic, cubic, elliptic), we have 4 different cap types and 4\u00d74=16 different join primitive types.","In an example, filling a path means filling the interior region of a given path by a given fill color. The interior region may be defined using either of the even\/odd or non-zero fill rules. One example algorithm to handle filling a path is as follows: (1) tessellate a given path into line segments, (2) create a triangle per line segment using Geometry Shader  by connecting the pivot point to line segments while honoring winding order. The clockwise or counterclockwise triangles are then rendered to stencil buffer . For Even\/Odd filling, every triangle, regardless of winding order, will flip the stencil value of the interior region. For Non Zero filling, clockwise triangles will increase and counterclockwise triangles will decrease the stencil value of the interior region. For both rules, outer region remain unaffected. (3) pass 2: render the bounding box area with stencil test enabled. Stencil pass condition is stencil value>0, regardless of the fill rule. Passing stencil values are then reset to zero (pass operation), hence leaving us with a fresh stencil buffer  of all zeros.","One example of filling may include the following flow: (1) load constant buffer with fill color and pivot point per path, (2) set appropriate stencil state (even-odd or non-zero), and (3) pass one draw call [4 Control Point Patch]. Passing one draw call may include using vertex shader  to transform vertices, using hull shader  [Domain: Isoline, Output Type: Line] to determine optimum tessellation level, or use fixed level tessellation, using domain shader  to compute tessellated vertices (position only), and using geometry shader  to connect the input lines to the pivot point coordinates from the constant buffer to create clockwise and counterclockwise triangles. In some examples, the pixel shader may be null.","An example may include a set to cover the stencil state. A second pass draw call may use a vertex shader  to bypass the output from the vertex shader (VS) . In this instance, the output from the VS  is same as the input, no operation is being done in the VS . The pixel shader may return fill color from the constant buffer. Additionally, vertex shader (VS)  may transform vertices using world, view and projection matrices. Hull shader (HS)  may determine tessellation level by using joins and caps, collapsed cubics and degenerate ellipses with 0.0f (Drop) and lines: 1.0f Note that a tessellation level of 0 indicates that primitive is dropped. For example, in some cases some caps\/joins may be dropped. For line primitives, tessellation level=1 may be used. A line does not need to tessellated into a plurality of new lines.","In an example, the HS  performs a transform. For arcs, part of the vertex information are ellipse parameters to which it may be advantageous to avoid appling a transformation matrix. Some examples may calculate optimum tessellation level for cubics and elliptic arcs, or use fixed tessellation.","In some examples, the tessellation engine may be a Dx11 tessellator unit, with isoline domain, integer partitioning, line output. In an example, domain shader  [v may be ignored]. Domain shader  may evaluate tessellated vertices' locations for lines, cubics and elliptic arcs. For lines u is either 0.0f or 1.0f. In an example, the tessellator may output two domain-coordinates u and v. In some examples, coordinate v may be ignored and coordinate u may be used to tessellate our primitive. The coordinate u is the parametrization from 0.0 to 1.0. If the tessellation factor is n, u will be 0\/n, 1\/n, 2\/n . . . n\/n.","Endpoints may be outputted directly. For curves u will range from 0.0f to 1.0f, in equal increments depending on the tessellation level. For all u's, position will be found using the curve representation equation. For elliptic arcs u will range from 0.0f to 1.0f, in equal increments depending on the tessellation level. For all u's, positions will be found using the arc parametric representation. In an example, geometry shader  connects the input lines to the pivot point coordinates from the constant buffer to create triangles. Winding order will determine whether to increase or decrease stencil value for triangle coverage, in non-zero fill mode. In odd-even fill mode, triangle coverage will flip stencil values, regardless of the triangle winding. In an example, vertex shader  may be bypassed and the pixel shader may return fill color. One example 2-pass flow for filling is:\n\n","If Target Independent Rendering (TIR) can be used to resolve stencil buffer  directly to the frame buffer, the need for the extra bypass vertex shader  may be eliminated. The bounding box calculation may no longer be needed at the pre-process stage. Additionally, an extra stencil state for the \u201ccover\u201d pass may not be needed because there will be no \u201ccover\u201d pass. In some examples this may increase filling performance. An example flow is as follows:\n\n","Stroking of a path may include \u201cwidening\u201d the edges of the path along a straight-line perpendicularly to the path. Some examples tessellate and evaluate the path, at each evaluated point we widen the point according to the normal at that point and create triangulation to form segments. The union of all segments is the stroke line.","An example algorithm for stroking a path is as follows, (1) tessellate the path into line segments with normal at endpoints, (2) if re-tessellation is enabled, re-tessellate the line segments where endpoint normals deviate too much in direction to create new line segments, (3) if dashing is enabled, cut line segments according to the dash pattern, (4) create caps at cut locations, tessellate round joins and caps, (5) create triangulation to represent stroke lines, caps and joins, (5) render triangles with depth test enabled.","An example flow is as follows (1) update constant buffer with stroke color, stroke width, miter limit, join rule, cap rule, dash pattern, inverse of round tessellation factor (may be constant), (2) enable depth testing, (3) first pass, (4) second pass. The first pass may be a draw call to vertex shader  to transform vertices, to hull shader  to convert collapsed cubics and degenerate ellipses to lines (no pre-processing) and determine optimum tessellation level, or use fixed level tessellation. In first pass domain shader  may determine tessellated vertices' locations and determine tessellated vertices' normals (converted to angle representation). Geometry shader  may stream out lines for second rendering pass. The pixel shader may not be used in some examples.","The second pass may be a draw call bypassing the using vertex shader  and using hull shader  to compute tessellator inputs for tessellation delta, segment length, inverse of length, and SV_PrimType. An example may use a modified tessellator to tessellate joins, cut\/re-tessellate line segments, and create cap tessellations at cut locations. Domain shader , (SV_PrimType) may linear interpolate position and normal from original line segment\/join and convert normal from angular form to coordinates. Geometry shader  may increase the width of line segments, create triangles for joins\/caps. The pixel shader may return stroke color.","In an example, after the cell buffer contents are determined, if the filling rule is non-zero, take the absolute value of the contents and clamp every value to sample count. For odd-even filling, take the (2*sample count) modular of every value, and if a value is greater than the sample count, set it to be the distance from 2*sample count. This is illustrated in the code excerpt below:",{"@attributes":{"id":"p-0133","num":"0135"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"for (int y=0; y<CELLBUFFER_SIZE; y++)"},{"entry":"{"},{"entry":"int total = 0;\u2003for (int x=0; x<CELLBUFFER_SIZE; x++)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"total += frame[y*CELLBUFFER_SIZE+x];"]},{"entry":[{},"if (fillMode == \u2018F\u2019) \/\/ Non Zero"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"frame[y*CELLBUFFER_SIZE+x] = min("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"SAMPLE_COUNT, abs(total) );"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"else \/\/ if (fillMode == \u2018E\u2019) \/\/ Even odd"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"assert (fillMode == \u2018E\u2019);"]},{"entry":[{},"int value = abs(total) % (2*SAMPLE_COUNT);"]},{"entry":[{},"if (value > SAMPLE_COUNT)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"value = 2*SAMPLE_COUNT \u2212 value;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"frame[y*CELLBUFFER_SIZE+x] = value;","}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Unlike the similar odd-even rule, the non-zero winding rule relies on determining the direction of stroke for each part of the curve. For a given curve C and a given point P, the non-zero winding rule is determined as follows: (1) construct a straight line out from P in any direction towards infinity, (2) find all the intersections of C with this ray, and (3) score up the winding number. Scoring the winding number includes: (1) for every clockwise intersection (the curve passing through the ray from left to right, as viewed from P) subtract 1; (2) for every counter-clockwise intersection (curve passing from right to left, as viewed from P) add 1. If the total winding number is zero, P is outside C; otherwise, it is inside.","A simple, non-self-intersecting closed path divides the plane into two regions, a bounded inside region and an unbounded outside region. Note that knowing the orientation of the outermost path (i.e., clockwise or counter-clockwise) is not necessary to differentiate between the inside and outside regions.","A path that self-intersects, or that has multiple overlapping subpaths, requires additional information in order to define the inside region. Two rules that provide different definitions for the area enclosed by such paths, known as the non-zero and even\/odd fill-rules, are supported by OpenVG. To determine whether any point in the plane is contained in the inside region, imagine drawing a line from that point out to infinity in any direction such that the line does not cross any vertex of the path. For each edge that is crossed by the line, add 1 to the counter if the edge crosses from left to right, as seen by an observer walking along the line towards infinity, and subtract 1 if the edge crosses from right to left. In this way, each region of the plane will receive an integer value.","The non-zero fill rule says that the point is inside the shape if the resulting sum is not equal to 0. The even\/odd rule says that the point is inside the shape if the resulting sum is odd, regardless of sign (e.g., \u22127 is odd, 0 is even). Consider the star-shaped path shown in  below, indicated with solid lines. The orientation of the lines making up the path is indicated with arrows. An imaginary line to infinity starting in the central region of the star is shown as a dashed line pointing to the right. Two edges of the star cross the line to infinity going left to right, indicated by the downward-pointing arrows. The central region therefore has a count of +2. According to the even\/odd rule, it is outside the path, whereas according to the non-zero rule it is inside. Implementations must be able to deal with paths having up to 255 crossings along any line. The behavior of more complex paths is undefined.","In one example, the algorithm for filling a path is as follows:","1. Tessellate the path into line segments","2. Rasterize and scan-fill using the cell buffer","3. Draw the bounding box of the path using fill color and the stencil from the cell buffer","In an example of cell buffer rasterization, after the line segments are produced in domain shader , they are sent to the cell buffer. Stroking a path comprises \u201cwidening\u201d the edges of the path using a straight-line \u201cpen\u201d held perpendicularly to the path. The path may then be tessellated and evaluated. At each evaluation point, the point may be widened according to the normal at that point. Triangulation may be used to form segments as discussed below with respect to . The union of all segments is the stroke line.","In one example, the algorithm for stroking a path is as follows:","1. Tessellate the path into line segments","2. Cut the line segments according to the dash pattern","3. Create the triangulation of the stroke and rasterize it","To implement these methods in, for example, a DirectX11 pipeline architecture, or other similar 3D graphics pipelines, may be modified according to the techniques of this disclosure to include a number of extensions. For example, the DirectX11 pipeline may be modified to include a path primitive. The path primitive may allow the DirectX11 pipeline to process vector graphics by allowing for path rendering directly in a GPU implementing DirectX11 without using a separate CPU. For example, the path primitive may allow for filling, stroking, or both using the methods described herein.","In some examples, the GPU implements a DirectX11 application programming interfaces for handling graphics tasks. The GPU further implements a draw call function configured to process a number of indices and path segment types. The GPU may also further implement an information primitive type.","For the first pass, the CPU may place data indicative of a path segment to be rendered into one or more vertices of a vertex buffer. The primitive topology for the vertices in the vertex buffer may be, for example, a patch control list. For a line, the vertices in the patch control list may include data indicative of coordinates for the endpoints of the line (e.g., (x0, y0) and (x1, y1)). For a cubic B\u00e9zier curve, the vertices in the patch control list may include data indicative of the coordinates of the four control points that define the curve (e.g., (x0, y0), (x1, y1), (x2, y2), (x3, y3)). For a quadratic B\u00e9zier curve, the vertices in the patch control list may include data indicative of coordinates for three control points instead of four control points. For elliptic arcs, the vertices in the patch control list may include data indicative of an endpoint parameterization of the elliptic arc or data indicative of a center parameterization of the elliptic arc. The CPU may also place data indicative of the type of path to be rendered into an otherwise unused vertex coordinate.","One example of an input format for rendering path primitives will now be described. It should be understood that this is merely one example of how data indicative of a path to be rendered may be provided to the GPU and that other examples are possible and within the scope of this disclosure. In this example, the GPU receives each path segment as a four (4) control point patch list primitive. Each of the vertices (e.g., control points) in the path list, in this example, includes three (3) float vectors that define attributes for the respective vertex (e.g., control point).","For a line path segment, the input may take the following form or a similar form:\n\n","The input for a cubic B\u00e9zier path segment may take the following form or a similar form:\n\n","The input for an elliptic arc path segment may take the following form or a similar form:\n\n","In some examples, stroking operations may use 3 additional fields on the vertex input to handle endcaps, joins and open paths. For example, certain vertex coordinates may store data indicative of whether the path segment is the beginning of a new open path, the end of an open path, and whether the primitive may be dropped. The following is an example template that includes the above-described vertex coordinates:\n\n","The input assembler  obtains the vertices from the vertex buffer and passes the vertices to vertex shader stage  for processing. In some examples, vertex shader stage  may execute a \u201cpass-through\u201d shader program that simply outputs the input vertex for each instance of the shader program. In an example, vertex shader stage  may transform vertices using world, view and projection matrices.","Tessellator stages  (i.e., hull shader , tessellator , and domain shader stages ) may tessellate the path segment defined by the input data into a plurality of line segments. The plurality of line segments may approximate the curvature of the path to be rendered. In general, tessellator  may determine values at which one or more parametric equations that represent a particular type of path segment should be evaluated. Domain shader  may evaluate the parametric equations at the values determined by tessellator , and output a vertex for each evaluation. Some examples may use a Dx11 tessellator unit, with isoline domain, integer partitioning, line output. Tessellator  may cut the line segment according to the dash pattern and re-tessellation delta, using u coordinates. It may then create caps at every cut location using v coordinates and set the type to be cap or line segment.","Domain shader  may output the vertices in an ordered sequence where each set of adjacent vertices represents a tessellated line segment. The line segments may collectively approximate the path segment that was defined in the vertex buffer. For example, domain shader  may output the following set of vertices {0, 1, 2, 3, 4, 5} that define the following line segments: {0, 1}, {1, 2}, {2, 3}, {3, 4}, {4, 5}.","In some examples, tessellator processing stage  and domain shader processing stage  may be configured to uniformly tessellate a path segment into a plurality of line segments according to the following technique. Specifically, tessellator unit  may output coordinates for parametric evaluation (e.g., t=0\/T, 1\/T, 2\/T . . . T\/T, where T is the tessellation factor). Depending on the type of primitive, domain shader  may evaluate one or more parametric equations at the values that are output by tessellator .","In another example, domain shader  may evaluate tessellated vertices' locations and normals for lines, cubics and elliptic arcs. Domain shader  may also convert normals to angular form and mark output as line segment. For lines: u is either 0.0f or 1.0f. Endpoints may be outputted directly. For normal, i.e. lines meeting perpendicularly, both will be found from endpoints difference and will be the same. Curves: u will range from 0.0f to 1.0f, in equal increments depending on the tessellation level. For all u's, position will be found using the curve representation equation. For u=0.0f or 1.0f, normals will be found by control point differences (repeated control points will be checked); for other u values, normals will be found by the derivative of the curve equation.","Elliptic arcs: u will range from 0.0f to 1.0f, in equal increments depending on the tessellation level. For all u's, positions and normals will be found using the arc parametric representation and its derivative, respectively. For linear interpolation the normal angle for cap and joins, convert back to Cartesian representation. Mark output as cap or join as appropriately. Round caps\/joins: u will range from 0.0f to 1.0f, in equal increments depending on the round tessellation level. Position will be the same for all u values. When u=0.0f or 1.0f, we take the Cartesian representation of the endpoint tangents to calculate normals. For other u values, angular tangents will be lerped to find new tangents, and then converted to normals. Other caps\/joins, u will be 0.0f or 1.0f. Position will be the same both. We take the Cartesian representation of the endpoint tangents to calculate normals.","Another domain shader (DS\u2032), not shown, may provide for dashes and cusps in a line segment. Linear interpretation of normals and positions at tessellation locations. Domain shader  may convert normals from angular form back to Cartesian form. In an example, u of a line from point u to point v may be used to linear interpolate position and normal angle. The point v may be used to rotate the normal angle (used to create round caps). If no dashing and re-tessellation is required, one can use the following one-rendering pass flow: VS\u2192HS\u2192Tess\u2192DS\u2192GS\u2192PS","If dashing or re-tessellation is desired, the following 2-pass flow will need to be used: VS\u2192HS\u2192MTess\u2192DS\u2192Streamout (Existing tessellator is enough here).","Draw Auto\u2192HS\u2032\u2192MTess\u2192DS\u2032\u2192GS\u2192PS","In such an example, only two additional shaders (marked with an apostrophe) are required, on top of the minor tessellator hardware addition.","For a line, T may, in some examples, be always equal to 1. In such examples, domain shader  may not necessarily need to perform any evaluation to generate vertices that correspond to the line path segment.","For a cubic B\u00e9zier curve, domain shader stage may evaluate the curve and generate output vertices according to the following parametric equation:\n\n0*(1)1*3*(1)2*3*(1)*33\n\nwhere C0, C1, C2, C3 correspond to the control points for the cubic B\u00e9zier curve, and t corresponds to the coordinates provided by domain shader  to be used for performing parametric evaluation.\n","Alternatively, for the cubic B\u00e9zier curve, domain shader stage  may evaluate the curve and generate output vertices according to the following parametric equations:\n\n0*(1)1*3*(1)2*3*(1)*3\n\n0*(1)1*3*(1)2*3*(1)*3\n\nwhere (X0, Y0), (X1, Y1), (X2, Y2), (X3, Y3) correspond to the control points for the cubic B\u00e9zier curve, and t corresponds to the coordinates provided by domain shader  to be used for performing parametric evaluation.\n","For a quadratic B\u00e9zier curve, domain shader stage  may evaluate the curve and generate output vertices according to the following parametric equation:\n\n0*(1)1*2*(1)*2\n\nwhere C0, C1, C2 correspond to the control points for the quadratic B\u00e9zier curve, and t corresponds to the coordinates provided by domain shader  to be used for performing parametric evaluation.\n","Alternatively, for the quadratic B\u00e9zier curve, domain shader stage  may evaluate the curve and generate output vertices according to the following parametric equations:\n\n0*(1)1*(1)*2\n\n0*(1)1*(1)*2\n\nwhere (X0, Y0), (X1, Y1), (X2, Y2) correspond to control points for the quadratic B\u00e9zier curve, and t corresponds to the coordinates provided by domain shader  to be used for performing parametric evaluation.\n","For an elliptic arc path segment, domain shader  stage may evaluate the curve and generate output vertices according to the following parametric equations:\n\n=CenterCos*cos(angle)\u2212Sin*sin(angle)\n\n=CenterSin*cos(angle)+Cos*sin(angle)\n\nwhere the parameterization angle angleis determined from tessellator output t, where rh represents the horizontal radius of the unrotated ellipse, rv represents the vertical radius of the unrotated ellipse, rv Cos, rv Sin, rh Cos and rh Sin represent rv*Cos(angle), rv*Sin(angle), rh*Cos(angle) and rh*Sin(angle), respectively, and angle represents the counter-clockwise angle of the ellipse relative to the x axis measured prior to scaling by (rh, rv). In some examples, hull shader  stage may be configured to determine (e.g., precompute) cos(angle) and sin(angle) and\/or to determine (e.g., precompute) the rv Cos, rv Sin, rh Cos and rh Sin values, and to provide these values to the domain shader stage  for use in evaluating the above-recited parametric equations for ellipses.\n","As discussed above with respect to elliptic arcs, the vertices in the patch control list, in some examples, may include data indicative of an endpoint parameterization. In such examples, a hull shader program  executing on a shader unit of the GPU  may be used to convert the data indicative of an endpoint parameterization of the elliptic arc to a data indicative of a center parameterization of the elliptic arc.","In an example, another hull shader program (HS\u2032), not shown, may be added and may save an angular representations of round join and cap tangents into primitive data and determine tessellation level. For lines, non-round joins and caps, collapsed cubics and degenerate ellipses: 1.0f, calculate optimum tessellation level for cubics and elliptic arcs, or use fixed tessellation, and calculate optimum tessellation level for round joins and caps, or use fixed tessellation. Hull shader program  may compute tessellator inputs such as segment length, re-tessellation delta, inverse of length. In an example, segment length is the length of the line segment. Re-tessellation delta is the length of the line segment divided by re-tessellation amount. The maximum length of a line segment to come out of tessellator. Inverse of length is 1.0f\/Segment Length.","An example technique for finding the correct center of an ellipse when converting an endpoint parameterization of an elliptic arc to a center parameterization of the elliptic arc is now described. The example technique may determine a center point (cx, cy) and the initial and final angles \u03b81 and \u03b82 of an ellipse and\/or elliptic arc based on an endpoint representation of an ellipse defined by the set of parameters (x0, y0), (x1, y1), rh, rv, \u03c6, f, and f. An ellipse with center point (cx, cy), radii rh and rv, and rotation angle rot may satisfy the implicit equation (x)+(y)=1, where x\u2032=((x\u2212cx)*cos(rot)+(y\u2212cy)*sin(rot))\/rh and y\u2032=(\u2212(x\u2212cx)*sin(rot)+(y\u2212cy)*cos(rot))\/rv. The transformation from (x, y) to (x\u2032, y\u2032) maps the desired ellipse into a unit circle centered at the origin.","To determine the center points of the pair of ellipses with common radii and rotation angle that pass through the two given points (x, y) and (x, y), a plane is first transformed into a suitably scaled and rotated coordinate system such that the equation of each ellipse becomes (x\u2032\u2212cx\u2032)+(y\u2032\u2212cy\u2032)=1. Then the centers (i.e., (cx\u2032, cy\u2032) and (cx\u2032, cy\u2032)) of the two unit circles whose circumferences pass through two given points may be found. Finally, the center points are placed through an inverse transformation to obtain solutions in the original coordinate system.","The center points of the two unit circles that pass through points (x, y) and (x, y) are given by (x\u00b1\u0394y*d, y\u2213\u0394x*d), where x=(x+x)\/2, y=(y+y)\/2, \u0394x=(x\u2212x), \u0394y=(y\u2212y), and d=\u221a(1\/(\u0394x+\u0394y)\u2212\u00bc.). If d is infinite or imaginary, no solution exists due to the input points being coincident or too far apart, respectively. The angles \u03b81 and \u03b82 may be found by finding the slope of the endpoints on the circle and computing arctangents.","The following pseudo-code illustrates the process of computing ellipse centers according to the above-described technique. The findUnitCircles function is called by findEllipses following inverse transformation of the original ellipse parameters.",{"@attributes":{"id":"p-0171","num":"0189"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/* Given: Points (x0, y0) and (x1, y1)"},{"entry":"* Return: TRUE if a solution exists, FALSE otherwise"},{"entry":"* Circle centers are written to (cx0, cy0) and (cx1, cy1)"},{"entry":"*\/"},{"entry":"static VGboolean findUnitCircles(double x0, double y0,"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"double x1, double y1,"]},{"entry":[{},"double *cx0, double *cy0,"]},{"entry":[{},"double *cx1, double *cy1)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"{"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/* Compute differences and averages *\/"]},{"entry":[{},"double dx = x0 \u2212 x1;"]},{"entry":[{},"double dy = y0 \u2212 y1;"]},{"entry":[{},"double xm = (x0 + x1)\/2;"]},{"entry":[{},"double ym = (y0 + y1)\/2;"]},{"entry":[{},"double dsq, disc, s, sdx, sdy;"]},{"entry":[{},"\/* Solve for intersecting unit circles *\/"]},{"entry":[{},"dsq = dx*dx + dy*dy;"]},{"entry":[{},"if (dsq == 0.0) return VG_FALSE; \/* Points are coincident *\/"]},{"entry":[{},"disc = 1.0\/dsq \u2212 1.0\/4.0;"]},{"entry":[{},"if (disc < 0.0) return VG_FALSE; \/* Points are too far apart *\/"]},{"entry":[{},"s = sqrt(disc);"]},{"entry":[{},"sdx = s*dx;"]},{"entry":[{},"sdy = s*dy;"]},{"entry":[{},"*cx0 = xm + sdy;"]},{"entry":[{},"*cy0 = ym \u2212 sdx;"]},{"entry":[{},"*cx1 = xm \u2212 sdy;"]},{"entry":[{},"*cy1 = ym + sdx;"]},{"entry":[{},"return VG_TRUE;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"\/* Given: Ellipse parameters rh, rv, rot (in degrees),"},{"entry":"* endpoints (x0, y0) and (x1, y1)"},{"entry":"* Return: TRUE if a solution exists, FALSE otherwise"},{"entry":"* Ellipse centers are written to (cx0, cy0) and (cx1, cy1)"},{"entry":"*\/"},{"entry":"VGboolean findEllipses(double rh, double rv, double rot,"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"double x0, double y0, double x1, double y1,"]},{"entry":[{},"double *cx0, double *cy0, double *cx1, double *cy1)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"{"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"double COS, SIN, x0p, y0p, x1p, y1p, pcx0, pcy0, pcx1, pcy1;"]},{"entry":[{},"\/* Convert rotation angle from degrees to radians *\/"]},{"entry":[{},"rot *= M_PI\/180.0;"]},{"entry":[{},"\/* Pre-compute rotation matrix entries *\/"]},{"entry":[{},"COS = cos(rot); SIN = sin(rot);"]},{"entry":[{},"\/* Transform (x0, y0) and (x1, y1) into unit space *\/"]},{"entry":[{},"\/* using (inverse) rotate, followed by (inverse) scale *\/"]},{"entry":[{},"x0p = (x0*COS + y0*SIN)\/rh;"]},{"entry":[{},"y0p = (\u2212x0*SIN + y0*COS)\/rv;"]},{"entry":[{},"x1p = (x1*COS + y1*SIN)\/rh;"]},{"entry":[{},"y1p = (\u2212x1*SIN + y1*COS)\/rv;"]},{"entry":[{},"if (!findUnitCircles(x0p, y0p, x1p, y1p,"]},{"entry":[{},"&pcx0, &pcy0, &pcx1, &pcy1)) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"return VG_FALSE;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"\/* Transform back to original coordinate space *\/"]},{"entry":[{},"\/* using (forward) scale followed by (forward) rotate *\/"]},{"entry":[{},"pcx0 *= rh; pcy0 *= rv;"]},{"entry":[{},"pcx1 *= rh; pcy1 *= rv;"]},{"entry":[{},"*cx0 = pcx0*COS \u2212 pcy0*SIN;"]},{"entry":[{},"*cy0 = pcx0*SIN + pcy0*COS;"]},{"entry":[{},"*cx1 = pcx1*COS \u2212 pcy1*SIN;"]},{"entry":[{},"*cy1 = pcx1*SIN + pcy1*COS;"]},{"entry":[{},"return VG_TRUE;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Further details regarding converting an endpoint parameterization of an elliptic arc to a center parameterization of the elliptic arc may be found in the \u201cOpenVG Specification, Version 1.1,\u201d Dec. 3, 2008, available at: http:\/\/www.khronos.org\/registry\/vg\/specs\/openvg-1.1.pdf, the entire content of which is incorporated herein by reference. In particular, Section 18.4 of the OpenVG specification describes a technique for converting an endpoint parameterization of an elliptic arc to a center parameterization of the elliptic arc, incorporated herein by reference","Geometry shader  may be invoked once for each of the line segments produced by the domain shader . For each line segment, geometry shader  may generate a triangle primitive using a common control point as a first vertex of the triangle and using the two endpoints of the respective line segment as the second and third vertices of the triangle. For example, an example was provided above where the domain shader  generated the following set of vertices {0, 1, 2, 3, 4, 5} that define the following line segments: {0, 1}, {1, 2}, {2, 3}, {3, 4}, {4, 5}. For the above-listed sequence of line segments, geometry shader may generate the following triangles: {C, 0, 1}, {C, 1, 2}, {C, 2, 3}, {C, 3, 4}, {C, 4, 5}, {C, 4, 5} where C is any single vertex.","In an example geometry shader  may increase the width of a line type segments in both normal directions at endpoints to create stroke area. In some cases this may result in a quad, for which we output two triangles. In some other cases, where the curvature is high compared to line length and\/or stroke width is thick, a \u201cbutterfly\u201d may result. Butterflies require two triangles, but there may be rare bleeding issue due to t-joints. To eliminate t-joints, an extra teo triangles may be output, which can be packed into 8 vertices using triangle strip primitive type. It is an extremely rare phenomenon, so it is up to the programmer to use whether two triangle (maxvertices: 6) or 4-triangle (maxvertices: 8) approach. An example may (1) create one triangle for round caps\/joins (tessellated) and bevel joins, (2) create two triangles for square caps and miter joins, and (3) add z coordinate from the constant buffer to every output vertex.","In an example of preprocessing the path and packing of the vertex data may perform minimal preprocessing of path data prior to rendering. In some examples, preprocessing happens only once per path, and the result is not affected by world\/user\/perspective transformations. Preprocessing can be avoided, and an alternative solution without pre-processing is explained in the next section.","An example may iterate through all the vertices of a path, tracking the total, maximum and minimum values of vertices' x and y coordinates. The average of all vertices (centroid) will be used as the pivot point when performing filling. In some examples, the centroid of all vertices of a path is a good pivot point. The maximum and minimum coordinates define the bounding box for our path. This bounding box speeds up the filling process dramatically. Although not a very tight one, this is the quickest way to find a bounding box for a path. Some examples may implement different bounding boxes (or any other shape) algorithm depending on the needs of particular systems.","An example may convert elliptic arcs from endpoint representation to parametric representation. One way to represent an arc is the endpoint representation: Endpoints, radii and the rotation angle of the ellipse are defined. This representation may need to be converted to parametric representation before sending path data to GPU. The example may also need to find tangents at endpoints to find joins and caps corresponding to these locations. Hence, to be able to pre-process joins and caps, elliptic arcs need to be pre-processed as well. Some examples may create starting and ending Caps for open paths and Joins where path segments meet. Endpoint tangents need to be calculated to create cap and join primitives. Example systems may avoid finding starting and ending caps, and they can be handled when we are handling dashing. This may negligibly increase the modified tessellator unit size.","An example may pack the data into the format that will be understood by our DX11 program, and create the vertex buffers per path. This means embedding the primitive type (line, quadratic curve, cubic curve, elliptic arc, cap\/join) into the first vertices z coordinate. Every primitive is a 4 control point patch, regardless of whether all 4 control points are used or not. Below is an example line primitive packed into a 4 control point patch. Note the z coordinate of the first vertex defining the primitive type:",{"@attributes":{"id":"p-0179","num":"0197"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ line = 2.0f"]},{"entry":[{},"{ XMFLOAT3( \u22120.4f, 0.8f, 2.0f) }, \/\/ start point"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ XMFLOAT3( 0.4f, 0.8f, 1.0f) },\/\/ end point"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) },"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) },"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Every primitive may be conditioned to be unique even though they share vertices between adjacent primitives. Hence it is strictly patch-4 primitive type which results in no vertex reuse. The dash pattern may need to be pre-processed for stroke paths. The system may handle negative and zero dash pattern entries, remove last entry for odd number of entries, find the current dash pattern entry and how much dash is left based on the dash offset. Sometimes, although a dash pattern may be defined; there is no dashing (all zero entries, or a single entry in dash pattern). This pre-process may allow for the determination of such cases and skip dashing. Below is an example dash pattern and offset combination that shows the dash pattern pre-processing steps.","Dash Pattern: [10, 0, 20, \u22125, 8, 10, 15]","Offset: \u2212120","The above dash pattern has 7 entries. We remove the last entry to have a dash pattern with even number of entries:","Dash Pattern: [10, 0, 20, \u22125, 8, 10,]","Offset: \u2212120","We take the absolute value of the negative entries, and zero entries are removed by adding the following entry to the previous entry:","Dash Pattern: [30, +5, 8, 10]","Offset: \u2212120","An example system may compute the dash pattern length, which is 53 and add 53 to the negative offset value until we reach an offset greater than or equal to 0. The offset then becomes \u2212120+53+53+53=39. Now the example system may find what entry it points to. First entry is 30, which is less than the offset value 39. The example system may advance to the next entry and subtract 30 from the offset. New offset is 39\u221230=9. Current entry is 5, which is again less than the offset value 9. The example system may advance to the next entry and subtract 5 from the offset. New offset is 9\u22125=4. Current entry 8 is greater than the offset value 4. The offset may be subtracted from the current entry, which gives us the value 8\u22124=4. The index for the entry whose value is 8 becomes the \u201cdash index\u201d, and the remainder value of 4 on that entry becomes the \u201cdash left\u201d. Hence, the result of the pre-processing is as follows:","Dash Pattern: [30, 5, 8, 10]","Dash Index: 2 (pointing to the entry valued 8)","Dash Left: 4.","The rasterizer  may rasterize each of the triangles into a cell buffer (e.g., a buffer stored in the resources block of ). During the first pass, the pixel shader  may be disabled or set to a \u201cpass-through\u201d mode to pass input pixels directly to the output merger stage . The output merger stage  may be configured to populate stencil buffer  such that stencil buffer  stores values which are indicative of a fill area for the path segment according to one or more stencil buffer filling techniques. In various examples, in accordance with this disclosure, a cell buffer might be used rather than stencil buffer , as illustrated in . Generally, if a stencil buffer  is used a second rendering pass with bounding box to render the path fill using stencil data may be needed. In some examples, using a cell buffer may allow for a single pass solution, rather than a solution requiring multiple passes. In some examples, a cell buffer may be a dedicated hardware unit that may allow for 1-pass rendering. The cell buffer may be part of the rasterizer  in some examples. In an example, pixel shader  may return stroke color.","According to a first stencil buffer filling technique, for each of the rasterized primitives, the output merger stage may invert the values in stencil buffer  that correspond to pixels which are covered by the rasterized primitive. With this technique, after all of the primitives have been rasterized to stencil buffer , any inverted values in stencil buffer  may represent a fill area for the path segment to be rendered.","According to a second stencil buffer filling technique, for each of the rasterized primitives, the output merger stage may increment values in stencil buffer  that correspond to pixels which are covered by the rasterized primitive if a vertex order for the rasterized primitive is oriented in a clockwise direction, and decrement values in stencil buffer  that correspond to pixels which are covered by the rasterized primitive if a vertex order for the rasterized primitive is oriented in a counter-clockwise direction. With this technique, after all of the primitives have been rasterized to stencil buffer , any non-zero values in stencil buffer  may represent a fill area for the path segment to be rendered.",{"@attributes":{"id":"p-0196","num":"0214"},"figref":"FIG. 4"},"The DirectX11 pipeline may include a draw call that includes a number of indices and a number of path segment types. Indices may be used to, for example, fetch the control points, in the same way as a vertex buffer. The draw call may, for example, fetch both indices and path segment types. Path segment types may include line, quadratic curve, cubic curve, arc, etc. In some examples primitives may be added to allow for computing the tessellation level, e.g., in the hardware shader. Additionally, in some examples an information primitive type, also referred to as a generating primitive type, may be added to allow for the production of triangles (for strokes) and lines (for fill) in, for example, geometry shader .","Accordingly, hardware in a GPU implementing DirectX11 and the systems and methods described herein may include hardware to process the path and information primitive types. Additionally, a cell buffer may be added to the GPU implementing the DirectX11 architecture. In an example, the cell buffer may be a sixteen by sixteen grid of sub-pixels.",{"@attributes":{"id":"p-0199","num":"0217"},"figref":["FIG. 5","FIG. 5"]},{"@attributes":{"id":"p-0200","num":"0218"},"figref":["FIG. 6","FIG. 6","FIG. 6","FIGS. 5 and 6"],"br":[{},{},{},{}],"in-line-formulae":[{},{},{},{},{},{},{},{}],"i":["n","\u00b7xy","t","\u00b7y,\u2212t","x","n","xy","t","\u00b7y,\u2212t","x","p\u2032","\/p\u2033","=p","+\/\u2212w*n","p\u2032","\/p\u2033","=p","+\/\u2212w*n"]},"To find p\u2032 and p\u2033 points, create trianglestrip (p\u20330,p\u20320,p\u20331,p\u20321).","First find n0 and n1 by the following equations:\n\n0=(00\u00b7) and 1\u00b7=(10\u00b7)\n\nThen\n\n0000 and\n\n1111\n",{"@attributes":{"id":"p-0203","num":"0221"},"figref":["FIG. 7","FIG. 7"]},{"@attributes":{"id":"p-0204","num":"0222"},"figref":["FIG. 8","FIG. 8"]},"For a bevel triangle, (p\u20320, p, p\u2032 1) may be created as illustrated in .\n\n0=(00\u00b7)\n\n111)\n\n00\n\n11\n",{"@attributes":{"id":"p-0206","num":"0224"},"figref":["FIG. 9","FIG. 9"]},"Find p\u20320 and p\u20321 as in bevel join.","Find ta=(t0+t1)\/2\n\n22\n\n\/sqrt(2)\n\n\n",{"@attributes":{"id":"p-0209","num":"0227"},"figref":["FIG. 10","FIG. 10"],"br":[{},{}],"in-line-formulae":[{},{},{},{}],"i":["a ","t",",\u2212t","N ","n","*w "]},"For i=1 . . . N","If (i==N)\n\nend=1(for water tightness)\n\nElse\n\nend\u00b7=start\u00b7*cos \u03b8\u2212start\u00b7*sin \u03b8\n\nend\u00b7=start\u00b7*sin \u03b8+start\u00b7*cos \u03b8\n\nTriangle(start+,end+)\n","It is to be recognized that depending on the example, certain acts or events of any of the techniques described herein can be performed in a different sequence, may be added, merged, or left out altogether (e.g., not all described acts or events are necessary for the practice of the techniques). Moreover, in certain examples, acts or events may be performed concurrently, e.g., through multi-threaded processing, interrupt processing, or multiple processors, rather than sequentially.",{"@attributes":{"id":"p-0213","num":"0231"},"figref":["FIG. 11","FIG. 11"]},"Pass 1",{"@attributes":{"id":"p-0214","num":"0000"},"ul":{"@attributes":{"id":"ul0013","list-style":"none"},"li":{"@attributes":{"id":"ul0013-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0014","list-style":"none"},"li":["1. Clear the stencil buffer and disable writing into the color buffer. Pick an arbitrary point C","2. Break the boundary of the Polygon into sequence of directed line segments p0p1,p1p, . . .","3. Construct a triangle fan center at C: Cp0p1, Cp1p2, Cp2p3 . . .","4. Draw every triangle and set the stencil operation to be INVERT(EVEN\/ODD) or INCR(NOZERO)\n\nPass 2\n","1. Draw a big quad\/triangle covering the whole screen and draw to the pixels where stencil value is not zero."]}}}},"In some examples, point p1 illustrated in  may be selected as the common point (C) for generating a triangle fan, and a triangle fan may be generated that includes the following triangles: {p1, p2, p3}, {p1, p3, p4}, {p1, p4, p5}, {p1, p5, p6}, {p1, p6, p7}. The target fill region for the path illustrated in  is the union of regions A, D and F.","As illustrated in , regions A, D and F are the only regions that are within an odd number of the triangles formed by the triangle fan. Thus, if these triangles are rendered according to the first stencil buffer filling technique where the values in stencil buffer  that correspond to pixels which are covered by the rasterized primitive are inverted, then, after all of the primitives have been rasterized to stencil buffer , any inverted values in stencil buffer  may correspond to the union of regions A, D and F (i.e., the fill area for the path segment to be rendered).","In addition, regions A, D and F are the only regions that are within an unbalanced number of clockwise and counter-clockwise triangles formed by the triangle fan. Regions that are within an unbalanced number of clockwise and counter-clockwise triangles may refer to regions where the total number of triangles of which the region is inside is not equal to the total number of triangles of which the region is outside. Thus, if these triangles are rendered according to the second stencil buffer filling technique where the values in stencil buffer  are either incremented or decremented depending on whether the triangle is oriented in a clockwise or counter-clockwise direction, then after all of the primitives have been rasterized to stencil buffer , any non-zero values in stencil buffer  may correspond to the union of regions A, D and F (i.e., the fill area for the path segment to be rendered).","Further details regarding the use of a stencil buffer  to fill a polygon may be found in the \u201cOpenGL Programming Guide: The Official Guide to Learning OpenGL, Version 1.1,\u201d available at: http:\/\/www.glprogramming.com\/red\/chapter14.html#name13, the entire contents of which is incorporated herein by reference.","The first pass completes after rendering all of the primitives generated by geometry shader  into stencil buffer . During the second pass, a bounding box (e.g., formed from two triangle primitives) that encompasses the fill area is rendered into a render target (e.g., the frame buffer) with the stencil test enabled. The data in stencil buffer  may cause pixels inside of the fill area to light up with a fill color (specified by the CPU prior to the second rendering pass), and cause pixels that are outside of the fill area to remain dark. During the second pass, the tessellation stages and geometry shader  may be disabled. The vertex shader may be configured to perform standard vertex shader operations (e.g., transforms) for rendering 3D graphics primitives. The pixel shader may be configured to perform standard operations and\/or configured to operate in a \u201cpass-through\u201d mode. Once the second pass is complete, the render target (e.g., the frame buffer) may store a rasterized version of the fill area for the path segment.","The stroking operation may utilize a single-pass approach that may generally involve the following steps:\n\n","The input processing and tessellation operations are substantially similar to the input processing and tessellation operations described with respect to the filling operation, and therefore will not be described in further detail.","In addition to domain shader  evaluating parametric equations to generate vertices, as described above with respect the filling operation, domain shader  may also generate normals for the endpoints of the line segments during the stroking operation. To generate the normals, domain shader  may evaluate additional parametric equations for each of the values generated by tessellator , and output a normal vertex for each evaluation. The normal vertex may be indicative of a normal vector for a point on the path segment that corresponds to the parameter value generated by tessellator .","In general, the tangent formulae for curves and elliptic arcs (which may be used to determine the normal) are the derivatives of the parametric formulas described above with respect to generating the vertices for the curves and arcs. For example, for a cubic B\u00e9zier curve, domain shader  stage may generate normals for the output vertices of the curve according to the following parametric equation:\n\n0*\u22123*(1)1*(\u22126*(1)*3*(1))+2*(\u22123+6*(1)*)+3*3\n\nwhere C0, C1, C2, C3 correspond to the control points for the cubic B\u00e9zier curve, and t corresponds to the coordinates provided by domain shader  to be used for performing parametric evaluation. A derivative of the parametric equation for the quadratic B\u00e9zier curve provided above may be used to generate normals for a quadratic B\u00e9zier curve in a similar fashion.\n","Alternatively, for the cubic B\u00e9zier curve, domain shader stage  may generate normals for the output vertices of the curve according to the following parametric equations:\n\n0*\u22123*(1)1*(\u22126*(1\u2212)*3*(1))+2*(\u22123+6*(1)*)+3*3\n\n0*\u22123*(1)1*(\u22126*(1\u2212)*3*(1))+2*(\u22123+6*(1)*)+3*3\n\nwhere (X0, Y0), (X1, Y1), (X2, Y2), (X3, Y3) correspond to the control points for the cubic B\u00e9zier curve, and t corresponds to the coordinates provided by domain shader  to be used for performing parametric evaluation. A derivative of the parametric equations for the quadratic B\u00e9zier curve provided above may be used to generate normals for a quadratic B\u00e9zier curve in a similar fashion.\n","For an elliptic arc path segment, domain shader  stage may generate normals for the output vertices of the curve according to the following parametric equations:\n\nTanCos*sin(angle)\u2212Sin*cos(angle)\n\nTanSin*sin(angle)+Cos*cos(angle)\n\nwhere the parameterization angle angleis determined from tessellator output t, where rh represents the horizontal radius of the unrotated ellipse, rv represents the vertical radius of the unrotated ellipse, rv Cos, rv Sin, rh Cos and rh Sin represent rv*Cos(angle), rv*Sin(angle), rh*Cos(angle) and rh*Sin(angle), respectively, and angle represents the counter-clockwise angle of the ellipse relative to the x axis, measured prior to scaling by (rh, rv). In some examples, hull shader stage may be configured to determine (e.g., precompute) cos(angle) and sin(angle) and\/or to determine (e.g., precompute) the rv Cos, rv Sin, rh Cos and rh Sin values, and to provide these values to domain shader stage  for use in evaluating the above-recited parametric equations for ellipses.\n","After finding the tangent, the normal vector may be found according to the following equation:\n\nnormal=normalize(\u2212Tan,Tan).\n","As discussed above with respect to elliptic arcs, the vertices in the patch control list, in some examples, may include data indicative of an endpoint parameterization. In such examples, a hull shader program executing on a shader unit of the GPU may be used to convert the data indicative of an endpoint parameterization of the elliptic arc to a data indicative of a center parameterization of the elliptic arc.","Geometry shader  may receive the line segments and the normals produced by domain shader , and generate primitives (e.g., triangles) that spatially correspond to the stroke area for each of the line segments. The stroke area for each of the line segments may collectively approximate the stroke area for the original path segment.","In general, each line segment may be defined by two consecutive points p0, p1 on a path and the normals n0,n1 at each of point, respectively. To determine the stroke area for a line segment, geometry shader  may calculate the four corner points (u0, l0, u1, l1) of the stroke area for the line segment according to the following equations:\n\n0=00*StrokeWidth\n\n0=0\u22120*StrokeWidth\n\n1=1+1*StrokeWidth\n\n1=1\u22121*StrokeWidth\n\nwhere p0 and p1 are endpoints of the line segment for which the stroke area is being calculated, n0 is the normal vector corresponding to p0, n1 is the normal vector corresponding to p1, and StrokeWidth is the stroke width defined by the user application and passed to the GPU.\n",{"@attributes":{"id":"p-0230","num":"0257"},"figref":["FIGS. 12 and 13","FIGS. 12 and 13"]},"Geometry shader  may determine whether the intersection point is outside of the stroke area (e.g., ) or inside of the stroke area (e.g., ), and generate one or more primitives that spatially correspond to the stroke area based on the determination. To determine whether the intersection point is outside of the stroke area, geometry shader  may determine whether strokewidth<min(u0c,u1c). If strokewidth<min(u0c,u1c), geometry shader  may determine that the intersection point is outside of the stroke area. Otherwise, geometry shader  may determine that the intersection point is inside of the stroke area.","If the stroke width is small enough (strokewidth<min(u0c,u1c) so that the two line segment u0u1 and l0l1 have the same orientation, then the shape of stroke area for the line segment is a quad (). Otherwise the shape of the stroke area for the line segment is two head to head triangles (i.e., a butterfly) ().","If the intersection point is outside of the stroke area (e.g., ), then geometry shader  may generate two triangles to form a quad that spatially corresponds to the stroke area. For example, geometry shader  may generate two triangles using the following combinations of vertices {u0, u1, l1} and {l1, l0, u0}.","If the intersection point is inside of the stroke area (e.g., ), then geometry shader  may generate two triangles to form a butterfly that spatially corresponds to the stroke area. For example, geometry shader  may generate two triangles using the following combinations of vertices {u0, u1, c} and {c, l0, l1} if the {u0, u1, c} triangle is oriented in a clockwise direction, and generate two triangles using the following combinations of vertices {u0, u1, c} and {c, l1, l0} if the {u0, u1, c} triangle is oriented in a counter-clockwise direction.","To determine if the {u0, u1, c} triangle is oriented in a clockwise direction, geometry shader  may determine whether sin(a0+a1)>0 in the equations defined below. If sin(a0+a1)>0, then geometry shader  may determine that the {u0, u1, c} triangle is oriented in a clockwise direction. Otherwise, geometry shader  may determine that the {u0, u1, c} triangle is oriented in a counter-clockwise direction. The distances u0c and u1c, which may be used to determine the shape of the quad and also find out the coordinate of the center point C may be determined based on the following formulas:",{"@attributes":{"id":"p-0236","num":"0263"},"maths":[{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"v","mo":"=","mrow":{"mi":"normalize","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":[{"mi":"n","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"},{"mi":"n","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"}],"mo":"-"}}}}}},{"@attributes":{"id":"MATH-US-00001-2","num":"00001.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mrow":[{"mi":"sin","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"a","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"}}},{"mi":["n","v"],"mo":["\u2062","\u2062","\u00d7"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"}],"mo":"="},{"mrow":[{"mi":"cos","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"a","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"}}},{"mi":"n","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mn":"0","mo":"\u00b7","mi":"v"}}],"mo":"="}],"mo":","}}},{"@attributes":{"id":"MATH-US-00001-3","num":"00001.3"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mrow":[{"mi":"sin","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"a","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}}},{"mi":["v","n"],"mo":["\u00d7","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}],"mo":"="},{"mrow":[{"mi":"cos","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"a","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}}},{"mrow":{"mi":["v","n"],"mo":"\u00b7"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}],"mo":"="}],"mo":","}}},{"@attributes":{"id":"MATH-US-00001-4","num":"00001.4"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"sin","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":[{"mi":"a","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"},{"mi":"a","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}],"mo":"+"}}},{"mrow":[{"mrow":[{"mi":"sin","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"a","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"}}},{"mi":"cos","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"a","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}}}],"mo":"\u2062"},{"mrow":[{"mi":"cos","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"a","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"}}},{"mi":"sin","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"a","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}}}],"mo":"\u2062"}],"mo":"+"}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00001-5","num":"00001.5"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mrow":[{"mi":["u","c"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mn":"0"},{"mrow":{"mi":"sin","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"a","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}}},"mo":"\u2062","mfrac":{"mrow":[{"mo":["\uf603","\uf604"],"mrow":{"mrow":[{"mi":"u","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"},{"mi":"u","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"}],"mo":"-"}},{"mi":"sin","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":[{"mi":"a","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"},{"mi":"a","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}],"mo":"+"}}}]}}],"mo":"="},{"mrow":[{"mi":["u","c"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mn":"1"},{"mrow":{"mi":"sin","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"a","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"}}},"mo":"\u2062","mfrac":{"mrow":[{"mo":["\uf603","\uf604"],"mrow":{"mrow":[{"mi":"u","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"},{"mi":"u","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"}],"mo":"-"}},{"mi":"sin","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":[{"mi":"a","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"},{"mi":"a","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}],"mo":"+"}}}]}}],"mo":"="}],"mo":","}}},{"@attributes":{"id":"MATH-US-00001-6","num":"00001.6"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"c","mo":"=","mrow":{"mrow":[{"mi":"u","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"},{"mi":["n","c"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mrow":{"mn":"0","mo":"\u00b7","mi":"u"},"mn":"0"}],"mo":"-"}}}}],"br":{}},"If strokewidth<min(u0c,u1c), then the stroke area for the line segment may be a simple quad. The GPU may draw two (2) triangles (u0,u1,l1) and (l1,l0,u1). In some examples, regardless of the position of p0,p1,n0,n1, the two triangles may always be clockwise.","If strokewidth>min(u0c,u1c), then there are 2 cases. If sin(a0+a1)>0, which means triangle (u0,u1,c) is clockwise, then the triangles to be drawn is (u0,u1,c) and (c,l0,l1). If sin(a0+a1)<0, then triangles to be drawn are (u1,u0,c), (c,l1,l0).","In some cases, when primitives corresponding to the stroke areas of line segments are generated (e.g., by geometry shader ), the neighboring line segments may form a T junction if one or both of the stroke areas forms a butterfly shape (e.g. ). This is because the center point C is not at the same position for the different line segments.",{"@attributes":{"id":"p-0240","num":"0267"},"figref":"FIG. 14","b":["54","54","54"]},"In addition to the path rendering operations of filling and stroking, the techniques of this disclosure may include applying various types of end caps to the ends of a path, and applying various types of joins between the endpoints of interior path segments of a path. In some examples, these operations may be able to be implemented using the techniques of this disclosure on a DX11 pipeline.","Techniques are now described for rendering joins. Joins may be applied at where different path segments meet. In some examples, there may be three different types of joins: (1) bevel, (2) miter, and (3) round.","In an example, the cell buffer contains x*y cells. One cell represents one pixel in the final image, but cell name is used to distinguish the cells and pixels as they store different information. Each cell in the cell buffer stores sixteen bytes of winding counter information. The cell buffer may be the size of the frame buffer, but normally the memory requirements of the cell buffer would become too big. So the frame buffer can be split in to tiles of x*y pixels (and cells). This allows the drawing of the primitive one tile at a time.",{"@attributes":{"id":"p-0244","num":"0271"},"figref":"FIG. 15","b":"16"},"Each of the sixteen sample points of a pixel are an eight bit counter value. In one example, the counter may be a winding counter. The winding counter values may be incremented or decremented during the edge-drawing phase. Once all the edges have been drawn, the fill process examines the value of these counter values and calculates the pixel coverage value for anti-aliasing. The worst-case storage requirement is x*y*16 bytes where x and y are the dimensions of the tile. However, there are ways to reduce the required bandwidth to access the winding counters as in most of the cases the winding counter values are very small (either positive or negative). This information may be used compress the data, for example by storing the least significant bits of each winding counter (16 bits) as two bytes and have internal per pixel flags to determine the pixel type. The pixel type can be for example: empty, negative 16 bit, positive 16 bit, fully expanded 16 bytes. In other examples, more compression levels could be added.",{"@attributes":{"id":"p-0246","num":"0273"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0247","num":"0274"},"figref":"FIG. 17","b":["250","252","254","250","256","258","250","250"]},"The result of the sampling is collected as sixteen bit values (e.g., masks). Internally, there are left side and right side masks which are flushed out with certain rules. As the masks are flushed out, it means that the set bits affect the corresponding winding counters of that pixel. If the edge is upward, the winding counters are incremented. If the edge is downward the winding counters are decremented. As the edge sub-pixels are being generated it is checked if the next sub-pixel is within the current pixel, to the left, to the right or on different pixel row. If the new sub-pixel is on a different pixel row, then the both left and right side masks are flushed out. If the new sub-pixel is to the pixel right of the current pixel, the left side mask is flushed and then replaced by the right side mask. If the new sub-pixel is to the pixel left of the current pixel, the right side mask is flushed and then replaced by the left side mask. This may be done to reduce the amount of flushing. Basically, in the above example the left side and right side masks are each other's inverse. In other examples, that may not always be true. For example, very short edges or almost horizontal edges don't cover the whole pixel in vertical direction. In those examples, the left and right side masks are not each other's inverse.",{"@attributes":{"id":"p-0249","num":"0276"},"figref":["FIGS. 18A and 18B","FIGS. 18A and 18B"],"b":["12","500","12","502","12","504","12","506","12","508","12","510","514","512","502"]},"GPU  generates edge samples () and determines if the samples are in the current pixel (), as will be discussed with respect to . If the sample are in the current the GPU  determines if it is the left most tile (), if not then GPU  determines if the new pixel is left, right, or up\/down (). If the new pixel is right the GPU  replaces the right sample mask with the left sample mask and \u201cflushes,\u201d e.g., deletes the left sample mask (). If the new pixel is left the GPU  replaces the left sample mask with the right sample mask and \u201cflushes,\u201d e.g., deletes, the right sample mask (). If the new pixel is up or down then GPU  flushed and clears both sample masks ().","If the new tile is the left most tile, then GPU  may clamp the sample inside the tile, with x=max(x, tx0) (). If not, GPU  sampling updates the left or right mask (). This is also performed () if the tile is not the left most tile ().","If the edge is not finished, GPU again generates edge samples (), otherwise GPU  determines if all edges are done (). When all the edges are done the process completes, i.e., is done (). If all of the edges are not complete then one edge is input ().",{"@attributes":{"id":"p-0253","num":"0280"},"figref":"FIG. 19","b":["600","602"]},"The diagram illustrates the first two pixels ,  of the cell buffer after one upward edge (the edge drawing example above) has been drawn. As the edge was upward, the winding counters are positive ones in the cell buffer, on samples marked red. The winding counters from the cell buffer may be added to the internal winding counters before the coverage calculation. The column ,  on the left edge of the pixel shows the value of internal winding counters after the cell buffer winding counters have been added. The first pixel  in the illustrated example has ten samples having one in their winding counter. The final coverage value of the first pixel may be 10\/16. The second pixel  has six samples having one in their winding counter. As these are added to the internal winding counters it may be seen that now all sixteen internal winding counters are one, so the final coverage of the second pixel is 16\/16 (fully covered).",{"@attributes":{"id":"p-0255","num":"0282"},"figref":["FIGS. 20A-20Z","FIGS. 20A-20Z"],"b":["612","614","616","618","620","622","620","622"]},{"@attributes":{"id":"p-0256","num":"0283"},"figref":"FIG. 20A","b":["624","648","648","620","624"]},{"@attributes":{"id":"p-0257","num":"0284"},"figref":"FIG. 20B","b":["626","624","626"]},{"@attributes":{"id":"p-0258","num":"0285"},"figref":["FIG. 20C","FIG. 20C"],"b":["628","648","628","648","628","648"]},{"@attributes":{"id":"p-0259","num":"0286"},"figref":"FIG. 20D","b":["630","624","631","648"]},{"@attributes":{"id":"p-0260","num":"0287"},"figref":"FIG. 20E","b":["624","626","628","630","622","620","638"]},{"@attributes":{"id":"p-0261","num":"0288"},"figref":"FIG. 20F","b":["648","656"]},{"@attributes":{"id":"p-0262","num":"0289"},"figref":"FIG. 20G","b":["648","650"]},{"@attributes":{"id":"p-0263","num":"0290"},"figref":"FIG. 20H","b":["648","650","650","624","650","648"]},{"@attributes":{"id":"p-0264","num":"0291"},"figref":"FIG. 20I","b":["626","650","650","650","618","650","650"]},{"@attributes":{"id":"p-0265","num":"0292"},"figref":"FIG. 20J","b":"628"},{"@attributes":{"id":"p-0266","num":"0293"},"figref":"FIG. 20K","b":["630","650","630","650"]},{"@attributes":{"id":"p-0267","num":"0294"},"figref":"FIG. 20L","b":["650","648","636","638"]},{"@attributes":{"id":"p-0268","num":"0295"},"figref":"FIG. 20M","b":["650","665"]},{"@attributes":{"id":"p-0269","num":"0296"},"figref":"FIG. 20N","b":["624","652","624","652"]},{"@attributes":{"id":"p-0270","num":"0297"},"figref":"FIG. 20O","b":["626","652"]},{"@attributes":{"id":"p-0271","num":"0298"},"figref":"FIG. 20P","b":"628"},{"@attributes":{"id":"p-0272","num":"0299"},"figref":"FIG. 20Q","b":["630","630","652"]},{"@attributes":{"id":"p-0273","num":"0300"},"figref":"FIG. 20R","b":"652"},{"@attributes":{"id":"p-0274","num":"0301"},"figref":"FIG. 20S","b":"652"},{"@attributes":{"id":"p-0275","num":"0302"},"figref":"FIG. 20T","b":["652","654"]},{"@attributes":{"id":"p-0276","num":"0303"},"figref":"FIG. 20U","b":["624","654"]},{"@attributes":{"id":"p-0277","num":"0304"},"figref":"FIG. 20V","b":["626","654"]},{"@attributes":{"id":"p-0278","num":"0305"},"figref":"FIG. 20W","b":"628"},{"@attributes":{"id":"p-0279","num":"0306"},"figref":"FIG. 20X","b":["630","654"]},{"@attributes":{"id":"p-0280","num":"0307"},"figref":"FIG. 20Y","b":"654"},{"@attributes":{"id":"p-0281","num":"0308"},"figref":"FIG. 20Z","b":"654"},{"@attributes":{"id":"p-0282","num":"0309"},"figref":["FIGS. 21A-D","FIG. 21B"]},{"@attributes":{"id":"p-0283","num":"0310"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ cap = 6.0f"]},{"entry":[{},"{ XMFLOAT3( \u22120.4f, 0.8f, 6.0f) }, \/\/ location"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ XMFLOAT3( 0.8f, 0.0f, 1.0f) }, \/\/tangent"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) },"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) },"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ line = 2.0f"]},{"entry":[{},"{ XMFLOAT3( \u22120.4f, 0.8f, 2.0f) }, \/\/ start point"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ XMFLOAT3( 0.4f, 0.8f, 1.0f) },\/\/ end point"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) },"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) },"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/join = 5.0f"]},{"entry":[{},"{ XMFLOAT3( 0.4f, 0.8f, 5.0f) }, \/\/ location"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ XMFLOAT3( 0.8f, 0.0f, 1.0f) }, \/\/ first tangent"]},{"entry":[{},"{ XMFLOAT3( 0.2f, \u22120.2f, 1.0f) }, \/\/ second tangent"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) },"]},{"entry":[{},"\/\/cubic = 3.0f"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{ XMFLOAT3( 0.4f, 0.8f, 3.0f) }, \/\/ first control point"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ XMFLOAT3( 0.6f, 0.6f, 1.0f) }, \/\/ second control point"]},{"entry":[{},"{ XMFLOAT3( 0.6f, 0.2f, 1.0f) }, \/\/ third control point"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) }, \/\/ fourth control point"]},{"entry":[{},"\/\/ cap = 6.0f"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 6.0f) }, \/\/ location"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ XMFLOAT3( \u22120.6f, \u22120.2f, 1.0f) }, \/\/tangent"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) },"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) },"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In an example, all primitives may be a path-4 type and the programmer makes a drawAutoIndexed API call.","In an example without pre-processing, as illustrated in  five vertices may define the path, primitive types are as follows: [Line, Cubic]. The path is not closed. An example process may make following API call: (1) drawNonIndexedPrimType(numIndices=5, closed=false), (2) IA will start generating primitives based on the primitive types. Since this is an open path, there are caps at the beginning and end of the path.","In an example, output be as follows:",{"@attributes":{"id":"p-0287","num":"0314"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"PrimType","Indices"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Cap_Line","0, 1"]},{"entry":[{},"Line","0, 1"]},{"entry":[{},"Join_Line_Cubic","0, 1, 2, 3, 4"]},{"entry":[{},"Cubic","1, 2, 3, 4"]},{"entry":[{},"Cap_Cubic","4, 3, 2, 1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"(Note that indices are in reverse order for ending cap)"]}]}}}}},"An example may have four different types of path segments (line, quadratic, cubic, elliptic), we have 4\u00d74=16 join primitive types. In an example a vertex shader  may process X and Y coordinates that may have appropriate world\/view\/projections applied. For simplicity, we assume identity transformation, hence the input remains unchanged. A control point hull shader may perform the following process for caps and join:",{"@attributes":{"id":"p-0289","num":"0316"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"if( ( join AND (ControlPointId == 1 or 2) ) OR (cap AND ControlPointId"},{"entry":"== 1) )"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ convert tangent to angle for faster lerping later"]},{"entry":[{},"normalizedTangent = normalize( inputPatch[ControlPointId] )"]},{"entry":[{},"angle = acos( normalizedTangent.x )"]},{"entry":[{},"if ( normalizedTangent.y < 0 )"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"angle = 2.0*PI \u2212 angle;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ save the angle representation in the Z coordinate of the control"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"point vertex"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"output.z = a0;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Control points 1 and 2 for joins, and control point 1 for caps contain the tangent data. We convert these tangents to angular representation and save them in the z coordinate, which was not used previously. Hence, the input to tessellator  then will be the following:",{"@attributes":{"id":"p-0291","num":"0318"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ cap = 6.0f"]},{"entry":[{},"{ XMFLOAT3( \u22120.4f, 0.8f, 6.0f) }, \/\/ location"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ XMFLOAT3( 0.8f, 0.0f, 0.0f) }, \/\/ tangent"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) },"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) },"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ line = 2.0f"]},{"entry":[{},"{ XMFLOAT3( \u22120.4f, 0.8f, 2.0f) }, \/\/ start point"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ XMFLOAT3( 0.4f, 0.8f, 1.0f) }, \/\/ end point"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) },"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) },"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ join = 5.0f"]},{"entry":[{},"{ XMFLOAT3( 0.4f, 0.8f, 5.0f) }, \/\/ location"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ XMFLOAT3( 0.8f, 0.0f, 0.0f) }, \/\/ first tangent"]},{"entry":[{},"{ XMFLOAT3( 0.2f, \u22120.2f, 5.5f) }, \/\/ second tangent"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) },"]},{"entry":[{},"\/\/ cubic = 3.0f"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{ XMFLOAT3( 0.4f, 0.8f, 3.0f) }, \/\/ first control point"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ XMFLOAT3( 0.6f, 0.6f, 1.0f) }, \/\/ second control point"]},{"entry":[{},"{ XMFLOAT3( 0.6f, 0.2f, 1.0f) }, \/\/ third control point"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) }, \/\/ fourth control point"]},{"entry":[{},"\/\/ cap = 6.0f"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 6.0f) }, \/\/ location"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ XMFLOAT3( \u22120.6f, \u22120.2f, 3.46f) }, \/\/ tangent"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) },"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) },"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"An example may include constant HS will determine tessellation levels. For example, assume fixed tessellation, 4\u00d7 for the cubic, 4\u00d7 for round caps\/joins and 1\u00d7 for lines. Domain shader  may output is a vertex position, normal and type and evaluate tessellated vertices' locations and normals for lines, cubics and elliptic arcs. Domain shader  may convert normals to angular form and mark output as line segment. For curves, domain shader  may repeated control points might cause us to have zero tangents at curve start and end locations. To correctly determine tangents there, domain shader  may treat u=0.0f and 1.0f differently and linear interpolate intermediate values. Linear interpellation of the normal angle for cap and joins, convert back to Cartesian representation. Domain shader  may mark output as cap or join as appropriately. For u=0.0f and 1.0f, we directly use the tangents Cartesian representation instead of angular representation, to ensure water-tightness. Again, domain shader  may treat u=0.0f and 1.0f differently than intermediate values.","For u=0.0f, lines: Position is the first vertex. Normal is the endpoints difference.",{"@attributes":{"id":"p-0294","num":"0321"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ line = 2.0f"]},{"entry":[{},"{ XMFLOAT3( \u22120.4f, 0.8f, 2.0f) }, \/\/ start point"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ XMFLOAT3( 0.4f, 0.8f, 1.0f) }, \/\/ end point"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) },"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) },"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In an example, output position may be \u22120.4f, 0.8f (start point), output\u00b7norm may be 0.8f, 0.0f, tangent may be end point-start point, normal may be [\u2212tan\u00b7y, tan\u00b7x], and output. type may be line. For curves: position may be the first control point. Normal may be the difference of first two nonrepeating control points.",{"@attributes":{"id":"p-0296","num":"0323"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/cubic = 3.0f"]},{"entry":[{},"{ XMFLOAT3( 0.4f, 0.8f, 3.0f) }, \/\/ first control point"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ XMFLOAT3( 0.6f, 0.6f, 1.0f) }, \/\/ second control point"]},{"entry":[{},"{ XMFLOAT3( 0.6f, 0.2f, 1.0f) }, \/\/ third control point"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) }, \/\/ fourth control point"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In an example, output position may be 0.4f, 0.8f (first control point), output\u00b7norm may be 0.2f, 0.2f, tangent may be the difference between first two non-equal control points, normal may be [\u2212tan\u00b7y, tan\u00b7x], and output type may be line. Caps can be the position of the first vertex. Normal may be the Cartesian representation of the tangent vector rotated 90 degrees counterclockwise.",{"@attributes":{"id":"p-0298","num":"0325"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ cap = 6.0f"]},{"entry":[{},"{ XMFLOAT3( \u22120.4f, 0.8f, 6.0f) }, \/\/ location"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ XMFLOAT3( 0.8f, 0.0f, 0.0f) }, \/\/ tangent"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) },"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) },"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In another example, output position may be \u22120.4f, 0.8f (cap position), output\u00b7norm may be 0.0f, 0.8f. The example may use tangent Cartesian representation, normal=[\u2212tan\u00b7y, tan\u00b7x] and output\u00b7type may be cap.",{"@attributes":{"id":"p-0300","num":"0327"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ cap = 6.0f"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 6.0f) }, \/\/ location"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ XMFLOAT3( \u22120.6f, \u22120.2f, 3.46f) }, \/\/ tangent"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) },"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) },"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In another example, output position may be 0.0f, 0.0f (cap position), output\u00b7norm may be 0.2f, \u22120.6f. The example may use tangent Cartesian representation, normal=[\u2212tan\u00b7y, tan\u00b7x] and have output\u00b7type equal to cap. For joins the position is the first vertex. Normal it is the Cartesian representation of the first tangent vector rotated 90 degrees counterclockwise.",{"@attributes":{"id":"p-0302","num":"0329"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ join = 5.0f"]},{"entry":[{},"{ XMFLOAT3( 0.4f, 0.8f, 5.0f) }, \/\/ location"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ XMFLOAT3( 0.8f, 0.0f, 0.0f) }, \/\/ first tangent"]},{"entry":[{},"{ XMFLOAT3( 0.2f, \u22120.2f, 5.5f) }, \/\/ second tangent"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) },"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In another example, output position may be 0.4f, 0.8f (join position), output\u00b7norm may be 0.0f, \u22120.8f and the example may use the first tangent Cartesian representation, normal=[\u2212tan\u00b7y, tan\u00b7x] with an output\u00b7type=join. For this example u=1.0f, with lines in the position of the last vertex. Normal is the endpoints difference.",{"@attributes":{"id":"p-0304","num":"0331"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ line = 2.0f"]},{"entry":[{},"{ XMFLOAT3( \u22120.4f, 0.8f, 2.0f) }, \/\/ start point"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ XMFLOAT3( 0.4f, 0.8f, 1.0f) }, \/\/ end point"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) },"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) },"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In another example, output position may be 0.4f, 0.8f (end point) and output\u00b7norm may be 0.8f, 0.0f. In the example, the tangent may be the end point-start point and the normal may be [\u2212tan\u00b7y, tan\u00b7x]. The output\u00b7type may be line. For curves the position may be the last control point. Normal is the difference of last two nonrepeating control points.",{"@attributes":{"id":"p-0306","num":"0333"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ cubic = 3.0f"]},{"entry":[{},"{ XMFLOAT3( 0.4f, 0.8f, 3.0f) }, \/\/ first control point"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ XMFLOAT3( 0.6f, 0.6f, 1.0f) }, \/\/ second control point"]},{"entry":[{},"{ XMFLOAT3( 0.6f, 0.2f, 1.0f) }, \/\/ third control point"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) }, \/\/ fourth control point"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In another example, output position may be 0.0f, 0.0f (last control point) and output\u00b7norm=0.2f, \u22120.6f. In the example, the tangent may be difference between first two non-equal control points and the normal=[\u2212tan\u00b7y, tan\u00b7x]. The output\u00b7type may be line. A caps position may be the first vertex. Normal may be the Cartesian representation of the tangent vector rotated 90 degrees clockwise.",{"@attributes":{"id":"p-0308","num":"0335"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ cap = 6.0f"]},{"entry":[{},"{ XMFLOAT3( \u22120.4f, 0.8f, 6.0f) }, \/\/ location"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ XMFLOAT3( 0.8f, 0.0f, 0.0f) }, \/\/ tangent"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) },"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) },"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In another example, output position may be \u22120.4f, 0.8f (cap position), output\u00b7norm may be 0.0f, \u22120.8f and the example may use tangent Cartesian representation, with normal=[tan\u00b7y, \u2212tan\u00b7x] and an output\u00b7type that may be cap.",{"@attributes":{"id":"p-0310","num":"0337"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ cap = 6.0f"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 6.0f) }, \/\/ location"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ XMFLOAT3( \u22120.6f, \u22120.2f, 3.46f) }, \/\/ tangent"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) },"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) },"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In another example, output position may be 0.0f, 0.0f (cap position) with output\u00b7norm that is \u22120.2f, 0.6f and with a use tangent Cartesian representation, normal=[tan\u00b7y, \u2212tan\u00b7x] and an output\u00b7type that is cap. For joins the position is the first vertex. Normal is the Cartesian representation of the second tangent vector rotated 90 degrees counterclockwise.",{"@attributes":{"id":"p-0312","num":"0339"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ join = 5.0f"]},{"entry":[{},"{ XMFLOAT3( 0.4f, 0.8f, 5.0f) }, \/\/ location"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ XMFLOAT3( 0.8f, 0.0f, 0.0f) }, \/\/ first tangent"]},{"entry":[{},"{ XMFLOAT3( 0.2f, \u22120.2f, 5.5f) }, \/\/ second tangent"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) },"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In another example, output position may be 0.4f, 0.8f (join position) with output\u00b7norm that is 0.2f, 0.2f. The example may use second tangent Cartesian representation, with a normal that is [\u2212tan\u00b7y, tan\u00b7x] and an output\u00b7type that is type join.","In the example, u=i\/T (intermediate values), lines may have no intermediate tessellation values for lines and a curve's position may be found using the equation\n\n0(1)+31(1)32(1)\u00b73\n\nTangent are found using the derivative of the position equation:\n\n\u221230(1)\u221261(1)31(1)\u221232+62(1)33\n",{"@attributes":{"id":"p-0315","num":"0342"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ cubic = 3.0f"]},{"entry":[{},"{ XMFLOAT3( 0.4f, 0.8f, 3.0f) }, \/\/ first control point"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ XMFLOAT3( 0.6f, 0.6f, 1.0f) }, \/\/ second control point"]},{"entry":[{},"{ XMFLOAT3( 0.6f, 0.2f, 1.0f) }, \/\/ third control point"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) }, \/\/ fourth control point"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In another example output\u00b7pos may use cubic Bezier formula and output\u00b7norm may use cubic Bezier formula derivative to find tangent. The normal may be [\u2212tan\u00b7y, tan\u00b7x] and the output\u00b7type may be line. Caps (Round only) may have no intermediate values for square caps. For round caps, position may be the first vertex. Normal may be found by first linear interpolating the angular tangent with its opposite direction (add PI), then rotating 90 degrees counterclockwise.",{"@attributes":{"id":"p-0317","num":"0344"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ cap = 6.0f"]},{"entry":[{},"{ XMFLOAT3( \u22120.4f, 0.8f, 6.0f ) }, \/\/ location"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ XMFLOAT3( 0.8f, 0.0f, 0.0f) }, \/\/ tangent"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) },"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) },"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In another example, output position may be \u22120.4f, 0.8f (cap position). The output\u00b7norm may be \u2212sin(lerpedAngle), cos(lerpedAngle) with lerp angle with (angle+PI), (1\u2212u)*angle+u*(angle+PI), tangent=cos(lerpedAngle), sin(lerpedAngle), normal=[\u2212tan\u00b7y, tan\u00b7x], and output\u00b7type=cap.",{"@attributes":{"id":"p-0319","num":"0346"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ cap = 6.0f"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 6.0f) }, \/\/ location"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ XMFLOAT3( \u22120.6f, \u22120.2f, 3.46f) }, \/\/ tangent"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) },"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) },"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In another example, output position may be 0.0f, 0.0f (cap position), output\u00b7norm may be \u2212sin(lerpedAngle), cos(lerpedAngle), lerp angle with (angle+PI), (1\u2212u)*angle+u*(angle+PI), tangent=cos(lerpedAngle), sin(lerpedAngle), normal=[\u2212tan\u00b7y, tan\u00b7x], and output\u00b7type=cap. For joins, position may be the first vertex. Normal may be the Cartesian representation of the second tangent vector rotated 90 degrees counterclockwise.",{"@attributes":{"id":"p-0321","num":"0348"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ join = 5.0f"]},{"entry":[{},"{ XMFLOAT3( 0.4f, 0.8f, 5.0f) }, \/\/ location"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ XMFLOAT3( 0.8f, 0.0f, 0.0f) }, \/\/ first tangent"]},{"entry":[{},"{ XMFLOAT3( 0.2f, \u22120.2f, 5.5f) }, \/\/ second tangent"]},{"entry":[{},"{ XMFLOAT3( 0.0f, 0.0f, 1.0f) },"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In another example, output position may be 0.4f, 0.8f (join position), output\u00b7norm may be \u2212sin(lerpedAngle), cos(lerpedAngle), lerp first tangent angle with second tangent angle, (1\u2212u)*firstAngle+u*secondAngle, tangent may be=cos(lerpedAngle), sin(lerpedAngle), and normal=[\u2212tan\u00b7y, tan\u00b7x]. The output type may be join.","The example of  may have the illustrated line segments, caps, and joins to feed into geometry shader . In examples without dashing, and in which re-tessellation\/cusps are not needed a single pass method may be used and the inputs discussed below may be sent to geometry shader :","In this example, input coordinates are still two-dimensional. Output will be 4 dimensional (SV_Position). The line type segments in both normal directions at endpoints to create stroke area may be thickened as illustrated in . In some examples, a quad may be determined for which the output may be two triangles. In some other examples, where the curvature is high compared to line length and\/or stroke width is thick, a \u201cbutterfly\u201d may be determined, as illustrated in . In the example, strokewidth is not too high to cause butterflies. In the butterfly case, the center c, and send two triangles (u0, u1, c) and (l0, l1, c) may be found. There may be rare bleeding issue due to t-joints. To eliminate t-joints, two extra triangles: (u0,l0, c) and (u1,l1, c) may be output. These four triangles can be packed into eight vertices using triangle strip primitive type. It may be a rare phenomenon. Some examples may use the two triangle (maxvertices: 6), while other examples may use the 4-triangle (maxvertices: 8) approach.",{"@attributes":{"id":"p-0325","num":"0352"},"figref":["FIGS. 23A-23C","FIG. 23B","FIG. 23C"],"b":"54"},"In an example, the pixel shader may return stroke color. The result may be (round cap\/join used), as illustrated in . For the pixel shader, on single pass solution, the result may be cut locations that may not accurately match , as illustrated in ",{"@attributes":{"id":"p-0327","num":"0354"},"figref":"FIG. 26A-26D","b":["52","1"]},"In an example, a modified tessellator may be used. Caps from first rendering pass will essentially bypass the tessellation on second pass. They go all the way to the GS unchanged. Joins will either be dropped or sent unchanged, depending of if they land on a dash on empty space. In the example, the only join we have lands on a dash are so it is kept. The modified tessellator may cut the line segment according to the dash pattern and re-tessellation delta, using u coordinates. Cut locations are marked with dots, as illustrated in . U coordinates to be sent to domain shader  will be the ratio of cut location distance from starting point divided by the segment length. If a dash cut happens to be longer than re-tessellation delta, we would cut first at the re-tessellation delta length. In other words, no new line segment can be longer than the re-tessellation delta of its parent segment. Set primitive type to be line.","The modified tessellator may then create caps at every cut location using v coordinates. Round caps will be generated in a similar fashion to round caps from the first rendering pass. The modified tesselator may use v coordinates to handle the normal rotation at cap locations. Following illustrates the round cap on the first cut location. Every dash cut location will have a cap. Re-tessellation cuts will not have dashes, as illustrated in  B.","In an example a (DS\u2032) Dash\/Cusp Domain Shader (Line Segment, u, v) may be used. Linear interpretation of normals and positions at tessellation locations may be performed by the Dash\/Cusp Domain Shader. The Dash\/Cusp Domain Shader may convert normals from angular form back to Cartesian form with u is used to lerp position and normal angle and v coordinate is used to rotate the normal, so as to create round cap tessellation as illustrated in . Geometry shader  may use a single pass solution. The pixel shader may use a single pass solution. Result may be cut locations that may not accurately match above illustrations, which are only examples.",{"@attributes":{"id":"p-0331","num":"0358"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0332","num":"0359"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"e","mo":"=","mrow":{"mi":"r","mo":"-","mrow":{"mi":["r","cos"],"mo":["\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mfrac":{"mi":"\u03b8","mn":"2"}}}}}}},"So:",{"@attributes":{"id":"p-0334","num":"0361"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"\u03b8","mo":"=","mrow":{"mrow":[{"mn":"2","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msup":{"mi":"cos","mrow":{"mo":"-","mn":"1"}},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mn":"1","mo":"-","mfrac":{"mi":["e","r"]}}}}},{"mn":"2","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msup":{"mi":"cos","mrow":{"mo":"-","mn":"1"}},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mn":"1","mo":"-","mfrac":{"mi":"p","mrow":{"mn":"2","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mi":"r"}}}}}}],"mo":"="}}}},"br":{}},"The tessellation factor is \u03b1\/\u03b8, where \u03b1 is the angle of the arc.","For an ellipse, the parameterized equation is:\n\n()=(\u00b7sin(\u03b8),\u00b7cos(\u03b8)), assume \n\nIt could be treated as a circle scaled along the x-direction by a factor of a\/b, which is smaller than 1. So it's safe to say that the error of the tessellated ellipse will be smaller than the error of a tessellated circle of radius b using the same tessellation factor. So w the same formula of arc may be used:\n",{"@attributes":{"id":"p-0337","num":"0364"},"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":"\u03b8","mo":"=","mrow":{"mrow":[{"mn":"2","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msup":{"mi":"cos","mrow":{"mo":"-","mn":"1"}},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mn":"1","mo":"-","mfrac":{"mi":["e","r"]}}}}},{"mn":"2","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msup":{"mi":"cos","mrow":{"mo":"-","mn":"1"}},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mn":"1","mo":"-","mfrac":{"mi":"p","mrow":{"mn":"2","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mi":"r"}}}}}}],"mo":"="}},"mo":","}}}},"where r=max(a, b)","In another example, the tessellation factor for cubic and quadratic Bezier curves may be found. Quadratic curves can be converted to cubics before processing. A technique called subdividable linear efficient variety enclosure (SLEVEs) may be used to estimate the tessellation factor of cubic curves, as illustrated in .","Given a polynomial function and the number of segments (tessellation factor), SLEVEs can efficiently compute a piecewise linear bound of the curve with uniform knots. So with SLEVEs we can estimate the error of the piecewise linear approximation of a curve. In addition, SLEVEs guarantee that as the tessellation factor increase, the bounding width (error) will decrease quadratically. So given a required error, we can estimate a safe tessellation factor. The whole algorithm follows:\n\n",{"@attributes":{"id":"p-0341","num":"0371"},"maths":{"@attributes":{"id":"MATH-US-00005","num":"00005"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":"t","mn":"0"},"mo":"\u00d7","msqrt":{"mfrac":{"mi":["w","e"]}}}}}},"For more detail about the computing of SLEVEs and its error, please refer to these 2 papers: Efficient Pixel-Accurate Rendering of Curved Surfaces. Young In Yeo, Lihan Bin and J\u00f6rg Peters, 13D 2012 and Mid-structures of subdividable linear efficient function enclosures linking curved and linear geometry. PETERS, J. 2004. In Proceedings of SIAM conference, Seattle, November 2003, each of which is incorporated herein by reference.","Tessellation factor for Stroke for Arc and Ellipse, may simply add the stroke width to the radius to calculate the tessellation factor. For Cubic, the stroke line is no longer a polynomial curve. It has square root and it's a rational function. So we can no longer using SLEVEs to bound it. Actually, theoretically there may not exist a big enough tessellation factor for cubic. Imagine a cubic with a sharp cusp, where the normal is no longer continuous through the curve. For this case not matter what tessellation factor we set the error will be big. In our implementation, in order to solve this problem, we re-tessellate the curve and interpolate the normal if we found the two normal at the endpoints of a segment is too different. We think this also will help in other case even if we don't have a safe tessellation factor, so for stoke we use the same tessellation factor as filling.","Comparing the optimal tessellation to reference implementation, in the conformance test, the reference implementation uses a fixed tessellation factor 256 for all curves, which is very high considering all the test case is smaller than 64 by 64 pixel. In our implementation, a fixed tessellation factor 64 can pass all the tests.","After applying the above optimized tessellation factor estimation with required error equals to half pixel size, much smaller tessellation factor in most of the conformance test are calculated. In some cases the test may be failed because the small bounded error doesn't guarantee the output to be exactly same. It can only guarantee the difference will be no more than 1 pixel along the boundary. Consider the illustration of .","For the lower right pixel, the center of the pixel sits right between the real curve and the tessellated curve. So the output will have 1 pixel difference. We try to decrease the required error from half pixel to \u215b a pixel and we pass almost all the test case (only for one test case we fail by one pixel).","In addition to smaller tessellation factor, the optimized tessellation factor can adaptively change to guarantee the render quality when use zoom in, which cannot be achieved by fixed tessellation factor. So if there is a curve that requires more than 256 tessellated line segments to be pixel-accurate, we will actually beat the reference implementation.",{"@attributes":{"id":"p-0348","num":"0378"},"figref":["FIGS. 31-34","FIG. 31"]},"As illustrated in , an example may include re-tesselation on these line segments to correct this problem. In the example, a maximum angular deviation in normals determines the re-tessellation level. Then the line length may be divided by this re-tessellation level to find the length of the desired re-tessellated lines (tessDelta). New normal are found by linear interpolating angular representation of the endpoint normals, then converting back to Cartesian representation.","In the example line segments may also be according to a dash pattern, as illustrated in . By start cutting according to the dash pattern, but if a new line segment is larger than \u2018tessDelta\u2019, it is cut at \u2018tessDelta\u2019 lengths too as illustrated in .",{"@attributes":{"id":"p-0351","num":"0381"},"figref":"FIG. 35","b":["12","1000","12","1002","12","1004","12","1006","12","1008"]},"In some examples, the first plurality of primitives and the second plurality of primitives may be the same primitives. The plurality of primitives may include a plurality of line segments. Additionally, the path segment comprises one of a line, an elliptic arc, a quadratic B\u00e9zier curve and a cubic B\u00e9zier curve.","In an example, the GPU  may further be configured to determine how a graphical shape with more than one closed outline will be filled based on an odd-even rule. The odd-even rule determines if a point should be considered inside by drawing a ray from the point to infinity in any direction and counting the number of path segments from the given shape that the ray crosses, if the number of path segments is odd the point is considered inside the curve, if the number of path segments is even the point is considered outside the curve.","GPU  may determine how a graphical shape with more than one closed outline will be filled based on a non-zero rule. The non-zero winding rule determines the direction of stroke for each part of the curve, for a given curve C and a given point P, the non-zero winding rule determines if a point should be considered inside by (1) construct a straight line out from P in any direction towards infinity, (2) find all the intersections of C with this ray, and (3) score up the winding number and wherein scoring the winding number includes: (1) for every clockwise intersection, the curve passing through the ray from left to right, as viewed from P, subtract 1, (2) for every counter-clockwise intersection, curve passing from right to left, as viewed from P, add 1, if the total winding number is zero, P is outside C, otherwise, it is inside.",{"@attributes":{"id":"p-0355","num":"0385"},"figref":"FIG. 36","b":["12","1050","12","1052","12","1054","12","1056"]},"The techniques described in this disclosure may be implemented, at least in part, in hardware, software, firmware or any combination thereof. For example, various aspects of the described techniques may be implemented within one or more processors, including one or more microprocessors, digital signal processors (DSPs), application specific integrated circuits (ASICs), field programmable gate arrays (FPGAs), or any other equivalent integrated or discrete logic circuitry, as well as any combinations of such components. The term \u201cprocessor\u201d or \u201cprocessing circuitry\u201d may generally refer to any of the foregoing logic circuitry, alone or in combination with other logic circuitry, or any other equivalent circuitry such as discrete hardware that performs processing.","Such hardware, software, and firmware may be implemented within the same device or within separate devices to support the various operations and functions described in this disclosure. In addition, any of the described units, modules or components may be implemented together or separately as discrete but interoperable logic devices. Depiction of different features as modules or units is intended to highlight different functional aspects and does not necessarily imply that such modules or units must be realized by separate hardware or software components. Rather, functionality associated with one or more modules or units may be performed by separate hardware, firmware, and\/or software components, or integrated within common or separate hardware or software components.","The techniques described in this disclosure may also be stored, embodied or encoded in a computer-readable medium, such as a computer-readable storage medium that stores instructions. Instructions embedded or encoded in a computer-readable medium may cause one or more processors to perform the techniques described herein, e.g., when the instructions are executed by the one or more processors. Computer readable storage media may include random access memory (RAM), read only memory (ROM), programmable read only memory (PROM), erasable programmable read only memory (EPROM), electronically erasable programmable read only memory (EEPROM), flash memory, a hard disk, a CD-ROM, a floppy disk, a cassette, magnetic media, optical media, or other computer readable storage media that is tangible.","Computer-readable media may include computer-readable storage media, which corresponds to a tangible storage medium, such as those listed above. Computer-readable media may also comprise communication media including any medium that facilitates transfer of a computer program from one place to another, e.g., according to a communication protocol. In this manner, the phrase \u201ccomputer-readable media\u201d generally may correspond to (1) tangible computer-readable storage media which is non-transitory, and (2) a non-tangible computer-readable communication medium such as a transitory signal or carrier wave.","Various aspects and examples have been described. However, modifications can be made to the structure or techniques of this disclosure without departing from the scope of the following claims."],"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIGS. 18A and 18B"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIGS. 20A-20Z"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIGS. 21A-21D"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIGS. 22A-22B"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIGS. 23A-23C"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIGS. 26A-26C"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 32"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 33"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 34"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 35"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 36"}]},"DETDESC":[{},{}]}
