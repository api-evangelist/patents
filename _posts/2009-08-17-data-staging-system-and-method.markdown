---
title: Data staging system and method
abstract: A data staging system comprises an inbound staging area, data conversion logic, and a graphical user interface. The inbound staging area is configured to receive data records from a data sending computer system, including being configured to receive different versions of the same record. The inbound staging area stores the different versions of the same record pending further processing. The data conversion logic is configured to perform the further processing. The further processing reduces the number of different versions of the same record. The graphical user interface logic is configured to generate a display showing the records in the inbound staging area.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08311987&OS=08311987&RS=08311987
owner: SAP AG
number: 08311987
owner_city: Walldorf
owner_country: DE
publication_date: 20090817
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF EXAMPLE EMBODIMENTS"],"p":["The same data is often stored at multiple locations. For example, a sending computer system (e.g., a master data system) may send data to a receiving computer system (e.g., a data consuming computer system that uses master data received from the master data system) to enable the receiving computer systems to perform various tasks (e.g., sales forecasting and so on).","Typically, such systems exchange data incrementally (i.e. exchange only changed attributes of an object). Sometimes, for example, during a remote function call made by the data receiving system, data that is sent by the master data system is never received by the receiving computer system. Consequently, the receiving computer system becomes out of synch with the sending computer system. Errors at the receiving computer system then need to be resolved to bring the receiving computer system back into synch with the sending computer system.","Example embodiments of the present invention relate to a data staging system that comprises an inbound staging area, data conversion logic, and a graphical user interface. The inbound staging area is configured to receive data records from a data sending computer system, including being configured to receive different versions of the same record. The inbound staging area stores the different versions of the same record pending further processing. The data conversion logic is configured to perform the further processing. The further processing reduces the number of different versions of the same record. The graphical user interface logic is configured to generate a display showing the records in the inbound staging area.","Example embodiments of the present invention relate to a method comprising receiving a record from a sending computer and processing the record at a receiving computer. The processing includes storing the record in an inbound staging table of an inbound staging area. The inbound staging table is one of a plurality of inbound staging tables in the inbound staging area. The record is one of a plurality of records stored in the plurality of inbound staging tables. Each of the plurality of records has a timestamp associated therewith. The processing further includes sorting the plurality of records in the plurality of inbound staging tables based on the timestamps and deleting older records. The processing further includes providing a graphical user interface to a user, the graphical user interface permitting the user to view details of messages in the inbound staging area.","Referring to , a data processing system  according to an example embodiment is shown. The data processing system  includes a plurality of sending computer systems  and a receiving computer system . The sending systems  may, for example, be master data systems and the receiving computer system  may, for example, be a data consuming computer system that uses master data received from the systems  to perform various tasks (e.g., sales forecasting and so on). For purposes of providing an example, it is assumed herein that the data relates to stores and to products sold by the stores at various locations. It is also assumed that the systems  and  are operated by the same entity, such that a user resolving errors may be assumed to have access to both systems  and . As will be appreciated, the data receiving systems  can also act as data sending systems , which send data to other data receiving systems. Other configurations are also possible.","In an example embodiment, the data records are transmitted in the form of service data objects. Each object that is sent comprises a unique key, a sender ID, and a key time stamp. The unique key uniquely identifies a data object and may comprise one or more segments. As described in greater detail below, the sender ID and the key time stamp enable more than one version of the same object to exist within the receiving system . The sender ID identifies the sending system , thereby permitting objects from different sending systems  to have the same identification (i.e., the same name). The key timestamp is a unique point in time, which identifies the sending date and time for the concerned object. The key timestamp may be a high resolution timestamp with multiple (e.g., six) decimal points of accuracy.","The sending systems  transmit data to the receiving system  using messages. The message for an object instance may comprise several parts including the object instance and dependant data. One part of the message is the main message of an object and the other parts are sub messages of an object. For example, the main message of a product object may contain a product identifier (e.g., product code or article number, etc) and a sub message of a product may contain the data for the different unit of measures. For example, in , discussed below, an example of a main message type may be location and examples of sub message types may be address data, hierarchy assignments, and text data. Thus, the unique key of the sub message of an object includes the key segments of the main message and additional following key segments for the sub message types. By modeling the description data of an object in such a way, it is possible to implement a generic and unified handling of different message types.","Each message that is sent by the sending systems  has a function code (I-insert, U-update, D-delete). When the data sending systems  transmit data for an object, the complete data record for the concerned object is sent (i.e., not just the changed attributes). Specifically, for insert and update operations, the sending system  sends the complete object instance (i.e., all the data of an object instance). For purposes of the receiving system , during inbound processing, the insert and update operations may be handled identically, although the sending system  may distinguish between the two types of operations. In the case that dependent data (e.g., unit of measure data) is sent, the complete data of an object instance (the data of the main message plus the dependent data for the unit of measure) is also sent. This only applies in cases where dependent data has changed. Thus, if data for one unit of measure has changed, but data for two other units of measure has not changed, then only the data of the main message and the data for the unit of measure that has changed is sent. For delete operations, it may be considered sufficient for the data sending system  to send only the object identifier, that is, the unique identification of an object instance. As will become apparent below, such full record processing permits data to be consolidated in the data receiving system , since the complete and current record is sent. Such full record processing also leads to a self-healing process for the data within the receiving system . That is, whenever a single field for an object of a failed data package is changed, all the data gaps of that object which might have been caused by missing data packages (e.g. due to remote function call errors) are eliminated without explicitly resending the missing packages.","The receiving system  further comprises a persistence layer , a business application layer , and an inbound staging layer . The persistence layer  stores data objects  accessed by business logic in the business application layer . The business application layer  comprises the business logic that operates on the data objects  stored by the persistence layer . The business application layer  further includes application programming interfaces  used to receive data from the inbound staging layer  and to communicate with the persistence layer . The business application layer  contains logic for creating, updating, deleting, and validating data received from the inbound staging layer .","The business application layer  distinguishes between insert and update operations, as previously noted. Hence, for an update record, it is checked (by the consuming business object) whether the object already exists. If it does exist, then it is a real update, otherwise it is an insert. Also, for an insert record it is checked (by the consuming business object) whether the object already exists. If it does exist, then it is an update, otherwise it is a real insert.","The inbound staging layer  is a data staging area that permits multiple versions of a data object to exist concurrently in the receiving system . The inbound staging layer  comprises inbound remote function calls , inbound staging tables , data conversion logic , and user interface logic . The remote function calls  receive incoming data from the data sending systems . The staging tables  are coupled to the remote function calls and store the incoming data. When the messages are received, the messages are appended to the inbound staging tables . The messages stored at each of the staging tables  may include different types of objects and different versions of the same object. Only inserts into the inbound staging tables  are performed (with the already mentioned high resolution time stamp field filled by the sending system). This timestamp represents the point in time of assembling changed object instances to a package. All object instances within a package will have a high resolution time stamp, as previously described. Additionally, two administrative fields are included with every data record in inbound staging tables . The first field is a Processing Status field, with possible values for the Processing Status field being not processed (N), error (E), and in process (P). The second field is a Processing Function field, with possible values for the Processing Function field being insert (I), update (U) and delete (D). When the data of an object is initially received, the data is stored in the inbound staging tables  without any validation. The data of an object is checked and validated during the data storage process which is triggered by the data conversion.","The data conversion logic  packages and compresses the objects stored in the inbound staging tables  to produce business objects for the business application layer . The operation of the data conversion logic  is discussed in greater detail below in connection with . The user interface logic  provides a user with a monitor view into the inbound staging layer . The user interface logic  is described in greater detail below in connection with .","In the arrangement described above, it is not necessary to read existing interface records during inbound processing. Additionally, the inbound history of objects is stored until the next processing of data, facilitating manual error processing as discussed below. Additionally, data import (mere inserts into interface tables) is decoupled from data processing into application database tables (Business Objects (BO)). Additionally, there is improved data consistency, because the full record processing eliminates all the data gaps of that object which might have been caused by missing data packages (e.g. due to remote function call errors) without explicitly resending the missing packages. For the same reason, error processing is simplified, because data inconsistencies do not have to be reported to the sender.","Referring now to ,  is a flowchart showing processing of inbound records in the system of . As previously noted, the messages stored at each of the staging tables  may include different types of objects and different versions of the same object.  shows the processing data from the staging tables  into the corresponding business objects. In the process of , packages are built for each message type. Each package corresponds to one message type, so that all of the messages (including sub messages) for a given object are contained in one package. For example, with reference to , if the main message type is \u201clocations\u201d and the sub message types are \u201caddress data,\u201d \u201chierarchy assignments,\u201d and \u201ctext data,\u201d there is one package built that contains the messages for the main message and sub message types. Further, all records for the same object are processed within the same package, though not necessarily all objects of the same message type are processed within the same package. For example, if there are five locations (A, B, C, D and E), and if for every location there exists three update entries in the staging tables  for the main object (location), then there are fifteen total messages (A, A, A, B; B, B, C, C, C, D, D, D, E, E, E) in the staging tables . However, all fifteen messages are not necessarily processed in the same package (e.g., A, A, A, B; B, B, C, C, and C may be processed in one package and D, D, D, E, E, E may be processed in another package). Hence, there may be more than one package for a particular message type. Again, if there are additional sub messages (e.g., A(), A() and A() corresponding to address data, hierarchy assignments, and\/or text data for location A), the sub messages are processed within the same package as the update entries (A, A, A) in the staging tables  for the main object (location) for location A.","At step , a configuration of the message type processing sequence is determined. The processing of the different message types in the different inbound staging tables  into the respective business objects is performed in a predefined sequence. For example, it may not be possible to process a product location object for a non-existing location object or a non-existing product object. Determining the correct sequence permits such object dependencies to be taken into account.","The configuration of the message type processing sequence may be determined by accessing a configuration table which stores the correct sequence. For every inbound message type, the configuration table holds a sequence number which defines the order of processing of the message types.","At steps -, the processing of the different inbound staging tables  into the respective business objects is performed. The processing is controlled by a supervising process. The supervising process reads the information from the configuration table and starts corresponding processes  . . . as parallel tasks, where m is the maximum number of available tasks for parallel processes. The parallel processes may be used to process different objects of the same message type (e.g., objects for different locations A, B, C, D and E in the above example). Likewise, the parallel processes may also be used to process objects from another message type which have the same sequence number (e.g. location and product). At steps -, each parallel task performs a package building on the corresponding records of the main message type by assigning a sequence number  . . . P to every record within the inbound staging table , where P is the number of different message types. After having assigned sequence numbers  . . . P to every record within the inbound staging table , these sequence numbers are provided (together with the message type) to a dispatching process, which takes over the control for processing the corresponding message type. This dispatching process starts the parallel processes (which are responsible for processing the data from the inbound staging tables  into the corresponding business objects) by assigning every process the message type and a sequence number from the set  . . . P of sequence numbers. This process iteratively proceeds through each message type in the sequence (steps , , , and ) until the last message type is reached (step ).","Whenever interface processing for a message type (object) is started, it is ensured that all interface records for this message type are processed regardless of their processing status (i.e. not only new records but also error records are also read). With the approach of appending records to fill the interface tables (instead of update), there can be an error record (for example) and one or more new records for the same object. All records are considered together, i.e., error records are not ignored when the next interface inbound processing run is started.","Also, as previously indicated, all records for the same message type object are condensed and processed within the same task to avoid inconsistencies. Therefore, if the currently processed staging table still contains more records and it is necessary to create further package(s), the records for the last message type object are processed in the next package. Thus, while all records for the same object may be processed within the same package, all objects of the same message type are not necessarily processed within the same package. For example, if there are five locations (A, B, C, D and E), and if for every location there exists three update entries in the staging tables  for the main object (location), then there are fifteen total messages (A, A, A, B; B, B, C, C, C, D, D, D, E, E, E) in the staging tables . If the maximum package size is ten, for example, then the first nine entries (A, A, A, B; B, B, C, C, C) are placed in the first package. When the next entry (D) is read, it is placed into the next package to accommodate the fact that there may be (and, in fact, are in this example) additional entries for location D. By placing D in the next package, it is ensured that have to put it into the next package to make sure, that D, D and D are processed together. As a consequence of this the number of processed objects N is always lower or equal the package size S, i.e. N<=S. The total number of needed packages (P) can be calculated as follows:\n\n=round()+1.\n\nwhere T is the total number of records within a database table and S is the package size.\n","Referring now to ,  is a flowchart showing a compression algorithm applied to inbound records in the system of . The compression algorithm is applied after the process shown in . As previously indicated, the staging tables  may contain several records for the same object key with different high-resolution time stamps. These records can be set to different function codes, e.g. a DELETE can follow on an UPDATE function code. To avoid unnecessary operations, it is desirable to condense all records for the same objects to one record for the call business object layer, considering all records for the message type.","In case of mere insert and update records, the merge logic during the processing of the interface records can be a simple sort by object key (i.e. the logical key of a record) and time stamp. It is sufficient to post the most recent (header) record of an object to the receiving business object. The dependent records that are linked to the main object are considered all together and may be posted together with the main record. The merging of dependent interface records consists of collecting the dependent data. (In the case of an error during processing of a main record which results in processing status \u2018E\u2019, the processing status \u2018E\u2019 is attached to all dependent data of this main record.) The actual merge is performed afterwards within the receiving business objects.","The process of  is applied to a single inbound staging table  and repeated for each of the inbound staging tables . At step , the main object is processed. At step , the entries of the staging table  are sorted by time stamp and object key. At steps -, the following merge and consolidation logic (for the main records) applies for the point in time t and t (t>t):\n\n","In the case that there is a deletion record which is followed by an insert\/update record, the consuming business object insures that the dependent data is actually deleted before an insert of the new data for the same object instance is performed.","After the processing of the interface tables, the inbound staging tables  are cleaned up depending on the result of the interface processing of each record. For example, successfully processed records are deleted from the inbound staging tables . In case an error occurs, the (consolidated) interface record for the associated object is set to status \u2018E\u2019 and no deletions occur. This allows identification of those objects that could not be updated. Assigned error messages may provide hints on how to adjust certain data inconsistencies which prevented the data from being posted (e.g. certain missing master data that are mandatory for the corresponding object). (A corresponding user interface is described below in connection with .) The \u2018E\u2019-objects are picked up during the next interface processing run (due to automatic processing of error records).","Basic error handling may be included. For example, whenever a message type is processed, the interface error record(s) of the associated message type are considered in each follow up processing step. Hence, if a record for an object has status \u2018E\u2019 (error), it is read and processed automatically whenever new records for the same message type are processed. Thus, if errors exist for some records or for dependent objects of some records, the inbound staging layer  creates error messages for such records and sets the processing status of the records to \u2018E\u2019 (error). The records with errors then remain in the staging tables . During the next inbound process for a message type, all the entries in the staging tables  for this message type with processing status new and erroneous are processed. For example, if an error occurs during the processing of a dependent object, then a subsequent update of the dependent object will either correct the error or encounter the same error thereby leading to a new error message. In the latter scenario, the processing type of the new staging table entry is set to \u2018E\u2019 (error) again. The first staging table record which has caused the first error is deleted, because it is condensed with the new record during processing. Thus, the error messages and the processing state reflects the current status for the staging table entries. Processing the records with errors brings them into a consistent state and minimizes the risk that old data may overwrite more recent data.","Referring now to , the user interface provided by user interface logic  for the inbound staging layer  is shown in greater detail. Specifically,  show a connectivity workbench provided by a user interface logic  in the system of . The processing of messages in the inbound staging layer  is initiated responsive to manual inputs received from a user. When the workbench is started, the number of entries in each respective inbound staging table  is determined. The user interface permits a user to supervise and control the data flow through the inbound staging layer .","Referring first to , in the screen display of , the user is provided with an overview of the messages in the inbound staging layer . The display comprises field , field , and field , which are shown in greater detail in , , and , respectively.","Referring now to ,  shows message type tree field  of the connectivity workbench of  in greater detail. Field  comprises a table  in which each row  corresponds to a different message type or sub message type for messages stored inbound staging layer . Column  indicates the message type shown in a particular row. Column  is displayed as a tree broken out into various message and sub-message types. As previously described, a configuration table (not shown) stores the message types for the inbound staging layer . For each message type, column  indicates error status (i.e., whether any messages have errors), column  indicates the total number of messages of that message type, column  indicates the total number of messages that have not been processed, column  indicates the total number of messages with errors, and column  indicates the total number of messages that are currently being processed. The indicators in column  may be color coded, for example, based on whether any messages of that message type have errors (i.e., a non-zero value in column ).","To display more information about a specific message type , the user may click on information in the respective row for the message type  (e.g., the total number of messages in column  or a status dependent number in columns -). When the user selects a specific message type , field  in  is built according to the structure of the staging table  for the selected message type and filled with the content of the staging table .","Referring now to ,  shows message type detail field  of the connectivity workbench of  in greater detail. Field  comprises a table  showing details of messages of the selected message type. Various buttons and tools - are provided for manipulating the display and the information that is displayed. The number of entries on one page of the display may be limited to enhance performance. Buttons  permit the user to page forward or backward on the display. Cursor  permits the page size to be changed. A display button  causes a new window to be opened, where the data of a selected record is displayed in a list. Buttons  and  permit additional information about exceptions and sub messages to be displayed, as described below. A sort and filter tool  permits the user to sort entries of the table by a single field and specify filters (e.g., up to ten different parallel filters may be applied at one time). By using range tables for the filter handling, wildcards (*) are also possible. Sort and filters always are applied to all entries of the database staging table (status will also be mentioned), not just to the displayed ones (i.e., the filter is not applied at the front end, but rather at the back end).",{"@attributes":{"id":"p-0043","num":"0044"},"figref":["FIG. 7","FIG. 6","FIG. 6","FIG. 7","FIG. 5"],"b":["720","720","618"]},{"@attributes":{"id":"p-0044","num":"0045"},"figref":["FIG. 8","FIG. 7","FIG. 7","FIG. 8"]},{"@attributes":{"id":"p-0045","num":"0046"},"figref":["FIG. 9","FIG. 4","FIG. 9","FIG. 8","FIG. 9"]},{"@attributes":{"id":"p-0046","num":"0047"},"figref":["FIG. 10","FIG. 4","FIG. 10"],"b":["476","476"]},{"@attributes":{"id":"p-0047","num":"0048"},"figref":["FIG. 11","FIG. 4","FIG. 11"],"b":["478","478"]},"The user interface logic  is generic and can handle new message types. When enhancing the inbound staging layer  with a new message type, it is not necessary to enhance (rework) the user interface logic . All dialogs of the user interface logic  are dynamically rendered. All underlying needed structures (e.g. for displaying different tables) are created at runtime. There exists one central configuration table, which holds all needed information for a message type. Whenever new message types have to be considered within the inbound staging layer , only additional entries into the configuration table are necessary.","The embodiments of the present invention have been described with reference to drawings. The drawings illustrate certain details of specific embodiments that implement the systems and methods and programs of the present invention. However, describing the invention with drawings should not be construed as imposing on the invention any limitations that may be present in the drawings. The present invention contemplates methods, systems and program products on any machine-readable media for accomplishing its operations. The embodiments of the present invention may be implemented using an existing computer processor, or by a special purpose computer processor incorporated for this or another purpose or by a hardwired system.","As noted above, embodiments within the scope of the present invention include program products comprising machine-readable media for carrying or having machine-executable instructions or data structures stored thereon. Such machine-readable media may be any available media that may be accessed by a general purpose or special purpose computer or other machine with a processor. By way of example, such machine-readable media may comprise RAM, ROM, EPROM, EEPROM, CD-ROM or other optical disk storage, magnetic disk storage or other magnetic storage devices, or any other medium which may be used to carry or store desired program code in the form of machine-executable instructions or data structures and which may be accessed by a general purpose or special purpose computer or other machine with a processor. Thus, any such a connection is properly termed a machine-readable medium. Combinations of the above are also included within the scope of machine-readable media. Machine-executable instructions comprise, for example, instructions and data which cause a general purpose computer, special purpose computer, or special purpose processing machines to perform a certain function or group of functions.","Embodiments of the present invention have been described in the general context of method steps which may be implemented in one embodiment by a program product including machine-executable instructions, such as program code, for example in the form of program modules executed by machines in networked environments. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. Machine-executable instructions, associated data structures, and program modules represent examples of program code for executing steps of the methods disclosed herein. The particular sequence of such executable instructions or associated data structures represent examples of corresponding acts for implementing the functions described in such steps.","As previously indicated, embodiments of the present invention may be practiced in a networked environment using logical connections to one or more remote computers having processors. Those skilled in the art will appreciate that such network computing environments may encompass many types of computers, including personal computers, hand-held devices, multi-processor systems, microprocessor-based or programmable consumer electronics, network PCs, minicomputers, mainframe computers, and so on. Embodiments of the invention may also be practiced in distributed computing environments where tasks are performed by local and remote processing devices that are linked (either by hardwired links, wireless links, or by a combination of hardwired or wireless links) through a communications network. In a distributed computing environment, program modules may be located in both local and remote memory storage devices.","An exemplary system for implementing the overall system or portions of the invention might include a general purpose computing computers in the form of computers, including a processing unit, a system memory or database, and a system bus that couples various system components including the system memory to the processing unit. The database or system memory may include read only memory (ROM) and random access memory (RAM). The database may also include a magnetic hard disk drive for reading from and writing to a magnetic hard disk, a magnetic disk drive for reading from or writing to a removable magnetic disk, and an optical disk drive for reading from or writing to a removable optical disk such as a CD ROM or other optical media. The drives and their associated machine-readable media provide nonvolatile storage of machine-executable instructions, data structures, program modules and other data for the computer. It should also be noted that the word \u201cterminal\u201d as used herein is intended to encompass computer input and output devices. User interfaces, as described herein may include a computer with monitor, keyboard, a keypad, a mouse, joystick or other input devices performing a similar function.","It should be noted that although the diagrams herein may show a specific order and composition of method steps, it is understood that the order of these steps may differ from what is depicted. For example, two or more steps may be performed concurrently or with partial concurrence. Also, some method steps that are performed as discrete steps may be combined, steps being performed as a combined step may be separated into discrete steps, the sequence of certain processes may be reversed or otherwise varied, and the nature or number of discrete processes may be altered or varied. The order or sequence of any element or apparatus may be varied or substituted according to alternative embodiments. Accordingly, all such modifications are intended to be included within the scope of the present invention. Such variations will depend on the software and hardware systems chosen and on designer choice. It is understood that all such variations are within the scope of the invention. Likewise, software and web implementations of the present invention could be accomplished with standard programming techniques with rule based logic and other logic to accomplish the various database searching steps, correlation steps, comparison steps and decision steps.","The foregoing description of embodiments of the invention has been presented for purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed, and modifications and variations are possible in light of the above teachings or may be acquired from practice of the invention. The embodiments were chosen and described in order to explain the principals of the invention and its practical application to enable one skilled in the art to utilize the invention in various embodiments and with various modifications as are suited to the particular use contemplated. Other substitutions, modifications, changes and omissions may be made in the design, operating conditions and arrangement of the embodiments without departing from the scope of the present invention.","Throughout the specification, numerous advantages of the exemplary embodiments have been identified. It will be understood of course that it is possible to employ the teachings herein without necessarily achieving the same advantages. Additionally, although many features have been described in the context of a particular data processing unit, it will be appreciated that such features could also be implemented in the context of other hardware configurations.","While the exemplary embodiments illustrated in the figures and described above are presently preferred, it should be understood that these embodiments are offered by way of example only. Other embodiments may include, for example, structures with different data mapping or different data. The invention is not limited to a particular embodiment, but extends to various modifications, combinations, and permutations that nevertheless fall within the scope and spirit of the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0008","num":"0007"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0009","num":"0008"},"figref":["FIG. 4","FIG. 1"]},{"@attributes":{"id":"p-0010","num":"0009"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 6","FIG. 4"]},{"@attributes":{"id":"p-0012","num":"0011"},"b":"1","figref":["FIG. 7","FIG. 6"]},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 8","FIG. 7"]},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 9","FIG. 4"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 10","FIG. 4"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 11","FIG. 4"]}]},"DETDESC":[{},{}]}
