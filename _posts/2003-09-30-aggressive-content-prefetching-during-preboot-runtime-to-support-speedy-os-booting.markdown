---
title: Aggressive content pre-fetching during pre-boot runtime to support speedy OS booting
abstract: A method and system for content pre-fetching during a processing system pre-boot runtime. First, it is determined when a processor of a processing system is in one of a busy wait state and an idle state during a pre-boot runtime of the processing system. Then, content is pre-fetched from a data storage unit of the processing system. The content is pre-fetched based upon a pre-fetch profile. The content is loaded into system memory of the processing system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07127600&OS=07127600&RS=07127600
owner: Intel Corporation
number: 07127600
owner_city: Santa Clara
owner_country: US
publication_date: 20030930
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND INFORMATION","DETAILED DESCRIPTION"],"p":["This disclosure relates generally to content pre-fetching, and in particular, relates to content pre-fetching during a pre-boot runtime to support speedy operating system booting.","In the field of computers, there has been a long felt need to reduce the boot time of computers. In fact, waiting for a computer to boot is an irritating nuisance almost universally acknowledged by all computer users.","One reason for extended pre-boot runtimes are wasted processing cycles. Typically, during the pre-boot runtime the processor is executing in a single threaded environment. As such, the processor spends a considerable amount of time simply waiting or idle. For example, when initializing a keyboard controller, the processor sends instructions to the keyboard controller to commence its initialization and then \u201cbusy\u201d waits for the keyboard controller to complete. As mentioned, the typical pre-boot environment is single threaded. Therefore, during this busy wait period the processor does not proceed to the next execution task, but rather, waits until the keyboard controller completes its initialization.","During the pre-boot runtime, the processor spends a considerable amount of time (e.g., 70%) busy waiting for any number of hardware devices, such as waiting for the hard disk drive to return requested data, waiting for input\/output (\u201cI\/O\u201d) ports, and the like. Furthermore, considerable time is lost busy waiting for user inputs (e.g., logon ID and password). All this busy waiting constitutes wasted processing power.","Embodiments of a system and method for aggressive content pre-fetching during a pre-boot runtime to support speedy operating system (\u201cOS\u201d) booting are described herein. In the following description numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize, however, that the invention can be practiced without one or more of the specific details, or with other methods, components, materials, etc. In other instances, well-known structures, materials, or operations are not shown or described in detail to avoid obscuring aspects of the invention.","Reference throughout this specification to \u201cone embodiment\u201d or \u201can embodiment\u201d means that a particular feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus, the appearances of the phrases \u201cin one embodiment\u201d or \u201cin an embodiment\u201d in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore, the particular features, structures, or characteristics may be combined in any suitable manner in one or more embodiments.","Throughout this specification, several terms of art are used. These terms are to take on their ordinary meaning in the art from which they come, unless specifically defined herein or the context of their use would clearly suggest otherwise. \u201cBusy waiting\u201d is defined herein as the act of intentionally stalling a processor or causing the processor to repeat a simple task for the purpose of waiting.","In short, embodiments of the present invention include a system and method to advantageously use the busy waiting periods and\/or idle time during the pre-boot runtime to pre-fetch content from data storage units into system memory. Additionally, embodiments of the present invention include a system and method to determine which content should be pre-fetched during the busy wait periods. These and other embodiments are described in detail below.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1","b":["100","100","105","110","115","120","125","130"]},"The elements of processing system  are interconnected as follows. Processor  is communicatively coupled to system memory , NV memory , HDD , and communication link , via chipset  to send and to received instructions thereto\/therefrom. In one embodiment, NV memory  is a flash memory device. In other embodiments, NV memory  includes any one of read only memory (\u201cROM\u201d), programmable ROM, erasable programmable ROM, electrically erasable programmable ROM, or the like. In one embodiment, system memory  includes random access memory (\u201cRAM\u201d). In one embodiment, communication link  includes a network interface card (\u201cNIC\u201d). HDD  may optionally include one or more of an integrated drive electronic (\u201cIDE\u201d) hard disk, an enhanced IDE (\u201cEIDE\u201d) hard disk, a redundant array of independent disks (\u201cRAID\u201d), a small computer system interface (\u201cSCSI\u201d) hard disk, and the like. Although HDD  is illustrated as internal to processing system ; however, HDD  may be external coupled to processing system .","It should be appreciated that various other elements of processing system  have been excluded from  and this discussion for the purposes of clarity. For example, processing system  may further include a graphics card or additional HDDs or other persistent data storage devices (e.g., tape drive). Chipset  may also include a system bus and various other data buses for interconnecting subcomponents, such as a memory controller hub and an input\/output (\u201cI\/O\u201d) controller hub, as well as data buses for connecting peripheral devices to chipset .",{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 2","FIG. 3","FIG. 3","FIG. 3"],"b":["200","200","200","301","301","100","120","115","115","301","305","315","320","325","330"]},"Returning to , in a process block , processing system  is power cycled. Power cycling processing system  includes a reset event or a power on event. In a processing block , processing system  executes early system initialization tasks. Typically, early system initialization includes tasks such as a power on self test (\u201cPOST\u201d), discovering memory resources (e.g., system memory , NV memory ), initializing the memory resources, discovering platform hardware, initializing the platform hardware, and the like.","In a decision block , profiler  determines whether a profile variable  is set. In short, profiler  acts to create a pre-fetch profile , as described below. Profiler  is enabled if profile variable  is set. Typically, profiler  will be initially stored in NV memory  and transferred into system memory  during operation of processing system . In one embodiment, profiler  is loaded into system memory  in response to profile variable  being set. Alternatively, profiler  may be stored in any persistent data storage device, such as HDD . Furthermore, profiler  may be executed directly from NV memory  or HDD , though doing so may considerably slow down execution of process . In one embodiment, pre-fetch variable  is a variable having one of two states (e.g., set and clear) stored within NV memory . In other embodiments, profile variable  is stored within any persistent memory device coupled to processor . If profile variable  is set, process  continues to a process block .","In process block , application program  or OS loader  requests I\/O agent  to load content  stored on DSU  into system memory . I\/O agent  is a software\/firmware I\/O interface between various hardware components of processing system  and software\/firmware modules executing thereon. Software\/firmware applications (e.g., application program , OS loader , etc.) use the services provided by I\/O agent  to transfer data or files from one location within processing system  to another.","In one embodiment, I\/O agent  is a block I\/O executing within an extensible firmware framework standard known as the Extensible Firmware Interface (\u201cEFI\u201d). EFI is a public industry specification that describes an abstract programmatic interface between platform firmware and shrink-wrap operating systems or other custom application environments. The EFI framework standard includes provisions for extending basic input output system (\u201cBIOS\u201d) code functionality beyond that provided by the BIOS code stored in a platform's boot firmware device (e.g., NV memory ). More particularly, EFI enables firmware, in the form of firmware modules and drivers, to be loaded from a variety of different resources, including primary and secondary flash devices, ROMs, various persistent storage devices (e.g., hard disks, CD ROMs, etc.), and even over computer networks.","Application program  may be any software\/firmware entity executing on processing system . In one embodiment, application program  is a pre-boot application, which is loaded and executed during a boot-up phase (i.e., start-up phase) of processing system . Similarly, OS loader  is loaded from DSU  and executed during the boot-up phase of processing system . OS loader  is executed by processing system  to begin loading portions of an OS from DSU , such as the OS kernel, device drivers, application programming interfaces (\u201cAPIs\u201d), and the like, into system memory . Each of application program  and OS loader  may request I\/O agent  to load and\/or execute content  from DSU , which may in turn request I\/O agent  to load other content from DSU . In fact, application program  and OS loader  are themselves content loaded from DSU . Content  may include instructions, data, files, applications, drivers, and the like, loaded by processing system  into system memory  during a boot-up or boot-up phase of processing system .","Returning to , in process block , one of application program  and OS loader  requests I\/O agent  to load a portion of content  from DSU  into system memory . In a process block , profiler  records a source location of the load request into pre-fetch profile . In the illustrated case, the source location of the load request would be the location of content  stored on DSU . For example, the source location of content  could be a logical block address (\u201cLBA\u201d) on HDD , a memory address or an address location in NV memory .","In a process block , I\/O agent  executes the requested load of content  into system memory , illustrated by arrow . In a decision block , process  loops back to process block  and continues from there until all of content  requested by application program(s)  or OS loader  has been loaded into system memory  and its source locations saved in pre-fetch profile . Once all of content  has been loaded, process  continues to a process block . In process block , profiler  clears profiler variable , signifying that profiling has completed and pre-fetch profile  is complete. In a process block , the pre-boot runtime is completed and the OS runtime commences. In one embodiment, the pre-boot runtime is completed upon execution of an \u201cexit boot services\u201d instruction.","Profiler  is illustrated in  within I\/O agent  to indicate that in one embodiment, profiler  is a functional component of I\/O agent . However, in other embodiments, profiler  may be an independent entity that performs the functionality described herein in collaboration with I\/O agent .","Process  represents a setup process for creating pre-fetch profile  for future use, as described below. In other words, process  is executed during an initial boot of a particular OS to create a pre-fetch profile of content loaded from DSU  for that particular OS. In subsequent boots, the pre-fetch profile created by process  is used to pre-fetch content  into system memory  to hasten the boot-up phase for the particular OS. Processing  may be repeated randomly, at preset intervals, when it is determined that content  has substantially changed, or at a user request to update the pre-fetch profile. A pre-fetch profile for a particular OS may change over time as the user installs new patches, updates, or applications on the OS or BIOS.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 4","b":["400","315","400","405","410","415"]},"Pre-fetch profile library  may include any number of pre-fetch profiles, including only one. In one embodiment, when profiler  records source locations of content  into pre-fetch profile , pre-fetch profile  is saved to pre-fetch profile library  and indexed with the OS being booted by processing system  at the time. Thus, embodiments of the present invention support aggressive content pre-fetching in processing systems having multiple OS's or boot options.","Any number of techniques may be used to encode pre-fetch profiles , , and . For example,  illustrates a blocking method to encode pre-fetch profiles , , and . In this technique, contiguous LBAs on DSU  are grouped within a single entry. For example, entry  of pre-fetch profile  includes three values. A first value  of entry  is a source location of the first LBA of several contiguous LBAs. A second value  is a count indicating the number of contiguous LBAs. A third value  is a destination location. The destination location indicates to I\/O agent  where the portion of the pre-fetched content  addressed by entry  should be loaded in system memory  (described below).","Another technique of encoding pre-fetch profiles , , and  is a one-to-one method. Using the one-to-one method, each LBA to be referenced within a pre-fetch profile has its own entry, each entry having two values\u2014a source location and a destination location. Yet another technique of encoding pre-fetch profiles , , and  is called elevator scheduling. Elevator Scheduling may be used in conjunction with the blocking method and the one-to-one method to accelerate the pre-fetching process described below. Elevator scheduling organizes the entries of each of pre-fetch profiles , , and  according to the physical position of the LBAs on DSU . In an example where DSU  represents HDD , elevator scheduling would arrange the order of the entries of pre-fetch profiles , , and  to match the physical order of the source locations on HDD . Elevator scheduling minimizes read times from DSU  by minimizing travel distance of a read head. Yet another technique of encoding a pre-fetch profile is probability profiling. Using probability profiling a single pre-fetch profile is generated for multiple operating systems. A pre-fetch profile using probability profiling gathers the most common LBAs loaded during boot-up phases for several operating systems into one pre-fetch profile. The pre-fetch profile could be generated using various types of probability density functions. In one embodiment, a pre-fetch profile could be generated from on a learned set of fetches based on a number of access patterns to DSU  over time. In one embodiment, the learned set of fetches could be acquired via Bayesian learning. In other embodiments, the learned set of fetches could be acquired via k-means and other learning techniques based on observation of disk patterns to determine a probability density function of the most-probable accesses to DSU .",{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 5","FIG. 6","FIG. 6"],"b":["500","335","301","110","500","335","301","615","405","410","415","500","700","500","500"]},"Returning to process  illustrated in , if profile variable  is not set (i.e., cleared), then process  continues to an off-page reference A. Process  continues from off-page reference A. In a decision block , a prefetcher  determines whether a pre-fetch variable  is set. In short, pre-fetcher  is a firmware agent which acts to preemptively load content  from DSU  into system memory  prior to content  being loaded in a natural course of the boot-up phase of processing system . Prefetcher  is enabled if pre-fetch variable  is set. In one embodiment, prefetcher  is loaded into system memory  from a persistent data storage device (e.g., NV memory , HDD , etc.) into system memory  and executed from there in response to pre-fetch variable  being set.","In a process block , prefetcher  determines which pre-fetch profile from pre-fetch profile library  to access. In one embodiment, pre-fetcher  may simply access the one of pre-fetch profiles , , and , which corresponds to the last OS loaded by processing system . Alternatively, in one embodiment, pre-fetcher  may access and pre-fetch content of several of pre-fetch profiles , , and  dependent upon system idle time available during the boot-up phase. In a case where pre-fetch profile library  includes only one pre-fetch profile process block  may be skipped. It should be appreciated that various other techniques may be implemented within the spirit of the present invention to determine which pre-fetch profile within pre-fetch profile library  to access. Referring to , pre-fetch profile  corresponds to the one of pre-fetch profiles , , and  accessed by prefetcher .","In a decision block , prefetcher  waits until processor  is busy waiting or idle. When it is determined that processor  is busy waiting or idle, then in a process block  prefetcher  requests I\/O agent  to preemptively load content  into system memory  from DSU . Prefetcher  determines what content to load from DSU  based on pre-fetch profile . In a process block , I\/O agent  loads the requested content  into system memory . In one embodiment, I\/O agent  loads the requested content  into a temporary boot memory  within system memory . In one embodiment, temporary boot memory  is a boot services memory of the EFI standard framework. The boot services memory is valid only during the boot-up phase of processing system and upon entry into the OS runtime becomes stale, as the OS may reclaim the boot services memory at such time.","In an embodiment of the present invention where prefetcher  is compliant with an EFI standard framework, a boot services stall routine is often called for processing system  to busy wait on a timer while processor  waits for a hardware entity to initialize, return results, or the like. In one embodiment of the present invention, the boot services stall routine is augment with code to call prefetcher  to request preemptive loads of content  during this busy wait period. In this manner, the busy wait or idle periods are not wasted.","In a decision block , prefetcher  determine whether any entries remain in pre-fetch profile  which have not been preemptively loaded into system memory. If unloaded entries remain and the processing system  has not yet entered OS runtime (e.g., processor  has not yet executed an \u201cexit boot services\u201d instruction), then process  returns to decision block  and proceeds from there as described above. If on the other hand, all entries in pre-fetch profile  have been loaded or processing system  is about to complete the boot-up phase (i.e., no time remaining), then process  continues to a process block . In process block , the pre-boot runtime completes (e.g., processor  executes the \u201cexit boot services\u201d routine called by OS loader  in the EFI standard framework, launching of the active partition's boot record in a legacy system or the like), the OS claims control over processing system , and commences OS runtime.","Returning to decision block , if pre-fetch variable  is not set, then prefetcher  is not enabled and process  continues to a process block . In process block , processing system  completes a regular boot-up phase without pre-fetching content  from DSU . In a process block , OS loader  loads components of an OS (e.g., OS kernel, device drivers, etc.) into system memory  and processing system  commences OS runtime (process block ).",{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 7","FIG. 8","FIG. 8"],"b":["700","100","700","500","700","700"]},"Process  continues from off-page reference A in . In a process block , one of application program  and OS loader  requests I\/O agent  to load content from DSU  into system memory . In a decision block , I\/O agent  determines whether the requested content corresponds to content , which has already been preemptively loaded into temporary boot memory . Content  represents a portion of content , which has already been preemptively loaded into system memory  via the techniques described in connection with process .","If the requested content does match a portion of content , then process  continues to a process block . In process block , I\/O agent  copies the requested content (i.e., the corresponding portion of content ) from temporary boot memory  into runtime memory , illustrated with arrow . In one embodiment, the requested content is copied into a destination location within runtime memory  as requested by application program  or OS loader . It should be appreciated that the techniques of the present invention may also be used to preemptively load application program  and OS loader  into system memory .","Returning to decision block , if the requested content does not correspond to a portion of content  (i.e., the requested content has not yet been preemptively loaded into system memory  or does not correspond to an entry within pre-fetch profile  and therefore will not be pre-fetched), then process  continues to a process block . In process block , I\/O agent  fetches the requested content from DSU  and loads the requested content into system memory , illustrated by arrows  and . Depending upon whether the requested content is to be executed during the OS runtime or simply to be temporarily executed during the boot-up phase will determine where in system memory I\/O agent  loads the requested content.","In a decision block , if the boot-up phase of processing system  is not yet complete, then process  returns to decision block  and proceeds from there as described above. If the boot-up phase is complete, then process  exits the pre-boot runtime and commences execution within the OS runtime (process block ).","Embodiments of the present invention preemptively load (i.e., pre-fetch) content  from DSU  during a boot-up phase of processing system  thereby resulting in a speedy OS boot. Embodiments of the present invention take advantage of the busy waiting and\/or time which processor  would otherwise be idle during the pre-boot runtime to preemptively load content from DSU  into system memory . Copying the pre-fetched content  from one location within system memory  to another is many times faster than loading content from DSU  into system memory . Thus, by preemptively loading content from DSU  during otherwise wasted time, the boot-up phase of processing system  is decreased.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 9","b":["900","905","905","100","905","910","915","920","925","910","930","945","950","110","115","105"]},"In one embodiment, a network interface card (\u201cNIC\u201d) (not shown) is coupled to an expansion slot (not shown) of motherboard . The NIC is for connecting processing system  to a network , such as a local area network, wide area network, or the Internet. In one embodiment network  is further coupled to a remote computer , such that processing system  and remote computer  can communicate.","Hard disk  may comprise a single unit, or multiple units, and may optionally reside outside of processing system . Monitor  is included for displaying graphics and text generated by software and firmware programs run by processing system . Mouse  (or other pointing device) may be connected to a serial port, USB port, or other like bus port communicatively coupled to processor(s) . Keyboard  is communicatively coupled to motherboard  via a keyboard controller or other manner similar to mouse  for user entry of text and commands.","The above description of illustrated embodiments of the invention, including what is described in the Abstract, is not intended to be exhaustive or to limit the invention to the precise forms disclosed. While specific embodiments of, and examples for, the invention are described herein for illustrative purposes, various equivalent modifications are possible within the scope of the invention, as those skilled in the relevant art will recognize.","These modifications can be made to the invention in light of the above detailed description. The terms used in the following claims should not be construed to limit the invention to the specific embodiments disclosed in the specification and the claims. Rather, the scope of the invention is to be determined entirely by the following claims, which are to be construed in accordance with established doctrines of claim interpretation."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Non-limiting and non-exhaustive embodiments of the present invention are described with reference to the following figures, wherein like reference numerals refer to like parts throughout the various views unless otherwise specified.",{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
