---
title: System and method for unloading namespace devices
abstract: An advanced configuration and power management system is described which supports an unload command by identifying those objects that are to be unloaded and, rather than simply attempting to delete the objects, detaches them from the namespace while keeping them in memory in a location accessible by the system. In this way, the system avoids the problem of trying to synchronize accesses to the objects, yet the objects not longer exist in the tree, so namespace collisions are avoided.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06877018&OS=06877018&RS=06877018
owner: Microsoft Corporation
number: 06877018
owner_city: Redmond
owner_country: US
publication_date: 20010629
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["REFERENCE TO RELATED APPLICATION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT"],"p":["The present patent application claims priority from U.S. Provisional Patent Application No. 60\/276,101, entitled System and Method for Unloading Namespace Devices, filed on Mar. 15, 2001.","Power management and control is an important and evolving part of computing technology. Greater demand for computing devices with more functionality and smaller size increases the need for an efficient power management and configuration system. For instance, many computing systems, particularly in smaller, laptop computers, have moved toward hot-pluggable components so that they may be dynamically removed to conserve power and weight when not needed. ACPI (Advanced Configuration and Power Interface) is an emerging industry specification that defines a flexible and extensible interface for power and configuration management. The interface enables and supports power management through improved hardware and operating system coordination. ACPI allows the operating system to control the power states of many hardware components, and to pass information to and from some hardware components, such as the temperature of a thermal sensor or the power remaining in a battery. It should be noted that a computer system may include both hardware components that are designed to interact with an ACPI system and some that are not.","Stated generally, to interact with the ACPI system, hardware components provide a platform-independent description of themselves (termed \u201cACPI tables\u201d) to an ACPI portion of the computer's operating system. At boot time, the ACPI subsystem builds a namespace that describes each of the several ACPI-compliant hardware devices by loading the several ACPI tables. Each ACPI table may include methods that allow the ACPI subsystem or other program modules to interact with the ACPI-compliant hardware devices.","More specifically, the ACPI specification defines two types of ACPI tables that are pertinent to the present discussion: a Differentiated System Description Table (DSDT) and a Secondary System Description Table (SSDT). The DSDT is part of a fixed system description loaded at system boot and it cannot be unloaded. SSDTs are description tables that may be loaded after system boot. There may be multiple SSDTs but there is only one DSDT. The theory is that an OEM can provide base system support in one table (the DSDT) and add smaller system options on an as needed basis in other tables (the SSDTs).","The ACPI specification provides for an Unload function to unload SSDTs that may be loaded, however, existing ACPI implementations have not implemented the Unload function for several reasons. For instance, there has not been a real need to use SSDTs in addition to the DSDT. Creating and loading a DSDT to describe the typical computing system has been sufficient because most computing systems simply don't have components which are routinely removed or that require an ACPI description to be removed from the namespace. In addition, difficult synchronization issues have acted to dissuade ACPI system developers from implementing an unload capability.","Moreover, removing entries from the ACPI namespace creates collision issues with entries that would subsequently be loaded. For mostly that reason, in the few instances where computing components are commonly removed from a computing system (such as undocking a laptop computer), the ACPI objects are simply left in the namespace. If another ACPI table is subsequently loaded in the namespace and has the same name or is configured to support the same device, a collision would occur. Until now, namespace collisions have been avoided by simply loading multiple ACPI descriptions for each alternative type of hardware device that may be present and then not unloading them. The number of alternative hardware devices has, until recently, been small enough that the DSDT can be loaded with each alternative hardware device without a need for SSDTs. Alternatively, the number of SSDTs that may be loaded is small enough that there has not been a need to unload them.","The present invention overcomes the problems identified above by providing a system and method for unloading objects from the namespace of an advanced configuration and power management system. Briefly stated, a software component, such as an ACPI driver, in accordance with the present invention manages the ACPI namespace. The component supports an Unload command by identifying those objects that are to be unloaded and, rather than simply attempting to delete the objects, detaches them from the namespace while keeping them in memory in a location accessible by the system. Events that may surface through the ACPI subsystem are temporarily suspended during the unload event to avoid synchronization conflicts. In this way, the described system overcomes the problems of trying to synchronize accesses to the objects, yet the objects no longer exist in the tree, so namespace collisions are avoided.","More specifically, the invention provides a method for unloading an object from an advanced configuration and power management system by, in response to an Unload command, disabling general purpose events and flushing various work queues. These tasks put the ACPI subsystem in a steady state. At that point, the ACPI subsystem identifies those ACPI namespace objects to be unloaded, such as from a parameter passed with the Unload command. The ACPI subsystem may, in addition, temporarily terminate access to the ACPI namespace, such as by acquiring a lock on the ACPI namespace. With access to the ACPI namespace suspended, the ACPI subsystem detaches each of the objects from the ACPI namespace while maintaining pointers to the actual locations of the objects in memory. This operation preserves the direct children of the objects to be unloaded, which allows the ACPI subsystem to find any control methods that it thinks belong to the object.","The ACPI subsystem may then mark the detached objects and any associated namespace objects as invalid, which informs various components of the ACPI subsystem that they should not try to execute or evaluate those objects. The ACPI system can then release the lock on the ACPI namespace, resume handling general purpose events, and issue a notification to the kernel that the objects that have been removed from the ACPI namespace. In response to the notification, the kernel may unload any device drivers that were supporting the devices associated with the unloaded objects. When a final device driver has been unloaded, the ACPI subsystem may free any data structures associated with the unloaded objects, including the namespace objects that were detached from the namespace.","There are several advantages to the present invention. For instance, the computer operating system does not have to make the entire unload process synchronous. In other words, in the absence of the present invention, to simply delete a device description from the namespace the ACPI subsystem would have to block until the operating system has stopped using the device. With the invention, the ACPI subsystem still has control of the device descriptions that have only been detached from the namespace but not deleted, which avoids the blocking problem. In addition, the ACPI subsystem may handle an Unload command followed by a Load command without the namespace collision problem identified above because the device description has been removed from the namespace. Moreover, an existing facility, such as an operating system kernel, maintains reference counts on the various devices in the system, then reference counting by the ACPI subsystem is not required.","Illustrative Operating Environment","With reference to , an exemplary system for implementing the invention includes a computing device, such as computing device . In a very basic configuration, computing device  typically includes at least one processing unit  and system memory . Depending on the exact configuration and type of computing device, system memory  may be volatile (such as RAM), non-volatile (such as ROM, flash memory, etc.) or some combination of the two. System memory  typically includes an operating system , one or more application programs , and may include program data . This basic configuration is illustrated in  by those components within dashed line .","Computing device  may also have additional features or functionality. For example, computing device  may also include additional data storage devices (removable and\/or non-removable) such as, for example, magnetic disks, optical disks, or tape. Such additional storage is illustrated in  by removable storage  and non-removable storage . Computer storage media may include volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information, such as computer readable instructions, data structures, program modules or other data. System memory , removable storage  and non-removable storage  are all examples of computer storage media. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can accessed by computing device . Any such computer storage media may be part of device . Computing device  may also have input device(s)  such as keyboard, mouse, pen, voice input device, touch input device, etc. Output device(s)  such as a display, speakers, printer, etc. may also be included. All these devices are well know in the art and need not be discussed at length here.","Computing device  may also contain communications connection(s)  that allow the device to communicate with other computing devices , such as over a network. Communications connection(s)  is an example of communication media. Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. The term computer readable media as used herein includes both storage media and communication media.","Illustrative Configuration Management System",{"@attributes":{"id":"P-00024","num":"00024"},"figref":["FIG. 2","FIG. 2","FIG. 4"],"b":["200","100","1","200","2","200"]},"As shown, the application programs  may interface with a kernel , which is a part of the operating system , generally through application programming interface (API) calls or the like. The kernel  can be generally considered as one or more software modules that are responsible for performing many operating system functions. One such function is passing information between the application programs  and the lower level components of the ACPI system , such as the ACPI driver  (described below) and various device drivers (e.g., device driver ).","The kernel  interfaces with Operating System Power Management (OSPM) system code . The OSPM system code  comprises one or more software modules that may be a part of the operating system  and that may be used to modify the behavior of certain components of the computer system , typically to conserve power in accordance with pre-configured power conservation settings. As is generally known, the various device drivers  interface with and generally control the hardware installed in the computer system .","The ACPI driver  is, generally speaking, a module that controls the functioning of much of the ACPI system . The ACPI driver  may be supplied as part of the operating system  or as a separate component. In the described system, the ACPI driver  is loaded during system start-up at the base of a tree of devices where it acts as an interface between the operating system  and the ACPI BIOS . The ACPI driver  is responsible for many tasks, such as initiating and maintaining the ACPI system  by populating an ACPI namespace  (illustrated in FIG.  and described below) at system startup, loading and unloading description blocks from the ACPI namespace at run time, handling certain general purpose events triggered by ACPI hardware, handing off other general purpose events to modules registered to handle those events, and the like.","A driver communicates with other drivers and the operating system components (e.g., an I\/O manager or the kernel ), for example in the Windows\u00ae 2000 operating system, by passing messages called I\/O request packets (IRPs) up and down a \u201cdriver stack.\u201d As will be understood by those skilled in the art, drivers for a particular hardware device may be \u201cstacked\u201d such that messages directed either down to the hardware device or back up to the operating system (or other program module) are passed through a chain of drivers in a driver stack before reaching their destination. Applications and systems, such as the ACPI system , may insert a driver, such as the ACPI driver , in a driver stack to add functionality to the hardware device.","To that end, for each device described in an ACPI namespace  (described below), the ACPI driver  creates either a filter Device Object (filter DO) or a Physical Device Object (PDO) in the driver stack for that device. If the device is capable of being enumerated by an element of another subsystem, such as a Plug-n-Play subsystem, that element of the other subsystem may create the PDO for the device and the ACPI driver  may put a filter DO on top of the PDO. The ACPI system  provides power management features to the device stack by means of these device objects. For more information on filter DOs, PDOs and Functional DOs (FDOs), refer to the Microsoft Windows\u00ae 2000 Driver Development Kit, publicly available from the Microsoft Corporation of Redmond, Wash.","The ACPI driver  makes use of several components when performing the functions of the ACPI system . One component is the ACPI BIOS , which refers to the portion of system firmware that is compatible with the ACPI specification. Generally stated, the ACPI BIOS  is part of the code that boots the machine (similar to the BIOS present in most conventional computer systems) and implements interfaces for power and configuration operations, such as sleep, wake, and some restart operations. The ACPI BIOS  contains definition blocks used to construct ACPI Tables , as is described in greater detail below. Note that although the BIOS  and the ACPI BIOS  are illustrated as separate components in , they may be implemented as one component in the computer system .","The ACPI Tables  include at least one definition block (e.g., a DSDT described later) that contains data, control methods, or both. Each set of data or control methods defines and provides access to a respective hardware device. The definition blocks are written in an interpreted language called ACPI Machine Language (AML), the interpretation of which is performed by an AML interpreter . One such definition block, a Differentiated Definition Block (DDB), describes the base computer system. Other definition blocks may be provided to describe additional hardware devices. One ACPI Table , known as a Differentiated System Description Table (DSDT) describes the base computer system, that is, the DSDT contains a Differentiated Definition Block (DDB), which describes the root system. The DSDT is like other data blocks, except that it cannot be unloaded.","There may be one or more Secondary System Descriptor Tables (SSDTs), each of which describes hardware components in addition to the base computer system. The ACPI Specification provides that SSDTs may be unloaded, although until now that capability has been unrealized. The tables also include header data structures that contain information about what the block contains, for example, whether it is a Differentiated System Description Table (DSDT) or a Secondary System Descriptor Table (SSDT). Other definition blocks may be provided to describe additional ACPI devices.",{"@attributes":{"id":"P-00033","num":"00033"},"figref":"FIG. 3","b":["209","222","209","100","105","202","222","220","222","209","202","209","222"]},"As mentioned, a device in the ACPI namespace  may contain control methods. A \u201ccontrol method\u201d is a software module that defines how the ACPI system  performs a hardware-related task. For example, the ACPI system  may invoke a control method to read the temperature of a thermal zone. Control methods are written in AML, are stored in the definition blocks within the ACPI BIOS , and are loaded into the ACPI namespace , typically at system boot up. Once in the ACPI namespace , the control methods may be invoked by other components in the ACPI system , such as device drivers or the like, and are then interpreted and executed by a virtual machine in the AML Interpreter . The use and structure of the ACPI namespace, and the objects within, are described in greater detail below with respect to FIG. .","The illustrative ACPI namespace  shown in  includes a namespace root , several illustrative branches under the root , and several other objects of various types. For instance, power resource objects, such as power resource object \\_PID, may reside under the namespace root . The object \\PID may define a power resource for a particular device, such as an on-off switch for an IDE device. The \\_SB namespace  includes namespace objects that define ACPI-compliant components attached to the system bus. One example of a such namespace object is the PCI bus namespace object . Each namespace object may contain other objects, such as data objects , control methods, or other namespace objects (e.g., IDE namespace objects IDE and IDE). Several control methods may be loaded in the ACPI namespace  in connection with various objects. For example, control methods related to the status and maintenance of a particular power resource object may be loaded within the scope of the power resource object, such as control methods  under the power resource object \\PID.",{"@attributes":{"id":"P-00036","num":"00036"},"figref":["FIG. 4","FIG. 2","FIG. 4","FIG. 2. A","FIG. 4"],"b":["2","202","205","224","201","405","209","2","3","405","202","406","405","406","202"]},"Application  is shown that may interact with the kernel  or other components of the ACPI system . Other components of the ACPI system  include a GPE event mask , which presents to the ACPI system  a current state of the ACPI registers  so that the ACPI system  may identify the existence and the originator of any GPE events raised by ACPI-compliant hardware, such as hardware device . The hardware device  is accessed by the computing system through the use of a driver stack  that includes the ACPI driver , a device object , and may include filter drivers, such as filter driver  and filter driver . In this discussion, a device object (sometimes referred to as a Physical Device Object or PDO) is a kernel-mode object, defined by an I\/O manager portion of the operating system , that represents a physical hardware device. The device object may be created by an underlying bus driver when the physical device is enumerated. Each object in the namespace  is associated with a device object, such as device object , for the particular hardware device which the namespace object represents. The filter drivers (, ) are inserted into the driver stack  by other processes and provide additional functionality to the hardware device .","A device extension  is associated with the ACPI driver  and contains information used by the ACPI driver , such as at least a pointer to a corresponding device-type object (e.g., object A) and additionally may have pointers to other namespace objects, such as method objects (e.g., object B), associated with that device-type namespace object. In this discussion, a device extension is a data structure associated with a device object that includes context information, such as device state information, spin locks, driver data, and other device-object information. In this embodiment, the device extension  includes a reference count field that includes a reference count for each resource that refers to the device object , such as the device-type namespace object, any child device extensions, and the like. Preferably, that reference count field is managed by the ACPI driver  but is based on a reference count performed by the kernel  for each device object enumerated in the system. By making use of the reference counting already performed by the kernel , the ACPI system  need not reproduce the reference counting that is already being performed. It should be noted that the ACPI driver  may also maintain reference counts for its own convenience in addition to any external reference count. The device extension  also includes pointers to those resources that refer to the device object , including objects in the namespace .","The operation of the components is generally described with reference to an example of an unload operation. In this example, an unload event is generated in response to the hardware device  either being removed or indicating that it is about to be removed (e.g., a hardware switch or button being pressed). The unload event may be generated by raising a GPE signal in the ACPI registers , which is transmitted, via the GPE event mask , to the AML interpreter  as an instruction to unload the hardware device . Alternatively, the unload event may be generated in software, such as by the operating system in response to a user request to remove a piece of hardware or the like. In response to the unload event, the AML interpreter  first (prior to actually beginning the unload operation) informs the ACPI driver  that an unload operation is about to occur. This pre-notification allows the ACPI driver  to do some pre-processing, like disabling system power management and other miscellaneous events.","In addition, the ACPI driver  may disable general purpose events from being generated and sent to the AML interpreter . Disabling GPE signals at the beginning of the unload operation avoids potential problems that could otherwise occur during the unload operation. For instance, the ACPI driver  does not know which hardware device, such as a laptop docking station, is associated with which GPE pins. Thus, if any part of the ACPI namespace  is being unloaded, disabling all the GPE pins is the safest way to avoid improperly attempting to service a GPE event for a piece of hardware whose definition is being unloaded. For that reason, the GPE enable pins are cleared at the start of the unload operation so that the GPE mask  may be rebuilt at the conclusion of the unload operation.","Next, the AML interpreter  informs the ACPI driver  which entries in the namespace  are disappearing. For example, the unload message may have indicated that the hardware device  is being removed or otherwise made unavailable, and the namespace  may include one or more objects associated with the hardware device . For instance, the objects within box  may be associated with the hardware device , and as such are identified to the ACPI driver . The object labeled \u201cA\u201d may be an ACPI device-type namespace object, and the object labeled \u201cB\u201d may be a control method or other namespace object associated with namespace object \u201cA.\u201d","In response to the notice from the AML interpreter , the ACPI driver  severs any links in its data structures  between the disappearing namespace entries (objects ) and the parents of those disappearing entries. The ACPI driver  maintains reference counts in the parent for each child, so the ACPI driver  decrements those reference counts as appropriate. The ACPI driver  also marks the parent as needing to be updated and indicates to the kernel  that the hardware device  no longer exists so that the kernel  may begin tearing down the driver stack  associated with the hardware device . It should be noted that the kernel  may wait until no running applications or other processes have open handles to the unloaded hardware device before tearing down the driver stack.","Concurrently, the AML interpreter  unlinks the disappearing entries (objects ) from the namespace  and marks any control methods (e.g., namespace object \u201cB\u201d) associated with the disappearing entries as not executable. If an attempt is made to execute a method marked as not executable, the AML interpreter  would either return a failure code or success without actually executing the method. The AML interpreter  detaches the disappearing entries from the namespace tree  without severing the links between the ACPI devices (e.g., namespace object \u201cA\u201d) and their children (e.g., namespace object \u201cB\u201d). Preserving these relationships makes implementation simpler because it allows for certain assumption to remain true, such as caching pointers to certain namespace objects. Moreover, by detaching the entries from the namespace, new entries may be added to the namespace  in place of the unloaded entries without fear of a namespace collision.","Once the AML interpreter  has completed cutting the disappearing entries from the namespace, it notifies the ACPI driver  that the AML interpreter's portion of the unload operation is complete. In response to that notification, the ACPI driver  may re-enable any of the support that was disabled at the start of the unload operation. For example, the ACPI driver  may rebuild the GPE mask  by looking at the GPE Control Methods in the ACPI namespace  to calculate a bit mask. The ACPI driver  may additionally look at the devices contained in the namespace to see which pins they use for Wake-Support and add those pins to the bit mask.","Referring to , there are now a number of objects  (including object \u201cA\u201d and object \u201cB\u201d) floating in memory that are not attached to the ACPI namespace . However, as mentioned above, the device extension  associated with the ACPI driver  includes a pointer  to the ACPI device-type namespace object (i.e., object \u201cA\u201d) that has been cut from the namespace . For that reason, the operating system  and the ACPI driver  may still access those objects. In such a case, because any control methods or data structures associated with the objects have been marked as invalid, the accessing entity (e.g., the kernel ) is notified that the device no longer exists and may respond in a graceful manner, such as with a surprise remove event or the like.","As mentioned above, the ACPI driver  keeps track of the resources that point to the device extension . The kernel  begins deleting those resources and tearing down the driver stack  () when notified by the ACPI driver  of the unload operation. As each resource pointing to the device extension  is destroyed, the reference count  in the device extension  is decremented. Thus, the reference count  will eventually reflect only a single referring entity, the corresponding namespace object. At that point, the ACPI driver  may safely notify the AML interpreter  that the namespace objects  that were cut are no longer being referenced by any process outside of the ACPI system , and it is safe to free the memory associated with the unloaded namespace objects . In response, the AML interpreter  may destroy the unloaded namespace objects  and clean up any memory allocated to them.","If the unloaded objects  do not have a corresponding device object, then one of three situations applies: the objects have zero, one, or more than one reference. First, if the data structure has only one reference, then there is not an error and the operations outlined above apply to free the memory. However, zero references or more than one reference indicates a problem with the reference counting. For instance, zero references would not normally be a valid case and would indicate a bug in the driver. More than one reference may indicate to the system that there is an error in the ACPI tables themselves and it will react accordingly. It should be noted that the case where there are two references can occur even if the unloaded objects did not have corresponding device object. The particular case is where an unloaded object has a child device that is not part of the table being unloaded. The operating system treats this case as an error in the ACPI bios.","While the invention has been described thus far with reference to functional block diagrams of software components implementing embodiments of the invention, it may also be described with reference to logical flow diagrams illustrating processes for implementing embodiments of the invention. The logical operations making up the described embodiments of the present invention may be referred to variously as operations, structural devices, acts, or modules. It will be recognized by those skilled in the art that these operations, structural devices, acts, or modules may be implemented in software, in firmware, in special purpose digital logic, or any such combination without deviating from the spirit and scope of the present invention.",{"@attributes":{"id":"P-00049","num":"00049"},"figref":"FIG. 6","b":["205","600","405","600","601","602"]},"At block , the AML interpreter  informs the ACPI driver  that an unload event has been generated. In this embodiment, the ACPI driver  is provided notice at the beginning of the unload operation so that the ACPI driver  may begin any preprocessing activities that may be helpful or necessary for the unload operation to proceed properly. For example, the ACPI driver  may clear the GPE mask  and disable the GPE enable pins (within the ACPI registers ) until the AML interpreter  has had time to conduct its portion of the unload operation. In this way, new GPE events will not be created until the unload operation is complete. Other preprocessing activities may also be performed.","At block , the AML interpreter  identifies the namespace objects which are affected by the unload operation and passes that information to the ACPI driver . For instance, the AML interpreter  may first acquire a lock on the ACPI namespace  and then walk the namespace to build a list of objects within the ACPI namespace  that are intended to be unloaded. It should be noted that the ACPI driver  is only interested in device-type namespace objects at this point because the linkages are maintained between those objects and their children (e.g., control methods, static values, packages, and the like). The information describing the affected namespace objects is then passed to the ACPI driver  to be handled as appropriate (and as described more fully below). The AML interpreter  may release the lock it acquired on the ACPI namespace  at this point (e.g., when it has finished walking the namespace to build the list).","At block , the AML interpreter  detaches the affected ACPI namespace objects from the namespace . The AML interpreter  may walk the namespace  and sever any links between the affected objects and their parents. The AML interpreter  may set a flag in the affected objects indicating that they are being removed. It may be helpful to note again that the affected device-type namespace objects are detached from their parents, while any children of those objects remain linked. In other words, those namespace objects that may be found in memory through the use of a device extension are severed from their parent, but any children that do not have a corresponding device extension remain linked to their parent so that the ACPI driver  continues to have a link to those objects.","At block , once the AML interpreter  has detached the affected objects from the namespace , the AML interpreter  informs the ACPI driver  of the success and that the unload event is complete. In other words, the AML interpreter  indicates to the ACPI driver  that the AML interpreter  has completed its portion of the unload operation. At that point, the affected ACPI namespace objects remain accessible to the ACPI driver  but have been removed from the namespace . For that reason, the AML interpreter  may reload a new table in the namespace  to support a similar hardware device without fear of a collision with the unloaded objects.","At decision block , the AML interpreter  continues normal processing until a notification that the ACPI driver  has completed its portion of the unload operation is received. The AML interpreter  may continue to perform routine ACPI functions and operations while awaiting that notification. When the notification is received from the ACPI driver , at block , the AML interpreter  may destroy the affected objects and any associated data structures or the like. It will be appreciated that this notification may happen several times. For instance, the operating system may not unload device drivers in such a way that a single call to free deleted namespace objects is possible. The notification from the ACPI driver  indicates that the device corresponding to the affected objects is no longer in use (or referred to by other processes) and the memory may be freed and the process ends at ending block .",{"@attributes":{"id":"P-00055","num":"00055"},"figref":"FIG. 7","b":["202","700","405","700","701"]},"At block , the ACPI driver  receives notification from the AML interpreter  that the unload operation has begun. In response to the notification, at block , the ACPI driver may perform any preprocessing activity that may be necessary or helpful to the unload operation. In one example, as described above, the ACPI driver  may clear the GPE mask  and the GPE enable pins until the completion of the unload operation.","At block , the ACPI driver  receives from the AML interpreter  a notification of the affected ACPI namespace objects and the affected hardware devices. In addition, the ACPI driver  may set flags in the parent of any affected object indicating that the parent now has invalid relations and should be reevaluated at the conclusion of the unload operation. At block , the ACPI driver  passes that information to the kernel  so that the kernel  may begin tearing down any driver stack associated with the hardware device being unloaded.","At decision block , the ACPI driver  continues processing normally until a notification is received from whatever facility (e.g., the kernel ) tracks reference counts that the affected namespace objects are no longer in use by any outstanding tasks or processes. In this particular embodiment, a device extension associated with a device object in the driver stack for the hardware device is used to track the reference count. When a reference count within that device extension indicates that the only reference remaining is to the affected namespace objects themselves, then the ACPI driver  determines that it is safe to destroy the affected objects and free the memory. If there are more references remaining, the ACPI driver  doesn't do anything.","At block , the ACPI driver  notifies the AML interpreter that the affected objects are no longer in use, indicating that it is safe to destroy the objects and free the memory. The AML interpreter  may respond to the notification by doing exactly that, destroying the now-unused objects and freeing the memory. At block , once the AML interpreter has informed it of success, the ACPI driver  performs any post-processing activities that may be appropriate, such as setting the appropriate GPE enable pins to reactivate the GPE events, and the like.","As can be seen from the above description, implementations of the invention make possible an unload operation of devices from an ACPI namespace. The above specification, together with the attached drawings, provide a complete description of the manufacture and use of the invention. Since many embodiments of the invention can be made without departing from the spirit and scope of the invention, the invention resides in the appended claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"P-00012","num":"00012"},"figref":"FIG. 1"},{"@attributes":{"id":"P-00013","num":"00013"},"figref":"FIG. 2","b":"1"},{"@attributes":{"id":"P-00014","num":"00014"},"figref":"FIG. 3","b":"2"},{"@attributes":{"id":"P-00015","num":"00015"},"figref":["FIG. 4","FIG. 2"]},{"@attributes":{"id":"P-00016","num":"00016"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"P-00017","num":"00017"},"figref":"FIG. 6"},{"@attributes":{"id":"P-00018","num":"00018"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
