---
title: Testing pattern-based applications
abstract: Methods and apparatus, including computer program products, implement techniques for testing applications using configurable patterns. A test script is received for a pattern that includes a predefined arrangement of user interface elements and specifies predefined actions that can be performed using the user interface elements. The test script specifies test sequences operable to invoke one or more of the predefined actions that can be performed. A specification of an application is received, where the specification includes configuration data for the pattern. The configuration data specifies associations between one or more of the user interface elements and one or more entities in a back-end system. A generated application-specific test is operable to invoke one or more of the predefined actions according to the test sequences in the test script. The predefined actions use the entities in the back-end system with which the user interface elements are associated.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07913231&OS=07913231&RS=07913231
owner: SAP AG
number: 07913231
owner_city: Walldorf
owner_country: DE
publication_date: 20040511
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","Overview of UI Patterns"],"p":["The present invention relates to data processing by digital computer, and more particularly to testing applications.","A user interface (UI) facilitates interaction between humans and computers by inviting and responding to user input. User interfaces come in many varieties, and are designed to work in concert with application programs. Application programs, sometimes referred to simply as applications, are programs that an end-user runs to accomplish certain tasks. Applications typically work in conjunction with one or more back-end systems, which store the data to be worked on (e.g., business objects and other business data), as well as logic for manipulating the data (e.g., transactions or other business logic). Examples of back-end systems include database systems, enterprise resource planning (ERP) systems, and customer relationship management (CRM) systems.","A common scenario involving user interfaces is a network application, where a network connects an application program running on a server and one or more user interfaces displayed in client programs running on client devices. The client\/server relationship is one in which a server provides services to the client devices. Both the client devices and the server typically have a network interface for accessing networks such as a local area network (LAN), a wide area network (WAN), or the Internet.","In a network environment, a common client device is a personal computer, and a common client program is a Web browser. The client program, which displays a user interface for an application running on a server, enables networked communication between the client device and the server using a data transfer protocol, e.g., the Hypertext Transfer Protocol (HTTP), to exchange files, images, programs, or application data. HTTP is a request\/response-type protocol that specifies how the client device and the server communicate with each other. The server may receive a request from the client device using HTTP, respond to the request, and then close the connection. HTTP is a stateless protocol, meaning that each time a client device requests a Web page, the server will respond to the request independently of any previous requests from the client device, and without recording the request.","The information transmitted from the server and intended for display in the client program on the client device may be marked up with Hypertext Markup Language (HTML) code or Extensible Markup Language (XML) code. HTML is a language that is used to describe the structure of a document, such as a Web page. Client programs interpret HTML code to determine how to display the information contained in the page. A user may request a Web page from a server by clicking on a hyperlink or specifying a Uniform Resource Locator (URL) string. A URL can be used to identify the address of a file or Web page that may be accessed on a network. The address identifies the Web server on which the file is stored and the directory in which the file is located. When the server receiving the URL request finds the sought Web page, the server sends the page to the client device so that the client device can use that Web page, for example, by generating a display for a user according to the Web page.","An application usually implements the functionality required to display and execute one or more user interfaces for the application. For this reason, an application is sometimes referred to as a user interface application. In some cases, part of the user interface functionality (e.g., rendering) may be handled by a client program that interacts with the application. Whether or not this can occur depends on the capabilities of the client program.","In general, in one aspect, the invention provides methods and apparatus, including computer program products, implementing techniques for developing and deploying applications using configurable patterns. These applications include, for example, a user interface (UI) portion that is distributed over a network such as the Internet. The techniques include receiving a test script for a pattern, receiving a specification of an application, and generating an application-specific test. The pattern includes a predefined arrangement of user interface elements and specifies predefined actions that can be performed using the user interface elements. The test script specifies test sequences operable to invoke one or more of the predefined actions that can be performed using the user interface elements. The specification of the application includes configuration data for the pattern, where the configuration data specifies associations between one or more of the user interface elements and one or more entities in a back-end system. The application-specific test is operable to invoke one or more of the predefined actions according to the test sequences in the test script, the predefined actions using the entities in the back-end system with which the user interface elements are associated.","Advantageous implementations of the invention include one or more of the following features. The application can be tested by executing the application-specific test. The pattern can include one or more tested patterns. Receiving the test script can include receiving one or more distinct test scripts, where each distinct test script corresponds to one of the nested patterns. Receiving the specification of the application can include receiving distinct configuration data for each nested pattern. The application specific tests can be used to test each nested pattern as configured by the distinct configuration data according to the distinct test script corresponding to the nested pattern. The test script can include test data, and generating the application specific test can include selecting a portion of the test data based on the configuration data. The techniques can further include receiving a specification of a second application, and generating a second application specific test. The specification of the second application can include distinct configuration data for the pattern, where the distinct configuration data specifies associations between one or more of the user interface elements and one or more entities in a second back-end system. The second application specific test is operable to invoke one or more of the predefined actions according to the test sequences in the test script, where the predefined actions use the entities in the second back-end system with which the user interface elements are associated.","The invention can be implemented to realize one or more of the following advantages. A pattern test script is developed for a pattern, and the pattern test script can be used to test multiple applications developed using that pattern. The pattern test script can be used to generate application-specific tests for pattern applications using the corresponding pattern configurations for each application. Only one pattern test script is required to be developed for each pattern, instead of one test script for each pattern application. A pattern developer can develop the pattern test script, and pattern application developers can use the pattern test script to test applications that use the pattern. One implementation of the invention provides all of the above advantages.","The details of one or more implementations of the invention are set forth in the accompanying drawings and the description below. Further features, aspects, and advantages of the invention will become apparent from the description, the drawings, and the claims.","Like reference numbers and designations in the various drawings indicate like elements.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1","b":["100","125","125","125","135"],"i":["a","b","c"]},"A more constrained and structured approach to developing user interfaces is to build them using user interface patterns. A UI pattern (sometimes referred to simply as a pattern) is a configurable, reusable user interface unit designed to let users accomplish a specific but generically-defined task, such as searching for business objects, and editing the objects that are retrieved. Generally, each UI pattern has a specific semantic meaning and defined interaction behavior. In one implementation, each UI pattern includes a predefined arrangement of UI elements. Using UI patterns promotes uniform design throughout an application or group of applications because similar tasks are represented and handled in the same manner. For example, a user can always search in the same way, whether searching for a sales order, a business partner, or a product.","UI patterns can be defined at various levels, and can be nested within each other, thus creating hierarchies of patterns. At the top level of the hierarchy, a pattern can act as a \u201cfloor plan\u201d for a user interface that is designed to help end-users complete a specific business process. The floor plan defines the user interface by specifying an overall screen layout for the user interface and managing and orchestrating any nested patterns.","One example of an important business process is working with business documents. A business document (e.g., a sales order or an invoice) is a high-level business object that can contain references to other business objects (e.g., objects corresponding to the items in a sales order and to the customer that placed the sales order). The process of working with business documents typically involves finding an existing business document or creating a new business document, and then displaying and editing the document. To help a user accomplish these tasks, an application should include a user interface that assists the user in locating the business document to be edited, and then presents the logical parts of the business document (e.g., the referenced objects that contain the customer data and the sales order items) in a clear and structured manner. The user interface should display the relevant data in an appropriate format for the given context (e.g., in a table, a form, or a chart). The user interface should also provide input help where applicable, and supply application documentation if needed. After the user has finished editing the business document (including objects referenced by the document), the user interface should also help the user carry out post-editing tasks, such as printing out the business document, and performing document lifecycle actions (e.g., saving, deleting, creating, or updating).","An example floor plan for such a user interface can specify that an application screen is to be divided into three sections, with a top section for searching for and selecting business objects, a middle section for showing the details of an object selected in the top section, and a bottom section for showing the details of a sub-object of the object in the middle section.","More detailed, lower-level patterns can be used for each of the sections specified in a floor plan. For example, an object identification pattern (OIP) can be used for the top section in the floor plan specified above. An OIP pattern (an example of which is provided below), can specify, for instance, that a section of the screen is to include a search bar with various text entry fields and buttons at the top, and an area below the search bar where content (i.e., the content returned as a result of a search) is to be displayed.","This process can continue with the definition and hierarchical nesting of even lower-level patterns. For example, the OIP pattern above can specify that the content display area is to include a table control for displaying the results of a search. The table control can be a complex control that lets users perform tasks such as selecting and sorting rows in the table, and editing entries directly in the table. In this scenario, the table control itself can be thought of as a low-level pattern.","The user interface  shown in  illustrates an example of a pattern-based user interface. The user interface  has a floor plan that includes an object identification pattern (OIP)  and two object data patterns (ODPs)  and . As described below, object identification pattern  and object data patterns  and  are made up of embedded lower-level patterns, such as a data view, a form pane, a list pane, or a chart pane. Each embedded pattern can include further embedded patterns, including, for example, tool bars, tables, tab strips, and other UI pattern elements.","Object identification pattern  is a pattern that provides an interface for searching for objects (using zero or more selected criteria), and for displaying objects found to meet those criteria. Like the floor plan pattern, OIP  is itself a pattern with several embedded elements. Object identification pattern  includes a title bar , a search bar , a tool bar , and a content area .","Title bar  orients the user. Search bar  enables the user to enter zero or more search criteria to locate objects of interest. For example, search bar  includes a drop down element that lists the fields for which the user can enter a search term. Drop down element illustrated in  shows that the user has selected the field \u201cStatus\u201d for searching. Search bar  also includes a text box element that allows a user to enter a search term to identify the objects of interest. Text box element illustrated in  shows that the user has entered \u201cOpen\u201d as the value to find in the \u201cStatus\u201d field. Search bar  also includes a \u201cGo\u201d button element that initiates the search based on user input in elements and . With the word \u201cGet\u201d located in front of drop down element , search bar  reads \u201cGet Status Open Go\u201d, which provides a reusable and intuitively understandable mechanism for initiating user searches.","Search bar  also includes an \u201cAdvanced\u201d button element that allows a user to initiate an advanced search. Upon pushing button , a form pane is rendered between search bar  and tool bar . The form pane can include, for example, each of the fields that are in drop down element , and a text box besides each field. Thus, the user can enter search terms for multiple fields to create more focused searches, thereby limiting the number of objects that appear in content area .","Tool bar  provides functions that the user can perform on the objects displayed in the content area , such as create, save, and add to and delete from the user's list of favorite objects. Tool bar  also includes a toggle control that allows a user to toggle the layout of content area  between different types of panes that provide different representations of the objects retrieved by a search. For example, a list pane displays a tabular representation of the objects (as illustrated in ). A form pane displays the object that is currently selected, with each field in the object having a control (e.g., a text box, a pull down menu, or a check box) to enable a user to change data associated with that field. As another example, a chart pane can display a graphical representation of the retrieved data. Panes can be developed to meet specific needs, and can be integrated as low-level patterns into high-level patterns such as OIPs and ODPs.","As indicated above, content area  displays those objects that meet the search criteria specified by the user. Selecting an object in content area  determines what is displayed in object data pattern (ODP) . ODP  is a pattern that displays detail data associated with the selected object from content area . ODP  includes a tab bar , a tool bar , and a content area . Tab bar  selects the type of data that is displayed in content area .  depicts the \u201cProducts\u201d tab as having been selected, so the data in content area  corresponds to product data (e.g., a list of products with item numbers, product descriptions, quantities, and the like) associated with the object selected in content area . Tool bar  includes a toggle button that allows a user to toggle the layout of content area  between a list pane (as currently illustrated in ) and another type of pane (e.g., a form pane or a chart pane).","Selecting an object in content area  determines what is displayed in object data pattern (ODP) . ODP  is a pattern that displays detail data associated with the selected object from content area . ODP  includes a tab bar  and a content area . Tab bar  selects the type of data that is displayed in content area .  depicts the \u201cItem Detail\u201d tab as selected, so the data in content area  corresponds to item detail data (e.g., a form pane with item details such as product description, quantity, net value, status, and the like) associated with the object selected in content area .","As an example of a different floor plan, ODP  can be replaced with a guided data entry pattern (GDP). A GDP is a pattern that guides the user through a sequence of steps in a task. A GDP can contain a step bar and a data entry area, similar to tab strip  and content area  of ODP . The step bar of the GDP however, represents the steps of the guided process. For example, using tab strip  for illustration, the \u201cItem Detail\u201d tab would be a \u201cStep 1\u201d tab, the \u201cProduct Information\u201d tab would be a \u201cStep 2\u201d tab and so on. In execution, the GDP would start on the \u201cStep 1\u201d tab and display in the data entry area the fields that the user must enter for the first step of the process. When the user clicks on the \u201cStep 2\u201d tab, the data entry area would change for the second step of the process. In one implementation of a GDP, the user is not permitted to perform steps out of sequence (e.g., to go from the \u201cStep 1\u201d tab to the \u201cStep 3\u201d tab), or to proceed to the next step until the current step is completed (e.g., the user is not allowed to select a subsequent tab or enter data for a subsequent tab until data entry for the current tab is complete). In another implementation, whether or not the user is allowed to perform steps out of sequence is left as a choice for the application developer to specify as part of a configuration for a GDP.","The UI patterns described above and in the remainder of this application (e.g., OIPs, ODPs, and GDPs) are meant to serve only as illustrative, concrete examples of patterns. Patterns can be created to let users accomplish any generically-defined task, and the concepts and techniques described in this application apply to and can be used with all such patterns, and are not to be restricted to the example patterns discussed herein.","Configuring UI Patterns","User interface  of  illustrates a particular application that is based on the patterns described above. Such an application will be referred to as a pattern-based application, a pattern application, or simply an application. As explained above, UI patterns are reusable user interface units designed for generic tasks\u2014for example, an OIP pattern is designed for the task of searching for and selecting business objects stored in a back-end system (e.g., a database). In order to create a concrete user interface, e.g., user interface  with OIP , UI patterns need to be configured.  illustrates an example in which a UI pattern  is configured (shown using arrows  and ) to create two UI applications  and . Configuration one  is used to create application one , and configuration two  is used to create application two .","Configuration is the process through which a UI pattern is developed into an actual user interface (or portion thereof) for an actual application. For illustrative purposes, this might be compared to instantiating an object of a specified class\u2014the UI pattern (comparable to a class) specifies the general properties of a portion of a user interface, and a configured pattern (comparable to an instantiated object) specifies the actual properties of the portion of the user interface for an actual application. UI pattern  represents the general properties of the UI portion\u2014for example, that a table is included in that UI portion, and that the location of the table is under a title bar. Configuration one  represents the process of specifying the specifics of the UI portion (for example, the specific columns that will be included in the table when the table is rendered), so as to create an application (for example, application one ) that displays a UI with a table under the title bar with specific columns defined by configuration one . Similarly, application two  displays a table, but with specific columns as defined by configuration two .","A configuration can also specify what back-end systems and data are to be used for a pattern. For example, configuration one  can specify a particular back-end system (e.g., a local or remote database system) and a particular service to use to access the data on that back-end system that is to be displayed in the table in the UI pattern . Examples of services that can be used to access a host system include web services, Enterprise Java Beans (EJBs), Business Application Programming Interfaces (BAPIs) developed by SAP AG of Walldorf (Baden), Germany (SAP), and other business logic services.","As another example of a configuration, an OIP might specify that a user interface is to include a search bar at the top of the interface and a content area below the search bar. The search bar is to include a drop down box for selecting a search field, a text box for entering a query string, and a \u201cGo\u201d button for executing searches. Configuring such a pattern is the process of providing specifics for the pattern for an actual application. For example, to configure the OIP pattern, an application developer can specify the search fields to be included in the drop down box, the query to run when the \u201cGo\u201d button is pressed, the back-end system in which to run the query (i.e., the system where the actual data is located), and the columns from the returned results to display in the content area.","In some implementations, a UI pattern can have a number of predefined layouts (e.g., a grid layout and a flow layout), and the application developer can decide which of the available layouts to use as part of the configuration process. Moreover, each layout can be further configurable, providing the application developer with further configuration options (e.g., an option to create groupings of fields or other elements). In yet other implementations, a pattern can be defined to have a fully configurable layout, giving the application developer complete freedom to modify the arrangement of the elements in the pattern (e.g., by using a graphical configuration tool to specify screen positions for each element in the patter).","Thus, the degree to which each UI pattern is configurable can vary. For example, the degree to which the arrangement of elements in a pattern can be configured can vary across a spectrum\u2014for some patterns, the arrangement of UI elements can be fully predefined, leaving no configuration options for the application developer; for some patterns, the application developer can be given an option to choose between a handful of predefined arrangements; and for other patterns, the application developer can be given full freedom to define a custom arrangement of elements.","Other pattern properties can also be partially or fully configurable. For example, a developer can be given no options or a few options regarding the actions to be performed by a UI element in a pattern. Or the developer can be allowed to define and associate a custom action with an element in a pattern.","As can be seen from the prior discussion, the term \u201cconfiguration\u201d can be used in multiple ways. First, \u201cconfiguration\u201d is the process by which a pattern is developed into a concrete user interface (or portion thereof) for a concrete application. A \u201cconfiguration\u201d also refers to the data that is produced as a result of the configuration process\u2014i.e., it is the set of data that defines a concrete user interface based on a pattern. Finally, \u201cconfiguration\u201d can also be used to refer to the set of options provided during the configuration process. As used in this manner, a selected option in a configuration produces a defined item of configuration data.","The use of patterns to develop applications creates two potential levels of re-use. First of all, patterns serve as re-usable building blocks for building user interfaces. For example, an OIP can be used to create two different user interfaces\u2014a first configuration can define a user interface for searching for business objects related to customers (customer objects), and a second configuration can define a second user interface for searching for business objects related to inventory (inventory objects).","In addition, configurations can be reused, meaning that the configurations themselves can serve as re-usable building blocks for building applications. Thus, in the example above, the OIP configuration that defines a user interface for searching for customer objects can be integrated and used in two different applications (e.g., a customer relationship management application and a billing application).","The configuration of a UI pattern can be done either manually (e.g., with a text editor), or through the use of a configuration application. A configuration application facilitates the process of configuring a UI pattern. In one implementation, the configuration application displays multiple configuration options for the application developer to select. As the selections are made, the configuration application displays a WYSIWYG representation of the resulting configured user interface, thereby allowing the application developer to preview his selections and make any necessary modifications. The configuration options can include lists of the available back-end systems, queries, query fields, and query results.","Once the application developer has finished selecting the configuration options, the selections are stored as configuration data for the UI pattern. The configuration data can include associations between one or more of the UI elements in the UI pattern and one or more of the back-end entities to be used with the UI pattern. As an example, configuration data for the OIP described above can include a specification of the back-end system to be used, the query to be run in the back-end system, the query fields to show in the drop down box, and the result fields to display in the content area.","The configuration data can also include customization data for one or more of the UI elements in the UI pattern. The customization data can specify local changes to the business objects associated with the UI elements. For example, a drop-down menu item might be associated with a back-end query field called \u201cUID\u201d. The customization data may specify that the \u201cUID\u201d field should be displayed using a more user-friendly label, for example, \u201creference number\u201d. Such a customization applies only to the particular UI element in the particular application being configured, and does not affect how the business object is represented in the back-end system or how the business object is represented by other UI elements in other applications that use the same UI pattern.","The configuration data can be stored in a configuration repository. In one implementation, the configuration data is stored in one or more files. Such files can be nested to reflect a hierarchical arrangement of further UI patterns. The configuration data can then be read by a pattern component, which generates the implementation of the actual user interface for the application based on the configuration data.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 3","b":["305","310","315","320","325","305","315","325","305","325"]},"The generation of a pattern-based application based on a configuration can be done either immediately after the configuration has been completed, or at a subsequent point in time, such as when the pattern-based application is executed.","For example, in the scenario described above where a configuration application produces configuration data for a pattern component, the pattern component can read the configuration data and generate the pattern-based application immediately after the configuration data has been produced. This is referred to as a design-time generation of a pattern-based application, since the generation occurs when the configuration is produced (i.e., when the configured pattern or application is designed).","Alternatively, the pattern component can read the configuration data and generate the implementation of the corresponding pattern-based application when the pattern-based application is executed by an end-user. This is referred to as a run-time or on-demand generation of a pattern-based application. In one implementation, the choice of whether the implementation of a pattern should be generated at design time or at run time is left as an option for the application developer. The use of configuration data to generate an implementation of a pattern (e.g., a configured pattern component) is described in more detail below.","Application Development Framework",{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 5","b":["500","500","510","510"]},"To enable applications to execute on different platform layers , framework  includes a platform independent component development and run-time layer . In this environment, applications can be developed using modules known as components. Components can be stored in a component repository and reused\u2014that is, each component can have more than one instance, where the component instances are used in multiple applications, or multiple times in the same application. Components can be embedded (nested) within other components, and they can have zero or more visual representations. In one implementation, each component provides three separate interfaces\u2014a programming interface, a data binding interface, and a visual interface. The programming interface can be used by an embedding entity (a component embedder\u2014e.g., a higher level component, or an application) to interact with the embedded component. The visual interface can be used by a component embedder to access and use the visual representations of the embedded component (for example, to form the component embedder's own visual representation). The data binding interface can be used by the component embedder to exchange data with the embedded component.","An example platform independent component development and runtime layer  is the Web Dynpro environment manufactured by SAP. The Web Dynpro environment is based on the Web Dynpro programming model, which conforms to the model-view-controller programming paradigm described below with respect to . In one implementation, platform independent layer  provides a framework for defining application components in a declarative and\/or graphical manner, without needing to program the components for a particular platform layer . Platform independent layer  also provides interfaces, tools, services, and other features to enable the application components to execute on a specific platform layer . In another implementation, platform independent layer  additionally provides functionality to enable application components to render user interfaces on a number of different clients, with platform independent layer  performing the appropriate transformations for specific clients.","Building on top of platform independent layer , framework  includes a pattern layer  with one or more generic UI patterns. Each UI pattern is generic because it defines a particular pattern (e.g., a floor plan pattern, an OIP, an ODP, a GDP, and the like), but not the specific content that is included for a specific application that uses that pattern. The specific content for a specific application is created by configuring the pattern as described above.","In one implementation, each UI pattern includes a configuration application and a pattern component. The configuration application and the pattern component for each UI pattern can be applications that are developed and executed on the platform independent layer  shown in . Using this approach, the configuration application and the pattern component for each UI pattern can take advantage of the features offered by platform independent layer , including, for example, platform independence, client independence, and various functionality offered by platform independent layer , such as automatic input help and validation based on declared data types.","In one implementation, each UI pattern is implemented as a single Web Dynpro application , illustrated in . The single Web Dynpro application has two components, a configuration component  that performs the functionality of the configuration application, and an execution component  that performs the functionality of the pattern component. Alternatively, as illustrated in , the Web Dynpro application  can be developed using a single component  with two entry points\u2014one for configuration  and one for execution . The application  uses a different entry point depending on whether it is being used for configuration or execution of the pattern.","Yet another alternative, illustrated in , is for each UI pattern to be implemented as two separate Web Dynpro applications\u2014one for configuration  and one for execution . Each of the two Web Dynpro applications is developed using a separate component\u2014i.e., the configuration application  includes a configuration component, and the execution application  includes a pattern or execution component.","Referring back to , the top layer, application layer , contains the actual applications to be run by end-users. In this framework, an end-user application is made up of one or more configured UI patterns. In an implementation where each UI pattern includes a pattern component, an end-user application is made up of one or more configured pattern components (e.g., pattern components and their corresponding configurations). An end-user application can be stored in a configuration repository in the form of configuration data and references to the associated pattern components.","Framework  thus enables application developers to develop applications by configuring generic pattern components into components for specific applications (e.g., components that display the actual fields illustrated in UI ). In one implementation, as described in more detail below, configuration data (e.g., data in a configuration repository or in one or more configuration files) is used to configure a generic pattern component into a component for a specific application. The configuration data can be defined through the use of declarative and\/or graphical tools that are included, for example, in a configuration application, thus dramatically simplifying the task of developing applications. If, for example, the configuration application has access to a meta data repository that specifies the fields available for a particular back-end system for which an application is being developed, the application developer can develop an application (e.g., create a configuration) by simply choosing the fields in the meta data repository to be included (e.g., displayed) in the application.","Framework  can be thought of as creating a role-based programming methodology, where layers , , , and  correspond to different roles for different developers. Framework  is illustrated as a triangle to represent graphically that complexity and difficulty decrease for each role as one moves from the base layer to the top layer. Thus, a developer who is responsible for building and maintaining the platform independent layer  has the most complex and difficult job, and must be familiar with the programming languages, tools, and other intricacies of one or more platform layers . A developer who is responsible for building and maintaining UI patterns (e.g., configuration applications and pattern components) has a simpler job, as he or she can take advantage of the features and functionality offered by the platform independent layer , as described above. Finally an application developer (a developer who is responsible for developing end-user applications) has the least complex job, as he or she can create applications simply by configuring predefined UI patterns. Where the configuration process is as simple as using a configuration application to choose the desired fields from a set of available fields, the application developer may not need to have any advanced programming skills.","Example OIP Pattern Component","As described above, an application can be built by configuring a generic pattern component.  illustrates an example of a generic pattern component  for an OIP. Component  follows a model-view-controller (MVC) paradigm, and as such includes a model , a view , and a controller . In the MVC paradigm, models generally implement application logic. Each model can have multiple views, where each view displays information about the model to a user. A controller of the application receives events, for example, raised by a user interacting with a view to manipulate the model. A model can have multiple controllers. Controllers can relate to zero or more views. Controllers can also relate to an application in general, or to one or more application parts or components. Models and controllers typically include application code. When changes occur in a model, the model can update its views. Data binding can be used for data transport between a view and its model or controller. For example, a table view can be defined to display data from a corresponding table that is stored in a model or controller. The table view is thus bound to the table, indicating that the table is to be used as the data source for the table view. As another example, the table view can be replaced by a further view, such as a linked list, that binds against the same table. In this case, the further view can display the table data without requiring any changes to be made to the controller or the model.","As explained earlier, an OIP provides an interface to search for and select objects. Accordingly, the model  in the OIP component  includes a query  (e.g., a query class). Because an OIP is a generic UI pattern, query  represents a generic query. In one implementation, query  includes an input structure  of n parameters allowed for queries, and a result structure  of m fields returned for each object meeting the search criteria.","View  of component  defines a user interface with a generic arrangement of UI elements for performing searches. View  includes a title bar  that displays a caption to orient the user. View  also includes a search bar with a drop down element  in which the user can select from the available input parameters selected from the input structure . The search bar also includes a text entry box  in which the user can enter a match criterion for a search, and a \u201cGo\u201d button  to initiate the search.","Controller  of component  binds the UI elements of view  (e.g., UI elements , , and ) to data elements in a storage area (referred to as a context) that is associated with the controller . The context is a structured storage area with hierarchically arranged nodes and attributes. The context associated with the controller  includes a query node  that includes an input structure . The input structure  in the controller context corresponds to the input structure  in the model , and can include up to the n parameters included in the input structure .","When the OIP pattern component  executes, the component receives configuration data (e.g., from a configuration repository or one or more configuration files), and, based on that configuration data, generates child elements for the input structure context node , and binds those elements to elements in the view  and the model .","As an example, consider an application that allows end-users to search for and retrieve information about a company's customers. To create such an application, a developer can configure an OIP pattern to use a specific back-end system with customer information, e.g., a system represented by back-end specific model . Back-end specific model  indicates that the back-end system in this example can execute a query called customer query  that takes up to three input parameters (a customer number, customer name, and customer city, as specified in the customer query input structure ), and returns records with six fields (the six fields specified in the customer result structure ). In an example configuration, an application developer might specify that users should be able to run searches based on any of the three available input parameters (i.e., that all three of the input parameters in the customer query input structure  should be listed in the drop down element ). The developer might further specify that the content display area below the search bar in view  should display all six of the available return fields listed in customer result structure .","The preceding configuration can be specified as configuration data, an example of which is shown as XML data  in . The XML configuration data , which is discussed in more detail below, can be used to generate the execution-related entities in the pattern component  that are required to implement the specified configuration for the OIP pattern. For example, in an implementation in which applications (including pattern components) are structured according to the Web Dynpro programming model, several types of entities can be generated based on the configuration data, including UI elements (e.g., controls in views), data structures (e.g., context entities such as nodes and attributes), and bindings (e.g., context bindings, which serve to couple UI elements and context entities, and model bindings, which serve to couple context entities and model entities).","As a specific example, the XML configuration data  includes a first section of data  that indicates that the pattern component  is to execute searches using a query object named \u201cCustomerQuery\u201d in a back-end service module named \u201cCustomer.\u201d A service module is a grouping of functionality in a back-end system; the functionality can include business functionality that defines business objects or other entities (e.g., customers), and that provides access to such entities (e.g., through query objects such as CustomerQuery). In this example, the CustomerQuery query object is represented by the customer query object  in the model .","As discussed above, the application developer has chosen a configuration in which end-users are to be able to execute searches using any of the three available input parameters in the customer query object . This selection of input parameters is indicated in a second section of configuration data , which lists all three parameters (Number, Name, and City) from the input structure  in the customer query object .","In particular, the Number parameter  in the input structure  is listed in the section of configuration data . The Number parameter  represents customer numbers, and its selection as an available search parameter means that application end-users are to be able to search for customers by providing a customer number (as well as possible additional parameters). To enable such searches, a number of execution-related entities are added to the pattern component , including a Number UI element  and a Number context attribute .","The Number UI element  is added to the view  so that an end-user can type in a customer number in that UI element. Though not shown in the preview of the view  in , the UI element  can be displayed and enabled in the view , for example, when an end-user selects an \u201cadvanced search\u201d option that exposes a form with multiple fields in which the end-user can enter search criteria. Based on the configuration data , the UI element  is given the label \u201cCustomer No.\u201d Moreover, because the configuration data  indicates that string-type input is to be provided for the Number input parameter, the UI element  is set to be a control that is operable to receive such input (e.g., a text box).","The Number attribute  in the context associated with the controller  can be used by the pattern component  to store input data provided by an end-user in the UI element . As with the type of the Number UI element , the type of the Number attribute  can be set based on the data type indicated in the configuration data  (in this case, a \u201cstring\u201d type). The coupling between the Number UI element  and the Number attribute  can be enabled by binding the Number UI element  and the Number attribute . Bindings between other types of entities can also be created\u2014for example, a context attribute (e.g., the Number attribute ) can be bound to a model entity (e.g., the Number parameter  in the input structure  of the query object ). Such a binding, known as a model binding, generally serves to couple an item with a model entity that represents an abstraction of business logic in a back-end system.","Similar entities (e.g., UI elements, data structure elements, and bindings) can be generated for the other two input parameters (Name and City) specified in the section of configuration data . In addition, many other types of entities can be generated based on the configuration data specified by an application developer. Such entities can be used by a pattern component for purposes of navigation and for other UI-related issues. For example, various entities can be generated for purposes of implementing advanced UI functionality, such as input help and input validation.","The use of configuration data to generate execution-related entities for a pattern component can be carried out at various times, including, for example, in a pre-execution step (e.g., after the configuration data has been specified), when the pattern component or application is loaded into a runtime system or otherwise launched, or during execution of the pattern component or application. In one implementation, the entities are generated on an on-demand basis as they are needed. For instance, in the preceding example, the Number UI element  can be generated when the view  is first displayed, or even when the Number UI element  first becomes visible (e.g., when the end-user exposes an \u201cadvanced search\u201d form in the view ).","Example Configuration Data","To configure a UI pattern (e.g., as in the example configuration described above), a developer can associate the pattern with a specific back-end system and the entities (e.g., queries, input structure, input parameters, input fields, result structure, and\/or result fields) available within that back-end system. As described above, such an association can be specified as configuration data stored in a configuration repository or in one or more configuration files. The application developer can use a configuration application that assists him in selecting a back-end system, determining which parameters and other entities exist in the back-end system, selecting an appropriate set of those entities for an application, and specifying all such selections as formatted configuration data (e.g., in a formatted configuration file).","In one implementation, the configuration application uses an interface layer that provides a generic interface to back-end systems. An example of such an interface layer is the interface layer in the Enterprise Service Framework (ESF) developed by SAP. The interface layer includes a repository with meta data corresponding to the back-end data.","Using the example in , the back-end specific model  can be stored as meta data in the meta data repository of an interface layer. The application developer can determine from this meta data that the customer query  (defined by the back-end system) is one used to find customer objects. The meta data repository further includes the parameters  of the input to the query, namely a number, a name, and a city. The configuration application enables the application developer to select any combination of input parameters  that is to be presented in drop down element  when view  is rendered. The application developer can also select which of the fields in result structure  are to be displayed when result objects are returned from the back-end system in response to a query.","An example of configuration data that defines the search portion of a specific application (i.e., that specifies a configuration for a search pattern) is shown below:",{"@attributes":{"id":"p-0092","num":"0091"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<?xml version=\u201c1.0\u201d encoding=\u201cUTF-8\u201d ?>"]},{"entry":[{},"<SearchView Caption=\u201cCustomer Search\u201d>"]},{"entry":[{},"\u2003<Query Service Module=\u201cCustomer\u201d Query=\u201cCustomerQuery\u201d>"]},{"entry":[{},"\u2003\u2003<QueryParameters>"]},{"entry":[{},"\u2003\u2003\u2003<Number Label=\u201cCustomer No.\u201d Type=\u201cstring\u201d\/>"]},{"entry":[{},"\u2003\u2003\u2003<Name Label=\u201cLast Name\u201d Type=\u201cstring\u201d\/>"]},{"entry":[{},"\u2003\u2003\u2003<City Label=\u201cCity\u201d Type=\u201cstring\u201d\/>"]},{"entry":[{},"\u2003\u2003<\/QueryParameters>"]},{"entry":[{},"\u2003<\/Query>"]},{"entry":[{},"<\/SearchView>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In this example, the configuration data is represented using XML. Taking the data in order, the first line defines the version and encoding of the XML file. The next line defines the caption that is inserted into the generic caption text  of pattern view . As indicated, the application associated with this configuration displays \u201cCustomer Search\u201d in the title bar to orient the user that he or she is searching for customers. The next line specifies that the query to be executed for this application is the \u201cCustomerQuery\u201d query within the \u201cCustomer\u201d service module in the back-end system.","The next five lines specify the input parameters selected by the application developer to be included in drop down element . As indicated in the data, the application developer has selected all three of the available input parameters , namely \u201cNumber\u201d, \u201cName\u201d, and \u201cCity\u201d. Further, the application developer has defined more user-friendly labels for each of the parameters. The configuration data also defines the data type for each of the parameters, so view  can provide an appropriate control for each selected field. For example, in an advanced search view, a checkbox can be provided for a Boolean type input parameter, rather than the text entry box that is typically used for string type input parameters.","Although an application developer can generate configuration data directly, the use of a configuration application can advantageously enforce the required schema for the configuration data, so as to ensure that the configuration data is successfully merged with a generic pattern component to generate a specific application.",{"@attributes":{"id":"p-0096","num":"0095"},"figref":"FIG. 7","b":["712","717","715","725","717","710"]},"To create a specific application  for a specific type of business process, an application developer  can configure a floor plan pattern that corresponds to that type of business process (as well as possibly one or more nested patterns). In the implementation shown in , the process of configuring a pattern involves the use of a configuration application  to create configuration data  for a corresponding pattern component . The configuration application  can be designed to be very simple to use\u2014e.g., it can be designed to let an application developer configure a pattern by simply choosing among multiple alternatives for each required piece of configuration data. Accordingly, application developers need not have programming skills\u2014rather, they can be non-technical people, such as program managers or business executives who are experts in a particular application or business area.","Multiple application development scenarios are possible. For example, patterns can be delivered by a pattern provider to a customer either with or without corresponding configurations. In the former scenario, an application developer on the pattern provider side configures a pattern and delivers a fully-configured pattern-based application  that is ready to be used by an application end-user  on the customer side. In the latter scenario, the pattern provider delivers only the patterns (e.g., the configuration applications and the pattern components) to the customer, and an application developer on the customer side creates a pattern application  by configuring one or more of the patterns. As another possible scenario, an application developer on the pattern provider side can create and deliver pre-configured applications, which can either be used directly by an end-user, or further adapted by an application developer on the customer side (e.g., by modifying the delivered configurations) in order to meet the specific needs of the customer.","Testing Pattern-Based Applications",{"@attributes":{"id":"p-0100","num":"0099"},"figref":"FIG. 8","b":["815","805","800","815","800","805","815"]},"The testing environment shown in  includes a pattern test script  for the pattern  used by the pattern application . A pattern test tool  uses the pattern test script  and the pattern configuration  to generate a pattern application test  that is used to test the pattern application . Generating the pattern application test  can include generating test data required by the pattern application test . In one implementation, the pattern application test  is an application-specific test script that can be used to test the pattern application. Alternatively, the pattern application test can be a series of test sequences or function calls that are executed directly by the pattern test tool .","The pattern test script  knows what functionality is implemented by the corresponding pattern , and includes the logic required to test that functionality as configured in pattern applications . The pattern test script  can encapsulate data and instructions or commands to test the functions implemented by the pattern  in one or more user interface environments. The pattern application test  can test the pattern application  by testing each pattern  used by the pattern application and configured according to a corresponding pattern configuration. The pattern application test  can test the pattern application  using one or more layers of the framework  (), e.g., the generic pattern layer , the platform independent component development and runtime layer , and the platform layer .","The pattern application  can include a hierarchical arrangement of one or more patterns. Each pattern  can have an associated configuration application, and a pattern configuration  can be created for each pattern  using the associated configuration application. The pattern configurations  for the patterns  used by the pattern application  can be stored in the configuration repository.",{"@attributes":{"id":"p-0104","num":"0103"},"figref":"FIG. 9","b":["815","810","800","815","900","805","800","815","905","810","805","820","825","910","815","825","915"]},{"@attributes":{"id":"p-0105","num":"0104"},"figref":"FIG. 10","b":["815","910","800","815","805","1000","800","800","815","825","800","825","815","805","800","815","1005","800","825","825","815","1000","1005","800","815","1010"]},{"@attributes":{"id":"p-0106","num":"0105"},"figref":"FIG. 11","b":["815","815","1100","805","1105","805","1110","820","810","805","1115","1120","810"]},"In one implementation, the pattern test script  verifies the search results by counting the number of results returned to the pattern application , and ensuring that the pattern application  displays all the search results. In an alternative implementation, the OIP pattern test script verifies that each search result returned to the pattern application  can be selected, and that the selected search result is appropriately highlighted. If the pattern application includes an ODP pattern that displays the selected search result, the test script can verify that the tab strips and fields displayed by the ODP pattern match the corresponding pattern configuration .",{"@attributes":{"id":"p-0108","num":"0107"},"figref":"FIG. 12","b":["825","815","805","1200","805","810","805","805","1205","1210","1215","1220","1220","1230","1210"]},{"@attributes":{"id":"p-0109","num":"0108"},"figref":"FIG. 13","b":["825","815","810","805","1300","805","1305","1305","1310","1315","1320","1325","1310","1315","1330","1310"]},"The invention can be implemented in digital electronic circuitry, or in computer hardware, firmware, software, or in combinations of them. The invention can be implemented as a computer program product, i.e., a computer program tangibly embodied in an information carrier, e.g., in a machine-readable storage device or in a propagated signal, for execution by, or to control the operation of, data processing apparatus, e.g., a programmable processor, a computer, or multiple computers. A computer program can be written in any form of programming language, including compiled or interpreted languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A computer program can be deployed to be executed on one computer or on multiple computers at one site or distributed across multiple sites and interconnected by a communication network.","Method steps of the invention can be performed by one or more programmable processors executing a computer program to perform functions of the invention by operating on input data and generating output. Method steps can also be performed by, and apparatus of the invention can be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).","Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer. Generally, a processor will receive instructions and data from a read-only memory or a random access memory or both. The essential elements of a computer are a processor for executing instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks. Information carriers suitable for embodying computer program instructions and data include all forms of non-volatile memory, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in special purpose logic circuitry.","The invention can be implemented in a computing system that includes a back-end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front-end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the invention, or any combination of such back-end, middleware, or front-end components. The components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (\u201cLAN\u201d) and a wide area network (\u201cWAN\u201d), e.g., the Internet.","The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.","The invention has been described in terms of particular embodiments, but other embodiments can be implemented and are within the scope of the following claims. For example, the operations of the invention can be performed in a different order and still achieve desirable results. In certain implementations, multitasking and parallel processing may be preferable. As another example, although the use of UI patterns has been described in connection with business objects and business data, patterns can be used with other types of objects and with data that is not business-related.","Patterns can also be developed using different development processes in different development environments, and executed in different run-time systems. For example, patterns can be developed using an integrated development environment (IDE) that incorporates tools for building, testing, deploying, and maintaining applications (e.g., configuration applications and pattern components). Such tools can include visual development tools, templates (e.g., code templates), and class libraries. A class library can include base classes that provide basic functionality (e.g., input\/output, string manipulation, and network communication), as well as specialized classes that provide enhanced functionality (e.g., classes for building and using graphical user interfaces on clients, and for offloading application functionality onto smart clients). Where an IDE supports multiple languages, class libraries can provide a consistent development interface across those languages.","In addition, some IDEs also provide services and functionality that can be used to reduce the amount of code that needs to be written manually. Such functionality can include, for example, the ability to declare and bind to data types, and the ability to bind application elements such as controls and data structures.","IDEs can also provide code generation capabilities\u2014for example, the ability to automatically generate plumbing code (e.g., code for drawing windows or accessing Web services), or the ability to automatically generate run-time code (e.g., by using code generators, compilers, or both). The automatic generation of run-time code allows programs to be targeted to multiple platforms. For example, a code generator can be used to automatically generate run-time code for one or more specific platforms based on the program code produced by a developer. Alternatively, the developer code can be compiled for a run-time system, which can be hosted in multiple environments (e.g., servers, clients, or a combination of servers and clients).","Some IDEs also provide the ability to create metadata that specifies descriptive information about an application, and that can be used by a run-time system to provide services to the application. Metadata can be explicitly declared by a developer, generated in the process of generating run-time code, or both.","Examples of IDEs that can be used to develop patterns include IDEs that are built using the open Eclipse Platform supported by the Eclipse Foundation (e.g., the Web Dynpro IDE developed by SAP, or the WebSphere Studio IDE developed by IBM Corp. of Armonk, N.Y.), as well as proprietary IDEs (e.g., the Visual Studio NET IDE developed by Microsoft Corp. of Redmond, Wash.).","The overall process of developing a pattern (including, e.g., developing a configuration application and a pattern component) can include a design time aspect and a run-time aspect. The design time aspect can involve use of the IDE to write code and to declare attributes, bindings, and other metadata. The code and the metadata can then be used to generate run-time code to be executed in a run-time system. Some development environments can be coupled to a corresponding run-time system, which allows programs developed in such development environments to take advantage of services offered by the corresponding run-time systems. For example, in the Web Dynpro environment discussed in conjunction with , applications can take advantage of services such as input help and validation offered by the Web Dynpro runtime, which frees developers from having to code such functionality manually into their programs.","Run-time systems provide a code execution environment that generally includes core services (e.g., memory, process, and session management), as well as enhanced services (e.g., input help and validation). In addition to the Web Dynpro runtime, other examples of run-time systems include virtual machines (e.g., the Java Virtual Machine), and the Common Language Runtime (a run-time system developed by Microsoft Corp.) As specified above, run-time systems can be hosted in multiple environments, including servers and clients. Servers generally provide a core operating environment for applications (e.g., by providing a run-time system in which the applications can execute). An example of a server is a J2EE-compliant server, such as the Web Application Server from SAP or the WebSphere Application Server from IBM Corp."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIGS. 4A-4C"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIGS. 6A-6B"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 13"}]},"DETDESC":[{},{}]}
