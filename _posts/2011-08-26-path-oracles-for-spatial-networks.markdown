---
title: Path oracles for spatial networks
abstract: One embodiment of the invention is directed to a method including constructing a path-distance oracle that provides both an intermediate vertex of a shortest path between two vertices in a spatial network and an approximate distance between the two vertices. The constructing comprises decomposing the spatial network into a set of path-coherent pairs (PCPs) that satisfy at least one predefined property.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08744770&OS=08744770&RS=08744770
owner: University of Maryland, College Park
number: 08744770
owner_city: College Park
owner_country: US
publication_date: 20110826
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","GOVERNMENT SUPPORT","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application claims priority from provisional application Ser. No. 61\/377,795 filed on Aug. 27, 2010, the contents of which is hereby incorporated by reference in its entirety.","This invention was made with government support under contract no. CCF0830618 awarded by the NSF. The government has certain rights in the invention.","1. Field","Embodiments of the invention relate to systems and methods for finding shortest paths in spatial networks.","2. Description of the Related Art","The trend towards smaller computing platforms and mobile devices, as well as the concomitant increase in their power, has led to an increasing interest in their use to facilitate the mobility of their owners. This has resulted in the development of a new component of the software industry known collectively as location-based services. Such location-based services can be used to continuously monitor ever-changing user positions as well as their destinations, and provide up-to-the-minute (second) information about their environment, as well as paths to their destinations. This is especially useful in an emergency response environment where destinations may change given the continuously changing conditions on the ground. The challenge in providing location information includes the fact that these paths are not simple to compute as it is desirable to take the shortest paths, and the total distance is computed along a network instead of \u201cas the crow flies.\u201d","In fact, changes may occur so quickly that there may not be enough time to compute exact answers and, therefore, many solutions resort to estimates (i.e., approximate answers) with some guarantee of optimality (i.e., within some tolerance e). Moreover, in these situations, there is a need to interact with a multitude of information sources such as road networks, building diagrams, service areas, etc. Increasingly, these information sources are stored in databases that must be accessible using a common interface (i.e., language), most often some variant of SQL.","One embodiment of the invention is directed to a method including constructing a path-distance oracle that provides both an intermediate vertex of a shortest path between two vertices in a spatial network and an approximate distance between the two vertices. The constructing comprises decomposing the spatial network into a set of path-coherent pairs (PCPs) that satisfy at least one predefined property.","Another embodiment is directed to an apparatus including a processor, and memory including computer program code. The processor and memory are configured to control the apparatus to construct a path-distance oracle that provides both an intermediate vertex of a shortest path between two vertices in a spatial network and an approximate distance between the two vertices. The processor and memory are further configured to control the apparatus to construct the path-distance oracle by controlling the apparatus to decompose the spatial network into a set of path-coherent pairs (PCPs) that satisfy at least one predefined property.","Another embodiment includes a computer program, embodied on a non-transitory computer readable medium. The computer program configured to control a processor to perform a process including constructing a path-distance oracle that provides both an intermediate vertex of a shortest path between two vertices in a spatial network and an approximate distance between the two vertices. The constructing comprises decomposing the spatial network into a set of path-coherent pairs (PCPs) that satisfy at least one predefined property.","Spatial networks may refer to general graphs whose vertices and edges are augmented with spatial information. S denotes a d-dimensional embedding space (i.e., a reference coordinate system), which is two-dimensional for road networks. A spatial network can be abstracted to form an equivalent graph representation G=(V,E), where V is the set of vertices, E is the set of edges, n=|V|, and m=|E|. Given edge e\u2208E, w(e)\u22670 denotes the distance along e. In addition, for every v\u2208V, p(v) denotes the spatial position of v with respect to S.","A path \u03c0 of length k is a sequence of vertices (\u03c0, . . . , \u03c0) such that (\u03c0, \u03c0)\u2208E for 1\u2266I\u2266k, where \u03c0is referred to as the source vertex of \u03c0 and \u03c0is referred to as the destination vertex of \u03c0. \u03c0(u, v) denotes a path (not necessarily the shortest path) with u as its source vertex and v as its destination vertex. The sequence of edges that make up the path \u03c0 is denoted by the sequence \u03c6(\u03c0), where \u03c6(\u03c0)=(\u03c0, \u03c0). Furthermore, the weight w(\u03c0) of a path \u03c0 of length k is w(\u03c0)=\u03a3w(\u03c6(\u03c0)). Two paths \u03c0(v, t) and \u03c0(t, u) can be composed to form another path \u03c0 denoted by \u03c0\u2192\u03c0. A subpath of a path \u03c0 is a subsequence of \u03c0. The set of vertices that make up the shortest path between a pair of vertices u, v \u00ce V is denoted by \u03c0(u, v). Also, any subpath \u03c0(r, t) of \u03c0(u, v) is also the shortest path between r and t. If there are multiple shortest paths of the same length between vertex pairs, extra care must be taken to ensure that the above property holds. In such cases, the first path in the lexicographic ordering on the set of possible shortest paths is chosen, such that the ordering is defined on triples (w(\u03c0), k, reverse(\u03c0)), where the reverse operator takes an ordered set as input and reverses its ordering. Furthermore, two sequences \u03c0and \u03c0are disjoint, if and only if \u03c0\u2229\u03c0=\u00d8. Notice that if two paths \u03c0(v, t) and \u03c0(t, u) are disjoint from a path \u03c0* then the path \u03c0\u2192\u03c0is also disjoint from \u03c0*. Moreover, if \u03c0is disjoint from \u03c0then any subpath of \u03c0is also disjoint from \u03c0.","For vertices u, v \u00ce V, d(u, v)=w(\u03c0(u, v)) is defined to be the shortest network distance from u to v with respect to G(V, E). The spatial distance d(u, v) (i.e., \u201cas the crow flies.\u201d) between vertices u, v\u2208V in a spatial network is defined as a function on p(u) and p(v). Also, l(v) is defined to be the next vertex visited (after u) on the shortest path from u to v. Note that the first edge on the shortest path from u to v is (u, l(v)).","T is the root block of a PR-quadtree H on the spatial positions of the vertices V. A PR-quadtree is a hierarchical decomposition of the embedding space S such that every block is decomposed into 2children blocks until a leaf block is obtained, which corresponds to a region in space containing a single vertex in V. A non-leaf block in H, on the other hand, represents a region in the embedding space containing a subset of vertices (more than one) in V. An addressing scheme for a block b can be devised by a bit-encoding obtained by concatenating the bits corresponding to the path taken to reach b from the root block T. Embodiments of the invention may use this representation, also known as the Morton Blocks, in order to uniquely identify blocks in a PR-quadtree.","Embodiments of the invention address how to find shortest paths in a dynamically changing environment which is only the first step in being able to perform a wide variety of operations on spatial networks such as region searches, nearest neighbor finding and distance joins. One challenge is that finding shortest paths and distances invariably involves a search process (e.g., via use of a shortest path algorithm), which takes quite a bit of time, and is not a satisfactory solution in terms of data that is organized using a relational database and is accessed via SQL SELECT operations, for example. Embodiments of the invention are based on pre-computing the shortest paths between all possible sources and destinations, and encoding them in a compact form which lends itself to being stored and retrieved in\/from a conventional relational database.","Certain embodiments extend the concept of the shortest-path map, whose representation by the shortest-path quadtree, enabled a reduction in the necessary storage for the set of all of the shortest paths from O(n) to O(n). This was achieved by taking advantage of the fact that the shortest paths from a particular vertex v to all of the remaining vertices can be partitioned into i subsets depending on the identity of the first edge (there are i such edges) on the shortest paths to them from v. For example,  illustrates a space partition induced by aggregating vertices sharing the same first link  in the shortest path from a given source vertex in a road network. This is characterized as taking advantage of the path coherence of the destination vertices. In one embodiment, the shortest paths are derived by an iterative process that repeatedly finds the next vertex or edge to the destination and thus lends itself to a database solution (i.e., the repeated retrieval of information) rather than a graph search. In particular, the process is several times faster than conventional graph-based solutions, and also casts a nice balance between offline and online computation of the shortest paths.","Embodiments of the invention are able to reduce the space requirements from O(n) to O(n) by also capturing the path coherence of the source vertices, instead of just the path coherence of the destination vertices. As an example of the advantage of capturing the path coherence of source vertices, someone who is driving along the shortest route from the Northeast of the US to the Northwest Coast of the US will invariably end up using Highway I-80 West. This path coherence is most evident when the sources and destinations are sufficiently far apart in the road network. For instance, of the amount of space that can be potentially saved, suppose that there are one million source vertices and one million destination vertices. If for each such pair of vertices, a vertex on I-80West is stored, this would incur a storage cost of 10pieces of information; while when using the path coherence techniques, storage can be achieved in O(1) space by virtue of storing just one item of information for the set of vertices in the Northeast Coast, one intermediate vertex, and one item of information for the set of vertices on the Northwest Coast.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 2","FIG. 2"],"b":"12","sup":"2"},"Embodiments of the invention use the term oracle to describe a data structure, or representation, or a relation in a database that captures all the shortest paths. Three such oracles are described in this disclosure.","First, given a source and a destination vertex in a spatial network G, and letting s be a factor depending on G, embodiments of the invention provide a path oracle of size O(sn) that enables the retrieval of an intermediate vertex on the shortest path between them in O(log n) time. This may be done via use of a B-tree.","Next, for a source and a destination vertex in a spatial network G, an \u03b5-approximate distance oracle that requires O(n\/\u03b5) space can be constructed that enables the retrieval of a network distance between the two vertices that lies within \u03b5 of the true network distance between them in O(log n) time.","Finally, embodiments of the invention provide a combination of the path oracle and distance oracle to define a path-distance oracle that can provide both an intermediate vertex, as well as an \u03b5-approximate distance in O(log n) time using O(n\u00b7max(s, 1\/\u03b5)) space via the use of a B-tree.","Experimental results show that for road networks of different sizes n (for which s turned out to lie in the range 8.15), the size of the path-distance oracle is about 122n and provides answers in 10-35 \u03bcseconds for \u03b5=20%. When \u03b5 was allowed to vary between 1 and 50%, and n was kept constant at 91,113, the size of the path-distance oracle was O(n\u00b7max(12, 2.5\/\u03b5)) and provided answers in 30-35 \u03bcseconds. According to certain embodiments, access times can be further improved to O(1) by making using of a hash table that takes O(sn log n) for path oracles and O(n log n\u00b7max(s, 1\/\u03b5)) for path-distance oracles.","Embodiments of the invention demonstrate that shortest paths can be computed by the repeated application of a SQL SELECT statement, or some other equivalent database operator. Moreover, by having the ability to refine the paths, the network distance value can also be refined, which is an improvement on previous solutions that only provided one predicted approximate distance value. This ability to refine the distance enables embodiments of the invention to obtain exact values and thereby enables obtaining exact, rather than approximate, responses to a number of spatial queries via SQL relational operators, for example. The path-distance oracle on a spatial network may be related to oracles on other kinds of graphs (e.g., general graphs) as well as to those that view spatial networks as a general metric space and apply an embedding method.","According to embodiments of the invention, pre-computation of the shortest-paths obviates the need to search, and instead replaces it with a retrieval process which is much faster. Additionally, query processing using the oracles according to embodiments of the invention and the shortest-path quadtree perform operations that are spatial in nature and hence, more suitable for incorporation into a database. Finally, once the representation is computed for a spatial network it can be used in conjunction with any dataset of entities (e.g., restaurants, coffee shops) that lie on the spatial network as long as the network itself remains unchanged.","Vertices in a spatial network that are spatially close to one another share a number of common properties. For example, often two vertices u, v that are spatially close to each other share large common segments of their shortest paths to two other vertices t, w that are also spatially close to each other, but far from u, v. The term path coherence describes this coherence between the shortest paths from nearby sources to nearby destinations.  illustrates a configuration of source A and destination B vertices such that every shortest path from a vertex u\u2208A to a vertex t\u2208B passes through a particular set of vertices. Two sets of vertices A, B are said to form a Path-Coherent Pair (PCP) if all the shortest paths from source vertices in A to destination vertices in B have at least one vertex or one edge  in common, as shown in . According to embodiments of the invention, a path oracle relies on decomposing a given spatial network G into path-coherent pairs such that they capture all the nshortest paths in G.","The arrangement of vertices and shortest paths in  describes a dumbbell-like structure. A PCP (A, B, \u03a8, \u03bb) in a spatial network G(V, E) includes a set of source vertices A\u2282V, a set of destination vertices B\u2282V, a set \u03a8 which is a vertex or an edge such that all the shortest paths from source vertices in A to destination vertices in B contain \u03a8, \u03bb\u2208R approximates the network distances of all the shortest paths from A to B. A and B are referred to as the heads of the PCP. A PCP (A, B, \u03a8, \u03bb) belongs to one of the two possible configurations given below:\n\n","Given a spatial network G, embodiments of the invention perform a decomposition GG of G, into a set of PCPs, such that the resulting decomposition has the following properties:\n\n","The first property ensures that the decomposition of G results in a set containing l PCPs, where the iPCP in the decomposition is denoted by (A, B, \u03a8, \u03bb). The second property ensures that the heads Aand Bof a PCP are disjoint. The third property ensures that any pair of vertices (u, v) in G is contained in exactly one of the PCPs in the decomposition. This also means that the PCP decomposition contains all the nshortest paths in G. Below are the definitions of path, distance and path-distance oracles according to an embodiment:\n\n","Embodiments of the invention include a method that constructs path, distance, and path-distance oracles. Table 1 shown below lists an example of a PCP decomposition method in pseudo-code format that decomposes a spatial network G(V,E) into a set of PCPs thereby constructing a path, distance, and\/or path-distance oracle, according to one embodiment. The method takes G, the root block T of a PR-quadtree H on the spatial positions of V, the type of oracle ORACLETYPE, and the quality of approximations as inputs. The possible values for ORACLETYPE are PATH, DISTANCE, or PATH-DISTANCE. The value of \u03b5 should be specified for distance and path-distance oracles, but is assumed to be \u221e for path oracles.","Q refers to a list of block-pairs, which is initialized with the pair (T,T) in line 1 of Table 1. At each stage of the method, a block-pair (A,B) is retrieved from Q and examined in line 3. Note that A and B correspond to blocks in the PR-quadtree on V. If A and B refer to the same block (line 4) and A (and B) is a non-leaf block, then DECOMPOSEANDINSERT operator is invoked with Q, A, and B. The DECOMPOSEANDINSERT operator takes two blocks A and B and a list Q as inputs. It first breaks up A and B into their 2children blocks, forms all possible pairs obtained by taking non-empty children blocks of A and B which are then inserted into Q. Note that if the DECOMPOSEANDINSERT operator is invoked on A and B such that one of them is a Leaf block, it can be still broken up into 2children blocks, but all but one of the children blocks will be empty.","If A and B do not refer to the same block in the PR-quadtree, the PCP decomposition method invokes the FINDPATHCOHERENTPAIRS operator on A and B in line 9 that returns, if it exists, a vertex or an edge \u03a8 that is common to the shortest paths from source vertices in A to destination vertices in B, as well as an approximate network distance \u03bb, and the maximum error \u03b5in approximating the network distances by \u03bb. Optionally, we can also obtain the minimum error in approximating the network distances between vertices in A and B by \u03bb. Both the values of \u03b5and \u03b5can also be stored along with the PCPs in the output. Given (A, B), efficient methods for computing \u03bb and \u03b5are known. One possible way of finding whether a common vertex or edge \u03a8 exists is to compute the shortest path from every pair of source vertices in A to destination vertices in B using Dijkstra's algorithm and determine if there is a vertex or edge in common between all the shortest paths. If there is more than one vertex in common to all the shortest paths then one of the vertices is chosen at random; preferably one not belonging to either A or B. The case that an edge is common to all the shortest paths occurs only if all the shortest paths pass through an edge <u, v>, such that u\u2208A or {u}=A, and v\u2208B or {v}=B. An example of such a configuration arises if a bridge or a tunnel represented by an edge connects vertices belonging to two cities denoted by A and B.","If ORACLETYPE is DISTANCE (line 10), it is examined whether the quality of the approximation \u03b5is less than or equal to the desired approximation \u03b5. If so, the pair (A, B, _, \u03bb) is added to the result set using the REPORTPCP procedure. If not, A and B is split into block-pairs formed by children blocks of A and B, which are then inserted into Q.","If ORACLETYPE is PATH, it is checked whether \u03a8 is empty in which case (A, B) is not a valid PCP and the block-pair (A, B) has to be further decomposed. If \u03a8 is a vertex that does not belong to either A or B, it is reported as a PCP, otherwise it is further decomposed. If \u03a8=(u, v) is an edge, it is ensured that u\u2209B and v\u2209A, in which case it is reported as a PCP. It is noted that all other possible cases, i.e., when u\u2208B, and\/or v\u2208A are all undesirable.","Finally, if ORACLETYPE is PATH-DISTANCE and (A, B, \u03a8, \u03bb) satisfies both the path and distance constraints, it is added to the result set.","The PCP decomposition method terminates when Q is empty at which point the decomposition of G into PCPs is complete. Note that, according to an embodiment, the method breaks up both A and B in a symmetric fashion which means that the heads of the PCP in the output are at the same level in H, and, consequently, of the same size. Further, it should be noted that the output of the PCP decomposition method, according to one embodiment, is an oracle of order n.",{"@attributes":{"id":"p-0046","num":"0053"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Procedure PCPDECOMPOSE[G, T, ORACLETYPE, \u03b5 = \u221e]"},{"entry":"Input: G(V, E) \u2190Input spatial network"},{"entry":"Input: T \u2190 Root node of a PR-quadtree H on V"},{"entry":"Input: ORACLETYPE \u2190PATH, DISTANCE, or"},{"entry":"PATH-DISTANCE"},{"entry":"Input: \u03b5 \u2190Required approximation; \u221e if not specified"},{"entry":"Output: Set of PCPs (A, B, \u03a8, \u03bb, [\u03b5, \u03b5]); [\u03b5, \u03b5] is optional"},{"entry":"(* Q \u2190 list of block-pairs *)"},{"entry":"\u20021. INSERT(Q, (T,T))"},{"entry":"\u20022. while (ISNOTEMPTY(Q)) do"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u20023.","(A;B) \u2190POP(Q) (* Remove head element *)"]},{"entry":["\u20024.","if A = B then"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u20025.","if ISNONLEAF(A) then"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u20026.","DECOMPOSEANDINSERT(Q, A, B)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u20027.","end-if"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u20028.","else"]},{"entry":["\u20029.","\u2003(\u03a8, \u03bb, \u03b5, [\u03b5]) \u2190FINDPATHCOHERENTPAIRS(A,B)"]},{"entry":["10.","\u2003if ORACLETYPE = DISTANCE or PATHDISTANCE then"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["11.","if \u03b5> \u03b5 then"]},{"entry":["12.","\u2003DECOMPOSEANDINSERT(Q, A, B)"]},{"entry":["13.","else if ORACLETYPE = DISTANCE then"]},{"entry":["14.","\u2003REPORTPCP(A, B, \u03a8, \u03bb, [\u03b5, \u03b5])"]},{"entry":["15.","end-if"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["16.","\u2003end-if"]},{"entry":["17.","\u2003if ORACLETYPE = PATH or PATH-DISTANCE then"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["18.","if \u03a8 = \u00d8 then"]},{"entry":["19.","\u2003DECOMPOSEANDINSERT(Q, A, B)"]},{"entry":["20.","else if TYPE(\u03a8) = VERTEX then"]},{"entry":["21.","\u2003if \u03a8\u2208A or {\u03a8} = A or \u03a8\u2208B or {\u03a8} = B then"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["22.","DECOMPOSEANDINSERT(Q, A, B)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["23.","\u2003else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["24.","REPORTPCP(A, B, \u03a8, \u03bb, [\u03b5, \u03b5])"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["25.","\u2003end-if"]},{"entry":["26.","else if TYPE(\u03a8 =< u, v >) = EDGE then"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["27.","if u\u2209B and v\u2209A then"]},{"entry":["28.","\u2003REPORTPCP(A;B;Y=< u;v >;l; [eL;eH])"]},{"entry":["29.","else"]},{"entry":["30.","\u2003DECOMPOSEANDINSERT(Q, A, B)"]},{"entry":["31.","end-if"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["32.","end-if"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["33.","\u2003end-if"]},{"entry":["34.","end-if"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"35. end-while"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"As can be seen, the PCP decomposition method shown in Table 1 decomposes G into a set of PCPs that satisfies properties 1-3 discussed above. Thus, given a vertex pair a, b, it is guaranteed that there exists exactly one PCP (A, B, \u03a8, \u03bb) in the output of the method such that A contains a, B contains b, \u03a8 is an intermediate vertex or edge in the shortest path from a to b, and \u03bb approximates the network distance between a and b.","The REPORTPCP routine shown above in Table 1 stores the PCP decomposition as a relation O in a database system with the following schema: O(AB, IE, VI, Es, EE, \u03bb), where AB are the heads of the PCP represented as a single four-dimensional Morton block, IE is a Boolean flag that indicates if the tuple representing a PCP stores an intermediate vertex or edge. If IE is set to false, then VI stores an intermediate vertex, otherwise <ES, EE> represents an intermediate edge. Finally, the value of \u03bb represents the approximate network distance between the heads of the PCP. Both the heads of the PCP, A and B, correspond to nodes of a PR-quadtree on V. Hence, (A, B) can be compactly represented as a single four dimensional Morton block. A four-dimensional Morton block AB of (A, B) is obtained by first constructing the Morton blocks corresponding to A and B, and then bit-interleaving them to obtain AB. Now, the attribute AB in the relation O is indexed using a B-tree or B+-tree, and the resulting representation is known as a linear quadtree, which is a disk-efficient access structure.","Given a source u and destination v, we can obtain an intermediate vertex or edge in the shortest path between u and v as well as an approximate network distance \u03bb using the relation O by first constructing the four-dimensional Morton block Z(u, v) of (u, v), and using it to search the B-tree or B+-tree on AB for the longest prefix match to Z(u, v), where Z4(\u2022,\u2022) is a function that takes a pair of two dimensional points and converts them into a single four dimensional Morton block representation. Note that Z4(\u2022,\u2022) can be computed in O(1) time using bit-operations. Searching the index on AB takes logarithmic time in the number of tuples in O. According to embodiments of the invention, this can be achieved in O(log n) time as the size of the oracle is linear in n. The above operation corresponds to a \u201cSELECT\u201d operator on O. The shortest path between u and v can be retrieved by the repeated application of the SELECT operation on O.","Another embodiment includes a shortest path method that provides a shortest path between two vertices. Table 2 below illustrates an example of the shortest path method in pseudo-code format that takes a source vertex u and a destination vertex v as inputs, and then retrieves the shortest path \u03c0(u, v) between u and v in G. In lines 1-3 of Table 2, it is checked if u and v are the same, in which case, the shortest path method returns {u}. This is the base case of the method. In line 4 of Table 2, using the Morton block Z(u, v) of u, v as the search key on the B-tree on AB, tuple in O(AB, IE, VI, Es, EE, \u03bb) can be obtained, such that AB contains Z(u, v). Note that the nature of the PCP decomposition guarantees that there will be exactly one matching tuple in O for any search key Z(u, v). If A and B share an edge (in which case IE is set to true as shown in lines 5-6), \u03bb(u, v) is represented as a composition of SPATH(u, ES)\u2192<ES, EE>\u2192SPATH(EE, v), resulting in subsequent recursive calls to the shortest path method. If A and B share an intermediate vertex VI (in which case IE is set to false), two instances of the shortest path method are recursively invoked with inputs (u, VI) and (VI, v) as shown in line 8.",{"@attributes":{"id":"p-0051","num":"0058"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 2"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Procedure SPATH[u, v]"]},{"entry":[{},"Input: u, v \u2190 Source and Destination vertices"]},{"entry":[{},"Output: Shortest path \u03c0(u, v) between u and v"]},{"entry":[{},"(* O(AB, IE, VI, Es, EE, \u03bb) Oracle relation *)"]},{"entry":[{},"1. if u = v then (* Base case of the recursion *)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"2.","return {u}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"3. end-if"]},{"entry":[{},"4. SELECT IE, VI, ES, EE FROM O WHERE AB = Z(u, v)"]},{"entry":[{},"5. if (IE = true) then"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"6.","return SPATH(u, ES)\u2192<ES, EE>\u2192SPATH(EE, v)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"7. else (* IE = false *)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"8.","return SPATH(u, VI)\u2192SPATH(VI, v)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"9. end-if"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Embodiments of the invention are capable of storing the oracle(s) as a relation in a database system. The oracle is seamlessly integrated into the relational database system, indexed using a traditional indexing scheme (e.g., B-tree), and used in complicated query processing scenarios without the need to make any significant changes to existing database systems. For example, one embodiment incorporates a path-distance oracle in a SQL-based system that can perform complex queries on a spatial network using a relational database system. In one example, O is the path-distance oracle with the schema: O(AB, IE, VI, ES, EE, \u03bb, \u03b5, \u03b5). It is noted that the schema has been expanded by augmenting two additional attributes \u03b5and \u03b4, \u03b5\u2266\u03b5\u2266\u03b5 which are the minimum and maximum errors, respectively, due to approximating all the network distances from A to B with \u03bb. The value of \u03b5and \u03b5can be trivially obtained by modifying the procedure FINDPATHCOHERENTPAIRS in PCP decomposition method of Table 1 (line 9) to compute and associate it with a PCP.","In addition, embodiments of the invention introduce a refinement operator which, when given a source u and destination v, can improve upon the quality of the approximation (known as the effective error) provided by \u03bb by retrieving additional intermediate vertices in the shortest path from u to v. Note that an approximate error can be refined at most k times before the exact network distance is obtained, where k is the number of intermediate vertices in the shortest path between u and v. Also, it is assumed that the refinement operator will keep its own state information such as the set of intermediate vertices, effective error, etc., all of which may be abstracted from the user of this system. Further, it is assumed that a number of macros have been provided which given a source and destination vertex, will keep invoking the refinement operator as many times as needed to either achieve a predicted approximation quality, or until a certain condition is satisfied. A few example macros according to some embodiments of the invention are described below.","Approximate Network Distance Query: Given source vertex p and destination vertex q, find an intermediate vertex or edge, approximate network distance \u03bb, and minimum \u03b5and maximum \u03b5errors due to the use of the approximation:","SELECT IE, VI, ES, EE 1, \u03b5, \u03b5FROM O WHERE AB=Z(p, q)","\u03b7-approximate Network Distance Query: Given source p and destination q, find an approximate network distance with an approximation quality of \u03b7 or better. The macro REFINE_UNTIL invokes the refinement operator until the desired approximation \u03b7 is attained:",{"@attributes":{"id":"p-0057","num":"0064"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"SELECT l, \u03b5, \u03b5FROM O WHERE AB = Z(p, q) and"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"REFINE_UNTIL(EFFECTIVE ERROR OF(O.\u03bb)\u2266 \u03b7)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Region Search: Given a query location q, find all restaurants R(position, type) that are within 10 miles of q. The macro REFINE_UNTIL_DECIDE_IF invokes the refinement operator until it is clear if a restaurant is within 10 miles of q or is not:",{"@attributes":{"id":"p-0059","num":"0066"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"SELECT R.position, \u03bb FROM O, R WHERE AB = Z(q, R.position)"},{"entry":"and REFINE_UNTIL_DECIDE_IF(O.\u03bb\u226610 miles)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"k-Nearest Neighbor Search: Given a query location q, find the k closest restaurants in R(position, type) to q that serve Italian cuisine. The results are produced by sorting on the \u03bb values using a comparator (not given here) that is modified so that given two restaurants at distances \u03bband \u03bb, the comparator refines both \u03bband \u03bbuntil it is clear if \u03bb\u2266\u03bbor \u03bb>\u03bb:",{"@attributes":{"id":"p-0061","num":"0068"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"SELECT R.position, \u03bb FROM O, R"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"WHERE AB = Z(q, R.position) and R.type = \u201cItalian\u201d"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ORDER BY O. \u03bb LIMIT k"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Distance Join Operator: Suppose that in addition to R, a relation of coffee shops Q(position, type) is also given. Now, find the k closest pairs of restaurants and coffee shops. This query uses the same sorting operator on \u03bb as in the k-nearest neighbor search:",{"@attributes":{"id":"p-0063","num":"0070"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"SELECT R.position, Q.position, \u03bb FROM O, R, Q"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"WHERE AB = Z(R.position, Q.position)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ORDER BY O.\u03bb LIMIT k"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Embodiments of the invention can optimize queries on spatial networks that are expressed using SQL statements with a path-distance oracle. Any spatial query that is expressed using SQL can be converted into an operator tree, which is a computational tree made up of spatial and non-spatial relational operators. , which is discussed in more detail below, is an example of an operator tree of an SQL query that performs region search on a spatial network. Note that the operator tree shown in is just one of many possible strategies for answering a query. In other words, there are several ways of arriving at the correct answer and the job of generating all possible strategies and choosing among them is typically done by a query optimizer. Although there are many ways of answering a query, they typically have different associated costs. The database system can select the strategy with the least cost.","One scenario where optimization of queries involving path-distance oracles becomes difficult is if the user is only interested in a small subset of tuples, where the criterion for selecting relevant tuples is expressed either directly or indirectly in terms of network distances. For example, consider a query to find all the restaurants, given by the relation R, that are closer than 10 miles on a spatial network from an input address (i.e., point) q. One way of processing this query is to obtain the approximate network distances of every restaurant in R from q by joining the tuples of R with O, and then subsequently pruning away all restaurants that are farther than 10 miles on the spatial network from q. This solution strategy is not very efficient, especially if R is a large relation such as the one containing all the restaurants in the US. Another variation of this query is if the user is only interested in the \u201ctop k\u201d closest restaurants to q in R, in which case, obtaining the network distances of all the restaurants in R from q and subsequently retaining the k closest to q results in wasted work. Both these inefficiencies occur because no restaurant in R can be excluded without first determining its network distance from q, which is not known until R is joined with O. The network distance may not be a computable quantity but, instead, may have to be retrieved from O. This means that a join of R with O may be inevitable at runtime as the identity of the query point q (or a relation S in case of distance joins) is only known at the time of execution of the query.","One embodiment implements a strategy for making query processing using a distance oracle efficient by making the query optimizer aware that the spatial distance between two objects on a spatial network always lower bounds the network distance between them. If the query processor uses this strategy effectively, then it can prune away most of the tuples in R using this relationship between the spatial and network distance functions. For example, in the case of the network range query, the query optimizer can first restrict the output to only contain those tuples in R whose spatial distance from q is less than 10 miles, which are then joined with distance oracle relation O, after which it again prunes those restaurants in R that are farther than 10 miles. Further, in some embodiments, a query optimizer can modify the operator tree suitably so that queries involving the path-distance oracle can be processed correctly and efficiently.","The following is a description of a few of the spatial relational operators that may be needed for query processing and which are commonly available on commercial database systems.","Index Scan: A spatial index, such as a quadtree, is an ordering of the tuples in a relation based on the space that they occupy. A spatial index allows for the browsing or retrieval of the tuples in a relation in many different ways, which we refer to as an index scan. For example, an index scan of R can retrieve tuples based on the distance from a query point q either in an increasing or decreasing order of distances from q. It can even obtain tuples based on containment or non-containment within a geometric shape, or some combination of distance and geometric constraints. An index scan can also be made incremental, which means that we need not specify how many tuples are needed before the start of the query but can keep obtaining more tuples until all the tuples in R have been exhausted. One method for incrementally retrieving tuples in R based on distances from q is the best first nearest neighbor method.","Spatial Select: A spatial select operator, represented by \u03b3, is analogous to its non-spatial variant in the sense that it allows for the pruning of tuples in a relation based on a set of spatial constraints. An example of a spatial selection operation is, given a relation of restaurants in the US, obtain only those restaurants that are in New York city, which is represented by a polygon.","Spatial Join: Given two relations R and S, the distance join R S of R and S generates pairs of tuples (p, q) such that p is drawn from R and q from S, usually subject to an additional constraint involving the values of the spatial attributes of R and S. If the output pairs are ordered either in an increasing or decreasing order of distances between p and q, such a join is referred to as a distance join. The processing of spatial network distance join queries, according to one embodiment, may use the incremental distance join algorithm.","In order to process SQL queries with LIMIT constraints, embodiments of the invention use two SQL operators\u2014STOP and RESTART. STOP operator suspends the output of an operator subtree once a predetermined condition is satisfied. The condition can either be specified in terms of a limit on the numbers of tuples produced by an operator subtree, or some other constraint determined at runtime. RESTART operator restarts a previously suspended operator subtree so that more tuples can be produced. A subtree of an operator tree is said to be restartable only if it can produce more tuples without having to re-compute all the previously computed tuples. Below it will be shown how a query optimizer can optimize queries on spatial networks using a path-distance oracle with the aid of the example macros discussed above.","Approximate Network Distance: Given a source p and a destination q on a spatial network, obtaining an \u03b5-approximate network distance between p and q involves a selection on O with Z(p, q) as the search key. Such a query involves a simple selection operator on the oracle relation O with the aid of the B-tree on Z.","Region Search: illustrates the operator tree corresponding to a query that finds all the Italian restaurants within 10 miles of a query point q. One way of processing such a query is to first determine the \u03b5-approximate network distance of all the Italian restaurants in R, and then prune away all the restaurants in the output that are farther than 10 miles using a select operator. This is an inefficient approach as the query processing will visit every tuple in R, even the ones that are much further than 10 miles from q which will result in wasted work.",{"@attributes":{"id":"p-0074","num":"0081"},"figref":["FIG. 5","FIG. 5"],"i":["b ","b "]},"Note that it is conceivable that a restaurant r in R that is at both spatial and network distances that are a bit more than 10 miles from q, while having an \u03b5-approximate network distance from q that is less than 10 miles owing to the approximation. In this case, some embodiments may miss reporting r even though its approximate network distance is less than 10 miles because r would not be in the initial set of restaurants whose spatial distance from q is less than 10 miles. An embodiment of the invention can overcome this problem by increasing the above spatial distance restriction to (1+\u03b5)\u00b710 miles, which would mean that r will now be reported in the result. In another embodiment, an additional constraint is added to the select operator in the un-optimized algorithm in to prune away all those restaurants that are farther than 10 miles in the spatial distance measure.","k-Nearest Neighbor Search: shows an un-optimized version of a k-nearest neighbor search on a spatial network which suffers from the same drawback as the region search in in the sense that the algorithm ends up retrieving the network distances of all Italian restaurants in R, even though only a small subset of the Italian restaurants (i.e., k of them) are required in the result set. illustrates an example of the optimized nearest neighbor search query. In particular, according to an embodiment, first select all tuples in R that are Italian restaurants which are then joined with the path-distance oracle relation O to yield the network distances of R from q. Only the top k tuples are retained from this set via the use of the STOP operator which corresponds to the k closest restaurants in R to q on the spatial network. Embodiments of the invention optimize the k-nearest neighbor query on spatial networks by obtaining the tuples in R in an increasing order of network distance from q. First, obtain the closest k Italian restaurants to R to q in terms of the spatial distance function, at which time the query subtree is suspended by the STOP operator. Now, these k tuples are joined with the distance oracle relation O to obtain their approximate network distances from q, which are then sorted to yield an upper bound on the network distance of the k farthest restaurant in R, which is referred to as d. Then, the earlier suspended query subtree is restarted (via RESTART) to yield more tuples incrementally in an increasing order of spatial distance from q, until a restaurant in R is obtained whose spatial distance to q is greater than d. These additional tuples are also joined with O to yield their network distances, at which point the closest k restaurants to q are chosen from a pool of restaurants from the initial set of k restaurants from before application of the STOP operator and the additional restaurants produced after application of the RESTART operator.","Distance Join: The distance join works in a similar manner to the k-nearest neighbor search in the sense that a query point q is replaced with a relation. As can be seen from , the main difference between the operator trees for the nearest neighbor and the distance join queries is the use of a distance join operation between R and S using the spatial distance function. One embodiment uses an incremental distance join algorithm, which provides the ability to suspend and restart the operator as needed. One embodiment of a strategy for optimizing distance join queries on spatial networks is illustrated in . It starts with application of the incremental distance join generating k pairs, whose network distances are ascertained by a join with O. An upper bound on the network distance is computed between the k farthest pair in the output, which is referred to as d. The distance join operation is restarted and more pairs are generated until a pair whose spatial distance is farther than dis obtained, at which time, the operator is suspended once again. After obtaining the network distances of the additional pairs, the k closest pairs from the original k pairs as well as the newly generated pairs are chosen.",{"@attributes":{"id":"p-0078","num":"0085"},"figref":"FIG. 3","b":["10","10","12","10","10","12"]},"Apparatus  also includes a processor , coupled to interface , for receiving, managing, and\/or processing user input or information, and for executing instructions or operations. Processor  may be any type of general or specific purpose processor.","Apparatus  further includes memory  for storing information and instructions to be executed by processor . Memory  can be comprised of any combination of random access memory (RAM), read only memory (ROM), static storage such as a magnetic or optical disk, or any other type of machine or computer readable media. Computer readable media may be any available media that can be accessed by processor  and could include volatile or nonvolatile media, removable or non-removable media, and communication media. Communication media may include computer program code or instructions, data structures, program modules or other data, and includes any information delivery media. Processor  can further be coupled, via interface  or directly, to a graphical user interface or display  for displaying information to a user.","In one embodiment, memory  stores software modules or applications that provide functionality when executed by processor . The modules may include an operating system  that provides operating system functionality for apparatus . The memory  may also store applications , such as applications for interfacing with database system . Processor  and memory  may be coupled via interface , or directly, to database system  and, thus, may be able to access and retrieve information stored in database system . Although only a single database is illustrated in , any number of databases may be used in accordance with certain embodiments.","According to certain embodiments, processor  and memory  may be configured to control apparatus  to construct a path oracle, distance oracle, and\/or a path-distance oracle, as discussed above. Further, in some embodiments, apparatus  may be controlled to perform the PCP decomposition method and the shortest path method discussed above, or any other method described herein. In one embodiment, apparatus  is configured to receive certain input including the spatial network G, the root block T of a PR-quadtree H on the spatial positions of V, the type of oracle (i.e., path, distance, and\/or path-distance), and the quality of approximation \u03b5. Based on this input, apparatus  is controlled to construct the specified type of oracle by decomposing the spatial network into a set of PCPs that satisfy at least one of the three predefined properties discussed above. In particular, according to embodiments of the invention, the resulting decomposition may have the following properties:\n\n","If the oracle type is path-distance, the decomposition of the spatial network into a set of PCPS, by apparatus , will result in the construction of a path-distance oracle that provides both an intermediate vertex of a shortest path between the two vertices in the spatial network and an approximate distance between the two vertices. Apparatus  may then be controlled to store the set of PCPs as a relation in database system .",{"@attributes":{"id":"p-0084","num":"0094"},"figref":["FIG. 4","FIG. 4"]},"As illustrated in , the method includes, at , receiving input including the spatial network G, the root block T of a PR-quadtree H on the spatial positions of V, the type of oracle (i.e., path, distance, and\/or path-distance), and the quality of approximation \u03b5. The method then includes, at , constructing the specified oracle type by decomposing the spatial network into PCPs that satisfy the properties discussed above. The decomposing of the spatial network may be performed by the PCP decomposition method described in Table 1 above. At , the method includes outputting the set of PCPs resulting from the decomposition of the spatial network. The set of PCPs can be a path oracle, distance oracle, or path-distance oracle depending on the oracle type specified in the input.","For example, when the specified oracle type is path-distance, the method of  would construct a path-distance oracle that provides both an intermediate vertex of the shortest path between two vertices in the spatial network. In one embodiment, the path-distance oracle would be constructed by decomposing the spatial network into a set of PCPs.","According to certain embodiments, any set of ordered PCPs may be considered an oracle. Referring again to , the method may also include, at , storing the set of PCPs as a relation in a relational database system. Once the set of PCPs (e.g., path-distance oracle) are stored, complex queries on the spatial network may be performed using the relational database system.","In view of the above, embodiments of the invention introduce two linear-sized constructs termed path and path-distance oracles that represent the nshortest paths in a spatial network concisely. Certain embodiments exploit the observed coherence between the spatial positions of vertices and their interconnectivity. This enables the decomposition of a spatial network into groups of source and destination vertices, called path-coherent pairs, that share common vertices in their shortest paths. With the aid of a well-separated pair decomposition method, a path oracle can be constructed that takes O(sn) space (s>2+2\/\u03b4\u22121 for \u03b4>1 and empirically is 12n), but which can retrieve an intermediate link in the shortest path between a source and a destination vertex in O(log n) time using a B-tree. Embodiments of the invention also introduce another representation called a path-distance oracle that takes O(n\u00b7max(s, (1\/\u03b5))) space (empirically n\u00b7max(12, (2.5\/\u03b5))) but which can yield an intermediate link in the shortest path as well as an \u03b5-approximation of the network distance in O(log n) time using a B-tree. The average access time for the oracles was on the order of tens of microseconds.","Further, embodiments of the invention reduce the access time of the path and path-distance oracles to O(1) using a hash table of size O(sn log n) for the path oracle and O(n log n\u00b7max(s, (1\/\u03b5))) for the path-distance oracle. As a result of certain embodiments, shortest paths can be retrieved by making repeated SQL SELECT operations on the oracle relations which are stored in the database. Even more complex query processing scenarios on spatial networks can be performed by using the initial 8-approximation of the network distances, and performing subsequent refinement operations on the distances to improve the approximation.","One having ordinary skill in the art will readily understand that the invention as discussed above may be practiced with steps in a different order, and\/or with hardware elements in configurations which are different than those that are disclosed. Therefore, although the invention has been described based upon these preferred embodiments, it would be apparent to those of skill in the art that certain modifications, variations, and alternative constructions would be apparent, while remaining within the spirit and scope of the invention. In order to determine the metes and bounds of the invention, therefore, reference should be made to the appended claims."],"GOVINT":[{},{}],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["For proper understanding of the invention, reference should be made to the accompanying drawings, wherein:",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIGS. 5","i":["a ","b "],"b":"5"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIGS. 6","i":["a ","b "],"b":"6"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIGS. 7","i":["a ","b "],"b":"7"}]},"DETDESC":[{},{}]}
