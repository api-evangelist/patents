---
title: Apparatus and method for performing hardware and software co-verification testing
abstract: Verification tests perform hardware and software co-verification on a system under verification. Each signal interface controller coupled to the system performs a test action transferring at least one of stimulus signals and response signals between a corresponding portion of the system under verification and the signal interface controller during verification. A debugger controls an associated processing unit that executes software routines. A debugger signal interface controller performs test actions transferring stimulus signals and response signals between the debugger and the debugger signal interface controller during verification. A test manager transfers test controlling messages to these interface controllers identifying the test actions to be performed. As a result, the test manager controls the processing unit via the debugger signal interface controller and the debugger in order to coordinate the execution of the software routines with a sequence of verification tests.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08180620&OS=08180620&RS=08180620
owner: ARM Limited
number: 08180620
owner_city: Cambridge
owner_country: GB
publication_date: 20040127
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DESCRIPTION OF PREFERRED EMBODIMENTS"],"p":["1. Field of the Invention","The present invention relates to techniques for performing hardware and software co-verification testing as part of verifying the design of a data processing system.","2. Description of the Prior Art","The ability to effectively and efficiently test and\/or validate designs is becoming increasingly important. Typical data processing system designs are rapidly increasing in complexity and furthermore are including circuit blocks designed by a variety of different sources or companies. So-called System-on-Chip (SoC) designs that integrate a large number of functional elements on a single integrated circuit have strong advantages in terms of cost and performance, but require significant amounts of validation and testing before the designs can be reliably released for manufacture. This validation and testing requirement is becoming a bottleneck in getting new systems into the market place. Consequently, measures that can improve the efficiency and effectiveness of such validation and testing of designs are strongly advantageous.","U.S. patent application Ser. No. 09\/994,023 describes a technique for performing hardware simulation using a test manager.  illustrates the technique discussed in that patent application.  discloses a verification environment  formed of a hardware simulation , a plurality of signal interface controllers , , , , , , and a test manager . The hardware simulation  represents at least a portion of a System-on-Chip on an integrated circuit modelled as Register Transfer Language (RTL), for example Verilog or VHDL, using known hardware modelling computer programs. Such hardware modelling computer programs given RTL definitions (other types of definition are also possible) of circuit designs are able to simulate the processing activity of those designs by propagating signals throughout the designs and observing responses to those signals. The techniques of hardware simulation using RTL models are well known from commercially available systems.","In the example illustrated in , the hardware simulation  includes a bus matrix , in this example the bus matrix conforming to the Advanced Microcontroller Bus Architecture (AMBA) protocol developed by ARM Limited of Cambridge, United Kingdom, and further includes three devices under verification (DUVs) , ,  connected to the bus matrix via respective buses , , .","The hardware simulation  is supplied with stimulus signals from, and returns response signals to, associated signal interface controllers , , , , ,  that are also referred to herein as eXtensible Verification Components (XVCs). These signal interface controllers are connected to corresponding buses , , , , ,  within the hardware simulation .","The modular nature of the design being simulated by the hardware simulation  allows it to be considered as a plurality of hardware blocks. These hardware blocks typically have their own external interface requirements that do not vary between the different designs in which they are used. Thus, a block within the hardware being simulated and its associated XVC are likely to remain unchanged, or substantially unchanged, between different designs. Thus, by building up a plurality of XVCs from a library of these XVCs, a stimulus and response interface for a whole new design as a whole may be rapidly assembled.","The action of the separate XVCs is co-ordinated by a test manager . The test manager  is responsive to pre-programmed test scenarios , which are written by a test engineer or machine generated to provide random state coverage, to issue test scenario controlling messages over path  to the various XVCs , , , , , . These test scenario controlling messages specify simulation actions to be performed by the target XVC as well as specifying when that simulation action should be performed. The simulation actions can take a wide variety of different forms depending upon the hardware block to which the particular XVC relates. Typically, the master XVCs , ,  have simulation actions to either drive directed FRBM (File Reader BUS Master) format vectors  onto the associated bus, or to generate random patterns of transfers constrained by a user configuration file. FRBM is an ARM Limited proprietary format used to stimulate AMBA bus signals, for example AHB, APB or AXI, in order to perform read and write transfers on a bus interconnect.","The above described approach is used for hardware integration performance testing and provides a flexible approach for such testing. However, it does not provide any mechanism for coordinating a software based scenario running on a processor. This problem can be illustrated with reference to , which shows the verification environment of , but with the addition of a representation of a processor  provided within the hardware simulation . Software to be executed by the processor can be provided as user test code , which can be compiled and linked in a standard manner in order to load that software into the ROM . The processor can then execute the software by retrieving instructions from the ROM  via the bus matrix  and the memory controller  using the buses ,  and . Further, a RAM  accessible via the bus  can be used for storing data used by the processor when executing the instructions.","As can be seen from , the XVC verification methodology can be employed to transfer stimulus signals and\/or response signals to and from the hardware simulation , whilst the processor  is executing software stored within the ROM , but there is no co-ordination between the software routines executing on the processor  and the verification testing being performed under the control of the test manager . Hence, the prior art techniques described above with reference to  cannot readily be used to perform co-verification of hardware and software.","One known technique that aims to provide for such hardware and software co-verification is the Mentor Seamless CVE (Co-Verification Environment) product, details of which are provided in the article \u201cCore Based SoC Design System Verification Challenges\u201d published on the Website www.mentor.com. A general overview of the technique provided through use of this product is illustrated in . The Seamless\u2122 tool allows verification tests to be performed on hardware representations as well as the execution of software routines to interact with said hardware representations. In operation the Seamless\u2122 kernel  processes all the bus requests coming from the co-verification simulator  (an instruction set simulator running software). For each instruction or data request, the kernel  can choose to supply data either directly from the memory model in the co-verification memory  or by exercising the bus-interface model (BIM) , which is included as a \u201cblack box\u201d model with the hardware simulator . The memory model also has a port connected to the hardware simulator. The debugger  is used to debug the software running on the co-verification simulator .","Assuming that the user has correctly implemented a bus connection between the processor bus and the memory (i.e. over path , , , , , , ), then the data will be read from the memory model through the hardware simulation  and into the BIM . Once the user has established that the hardware design for the memory sub-system is correct then the kernel can be instructed to map all instruction and data memory areas, in the memory map, to use the high-speed direct access route (i.e. the route over path , , ). Work can then focus on the interfaces to peripherals that remain mapped in the hardware simulator.","Proprietary algorithms within the kernel  decide how BIM pins should be manipulated during periods when direct access to the memory model is used, to keep the relationship between software execution state and the hardware simulation state consistent.","The limiting factor in terms of software execution performance is the execution speed of the hardware simulator . This can be offset by judicious use of the Seamless\u2122 optimization features (i.e. the direct access to memory over path ).","A Co-Verification Controller (CVC) technique described in GB-A-2,374,435 uses a verification environment provided by Specman, Seamless CVE and ModelSim to form the basis of a software\/hardware co-verification testbench. The RPC technique described in that patent application adds the ability to stimulate, monitor and check an IP block (i.e. hardware simulation) through its software interface. This is an important advance that allows IP blocks to be supplied with re-useable system verification components.","With this technique, the software is tested in the context of the hardware that it drives using the high-level verification generation and coverage facilities of the testbench. Furthermore, because the software and hardware models are accessible at the same time, it is possible to set up tests that would be impractical in other environments.","The earlier-described Mentor Seamless approach, and the technique described in GB-A-2,374,435 (which makes use of the Mentor Seamless technique) employ a mechanism specific to the Seamless\u2122 tool to access a shared memory directly when seeking to perform co-verification of the software executing on the co-verification simulator  whilst also performing verification of the hardware simulation . Although this mechanism can work well, it does not scale well with models that incorporate more than one processor, nor can it readily be migrated to testing of hardware at different abstraction levels, for example silicon level testing. Further, when employing the Mentor Seamless technique described with reference to , it will be appreciated that there is no direct co-ordination between stimulus input from the hardware simulator  and software execution state. Although the technique described in GB-A-2,374,435 does allow the co-ordination or hardware stimulus and execution of software routines, this is restricted to operation on a device-by-device basis, and there is no single entity which is in control of the test procedure.","Accordingly, it would be desirable to provide an improved technique for performing hardware and software co-verification testing.","Viewed from a first aspect, the present invention provides apparatus for performing a sequence of verification tests to perform hardware and software co-verification on a system under verification, comprising: a plurality of signal interface controllers operable to be coupled to said system under verification, each signal interface controller being operable to perform one or more test actions transferring at least one of one or more stimulus signals and one or more response signals between a corresponding portion of the system under verification and said signal interface controller during performance of said sequence of verification tests; a debugger operable to control operation of a processing unit associated with the system under verification, the processing unit being operable to execute software routines; a debugger signal interface controller operable to interface with the debugger and to perform one or more test actions transferring at least one of one or more stimulus signals and one or more response signals between the debugger and said debugger signal interface controller during performance of said sequence of verification tests; and a test manager coupled to said plurality of signal interface controllers and the debugger signal interface controller and operable to transfer test controlling messages to said plurality of signal interface controllers and the debugger signal interface controller identifying the test actions to be performed; the test manager being operable to control the operation of the processing unit via the debugger signal interface controller and the debugger in order to co-ordinate the execution of said software routines with the sequence of verification tests.","In accordance with the present invention, a debugger signal interface controller is provided which is operable to interface with a debugger used to control the operation of a processing unit associated with the system under verification. A test manager is then arranged to send test controlling messages to the debugger signal interface controller, and to other signal interface controllers coupled to the system under verification, identifying test actions to be performed by those interface controllers. With regard to the debugger signal interface controller, this enables the test manager to cause the debugger signal interface controller to perform one or more test actions such that at least one of one or more stimulus signals and one or more response signals are passed between the debugger and the debugger signal interface controller during performance of the sequence of verification tests, this allowing the test manager to control the operation of the processing unit via the debugger signal interface controller and the debugger in order to co-ordinate the execution of the software routines with the sequence of verification tests.","Thus, in accordance with the present invention, co-verification of hardware and software can be performed in a co-ordinated manner. In particular, this approach enables the co-ordination of specific software test routines with the application of hardware stimulus to the system under verification, under the control of the test manager.","In accordance with the present invention, the debugger is controlled by the test manager via the debugger signal interface controller, which provides a very flexible and efficient technique for controlling operation of a processing unit coupled to that debugger.","There are a number of ways in which the debugger signal interface controller may generate an appropriate test action in response to receipt of a test controlling message from the test manager. In one embodiment, the apparatus further comprises a memory in which the software routines are stored, the debugger signal interface controller being provided with an address indication identifying the addresses of the software routines within the memory, upon receipt of a test controlling message from the test manager, the debugger signal interface controller being operable to generate a corresponding test action with reference to the address indication. As an example of the implementation of such an embodiment, the test controlling message from the test manager may identify, for example by a predetermined name, a particular software routine to be executed, and with reference to the address indication the debugger signal interface controller can then perform a corresponding test action during which the address for the required software routine is passed to the debugger as part of a stimulus signal.","In one embodiment, the apparatus further comprises a status memory operable to store status data, the processing unit being operable to execute monitoring code to monitor the status data in order to identify any changes to the status data and to then execute at least one of said software routines as identified by the change in status data, the corresponding test action being arranged to cause updated status data identifying a corresponding one of said software routines to be stored in the status memory under the control of the debugger. Hence, in accordance with this embodiment, the processing unit is placed in a remote control mode where it monitors the status data and reacts to a change in the status data by performing a software routine identified by that change in status data.","It will be appreciated that there are a number of ways in which the debugger may cause the updated status data to be placed in the status memory. However, in one embodiment, the debugger is operable to cause the processing unit to store the updated status data in the status memory, whereafter the processing unit reverts to executing the monitoring code. Hence, in accordance with this embodiment, the execution of the monitoring code is temporarily interrupted by the debugger, and the processing unit is then used to store the updated status data in the status memory. Thereafter, the processing unit reverts to executing the monitoring code, as a result of which it will notice the change in the status data, and accordingly will execute the appropriate software routine(s) as identified by the change in status data.","In an alternative embodiment, rather than employing a change in the status data in the status memory to trigger execution of the required software routine, an alternative mechanism is used. Typically, the processing unit has a plurality of registers associated therewith, and in accordance with this alternative technique, the corresponding test action is arranged to cause data in a selected register of said plurality of registers to be updated under the control of the debugger, such that the processing unit will then execute a corresponding one of said software routines.","In one particular embodiment, the selected register is operable to store a program counter value and the corresponding test action is arranged to cause the program counter value to be updated in order to cause the processing unit to branch to a corresponding one of said software routines. The program counter value identifies the address of a current instruction being executed by the processing unit, and accordingly by changing the value of the program counter value, this mechanism will cause the processing unit to branch to a new address, which can be arranged to identify the beginning of the required software routine.","It will be appreciated that as part of the verification process, it will typically be desired to determine, following execution of a software routine by the processing unit, whether the execution of that software routine has completed successfully. In one embodiment, upon execution of one of the software routines, the processing unit is operable to update status data indicative of whether the software routine has completed successfully.","It will be appreciated that this status data will then need to be analysed in order to determine whether the operation was successfully completed or not. There are a number of ways in which this updated status data may be extracted by the debugger signal interface controller. For example, in one embodiment, the debugger signal interface controller may be arranged to periodically perform test actions which cause the debugger to temporarily halt the processing being performed by the processing unit so as to enable the debugger to read the status data.","However, in an alternative embodiment, the debugger signal interface controller is operable to perform a predetermined test action in order to cause a breakpoint to be set by the debugger which is triggered when the processing unit performs said update of the status data. The ability for a debugger to set a breakpoint is a standard feature of many debuggers. In accordance with this embodiment of the present invention, this feature is used to improve the efficiency of the process, since it is no longer necessary to periodically interrupt the operation of the processing unit in order to determine whether the execution of the software routine has completed. Further, this can improve the accuracy of the verification process, since it avoids any risk that the periodic interruption of the processing unit during execution of the software routine might affect the successful operation or otherwise of that software routine.","In one embodiment, the debugger is operable to issue a callback event to the debugger signal interface controller upon triggering of the breakpoint. This simple mechanism then identifies to the debugger signal interface controller that the processing unit has finished executing the particular software routine, and accordingly the debugger signal interface controller can then initiate any appropriate further step. For example, as discussed earlier, the debugger signal interface controller will typically wish to read the updated status information in order to determine whether execution of the software routine has completed successfully or not, and accordingly at this point in time the debugger signal interface controller can be arranged to perform a further test action in order to cause the updated status data to be retrieved by the debugger for analysis by the debugger signal interface controller or by the test manager. In one particular embodiment, the updated status data is analysed by the debugger signal interface controller, and then a signal indicative of whether the execution of the software routine has completed successfully is returned to the test manager.","Whilst in the above described embodiment a breakpoint mechanism is used for handshaking status information between the software running on the processing unit and the debugger signal interface controller, it will be appreciated that various other mechanisms may be used, for example a watchpoint mechanism may be used. Furthermore, in embodiments where the debugger and its interface to the system under verification support a shared status memory which can be accessed by the debugger signal interface controller whilst the software is running, it will be appreciated that there may be no requirement for such a breakpoint mechanism to be used. Indeed, future ARM debugger implementations may provide hardware support for reading and writing memory whilst software is running on the processor, and in such embodiments no break-point shared data handshaking would be required.","It will be appreciated that there are a number of ways in which the debugger signal interface controller and the debugger may pass signals between themselves. In one embodiment, the stimulus and\/or response signals are transferred between the debugger signal interface controller and the debugger using Application Programming Interface (API) calls. Accordingly, a standardised interface is provided between the debugger signal interface controller and the debugger so that an interface protocol already supported by the debugger can be used. In one particular embodiment, the debugger signal interface controller is coupled to the debugger via an EABS interface. EABS (Extension ABStraction) is an ARM proprietary interface within RVD (ARM RealViewDebugger) that allows third parties to write a shared object, (.dll or .so), that plugs into RVD and gives access to its debug functionality. In one embodiment of the present invention, this interface forms part of the debugger signal interface controller. The debugger would provide an EABS interface, or in different embodiments may provide a similar interface specific to the debugger being used.","In one embodiment, the software routines to be executed by the processing unit may be pre-stored in memory, and accordingly for example may be stored in a ROM. However, in an alternative embodiment, at least one of the software routines is written into the memory via the debugger under the control of the debugger signal interface controller. Accordingly, the test manager may issue test controlling messages to the debugger signal interface controller to cause the debugger signal interface controller to perform one or more test actions in order to transfer the instructions making up a software routine into the memory via the debugger. This provides a flexible approach for loading of software into the memory for execution by the processing logic.","In embodiments where the debugger command interface is used to download a program dynamically into memory, for example RAM, and where functions are executed by manipulating the processor model program counter, there is no need to employ the breakpoint status monitoring methodology as described earlier.","In one embodiment of the present invention, multiple processing units are provided, and a corresponding multiple of debugger signal interface controllers are provided, each debugger signal interface controller communicating with the same debugger to cause their respective test actions to be performed. Accordingly, it can be seen that the technique of embodiments of the present invention is readily expandable to systems where multiple processing units are used, and accordingly provides a very flexible technique for the co-verification of hardware and software.","It will be appreciated that there are a number of ways in which the execution of the software routines may be co-ordinated with the sequence of verification tests. In one embodiment, it is the timing of the execution of the software routines which is coordinated with the sequence and verification tests. Alternatively, or in addition, the co-ordination may involve flagging to the test manager that certain events have occurred in the software being executed, and\/or the reacting to events from the test manager in order to change the state of the software being executed.","It will be appreciated that the system under verification may take a variety of forms. However, in one embodiment, the system under verification comprises a plurality of components, each signal interface controller being associated with one of said components. Typically, there may be one or more components which do not have a signal interface controller associated with them, and also it is possible that more than one signal interface controller may be associated with a particular component.","In one embodiment, the processing unit forms one of the components of the system under verification. However, in an alternative embodiment, the processing unit is provided as part of the apparatus, externally to the system under verification.","It will be appreciated that the processing unit may take a variety of forms. However, in one embodiment, the processing unit comprises a representation of a processor on which the software routines are intended to be executed. In one particular embodiment, the processing unit takes the form of a software model representing the processor.","The system under verification may take a variety of forms, and in particular may be provided at a number of different levels of abstraction. For example, the system under verification may in certain situations be provided on silicon or may be provided as a FPGA (Field Programmable Gate Array), whilst in other embodiments it may be provided at the RTL level. In one embodiment, the system under verification comprises a hardware simulator responsive to said one or more stimulus signals to generate said one or more response signals simulating a response of a data processing apparatus to said one or more stimulus signals if applied to said data processing apparatus. Accordingly, in one example, an RTL representation of the components of the system under verification may be loaded into a hardware simulator so as to simulate the response of the modelled data processing apparatus to one or more stimulus signals input to the hardware simulator.","Viewed from a second aspect, the present invention provides a method of performing a sequence of verification tests to perform hardware and software co-verification on a system under verification, comprising the steps of: performing in each of a plurality of signal interface controllers coupled to said system under verification one or more test actions transferring at least one of one or more stimulus signals and one or more response signals between a corresponding portion of the system under verification and said signal interface controller during performance of said sequence of verification tests; controlling via a debugger execution of software routines by a processing unit associated with the system under verification; performing in a debugger signal interface controller coupled with the debugger one or more test actions transferring at least one of one or more stimulus signals and one or more response signals between the debugger and said debugger signal interface controller during performance of said sequence of verification tests; and transferring test controlling messages from a test manager to said plurality of signal interface controllers and to the debugger signal interface controller, the test controlling messages identifying the test actions to be performed; whereby the test manager controls the operation of the processing unit via the debugger signal interface controller and the debugger in order to co-ordinate the execution of said software routines with the sequence of verification tests.","Viewed from a third aspect, the present invention provides a computer program product for performing a sequence of verification tests to perform hardware and software co-verification on a system under verification, the computer program product comprising: a plurality of signal interface controller code blocks operable to be coupled to said system under verification, each signal interface controller code block being operable to perform one or more test actions transferring at least one of one or more stimulus signals and one or more response signals between a corresponding portion of the system under verification and said signal interface controller code block during performance of said sequence of verification tests; debugger code operable to control operation of a processing unit associated with the system under verification, the processing unit being operable to execute software routines; a debugger signal interface controller code block operable to interface with the debugger code and to perform one or more test actions transferring at least one of one or more stimulus signals and one or more response signals between the debugger code and said debugger signal interface controller code block during performance of said sequence of verification tests; and test manager code coupled to said plurality of signal interface controller code blocks and the debugger signal interface controller code block and operable to transfer test controlling messages to said plurality of signal interface controller code blocks and the debugger signal interface controller code block identifying the test actions to be performed; the test manager code being operable to control the operation of the processing unit via the debugger signal interface controller code block and the debugger code in order to co-ordinate the execution of said software routines with the sequence of verification tests.","Viewed from a fourth aspect, the present invention provides a computer program operable when loaded onto a computer to cause the computer to operate in accordance with the method of the second aspect of the present invention.",{"@attributes":{"id":"p-0061","num":"0060"},"figref":["FIG. 3","FIG. 1B","FIG. 1B","FIG. 1B","FIG. 3","FIG. 1B","FIG. 3"],"b":["10","310","300","20","30","320","190","150"]},"When performing the user-defined test scenarios , the test manager  can now, in addition to sending test controlling messages to the XVCs , , , , , , send test controlling messages to the RVD-XVC  in order to cause the RVD-XVC  to perform one or more test actions. As will be discussed in more detail below, this enables the test manager to control via the debugger  the operation of the processor , so that software routines executed by the processor can be co-ordinated with the sequence of verification tests performed on the hardware simulation .","When the user test code  is compiled and linked for storing in the ROM , an address map is generated identifying the addresses of functions of a piece of software code to be tested, and thus providing the addresses of individual software routines provided by the user test code. This address map is provided over path  to the RVD-XVC . At boot time, the processor  will communicate with the memory controller  via the buses  and  and via the bus matrix  in order to retrieve from ROM  via path  a number of instructions defining an initialisation routine to be executed by the processor . This will typically cause the processor to establish some working space within the RAM , to enable storage, amongst other things, of status data maintained by the processor during execution of instructions. At the end of execution of this initialisation code, execution will branch to the RVD-XVC driver code  which is arranged to cause the processor  to monitor the status data within the RAM . Whenever the status data is changed, this will cause the processor to branch to a particular software routine identified by the change in status data to cause that software routine to be executed, and following execution of that particular software routine, the status data will then be updated by the processor  to indicate whether execution of that software routine was successful or not.","Once the initialisation code has been executed, the processor  will be able to receive communications initiated by the RVD-XVC  via the debugger . These communications take place via a communications link established at the time of initialisation.","To cause the processor  to execute a specific software routine, the test manager  will issue a test controlling message to the RVD-XVC , which will cause the RVD-XVC  to perform an execute test action during which an indication of the address of that particular software routine will be provided as a stimulus signal over the interface  to the debugger , this address being determined with reference to the address map received by the RVD-XVC  over path . This will cause the RVD debugger  to communicate with the CPU  over the path  to interrupt execution of the driver code  by the CPU , and to then cause the CPU  to make the necessary update to the status data maintained within the RAM . Once this update has taken place, the debugger  will then release control back to the processor , at which point the processor  will return to execution of the driver code , and as a result will identify that the status data in the RAM  has changed. This will then cause the processor  to execute the particular software routine as identified by the change in status data, and upon completion of execution of that software routine, the processor  will then update the status data in the RAM . At this point, the processor  will then return to execution of the driver code  to monitor for any further changes to the status data.","The status data as updated by the processor  upon completion of execution of the particular software routine then needs to be analysed by the RVD-XVC  and\/or the test manager  in order to determine whether execution of the software routine was successful. There are a number of ways in which this can be done. In one embodiment, the RVD-XVC  can be arranged to periodically cause the debugger  to interrupt execution of the processor , so that the contents of the status data in the RAM  can be read by the debugger  and returned to the RVD-XVC . However, this in invasive to the processing of the processor , and hence in an alternative embodiment a breakpoint mechanism provided by the debugger  is employed to notify the RVD-XVC  once the CPU  has completed execution of the software routine. In particular, the RVD-XVC  can perform a test action which causes the debugger  to set a breakpoint which is then triggered when the processing unit performs the update of the status data at the end of the execution of the software routine. The debugger  then issues a call-back event to the RVD-XVC  to indicate that the status data has been updated.","The RVD-XVC  can then issue a further test action to the debugger  to cause it to interrupt processing of the processor , so that the status data in the RAM  can be read by the debugger , and then returned to the RVD-XVC .","In one embodiment, this status data is then analysed by the RVD-XVC  to determine whether the execution of the software routine was successful or not, after which a signal indicative of the success is returned to the test manager  over path .","It can be seen that this approach enables the test manager  to perform the usual hardware verification tests via the various XVCs , , , , ,  whilst also at the same time co-ordinating the timing of execution of particular software routines by the processor  via communications between the RVD-XVC  and the debugger . This provides a very efficient technique for co-ordinating the execution of software routines with the sequence of verification tests when performing hardware and software co-verification on the system under verification, i.e. the hardware simulation .","Another coordination aspect that can be managed by embodiments of the present invention is the signalling by the debugger signal interface controller to the test manager that a software status flag has been set, or the signalling from the test manager to the debugger signal interface controller that a hardware status flag has been set. In this context the verification engineer would be interested to see if certain events would occur rather than when, for example to check whether a FIFO full event on a hardware block was recognised correctly by a piece of software designed to stimulate that block, or to check that this condition never occurred. The verification engineer would determine what conditions\/states were required to fire these events and would typically refer to them as \u2018corner-cases\u2019. Such corner-cases could be used as assertions\/error-traps. Hence, to summarise, in one embodiment of the present invention, co-ordination may involve one or more of the following aspects:\n\n",{"@attributes":{"id":"p-0071","num":"0073"},"figref":["FIG. 4","FIG. 4","FIG. 3","FIG. 4"],"b":["150","140","330","140","330","140","150","330","335","330","310","330","335"]},"Other than the fact that the representation of the processor is now provided as a software model  external to the hardware simulation , rather than being provided by a representation of the processor  provided internally to the hardware simulation, the execution of the verification environment  of  operates in the same manner as described earlier with reference to .","In both the embodiments of , the interface  between the RVD-XVC  and the debugger  is preferably provided by a standard debugger external interface, in one embodiment this being an EABS extension DLL interface, thereby avoiding any need to modify the debugger  in order to allow it to receive communications from the RVD-XVC . In accordance with this standard interface, the stimulus and\/or response signals are transferred between the RVD-XVC  and the debugger  using Application Programming Interface (API) calls.","As an alternative to running the processor in the remote control mode described above with reference to , a different implementation may be used to cause the processor ,  to perform a particular software routine. In particular, the processor will typically have a number of working registers associated therewith, and the RVD-XVC  can be arranged to perform a test action in order to cause the contents of one of those registers to be updated under the control of the debugger . In one particular embodiment, one of the registers will contain the program counter (PC) value, and the test action can be arranged to cause the PC value to be updated, as a result of which the processor will branch to the corresponding software routine identified by the updated PC value. The same techniques as described earlier could then be used to determine when execution of that software routine has been completed, so as to enable the updated status data to be analysed.","In the embodiments described with reference to , the user test code is loaded into ROM , and executed from the ROM. However, in an alternative embodiment, it is possible for at least one of the software routines to be written into the RAM  via the debugger  under the control of the RVD-XVC  in response to appropriate test controlling messages issued to the RVD-XVC  from the test manager . This provides additional flexibility in specification of the user test code to be executed by the processor , .","The RVD debugger  has a multiple-processor connection, and allows the user to hence debug targets that contain multiple processors. Accordingly, the verification environment  of  can be modified to include multiple processors, which all communicate with the same debugger . Each processor will then have a corresponding RVD-XVC , such that each RVD-XVC object will have access to a particular target processor via the debugger. Accordingly, the above described technique provides a very scalable technique for performing hardware and software co-verification in a multi-processor environment.",{"@attributes":{"id":"p-0077","num":"0079"},"figref":["FIGS. 5A and 5B","FIG. 5A","FIG. 4","FIGS. 1A and 1B"],"b":["90","120","35","350","50"]},{"@attributes":{"id":"p-0078","num":"0080"},"figref":["FIG. 5B","FIG. 5A"],"b":["10","400","405","20","25"]},"Thereafter, at step , the test manager  causes the AHB master XVC  to set configuration options of the GPIO device  via input of an appropriate stimulus signal over buses  and  via the bus matrix . In particular, these configuration options will specify a FIFO depth for a FIFO contained within the GPIO device , this FIFO depth being identified by the initial configuration data determined at step .","The process then proceeds to step , where the test manager  again causes the AHB master XVC  to perform a test action in order to read a stimulus file in order to initialise the GPIO device . The stimulus file may be obtained from the FRBM format vectors , or may be generated on a random basis constrained by a user configuration file.","Thereafter, the process proceeds to step , where a write operation is performed to the GPIO device's external input. This is achieved by causing the GPIO XVC  to drive stimulus onto the external pins of the GPIO device  over the bus .","At step , it is determined whether the GPIO FIFO is full, and if not the process returns to step  to cause further stimulus to be driven onto the external input of the GPIO device. At step , the GPIO XVC  monitors the FIFO full interrupt within the GPIO device , and sends an event to the test manager  to signal when the GPIO FIFO is full.","When the GPIO FIFO is full, the test manager  then issues a test controlling message to the RVD-XVC  to cause a test action to be performed at step  in order to control the processor  via the debugger  so that it executes a software driver routine to write to the GPIO device . Clearly, this will cause the software executing on the processor to write to the GPIO device in a situation where the input FIFO of the GPIO device is full. This is clearly an interesting corner case condition where there is the potential for incorrect processing to take place.","At step , it is determined whether execution of the software routine was successful. To determine this success, the RVD-XVC  is arranged to issue a test action to the debugger , to cause the debugger to interrupt the processor , so that the updated status data placed in the RAM  by the processor  upon completion of the software routine can be read and returned to the RVD-XVC . The RVD-XVC  then determines the success or failure of the software routine, and signals this to the test manager . If as a result of this process it is determined that execution of the software routine was not successful, then the error is displayed at step , thereby allowing further analysis of that error to take place. However, assuming that the software execution was successful, in this context meaning that the write did take place, then the process proceeds to step , where it is determined with reference to the user test scenario whether a further configuration of the FIFO depth should be tested. Accordingly, at step , it is determined whether the test routine has finished, i.e. whether all desired FIFO depths have been tested, and if so the process ends at step . However, assuming that the process has not finished, the process returns to step , where the new FIFO depth is set, and the process repeated.","The test illustrated in  would be useful if the GPIO designer used the same logic to test for read or write buffer full, and wanted to make sure that write data would still be accepted even though the read buffer was full. This test process also tests that the software recognised the difference between read buffer and write buffer full. If either the GPIO hardware aborted the write, or the software state prevented the write from occurring then the test would have failed. Hence, it can be seen that this process provides co-verification of hardware and software.","Hence, in summary, it can be seen that the flow diagram of  shows the execution of a simple test manager test scenario, designed to prove that the software driver for a GPIO device  and the GPIO device  itself are working for a specific test case required by the GPIO designer. The GPIO driver software is being tested to ensure that it can write data into the GPIO device  and can correctly clear the FIFO full interrupt by reading from it. The GPIO designer wants to see this test case exercised over a range of FIFO depth configurations. By using this co-verification environment, these tests are completed with a very quick turnaround when compared to conventional verification techniques.",{"@attributes":{"id":"p-0087","num":"0089"},"figref":["FIG. 6","FIG. 6"],"b":["500","500","502","504","506","508","510","512","514","516","518","520","522","502","504","506","510","508","512","514","500","516","518","520","500","500","200"]},"A further description of the hardware and software co-verification techniques of embodiments of the present invention is given in the following appendix:","Contents","1 About this document","1.1 Terms and abbreviations","2 SCOPE","3 INTRODUCTION","3.1 Existing XVC test infrastructure","3.2 XVC test infrastructure with an RVD-XVC and processor model","4 RVD-XVC ACTION LIST","4.1 Typical test actions for the RVD-XVC",{"@attributes":{"id":"p-0089","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":{"@attributes":{"id":"ul0002-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0003","list-style":"none"},"li":["4.1.1 Action 1 Wait for init: [<timeout>]","4.1.2 Action 2 Set up Method name address resolution: <filename>","4.1.3 Action 3 Execute Test: <Name>[<p1>] [<p2>] [<p3>] [<p4>]","4.1.4 Action 4 Finished Tests:","4.1.5 Action 5 Abort Test:","4.1.6 Action 6 Execute RVD CLI command: <string>\n\n5 THE RVD-XVC AND SOFTWARE COMMUNICATIONS LINK\n\n5.1 Requirements\n\n5.2 RVD-XVC comms link access\n","5.2.1 Example System Memory Map","5.2.2 Example Software configuration\n\n5.3 RVD-XVC comms link data structure\n","5.3.1 Header information","5.3.2 Initialisation Handshake Protocol","5.3.3 Data structure and type definitions\n\n5.4 RVD-XVC comms link access protocol\n","5.4.1 Action 1 Wait for init","5.4.2 Action 3 Execute test","5.4.3 Action 4 Finished tests","5.4.4 Action 5 Abort test\n\n5.5 Example XVCIO driver code for the software thread\n","5.5.1 Software Task: main( )","5.5.2 Software Task: XVCIO_InitCommsStruct ( )","5.5.3 Software Task: XVCIO_CheckValidHeader( )","5.5.4 Software Task: XVCIO_Handshake( )","5.5.5 Software Task: XVCIO_InitComms( )","5.5.6 Software Task: XVCIO_EnterPollLoop( )\n\n5.6 RVD EABS API Calls used\n\n1 About this Document\n\n1.1 Terms and Abbreviations\n"]}}}},"This document uses the following terms and abbreviations.",{"@attributes":{"id":"p-0091","num":"0113"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"322pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Term","Meaning"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Verification","The equivalence of two views (e.g. RTL and gate level)."]},{"entry":["Validation","Checking the design intent."]},{"entry":["V&V","Verification and Validation Methodology"]},{"entry":["Level 4","System Level. In-situ testing, for example interrupt testing with fifo-full conditions, usually by running"]},{"entry":[{},"verification code on ARM model. May include external models to provide realistic scenarios, e.g. Denali"]},{"entry":[{},"memory models, UART model, PCI model."]},{"entry":["Level 3","In System Block Level. As for Level4, but tests directed at specific block(s)."]},{"entry":["Level 2","Integration Level. In-situ testing designed to prove out inter-block connectivity, for example timer block"]},{"entry":[{},"connected to interrupt control block."]},{"entry":["Level 1","Register Access Level. In-situ testing to confirm memory map reset, read and write properties."]},{"entry":["Level 0","Standalone Block Level. Module instantiated in standalone test bench, with the objective of achieving full"]},{"entry":[{},"functional coverage on that module."]},{"entry":["System","The top element of the system architecture, specification tree, or system breakdown structure that is"]},{"entry":[{},"comprised of one or more products and associated life cycle processes and their products and services."]},{"entry":["II","Initial Investigation Project Phase"]},{"entry":["DI","Detailed Investigation Project Phase"]},{"entry":["DT","Development and Test Project Phase"]},{"entry":["AMBA","Advanced Microcontroller Bus Architecture (rev 2.0: ASB, AHB, APB), (rev 3.0: AXI, AHB, APB)"]},{"entry":["APB","Advanced Peripheral Bus"]},{"entry":["AHB","Advanced High-performance Bus"]},{"entry":["AXI","Advanced eXtensible Interface"]},{"entry":["ADK","AMBA Developers Kit"]},{"entry":["ACT","AMBA compliance testbench"]},{"entry":["IP","Intellectual Property"]},{"entry":["Trick Box","Typically an RTL model in Verilog or VHDL that generates and\/or monitors stimulus on external DUV I\/O"]},{"entry":[{},"signals"]},{"entry":["PTB","The latest generation Trick Box that interfaces to the PFI layer of an XVC (see below)"]},{"entry":["PrimeCell","High quality reusable IP from ARM"]},{"entry":["ASM","Advanced Simulation Model"]},{"entry":["DSM","Design \u2018Sign-off\u2019 Model"]},{"entry":["TLM\/TLV","Transaction level modelling\/Transaction level verification"]},{"entry":["PV","Programmers view modelling abstraction e.g. master model calls slave->fn_transfer( )"]},{"entry":["PVT","Programmers view with timing e.g. as PV but includes cycle level control signals associated with function"]},{"entry":[{},"calls"]},{"entry":["ADS","ARM Developer Suite"]},{"entry":["ADU","ARM Debugger for Unix"]},{"entry":["AVS","Architecture validation suite"]},{"entry":["DVS","Device validation suite"]},{"entry":["DUV","Design\/Device under verification"]},{"entry":["BFM","A bus functional model typically written in RTL that has the ability to drive transfers onto a bus to stimulate a"]},{"entry":[{},"DUV"]},{"entry":["XVC","Extensible verification component"]},{"entry":["XTSM","External test scenario manager"]},{"entry":["FRBM","An AHB Master capable of reading bus transactions from a stimulus file. This format is defined by the ADK"]},{"entry":[{},"team."]},{"entry":["MLAHB","Multi-layer AHB"]},{"entry":["PTB","Peripheral Test Block"]},{"entry":["RVD","ARM RealView Debugger Environment"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"Since the introduction of the XVC methodology in 2000, one of the longer term goals for system testing was to include the software environment when building and executing test scenarios. There have been various interim solutions to date for coordinating the execution of specific software test routines with the application of hardware stimulus, including the use of the Mentor Seamless environment for co-simulation of hardware and software.","Up until now however, none of these solutions has been able to address the sequencing and co-ordination of test routines as part of an XVC manager test scenario.","Why now? The reason for developing an RVD XVC at this current time is due to the emergence of standardized interfaces in the debugger tool chain and in the modeling group tool-chain (EABS and SimAbs2 respectively), that allow these missing bridging links to be formed. Now that EABS and SimAbs2 are part of RVD this gives rise to a number of advantages:\n\n",{"@attributes":{"id":"p-0095","num":"0125"},"figref":"FIG. 7"},"In this verification environment, an AHB master XVC is used to drive the AMBA bus in place of a processor model. The AHB Master XVC has actions to either drive directed FRBM format vectors onto the bus, or to generate random patterns of transfers constrained by a user configuration file.","In either case, the above testbench environment cannot execute ARM assembler instructions; neither can it emulate a processors bus activity whilst executing the instruction stream. In the latter case, the XVC Master could be made to emulate typical bus activity using certain sequences of transfers, or by replaying captured vectors, but this mode of operation requires a number of prerequisite steps.","3.2 XVC Test Infrastructure with an RVD-XVC and Processor Model",{"@attributes":{"id":"p-0098","num":"0128"},"figref":"FIG. 8"},"In this verification environment, the AHB master XVC is replaced by an ARMulator based processor CCM. The RealView Debugger is connected to the CCM and in turn the RVD-XVC is connected to the RealView Debugger via an EABS interface (RVD Third Party Extension Interface). RVD itself has a multi-processor connection and allows the user to debug targets that contain multi-processors. This ability is passed on to the RVD-XVC. Each RVD-XVC object will have access to any one instance of an RVD connected processor target, and will be able to make debug calls to any targets that it has connected to.","Unlike the conventional XVC Manager\/XVC verification environment, the above environment provides a fully functional ARM software and debug environment, coupled with the ability to synchronise the execution of specific software test routines, with stimulus injected directly into the DUV that the software test routine is targeted at.","4 RVD-XVC Action List","4.1 Typical Test Actions for the RVD-XVC","The set of actions supported by the RVD-XVC are currently restricted to initiating specific test routines and checking their progress. This is because the primary purpose of using an XVC is to automate the execution of a software environment rather than to aid in interactive debugging such as setting breakpoints and stepping code. However for the sake of flexibility and future expansion, the RCD-XVC will support execution of RVD-CLI commands.","4.1.1 Action 1 Wait for init: [<timeout>]","In order for the software environment to be in a state where it can execute commands from the RVD-XVC, it may be necessary to wait for the communications channel between the RVD-XVC and the test software to be initialised. If the testbench is running in an RTL simulation environment, some significant time may elapse before the test software is ready to accept RVD-XVC commands. An optional timeout parameter in seconds can be specified to guard against software crashes or similar events that prevent the software from executing.","4.1.2 Action 2 Set Up Method Name Address Resolution: <filename>","Action 2 supports the execution of software test modules by name. This is achieved by the RVD-XVC reading a linker symdefs output log (e.g. armlink option-symdefs <filename>) to resolve the address of the desired test module and takes a fully qualified path name as an input parameter. The default name for the linker file is .\/symdefs.txt. An example output format is provided below (comment: #, D:Data, A:ARM Code, T:Thumb Code):","#<SYMDBFS># ARM Linker, RVCT2.0 [Build 155]: Last Updated: Wed Oct. 8 15:56:00 2003","0x10000040 D gDefaultintHandler","0x10000044 D gIrqFiqInitialised","0x10000070 D IRQHandlerInstalled","0x10000074 D FIQHandlerInstalled","0x10000078 D IRQHandler","0x100000b8 D FIQHandler","0x10000158 D_stdin","0x1000019c D_stdout","0x100001e0 D_stderr","0x30000000 A VectorInitBlock","0x30000040 A StartBoot","0x30000050 A_main","0x30000054 A_scatterload","0x30000130 A main","4.1.3 Action 3 Execute Test: <Name>[<p1>] [<p2>] [<p3>] [<p4>]","Up to four parameters can be specified for the target test routine which will use the APCS calling conventions. The word size for each of these parameters is restricted to 32 bits. When an action is complete its return status will either be 0 for successful completion, or an error code will be returned.","A breakpoint debugger command is used to determine when the test routine has completed. This is to minimise the amount of interaction with the processor whilst the software routine is executing. The breakpoint function used is XVCIO_Handshake_hook, the address of which is exported in the above symdefs file and is visible to the RVD-XVC. In fact the breakpoint mechanism is used as the main handshaking mechanism between the software environment and the RVD-XVC.","The software status location that will be updated when the function is complete is at shared memory location XVCIOBASE+0x8 and will change from XVCIO_SWREADY to XVCIO_SWEXEC whilst the routine is executing and then to XVCIO_SWOKAY or XVCIO_SWERROR after the routine has completed.","4.1.4 Action 4 Finished Tests:","Sets the software\/RVD-XVC link status on the target such that the software exits \u2018remote-control\u2019 mode. Any currently executing test action code will finish execution first. This action should be used in preference to Action 5 below. Once control has returned to the software environment, Action 1 needs to be called in order to synchronise the RVD-XVC with the software environment.","4.1.5 Action 5 Abort Test:","If a test action has been initiated it may be terminated early by the RVD-XVC by forcing a reset on the target processor model. No parameters are required for this action. Action 4 should be used in preference to this action. As with Action 4 above, once control has returned to the software environment, Action 1 needs to be called in order to synchronise the RVD-XVC with the software environment.","4.1.6 Action 6 Execute RVD CLI Command: <string>","Under certain test scenarios, especially where a debugger script needs to be called prior to code execution this action can be used to control the RVD command line directly. The string parameter represents a valid RVD CLI command.","5 The RVD-XVC and Software Communications Link","5.1 Requirements","With reference to , essentially the RVD-XVC (1) and CCM (2) operate in different thread execution spaces and are not naturally synchronised. This means that any communications link between the RVD-XVC and the CCM via RVD (3) will need to be used with this requirement in mind, i.e. either process must not be granted write access to the others memory area at any time; read access is granted at all times.","The common communications area\/data is defined by the test code itself (4) and must be defined as a non-cacheable, non-bufferable block of memory. A single entry point is defined in a global symbol within the software that points to the communications area, the RVD-XVC will have access to this symbol before execution begins. This approach maximises flexibility for both the test software, the hardware architecture being used, and for future expansion of the interface.","In order to make the communications interface as simple as possible a co-operative polling approach will be used. This is because using interrupts is both intrusive and more difficult to debug. The drawback here is that test routines cannot be interrupted by the RVD-XVC in mid operation to examine progress etc, but this is not seen to be an important issue at this stage.","The main requirements then for the communications link between the RVD-XVC and the CCM of one embodiment will be:\n\n","With reference to item  of , the example system memory map of  shows the physical location of the RVD-XVC comms link pointer in the executable code that is to be loaded into the target system. This is a single location that points to a block of RAM containing a communications structure for data interchange between the RVD-XVC and the software itself.","The pointer is a fixed 32-bit address value stored in zero-memory at virtual location 0x14. This location is currently specified at the ARM reserved word of the vector table but may be moved to any other fixed location as required at a future date.","Using a vector table entry ensures that there is always a common entry-point for the RVD-XVC link, and allows maximum flexibility for relocation and future expansion of the RVD-XVC comms link interface software. Indeed by just declaring a static global structure in the source code, the user can use any memory map model that the TRM for their system specifies. The only pre-requisite here being that it is:\n\n","The following assembler file is an example boot-strap module including the definition of the vector table:",{"@attributes":{"id":"p-0118","num":"0154"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"357pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":";----------------------------------------------------------------------------"},{"entry":"; Boot Code Block:"},{"entry":";"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"AREA","|Init|, CODE, READONLY",{}]},{"entry":[{},"EXPORT","VectorInitBlock","; ROM Entry Point"]},{"entry":[{},"EXPORT","StartBoot","; System Startup Entry Point"]},{"entry":[{},"IMPORT","EHAND_UndefinedInstruction","; Undefined Instruction Handler"]},{"entry":[{},"IMPORT","EHAND_PrefetchAbort","; Prefetch Abort Handler"]},{"entry":[{},"IMPORT","EHAND_DataAbort","; Data Abort Handler"]},{"entry":[{},"IMPORT","IRQDispatcher","; IRQ Handler"]},{"entry":[{},"IMPORT","FIQDispatcher","; FIQ Handler"]},{"entry":[{},"IMPORT","SWIHandler","; Software Interrupt Handler"]},{"entry":[{},"IMPORT","XVCIOBASE","; XVC Comms Interface Pointer"]},{"entry":[{},"IMPORT","ExtMemInit","; External Memory Controller setup"]},{"entry":[{},"IMPORT","DoRemap","; Memory Remap from ROM to RAM"]},{"entry":[{},"IMPORT","SetupCPU","; CPU Specific Setup"]},{"entry":[{},"IMPORT","StartCode","; Initialise C Data and Stacks"]},{"entry":[{},"ENTRY"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"357pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"VectorInitBlock"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"308pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2002; Set up the ROM vectors"]},{"entry":[{},"\u2002;"]},{"entry":[{},"\u2002; Note : The DoRemap routine will create a vector table in"]},{"entry":[{},"\u2002; \u2003\u2003\u2003\u2003\u2009RAM at location 0 upwards and fill each vector locn with the instructions"]},{"entry":[{},"\u2002\u2003\u2003\u2003\u2003\u2009\u2009below"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2002;",{},{}]},{"entry":[{},"\u2002B","\u2003StartBoot","; Vector 0x00 - Reset"]},{"entry":[{},"\u2002LDR","\u2003PC, UndefinedAddr","; Vector 0x04 - Jump to Undefined Inst Address"]},{"entry":[{},"\u2002LDR","\u2003PC, SWIAddr","; Vector 0x08 - Jump to Software Interrupt Address"]},{"entry":[{},"\u2002LDR","\u2003PC, PrefetchAddr","; Vector 0x0C - Jump to Prefetch Abort Address"]},{"entry":[{},"\u2002LDR","\u2003PC, AbortAddr","; Vector 0x10 - Jump to Data Abort Address"]},{"entry":[{},"\u2002DCD","\u2003XVCIOBASE","; Vector 0x14 - XVC IO comms structure pointer"]},{"entry":[{},"\u2002LDR","\u2003PC, IRQAddr","; Vector 0x18 - Jump to IRQ Address"]},{"entry":[{},"\u2002LDR","\u2003PC, FIQAddr","; Vector 0x1C - Jump to FIQ Address"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"308pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u2002; ROM Vector Addresses"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ResetAddr","DCD","\u2002StartBoot","; Location 0x20 - Reset Handler Address"]},{"entry":["UndefinedAddr","DCD","\u2002EHAND_UndefinedInstruction","; Location 0x24 - Undefined Inst Handler Address"]},{"entry":["SWIAddr","DCD","\u2002SWIHandler","; Location 0x28 - Software Interrupt Handler Address"]},{"entry":["PrefetchAddr","DCD","\u2002EHAND_PrefetchAbort","; Location 0x2C - Prefetch Abort Handler Address"]},{"entry":["AbortAddr","DCD","\u2002EHAND_DataAbort","; Location 0x30 - Data Abort Handler Address"]},{"entry":[{},"DCD","\u20020","; Location 0x34 - Reserved"]},{"entry":["IRQAddr","DCD","\u2002IRQDispatcher","; Location 0x38 - IRQ Handler Address"]},{"entry":["FIQAddr","DCD","\u2002FIQDispatcher","; Location 0x3C - FIQ Handler Address"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"357pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"StartBoot ROUT"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"BL","ExtMemInit","; Initialise Ext Memory Controller (ExtMemInit.s)"]},{"entry":[{},"BL","DoRemap","; Remap from ROM to RAM and copy Vec table to RAM"]},{"entry":[{},"BL","SetupCPU","; CPU Specific Setup (SetupCPU.s)"]},{"entry":[{},"B","StartCode","; Initialise C Data and Stacks (StartCode.s)"]},{"entry":[{},"END"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},"Note that the above code stored the address of the imported symbol XVCIOBASE in the 6entry of the vector table at offset address 0x14 from the program entry point. The symbol is resolved at link time as it is imported from a C module that declares the communications structure in RAM.","The following example C header code segment shows the declaration of the RVD-XVC communications data structure in memory. The actual definition of the XVCINOUT structure is described in more detail further on in this document in section 5.3.3:",{"@attributes":{"id":"p-0121","num":"0157"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"301pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"#ifndef _XVCIO_h"},{"entry":"#define _XVCIO_h"},{"entry":"\/\/ . . ."},{"entry":"\/\/----------------------------------------------------------------------------"},{"entry":"\/\/"},{"entry":"\/\/ XVC IO control for software XVC"},{"entry":"\/\/"},{"entry":"\/\/--========================================================================--"},{"entry":"\/\/ Include enums and typedefs from section 5.3.3 here"},{"entry":"#include \u201cXVCIOdefs.h\u201d"},{"entry":"\/\/------------------------------------------------------------------------"},{"entry":"\/\/ Allocate global memory for the XVC IO comms link"},{"entry":"#ifdef XVCIO_SCOPE"},{"entry":"#\u2003undef XVCIO_SCOPE"},{"entry":"#endif"},{"entry":"#ifdef XVCIO_c"},{"entry":"#\u2003define XVCIO_SCOPE"},{"entry":"#else"},{"entry":"#\u2003define XVCIO_SCOPE extern"},{"entry":"#endif"},{"entry":"volatile XVCIO_SCOPE XVCINOUT XVCIOBASE"},{"entry":"#ifdef XVCIO_c"},{"entry":"\u2003= {XVCIO_INVALIDHEADER} \/\/ Set to XVCIO_ID on initialisation after _main( )"},{"entry":"#endif"},{"entry":"\/\/ . . ."},{"entry":"#endif \/* defined(_XVCIO_h) *\/"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Using the conventions outlined above, this methodology gives access to the RVD-XVC comms link data structures via the XVCIOBASE symbol which is independent of any memory map configuration that is used. With the exception of the vector 0x14 which holds the address pointer to XVCIOBASE, no other hard coded address map variables need to be declared.","Note that the XVCIO_c defined above is declared in a .c implementation file (#define XVCIO_c), and is required such that the extem scope does not get applied in this instance. If no .c files include this define, then XVCIOBASE remains an unresolved external.","The following sections of this document define the data structure of the RVD-XVC comms link, and the handshaking mechanism used to get data in and out of the software environment in order for the RVD-XVC actions to be implemented.","5.3 RVD-XVC Comms Link Data Structure","5.3.1 Header Information",{"@attributes":{"id":"p-0125","num":"0161"},"figref":"FIG. 11"},"It is intended that with subsequent revisions of RVD-XVC comms link software that this header format does not change.","5.3.2 Initialisation Handshake Protocol","As the RVD-XVC thread will already be running by the time the software thread has booted, it will initiate the following handshake sequence. Note that timeout values used below will vary depending on the relative execution speed of the RVD-XVC with the software implementation:\n\n",{"@attributes":{"id":"p-0128","num":"0169"},"figref":"FIG. 11"},"5.3.3 Data Structure and Type Definitions","With reference to the comms link access sequences below in section 5.4, the following data items make up the structure required to sustain a simple command-response link between the software thread running on the CCM and the RVD-XVC:","5.3.3.1 Enum Typedefs",{"@attributes":{"id":"p-0130","num":"0171"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"350pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef unsigned int (*XVCIO_TESTFUNCTION)(unsigned int r0, unsigned int r1, unsigned"},{"entry":"int r2, unsigned int r3);"},{"entry":"typedef enum {XVCIO_INVALIDHEADER=0x00000000, XVCIO_ID=0x50F7101F } XVCIO_IDT;"},{"entry":"typedef enum {XVCIO_DOCMDT=0x0 } XVCIO_CDT;"},{"entry":"typedef enum {XVCIO_NOP=0x0, XVCIO_EXECUTE=0x1, XVCIO_FINISH=0x2, XVCIO_RESET=0x4 }"},{"entry":"XVCIO_CMDT;"},{"entry":"typedef enum {XVCIO_SWBOOT=0x0000, XVCIO_SWINIT=0x0001, XVCIO_SWREADY=0x0004,"},{"entry":"XVCIO_SWEXEC=0x0008, XVCIO_SWERROR=0x000C, XVCIO_SWREADY=0x000C } XVCIO_SWSTATUS;"},{"entry":"typedef enum {XVCIO_RVUNKNOWN=0x0000, XVCIO_RVINIT=0x0001, , XVCIO_RVREADY=0x0002,"},{"entry":"XVCIO_RVCMD=0X0004, XVCIO_RVERROR=0x0008} XVCIO_RVSTATUS;"},{"entry":"typedef enum {XVCIO_HSWAIT=0x0, XVCIO_HSCMD=0x1} XVCIO_HANDSHAKE;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"Although the comms data is user defined, the default recommended structures are listed below which define a \u2018do command\u2019 structure that can be used to support RVD-XVC Action3: Execute test:",{"@attributes":{"id":"p-0132","num":"0173"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"typedef struct tagXVCIO_DOCMD {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003XVCIO_CMDT cmd;","\/\/ Command ID"]},{"entry":["\u2003unsigned int addr;","\/\/ Address of function to be called"]},{"entry":["\u2003unsigned int r0;","\/\/ Parameters for function"]},{"entry":"\u2003unsigned int r1;"},{"entry":"\u2003unsigned int r2;"},{"entry":"\u2003unsigned int r3;"},{"entry":["\u2003unsigned int task_id;","\/\/ Task ID <= XVCIO_MAXTASKID"]},{"entry":["\u2003unsigned int retval;","\/\/ Finished task return value"]},{"entry":"} XVCIO_DOCMD;"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"typedef union tagXVCIO_COMMSDATA {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003XVCIO_DOCMD docmd;","\/\/ Data for executing a command"]},{"entry":"} XVCIO_COMMSDATA;"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},{"@attributes":{"id":"p-0133","num":"0174"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"210pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["typedef struct tagXVCINOUT {",{}]},{"entry":["\u2003XVCIO_IDT id;","\/\/ RVD-XVC software IO interfaces: comms link structure id"]},{"entry":["\u2003XVCIO_SWSTATUS uSWstatus;","\/\/ Status word for SW task to which the SW task has R\/W access"]},{"entry":["\u2003unsigned int uSWparam;","\/\/ Optional parameter for SW task status word"]},{"entry":["\u2003XVCIO_RVSTATUS uRVDXVCstatus;","\/\/ Status word for RVD-XVC to which the RVD-XVC has R\/W access"]},{"entry":["\u2003unsigned int uRVDXVCparam;","\/\/ Optional parameter for RVD-XVC status word"]},{"entry":["\u2003unsigned int uSize;","\/\/ Initialise to sizeof(COMMSDATA);"]},{"entry":["\u2003XVCIO_CDT cdt;","\/\/ Indicator of the type of data currently in comms data"]},{"entry":["\u2003XVCIO_COMMSDATA cdData;","\/\/ User defined comms data structure"]},{"entry":"} XVCINOUT;"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The access protocols for the RVD-XVC\/software comms link are expressed on the following pages as a set of UML sequence diagrams. Each sequence diagram represents an RVD-XVC Action being executed, with the RVD-XVC being shown on the left of each of the sequence diagrams, and the software thread running on the CCM on the middle and right.","What is not shown below is the passing of control to and from the RVD-XVC\/debugger and the software app. This is currently achieved using a breakpoint sequence. This is because when the debugger hands control to the software thread it loses the ability to simultaneously update the shared software memory region until another break operation has occurred. An example breakpoint sequence from software boot is given below:\n\n","Future hardware debug support however may not need to use this breakpoint methodology.","With or without hardware debug support for simultaneous memory access, the sequencing diagrams remain conceptually the same.","Note that actions 2 and 6 do not require direct interaction with the software thread and are not included below.","5.4.1 Action 1 Wait for init",{"@attributes":{"id":"p-0139","num":"0186"},"figref":"FIG. 12"},"5.4.2 Action 3 Execute Test",{"@attributes":{"id":"p-0140","num":"0187"},"figref":"FIG. 13"},"5.4.3 Action 4 Finished Tests",{"@attributes":{"id":"p-0141","num":"0188"},"figref":"FIG. 14"},"5.4.4 Action 5 Abort Test",{"@attributes":{"id":"p-0142","num":"0189"},"figref":"FIG. 15"},"5.5 Example XVCIO Driver Code for the Software Thread","The code below is an example software task implementation based on the above specifications. The first code fragment shows the calls required from main to start the software task.","5.5.1 Software Task: main( )",{"@attributes":{"id":"p-0144","num":"0191"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/------------------------------------------------------------------------"},{"entry":"\/\/ Routine\u2003.\u2003main"},{"entry":"\/\/"},{"entry":"\/\/ Purpose\u2003.\u2003Provide control mechanism for validation test routines"},{"entry":"\/\/"},{"entry":"int main(int argc, char *argv[ ])"},{"entry":"{"},{"entry":"\u2003volatile XVCINOUT *xvcinout = &XVCIOBASE;"},{"entry":"\u2003\/\/ Setup link with RVD-XVC"},{"entry":"\u2003if (XVCIO_InitComms(xvcinout) == FALSE) {"},{"entry":"\u2003\u2003return FAIL;"},{"entry":"\u2003};"},{"entry":"\u2003\/\/ Enter command loop"},{"entry":"\u2003if (XVCIO_EnterPollLoop(xvcinout) == FALSE) {"},{"entry":"\u2003\u2003return FAIL;"},{"entry":"\u2003};"},{"entry":"\u2003return PASS;"},{"entry":"}\/\/ main"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The following code fragments are an implementation of the XVCIO driver itself using the structures and typedefs defined above in section 5.3.3:","5.5.2 Software Task: XVCIO_InitCommsStruct( )",{"@attributes":{"id":"p-0146","num":"0193"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/------------------------------------------------------------------------"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\/\/ Routine",".","XVCIO_InitCommsStruct"]},{"entry":"\/\/"},{"entry":["\/\/ Purpose",".","Set a valid header for the RVD-XVC comms link"]},{"entry":["\/\/",{},"this is to cater for embedded software that does not"]},{"entry":["\/\/",{},"have a global data initialisation library call before"]},{"entry":["\/\/",{},"entering _main"]},{"entry":"\/\/"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"int XVCIO_InitCommsStruct(volatile XVCINOUT* xvc)"},{"entry":"{"},{"entry":"\u2003\/\/ Check for invalid pointer"},{"entry":"\u2003if (xvc == (XVCINOUT*)NULL) return FALSE;"},{"entry":"\u2003\/\/ Initialise header structure"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003xvc->uSWstatus","= XVCIO_SWBOOT;"]},{"entry":["\u2003xvc->uSWparam","= XVCIO_VERSION;"]},{"entry":["\u2003xvc->uRVDXVCstatus","= XVCIO_RVUNKNOWN;"]},{"entry":["\u2003xvc->uRVDXVCparam","= 0;"]},{"entry":["\u2003xvc->uSize","= sizeof(XVCIO_COMMSDATA);"]},{"entry":["\u2003xvc->cdt","= XVCIO_DOCMDT;"]},{"entry":["\u2003xvc->cdData.docmd.cmd","= XVCIO_NOP;"]},{"entry":["\u2003xvc->cdData.docmd.addr","= 0;"]},{"entry":["\u2003xvc->cdData.docmd.r0","= 0;"]},{"entry":["\u2003xvc->cdData.docmd.r1","= 0;"]},{"entry":["\u2003xvc->cdData.docmd.r2","= 0;"]},{"entry":["\u2003xvc->cdData.docmd.r3","= 0;"]},{"entry":["\u2003xvc->cdData.docmd.task_id","= 0;"]},{"entry":["\u2003xvc->cdData.docmd.retval","= 0;"]},{"entry":["\u2003xvc->id","= XVCIO_ID;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003return XVCIO_CheckValidHeader(xvc);"},{"entry":"}\/\/ XVCIO_InitCommsStruct"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},{"@attributes":{"id":"p-0147","num":"0194"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/------------------------------------------------------------------"]},{"entry":[{},"\/\/ Routine . XVCIO_CheckValidHeader"]},{"entry":[{},"\/\/"]},{"entry":[{},"\/\/ Purpose . Check that we have a valid RVD-XVC comms block"]},{"entry":[{},"\/\/"]},{"entry":[{},"int XVCIO_CheckValidHeader(volatile XVCINOUT* xvc)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\/\/ Check for invalid pointer"]},{"entry":[{},"\u2003if (xvc == (XVCINOUT*)NULL) {"]},{"entry":[{},"\u2003\u2003return FALSE;"]},{"entry":[{},"\u2003};"]},{"entry":[{},"\u2003\/\/ Check that we can write to the header i.e. the address given is"]},{"entry":[{},"\u2003mapped to RAM"]},{"entry":[{},"\u2003if (xvc->id != XVCIO_ID) {"]},{"entry":[{},"\u2003\u2003return FALSE;"]},{"entry":[{},"\u2003};"]},{"entry":[{},"\u2003return TRUE;"]},{"entry":[{},"}\/\/ XVCIO_CheckValidHeader"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"Note that in order for the handshaking mechanism to work correctly on current debugger implementations, a breakpoint is required on the function XVCIO_Handshake_hook. This breaks program execution for the RVD-XVC to gain access to the required debugger read and write memory commands to interact with the software.","Where the debugger supports simultaneous memory access through hardware support, no breakpoint function is required.",{"@attributes":{"id":"p-0150","num":"0197"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/------------------------------------------------------------------------"},{"entry":"\/\/ Routine. XVCIO_Handshake_hook"},{"entry":"\/\/"},{"entry":"\/\/ Purpose . Debugger entry point for setting a breakpoint"},{"entry":"\/\/"},{"entry":"void XVCIO_Handshake_hook(XVCIO_HANDSHAKE ID, unsigned int* timeoutcnt) {"},{"entry":"\u2003*timeoutcnt += 1;"},{"entry":"};"},{"entry":"\/\/------------------------------------------------------------------------"},{"entry":"\/\/ Routine. XVCIO_Handshake"},{"entry":"\/\/"},{"entry":"\/\/ Purpose . Wait for an expected status word\/condition or timeout"},{"entry":"\/\/"},{"entry":"int XVCIO_Handshake(unsigned int addr, unsigned int expected, unsigned int waitwhile,"},{"entry":"unsigned int* timeoutcnt)"},{"entry":"{"},{"entry":"\u2003unsigned int exit_flag = FALSE;"},{"entry":"\u2003*timeoutcnt = 0;"},{"entry":"\u2003\/\/ Wait for specified memory value check to be satisfied"},{"entry":"\u2003do {"},{"entry":"\u2003\u2003\/\/ Function for the debugger to breakpoint on"},{"entry":"\u2003\u2003XVCIO_Handshake_hook(XVCIO_HSWAIT, timeoutcnt);"},{"entry":"\u2003\u2003if ((*timeoutcnt) > XVCIO_MAXTIMEOUT) return FALSE;"},{"entry":"\u2003\u2003if (waitwhile == XVCIO_HANDSHAKE_NE) {"},{"entry":"\u2003\u2003\u2003exit_flag = (IO(addr) != expected)? TRUE : FALSE;"},{"entry":"\u2003\u2003} else {"},{"entry":"\u2003\u2003\u2003exit_flag = (IO(addr) == expected)? TRUE : FALSE;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003} while (exit_flag == FALSE);"},{"entry":"\u2003return TRUE;"},{"entry":"}\/\/ XVCIO_Handshake"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Note that the IO macro used above is defined as:",{"@attributes":{"id":"p-0152","num":"0199"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"#ifndef IO"]},{"entry":[{},"#\u2003define\u2003IO(addr)\u2003(*((volatile unsigned*)\u2003(addr)))"]},{"entry":[{},"#endif"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0153","num":"0200"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"301pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/------------------------------------------------------------------------"},{"entry":"\/\/ Routine . XVCIO_InitComms"},{"entry":"\/\/"},{"entry":"\/\/ Purpose . Synchronise with the RVD-XVC"},{"entry":"\/\/"},{"entry":"int XVCIO_InitComms(volatile XVCINOUT* xvc)"},{"entry":"{"},{"entry":"\u2003unsigned int timeout1;"},{"entry":"\u2003unsigned int timeout2;"},{"entry":"\u2003unsigned int xvcversion;"},{"entry":"\u2003\/\/ Ensure that the header is valid\/initialised"},{"entry":"\u2003if (XVCIO_InitCommsStruct(xvc) == FALSE) return FALSE;"},{"entry":"\u2003\/\/ RVD XVC should write to its status register"},{"entry":"\u2003if (XVCIO_Handshake((unsigned int)&(xvc->uRVDXVCstatus), (unsigned int)XVCIO_RVINIT,"},{"entry":"XVCIO_HANDSHAKE_NE, &timeout1) == FALSE)"},{"entry":"\u2003{"},{"entry":"\u2003\u2003\u2003return FALSE;"},{"entry":"\u2003};"},{"entry":"\u2003\/\/ Handshake with RVD-XVC by reading the RVD-XVC parameter word and responding"},{"entry":"\u2003\/\/ by complementing this value and taking 1 and storing in the SW parameter WORD"},{"entry":"\u2003\/\/ software status world"},{"entry":"\u2003if (xvc->uRVDXVCparam) {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003xvcversion","= xvc->uRVDXVCparam;"]},{"entry":["\u2003\u2003xvc->uSWparam","= (\u2212xvc->uRVDXVCparam)\u22121L;"]},{"entry":["\u2003\u2003xvc->uSWstatus","= XVCIO_SWINIT;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"301pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003} else {"},{"entry":"\u2003\u2003return FALSE;"},{"entry":"\u2003};"},{"entry":"\u2003\/\/ RVD XVC should respond by clearing its parameter word"},{"entry":"\u2003if (XVCIO_Handshake((unsigned int)&(xvc->uRVDXVCparam), 0, XVCIO_HANDSHAKE_NE,"},{"entry":"&timeout2) == FALSE)"},{"entry":"\u2003{"},{"entry":"\u2003\u2003return FALSE;"},{"entry":"\u2003};"},{"entry":"\u2003xvc->uSWparam = 0L;"},{"entry":"\u2003xvc->uSWstatus = XVCIO_SWREADY;"},{"entry":"\u2003return TRUE;"},{"entry":"}\/\/ XVCIO_InitComms"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},{"@attributes":{"id":"p-0154","num":"0201"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/------------------------------------------------------------------------"},{"entry":"\/\/ Routine . XVCIO_EnterPollLoop"},{"entry":"\/\/"},{"entry":"\/\/ Purpose . Wait for commands from the RVD-XVC"},{"entry":"\/\/"},{"entry":"int XVCIO_EnterPollLoop(volatile XVCINOUT* xvc)"},{"entry":"{"},{"entry":"\u2003\u2002XVCIO_CMDT thiscmd = XVCIO_NOP;"},{"entry":"\u2003\u2002XVCIO_RVSTATUS rvdxvcstate = XVCIO_RVUNKNOWN;"},{"entry":"\u2003\u2002XVCIO_TESTFUNCTION tf;"},{"entry":"\u2003\u2002static unsigned int taskid = 0;"},{"entry":"\u2003\u2002unsigned int ack, timeout, cmd_timeout;"},{"entry":"\u2003\u2002unsigned int validcmd = FALSE;"},{"entry":"\u2003\/\/ Check for invalid pointer and for valid starting states"},{"entry":"\u2003if (XVCIO_CheckValidHeader(xvc) == FALSE) return FALSE;"},{"entry":"\u2003if (xvc->cdt != XVCIO_DOCMDT) return FALSE;"},{"entry":"\u2003if (xvc->uSWstatus != XVCIO_SWREADY) return FALSE;"},{"entry":"\u2003\/\/ ----------------- Loop until not finished or until error -----------------"},{"entry":"\u2003do {"},{"entry":"\u2003\u2003cmd_timeout = 0;"},{"entry":"\u2003\u2003\/\/ ----------------- Wait for a new command -----------------"},{"entry":"\u2003\u2003do {"},{"entry":"\u2003\u2003\u2003XVCIO_Handshake_hook(XVCIO_HSCMD, &cmd_timeout);"},{"entry":"\u2003\u2003\u2003rvdxvcstate = xvc->uRVDXVCstatus;"},{"entry":"\u2003\u2003} while ((rvdxvcstate == XVCIO_RVREADY) && (rvdxvcstate != XVCIO_RVERROR));"},{"entry":"\u2003\u2003if (xvc->uRVDXVCstatus != XVCIO_RVCMD) {"},{"entry":"\u2003\u2003\u2003xvc->uSWparam = 0L;"},{"entry":"\u2003\u2003\u2003xvc->uSWstatus = XVCIO_SWREADY;"},{"entry":"\u2003\u2003\u2003return FALSE;"},{"entry":"\u2003\u2003};"},{"entry":"\u2003\u2003validcmd = FALSE;"},{"entry":"\u2003\u2003thiscmd = xvc->cdData.docmd.cmd;"},{"entry":"\u2003\u2003\/\/ ----------------- XVCIO_RESET"},{"entry":"\u2003\u2003if (thiscmd == XVCIO_RESET) {"},{"entry":"\u2003\u2003\u2003validcmd = TRUE;"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003\u2003xvc->id","= XVCIO_INVALIDHEADER;"]},{"entry":["\u2003\u2003\u2003xvc->uSWstatus","= XVCIO_SWREADY;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\u2003return FALSE;"},{"entry":"\u2003\u2003};"},{"entry":"\u2003\u2003\/\/ ----------------- XVCIO_EXECUTE"},{"entry":"\u2003\u2003if (thiscmd == XVCIO_EXECUTE) {"},{"entry":"\u2003\u2003\u2003validcmd = TRUE;"},{"entry":"\u2003\u2003\u2003\/\/ Set up and call the specified function"},{"entry":"\u2003\u2003\u2003xvc->uSWparam = xvc->cdData.docmd.task_id = ++taskid;"},{"entry":"\u2003\u2003\u2003tf = (XVCIO_TESTFUNCTION) xvc->cdData.docmd.addr;"},{"entry":"\u2003\u2003\u2003xvc->uSWstatus = XVCIO_SWEXEC;"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003\u2003xvc->cdData.docmd.retval","= tf(xvc->cdData.docmd.r0,"]},{"entry":[{},"\u2003\u2002xvc->cdData.docmd.r1,"]},{"entry":[{},"\u2003\u2002xvc->cdData.docmd.r2,"]},{"entry":[{},"\u2003\u2002xvc->cdData.docmd.r3);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\u2003\/\/ Process return value"},{"entry":"\u2003\u2003\u2003xvc->uSWstatus = (xvc->cdData.docmd.retval)? XVCIO_SWERROR : XVCIO_SWOKAY;"},{"entry":"\u2003\u2003\u2003\/\/ Handshake return status out to RVD-XVC before continuing"},{"entry":"\u2003\u2003\u2003ack = XVCIO_Handshake((unsigned int)&(xvc->uRVDXVCstatus),"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002(unsigned int)XVCIO_RVCMD,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003XVCIO_HANDSHAKE_EQ, &timeout);"},{"entry":"\u2003\u2003\u2003xvc->uSWparam =0L;"},{"entry":"\u2003\u2003\u2003xvc->uSwstatus = XVCIO_SWREADY;"},{"entry":"\u2003\u2003};"},{"entry":"\u2003\u2003\/\/ ----------------- XVCIO_FINISH"},{"entry":"\u2003\u2003if (thiscmd == XVCIO_FINISH) {"},{"entry":"\u2003\u2003\u2003validcmd = TRUE;"},{"entry":"\u2003\u2003\u2003\/\/ Handshake return status out to RVD-XVC before continuing"},{"entry":"\u2003\u2003\u2003xvc->uSWstatus = XVCIO_SWOKAY;"},{"entry":"\u2003\u2003\u2003ack = XVCIO_Handshake((unsigned int)&(xvc->uRVDXVCstatus),"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002(unsigned int)XVCIO_RVCMD,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003XVCIO_HANDSHAKE_EQ, &timeout);"},{"entry":"\u2003\u2003\u2003xvc->uSWparam = 0L;"},{"entry":"\u2003\u2003\u2003xvc->uSWstatus = XVCIO_SWREADY;"},{"entry":"\u2003\u2003};"},{"entry":"\u2003\u2003xvc->uSWparam = 0L;"},{"entry":"\u2003\u2003xvc->uSWstatus = XVCIO_SWREADY;"},{"entry":"\u2003\u2003if (validcmd == FALSE) return FALSE;"},{"entry":"\u2003\u2003if (ack == FALSE) return FALSE;"},{"entry":"\u2003} while ((thiscmd != XVCIO_FINISH) ||(thiscmd != XVCIO_RESET));"},{"entry":"\u2003return TRUE;"},{"entry":"}\/\/ XVCIO_EnterPollLoop"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"EABS is an interface within RVD that allows 3rd parties to write a shared object, (.dll or .so), that plugs into RVD and gives access to its debug functionality. The shared object will be referred to as an EABS object. The EABS object is loaded at RVD startup and then controlled by the user through a window activated from the RVD menu system. The interface allows the EABS object to read and write memory, registers and variables. It also allows EABS object to be informed about key events happening in the debugger and on the target.","The following calls are required for communication between the RVD-XVC and the RVD itself and are called from within the AGI later of the RVD-XVC:",{"@attributes":{"id":"p-0157","num":"0204"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"308pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"EABS_RET EabsInit( struct _EABS *self, EABS_LOCAL *pstEabsMaster, char *error_msg);"},{"entry":"EABS_RET EabsTerm(struct _EABS *self, struct _EABS_LOCAL *pstEabs, char *buffer);"},{"entry":"EABS_RET EabsStart(long lHandle);"},{"entry":"EABS_RET EabsAddConn(long lConn, char* pchDesc);"},{"entry":"EABS_RET EabsDeleteConn(long lConn);"},{"entry":"EABS_SubmitCmd(lConn, name);"},{"entry":"EABS_WriteMem(lConn, (unsigned long)lAddr, EABS_MEM_ACCESS_BYTE, 1, &uchValue,"},{"entry":"&bytes_written);"},{"entry":"EABS_ReadMem(lConn, (unsigned long)lReadAddr, 4, EABS_MEM_ACCESS_BYTE, &bytes_read,"},{"entry":"&value[0]);"},{"entry":"EABS_GetLastError(lConn, &error[0], &value);"},{"entry":"void ReceiveEvent(EABS_EVENT evt, unsigned long lConn, void* pData);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2002----------------------------------------------------------------------------"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"From the above discussion of embodiments of the present invention, it will be appreciated that such embodiments of the present invention provide a particularly efficient and flexible technique for performing hardware and software co-verification whilst co-ordinating the execution of software routines with a sequence of verification tests. In one particular embodiment, an XVC-based hardware verification environment is connected through an ARM RealView Debugger (RVD) into a software environment running on an ARM processor, which is also connected commonly to the RVD. An RVD-XVC contains an algorithm for loading in an address map (derived from a standard ARMlink option) of functions of a piece of software code to be tested, and the technique of this embodiment provides an ability for a user to specify a sequence of software functions to be called which are interleaved precisely with hardware events. An interface protocol is also provided such that the RVD external interface (EABS extension DLL) can be used to communicate via a scratch RAM location accessible to the processor, to allow status information to be exchanged. A software algorithm\/library and method of configuring a software application is also provided, such that the scratch RAM can be used to efficiently communicate with the RVD-XVC.","One additional way in which such embodiments can be used is in the automatic software testing of the RealView tools themselves, since the debugger becomes the slave in the test scenario, and automated\/scripted debug sessions can be easily be replayed without the need for manual intervention. Remote control of the debugger also allows the test environment to be self-checking as well as automated, with the RVD-XVC acting as the checking mechanism for the debugger.","One advantage of the approach of embodiments of the present invention, apart from coupling hardware\/software integration testing, is that this method can be applied at any abstraction level from SystemC model prototype simulation, through to RTL simulation, up to silicon level testing. In particular, embodiments of the present invention may be applied at any of the following abstraction levels:","1. SystemC Models, where the debugger and signal interface controllers connect via a SystemC interface","2. RTL\u2014compiled and run on a hardware simulator computer program product","3. Simulation Acceleration Logic format\u2014similar to compiled RTL but with certain logic functions mapped to configurable hardware logic elements, and encapsulated within a dedicated hardware debugging environment","4. Hardware Emulation Logic format\u2014similar to FPGA but encapsulated within a dedicated hardware debugging environment. This approach is faster than option 3 above, but with restricted visibility of internal hardware logic states","5. FPGA","6. Silicon","The methodology of embodiments of the present invention can also be generally applied to any debugger\/software combination on any platform provided that the debugger software has an external software interface (API).","Although a particular embodiment of the invention has been described herein, it will be apparent that the invention is not limited thereto, and that many modifications and additions may be made within the scope of the invention. For example, various combinations of the features of the following dependent claims could be made with the features of the independent claims without departing from the scope of the present invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention will be described further, by way of example only, with reference to preferred embodiments thereof as illustrated in the accompanying drawings, in which:",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIGS. 1A and 1B"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 5A"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 5B","FIG. 5A"]},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIGS. 12 to 15"}]},"DETDESC":[{},{}]}
