---
title: Scheduling of instructions
abstract: A method of automatically extracting information from an architecture description. A memory resident directed acyclic graph data structure comprising nodes representing instructions and edges whose weights represent dependencies between pairs of instructions is constructed. A list of ready nodes are maintained in the directed acyclic graph. A list of nodes not scheduled is maintained. And, it is determined whether the next instruction to be scheduled is to be taken from the list of ready nodes or from the list of nodes not yet scheduled.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08689202&OS=08689202&RS=08689202
owner: Synopsys, Inc.
number: 08689202
owner_city: Mountain View
owner_country: US
publication_date: 20050330
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED U.S. APPLICATION","FIELD OF THE INVENTION","BACKGROUND ART","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","NOTATION AND NOMENCLATURE","Extracting Scheduling Information from an Architecture Description","Semi-Automatic Generation of Compiler Description from Architecture Description Using a GUI"],"p":["This Application claims priority to U.S. Provisional Application entitled, \u201cMETHOD AND SYSTEM OF SCHEDULING INSTRUCTIONS,\u201d Application No. 60\/558,334, filed on Mar. 30, 2004, which application is hereby incorporated by reference.","This Application is related to U.S. Application entitled, \u201cGENERATION OF COMPILER DESCRIPTION FROM ARCHITECTURE DESCRIPTION,\u201d application Ser. No. 10\/815,228, filed on Mar. 30, 2004.","A portion of the disclosure of this patent document contains material that is subject to copyright protection. The copyright holder has no objection to the facsimile reproduction by any one of the patent disclosure, as it appears in the Patent and Trademark Office files or records, but otherwise reserves all copyright rights whatsoever.","Embodiments of the present invention relate to the field of software tools for system level design. Specifically, embodiments of the present invention relate to semi-automatically generating a compiler description from an architecture description.","The design and test of modern electronic devices, such as embedded processors (EP) and systems-on-a-chip (SoC) is a complex process involving many stages. For example, many systems, such as mobile devices, networking products, and modems require new embedded processors (EP). These EPs can either be general purpose, such as microcontrollers (\u03bcC) and digital signal processors (DSP), or application specific, using application specific instruction set processors (ASIP).","Compared to ASICs, DSPs, ICs, and general-purpose processors, ASIPs provide a tradeoff of computational performance and flexibility on the one hand and power consumption on the other. Therefore, ASIPs that are designed to execute specific tasks very efficiently can be found in a wide range of embedded systems.","However, designing systems with ASIPs is far more complex than assembling systems with standard processors. Typically, designing ASIPs comprises an iterative exploration in which hardware and software are explored and modified. This iterative process is referred to as an architecture exploration loop. The architecture exploration requires a number of tools, such as an assembler, linker, and simulator. If hardware and software are available, profiling results are acquired that usually lead to architecture modifications making the processor more efficient. To be consistent with these modifications, the software tools potentially need to be changed, as well.","The algorithm that is executed by the ASIP is usually specified by algorithm designers in a high level language, such as the C programming language. The overall design time can be significantly reduced by introducing into the architecture exploration loop a compiler that reflects the architecture. Besides reducing the implementation and verification time, the availability of a compiler also increases the system reusability for similar applications.","However, using a compiler in the architecture exploration loop is only beneficial if the compiler itself can be created accurately and efficiently. Thus, there is a need for an efficient and accurate technique for creating a compiler that is usable in an architecture exploration loop.","There have been a number of attempts at generating a compiler for use in architecture exploration. However, these conventional techniques have various weaknesses, such as being limited to the type of architecture that may be explored.","A detailed overview of work related to compiler generation from processor architecture description languages (ADLs) or compiler specifications is given by R. Leupers and P. Marwedel in, \u201cRetargetable Compiler Technology for Embedded Systems,\u201d Kluwer Academic Publishers, Boston, October 2001.","A compiler development environment that is mainly useful for VLIW architectures is the Instruction Set Description Language (ISDL), \u201cISDL: An Instruction Set Description Language for Retargetability,\u201d G. Hadjiyiannis, S. Hanono, and S. Devadas. In Proc. of the Design Automation Conference (DAC), June 1997. This conventional technique hierarchically describes the processor and lists invalid instruction combinations in a constraints section. This list becomes very lengthy and complex for DSP architectures like the Motorola 56k. Therefore, this technique is mainly useful for orthogonal processors.","A technique described by Trimaran is capable of retargeting a sophisticated compiler. However, the technique is limited to a very restricted class of VLIW architectures called HPL-PD. HPL-PD (Hewlett-Packard Laboratories PlayDoh) is a parametric processor architecture conceived for research in instruction-level parallelism (ILP). Trimaran's tool input is a manual specification of processor resources (functional units), instruction latencies, etc. (Trimaran. \u201cAn Infrastructure for Research in Instruction-Level Parallelism\u201d http:\/\/www.trimaran.com.)","An extension of the CoSy\u00ae environment (ACE Associated Computer Experts by. \u201cThe CoSy\u00ae Compiler Development System\u201d http:\/\/www.ace.nl.) can be retargeted from a FlexWare2 description. (P. Paulin. \u201cTowards Application-Specific Architecture Platforms Embedded Systems Design Automation Technologies.\u201d In Proc. of the EuroMicro, April 2000.) Unfortunately, for the generation of the other software tools, FlexWare2 requires separate descriptions. This redundancy introduces a consistency\/verification problem.","The concept for scheduler generation has been proposed in EXPRESSION. (Peter Grun, Ashok Halambi, Nikil D. Dutt, and Alexandru Nicolau. \u201cRTGEN: An Algorithm for Automatic Generation of Reservation Tables from Architectural Descriptions.\u201d In Proc. of the Int. Symposium on System Synthesis (ISSS), pages 44-50, 1999.) The concept for scheduler generation has also been proposed in PEAS-III. (M. Itoh, S. Higaki, J. Sato, A. Shiomi, Y. Takeuchi A. Kitajima, and M. Imai. \u201cPEAS-III: An ASIP Design Environment.\u201d In Proc. of the Int. Conf. on Computer Design (ICCD), September 2000). Both of these conventional techniques extract structural information from the processor description that allows the tracing of instructions through the pipeline. Instructions are automatically classified by their temporal I\/O behavior and their resource allocation. Based on this information, a scheduler can be generated. In PEAS-III, all functional units that are used to model the behavior of instructions are taken from a predefined set called flexible hardware model database (FHT).","MIMOLA traces the interconnects of functional units to detect resource conflicts and I\/O behavior of instructions. (R. Leupers and P. Marwedel. \u201cRetargetable Code Compilation based on Structural Processor Descriptions.\u201d Design Automation for Embedded Systems, 3(1):1-36, January 1998. Kluwer Academic Publishers). For non-pipelined architectures, it is possible to generate a compiler called MSSQ, which also includes an instruction scheduler. However, the abstraction level of MIMOLA descriptions is very low, which slows down the architecture exploration loop.","The CHESS (D. Lanner, J. Van Praet, A. Kiffl, K. Schoofs, W. Geurts, F. Thoen, and G. Goosens. \u201cChess: Retargetable Code Generation for Embedded DSP Processors.\u201d In P. Marwedel and G. Goosens, editors, Code Generation for Embedded Processors. Kluwer Academic Publishers, 1995.) code generator is based on an extended form of the nML ADL (A. Fauth, J. Van Praet, and M. Freericks. \u201cDescribing Instruction Set Processors Using nML.\u201d In Proc. of the European Design and Test Conference (ED & TC), March 1995). Similar to the MSSQ compiler, the scheduler uses the instruction coding to determine which instructions can be scheduled in parallel. In contrast to MSSQ, the CHESS compiler can be used to generate code for pipelined architectures. This is achieved by manually attaching latency information (e.g., number of delay slots) to the instructions. CHESS is primarily useful for retargeting compilers for DSPs.","The Marion system uses the Maril language to generate a compiler. (D. G. Bradlee, R. E. Henry, and S. J. Eggers. \u201cThe Marion System for Retargetable Instruction Scheduling.\u201d In Proc. of the Int. Conf. on Programming Language Design and Implementation (PLDI), pages 229-240, 1991.) However, the system is restricted to RISC architectures: All target machines need to have general purpose register sets, each instruction produces at most one result, and only load and store operations can access memory.","The Mescal group, which is part of the Gigascale Research Center, recently proposed an operation state machine (OSM) based modeling framework. (W. Qin and S. Malik. \u201cFlexible and formal modeling of microprocessors with application to retargetable simulation.\u201d In Proc. of the Conference on Design, Automation & Test in Europe (DATE), March 2003.) OSM separates the processor into two interacting layers: an operation and timing layer and a hardware layer that describes the micro-architecture. A StrongARM and a PowerPC-750 simulator could be generated.","An operBT\/listBT backtracking scheduler has been proposed. (S. G. Abraham, W. Meleis, and I. D. Baev. \u201cEfficient backtracking instruction schedulers.\u201d In IEEE PACT, pages 301-308, May 2000.) However, the technique described in that paper is limited in its ability to handle delays. The paper presents two different backtracking scheduler techniques: The operBT scheduler and the listBT scheduler. Both schedulers assign priorities to the nodes of the dependence DAG. In contrast to other schedulers, the operBT scheduler does not maintain a ready list. It utilizes a list of nodes not yet scheduled that is sorted by node priority. It takes the highest priority node from this list and schedules it using one of the following three scheduling modes:","Schedule an operation without un-scheduling (normal).","Un-schedule lower priority operations and schedule into current_cycle (displace).","Un-schedule high priority operations to avoid invalid schedules and schedule an instruction into a so-called force_cycle (force).","The operBT scheduler has the drawback of being relatively slow due to many un-scheduling operations. To overcome this drawback, the operBT scheduler was extended to the listBT scheduler. This scheduler tries to combine the advantage of the conventional list scheduler (fast) with the advantage of the operBT scheduler (better schedule). The listBT scheduler does maintain a ready list. This means only nodes that are ready can be scheduled. Unfortunately the delay slot filling of the listBT scheduler does not work for all cases.","Therefore, it would be advantageous to provide a method and system that reduce the time required for the design exploration phase. It would be further advantageous to accurately and efficiently generate a compiler description that may be used in an architecture exploration. It would be still further advantageous to meet the above constraints while being compatible with existing technologies for developing embedded processors, systems-on-a-chip, and ASIPs.","Accordingly, embodiments of the present invention provide methods of and systems that reduce the time required for the design exploration phase. Embodiments of the present invention accurately and efficiently generate a compiler description that may be used in an architecture exploration. Embodiments of the present invention meet the above constraints while being compatible with existing technologies for developing embedded processors, systems-on-a-chip, and ASIPs. Embodiments of the present invention provide these advantages and others not specifically mentioned above but described in the sections to follow.","An embodiment of the present invention comprises a computer-implemented method of automatically extracting information from an architecture description. This embodiment comprises constructing a memory resident directed acyclic graph data structure comprising nodes representing instructions and edges whose weights represent dependencies between pairs of instructions; maintaining a list of ready nodes in the directed acyclic graph; maintaining a list of nodes not scheduled; and determining whether the next instruction to be scheduled is to be taken from the list of ready nodes or from the list of nodes not scheduled.","Systems and devices in accordance with embodiments of the present invention are also described herein.","In the following detailed description of embodiments of the present invention, semi-automatically generating a compiler description from an architecture description, numerous specific details are set forth in order to provide a thorough understanding of the present invention. However, it will be recognized by one skilled in the art that the present invention may be practiced without these specific details or with equivalents thereof. In other instances, well-known methods, procedures, and components have not been described in detail as not to unnecessarily obscure aspects of the present invention.","Some portions of the detailed descriptions that follow are presented in terms of procedures, steps, logic blocks, processing, and other symbolic representations of operations on data bits that can be performed on computer memory. These descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. A procedure, computer executed step, logic block, process, etc., is here, and generally, conceived to be a self-consistent sequence of steps or instructions leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually, though not necessarily, these quantities take the form of electrical or magnetic signals capable of being stored, transferred, combined, compared, and otherwise manipulated in a computer system. It has proven convenient at times, principally for reasons of common usage, to refer to these signals as bits, values, elements, symbols, characters, terms, numbers, or the like.","It should be borne in mind, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussions, it is appreciated that throughout the present invention, discussions utilizing terms such as \u201cexecuting\u201d or \u201creceiving\u201d or \u201cgenerating\u201d or \u201cprocessing\u201d or \u201ccomputing\u201d or \u201ctranslating\u201d or \u201cmapping\u201d or \u201cdetermining\u201d or \u201cmaintaining\u201d or \u201cimporting\u201d or \u201cstoring\u201d or \u201cconstructing\u201d or \u201caccessing\u201d or \u201cextracting\u201d or \u201cselecting\u201d or \u201cremoving\u201d or the like, refer to the action and processes of a computer system, or similar electronic computing device, that manipulates and transforms data represented as physical (electronic) quantities within the computer system's registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage, transmission or display devices.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 1","b":["150","160","150","150","150"]},"The compiler generator with GUI  extracts information from the architecture description  that is useful in generating a compiler description. This extracted information is imported into a computer program that displays this information in a GUI. The GUI allows the architecture's designer to input additional information that is useful in generating the compiler. The GUI also allows the architecture's designer to modify the extracted information, if so desired.  depict various dialog windows of the GUI that allow the user to input and modify information that is useful in generating a compiler description for the architecture being developed. The compiler generator with GUI  outputs a compiler description, based on the information extracted from the architecture description  and the information that the architecture's designer input and\/or modified using the GUI.","The compiler description is input into the compiler generator, which outputs the compiler . A suitable compiler generator  is the COSY\u00ae Compiler Development System provided by Associated Computer Experts (ACE) of Amsterdam, The Netherlands. However, the present invention is not limited to this compiler generator. The compiler  parses the C code , applies typical high level optimizations, utilizes a tree pattern matcher for code selection and conducts a global register allocation. The output of the compiler  is unscheduled instrumented assembly code . This means that each assembly instruction contains an instruction class identifier and information about the resources (e.g., registers, memory) that it reads or writes. From this input, the Ipacker tool  creates a dependence directed acyclic graph (DAG). An exemplary dependence DAG is illustrated in . The DAG is fed into a mixedBT scheduler, which is implemented in the Ipacker tool . Exemplary pseudocode for an implemented mixedBT scheduler is depicted in . The scheduling result is assembly code  that is compliant with the ADL model of the architecture being developed. The assembly code  is read by the assembler\/linker . The assembler\/linker may be generated from the architecture description  as well. However, the generation of the assembler\/linker is not a requirement of the present invention.","To retarget the output of the compiler generator  and Ipacker , the information extracted from the architecture description  is presented in a GUI. One reason for this extension is the fact that the compiler generator with GUI  requires information not contained in the architecture description  (e.g. calling conventions, stack layout). This information can be added in the GUI. Another reason is to offer the architecture designer the opportunity to override analysis results. It is possible to start the architecture design with a very simple architecture description  that mainly describes the instruction set but no temporal behavior (e.g., the pipeline is not modeled). The compiler generator with GUI  can be used to model instruction latencies, register file sizes, etc. Thus, the impact of major architectural changes can quickly be profiled through the compiler generator with GUI . A third benefit of the GUI is that it provides an opportunity to override analysis results that are too conservative. Such overriding can be useful if the architecture description  contains unrecognized hardware to hide instruction latencies.","For a given set of instructions, a scheduler decides which instructions are issued on the processor in which cycle. For instruction level parallelism (ILP) architectures, this not only means that the scheduler decides on the sequence in which instructions are executed, but it also arranges instructions to be executed in parallel. The freedom of scheduling is limited by two major constraints: structural hazards and data hazards. Structural hazards result from instructions that utilize exclusive processor resources. If two instructions require the same resource, then these two instructions are mutually exclusive. A typical example of structural hazards is the number of issue slots available on a processor architecture. For example, it is never possible to issue more instructions in a cycle than the number of available slots. Data hazards result from the temporal I\/O behavior of instructions. Data hazards can be subdivided into read after write (RAW), write after write (WAW), and write after read (WAR) hazards. An example for a RAW dependency is a multiplication that takes two cycles to finish computation on a processor without interlocking hardware followed by a second instruction that consumes the result of the multiplication. In this case, the multiplication has a RAW dependence of two cycles onto the second instruction. Consequently, the second instruction is issued two or more cycles after the multiplication.","Embodiments in accordance with the present invention find and associate a set of virtual resources (e.g., resources that have no direct correspondence in the processor hardware) with each instruction of an architecture description. These resources are exclusively allocated if an instruction is scheduled. Using a reservation table technique the scheduler can decide which instructions are allowed to be issued in the same clock cycle.","Embodiments in accordance with the present invention automatically extract the RAW, WAW, and WAR data flow hazards from an architecture description. This allows the generation of a complete instruction scheduler from the architecture description.","Exemplary Architecture Description Language","The following discussion outlines aspects of the structure of an exemplary ADL in order to facilitate explanation and understanding of embodiments in accordance with the present invention. However, the present invention is not limited to using this exemplary ADL. The following exemplary ADL is substantially compliant with the LISA language. A more detailed explanation of LISA and related software tools is provided in, \u201cArchitecture Exploration for Embedded Processors With LISA,\u201d by A. Hoffmann, H. Meyr and R. Leupers. Kluwer Academic Publishers, January 2003.","An exemplary single LISA operation  is illustrated in . A LISA processor description consists of two parts: The LISA operation tree and a resource specification. The operation tree is a hierarchical specification of instruction coding, syntax, and behavior. The resource specification describes memories, caches, processor registers, signals, and pipelines. There is not a resource specification in the example of . The name of this operation in  is register_alu_instr and it is located in the ID stage (instruction decode) of the pipeline called pipe.","The DECLARE section  contains local declarations and announcements for a LISA operation. In this example, the DECLARE section  lists the sons of register_alu_instr in the operation tree. ADD and SUB are names of other LISA operations that have their own binary coding, syntax, and behavior.","The CODING section  describes the binary image of the instruction word that is a part of the instruction set model. The SYNTAX section  describes the assembly syntax of instructions and their operands.","The BEHAVIOR section  indicates that elements of the GP_Regs array resource are read and written into a pipeline register. This means that the general-purpose register file is read in the instruction decode stage.","The ACTIVATION section  describes the subsequent control flow of the instruction through the processor. The LISA operation behind Opcode is generally (but not necessarily) located in a subsequent pipeline stage, which means that it will be activated in a subsequent cycle. Thus the ACTIVATION section  creates a chain of operations as depicted in .","Extracting Instruction Latencies",{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 3","b":["300","0","1","2","3","305","0","305","310","310","1","315","321","322","319","323","324"]},"Based on the activation chain, it can be determined which LISA operation of the instruction is executed in which cycle. Furthermore, it can be determined if the C code in the BEHAVIOR section of the operations accesses processor resources of the LISA model. In the example of , the decoding of the instruction results in the \u201cregister_alu_instr\u201d, as opposed to the \u201cimm_alu_instr.\u201d In this case, an add is performed in cycle  and the result is written back to register  in cycle , as indicated by the alu_wb box .","The analysis of activation chains in accordance with embodiments of the present invention differs from a trace technique that is used in some conventional design environments. Traces include information about which functional units are used by an instruction in a specific cycle. Traces require modeling of functional units and their interconnects. In the LISA language, operations are abstracted from functional units, which significantly speeds up the architecture exploration phase. For example, a processor such as the ST200 VLIW processor has four parallel ALUs that can execute an addition. In the LISA model there is only a single ADD operation that is potentially activated four times in the same clock cycle from different sources.","The vectors of two example assembly instructions are depicted in the diagram  of , depicting latency analysis in accordance with an embodiment of the present invention. The add immediate instruction, \u201cADDI R, R, \u201d reads the program counter (PC) in its cycle . In its cycle  it reads a source operand from register R, and in cycle  it writes a result back to register R. The add immediate instruction is followed by a return instruction \u201cRET\u201d that reads the PC in its cycle  and writes the PC in its cycle . The dependency between the two instructions is a \u201cwrite after read\u201d (WAR). Furthermore, the latency from the add immediate instruction to the return instruction is \u22121.","Based on the LISA activation chains, a determination can be made as to when an instruction accesses processor resources. The access direction (read or write) and the resource names are organized in an instruction specific vector. Starting from cycle , each vector component represents a cycle that is required to execute the instruction.","To schedule a sequence of instructions, embodiments in accordance with the present invention construct a directed acyclic graph (DAG)  data structure such as the one depicted in . The DAG comprises three instructions, labeled 1, 2, and 3 in this example. The arrow between each instruction is referred to as an edge and is assigned a weight based on the latency between the instructions. In general, each edge weight of the DAG represents a RAW, WAW, or WAR dependency between a pair of instructions. In , all dependencies are of the WAR variety. If there is more than one latency between two instructions (e.g., the second instruction reads and writes a register that is written by the first instruction) the maximum latency is taken.","The following discussion covers more general sequences of instructions than depicted in . If a second instruction \u201cI\u201d reads a register resource \u201cR\u201d that was written by a first instruction \u201cI,\u201d then the RAW latency is calculated by the formula expressed in Equation 1.\n\nRAW=last write cycle(1)\u2212first read cycle(2)+1\u2003\u2003Eq. 1:\n","The last write cycle function iterates through the vector of instruction I and returns the greatest component index that indicates a write to register resource R. Similarly, the first read cycle function returns the first component index of instruction I that contains a read of register resource R. The inherent resource latency is taken into account by the last addend because it takes one cycle to read a value from a register that has been written to it an addition of 1 is required.","If two sequential instructions \u201cI\u201d and \u201cI\u201d write to the same register resource \u201cR,\u201d then the WAW latency is computed as expressed in Equation 2.\n\nWAW=last write cycle(1)\u2212last write cycle(2)+1.\u2003\u2003Eq. 2:\n\nIn Equation 2, the addition of 1 is needed because it is not possible that two instructions write a resource at the same time.\n","If the second instruction I writes register resource R and the first instruction I reads register resource R, then the WAR latency is computed as in Equation 3.\n\nWAR=last read cycle(1)\u2212first write cycle(2)\u2003\u2003Eq. 3:\n","An example for a WAR latency is depicted in . As previously discussed, the instruction, \u201cADDI R, R,\u201d reads the program counter (PC) in its cycle . In its cycle  it reads a source operand from register R and in cycle  it writes a result back to register R. It is followed by a RET instruction that reads the PC in its cycle  and writes it in its cycle . This means that WAR: PC=0\u22121=1.","Consequently, the RET instruction is scheduled \u22121 or more cycles behind the instruction ADDI R,R,. The negative latency can be interpreted as an opportunity to fill the delay slot of the RET instruction. For the scheduler, it is possible to issue the RET instruction one cycle before the instruction ADDI R,R,. This means that the activation chains can be used to automatically generate schedulers capable of delay slot filling, in accordance with an embodiment of the present invention. The time required for analyzing the latencies in the scheduler generator is negligible.","Scheduling Algorithms","List Scheduler","Unfortunately, typical conventional list schedulers are not capable of filling delay slots. In contrast, embodiments in accordance with the present invention are able to fill delay slots. A list scheduler in accordance with an embodiment of the present invention takes a dependence DAG representing a basic block as an input. The technique of this embodiment selects one or more of the nodes that have no predecessor (the so called ready set) to be scheduled into a cycle, as determined by a current_cycle variable. The scheduled nodes are removed from the DAG, the current_cycle is potentially incremented, and the loop starts again.","An embodiment in accordance with the present invention processes the exemplary DAG  of  a follows. A \u201ccurrent_cycle\u201d variable is initialized to 0 and the list scheduler would schedule instruction , which is the only ready node (e.g., it has no predecessor) into cycle . The node for instruction  is removed from the DAG  and instruction  becomes ready. Assuming that the underlying architecture has only a single issue slot, it is not possible to schedule any ready instruction into current_cycle (which is still 0). Consequently current_cycle is incremented. Since no latency constraint is violated, instruction  is scheduled into cycle . After another scheduling loop, instruction  is scheduled into cycle . Because the RET instruction has a delay slot, the list scheduler appends a NOP as the last instruction of the basic block. A better schedule would be instructions ,, which means that the delay slot of the RET instruction is filled with one of the preceding instructions. To create this schedule, the scheduler is able to revoke decisions on instructions being scheduled into certain cycles. An embodiment of the present invention discussed below provides for an improved scheduling that is able to revoke decisions on instructions being scheduled into certain cycles.","5.2 Backtracking Schedulers","As discussed herein, conventional back-tracking algorithms are limited in their ability to handle delays.  illustrates an example of a dependence DAG  for which a conventional listBT scheduler creates the following schedule after 11 scheduling loops iterations:","(0) ADDI R,R,;","(1) NOP;","(2) RET;","(3) ADDI R,R,.","The reason for the NOP is that in the 9th schedule loop iteration the scheduler tries to schedule ADDI R,R, instead of the higher prioritized RET. This leads to a correct but sub-optimal schedule. Embodiments in accordance with the present invention provide a more optimal schedule than the schedule provided by this conventional back-tracking algorithm.\n\nMixedBT Scheduler\n","A mixedBT scheduler in accordance with embodiments of the present invention reduces the number of computational intense instruction un-scheduling by maintaining a ready list, but is able to switch to a better quality priority scheduling when applicable. To support both modes, a ready list and a list of nodes not yet scheduled are maintained by an embodiment of the present invention. Exemplary pseudo code of a scheduling algorithm  is depicted in , in accordance with an embodiment of the present invention. The initial priority of the DAG leaf nodes is equivalent to the cycles these instructions require to finish their computation. For all other nodes, the edge weights of any path from that node to any leaf node is accumulated. The maximum sum is the node priority.","The get_next_current_insn_to_be_scheduled function  decides from which list to take the next node that is to be scheduled. It takes the highest priority node from the list of nodes not yet scheduled if the priority is higher than any node priority in the ready list. Otherwise, the highest priority node from the ready list is scheduled next.","If there are only positive data dependencies, the ready nodes have the highest priorities. For nodes that have zero latency, the function  selects the father node. In contrast, a conventional operBT scheduler would potentially select the son here. Thus, the conventional technique would most probably lead to an un-scheduling of this node later on.","If nodes are connected by a negative latency, the son has a higher priority. The present embodiment schedules this son node first even if it is not ready. Thus, this embodiment speeds up the filling of delay slots.","The automatically extracted scheduling information may be input to a computer program that semi-automatically generates a compiler description.","Embodiments of the present invention semi-automatically generate a compiler description from an architecture description. A graphical user interface (GUI) is used to allow user interaction in conversion from the architecture description to the compiler description. The GUI visualizes information that was extracted from the architecture description that is relevant for the compiler generator and provides the user the opportunity to refine, extend, or override the information such that a desired compiler description may be generated. The extracted information may comprise schedule information, as described herein. The extracted information may also comprise other information, such as resources defined in the architecture description.","The GUI in accordance with embodiments of the present invention comprises several on-screen display windows that address different aspects of the conversion process.  are exemplary dialog screens that allow a user to refine a description of the architecture such that a compiler description may be generated, in accordance with embodiments of the present invention.",{"@attributes":{"id":"p-0084","num":"0083"},"figref":["FIG. 7A","FIG. 1","FIG. 7A"],"b":["700","700","702","704","706","702","703","702","170","704","706","708","706","701"]},{"@attributes":{"id":"p-0085","num":"0084"},"figref":["FIG. 7B","FIG. 7B"],"b":["710","711","712","710"]},"The type sizes box  of the exemplary data layout dialog  allows a user to specify certain bitwidth and alignment information. For example, the C standard does not define any bit-width for the native C data types. This information is specified by the user in bit-width column  of the exemplary data layout dialog . The desired alignment of the types in memory is specified by the user in the alignment column .","In addition to the native C types, the compiler may support the long long and long double types, for example. Column  has fields that allow the user to input structure alignments (Structures), the alignment of heap data elements (Memory Data), and stack elements (Stack). The size of an addressing unit can be specified in the Addressable Unit field.",{"@attributes":{"id":"p-0088","num":"0087"},"figref":"FIG. 7C","b":["730","732","733","734","735","736","731","730"]},"Continuing with the discussion of , to support recursive function calls the compiler makes sure that each function call dynamically reserves a certain amount of memory on a global stack. This stack frame stores all data private to the function. It contains room for all local variables (Local Area), spilled values (Spill Area) (e.g., values of registers that temporarily needed to be dumped to memory), and values that are passed as arguments to subsequent function calls (Args Area). The callee saved registers that were clobbered by the function are also saved on the stack in the (Regsave Area). The relative position of these elements can be changed by selecting an item in the dialog and pushing one of the arrow buttons  in the middle of the dialog.","The compiler that is created by embodiments of the present invention generates the code needed to set and clean up the stack each time a function is entered or left. Therefore, the user specifies some essential instructions needed for this operation, which can be entered in a pro-\/epilogue mapping dialog that is accessible by clicking on the pro-epilogue button .",{"@attributes":{"id":"p-0091","num":"0090"},"figref":"FIG. 7D","b":["740","7"]},"An embodiment of the present invention generates two additional IR nodes for each function. These are the prologue, which is the first basic block of a function, and the epilogue at the end of the function. The prologue performs the following steps:\n\n","The pro-\/epilogue GUI  concerns the following rules, in accordance with an embodiment of the present invention. In the following, the notion is: (C semantic, CoSy\u00ae rule). However, the present invention is not limited to the programming language C or to the CoSy\u00ae environment.","Rule-C: SP=FP; CoSy\u00ae: FP\u2192SP. Needed to copy the frame-pointer (FP) to the stack-pointer (SP). The instruction assigned to this rule will also be used for an assignment of the SP to the FP. During generation, the registers names will simply be exchanged for this case. Thus, the instruction is also capable of assigning the SP to the FP.","Rule-C: SP=SP+Immediate; CoSy\u00ae: mirPlus(SP, Immediate)\u2192SP. This rule is used to increase the stack-pointer by a constant value.","Rule-C: SP=SP\u2212Immediate; CoSy\u00ae: mirSub(SP, Immediate)\u2192SP. The stack-pointer is reduced by a constant using the instruction assigned to this rule.","Rule-C: SP=Stackbase; CoSy\u00ae: mirAssign(SP, Stackbase)\u2192SP. The first assign rule is used to initialize the SP in the very first function of a program, generally main. A stack-base symbol (\u201c_stackbase\u201d) will be generated in the assembly file, which can be defined during the invocation of a linker, thus determining the absolute stack frame location in memory.","Rule-C: FP[Offset]=Reg; CoSy\u00ae: mirAssign(FP+Offset, Reg). In case registers have to be saved on the stack, this rule would be applied. At least one register non-terminal is specified in the non-terminal dialog that contains all pushable registers and the frame-pointer. Furthermore, the assigned instruction should be valid if the SP is used as base address instead of the FP.","Rule-C: Reg=FP[Offset]; CoSy\u00ae: mirContent(FP+Offset)\u2192Reg In the epilogue, the saved registers have to be restored. Therefore, an instruction is needed that loads registers from the address given by FP plus Offset. Again, one register non-terminal should contain the pushable registers and the FP. Restoring the FP will use the SP as base address, hence, this instruction should be correct for this case, as well.","Rule-C: return; CoSy\u00ae: mirReturn. Specifies the instruction used to return to the caller.","Rule-C: goto Label; CoSy\u00ae: mirGoto(Label) The epilogue of the main function will generate an endless loop. Therefore, an instruction is needed that jumps to a label.",{"@attributes":{"id":"p-0102","num":"0112"},"figref":"FIG. 7E","b":["750","750"]},"Non-terminals are used to factorize the tree grammar rules of the instruction selector. This means that an IR pattern, specified in the mapping dialog, produces its result in a non-terminal, which can be the input of other IR patterns. This also means that non-terminals can have attributes. For example, if a pattern was specified for mapping an address constructed by the sum of the stack-pointer and an offset, the name of the stack-pointer register and the offset value will be written to the non-terminal attributes. A hypothetical rule for loading data from memory could have this non-terminal as input and use the attributes to fill the arguments of assembly instructions loading data from memory.","The non-terminals used for mapping IR patterns to assembly instructions are listed in the non-terminals dialog  depicted in . The main window  lists all existing non-terminal names, their types, and potential attributes. Non-terminals are added, removed or modified with the buttons  on the right hand side of the main window . A separate dialog , which has its own buttons , facilitates the adding, removing, and modifying of non-terminals. A nonterminal tab  has been selected in  to bring up the nonterminals dialog.","The non-terminal has an arbitrary but unique name. Several kinds of non-terminals are supported in accordance with this embodiment of the present invention. Following is a brief description of several non-terminal types. Other kinds of non-terminals could be supported, if desired.","REGISTERS: This non-terminal kind is used for grammar rules that produce results in processor registers. After instruction selection, the register allocator will assign a register to all rule instances of this kind that are used to cover the IR tree. The selection of the REGISTER kind activates a list box (not depicted in ). In the list box, the list of registers that are contained in the non-terminal can be specified.","ADDRMODE: REGISTER non-terminals are usually used to pass data between instructions. In contrast, the ADDRMODE non-terminal is used to factor out addressing modes common to several instructions. Attributes can be associated with ADDRMODE non-terminals. The dialog depicts the attributes that are used for a register offset addressing mode. Currently supported types of attributes are registers and integers.","MEMORY: Statement rules, e.g., rules that do not produce any non-terminal or that store their result in memory, are of the MEMORY kind.","UNIQUE: The UNIQUE non-terminal kind is used for rules that produce their result in a unique location. Comparison instructions that write to a single condition code register are a typical example. The scheduler makes sure that only one condition code value is live at any time. Consequently, the register allocator is not affected by this non-terminal kind.","The separate dialog  in  illustrates the specification of a register offset addressing mode. The non-terminal name is \u201caddr.\u201d It is of \u201cADDRMODE\u201d kind and has the attributes \u201creg\u201d and \u201coffset.\u201d The attributes represent a register and an integer respectively.","Table I is exemplary code that is generated in accordance with an embodiment of the present invention. The code, which is suitable for use as a compiler description, describes non-terminal information, in accordance with an embodiment of the present invention. Some of the information is provided by the user in various dialogs. For example, the registers may be automatically extracted from an architecture description. The pushable registers, saved registers, callee changed registers, and available registers may be user-specified. For example, dialogs  and  may be used to input various information about registers that is included in the exemplary code in Table I.",{"@attributes":{"id":"p-0112","num":"0122"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE I"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003NONTERMINALS"},{"entry":"\u2003\u2003Nt_regi REGISTERS"},{"entry":"\u2003\u2003\u2003<"},{"entry":"\u2003\u2003\u2003reg_idx_1, reg_idx_2, reg_idx_3, reg_idx_4, reg_idx_5, "},{"entry":"reg_idx_6, reg_idx_7, reg_idx_8,"},{"entry":"\u2003\u2003\u2003reg_idx_9, reg_idx_10, reg_idx_11, reg_idx_12, reg_idx_13, "},{"entry":"reg_idx_14, reg_idx_15"},{"entry":"\u2003\u2003\u2003>;"},{"entry":"\u2003\u2003Nt_addr ADDRMODE CONDITIONAL"},{"entry":"\u2003\u2003\u2003("},{"entry":"\u2003\u2003\u2003base:gcgRegister;"},{"entry":"\u2003\u2003\u2003imm8:INT;"},{"entry":"\u2003\u2003\u2003);"},{"entry":"\u2003\u2003Nt_imm12 ADDRMODE CONDITIONAL"},{"entry":"\u2003\u2003\u2003("},{"entry":"\u2003\u2003\u2003value:INT;"},{"entry":"\u2003\u2003\u2003);"},{"entry":"\u2003\u2003Nt_imm16 ADDRMODE CONDITIONAL"},{"entry":"\u2003\u2003\u2003("},{"entry":"\u2003\u2003\u2003value:INT;"},{"entry":"\u2003\u2003\u2003);"},{"entry":"\u2003\u2003memarglist MEMORY;"},{"entry":"\u2003\u2003regarglist ADDRMODE;"},{"entry":"\u2003\u00a9\u20092003, Coware, Inc."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0113","num":"0123"},"figref":"FIG. 7F","b":["760","760","762","762","762","762"]},"By double clicking the table elements, an ordered list of registers can be selected that is used to pass applicable function arguments\/return values. If no register is specified or if all registers are already used by other arguments, then the argument\/return value is passed via the stack instead.","For example, if the specification of  is applied to a hypothetical C function declared as: int f(long long a, char b, float c, short d), then the registers are assigned as follows. Register register_ would be used to pass the 64 bit integral long long argument \u201ca.\u201d The integral 8-bit char b argument would go into register regster_. The same register could also be used for the float c argument. However, since this register is already occupied, register_ is utilized. The short d argument is passed over the stack because register_ and register_ are not available. The allocation of the register for the return value is independent from the arguments. Thus, the return value of the function will be passed in register_.","In the callee changed registers box  of the dialog, the callee saved registers are selected. If a function clobbers the contents of these registers, it has to restore the register contents at its end. There is no need to specify any caller saved registers (i.e., registers that are temporarily stored to memory by the calling function before a function call. The generated compiler automatically stores the appropriate registers on the stack. If the definition of the callee is visible to the compiler it calculates the set of caller saved registers by taking an intersection of registers alive at calling time with the set of registers modified by the callee not in the callee saved register set. Otherwise, it stores all registers alive at calling time.","Table II is exemplary code that is generated in accordance with an embodiment of the present invention. The code, which is suitable for use as a compiler description, describes various register information, in accordance with an embodiment of the present invention. Some of the information is automatically extracted from an architecture description. Some of the information is provided by the user in various dialogs. For example, the registers may be automatically extracted from an architecture description. The pushable registers, saved registers, callee changed registers, and available registers may be user-specified. For example, dialogs , , , and  may be used to input various information about registers that is included in the exemplary code in Table II.",{"@attributes":{"id":"p-0118","num":"0128"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE II"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"REGISTERS",{}]},{"entry":[{},"\u2003reg_idx_0,",{}]},{"entry":[{},"\u2003reg_idx_1,",{}]},{"entry":[{},"\u2003reg_idx_2,",{}]},{"entry":[{},"\u2003reg_idx_3,",{}]},{"entry":[{},"\u2003reg_idx_4,",{}]},{"entry":[{},"\u2003reg_idx_5,",{}]},{"entry":[{},"\u2003reg_idx_6,",{}]},{"entry":[{},"\u2003reg_idx_7,",{}]},{"entry":[{},"\u2003reg_idx_8,",{}]},{"entry":[{},"\u2003reg_idx_9,",{}]},{"entry":[{},"\u2003reg_idx_10,",{}]},{"entry":[{},"\u2003reg_idx_11,",{}]},{"entry":[{},"\u2003reg_idx_12,",{}]},{"entry":[{},"\u2003reg_idx_13,",{}]},{"entry":[{},"\u2003reg_idx_14,",{}]},{"entry":[{},"\u2003reg_idx_15;",{}]},{"entry":[{},"pushable :",{}]},{"entry":[{},"\u2003\u2003reg_idx_1, reg_idx_2, reg_idx_3, reg_idx_4, reg_idx_5, ",{}]},{"entry":[{},"\u2003\u2003reg_idx_6, reg_idx_7, reg_idx_8, reg_idx_9, reg_idx_10, ",{}]},{"entry":[{},"reg_idx_11, reg_idx_12, reg_idx_13, reg_idx_14, reg_idx_15;",{}]},{"entry":[{},"implicit_saved : reg_idx_14, reg_idx_13;",{}]},{"entry":[{},"abi_callee_changed :",{}]},{"entry":[{},"\u2003\u2003reg_idx_4, reg_idx_5, reg_idx_6, reg_idx_7, reg_idx_8, ",{}]},{"entry":[{},"\u2003\u2003reg_idx_9, reg_idx_10, reg_idx_11, reg_idx_12, reg_idx_13, ",{}]},{"entry":[{},"reg_idx_14, reg_idx_15;",{}]},{"entry":[{},"sz32_regs :",{}]},{"entry":[{},"\u2003\u2003reg_idx_1, reg_idx_2, reg_idx_3, reg_idx_4, reg_idx_5, ",{}]},{"entry":[{},"\u2003\u2003reg_idx_6, reg_idx_7, reg_idx_8, reg_idx_9, reg_idx_10, ",{}]},{"entry":[{},"reg_idx_11, reg_idx_12, reg_idx_13, reg_idx_14, reg_idx_15;",{}]},{"entry":[{},"AVAIL <",{}]},{"entry":[{},"\u2003\u2003reg_idx_1, reg_idx_2, reg_idx_3, reg_idx_4, reg_idx_5, ",{}]},{"entry":[{},"\u2003\u2003reg_idx_6, reg_idx_7, reg_idx_8, reg_idx_9, reg_idx_10, ",{}]},{"entry":[{},"reg_idx_11, reg_idx_12, reg_idx_13, reg_idx_14, reg_idx_15 >;",{}]},{"entry":[{},"\u2003\u00a9\u20092003, Coware, Inc."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0119","num":"0129"},"figref":["FIG. 7G","FIG. 7G"],"b":"770"},"A data producer table  and a data consumer table  list sets of instructions referred to as \u201cdata producers\u201d or \u201cdata consumers.\u201d A read after write table , a write after write table , and a write after read table  specify, respectively, the true, output dependency, and anti-dependence latency in clock cycles for the instructions. Using the Generate Latency Tables button , the information in tables , , , , and  is automatically extracted from the architecture description in accordance with an embodiment of the present invention.","The extracted values in tables , , and  can be overridden by the user. This may be useful because the current version of the analysis tool does not recognize processor hardware for hiding latencies (e.g., forwarding paths). It may be further useful if the computed latency of instructions that utilize forwarding logic is greater than necessary (which is a conservative analysis result). The user of the GUI can enter the correct latency values in the tables , , and .","The producer\/consumer instruction sets in tables  and  are generated automatically using the Generate Latency Tables button . However, they may be added\/edited\/removed manually by using the buttons  in the producers and consumers boxes , .",{"@attributes":{"id":"p-0123","num":"0133"},"figref":["FIG. 7H","FIG. 7H"],"b":["780","781","780","782"]},"For a specific assembly instruction the children of all GROUPs are selected. Such selections are tested in the Boolean expression. An example expression would be (instruction==integer_insn) && (opcode==add), wherein instruction and opcode are LISA GROUPs and integer_insn and add are names of LISA operations. If the expression evaluates to true for an instruction, it is associated with the producer\/consumer name. If the expressions of several producers\/consumers evaluate to true, the producer\/consumer name with the smaller index is used (according to tables  and ).","Valid operators in the Boolean expression are the logical and (&&) and the logical or (II) operators, parentheses, and LISA-GROUP expressions. A LISA-GROUP expression starts with the name of a GROUP declared in the LISA model, followed by an equal (==) or a not equal (!=) sign and a list of OPERATION names separated by a vertical bar (I). A LISA-GROUP expression evaluates to true if the declaration tree of the instruction in question contains a group whose selected son operation is (or is not) part of the operation name list.","An example of a LISA-GROUP expression would be opcode==addlsub which evaluates to true if the instruction in question has a GROUP called opcode that has a selected son operation with the name add or sub.","The group list  on the left hand side of the dialog  lists all GROUPS of the LISA processor model. If an entry is selected the OPERATIONs that are declared in the GROUP are displayed in the operations column . Clicking a GROUP or an OPERATION in respectively columns  or  inserts the corresponding name into the Boolean expression field  at the current cursor position. Similarly, operations can be inserted by clicking the buttons  on the right hand side of the window. It is possible to exclude LISA processor resources from the latency analysis. This is useful, for example, if instructions write or read registers or resources that are used for debugging, only.",{"@attributes":{"id":"p-0128","num":"0138"},"figref":["FIG. 7I","FIG. 7I","FIG. 7I"],"b":["790","790","792"]},"The resource templates frame  utilizes these resources to create reservation tables. These tables are associated with LISA-INSTRUCTIONs, in accordance with an embodiment of the present invention. This means that scheduling of instructions leads to an allocation of the specified resources. Furthermore, an instruction can only be scheduled if the specified resources are available.","Resources do not necessarily have a direct correspondence to hardware resources. Their only purpose is to express valid instruction combinations by the reservation tables. All entries in this dialog can automatically be generated by pressing the Generate Reservation Tables button  on top of the window. Frame entries can be added, edited, or deleted by the buttons  on the right hand side of the window.","A so-called resource template expression is used to model the reservation table. An exemplary dialog , in accordance with an embodiment of the present invention, for adding\/editing resource templates is depicted in . The discussion of  describes an embodiment that uses the LISA language. However, it will be understood that the present invention is not limited to the LISA language. The LISA-INSTRUCTION name is depicted in the template name box  of this dialog . The template string  contains elements and operators. Elements are resources or the names of other templates. This means that it is possible to factorize reservation tables. The following is a list of valid operators:","Resource union (+): The resource union creates sets of resources. This operator is used if an instruction allocates several resources.","Subsequent cycle (>): The execution of an instruction is usually not finished in one cycle. To allocate different resources in subsequent cycles the >operator can be used.","Alternatives (I): If instructions can allocate alternative resources (e.g., one register file port out of two) the \u201cI\u201d operator can be used to express the alternative resources.","Grouping ( ): Operator precedence can be overridden by parentheses.","A number of buttons  are provided for editing purposes. The text of resources is inserted at the current cursor position into the template string  by clicking the appropriate items in the resource box . The template box  is used to select the instruction to be edited, as appears in the template name box .",{"@attributes":{"id":"p-0137","num":"0147"},"figref":["FIG. 7K","FIG. 7K"],"b":["810","810","810","810","812","811","812"]},"Several tables of exemplary code have been presented for various types of IR nodes. A detailed explanation of all IR nodes is provided in \u201cACE Associated Compiler Experts by. CCMIR Definition, May 2003, Specification in fSDL, Description and Rationale.\u201d","The code in table III is exemplary code for arithmetic IR nodes that is generated in accordance with an embodiment of the present invention. A user may input information that is useable to generate such exemplary code through, for example, the arithmetic tab  of the mapping dialog . The arithmetic IR nodes related to arithmetic operations: mirPlus (a+b), mirDiff (a\u2212b), mirAddrPlus (ptr+b), mirAddrDiff (ptr\u2212b), mirShiftLeft (a<<b), mirShiftRight (a>>b), mirShiftRightSign (a>>b), mirOr (aIb and aIIb), mirAnd (a&b and a&&b), mirXor (a^p), mirNot (!a and \u02dca), mirNeg (\u2212a), and mirCompare (a<b, a<=b, a==b, a !=b, a>=b, a>b).",{"@attributes":{"id":"p-0140","num":"0150"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"273pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"7pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE III"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"RULE [mirPlus_Nt_regi_Nt_regi__Nt_regi_30] o:mirPlus(src1:Nt_regi,src2:Nt_regi) ->",{}]},{"entry":[{},"dst:Nt_regi;",{}]},{"entry":[{},"COST 1;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\tpacks \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s = r%s +",{}]},{"entry":[{},"r%s\\042,3\\n\u201d,REGNAME(dst),REGNAME(src1),REGNAME(src2));",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirDiff_Nt_regi_Nt_regi__Nt_regi_31] o:mirDiff(src1:Nt_regi,src2:Nt_regi) ->",{}]},{"entry":[{},"dst:Nt_regi;",{}]},{"entry":[{},"COST 1;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w72);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s = r%s \u2212",{}]},{"entry":[{},"r%s\\042,3\\n\u201d,REGNAME(dst),REGNAME(src1),REGNAME(src2));",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirAnd_Nt_regi_Nt_regi__Nt_regi_32] o:mirAnd(src1:Nt_regi,src2:Nt_regi) ->",{}]},{"entry":[{},"dst:Nt_regi;",{}]},{"entry":[{},"COST 1;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s =r%s &",{}]},{"entry":[{},"r%s\\042,3\\n\u201d,REGNAME(dst),REGNAME(src1),REGNAME(src2));",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirMult_Nt_regi_Nt_regi__Nt_regi_33] o:mirMult(src1:Nt_regi,src2:Nt_regi) ->",{}]},{"entry":[{},"dst:Nt_regi;",{}]},{"entry":[{},"COST 1;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s = r%s *",{}]},{"entry":[{},"r%s\\042,3\\n\u201d,REGNAME(dst),REGNAME(src1),REGNAME(src2));",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirShiftLeft_Nt_regi_Nt_regi__Nt_regi_34] o:mirShiftLeft(src1:Nt_regi,src2:",{}]},{"entry":[{},"Nt_regi) -> dst:Nt_regi;",{}]},{"entry":[{},"COST 1;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s = r%s <<",{}]},{"entry":[{},"r%s\\042,3\\n\u201d,REGNAME(dst),REGNAME(src1),REGNAME(src2));",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirOr_Nt_regi_Nt_regi__Nt_regi_35] o:mirOr(src1:Nt_regi,src2:Nt_regi) -> dst:Nt_regi;",{}]},{"entry":[{},"COST 1;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s = r%s I",{}]},{"entry":[{},"r%s\\042,3\\n\u201d,REGNAME(dst),REGNAME(src1),REGNAME(src2));",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirShiftRight_Nt_regi_Nt_regi__Nt_regi_36] o:mirShiftRight(src1:Nt_regi,src2:",{}]},{"entry":[{},"Nt_regi) -> dst:Nt_regi;",{}]},{"entry":[{},"COST 1;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s = r%s >>",{}]},{"entry":[{},"r%s\\042,3\\n\u201d,REGNAME(dst),REGNAME(src1),REGNAME(src2));",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirXor_Nt_regi_Nt_regi__Nt_regi_37] o:mirXor(src1:Nt_regi,src2:Nt_regi) ->",{}]},{"entry":[{},"dst:Nt_regi;",{}]},{"entry":[{},"COST 1;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s = r%s {circumflex over (\u2009)}",{}]},{"entry":[{},"r%s\\042,3\\n\u201d,REGNAME(dst),REGNAME(src1),REGNAME(src2));",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirPlus_Nt_regi_Nt_imm12__Nt_regi_38] o:mirPlus(src1:Nt_regi,src2:Nt_imm12) ->",{}]},{"entry":[{},"dst:Nt_regi;",{}]},{"entry":[{},"COST 1;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s = r%s +",{}]},{"entry":[{},"%d\\042,3\\n\u201d,REGNAME(dst),REGNAME(src1),src2.value);",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirAnd_Nt_regi_Nt_imm12__Nt_regi_39] o:mirAnd(src1:Nt_regi,src2:Nt_imm12) ->",{}]},{"entry":[{},"dst:Nt_regi;",{}]},{"entry":[{},"COST 1;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s = r%s &",{}]},{"entry":[{},"%d\\042,3\\n\u201d,REGNAME(dst),REGNAME(src1),src2.value);",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirShiftLeft_Nt_regi_Nt_imm12__Nt_regi_40]",{}]},{"entry":[{},"o:mirShiftLeft(src1:Nt_regi,src2:Nt_imm12) -> dst:Nt_regi;",{}]},{"entry":[{},"COST 1;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s = r%s <<",{}]},{"entry":[{},"%d\\042,3\\n\u201d,REGNAME(dst),REGNAME(src1),src2.value);",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirMult_Nt_regi_Nt_imm12__Nt_regi_41] o:mirMult(src1:Nt_regi,src2:Nt_imm12) ->",{}]},{"entry":[{},"dst:Nt_regi;",{}]},{"entry":[{},"COST 1;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s = r%s *",{}]},{"entry":[{},"%d\\042,3\\n\u201d,REGNAME(dst),REGNAME(src1),src2.value);",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirOr_Nt_regi_Nt_imm12__Nt_regi_42] o:mirOr(src1:Nt_regi,src2:Nt_imm12) ->",{}]},{"entry":[{},"dst:Nt_regi;",{}]},{"entry":[{},"COST 1;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s = r%s I",{}]},{"entry":[{},"%d\\042,3\\n\u201d,REGNAME(dst),REGNAME(src1),src2.value);",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirShiftRight_Nt_regi_Nt_imm12__Nt_regi_43]",{}]},{"entry":[{},"o:mirShiftRight(src1:Nt_regi,src2:Nt_imm12) -> dst:Nt_regi;",{}]},{"entry":[{},"COST 1;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s = r%s >>",{}]},{"entry":[{},"%d\\042,3\\n\u201d,REGNAME(dst),REGNAME(src1),src2.value);",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirDiff_Nt_regi_Nt_imm12__Nt_regi_44] o:mirDiff(src1:Nt_regi,src2:Nt_imm12) ->",{}]},{"entry":[{},"dst:Nt_regi;",{}]},{"entry":[{},"COST 1;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s = r%s \u2212",{}]},{"entry":[{},"%d\\042,3\\n\u201d,REGNAME(dst),REGNAME(src1),src2.value);",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirXor_Nt_regi_Nt_imm12__Nt_regi_45] o:mirXor(src1:Nt_regi,src2:Nt_imm12) ->",{}]},{"entry":[{},"dst:Nt_regi;",{}]},{"entry":[{},"COST 1;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s = r%s {circumflex over (\u2009)}",{}]},{"entry":[{},"%d\\042,3\\n\u201d,REGNAME(dst),REGNAME(src1),src2.value);",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirCompare_Nt_regi_Nt_regi__Nt_regi_46] o:mirCompare(s1:Nt_regi,s2:Nt_regi) ->",{}]},{"entry":[{},"dst:Nt_regi<reg_idx_1, reg_idx_2, reg_idx_3>;",{}]},{"entry":[{},"CONDITION",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003IS_GREATER_EQUAL(o)",{}]},{"entry":[{},"}",{}]},{"entry":[{},"COST 1;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s = ( r%s >= r%s )",{}]},{"entry":[{},"\\042,3\\n\u201d,REGNAME(dst),REGNAME(s1),REGNAME(s2));",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirCompare_Nt_regi_Nt_regi__Nt_regi_47] o:mirCompare(s1:Nt_regi,s2:Nt_regi) ->",{}]},{"entry":[{},"dst:Nt_regi<reg_idx_1, reg_idx_2, reg_idx_3>;",{}]},{"entry":[{},"COST 1;",{}]},{"entry":[{},"CONDITION",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003IS_EQUAL(o)",{}]},{"entry":[{},"}",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s = ( r%s == r%s",{}]},{"entry":[{},")\\042,3\\n\u201d,REGNAME(dst),REGNAME(s1),REGNAME(s2));",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirCompare_Nt_regi_Nt_regi__Nt_regi_48] o:mirCompare(s1:Nt_regi,s2:Nt_regi) ->",{}]},{"entry":[{},"dst:Nt_regi<reg_idx_1, reg_idx_2, reg_idx_3>;",{}]},{"entry":[{},"COST 1;",{}]},{"entry":[{},"CONDITION",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003IS_GREATER(o)",{}]},{"entry":[{},"}",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s = ( r%s > r%s )",{}]},{"entry":[{},"\\042,3\\n\u201d,REGNAME(dst),REGNAME(s1),REGNAME(s2));",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirCompare_Nt_regi_Nt_regi__Nt_regi_49] o:mirCompare(s1:Nt_regi,s2:Nt_regi) ->",{}]},{"entry":[{},"dst:Nt_regi<reg_idx_1, reg_idx_2, reg_idx_3>;",{}]},{"entry":[{},"COST 1;",{}]},{"entry":[{},"CONDITION",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003IS_LESS_EQUAL(o)",{}]},{"entry":[{},"}",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s = ( r%s <= r%s )",{}]},{"entry":[{},"042,3\\n\u201d,REGNAME(dst),REGNAME(s1),REGNAME(s2));",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirCompare_Nt_regi_Nt_regi__Nt_regi_50] o:mirCompare(s1:Nt_regi,s2:Nt_regi) ->",{}]},{"entry":[{},"dst:Nt_regi<reg_idx_1, reg_idx_2, reg_idx_3>;",{}]},{"entry":[{},"COST 1;",{}]},{"entry":[{},"CONDITION",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003IS_LESS(o)",{}]},{"entry":[{},"}",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s = ( r%s < r%s )",{}]},{"entry":[{},"\\042,3\\n\u201d,REGNAME(dst),REGNAME(s1),REGNAME(s2));",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirCompare_Nt_regi_Nt_regi__Nt_regi_51] o:mirCompare(s1:Nt_regi,s2:Nt_regi) ->",{}]},{"entry":[{},"dst:Nt_regi<reg_idx_1, reg_idx_2, reg_idx_3>;",{}]},{"entry":[{},"COST 1;",{}]},{"entry":[{},"CONDITION",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003IS_NOT_EQUAL(o)",{}]},{"entry":[{},"}",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s = ( r%s != r%s )",{}]},{"entry":[{},"\\042,3\\n\u201d,REGNAME(dst),REGNAME(s1),REGNAME(s2));",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirAddrPlus_Nt_regi_Nt_regi__Nt_regi_52] o:mirAddrPlus(s1:Nt_regi,s2:Nt_regi) ->",{}]},{"entry":[{},"d:Nt_regi;",{}]},{"entry":[{},"COST 1;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r% s = r%s +",{}]},{"entry":[{},"r%s\\042,3\\n\u201d,REGNAME(d),REGNAME(s1),REGNAME(s2));",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirAddrDiff_Nt_regi_Nt_regi__Nt_regi_53] mirAddrDiff(s1:Nt_regi,s2:Nt_regi) ->",{}]},{"entry":[{},"d:Nt_regi;",{}]},{"entry":[{},"COST 1;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s = r% \u2212",{}]},{"entry":[{},"r%s\\042,3\\n\u201d,REGNAME(d),REGNAME(s1),REGNAME(s2));",{}]},{"entry":[{},"}",{}]},{"entry":[{},"\u2003\u00a9\u20092003, Coware, Inc."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The code in table IV is exemplary code for calling IR nodes that is generated in accordance with an embodiment of the present invention. A user may input information that is useable to generate such exemplary code through, for example, the calling tab  of the mapping dialog . The calling nodes related to function calls: mirCall (call to void function), xirFuncCall (call to function returning a value), mirReturn (return statement), and mirActual (function arguments).",{"@attributes":{"id":"p-0142","num":"0152"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"280pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"7pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE IV"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"RULE [mirCall_Nt_regi_8] o:mirCall(addr:Nt_regi, INPUT {gcg_reg_restriction =",{}]},{"entry":[{},"gcg_RegToRegSet(\u2032gcg_expr->Reg),\u2032gcg_expr->Nt });",{}]},{"entry":[{},"CHANGE { get_changed_set(mirSTMT_mirCall_get_Proc(o)) }",{}]},{"entry":[{},"WRITE MEMORY;",{}]},{"entry":[{},"READ MEMORY;",{}]},{"entry":[{},"CONTROL branch;",{}]},{"entry":[{},"COST 20;",{}]},{"entry":[{},"SCRATCH scratch_0:Nt_regi;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);FPC:(w,0);EPC:(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042 \u2003r%s =",{}]},{"entry":[{},"(($+6)>>16)\\042,3\\n\u201d,REGNAME(scratch_0));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s <<= 16\\042,3\\n\u201d,REGNAME(scratch_0));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s I=",{}]},{"entry":[{},"(($+4)&65535)\\042,3\\n\u201d,REGNAME(scratch_0));",{}]},{"entry":[{},"\u2003fprinff(OUTFILE,\u201c\\t.packs \\042decode;P1;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src1:(r,0);R:(r,0);dc_src2:(r,0);R[%s]:(r,0);FPC:(w,0);dc_src1:",{}]},{"entry":[{},"(w,0);dc_src2:(w,0);EPC:(w,1);data_mem:(w,1);\\042,2\\n\u201d,REGNAME(Regreg_idx_13));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003dmem[ r%s + (\u22121) ] =",{}]},{"entry":[{},"r%s\\042,3\\n\u201d,REGNAME(Regreg_idx_13),REGNAME(Regreg_idx_14));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P1;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src1:(r,0);R:(r,0);dc_src2:(r,0);R[%s]:(r,0);FPC:(w,0);dc_src1:",{}]},{"entry":[{},"(w,0);dc_src2:(w,0);EPC:(w,1);data_mem:(w,1);\\042,2\\n\u201d,REGNAME(Regreg_idx_13));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003dmem[ r%s + (\u22121) ] =",{}]},{"entry":[{},"r%s\\042,3\\n\u201d,REGNAME(Regreg_idx_13),REGNAME(scratch_0));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);R[%s]:(r,0);dc_address:(r,0);FPC:(w,0);dc_address:(w,0);EPC:",{}]},{"entry":[{},"(w,1);\\042,2\\n\u201d,REGNAME(addr));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003jmp r%s\\042,3\\n\u201d,REGNAME(addr));",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [xirFuncCall_mirObjectAddr__Nt_regi_9] o:xirFuncCall(p:mirObjectAddr, INPUT {",{}]},{"entry":[{},"gcg_reg_restriction = gcg_RegToRegSet(\u2032gcg_expr->Reg),\u2032gcg_expr->Nt } )->Nt_regi",{}]},{"entry":[{},"RESTRICT {gcg_RegToRegSet(get_result_reg(mirEXPR_xirFuncCall_get_Proc(o)))};",{}]},{"entry":[{},"CHANGE { get_changed_set(p) }",{}]},{"entry":[{},"CONDITION { get_result_nt(p) == ntNt_regi}",{}]},{"entry":[{},"WRITE MEMORY;",{}]},{"entry":[{},"READ MEMORY;",{}]},{"entry":[{},"CONTROL branch;",{}]},{"entry":[{},"COST 20;",{}]},{"entry":[{},"SCRATCH scratch_0:Nt_regi;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);FPC:(w,0);EPC:(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s =",{}]},{"entry":[{},"(($+6)>>16)\\042,3\\n\u201d,REGNAME(scratch_0));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s <<= 16\\042,3\\n\u201d,REGNAME(scratch_0));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s I=",{}]},{"entry":[{},"(($+4)&65535)\\042,3\\n\u201d,REGNAME(scratch_0));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P1;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src1:(r,0);R:(r,0);dc_src2:(r,0);R[%s]:(r,0);FPC:(w,0);dc_src1:",{}]},{"entry":[{},"(w,0);dc_src2:(w,0);EPC:(w,1);data_mem:(w,1);\\042,2\\n\u201d,REGNAME(Regreg_idx_13));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003dmem[ r%s + (\u22121) ] =",{}]},{"entry":[{},"r%s\\042,3\\n\u201d,REGNAME(Regreg_idx_13),REGNAME(Regreg_idx_14));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P1;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src1:(r,0);R:(r,0);dc_src2:(r,0);R[%s]:(r,0);FPC:(w,0);dc_src1:",{}]},{"entry":[{},"(w,0);dc_src2:(w,0);EPC:(w,1);data_mem:(w,1);\\042,2\\n\u201d,REGNAME(Regreg_idx_13));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003dmem[ r%s + (\u22121) ] =",{}]},{"entry":[{},"r%s\\042,3\\n\u201d,REGNAME(Regreg_idx_13),REGNAME(scratch_0));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_address:(r,0);FPC:(w,0);dc_address:(w,0);EPC:",{}]},{"entry":[{},"(w,1);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003jmp %s\\042,3\\n\u201d,GET_GLOBAL_LABEL(p.Obj));",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirCall_mirObjectAddr_10] o:mirCall(p:mirObjectAddr, INPUT { gcg_reg_restriction =",{}]},{"entry":[{},"gcg_RegToRegSet(\u2032gcg_expr->Reg),\u2032gcg_expr->Nt } );",{}]},{"entry":[{},"CHANGE { get_changed_set(p) }",{}]},{"entry":[{},"WRITE MEMORY;",{}]},{"entry":[{},"READ MEMORY;",{}]},{"entry":[{},"CONTROL branch;",{}]},{"entry":[{},"COST 20;",{}]},{"entry":[{},"SCRATCH scratch_0:Nt_regi;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);FPC:(w,0);EPC:(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s =",{}]},{"entry":[{},"(($+6)>>16)\\042,3\\n\u201d,REGNAME(scratch_0));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s <<= 16\\042,3\\n\u201d,REGNAME(scratch_0));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s I=",{}]},{"entry":[{},"(($+4)&65535)\\042,3\\n\u201d,REGNAME(scratch_0)); ",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P1;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src1:(r,0);R:(r,0);dc_src2:(r,0);R[%s]:(r,0);FPC:(w,0);dc_src1:",{}]},{"entry":[{},"(w,0);dc_src2:(w,0);EPC:(w,1);data_mem:(w,1);\\042,2\\n\u201d,REGNAME(Regreg_idx_13));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003dmem[ r%s + (\u22121) ] =",{}]},{"entry":[{},"r%s\\042,3\\n\u201d,REGNAME(Regreg_idx_13),REGNAME(Regreg_idx_14));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P1;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src1:(r,0);R:(r,0);dc_src2:(r,0);R[%s]:(r,0);FPC:(w,0);dc_src1:",{}]},{"entry":[{},"(w,0);dc_src2:(w,0);EPC:(w,1);data_mem:(w,1);\\042,2\\n\u201d,REGNAME(Regreg_idx_13));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003dmem[ r%s + (\u22121) ] =",{}]},{"entry":[{},"r%s\\042,3\\n\u201d,REGNAME(Regreg_idx_13),REGNAME(scratch_0));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_address:(r,0);FPC:(w,0);dc_address:(w,0);EPC:(w,1);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003jmp %s\\042,3\\n\u201d,GET_GLOBAL_LABEL(p.Obj));",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [xirFuncCall_Nt_regi__Nt_regi_11] o:xirFuncCall(p:Nt_regi, INPUT ",{}]},{"entry":[{},"{ gcg_reg_restriction =",{}]},{"entry":[{},"gcg_RegToRegSet(\u2032gcg_expr->Reg), \u2032gcg_expr->Nt })->Nt_regi_RESTRICT",{}]},{"entry":[{},"{gcg_RegToRegSet(get_result_reg(mirEXPR_xirFuncCall_get_Proc(o)))};",{}]},{"entry":[{},"CHANGE { get_changed_set(mirEXPR_xirFuncCall_get_Proc(o)) }",{}]},{"entry":[{},"CONDITION { get_result_nt(mirEXPR_xirFuncCall_get_Proc(o)) == ntNt_regi}",{}]},{"entry":[{},"WRITE MEMORY;",{}]},{"entry":[{},"READ MEMORY;",{}]},{"entry":[{},"CONTROL branch;",{}]},{"entry":[{},"COST 20;",{}]},{"entry":[{},"SCRATCH scratch_0:Nt_regi;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);FPC:(w,0);EPC:(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003 r%s = ",{}]},{"entry":[{},"(($+6)>>16)\\042,3\\n\u201d,REGNAME(scratch_0));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s <<= 16\\042,3\\n\u201d,REGNAME(scratch_0));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode ;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s I=",{}]},{"entry":[{},"(($+4)&65535)\\042,3\\n\u201d,REGNAME(scratch_0));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P1;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src1:(r,0);R:(r,0);dc_src2:(r,0);R[%s]:(r,0);FPC:(w,0);dc_src1:",{}]},{"entry":[{},"(w,0);dc_src2:(w,0);EPC:(w,1);data_mem:(w,1);\\042,2\\n\u201d,REGNAME(Regreg_idx_13));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003dmem[ r%s + (\u22121) ] =",{}]},{"entry":[{},"r%s\\042,3\\n\u201c,REGNAME(Regreg_idx_13),REGNAME(Regreg_idx_14));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P1;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src1:(r,0);R:(r,0);dc_src2:(r,0);R[%s]:(r,0);FPC:(w,0);dc_src1:",{}]},{"entry":[{},"(w,0);dc_src2:(w,0);EPC:(w,1);data_mem:(w,1);\\042,2\\n\u201d,REGNAME(Regreg_idx_13));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003dmem[ r%s + (\u22121) ] =",{}]},{"entry":[{},"r%s\\042,3\\n\u201d,REGNAME(Regreg_idx_13),REGNAME(scratch_0));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);R[%s]:(r,0);dc_address:(r,0);FPC:(w,0);dc_address:(w,0);EPC:",{}]},{"entry":[{},"(w,1);\\042,2\\n\u201d,REGNAME(p));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003jmp r%s\\042,3\\n\u201d,REGNAME(p));",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirReturn_mirNoExpr_mirObjectAddr_12] o:mirReturn(mirNoExpr,n:mirObjectAddr);",{}]},{"entry":[{},"CONDITION",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003o.NextIsNext",{}]},{"entry":[{},"}",{}]},{"entry":[{},"CONTROL fallthrough;",{}]},{"entry":[{},"COST 0;",{}]},{"entry":[{},"RULE [mirReturn_mirNoExpr_mirObjectAddr_13] o:mirReturn(mirNoExpr,n:mirObjectAddr);",{}]},{"entry":[{},"COST 2;",{}]},{"entry":[{},"CONTROL branch;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_address:(r,0);FPC:(w,0);dc_address:(w,0);EPC:",{}]},{"entry":[{},"(w,1);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003jmp %s\\042,3\\n\u201d,GET_BBLOCK_LABEL(n.Obj));",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirActual_Nt_regi__memarglist_14] o:mirActual(rs:Nt_regi) -> a:memarglist;",{}]},{"entry":[{},"COST 1;",{}]},{"entry":[{},"CONDITION",{}]},{"entry":[{},"{",{}]},{"entry":[{},"o.Nt == ntmemarglist",{}]},{"entry":[{},"}",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P1;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src1:(r,0);R:(r,0);dc_src2:(r,0);R[%s]:(r,0);FPC:(w,0);dc_src1:",{}]},{"entry":[{},"(w,0);dc_src2:(w,0);EPC:(w,1);data_mem:(w,1);\\042,2\\n\u201d,REGNAME(Regreg_idx_13));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003dmem[ r%s + %d ] =",{}]},{"entry":[{},"r%s\\042,3\\n\u201d,REGNAME(Regreg_idx_13),OUTARG_OFFSET(o.Offset),REGNAME(rs));",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirReturn_mirNoExpr_mirObjectAddr_15] o:mirReturn(mirNoExpr,t:mirObjectAddr);",{}]},{"entry":[{},"COST 1;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_address:(r,0);FPC:(w,0);dc_address:(w,0);EPC:",{}]},{"entry":[{},"(w,1);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201d\\t.packs \\042\u2003jmp %s\\042,3\\n\u201d,GET_BBLOCK_LABEL(t.Obj));",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirReturn_Nt_regi_mirObjectAddr_16]",{}]},{"entry":[{},"o:mirReturn(ret:Nt_regi<reg_idx_15>t:mirObjectAddr);",{}]},{"entry":[{},"COST 1;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_address:(r,0);FPC:(w,0);dc_address:(w,0);EPC:",{}]},{"entry":[{},"(w,1);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003jmp %s\\042,3\\n\u201d,GET_BBLOCK_LABEL(t.Obj));",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE o:xirReg -> Nt_regi_RESTRICT { gcg_RegToRegSet(o.Reg) };",{}]},{"entry":[{},"CLASS NOCODE;",{}]},{"entry":[{},"CONDITION { o.Nt == ntNt_regi }",{}]},{"entry":[{},"RULE a:mirActual(rs:Nt_regi) -> rd :Nt_regi;",{}]},{"entry":[{},"RESULT rs;",{}]},{"entry":[{},"RULE [prologue] mirBeginProcedure;",{}]},{"entry":[{},"BARRIER;",{}]},{"entry":[{},"EMIT {",{}]},{"entry":[{},"\u2003gcgRegister Reg;",{}]},{"entry":[{},"\u2003char *proc_name;",{}]},{"entry":[{},"\u2003proc_name = mirProcGlobal_get_Name(state->proc);",{}]},{"entry":[{},"\u2003if ( !strcmp (proc_name, \u201c_main\u201d)) {",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);FPC:(w,0);EPC:(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s =",{}]},{"entry":[{},"_stackbase\\042,3\\n\u201d,REGNAME(Regreg_idx_13));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s = r%s +",{}]},{"entry":[{},"0\\042,3\\n\u201d,REGNAME(Regreg_idx_14),REGNAME(Regreg_idx_13));",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"\u2003if (state->frame_size !=0) {",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s = r%s \u2212",{}]},{"entry":[{},"%d\\042,3\\n\u201c,REGNAME(Regreg_idx_13),REGNAME(Regreg_idx_13),(state->frame_size));",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"\u2003gcg_RegSetLoop(state->tobesaved, Reg)",{}]},{"entry":[{},"\u2003{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P1;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src1:(r,0);R:(r,0);dc_src2:(r,0);R[%s]:(r,0);FPC:(w,0);dc_src1:",{}]},{"entry":[{},"(w,0);dc_src2:(w,0);EPC:(w,1);data_mem:(w,1);\\042,2\\n\u201d,REGNAME(Regreg_idx_14));",{}]},{"entry":[{},"\u2003\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003dmem[ r%s + (%d) ] =",{}]},{"entry":[{},"r%s\\042,3\\n\u201d,REGNAME(Regreg_idx_14),(state->offsets[Reg] + state->",{}]},{"entry":[{},"regsave_frame_base),REGNAME(Reg));",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"\u2003gcg_RegSetEndLoop",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [epilogue] mirEndProcedure;",{}]},{"entry":[{},"BARRIER;",{}]},{"entry":[{},"EMIT {",{}]},{"entry":[{},"\u2003gcgRegister Reg;",{}]},{"entry":[{},"\u2003char *proc_name;",{}]},{"entry":[{},"\u2003proc_name = mirProcGlobal_get_Name(state->proc);",{}]},{"entry":[{},"\u2003gcg_RegSetLoop(state->tobesaved, Reg)",{}]},{"entry":[{},"\u2003{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P1;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);R[%s]:(r,0);FPC:(w,0);data_mem:(r,1);EPC:(w,1);R:(w,2);\\04",{}]},{"entry":[{},"2,2\\n\u201d,REGNAME(Regreg_idx_14));",{}]},{"entry":[{},"\u2003\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s = dmem[ r%s + (%d) ]",{}]},{"entry":[{},"\\042,3\\n\u201d,REGNAME(Reg),REGNAME(Regreg_idx_14), (state->offsets[Reg] + state->",{}]},{"entry":[{},"regsave_frame_base));",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"\u2003gcg_RegSetEnd Loop",{}]},{"entry":[{},"\u2003if(!strcmp(proc_name,\u201c_main\u201d))",{}]},{"entry":[{},"\u2003{",{}]},{"entry":[{},"\u2003\u2003fprintf(OUTFILE,\u201cLLABEL_END:\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_address:(r,0);FPC:(w,0);dc_address:(w,0);EPC:(w,1);\\",{}]},{"entry":[{},"042,2\\n\u201d);",{}]},{"entry":[{},"\u2003\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003jmp %s\\042,3\\n\u201d,\u201cLLABEL_END\u201d);",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"\u2003else",{}]},{"entry":[{},"\u2003{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s = r%s +",{}]},{"entry":[{},"0\\042,3\\n\u201c,REGNAME(Regreg_idx_14),REGNAME(Regreg_idx_13));",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"};",{}]},{"entry":[{},"\u2003\u00a9\u20092003, Coware, Inc."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The code in table V is exemplary code for control IR nodes that is generated in accordance with an embodiment of the present invention. A user may input information that is useable to generate such exemplary code through, for example, the control tab  of the mapping dialog . The control nodes are related to nodes such as mirIf and mirGoto.",{"@attributes":{"id":"p-0144","num":"0154"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"7pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE V"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"RULE [mirlf_Nt_regi_mirObjectAddr_mirObjectAddr_28] ",{}]},{"entry":[{},"o:mirlf(c:Nt_regi<reg_idx_1, reg_idx_2, reg_idx_3>,",{}]},{"entry":[{},"t:mirObjectAddr,e:mirObjectAddr);",{}]},{"entry":[{},"COST 2;",{}]},{"entry":[{},"CONTROL branch;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_address:(r,0);dc_cond_reg:(r,0);",{}]},{"entry":[{},"R:(r,0);dc_cond_value:(r,0)",{}]},{"entry":[{},";FPC:(w,0);dc_address:(w,0);dc_cond_reg:(w,0);dc_cond_value:(w,0);",{}]},{"entry":[{},"EPC:(w,1);\\042,2\\n\u201d)",{}]},{"entry":[{},";",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042if (r%s) jmp",{}]},{"entry":[{},"%s\\042,3\\n\u201d,REGNAME(c),GET_BBLOCK_LABEL(t.Obj));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_address:(r,0);FPC:(w,0);",{}]},{"entry":[{},"dc_address:(w,0);EPC:(w,1);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042 jmp %s\\042,3\\n\u201d,GET_BBLOCK_",{}]},{"entry":[{},"LABEL(e.Obj));",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirGoto_mirObjectAddr_29] o:mirGoto(d:mirObjectAddr);",{}]},{"entry":[{},"COST 1;",{}]},{"entry":[{},"CONTROL fallthrough;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_address:(r,0);FPC:(w,0);",{}]},{"entry":[{},"dc_address:(w,0);EPC:(w,1);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042 jmp %s\\042,3\\n\u201d,GET_",{}]},{"entry":[{},"\u2003GLOBAL_LABEL(d.Obj));",{}]},{"entry":[{},"}",{}]},{"entry":[{},"\u2003\u00a9\u20092003, Coware, Inc."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The exemplary code in table VI is exemplary code for convert IR nodes that is generated in accordance with an embodiment of the present invention. A user may input information that is useable to generate such exemplary code through, for example, the convert tab  of the mapping dialog . Convert type casts are performed with mirConvert nodes.",{"@attributes":{"id":"p-0146","num":"0156"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"210pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"0pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE VI"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"RULE [mirConvert_Nt_addr__Nt_addr_26] o:mirConvert",{}]},{"entry":[{},"(s:Nt_addr) -> d:Nt_addr;",{}]},{"entry":[{},"CONDITION",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003IS_POINTER(o)",{}]},{"entry":[{},"}",{}]},{"entry":[{},"COST 0;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003d.base = s.base;",{}]},{"entry":[{},"\u2003d.imm8 = s.imm8;",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirConvert_Nt_regi__Nt_regi_27] mirConvert(rs:Nt_regi) -> rd:",{}]},{"entry":[{},"Nt_regi;",{}]},{"entry":[{},"RESULT rs;",{}]},{"entry":[{},"COST 0;",{}]},{"entry":[{},"\u2003\u00a9\u20092003, Coware, Inc."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The exemplary code in table VII is exemplary code for load\/store IR nodes that is generated in accordance with an embodiment of the present invention. A user may input information that is useable to generate such exemplary code through, for example, the load\/store tab  of the mapping dialog . Load\/Store IR nodes covered comprises: mirintConst, mirNil, mirObjectAddr, mirContent, and mirAssign.",{"@attributes":{"id":"p-0148","num":"0158"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"273pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"7pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE VII"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"RULE [mirEvaluate__Nt_regi] mirEvaluate(Nt_regi);",{}]},{"entry":[{},"RULE [mirEvaluate__memarglist] mirEvaluate(memarglist);",{}]},{"entry":[{},"RULE [mirIntConst__Nt_regi_0] o:mirIntConst -> dst:Nt_regi;",{}]},{"entry":[{},"SCRATCH scratch_0:Nt_regi;",{}]},{"entry":[{},"COST 4;",{}]},{"entry":[{},"INTERFERE ( dst , scratch_0 );",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);FPC:(w,0);EPC:(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042 \u2003r%s =",{}]},{"entry":[{},"%d\\042,3\\n\u201d,REGNAME(dst),UnivInt_to_int(o.Value));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042 \u2003r%s <<= 16\\042,3\\n\u201d,REGNAME(dst));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);FPC:(w,0);EPC:(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042 \u2003r%s =",{}]},{"entry":[{},"%d\\042,3\\n\u201d,REGNAME(scratch_0),UnivInt_to_int(o.Value));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042 \u2003r%s I=",{}]},{"entry":[{},"r%s\\042,3\\n\u201d,REGNAME(dst),REGNAME(scratch_0));",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirContent_Nt_addr__Nt_regi_1] o:mirContent(src:Nt_addr) -> dst:Nt_regi;",{}]},{"entry":[{},"COST 1;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P1;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);R[%s]:(r,0);FPC:(w,0);data_mem:(r,1);EPC:(w,1);R:",{}]},{"entry":[{},"(w,2);\\042,2\\n\u201d,REGNAME(src.base));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042 \u2003r%s = dmem[ r%s + %d ]",{}]},{"entry":[{},"\\042,3\\n\u201d,REGNAME(dst),REGNAME(src.base),src.imm8);",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirAddrConst__Nt_regi_2] o:mirAddrConst -> d:Nt_regi;",{}]},{"entry":[{},"SCRATCH scratch_0:Nt_regi;",{}]},{"entry":[{},"COST 4;",{}]},{"entry":[{},"INTERFERE ( d , scratch_0 );",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);FPC:(w,0);EPC:(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042 \u2003r%s =",{}]},{"entry":[{},"%d\\042,3\\n\u201d,REGNAME(d),UnivInt_to_int(o.Value));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042 \u2003r%s <<= 16\\042,3\\n\u201d,REGNAME(d));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);FPC:(w,0);EPC:(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042 \u2003r%s =",{}]},{"entry":[{},"%d\\042,3\\n\u201d,REGNAME(d),UnivInt_to_int(o.Value));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042 \u2003r%s I=",{}]},{"entry":[{},"r%s\\042,3\\n\u201d,REGNAME(d),REGNAME(scratch_0));",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirIntConst__Nt_imm12_3] o:mirIntConst -> d:Nt_imm12;",{}]},{"entry":[{},"COST 0;",{}]},{"entry":[{},"CONDITION",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003IS_SIMMX(o.Value, 12)",{}]},{"entry":[{},"}",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003d.value = UnivInt_to_int(o.Value);",{}]},{"entry":[{},"}RULE [mirIntConst__Nt_imm16_4] o:mirIntConst -> d:Nt_imm16;",{}]},{"entry":[{},"COST 0;",{}]},{"entry":[{},"CONDITION",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003IS_SIMMX(o.Value, 16)",{}]},{"entry":[{},"}",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003d.value = UnivInt_to_int(o.Value);",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirAssign_Nt_addr_Nt_regi_5] o:mirAssign(addr:Nt_addr,d:Nt_regi);",{}]},{"entry":[{},"COST 1;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P1;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src1:(r,0);R:(r,0);dc_src2:(r,0);R[%s]:(r,0);FPC:(w,0);dc_src1:",{}]},{"entry":[{},"(w,0);dc_src2:(w,0);EPC:(w,1);data_mem:(w,1);\\042,2\\n\u201d,REGNAME(addr.base));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042 \u2003dmem[ r%s + %d ] =",{}]},{"entry":[{},"r%s\\042,3\\n\u201d,REGNAME(addr.base),addr.imm8,REGNAME(d));",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirAssign_Nt_regi_Nt_regi_6] o:mirAssign(d:Nt_regi,s:Nt_regi);",{}]},{"entry":[{},"CONDITION",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003IS_POINTER(o)",{}]},{"entry":[{},"}",{}]},{"entry":[{},"COST 1;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P1;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src1:(r,0);R:(r,0);dc_src2:(r,0);R[%s]:(r,0);FPC:(w,0);dc_src1:",{}]},{"entry":[{},"(w,0);dc_src2:(w,0);EPC:(w,1);data_mem:(w,1);\\042,2\\n\u201d,REGNAME(d));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042 \u2003dmem[ r%s + 0] =",{}]},{"entry":[{},"r%s\\042,3\\n\u201d,REGNAME(d),REGNAME(s));",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirObjectAddr__Nt_regi_7] o:mirObjectAddr -> d:Nt_regi;",{}]},{"entry":[{},"SCRATCH scratch_0:Nt_regi;",{}]},{"entry":[{},"COST 4;",{}]},{"entry":[{},"INTERFERE ( d , scratch_0 );",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201ct.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);FPC:(w,0);EPC:(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201ct.packs \\042\u2003 r%s =",{}]},{"entry":[{},"%s\\042,3\\n\u201d,REGNAME(d),GET_GLOBAL_LABEL(o.Obj));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042 \u2003r%s <<= 16\\042,3\\n\u201d,REGNAME(d));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);FPC:(w,0);EPC:(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201ct.packs \\042 \u2003r%s =",{}]},{"entry":[{},"%s\\042,3\\n\u201d,REGNAME(scratch_0),GET_GLOBAL_LABEL(o.Obj));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTF1LE,\u201c\\t.packs \\042\u2003 r%s I=",{}]},{"entry":[{},"r%s\\042,3\\n\u201d,REGNAME(d),REGNAME(scratch_0));",{}]},{"entry":[{},"}",{}]},{"entry":[{},"\u2003\u00a9\u20092003, Coware, Inc."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The exemplary code in table IX is exemplary code for specifying how to convert from one non-terminal to another that is generated in accordance with an embodiment of the present invention. A user may input information that is useable to generate such exemplary code through, for example, the move tab  of the mapping dialog . Besides specifying how to convert one non-terminal into another, the rules for \u201cmove\u201d cover the IR nodes mirObjectAddr and mirNil.",{"@attributes":{"id":"p-0150","num":"0160"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"266pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"7pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE IX"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"RULE [Nt_regi__Nt_addr_19] o:Nt_regi -> d:Nt_addr;",{}]},{"entry":[{},"COST 0;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003d.base = o;",{}]},{"entry":[{},"\u2003d.imm8 = 0;",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [Nt_addr__Nt_regi_20] o:Nt_addr -> d:Nt_regi;",{}]},{"entry":[{},"COST 1;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201c);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s = r%s +",{}]},{"entry":[{},"%d\\042,3\\n\u201d,REGNAME(d),REGNAME(o.base),o.imm8);",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [Nt_regi__Nt_regi_21] o:Nt_regi -> d:Nt_regi;",{}]},{"entry":[{},"COST 1;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src2:(r,0);dc_src1:(r,0);R:(r,0);FPC:(w,0);dc_src1:(w,0);dc_",{}]},{"entry":[{},"src2:(w,0);alu_operand1:(r,1);alu_operand2:(r,1);EPC:(w,1);alu_operand1:(w,1);alu_operand2:",{}]},{"entry":[{},"(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s = r%s +",{}]},{"entry":[{},"0\\042,3\\n\u201d,REGNAME(d),REGNAME(o));",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirNil__Nt_regi_22] o:mirNil -> d:Nt_regi;",{}]},{"entry":[{},"COST 1;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);FPC:(w,0);EPC:(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s = 0\\042,3\\n\u201d,REGNAME(d));",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirObjectAddr__Nt_addr_23] o:mirObjectAddr -> addr:Nt_addr;",{}]},{"entry":[{},"CONDITION",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003IS_LOCAL(o.Obj)",{}]},{"entry":[{},"}",{}]},{"entry":[{},"COST 0;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003addr.base = Regreg_idx_13;",{}]},{"entry":[{},"\u2003addr.imm8 = LOCAL_OFFSET(o.Obj);",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [mirObjectAddr__Nt_addr_24] o:mirObjectAddr -> d:Nt_addr;",{}]},{"entry":[{},"CONDITION",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003IS_PARAM(o.Obj)",{}]},{"entry":[{},"}",{}]},{"entry":[{},"COST 0;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003d.base = Regreg_idx_14;",{}]},{"entry":[{},"\u2003d.imm8 = PARAM_OFFSET(o.Obj);",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [Nt_imm12__Nt_regi_25] s:Nt_imm12 -> d:Nt_regi;",{}]},{"entry":[{},"COST 1;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P2;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);FPC:(w,0);EPC:(w,1);R:(w,2);\\042,2\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003r%s = %d\\042,3\\n\u201d,REGNAME(d),s.value);",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [usepsr_Nt_regi] c:mirContent (mirObjectAddr) -> Nt_regi TEMPO;",{}]},{"entry":[{},"CONDITION {",{}]},{"entry":[{},"\u2003(c.Nt == ntNt_regi) && (c.psr > 0)",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [defpsr_Nt_regi] a:mirAssign (mirObjectAddr,Nt_regi TEMPO);",{}]},{"entry":[{},"CONDITION {",{}]},{"entry":[{},"\u2003(a.Nt == ntNt_regi) && (a.psr > 0)",{}]},{"entry":[{},"}",{}]},{"entry":[{},"\u2003\u00a9\u20092003, Coware, Inc."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The exemplary code in table X is exemplary code for specifying spill rules that are generated in accordance with an embodiment of the present invention. A user may input information that is useable to generate such exemplary code through, for example, the spill tab  of the mapping dialog . The spill rules determine how to load\/store the contents of non-terminals from\/to the special spill memory location.",{"@attributes":{"id":"p-0152","num":"0162"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"273pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"7pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE X"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"RULE [Nt_regi__Spill_17] o:Nt_regi -> d:Spill;",{}]},{"entry":[{},"COST 1;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201ct.packs \\042decode;P1;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);dc_src1:(r,0);R:(r,0);dc_src2:(r,0);R[%s]:(r,0);FPC:(w,0);dc_src1:",{}]},{"entry":[{},"(w,0);dc_src2:(w,0);EPC:(w,1);data_mem:(w,1);\\042,2\\n\u201d,REGNAME(Regreg_idx_14));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042\u2003dmem[ r%s + %d ] =",{}]},{"entry":[{},"r%s\\042,3\\n\u201d,REGNAME(Regreg_idx_14),SPILL_OFFSET(d),REGNAME(o));",{}]},{"entry":[{},"}",{}]},{"entry":[{},"RULE [Spill__Nt_regi_18] o:Spill -> d:Nt_regi;",{}]},{"entry":[{},"COST 1;",{}]},{"entry":[{},"EMIT",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs \\042decode;P1;C1;decode;\\042,1\\n\u201d);",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201c\\t.packs",{}]},{"entry":[{},"\\042FPC:(r,0);prog_mem:(r,0);R[%s]:(r,0);FPC:(w,0);data_mem:(r,1);EPC:(w,1);R:",{}]},{"entry":[{},"(w,2);\\042,2\\n\u201d,REGNAME(Regreg_idx_14));",{}]},{"entry":[{},"\u2003fprintf(OUTFILE,\u201ct.packs \\042\u2003r%s = dmem[ r%s + %d ]",{}]},{"entry":[{},"\\042,3\\n\u201d,REGNAME(d),REGNAME(Regreg_idx_14),SPILL_OFFSET(o));",{}]},{"entry":[{},"}",{}]},{"entry":[{},"\u2003\u00a9\u20092003, Coware, Inc."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The dialog  of  also has an \u201cextra\u201d tab . Clicking on the extra tab  bring up a text editor that allows the inclusion of code generator description syntax.","Each mapping is specified in the instruction mapping dialog  depicted in , in accordance with an embodiment of the present invention. The IR nodes are listed in IR element box . The non-terminal box  contains the non-terminals appearing in the non-terminals dialog of . With a drag and drop technique, the elements in boxes  and  can be used to construct the pattern of the mapping rule in pattern box . An error message is displayed if a drop was not accepted. Additionally, valid drops are confirmed.","The pattern box  of  illustrates an exemplary mirCompare node with two incoming non-terminals (Nt_i32) of register kind and a result non-terminal (Nt_cc) of unique kind that has an attribute (par). The incoming non-terminals could be produced by some other rules, e.g., a rule that loads a variable into a register.","The next step in creating a mapping is to give names to the nodes and non-terminals that are used in the pattern. (The nodes \u201co\u201d, \u201cs\u201d, \u201cs\u201d, and \u201cd\u201d are listed in the pattern box ). For all operands and the result non-terminal, the user specifies a name; otherwise, the rule will not be accepted when the Ok button  is pressed. It is also possible to assign values, expressions, or registers to the attributes of the result non-terminal.","If the user clicks on a result non-terminal register attribute, as it is used for a register-offset addressing mode non-terminal, a register selector pops up to specify the assigned register. Clicking an integer attribute opens an editor in which the user can enter arithmetic expressions. The user can also drop compatible source IR nodes\/attributes of the rule on the result non-terminal attributes. This is only allowed if a name was specified for the root node of the attribute.","In this example, the zero beside the par attribute in the pattern box  indicates that the instruction selector will write a zero into the non-terminal attribute if it uses this mapping rule. There are other mapping rules that consume the Nt_cc non-terminal. One of them is a rule that covers the mirNot IR node. It also produces an Nt_cc, but inverts the bits of the par attribute. Two other rules that consume a Nt_cc are the rules used to cover the mirIf IR node. The rules contain conditions that check if the par attribute is zero or not and issue a conditional jump that branches on true or on false condition.","Furthermore, by clicking on an arbitrary register non-terminal of the rule, the user can limit the register set of this non-terminal to a certain set. This might be used if the user desires to map instructions with restricted input registers to the rule. In case the result register is equal to one of the operand registers, the user can express this by choosing the same name for the result register non-terminal and the source non-terminal. The register allocator will then use the same physical register for both operands.","The instruction box  allows a mapping of the pattern to assembly instructions. Generally, the pattern from the pattern box  needs to be mapped to zero or more assembly instructions. Some rules do not need to be mapped. For example, rules producing addressing mode non-terminals are not mapped to assembly instructions. Buttons  near the instruction box  facilitate the mapping.","By clicking into the tree in the instruction box , the sons of LISA GROUPs can be selected. This selection is done for all groups that are part of the instruction. LISA LABELS are also part of the declaration tree. They are used to link the pattern with the instruction. By dragging the names or the attributes of the IR pattern into the LISA LABELS, a link is established. For all valid nodes except register attributes\/attributes an editor appears, where the user can specify an additional arithmetic expression to modify the dropped value. It is also possible to edit the LABELS directly by double clicking them. In case of a register label, a register selector will pop up; otherwise, a normal editor will appear.","The assembly syntax of the instruction is depicted in the assembly syntax area  and is updated every time the declaration tree is modified. It is possible to have multi-instruction rules.","It is quite common that additional information needs to be assigned to the grammar rule. For example, the mirCompare node usually requires a condition that tests what type of comparison needs to be performed (a<b, a<=b, a==b, a !=b, a>=b, or a>b). By pressing the extended tab , such information can be specified in the mapping clauses dialog  as illustrated in , in accordance with an embodiment of the present invention.",{"@attributes":{"id":"p-0164","num":"0174"},"figref":["FIG. 7M","FIG. 7N","FIG. 7N"],"b":["830","830","832","834","832","834","840","842","844"]},"A brief explanation of the rule clauses is presented below. A more detailed explanation of the rule clauses is provided in ACE Associated Compiler Experts by. BEG-CoSy\u00ae Manual, May 2003. CoSy\u00ae System Documentation.","BARRIER: Using this clause will introduce additional dependencies before (PREBARRIER) or behind the rule (POSTBARRIER). BARRIER adds both. This can be selected in the drop down menu in the parameter column. The scheduler generally will not move instructions across these barriers.","CALC: Main purpose is to calculate and assign values to the fields of compiler IR nodes.","CHANGE: This clause specifies which register beside the result register is modified by the rule.","CLOBBER: Indicates that the rule changes the value of the indicated operand, which can be selected in the opening dialog. May be used several times on a rule.","CONDITION: Adding this clause opens a dialog depicted in  to build a Boolean expression from a set of fixed conditions which are available for the current rule. In the MIR node box , the user can select one of the nodes of the rule. The conditions box  displays the conditions that are available for the selected node. Most of the conditions check for the data type of an operand, or for a certain data type with a specific bit-width, which can be passed as parameter the condition in another dialog. Only if the specified condition is evaluated to true during the match phase this rule will be applied.","CONTROL: Indicates a control dependency between this rule and surrounding ones. The user selects between three kinds from a drop down menu in the parameter column. \u201cbranch\u201d and \u201ccall\u201d are currently equivalent. The third one, \u201cfall through\u201d, indicates that the rule is a null instruction, e.g., a fall through to the only successor basic block. This should be specified for all rules dealing with control flow, in general mirGoto, mirReturn and mirIf.","COST: Specifies the cost of this rule if it is applied. This is used by the matcher to find the optimal match for a statement. If no COST clause is specified, a default COST clause will be generated with costs of the number of assigned instructions.","EVAL: This clause cosists of a list of statements that can be entered in an editor. They will be executed during the matching phase. Useful for evaluating non-terminal attributes in this phase.","INTERFERE: Specifies the interferences of the rule operands explicitly. The register allocator will assign different physical registers for the interfering registers.","LOCK: This clause will lock the operands of the rule, e.g., a following instruction that writes the operands will stall.","OUTPUT: With this clause it can be specified which pseudo registers leave this rule alive. The clause is used for rules producing more than one result.","PREEMIT: Contains a list of C statements which will be executed during the emit phase, and is basically an escape mechanism for rules that need special preprocessing.","PREFER: The operand selected from the dialog should preferably be the same as the result register.","READ\/WRITE: These clauses can be used to specify data dependencies explicitly. The MEMORY parameter indicates an operand representing a memory address, whereas the REGISTER parameter specifies dependencies through different physical registers.","RESULT: With this clause it can be specified that the result register is the same as one of the source operands. Such rules should not emit code.","SCRATCH: The user can request additional scratch (e.g., temporary) register non-terminals for the mapping. After specifying the type and amount of the scratch registers, the scratch non-terminals will appear in the mapping dialog and can be used for the mapping procedure.","UNIQUE: This clause specifies that all registers used by the rule are distinct. This includes also the registers used by addressing mode non-terminals.",{"@attributes":{"id":"p-0183","num":"0193"},"figref":["FIG. 8","FIG. 8"],"b":["900","910"]},"In step , the extracted information is imported into a program comprising a graphical user interface that allows a user to input additional information that is usable in the compiler description. This step may comprise automatically extracting data flow hazard and control flow hazard information from the architecture description.","In step , user provided information is accessed that is usable in the compiler description. If desired, user-provided modifications to the extracted information may be accessing, as well.","In step , the compiler description is automatically generated for the described architecture, based on the automatically extracted information and the received user provided information. If user-provided modifications were accessed in step , then step  comprises automatically generating the compiler description based on the extracted information as modified by the user. Step  may comprise accessing a mapping of compiler rules to instructions used in the architecture description. For example, information that is entered via a GUI is accessed.",{"@attributes":{"id":"p-0187","num":"0197"},"figref":["FIG. 9","FIG. 9"],"b":["1000","1010"]},"In step , a mapping of rules for a compiler to instructions in said architecture description language is accessed. For example, information that is entered via a GUI is accessed. In order to fully describe the compiler description it is also useful to provide definitions for abstract elements in the compiler description that have no direct representative in said architecture description language. For example, as discussed herein, embodiments of the present invention provide definitions for non-terminals in the compiler description that have no direct representative in the architecture description language.","In step , a description for a compiler for the architecture description based on the mapping is generated, wherein said compiler description has a flattened format.",{"@attributes":{"id":"p-0190","num":"0200"},"figref":"FIG. 10","b":["1100","1010"]},"In step , a list of ready nodes in the directed acyclic graph is maintained. In step , a list of nodes not yet scheduled is maintained.","In step , a determination is made of whether the next instruction to be scheduled is to be taken from the list of ready nodes or from the list of nodes not yet scheduled. Step  may further comprise accumulating edge weights for all paths from a given node to leaf nodes; and assigning a priority to the given node based on the path having the maximum accumulated edge weight. Step  may still further comprise: if a node that has the highest priority from the list of nodes not yet scheduled has a higher priority than the priority any node in the list of ready nodes, scheduling the node that has the highest priority from the list of nodes not yet scheduled; otherwise, scheduling a node from the ready list having the highest priority. Process  then ends.","For purposes of illustration Tables XI-XVIII provide exemplary architecture description input code, in accordance with an embodiment of the present invention. Table XI is exemplary input code that is a main module of an architecture description, in accordance with an embodiment of the present invention.",{"@attributes":{"id":"p-0194","num":"0204"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"7pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE XI"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"#include \u201cdefine.h\u201d",{}]},{"entry":[{},"%sim_include \u201cdefine.h\u201d",{}]},{"entry":[{},"\/*{{{RESOURCE*\/",{}]},{"entry":[{},"RESOURCE",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003MEMORY_MAP",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003RANGE(0\u00d70000, 0\u00d70fff) -> prog_mem[(31..0)];",{}]},{"entry":[{},"\u2003\u2003\u2003RANGE(0\u00d71000, 0\u00d71fff) -> data_mem[(31..0)];",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003\/* 0\u00d71000 bytes of program memory *\/",{}]},{"entry":[{},"\u2003\/* FLAGS are set to RIX meaning that prog_mem is readable and executable *\/",{}]},{"entry":[{},"\u2003RAM U32 prog_mem",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003SIZE(0\u00d71000);",{}]},{"entry":[{},"\u2003\u2003\u2003BLOCKSIZE(32,8);",{}]},{"entry":[{},"\u2003\u2003\u2003FLAGS(RIX);",{}]},{"entry":[{},"\u2003\u2003\u2003\/* For the synthesis only the definition of the read and write ports are required *\/",{}]},{"entry":[{},"\u2003\u2003\u2003\/* PORT(READ=10 OR WRITE=10); *\/",{}]},{"entry":[{},"\u2003\u2003};",{}]},{"entry":[{},"\u2003\/* 0\u00d71000 bytes of data memory *\/",{}]},{"entry":[{},"\u2003\/* FLAGS are set to RIW meaning that data_mem is readable and writable *\/",{}]},{"entry":[{},"\u2003RAM U32 data_mem",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003SIZE(0\u00d71000);",{}]},{"entry":[{},"\u2003\u2003\u2003BLOCKSIZE(32,8);",{}]},{"entry":[{},"\u2003\u2003\u2003FLAGS(RIW);",{}]},{"entry":[{},"\u2003\u2003\u2003\/* For the synthesis only the definition of the read and write ports are required *\/",{}]},{"entry":[{},"\u2003\u2003\u2003\/* PORT(READ=10 OR WRITE=10); *\/",{}]},{"entry":[{},"\u2003\u2003};",{}]},{"entry":[{},"\u2003\/* Register bank with 16 registers *\/",{}]},{"entry":[{},"\u2003REGISTER\u2003TClocked<U32> R[0..15];",{}]},{"entry":[{},"\u2003\/* Fetch program counter *\/",{}]},{"entry":[{},"\u2003REGISTER\u2003TClocked<U32> FPC;",{}]},{"entry":[{},"\u2003\/* The program counter EPC corresponds to the instruction that will be executed *\/",{}]},{"entry":[{},"\u2003\/* in the next control step. *\/",{}]},{"entry":[{},"\u2003PROGRAM_COUNTER U32 EPC;",{}]},{"entry":[{},"\u2003PIPELINE_REGISTER IN pipe",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003\/* for load\/store\/branch instructions*\/",{}]},{"entry":[{},"\u2003\u2003\u2003U32 address;",{}]},{"entry":[{},"\u2003\u2003\u2003\/* for data processing instructions*\/",{}]},{"entry":[{},"\u2003\u2003\u2003U32 operand1 ;",{}]},{"entry":[{},"\u2003\u2003\u2003U32 operand2;",{}]},{"entry":[{},"\u2003\u2003\u2003U32 result;",{}]},{"entry":[{},"\u2003\u2003\u2003\/* for conditional program control instructions *\/",{}]},{"entry":[{},"\u2003\u2003\u2003bool branch_taken;",{}]},{"entry":[{},"\u2003\u2003\u2003\/* condition flag for execution *\/",{}]},{"entry":[{},"\u2003\u2003\u2003bool exec_true;",{}]},{"entry":[{},"\u2003\u2003\u2003\/* The following pipeline register entries are optional. *\/",{}]},{"entry":[{},"\u2003\u2003\u2003\/* They provide a better microarchitecture implementation such as fast *\/",{}]},{"entry":[{},"\u2003\u2003\u2003\/* branches or forwarding. If this mechanism is not desired",{}]},{"entry":[{},"\u2003\u2003\u2003\/* they can be removed *\/",{}]},{"entry":[{},"\u2003\u2003\u2003\/* for speed up unconditional program control instructions *\/",{}]},{"entry":[{},"\u2003\u2003\u2003\/* unconditional branches can be executed after decoding*\/",{}]},{"entry":[{},"\u2003\u2003\u2003\/* the conditional branch logic in EX is not required *\/",{}]},{"entry":[{},"\u2003\u2003\u2003bool jmp_taken;",{}]},{"entry":[{},"\u2003\u2003\u2003\/* for operand forwarding only : *\/",{}]},{"entry":[{},"\u2003\u2003\u2003\/* keep track of currently read register src1 and src2 *\/",{}]},{"entry":[{},"\u2003\u2003\u2003\/* keep track of currently written register *\/",{}]},{"entry":[{},"\u2003\u2003\u2003\/* enables forwarding operand from WB->EX or WB->DC if dest=srcx *\/",{}]},{"entry":[{},"\u2003\u2003\u2003U8 dest;",{}]},{"entry":[{},"\u2003\u2003\u2003U8 src1 ;",{}]},{"entry":[{},"\u2003\u2003\u2003U8 src2;",{}]},{"entry":[{},"\u2003\u2003\u2003\/* current instruction pc and word *\/",{}]},{"entry":[{},"\u2003\u2003\u2003\u2002PROGRAM_COUNTER U32 pc;",{}]},{"entry":[{},"\u2003\u2003\u2003U32 insn;",{}]},{"entry":[{},"\u2003\u2003\u2003\/* for post-increment load\/store*\/",{}]},{"entry":[{},"\u2003\u2003\u2003\u2002U8 dest_pi;",{}]},{"entry":[{},"\u2003\u2003};",{}]},{"entry":[{},"\u2003\/* Definition of the four stage pipeline *\/",{}]},{"entry":[{},"\u2003PIPELINE pipe = {FE; DC; EX; WB };",{}]},{"entry":[{},"\u2003\/* Intermediate forwarding variables for the execute stage *\/",{}]},{"entry":[{},"\u2003U32 alu_operand1 ;",{}]},{"entry":[{},"\u2003U32 alu_operand2;",{}]},{"entry":[{},"\u2003\/* Intermediate forwarding variables for the decode stage *\/",{}]},{"entry":[{},"\u2003U8 dc_src1 ;",{}]},{"entry":[{},"\u2003U8 dc_src2;",{}]},{"entry":[{},"\u2003U32 dc_address;",{}]},{"entry":[{},"\u2003U32 dc_cond_value;",{}]},{"entry":[{},"\u2003U32 dc_cond_reg;",{}]},{"entry":[{},"\u2003\/* Definition of units only necessary for the synthesis *\/",{}]},{"entry":[{},"\u2003UNIT UNT_FETCH",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003fetch;",{}]},{"entry":[{},"\u2003\u2003};",{}]},{"entry":[{},"\u2003UNIT DECODE",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003arithmetic, arithmetic_short,",{}]},{"entry":[{},"\u2003\u2003\u2003jmp, move,",{}]},{"entry":[{},"\u2003\u2003\u2003load_store, load_store_address,",{}]},{"entry":[{},"\u2003\u2003\u2003ex_if_equal, ex_if_notequal;",{}]},{"entry":[{},"\u2003\u2003};",{}]},{"entry":[{},"\u2003UNIT DMEM_AC",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003load, store;",{}]},{"entry":[{},"\u2003\u2003};",{}]},{"entry":[{},"\u2003UNIT ALU",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003alu_insn, jmp_ex;",{}]},{"entry":[{},"\u2003\u2003};",{}]},{"entry":[{},"\u2003UNIT WRITEBACK",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003writeback_register,writeback_post_increment_register;",{}]},{"entry":[{},"\u2003\u2003};",{}]},{"entry":[{},"}",{}]},{"entry":[{},"\/*}}}*\/",{}]},{"entry":[{},"\/*{{{OPERATION reset*\/",{}]},{"entry":[{},"OPERATION reset",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003BEHAVIOR",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003\/* Reset processor to a defined state *\/",{}]},{"entry":[{},"\u2003\u2003\u2003int i;",{}]},{"entry":[{},"\u2003\u2003\u2003\/* Zero register file *\/",{}]},{"entry":[{},"\u2003\u2003\u2003for (i = 0 ; i < 16 ; i++)",{}]},{"entry":[{},"\u2003\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003R[i] = 0;",{}]},{"entry":[{},"\u2003\u2003\u2003}",{}]},{"entry":[{},"\u2003\u2003\u2003\/* Set program counter to entry point as *\/",{}]},{"entry":[{},"\u2003\u2003\u2003\/* specified in COFF file*\/",{}]},{"entry":[{},"\u2003\u2003\u2003\u2002FPC = LISA_PROGRAM_COUNTER;",{}]},{"entry":[{},"\u2003\u2003\u2003\u2002EPC = LISA__PROGRAM_COUNTER;",{}]},{"entry":[{},"\u2003\u2003\u2003alu_operand1 = alu_operand2 = dc_address = dc_cond_value = dc_cond_reg = 0;",{}]},{"entry":[{},"\u2003\u2003\u2003dc_src1 = dc_src2 = 0;",{}]},{"entry":[{},"\u2003\u2003\u2003\/* Flush the pipeline : zero all entries *\/",{}]},{"entry":[{},"\u2003\u2003\u2003PIPELINE(pipe).flush( );",{}]},{"entry":[{},"\u2003\u2003\u2003}",{}]},{"entry":[{},"}",{}]},{"entry":[{},"\/*}}}*\/",{}]},{"entry":[{},"\/*{{{ OPERATION main*\/",{}]},{"entry":[{},"OPERATION main",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003\/* The operation main is not assigned to a pipeline stage. *\/",{}]},{"entry":[{},"\u2003DECLARE",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003INSTANCE fetch, decode;",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003BEHAVIOR",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003\/* Execute all activated operations in the pipeline *\/",{}]},{"entry":[{},"\u2003\u2003\u2003PIPELINE(pipe).execute( );",{}]},{"entry":[{},"\u2003\u2003\u2003PIPELINE(pipe).shift( );",{}]},{"entry":[{},"\u2003\u2003\u2003\/* Difference to ISA model :*\/",{}]},{"entry":[{},"\u2003\u2003\u2003\/* The fetch-program counter logic is located in *\/",{}]},{"entry":[{},"\u2003\u2003\u2003\/* the fetch operation *\/",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003\/* decode and fetch are not executed in the behavior as they are *\/",{}]},{"entry":[{},"\u2003\/* in the instruction accurate implementation, rather they are *\/",{}]},{"entry":[{},"\u2003\/* acitvated now. The pipeline stage assignment of these *\/",{}]},{"entry":[{},"\u2003\/* operations defines the temporal execution order *\/",{}]},{"entry":[{},"\u2003ACTIVATION",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003\/* activate fetch and decode only if the pipeline is not stalled *\/",{}]},{"entry":[{},"\u2003\u2003\u2003if (!PIPELINE_REGISTER(pipe,FE\/DC).stalled( ))",{}]},{"entry":[{},"\u2003\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003fetch, decode",{}]},{"entry":[{},"\u2003\u2003\u2003}",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"}",{}]},{"entry":[{},"\/*}}}*\/",{}]},{"entry":[{},"\/*{{{OPERATION fetch IN pipe.FE*\/",{}]},{"entry":[{},"OPERATION fetch IN pipe.FE",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003\u2003BEHAVIOR",{}]},{"entry":[{},"\u2003\u2003\u2003\/* We need some information from pipeline-registers which *\/",{}]},{"entry":[{},"\u2003\u2003\u2003\/* are beyond this stage. Thus we have to declare them in *\/",{}]},{"entry":[{},"\u2003\u2003\u2003\/* the behavior USES prolog.*\/",{}]},{"entry":[{},"\u2003\u2003\u2003USES ( IN",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003PIPELINE_REGISTER(pipe,DC\/EX).jmp_taken,",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003PIPELINE_REGISTER(pipe,DC\/EX).address,",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003PIPELINE_REGISTER(pipe,EX\/WB).branch_taken,",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003PIPELINE_REGISTER(pipe,EX\/WB).address; )",{}]},{"entry":[{},"\u2003\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003\/* Difference to ISA model :*\/",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003\/* The fetch logic is more complex than in the instruction accurate model because ",{}]},{"entry":[{},"we distinguish between conditional and unconditional branches. To speed up the program,",{}]},{"entry":[{},"execution of unconditional branches are taken after decoding and conditional branches after",{}]},{"entry":[{},"evaluating the condition in the execute stage *\/",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003U32 next_pc=FPC;",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003\/* fetch program counter multiplexer *\/",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003\/* Check if an unconditional branch instruction has been *\/",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003\/* decoded before. This is indicated by the jmp_taken flag.*\/",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003\/* The branch instruction is now in the EX stage *\/",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003if(PIPELINE_REGISTER(pipe,DC\/EX).jmp_taken){",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\/* Set the next pc to be fetched *\/",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003next_pc=PIPELINE_REGISTER(pipe,DC\/EX).address;",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003}",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003else",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003\/* Check if a conditional branch instruction has been *\/",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003\/* decoded before. This is indicated by the branch_taken flag.*\/",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003\/* The branch instruction is now in the WB stage *\/",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003if(PIPELINE_REGISTER(pipe,EX\/WB).branch_taken){",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\/* Set the next pc to be fetched *\/",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003next_pc=PIPELINE_REGISTER(pipe,EX\/WB).address;",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003}",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003\/* get the instruction word from the program memory and*\/",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003\/* put it together with the pc into the pipeline register *\/",{}]},{"entry":[{},"\u2003\u2003\u2003PIPELINE_REGISTER(pipe,FE\/DC).insn = prog_mem[ next_pc ];",{}]},{"entry":[{},"\u2003\u2003\u2003PIPELINE_REGISTER(pipe,FE\/DC).pc \u2002 = next_pc ;",{}]},{"entry":[{},"\u2003\u2003\u2003\/* fill pipeline register with default values *\/",{}]},{"entry":[{},"\u2003\u2003\u2003PIPELINE_REGISTER(pipe,FE\/DC).exec_true=true;",{}]},{"entry":[{},"\u2003\u2003\u2003\/* increment the fetch program counter *\/",{}]},{"entry":[{},"\u2003\u2003\u2003next_pc += 1;",{}]},{"entry":[{},"\u2003\u2003\u2003FPC=next_pc;",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"}",{}]},{"entry":[{},"\/*}}}*\/",{}]},{"entry":[{},"\/*{{{INSTRUCTION decode IN pipe.DC*\/",{}]},{"entry":[{},"INSTRUCTION decode IN pipe.DC",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003\/* Start of the instruction set description *\/",{}]},{"entry":[{},"\u2003DECLARE",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003GROUP instruction = {",{}]},{"entry":[{},"\u2003\u2003\u2003load_store\u2003II \/* st, Id *\/",{}]},{"entry":[{},"\u2003\u2003\u2003arithmetic\u2003II \/* add, sub, mul *\/",{}]},{"entry":[{},"\u2003\u2003\u2003arithmetic_short II \/* add, sub, mul (short forms)*\/",{}]},{"entry":[{},"\u2003\u2003\u2003move\u2003II \/* mov *\/",{}]},{"entry":[{},"\u2003\u2003\u2003jmp\u2003II \/* jmp *\/",{}]},{"entry":[{},"\u2003\u2003\u2003compare\u2003II \/* cmp *\/",{}]},{"entry":[{},"\u2003\u2003\u2003nop\u2003\/* nop *\/",{}]},{"entry":[{},"\u2003\u2003\u2003};",{}]},{"entry":[{},"\u2003\u2003\u2003\/* Execution condition, may be defined for every instruction *\/",{}]},{"entry":[{},"\u2003\u2003\u2003GROUP ex_cond = { ex_if_equal II ex_if_notequal II ex_uncond };",{}]},{"entry":[{},"\u2003\u2003\u2003\/* an operation just for setting the pc in the debugger *\/",{}]},{"entry":[{},"\u2003\u2003\u2003INSTANCE set_debugger_epc;",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003\/* The current instruction word is in \u201cPIPELINE_REGISTER(pipe,FE\/DC).insn\u201d.*\/",{}]},{"entry":[{},"\u2003\/* The current instruction word is at \u201cPIPELINE_REGISTER(pipe,FE\/DC).pc\u201d.*\/",{}]},{"entry":[{},"\u2003\/* An instruction is composed by a condition and an instruction *\/",{}]},{"entry":[{},"\u2003CODING AT (PIPELINE_REGISTER(pipe,FE\/DC).pc)",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003PIPELINE_REGISTER(pipe,FE\/DC).insn == ex_cond instruction",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003SYNTAX",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003ex_cond instruction",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003ACTIVATION",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003ex_cond, instruction, set_debugger_epc",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003\/* Difference to ISA model :*\/",{}]},{"entry":[{},"\u2003\/* The instruction condition is evaluated in the next stage EX.*\/",{}]},{"entry":[{},"\u2003\/* Thus, we do not decide here in DC if instruction should be*\/",{}]},{"entry":[{},"\u2003\/* activated or not. Instead, we check it in EX.*\/",{}]},{"entry":[{},"}",{}]},{"entry":[{},"\/*}}}*\/",{}]},{"entry":[{},"\/*{{{OPERATION set_debugger_epc IN pipe.EX*\/",{}]},{"entry":[{},"OPERATION set_debugger_epc IN pipe. EX",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003BEHAVIOR",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003if (PIPELINE_REGISTER(pipe,DC\/EX).exec_true)",{}]},{"entry":[{},"\u2003\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003EPC = PIPELINE_REGISTER(pipe,DC\/EX).pc;",{}]},{"entry":[{},"\u2003\u2003\u2003}",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"}",{}]},{"entry":[{},"\/*}}}*\/",{}]},{"entry":[{},"\u2003\u00a9\u20092003, Coware, Inc."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Table XII is exemplary code that is an operands module of an architecture description, in accordance with an embodiment of the present invention.",{"@attributes":{"id":"p-0196","num":"0206"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE XII"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"*****************************************************",{}]},{"entry":[{},"#include \u201cdefine.h\u201d",{}]},{"entry":[{},"OPERATION addr8",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003\/* 8-bit absolute address *\/",{}]},{"entry":[{},"\u2003DECLARE",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003LABEL addr;",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003CODING { addr=0bx[8] }",{}]},{"entry":[{},"\u2003SYNTAX { SYMBOL(addr=#S8) }",{}]},{"entry":[{},"\u2003EXPRESSION {addr }",{}]},{"entry":[{},"}",{}]},{"entry":[{},"OPERATION branch_addr_imm20 IN pipe.DC",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003\/* 20-bit relative address *\/",{}]},{"entry":[{},"\u2003DECLARE",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003LABEL addr;",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003CODING { 0b0 addr=0bx[20] }",{}]},{"entry":[{},"\u2003SYNTAX { SYMBOL(((addr=#S20)+CURRENT_ADDRESS) ",{}]},{"entry":[{},"=#X32 ) }",{}]},{"entry":[{},"\u2003BEHAVIOR {",{}]},{"entry":[{},"\u2003\u2003\u2003\/* Extract the branch address *\/",{}]},{"entry":[{},"\u2003\u2003\u2003\/* Relative address *\/",{}]},{"entry":[{},"\u2003\u2003\u2003dc_address=(SIGN_EXTEND_20(addr)) + PIPELINE_",{}]},{"entry":[{},"REGISTER(pipe,FE\/DC).pc ;",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"}",{}]},{"entry":[{},"OPERATION branch_addr_reg IN pipe.DC",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003\/* register address *\/",{}]},{"entry":[{},"\u2003DECLARE",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003INSTANCE reg_idx;",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"CODING {0bi 0b0000 0b0000 0b0000 0b0000 reg_idx }",{}]},{"entry":[{},"\u2003SYNTAX {reg_idx }",{}]},{"entry":[{},"\u2003BEHAVIOR {",{}]},{"entry":[{},"\u2003\u2003\/* Extract the branch address *\/",{}]},{"entry":[{},"\u2003\u2003\/* Absolute address *\/",{}]},{"entry":[{},"\u2003\u2003READ_REGISTER(reg_idx,dc_address);",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"}",{}]},{"entry":[{},"OPERATION imm12",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003\/* 12-bit immediate value *\/",{}]},{"entry":[{},"\u2003DECLARE",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003LABEL value;",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003CODING { value=0bx[12] }",{}]},{"entry":[{},"\u2003SYNTAX { SYMBOL( value=#S12 ) }",{}]},{"entry":[{},"\u2003EXPRESSION { value }",{}]},{"entry":[{},"}",{}]},{"entry":[{},"OPERATION imm16",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003\/* 16-bit immediate value *\/",{}]},{"entry":[{},"\u2003DECLARE",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003LABEL value;",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003CODING { value=0bx[16] }",{}]},{"entry":[{},"\u2003SYNTAX { SYMBOL( value=#S16 ) }",{}]},{"entry":[{},"EXPRESSION { value }",{}]},{"entry":[{},"}",{}]},{"entry":[{},"\/\/OPERATION reg_idx",{}]},{"entry":[{},"REGISTER reg_idx",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003\/* register *\/",{}]},{"entry":[{},"\u2003DECLARE",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003LABEL index;",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003CODING { index=0bx[4] }",{}]},{"entry":[{},"\u2003SYNTAX { \u201cr\u201d ~index=#U }",{}]},{"entry":[{},"\u2003EXPRESSION { index }",{}]},{"entry":[{},"}",{}]},{"entry":[{},"OPERATION cond_reg_idx",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003\/* register *\/",{}]},{"entry":[{},"\u2003DECLARE",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003LABEL index;",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003CODING { index=(0bx[2]) }",{}]},{"entry":[{},"\u2003SYNTAX { \u201cr\u201d ~index=#U }",{}]},{"entry":[{},"\u2003EXPRESSION { index }",{}]},{"entry":[{},"}",{}]},{"entry":[{},"\u2003\u2003\u2003\u00a9 2003, Coware, Inc.",{}]},{"entry":[{},"*****************************************************"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Table XIII is exemplary input code that is a load\/store module of an architecture description, in accordance with an embodiment of the present invention.",{"@attributes":{"id":"p-0198","num":"0208"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE XIII"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"******************************************************",{}]},{"entry":[{},"#include \u201cdefine.h\u201d",{}]},{"entry":[{},"OPERATION load_store IN pipe.DC",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003DECLARE {",{}]},{"entry":[{},"\u2003\u2003\/* opcode : load or store *\/",{}]},{"entry":[{},"\u2003\u2003GROUP opcode = { load || store };",{}]},{"entry":[{},"\u2003\u2003\/* source or destination register. *\/",{}]},{"entry":[{},"\u2003\u2003GROUP load_store_reg= { reg_idx };",{}]},{"entry":[{},"\u2003\u2003\/* load or store address *\/",{}]},{"entry":[{},"\u2003\u2003INSTANCE load_store_address;",{}]},{"entry":[{},"\u2003\u2003\/* storing : try forward the register value from the WB stage *\/",{}]},{"entry":[{},"\u2003\u2003INSTANCE read_register_or_forward_dc;",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"\u2003CODING { opcode load_store_reg load_store_address}",{}]},{"entry":[{},"\u2003SWITCH(opcode)",{}]},{"entry":[{},"\u2003{",{}]},{"entry":[{},"\u2003\u2003CASE load :",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003SYNTAX { load_store_reg \u201c=\u201d \u201cdmem[\u201c load_",{}]},{"entry":[{},"store_address \u201d]\u201d }",{}]},{"entry":[{},"\u2003\u2003BEHAVIOR",{}]},{"entry":[{},"\u2003\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003\/* in case of loading the destination register is stored for ",{}]},{"entry":[{},"writing back the result *\/",{}]},{"entry":[{},"\u2003\u2003\u2003PIPELINE_REGISTER(pipe,DC\/EX).dest=load_store_reg;",{}]},{"entry":[{},"\u2003\u2003\u2003}",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003\u2003CASE store :",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003SYNTAX {\u201cdmem[\u201c load_store_address \u201d]\u201d \u201c=\u201d ",{}]},{"entry":[{},"load_store_reg }",{}]},{"entry":[{},"\u2003\u2003\u2003BEHAVIOR",{}]},{"entry":[{},"\u2003\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003\/* in case of storing the source register value is loaded *\/",{}]},{"entry":[{},"\u2003\u2003\u2003\/* prepare the signals for forwarding *\/",{}]},{"entry":[{},"\u2003\u2003\u2003dc_src1=load_store_reg;",{}]},{"entry":[{},"\u2003\u2003\u2003dc_src2=0;",{}]},{"entry":[{},"\u2003\u2003\u2003\/* forward the register value from the WB stage *\/",{}]},{"entry":[{},"\u2003\u2003\u2003\/* otherwise read value from the the register file *\/",{}]},{"entry":[{},"\u2003\u2003\u2003read_register_or_forward_dc( );",{}]},{"entry":[{},"\u2003\u2003\u2003}",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"\u2003ACTIVATION",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003\/* prepare the address used for either loading or storing*\/",{}]},{"entry":[{},"\u2003\u2003\u2003load_store_address,",{}]},{"entry":[{},"\u2003\u2003\u2003\/* perform the load or store operation *\/",{}]},{"entry":[{},"\u2003\u2003\u2003opcode",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"}",{}]},{"entry":[{},"OPERATION load IN pipe.EX",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003DECLARE {",{}]},{"entry":[{},"\u2003\u2003\/* write-back the loaded value to the destination register *\/",{}]},{"entry":[{},"\u2003\u2003INSTANCE writeback_register;",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"\u2003CODING {0b01110000 }",{}]},{"entry":[{},"\u2003BEHAVIOR",{}]},{"entry":[{},"\u2003{",{}]},{"entry":[{},"\u2003\u2003\/* load from data memory at <address> into the result field *\/",{}]},{"entry":[{},"PIPELINE_REGISTER(pipe,EX\/WB).result=data_mem",{}]},{"entry":[{},"[PIPELINE_REGISTER(pipe,DC\/EX).address&0xfff];",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"\u2003ACTIVATION",{}]},{"entry":[{},"\u2003{",{}]},{"entry":[{},"\u2003\u2003\/* write-back the result to the destination register *\/",{}]},{"entry":[{},"\u2003\u2003writeback_register",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"}",{}]},{"entry":[{},"OPERATION store IN pipe.EX",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003CODING {0b01100000 }",{}]},{"entry":[{},"BEHAVIOR",{}]},{"entry":[{},"\u2003{",{}]},{"entry":[{},"\u2003\u2003\/* store the store-operand prepared in DC into data ",{}]},{"entry":[{},"memory at <address> *\/",{}]},{"entry":[{},"data_mem[PIPELINE_REGISTER(pipe,DC\/EX).",{}]},{"entry":[{},"address&0xfff]=PIPELINE_",{}]},{"entry":[{},"REGISTER(pipe,DC\/EX).operand1;",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"}",{}]},{"entry":[{},"OPERATION load_store_address IN pipe. DC",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003DECLARE {",{}]},{"entry":[{},"\u2003\u2003GROUP base_reg = {reg_idx };",{}]},{"entry":[{},"\u2003\u2003\/* addressing modes*\/",{}]},{"entry":[{},"\u2003\u2003\/* A regular mode and also a mode *\/",{}]},{"entry":[{},"\u2003\u2003\/* with post increment of the*\/",{}]},{"entry":[{},"\u2003\u2003\/* address register is provided. *\/",{}]},{"entry":[{},"\u2003\u2003GROUP address_mode = {mode_normal || ",{}]},{"entry":[{},"mode_post_increment };",{}]},{"entry":[{},"\u2003\u2003\/* 8-bit address *\/",{}]},{"entry":[{},"\u2003\u2003INSTANCE addr8;",{}]},{"entry":[{},"\u2003\u2003\/* write-back the post increment register *\/",{}]},{"entry":[{},"\u2003\u2003INSTANCE writeback_post_increment_register;",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"\u2003CODING {address_mode base_reg addr8 }",{}]},{"entry":[{},"\u2003SWITCH (address_mode) {",{}]},{"entry":[{},"\u2003\u2003CASE mode_normal :",{}]},{"entry":[{},"\u2003\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003\/* normal addressing *\/",{}]},{"entry":[{},"\u2003\u2003\u2003SYNTAX {base_reg \u201c+\u201d addr8 }",{}]},{"entry":[{},"\u2003\u2003\u2003BEHAVIOR {",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003U32 address;",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003READ_REGISTER(base_reg,address);",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003address+=SIGN_EXTEND_8(addr8);",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003PIPELINE_REGISTER(pipe,DC\/EX).address=address;",{}]},{"entry":[{},"\u2003\u2003\u2003}",{}]},{"entry":[{},"\u2003\u2003\u2003}",{}]},{"entry":[{},"\u2003\u2003CASE mode_post_increment:",{}]},{"entry":[{},"\u2003\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003\/* post increment addressing *\/",{}]},{"entry":[{},"\u2003\u2003\u2003SYNTAX {base_reg ~\u201c+=\u201d addr8 }",{}]},{"entry":[{},"\u2003\u2003\u2003BEHAVIOR {",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003U32 address;",{}]},{"entry":[{},"\u2003\u2003\u2003READ_REG ISTER(base_reg,address);",{}]},{"entry":[{},"\u2003\u2003\u2003PIPELINE_REGISTER(pipe,DC\/EX).address =address;",{}]},{"entry":[{},"\u2003\u2003\u2003\/* post increment the base register and write-back *\/",{}]},{"entry":[{},"\u2003\u2003\u2003PIPELINE_REGISTER(pipe,DC\/EX).operand2=",{}]},{"entry":[{},"address+SIGN_EXTEND_8(addr8);",{}]},{"entry":[{},"\u2003\u2003\u2003PIPELINE_REGISTER(pipe,DC\/EX).dest_pi =base_reg;",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003\u2003ACTIVATION",{}]},{"entry":[{},"\u2003\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003writeback_post_increment_register",{}]},{"entry":[{},"\u2003\u2003\u2003}",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"}",{}]},{"entry":[{},"\/** The following operation comprises the regular mode for a load\/",{}]},{"entry":[{},"store operation *\/OPERATION mode_normal",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003CODING {0b0000}",{}]},{"entry":[{},"}",{}]},{"entry":[{},"\/** The following operation comprises the post-increment mode ",{}]},{"entry":[{},"for a load\/store operation. *\/OPERATION mode_post_increment",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003CODING {0b0001}",{}]},{"entry":[{},"}",{}]},{"entry":[{},"\/** Operation to move data to a register *\/",{}]},{"entry":[{},"OPERATION move IN pipe.DC",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003DECLARE",{}]},{"entry":[{},"\u2003{",{}]},{"entry":[{},"\u2003\u2003\/* Destination register *\/",{}]},{"entry":[{},"\u2003\u2003GROUP dest_reg = {reg_idx };",{}]},{"entry":[{},"\u2003\u2003\/* 16bit constant to be loaded *\/",{}]},{"entry":[{},"\u2003\u2003INSTANCE imm16;",{}]},{"entry":[{},"\u2003\u2003INSTANCE move_ex;",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"\u2003CODING { 0b01010000 dest_reg imm16 }",{}]},{"entry":[{},"\u2003SYNTAX { dest_reg \u201c=\u201d imm16 }",{}]},{"entry":[{},"\u2003BEHAVIOR",{}]},{"entry":[{},"\u2003{",{}]},{"entry":[{},"\u2003\u2003\/* Assign \u201cimm16\u201d to source operand one \u201csrc1\u201d *\/",{}]},{"entry":[{},"\u2003\u2003PIPELI NE_REGISTER(pipe,DC\/EX).result=SIGN_",{}]},{"entry":[{},"EXTEND_16(imm16);",{}]},{"entry":[{},"\u2003\u2003PIPELINE_REGISTER(pipe,DC\/EX).dest=dest_reg;",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"\u2003ACTIVATION",{}]},{"entry":[{},"\u2003{",{}]},{"entry":[{},"\u2003\u2003move_ex",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"}",{}]},{"entry":[{},"OPERATION move_ex IN pipe.EX",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003DECLARE",{}]},{"entry":[{},"\u2003{",{}]},{"entry":[{},"\u2003\u2003\/* Result-writeback operation *\/",{}]},{"entry":[{},"\u2003\u2003INSTANCE writeback_register;",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"\u2003ACTIVATION",{}]},{"entry":[{},"\u2003{",{}]},{"entry":[{},"\u2003\/* check the result of the instruction condition evaluated in DC *\/",{}]},{"entry":[{},"\u2003\u2003if(PIPELINE_REGISTER(pipe,DC\/EX).exec_true)",{}]},{"entry":[{},"\u2003{",{}]},{"entry":[{},"\u2003\u2003\/\/ Write-back \u201cdest\u201d to destreg",{}]},{"entry":[{},"\u2003\u2003writeback_register",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"}",{}]},{"entry":[{},"\u2003\u00a9 2003, Coware, Inc.",{}]},{"entry":[{},"******************************************************"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Table XIV is exemplary input code that is a data forwarding module of an architecture description, in accordance with an embodiment of the present invention.",{"@attributes":{"id":"p-0200","num":"0210"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE XIV"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"******************************************************",{}]},{"entry":[{},"#include \u201cdefine.h\u201d",{}]},{"entry":[{},"OPERATION read_register_or_forward_dc IN pipe.DC",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\/* Operand forwarding from WB to DC *\/",{}]},{"entry":[{},"BEHAVIOR USES (IN PIPELINE_REGISTER",{}]},{"entry":[{},"(pipe,EX\/WB).result,",{}]},{"entry":[{},"\u2003\u2003PIPELINE_REGISTER(pipe,EX\/WB).dest;)",{}]},{"entry":[{},"\u2003{",{}]},{"entry":[{},"\u2003\/* check if the source operand register has been written in EX ",{}]},{"entry":[{},"in the previous cycle *\/",{}]},{"entry":[{},"\u2003if(dc_src1!=0){",{}]},{"entry":[{},"\u2003\/* check if the operand register is going to be written ",{}]},{"entry":[{},"in the WB stage *\/",{}]},{"entry":[{},"\u2003\u2003if((dc_src1==PIPELINE_REGISTER(pipe,EX\/WB).dest))",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\/* forward the result from the WB stage *\/",{}]},{"entry":[{},"PIPELINE_REGISTER(pipe,DC\/EX).operand1=PIPELINE_ ",{}]},{"entry":[{},"REGISTER(pipe,EX\/WB).result;",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003\u2003else{",{}]},{"entry":[{},"\u2003\u2003\/* get the register value from the register file *\/",{}]},{"entry":[{},"\u2003\u2003READ_REGISTER(dc_src1,PIPELINE_REGISTER",{}]},{"entry":[{},"(pipe,DC\/EX).operand1);",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"\u2003if(dc_src2!=0){",{}]},{"entry":[{},"\u2003\/* check if the operand register is going to be written ",{}]},{"entry":[{},"in the WB stage *\/",{}]},{"entry":[{},"\u2003\u2003if((dc_src2==PIPELINE_REGISTER(pipe,EX\/WB).dest))",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\/* forward the result from the WB stage *\/",{}]},{"entry":[{},"PIPELINE_REGISTER(pipe,DC\/EX).operand2=PIPELINE_",{}]},{"entry":[{},"REGISTER(pipe,EX\/WB).result;",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003\u2003else{",{}]},{"entry":[{},"\u2003\u2003\/* get the register value from the register file *\/",{}]},{"entry":[{},"\u2003\u2003READ_REGISTER(dc_src2,PIPELINE_REGISTER",{}]},{"entry":[{},"(pipe,DC\/EX).operand2);",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"}",{}]},{"entry":[{},"OPERATION prepare_alu_operand_try_forward_ex IN pipe.EX",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\/* Operand forwarding from WB to EX *\/",{}]},{"entry":[{},"BEHAVIOR USES (IN PIPELINE_REGISTER",{}]},{"entry":[{},"(pipe,EX\/WB).result,",{}]},{"entry":[{},"\u2003\u2003PIPELINE_REGISTER(pipe,EX\/WB).dest;)",{}]},{"entry":[{},"\u2003{",{}]},{"entry":[{},"\u2003\/* check if the operand register is going to be written ",{}]},{"entry":[{},"in the WB stage *\/",{}]},{"entry":[{},"if((PIPELINE_REGISTER(pipe,EX\/WB).dest==PIPELINE_",{}]},{"entry":[{},"REGISTER(pipe,DC\/EX).src1 )&&",{}]},{"entry":[{},"\u2003\u2003(PIPELINE_REGISTER(pipe,DC\/EX).src1!=0))",{}]},{"entry":[{},"\u2003{",{}]},{"entry":[{},"\u2003\u2003\/* forward the result from the WB stage *\/",{}]},{"entry":[{},"\u2003\u2003alu_operand1=PIPELINE_REGISTER(pipe,EX\/WB).result;",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"\u2003else",{}]},{"entry":[{},"\u2003{",{}]},{"entry":[{},"\u2003alu_operand1=PIPELINE_REGISTER(pipe,DC\/EX).operand1;",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"\u2003if",{}]},{"entry":[{},"((PIPELINE_REGISTER(pipe,EX\/WB).dest==PIPELINE_",{}]},{"entry":[{},"REGISTER(pipe,DC\/EX).src2)&&",{}]},{"entry":[{},"\u2003\u2003(PIPELINE_REGISTER(pipe,DC\/EX).src2!=0))",{}]},{"entry":[{},"\u2003{",{}]},{"entry":[{},"\u2003\u2003\/* forward the result from the WB stage *\/",{}]},{"entry":[{},"\u2003\u2003alu_operand2=PIPELINE_REGISTER(pipe,EX\/WB).result;",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"\u2003else",{}]},{"entry":[{},"\u2003{",{}]},{"entry":[{},"\u2003\u2003alu_operand2=PIPELINE_REGISTER(pipe,DC\/EX).",{}]},{"entry":[{},"operand2;",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"}",{}]},{"entry":[{},"OPERATION read_conditon_register_or_forward_dc IN pipe.DC",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\/* Operand forwarding from WB to DC *\/",{}]},{"entry":[{},"BEHAVIOR USES ( IN",{}]},{"entry":[{},"\u2003PIPELINE_REGISTER(pipe,EX\/WB).result,",{}]},{"entry":[{},"\u2003PIPELINE_REGISTER(pipe,EX\/WB).dest;",{}]},{"entry":[{},"\u2003)",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003\u2003\/* check if the operand register is going to be ",{}]},{"entry":[{},"written in the WB stage *\/",{}]},{"entry":[{},"\u2003\u2003\u2003if(PIPELINE_REGISTER(pipe,EX\/WB).",{}]},{"entry":[{},"dest!=dc_cond_reg){",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003\/* Assign the first source register to source ",{}]},{"entry":[{},"operand one \u201csrc1\u201d *\/",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003READ_REGISTER(dc_cond_reg,dc_cond_value);",{}]},{"entry":[{},"\u2003\u2003\u2003}",{}]},{"entry":[{},"\u2003\u2003\u2003else{",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003\/* forward the result from the EX stage *\/",{}]},{"entry":[{},"\u2003\u2003\u2003\u2003dc_cond_value=PIPELINE_REGISTER",{}]},{"entry":[{},"(pipe,EX\/WB).result;",{}]},{"entry":[{},"\u2003\u2003\u2003}",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"}",{}]},{"entry":[{},"\u2003\u00a9 2003, Coware, Inc.",{}]},{"entry":[{},"******************************************************"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Table XV is exemplary input code that is a control-flow module of an architecture description, in accordance with an embodiment of the present invention.",{"@attributes":{"id":"p-0202","num":"0212"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE XV"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"****************************************************",{}]},{"entry":[{},"#include \u201cdefine.h\u201d",{}]},{"entry":[{},"\/** The jump is a special case of the branches. Here the control ",{}]},{"entry":[{},"transfer instruction is executed unconditional.*\/",{}]},{"entry":[{},"\/*{{{OPERATION jmp IN pipe.DC*\/",{}]},{"entry":[{},"OPERATION jmp IN pipe.DC",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003DECLARE",{}]},{"entry":[{},"\u2003{",{}]},{"entry":[{},"\u2003\u2003GROUP branch_addr ={ branch_addrimm20 ",{}]},{"entry":[{},"|| branch_addr_reg};",{}]},{"entry":[{},"\u2003\u2003REFERENCE ex_cond;",{}]},{"entry":[{},"\u2003\u2003INSTANCE jmp_ex;",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"\u2003CODING {0b0100000 branch_addr }",{}]},{"entry":[{},"\u2003SYNTAX {\u201cjmp\u201d~\u201c \u201d branch_addr }",{}]},{"entry":[{},"BEHAVIOR {",{}]},{"entry":[{},"\u2003\/* Extract the branch address *\/",{}]},{"entry":[{},"\u2003branch_addr( );",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"\u2003IF(ex_cond==ex_uncond) THEN",{}]},{"entry":[{},"\u2003{",{}]},{"entry":[{},"\u2003\u2003\/* Immediate branch in decode stage *\/",{}]},{"entry":[{},"\u2003\u2003BEHAVIOR",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\/* set branch taken flag *\/",{}]},{"entry":[{},"\u2003\u2003PIPELINE_REGISTER(pipe,DC\/EX).jmp_taken=true;",{}]},{"entry":[{},"\u2003\u2003PIPELINE_REGISTER(pipe,DC\/EX).address=dc_address;",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003\u2003ACTIVATION",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\/* flush the currently fetched instruction *\/",{}]},{"entry":[{},"\u2003\u2003PIPELINE_REGISTER(pipe,FE\/DC).flush( )",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"\u2003ELSE",{}]},{"entry":[{},"\u2003{",{}]},{"entry":[{},"\u2003\u2003\/* the branch is conditional *\/",{}]},{"entry":[{},"\u2003\u2003BEHAVIOR",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\/* propagate the address to the execute stage*\/",{}]},{"entry":[{},"\u2003\u2003PIPELINE_REGISTER(pipe,DC\/EX).address=dc_address;",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003\u2003ACTIVATION",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003jmp_ex,",{}]},{"entry":[{},"\u2003\u2003\/* stall the pipeline until the condition is evaluated in EX *\/",{}]},{"entry":[{},"\u2003\u2003PIPELINE_REGISTER(pipe,FE\/DC).stall( )",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"}",{}]},{"entry":[{},"\/*}}}*\/",{}]},{"entry":[{},"\/*{{{OPERATION jmp_ex IN pipe.EX*\/",{}]},{"entry":[{},"OPERATION jmp_ex IN pipe.EX",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003BEHAVIOR",{}]},{"entry":[{},"\u2003{",{}]},{"entry":[{},"\u2003\u2003if(PIPELINE_REGISTER(pipe,DC\/EX).exec_true)",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\/* set branch taken flag *\/",{}]},{"entry":[{},"\u2003\u2003PIPELINE_REGISTER(pipe,EX\/WB).branch_taken=true;",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"ACTIVATION",{}]},{"entry":[{},"\u2003{",{}]},{"entry":[{},"\u2003\u2003if(PIPELINE_REGISTER(pipe,DC\/EX).exec_true)",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003PIPELINE_REGISTER(pipe,FE\/DC).flush( ),",{}]},{"entry":[{},"\u2003\u2003PIPELINE_REGISTER(pipe,DC\/EX).flush( )",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"}",{}]},{"entry":[{},"\/*}}}*\/",{}]},{"entry":[{},"\u00a9 2003, Coware, Inc.",{}]},{"entry":[{},"****************************************************"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Table XVI is exemplary input code that is a compare module of an architecture description, in accordance with an embodiment of the present invention.",{"@attributes":{"id":"p-0204","num":"0214"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE XVI"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"***********************************************",{}]},{"entry":[{},{},"#include \u201cdefine.h\u201d",{}]},{"entry":[{},{},"\/*{{{OPERATION compare IN pipe.DC*\/",{}]},{"entry":[{},{},"OPERATION compare IN pipe.DC",{}]},{"entry":[{},{},"{",{}]},{"entry":[{},{},"\u2003DECLARE",{}]},{"entry":[{},{},"\u2003{",{}]},{"entry":[{},{},"\u2003\u2003\/* CMPU instructions *\/",{}]},{"entry":[{},{},"\u2003\u2003INSTANCE cmp_insn;",{}]},{"entry":[{},{},"\u2003\u2003\/* First source register and destination register *\/",{}]},{"entry":[{},{},"\u2003\u2003GROUP src1_reg = {reg_idx };",{}]},{"entry":[{},{},"\u2003\u2003\/* Operand two: can be a register or an ",{}]},{"entry":[{},{},"immediate value *\/",{}]},{"entry":[{},{},"\u2003\u2003GROUP src2_reg_or_imm={src2 reg || \/* register *\/",{}]},{"entry":[{},{},"\u2003\u2003\u2003src2_imm }; \/* immediate *\/",{}]},{"entry":[{},{},"\u2003\u2003GROUP dest_reg ={cond_reg_idx };",{}]},{"entry":[{},{},"\u2003\u2003\/* operand forwarding operation for stage DC *\/",{}]},{"entry":[{},{},"\u2003\u2003INSTANCE read_register_or_forward_dc;",{}]},{"entry":[{},{},"\u2003}",{}]},{"entry":[{},{},"\u2003CODING {0b0000 cmp_insn dest_reg 0bi src2_",{}]},{"entry":[{},{},"reg_or_imm src1 _reg }",{}]},{"entry":[{},{},"\u2003SYNTAX {dest_reg \u201c=\u201d \u201c(\u201c src1_reg cmp_",{}]},{"entry":[{},{},"insn src2_reg_or_imm \u201d)\u201d}",{}]},{"entry":[{},{},"\u2003BEHAVIOR",{}]},{"entry":[{},{},"\u2003{",{}]},{"entry":[{},{},"\u2003\u2003\/* Prepare variable which stores the index of source ",{}]},{"entry":[{},{},"\u2003\u2003register 1, this variable is used for forwarding from ",{}]},{"entry":[{},{},"\u2003\u2003WB to DC *\/dc_srcl = src1_reg;",{}]},{"entry":[{},{},"\u2003\u2003\/* Prepare source operand two \u201csrc2\u201d*\/",{}]},{"entry":[{},{},"\u2003\u2003src2_reg_or_imm( );",{}]},{"entry":[{},{},"\u2003\u2003\/* Get register contents or forward from WB*\/",{}]},{"entry":[{},{},"\u2003\u2003read_register_or_forward_dc( );",{}]},{"entry":[{},{},"\u2003\u2003\/* Put the destination and source register *\/",{}]},{"entry":[{},{},"\u2003\u2003\/* index into the pipe to allow forwarding to EX *\/",{}]},{"entry":[{},{},"\u2003\u2003PIPELINE_REGISTER(pipe,DC\/EX).dest=dest_reg;",{}]},{"entry":[{},{},"\u2003\u2003PIPELINE_R EGISTER(pipe,DC\/EX).src1=dc_src1 ;",{}]},{"entry":[{},{},"\u2003}",{}]},{"entry":[{},{},"\u2003ACTIVATION",{}]},{"entry":[{},{},"\u2003{",{}]},{"entry":[{},{},"\u2003\u2003\/* Activate the CMPU *\/",{}]},{"entry":[{},{},"\u2003\u2003cmp_insn",{}]},{"entry":[{},{},"\u2003}",{}]},{"entry":[{},{},"}",{}]},{"entry":[{},{},"\/*}}}*\/",{}]},{"entry":[{},{},"\/*{{{OPERATION cmp_insn IN pipe.EX*\/",{}]},{"entry":[{},{},"OPERATION cmp_insn IN pipe.EX",{}]},{"entry":[{},{},"{",{}]},{"entry":[{},{},"\u2003DECLARE",{}]},{"entry":[{},{},"\u2003{",{}]},{"entry":[{},{},"\u2003\u2003\/* Condition code *\/",{}]},{"entry":[{},{},"\u2003\u2003GROUP insn = { CMP_EQ || CMP_NE || CMP_",{}]},{"entry":[{},{},"GE || CMP_LT || CMP_GT || CMP_LE };",{}]},{"entry":[{},{},"\u2003\u2003\/* operand forwarding operation for stage EX *\/",{}]},{"entry":[{},{},"\u2003\u2003INSTANCE prepare_alu_operand_try_forward_ex;",{}]},{"entry":[{},{},"\u2003\u2003\/* write-back the result to the destination register *\/",{}]},{"entry":[{},{},"\u2003\u2003INSTANCE writeback_register;",{}]},{"entry":[{},{},"\u2003}",{}]},{"entry":[{},{},"\u2003CODING { insn }",{}]},{"entry":[{},{},"\u2003SYNTAX { insn }",{}]},{"entry":[{},{},"\u2003BEHAVIOR",{}]},{"entry":[{},{},"\u2003{",{}]},{"entry":[{},{},"\u2003\u2003\/* check if a forward from EX is available*\/",{}]},{"entry":[{},{},"\u2003\u2003\/* prepare the ALU operands alu_operand1 and ",{}]},{"entry":[{},{},"alu_operand2 *\/",{}]},{"entry":[{},{},"\u2003\u2003prepare_alu_operand_try_forward_ex( );",{}]},{"entry":[{},{},"\u2003\u2003\/* execute the CMP instruction*\/",{}]},{"entry":[{},{},"\u2003\u2003insn( );",{}]},{"entry":[{},{},"\u2003}",{}]},{"entry":[{},{},"\u2003ACTIVATION",{}]},{"entry":[{},{},"\u2003{",{}]},{"entry":[{},{},"\u2003\u2003\/* writeback the result to the destination register *\/",{}]},{"entry":[{},{},"\u2003\u2003\/* which is in the \u201cdest\u201d field of the pipeline-reg.*\/",{}]},{"entry":[{},{},"\u2003\u2003writeback_register",{}]},{"entry":[{},{},"\u2003}",{}]},{"entry":[{},{},"}",{}]},{"entry":[{},{},"\/*}}}*\/",{}]},{"entry":[{},{},"\/*{{{OPERATION CMP_EQ IN pipe.EX*\/",{}]},{"entry":[{},{},"OPERATION CMP_EQ IN pipe.EX",{}]},{"entry":[{},{},"{",{}]},{"entry":[{},{},"\u2003CODING { 0b0001 }",{}]},{"entry":[{},{},"\u2003SYNTAX { \u201c==\u201d }",{}]},{"entry":[{},{},"\u2003BEHAVIOR",{}]},{"entry":[{},{},"\u2003{",{}]},{"entry":[{},{},"\u2003\u2003PIPELINE_REGISTER(pipe,EX\/WB).result =",{}]},{"entry":[{},{},"(alu_operand1 ==alu_operand2) ? 1 : 0;",{}]},{"entry":[{},{},"\u2003}",{}]},{"entry":[{},{},"}",{}]},{"entry":[{},{},"\/*}}}*\/",{}]},{"entry":[{},{},"\/*{{{OPERATION CMP_NE IN pipe.EX*\/",{}]},{"entry":[{},{},"OPERATION CMP_NE IN pipe.EX",{}]},{"entry":[{},{},"{",{}]},{"entry":[{},{},"\u2003CODING {0b0010 }",{}]},{"entry":[{},{},"\u2003SYNTAX {\u201c!=\u201d }",{}]},{"entry":[{},{},"\u2003BEHAVIOR",{}]},{"entry":[{},{},"\u2003{",{}]},{"entry":[{},{},"\u2003\u2003PIPELINE_REGISTER(pipe,EXIWB).result =",{}]},{"entry":[{},{},"(alu_operand1 !=alu_operand2) ? 1 : 0;",{}]},{"entry":[{},{},"\u2003}",{}]},{"entry":[{},{},"}",{}]},{"entry":[{},{},"\/*}}}*\/",{}]},{"entry":[{},{},"\/*{{{OPERATION CMP_GE IN pipe.EX*\/",{}]},{"entry":[{},{},"OPERATION CMP_GE IN pipe.EX",{}]},{"entry":[{},{},"{",{}]},{"entry":[{},{},"\u2003CODING {0b0011 }",{}]},{"entry":[{},{},"\u2003SYNTAX {\u201c>=\u201d }",{}]},{"entry":[{},{},"\u2003BEHAVIOR",{}]},{"entry":[{},{},"\u2003{",{}]},{"entry":[{},{},"\u2003\u2003PIPELINE_REGISTER(pipe,EX\/WB).result =",{}]},{"entry":[{},{},"(alu_operand1 >=alu_operand2) ? 1 : 0;",{}]},{"entry":[{},{},"\u2003}",{}]},{"entry":[{},{},"}",{}]},{"entry":[{},{},"\/*}}}*\/",{}]},{"entry":[{},{},"\/*{{{OPERATION CMP_LE IN pipe.EX*\/",{}]},{"entry":[{},{},"OPERATION CMP_LE IN pipe.EX",{}]},{"entry":[{},{},"{",{}]},{"entry":[{},{},"\u2003CODING {0b0100 }",{}]},{"entry":[{},{},"\u2003SYNTAX {\u201c<=\u201d }",{}]},{"entry":[{},{},"\u2003BEHAVIOR",{}]},{"entry":[{},{},"\u2003{",{}]},{"entry":[{},{},"\u2003\u2003PIPELINE_REGISTER(pipe,EX\/WB).result = ",{}]},{"entry":[{},{},"(alu_operand1 <=alu_operand2) ? 1 : 0;",{}]},{"entry":[{},{},"\u2003}",{}]},{"entry":[{},{},"}",{}]},{"entry":[{},{},"\/*}}}*\/",{}]},{"entry":[{},{},"\/*{{{OPERATION CMP_GT IN pipe.EX*\/",{}]},{"entry":[{},{},"OPERATION CMP_GT IN pipe.EX",{}]},{"entry":[{},{},"{",{}]},{"entry":[{},{},"\u2003CODING {0b0101 }",{}]},{"entry":[{},{},"\u2003SYNTAX {\u201c>\u201c~\u201d \u201d}",{}]},{"entry":[{},{},"\u2003BEHAVIOR",{}]},{"entry":[{},{},"\u2003{",{}]},{"entry":[{},{},"\u2003\u2003PIPELINE_REGISTER(pipe,EX\/WB).result =",{}]},{"entry":[{},{},"(alu_operand1 >alu_operand2) ? 1 : 0;",{}]},{"entry":[{},{},"\u2003}",{}]},{"entry":[{},{},"}",{}]},{"entry":[{},{},"\/*}}}*\/",{}]},{"entry":[{},{},"\/*{{{OPERATION CMP_LT IN pipe.EX*\/",{}]},{"entry":[{},{},"OPERATION CMP_LT-IN pipe.EX",{}]},{"entry":[{},{},"{",{}]},{"entry":[{},{},"\u2003CODING {0b0110 }",{}]},{"entry":[{},{},"\u2003SYNTAX {\u201c>\u201c~\u201d \u201d}",{}]},{"entry":[{},{},"\u2003BEHAVIOR",{}]},{"entry":[{},{},"\u2003{",{}]},{"entry":[{},{},"\u2003\u2003PIPELINE_REGISTER(pipe,EX\/WB).result = ",{}]},{"entry":[{},{},"(alu_operand1 < alu_operand2) ? 1 : 0;",{}]},{"entry":[{},{},"\u2003) ",{}]},{"entry":[{},{},"}",{}]},{"entry":[{},{},"\/*}}}*\/",{}]},{"entry":[{},{},"\u00a9 2003, Coware, Inc.",{}]},{"entry":[{},{},"***********************************************"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"Table XVII is exemplary input code that is an arithmetic module of an architecture description, in accordance with an embodiment of the present invention.",{"@attributes":{"id":"p-0206","num":"0216"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE XVII"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"***********************************************",{}]},{"entry":[{},{},"#include \u201cdefine.h\u201d",{}]},{"entry":[{},{},"\/*{{{OPERATION arithmetic IN pipe.DC*\/",{}]},{"entry":[{},{},"OPERATION arithmetic IN pipe.DC",{}]},{"entry":[{},{},"{",{}]},{"entry":[{},{},"\u2003DECLARE",{}]},{"entry":[{},{},"\u2003{",{}]},{"entry":[{},{},"\u2003\u2003\/* ALU instructions *\/",{}]},{"entry":[{},{},"\u2003\u2003INSTANCE alu_insn;",{}]},{"entry":[{},{},"\u2003\u2003\/* First source register and destination register *\/",{}]},{"entry":[{},{},"\u2003\u2003GROUP src1_reg, dest_reg ={reg_idx };",{}]},{"entry":[{},{},"\u2003\u2003\/* Operand two: can be a register or an ",{}]},{"entry":[{},{},"immediate value *\/",{}]},{"entry":[{},{},"\u2003\u2003GROUP src2_reg_or_imm={src2 reg || \/* register *\/",{}]},{"entry":[{},{},"\u2003\u2003\u2003src2_imm }; \/* immediate *\/",{}]},{"entry":[{},{},"\u2003\u2003\/* operand forwarding operation for stage DC *\/",{}]},{"entry":[{},{},"\u2003\u2003INSTANCE read_register_or_forward_dc;",{}]},{"entry":[{},{},"\u2003}",{}]},{"entry":[{},{},"\u2003CODING {alu_insn 0b000 src2_reg_or_imm srcl_",{}]},{"entry":[{},{},"reg dest_reg }",{}]},{"entry":[{},{},"\u2003SYNTAX {dest_reg reg \u201c=\u201d srcl_reg alu_insn src2_",{}]},{"entry":[{},{},"reg_or_imm }",{}]},{"entry":[{},{},"\u2003BEHAVIOR",{}]},{"entry":[{},{},"\u2003{",{}]},{"entry":[{},{},"\u2003\u2003\/* Prepare variable which stores the index of source ",{}]},{"entry":[{},{},"register 1, this variable is used for forwarding from ",{}]},{"entry":[{},{},"WB to DC *\/",{}]},{"entry":[{},{},"\u2003\u2003dc_src1=src1_reg;",{}]},{"entry":[{},{},"\u2003\u2003\/* Prepare source operand two \u201csrc2\u201d *\/",{}]},{"entry":[{},{},"\u2003\u2003src2_reg_or_imm( );",{}]},{"entry":[{},{},"\u2003\u2003\/* Get register contents or forward from WB*\/",{}]},{"entry":[{},{},"\u2003\u2003read_register_or_forward_dc( );",{}]},{"entry":[{},{},"\u2003\u2003\/* Put the destination and source register *\/",{}]},{"entry":[{},{},"\u2003\u2003\/* index into the pipe to allow forwarding to EX *\/",{}]},{"entry":[{},{},"\u2003\u2003PIPELINE_REGISTER(pipe,DC\/EX).dest=dest_reg;",{}]},{"entry":[{},{},"\u2003\u2003PIPELINE_REGISTER(pipe,DC\/EX).src1=dc_src1 ;",{}]},{"entry":[{},{},"\u2003}",{}]},{"entry":[{},{},"\u2003ACTIVATION",{}]},{"entry":[{},{},"\u2003{",{}]},{"entry":[{},{},"\u2003\u2003\/* Activate the ALU *\/",{}]},{"entry":[{},{},"\u2003\u2003alu_insn",{}]},{"entry":[{},{},"\u2003\u2003}",{}]},{"entry":[{},{},"}",{}]},{"entry":[{},{},"\/*}}}*\/",{}]},{"entry":[{},{},"\/*{{{ALIAS OPERATION arithmetic_short IN pipe.DC*\/",{}]},{"entry":[{},{},"ALIAS OPERATION arithmetic_short IN pipe.DC",{}]},{"entry":[{},{},"{",{}]},{"entry":[{},{},"\u2003\/* This operation is implemented for convenience to the ",{}]},{"entry":[{},{},"assembly programmer*\/",{}]},{"entry":[{},{},"\u2003\/* Here the destination register and the first source ",{}]},{"entry":[{},{},"register are the same. *\/",{}]},{"entry":[{},{},"\u2003\/* F.i.: r1+=2 *\/",{}]},{"entry":[{},{},"\u2003DECLARE",{}]},{"entry":[{},{},"\u2003{",{}]},{"entry":[{},{},"\u2003\u2003\/* ALU instructions *\/",{}]},{"entry":[{},{},"\u2003\u2003INSTANCE alu_insn;",{}]},{"entry":[{},{},"\u2003\u2003*\/ Destination register == source register 1*\/",{}]},{"entry":[{},{},"\u2003\u2003GROUP dest_reg ={reg_idx };",{}]},{"entry":[{},{},"\u2003\u2003\/* Operand two: can be a register or an ",{}]},{"entry":[{},{},"immediate value *\/",{}]},{"entry":[{},{},"\u2003\u2003GROUP src2_reg_or_imm ={ src2 reg || *\/ register *\/",{}]},{"entry":[{},{},"\u2003\u2003\u2003src2_imm }; \/* immediate *\/",{}]},{"entry":[{},{},"\u2003\u2003\/* operand forwarding operation for stage DC *\/",{}]},{"entry":[{},{},"\u2003\u2003INSTANCE read_register_or_forward_dc;",{}]},{"entry":[{},{},"\u2003}",{}]},{"entry":[{},{},"\u2003CODING { alu_insn 0b000 src2_reg_or imm dest_",{}]},{"entry":[{},{},"reg dest_reg }",{}]},{"entry":[{},{},"\u2003SYNTAX { dest_reg alu_insn ~\u201c=\u201d src2_reg_or_imm }-",{}]},{"entry":[{},{},"\u2003BEHAVIOR",{}]},{"entry":[{},{},"\u2003{",{}]},{"entry":[{},{},"\u2003\u2003\/* Prepare variable that stores the index of source ",{}]},{"entry":[{},{},"register 1, this variable is used for forwarding from ",{}]},{"entry":[{},{},"EX to DC *\/",{}]},{"entry":[{},{},"\u2003\u2003dc_src1=dest_reg;",{}]},{"entry":[{},{},"\u2003\u2003\/* Prepare source operand two \u201csrc2\u201d *\/",{}]},{"entry":[{},{},"\u2003\u2003src2_reg_or_imm( );",{}]},{"entry":[{},{},"\u2003\u2003\/* Get register contents or forward from WB*\/",{}]},{"entry":[{},{},"\u2003\u2003read_register_or_forward_dc( );",{}]},{"entry":[{},{},"\u2003\u2003\/* Put the destination and source register *\/",{}]},{"entry":[{},{},"\u2003\u2003\/* index into the pipe to allow forwarding to EX *\/",{}]},{"entry":[{},{},"\u2003\u2003PIPELINE_REGISTER(pipe,DC\/EX).dest=dc_src1;",{}]},{"entry":[{},{},"\u2003\u2003PIPELINE_REGISTER(pipe,DC\/EX).src1=dc_src1;",{}]},{"entry":[{},{},"\u2003}",{}]},{"entry":[{},{},"\u2003ACTIVATION",{}]},{"entry":[{},{},"\u2003{",{}]},{"entry":[{},{},"\u2003\u2003\/* Activate the ALU *\/",{}]},{"entry":[{},{},"\u2003\u2003alu_insn",{}]},{"entry":[{},{},"\u2003\u2003}",{}]},{"entry":[{},{},"}",{}]},{"entry":[{},{},"\/*}}}*\/",{}]},{"entry":[{},{},"\/*{{{OPERATION alu_insn IN pipe.EX*\/",{}]},{"entry":[{},{},"OPERATION alu_insn IN pipe.EX",{}]},{"entry":[{},{},"{",{}]},{"entry":[{},{},"\u2003DECLARE",{}]},{"entry":[{},{},"\u2003{",{}]},{"entry":[{},{},"\u2003\/* alu instruction type *\/",{}]},{"entry":[{},{},"\u2003\u2003GROUP insn ={add || sub || mul || and || or || ",{}]},{"entry":[{},{},"xor || (shift || rshift};",{}]},{"entry":[{},{},"\u2003\u2003\/* operand forwarding operation for stage EX *\/",{}]},{"entry":[{},{},"\u2003\u2003INSTANCE prepare_alu_operand_try_forward_ex;",{}]},{"entry":[{},{},"\u2003\u2003\/* write-back the result to the destination register *\/",{}]},{"entry":[{},{},"\u2003\u2003INSTANCE writeback_register;",{}]},{"entry":[{},{},"\u2003}",{}]},{"entry":[{},{},"\u2003CODING { insn }",{}]},{"entry":[{},{},"\u2003SYNTAX { insn }",{}]},{"entry":[{},{},"\u2003BEHAVIOR",{}]},{"entry":[{},{},"\u2003{",{}]},{"entry":[{},{},"\u2003\u2003\/* check the instruction condition evaluated in DC *\/",{}]},{"entry":[{},{},"\u2003\u2003if(PIPELINE_REGISTER(pipe,DC\/EX).exec_true)",{}]},{"entry":[{},{},"\u2003\u2003{",{}]},{"entry":[{},{},"\u2003\u2003\/* check if a forward from EX is available*\/",{}]},{"entry":[{},{},"\u2003\u2003\/* prepare the ALU operands alu_operand1 and ",{}]},{"entry":[{},{},"alu_operand2 *\/",{}]},{"entry":[{},{},"\u2003\u2003prepare_alu_operand_try_forward_ex( );",{}]},{"entry":[{},{},"\u2003\u2003\/* execute the ALU instruction*\/",{}]},{"entry":[{},{},"\u2003\u2003insn( );",{}]},{"entry":[{},{},"\u2003\u2003}",{}]},{"entry":[{},{},"\u2003}",{}]},{"entry":[{},{},"\u2003ACTIVATION",{}]},{"entry":[{},{},"\u2003{",{}]},{"entry":[{},{},"\u2003\u2003\/* check the instruction condition evaluated in DC *\/",{}]},{"entry":[{},{},"\u2003\u2003if(PIPELINE_REGISTER(pipe,DC\/EX).exec_true)",{}]},{"entry":[{},{},"\u2003\u2003{",{}]},{"entry":[{},{},"\u2003\u2003\/* writeback the result to the destination register *\/",{}]},{"entry":[{},{},"\u2003\u2003\/* which is in the \u201cdest\u201d field of the pipeline-reg.*\/",{}]},{"entry":[{},{},"\u2003\u2003writeback_register",{}]},{"entry":[{},{},"\u2003\u2003}",{}]},{"entry":[{},{},"\u2003}",{}]},{"entry":[{},{},"}",{}]},{"entry":[{},{},"\/*}}}*\/",{}]},{"entry":[{},{},"\/** This operation implements the addition. *\/",{}]},{"entry":[{},{},"\/*{{{OPERATION add IN pipe.EX*\/",{}]},{"entry":[{},{},"OPERATION add IN pipe.EX",{}]},{"entry":[{},{},"{",{}]},{"entry":[{},{},"\u2003CODING {0b1000 }",{}]},{"entry":[{},{},"\u2003SYNTAX {\u201c+\u201d }",{}]},{"entry":[{},{},"\u2003BEHAVIOR",{}]},{"entry":[{},{},"\u2003{",{}]},{"entry":[{},{},"\u2003\u2003\/* perform add *\/",{}]},{"entry":[{},{},"\u2003\u2003PIPELINE_REGISTER(pipe,EX\/WB).result=alu_",{}]},{"entry":[{},{},"operand1 + alu_operand2;",{}]},{"entry":[{},{},"\u2003}",{}]},{"entry":[{},{},"}",{}]},{"entry":[{},{},"\/*}}}*\/",{}]},{"entry":[{},{},"\/** This operation implements the subtraction.*\/",{}]},{"entry":[{},{},"\/*{{{OPERATION sub IN pipe.EX*\/",{}]},{"entry":[{},{},"OPERATION sub IN pipe.EX",{}]},{"entry":[{},{},"{",{}]},{"entry":[{},{},"\u2003CODING {0b1001 }",{}]},{"entry":[{},{},"\u2003SYNTAX {\u201c\u2212\u201d }",{}]},{"entry":[{},{},"\u2003BEHAVIOR",{}]},{"entry":[{},{},"\u2003{",{}]},{"entry":[{},{},"\u2003\u2003\/* perform subtraction *\/",{}]},{"entry":[{},{},"\u2003\u2003PIPELINE_REGISTER(pipe,EX\/WB).result=alu_",{}]},{"entry":[{},{},"operand1 - alu_operand2;",{}]},{"entry":[{},{},"\u2003}",{}]},{"entry":[{},{},"}",{}]},{"entry":[{},{},"\/*}}}*\/",{}]},{"entry":[{},{},"\/** This operation implements the multiplication. *\/",{}]},{"entry":[{},{},"\/*{{{OPERATION mul IN pipe.EX*\/",{}]},{"entry":[{},{},"OPERATION mul IN pipe.EX",{}]},{"entry":[{},{},"{",{}]},{"entry":[{},{},"\u2003CODING {0b1010 }",{}]},{"entry":[{},{},"\u2003SYNTAX {\u201c*\u201d }",{}]},{"entry":[{},{},"\u2003BEHAVIOR",{}]},{"entry":[{},{},"\u2003{",{}]},{"entry":[{},{},"\u2003\u2003\/* perform multiplication *\/",{}]},{"entry":[{},{},"\u2003\u2003PIPELINE_REGISTER(pipe,EX\/WB).result=alu_",{}]},{"entry":[{},{},"operand1 * alu_operand2;",{}]},{"entry":[{},{},"\u2003}",{}]},{"entry":[{},{},"}",{}]},{"entry":[{},{},"\/*}}}*\/",{}]},{"entry":[{},{},"\/** This operation implements or.*\/",{}]},{"entry":[{},{},"\/*{{{OPERATION or IN pipe.EX*\/",{}]},{"entry":[{},{},"OPERATION or IN pipe.EX",{}]},{"entry":[{},{},"{",{}]},{"entry":[{},{},"\u2003CODING {0b1011 }",{}]},{"entry":[{},{},"\u2003SYNTAX {\u201cI\u201d }",{}]},{"entry":[{},{},"\u2003BEHAVIOR",{}]},{"entry":[{},{},"\u2003{",{}]},{"entry":[{},{},"\u2003\u2003\/* perform multiplication *\/",{}]},{"entry":[{},{},"\u2003\u2003PIPELINE_REGISTER(pipe,EX\/WB).result=alu_",{}]},{"entry":[{},{},"operand1lalu_operand2;",{}]},{"entry":[{},{},"\u2003}",{}]},{"entry":[{},{},"}",{}]},{"entry":[{},{},"\/*}}}*\/",{}]},{"entry":[{},{},"\/** This operation implements and. *\/",{}]},{"entry":[{},{},"\/*{{{ OPERATION and IN pipe.EX*\/",{}]},{"entry":[{},{},"OPERATION and IN pipe.EX",{}]},{"entry":[{},{},"{",{}]},{"entry":[{},{},"\u2003CODING {0b1100 }",{}]},{"entry":[{},{},"\u2003SYNTAX {\u201c&\u201d }",{}]},{"entry":[{},{},"\u2003BEHAVIOR",{}]},{"entry":[{},{},"\u2003{",{}]},{"entry":[{},{},"\u2003\u2003\/* perform multiplication *\/",{}]},{"entry":[{},{},"\u2003\u2003PIPELINE_REGISTER(pipe,EX\/WB).result=alu_",{}]},{"entry":[{},{},"operand1&alu_operand2;",{}]},{"entry":[{},{},"\u2003}",{}]},{"entry":[{},{},"}",{}]},{"entry":[{},{},"\/*}}}*\/",{}]},{"entry":[{},{},"\/** This operation implements xor. *\/",{}]},{"entry":[{},{},"\/*{{{ OPERATION xor IN pipe.EX*\/",{}]},{"entry":[{},{},"OPERATION xor IN pipe.EX",{}]},{"entry":[{},{},"{",{}]},{"entry":[{},{},"\u2003CODING {0b1101 }",{}]},{"entry":[{},{},"\u2003SYNTAX {\u201c{circumflex over (\u2009)}\u201d }",{}]},{"entry":[{},{},"\u2003BEHAVIOR",{}]},{"entry":[{},{},"\u2003{",{}]},{"entry":[{},{},"\u2003\u2003\/* perform multiplication *\/",{}]},{"entry":[{},{},"\u2003\u2003PIPELINE_REGISTER(pipe,EX\/WB).result=alu_",{}]},{"entry":[{},{},"operand1{circumflex over (\u2009)}alu_operand2;",{}]},{"entry":[{},{},"\u2003}",{}]},{"entry":[{},{},"}",{}]},{"entry":[{},{},"\/*}}}*\/",{}]},{"entry":[{},{},"\/** This operation implements logical left shift. *\/",{}]},{"entry":[{},{},"\/*{{{OPERATION Ishift IN pipe.EX*\/",{}]},{"entry":[{},{},"OPERATION (shift IN pipe.EX",{}]},{"entry":[{},{},"{",{}]},{"entry":[{},{},"\u2003CODING {0b1110 }",{}]},{"entry":[{},{},"\u2003SYNTAX {\u201c<<\u201d }",{}]},{"entry":[{},{},"\u2003BEHAVIOR",{}]},{"entry":[{},{},"\u2003{",{}]},{"entry":[{},{},"\u2003\u2003\/* perform multiplication *\/",{}]},{"entry":[{},{},"\u2003\u2003PIPELINE_REGISTER(pipe,EX\/WB).result=alu_",{}]},{"entry":[{},{},"operand1<<alu_operand2;",{}]},{"entry":[{},{},"\u2003}",{}]},{"entry":[{},{},"}",{}]},{"entry":[{},{},"\/*}}}*\/",{}]},{"entry":[{},{},"\/** This operation implements logical right shift. *\/",{}]},{"entry":[{},{},"\/*{{{OPERATION rshift IN pipe.EX*\/",{}]},{"entry":[{},{},"OPERATION rshift IN pipe.EX",{}]},{"entry":[{},{},"{",{}]},{"entry":[{},{},"\u2003CODING {0b1111 }",{}]},{"entry":[{},{},"\u2003SYNTAX {\u201c>>\u201d }",{}]},{"entry":[{},{},"\u2003BEHAVIOR",{}]},{"entry":[{},{},"\u2003{",{}]},{"entry":[{},{},"\u2003\u2003\/* perform multiplication *\/",{}]},{"entry":[{},{},"\u2003\u2003PIPELINE_REGISTER(pipe,EX\/WB).result=alu_",{}]},{"entry":[{},{},"operand1>>alu_operand2;",{}]},{"entry":[{},{},"\u2003}",{}]},{"entry":[{},{},"}",{}]},{"entry":[{},{},"\/*}}}*\/",{}]},{"entry":[{},{},"\/** The second operand for an arithmetic operation may ",{}]},{"entry":[{},{},"be a register value. This operation implements the second ",{}]},{"entry":[{},{},"operand for an arithmetic operation as a register.*\/",{}]},{"entry":[{},{},"\/*{{{OPERATION src2_reg IN pipe.DC*\/",{}]},{"entry":[{},{},"OPERATION src2_reg IN pipe.DC",{}]},{"entry":[{},{},"{",{}]},{"entry":[{},{},"\u2003\/* Just register operand *\/",{}]},{"entry":[{},{},"\u2003DECLARE {",{}]},{"entry":[{},{},"\u2003\u2003INSTANCE reg_idx ;",{}]},{"entry":[{},{},"\u2003}",{}]},{"entry":[{},{},"\u2003CODING {0b0 0b00000000 reg_idx }",{}]},{"entry":[{},{},"\u2003SYNTAX {reg_idx }",{}]},{"entry":[{},{},"\u2003BEHAVIOR",{}]},{"entry":[{},{},"\u2003{",{}]},{"entry":[{},{},"\u2003\u2003\/* Prepare variable which stores the index of ",{}]},{"entry":[{},{},"source register 1, *\/",{}]},{"entry":[{},{},"\u2003\u2003\/* this variable is used for forwarding from ",{}]},{"entry":[{},{},"EX to DC *\/",{}]},{"entry":[{},{},"\u2003\u2003dc_src2=reg_idx;",{}]},{"entry":[{},{},"\u2003\u2003\/* Put the source register index into the pipe *\/",{}]},{"entry":[{},{},"\u2003\u2003\/* to allow forwarding to EX *\/",{}]},{"entry":[{},{},"\u2003\u2003PIPELINE_REGISTER(pipe,DC\/EX).src2=dc_src2;",{}]},{"entry":[{},{},"\u2003}",{}]},{"entry":[{},{},"}",{}]},{"entry":[{},{},"\/*}}}*\/",{}]},{"entry":[{},{},"\/** The second operand for an arithmetic operation may ",{}]},{"entry":[{},{},"be an immediate value. This operation implements the ",{}]},{"entry":[{},{},"second operand for an arithmetic operation as an ",{}]},{"entry":[{},{},"immediate value.*\/",{}]},{"entry":[{},{},"\/*{{{OPERATION src2_imm IN pipe.DC*\/",{}]},{"entry":[{},{},"OPERATION src2_imm IN pipe.DC",{}]},{"entry":[{},{},"{",{}]},{"entry":[{},{},"\u2003\/* just immediate operand, register is 0 *\/",{}]},{"entry":[{},{},"\u2003DECLARE{",{}]},{"entry":[{},{},"\u2003\u2003INSTANCE imm12 ;",{}]},{"entry":[{},{},"\u2003}",{}]},{"entry":[{},{},"\u2003CODING {0b1 imm12 }",{}]},{"entry":[{},{},"\u2003SYNTAX {imm12 }",{}]},{"entry":[{},{},"BEHAVIOR {",{}]},{"entry":[{},{},"\u2003\u2003\/* no register involved, avoid forward -> 0 *\/",{}]},{"entry":[{},{},"\u2003\u2003dc src2=0;",{}]},{"entry":[{},{},"\u2003\u2003PIPELINE_REGISTER(pipe,DC\/EX).src2=dc_src2;",{}]},{"entry":[{},{},"\u2003\u2003\/* Prepare source operand two \u201csrc2 *\/",{}]},{"entry":[{},{},"\u2003\u2003PIPELINE_REGISTER(pipe,DC\/EX).operand2=",{}]},{"entry":[{},{},"SIGN_EXTEND_12(imm12)",{}]},{"entry":[{},{},"\u2003}",{}]},{"entry":[{},{},"}",{}]},{"entry":[{},{},"\/*}}}*\/",{}]},{"entry":[{},{},"\u00a9 2003, Coware, Inc.",{}]},{"entry":[{},{},"***********************************************"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"Table XVIII is exemplary input code that is a miscellaneous module of an architecture description, in accordance with an embodiment of the present invention.",{"@attributes":{"id":"p-0208","num":"0218"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE XVIII"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"****************************************************",{}]},{"entry":[{},"#include \u201cdefine.h\u201d",{}]},{"entry":[{},"\/** This operation implements the no-operation instruction. ",{}]},{"entry":[{},"Thus, nothing is processed.",{}]},{"entry":[{},"*\/",{}]},{"entry":[{},"OPERATION nop IN pipe.DC",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003CODING {0b0000 0b0000 0b0000 0bx[4] 0bx[12] }",{}]},{"entry":[{},"\u2003SYNTAX {\u201cnop\u201d }",{}]},{"entry":[{},"\u2003BEHAVIOR {",{}]},{"entry":[{},"\u2003\u2003\/\/ Do nothing",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"}",{}]},{"entry":[{},"\/** This operation is intended to write the result ",{}]},{"entry":[{},"back to the destination register. *\/",{}]},{"entry":[{},"OPERATION writeback_register IN pipe.WB",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003BEHAVIOR {",{}]},{"entry":[{},"\u2003\u2003\/* Write back the result to the destination register *\/",{}]},{"entry":[{},"WRITE_REGISTER(PIPELINE_REGISTER(pipe,EX\/WB).",{}]},{"entry":[{},"dest,PIPELINE_REGISTER(pipe,EX\/WB).result);",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"}",{}]},{"entry":[{},"\/** This operation is intended to write a post incremented ",{}]},{"entry":[{},"address back to a register. *\/",{}]},{"entry":[{},"\u2003OPERATION writeback_post_increment_register IN pipe.WB",{}]},{"entry":[{},"\u2003{",{}]},{"entry":[{},"\u2003BEHAVIOR {",{}]},{"entry":[{},"\u2003\u2003\/* Write back the result to the destination register *\/",{}]},{"entry":[{},"WRITE_REGISTER(PIPELINE_REGISTER(pipe,EX\/WB).",{}]},{"entry":[{},"dest_pi,PIPELINE_REGISTER(pipe,EX\/VVB).operand2);",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"}",{}]},{"entry":[{},"\/** Here, the operation is processed unconditional, ",{}]},{"entry":[{},"thus, in any case.*\/",{}]},{"entry":[{},"OPERATION ex_uncond IN pipe.DC",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003CODING {0b00 0bxx }",{}]},{"entry":[{},"\u2003SYNTAX {~\u201c \u201c \u201d \u201d}",{}]},{"entry":[{},"\u2003BEHAVIOR {",{}]},{"entry":[{},"\u2003\/\/ Nothing",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"}",{}]},{"entry":[{},"\/** In this case the operation is only executed if the execution ",{}]},{"entry":[{},"condition register is unequal zero.*\/",{}]},{"entry":[{},"OPERATION ex_if_equal IN pipe.DC",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003DECLARE",{}]},{"entry":[{},"\u2003{",{}]},{"entry":[{},"\u2003\u2003INSTANCE cond_reg_idx;",{}]},{"entry":[{},"\u2003\u2003INSTANCE read_conditon_register_or_forward_dc;",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"\u2003CODING {0b10 cond_reg_idx }",{}]},{"entry":[{},"\u2003SYNTAX {\u201cif\u201d \u201c(\u201c ~cond_reg_idx ~\u201d)\u201d \u201c \u201d }",{}]},{"entry":[{},"\u2003BEHAVIOR",{}]},{"entry":[{},"\u2003{",{}]},{"entry":[{},"\u2003\u2003dc_cond_reg=cond_reg_idx;",{}]},{"entry":[{},"\u2003if(dc_cond_reg!=0){",{}]},{"entry":[{},"\u2003\u2003\u2003read_conditon_register_or_forward_dc( );",{}]},{"entry":[{},"\u2003\u2003\u2003PIPELINE_REGISTER(pipe,DC\/EX).exectrue.",{}]},{"entry":[{},"(dc_cond_value!=0);",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003\u2003else{",{}]},{"entry":[{},"\u2003\u2003\u2003PIPELINE_REGISTER(pipe,DC\/EX).exec_true=0;",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"}",{}]},{"entry":[{},"\/** In this case the operation is only executed if the execution ",{}]},{"entry":[{},"condition register is equal zero.*\/",{}]},{"entry":[{},"\u2003OPERATION ex_if_notequal IN pipe.DC",{}]},{"entry":[{},"\u2003{",{}]},{"entry":[{},"\u2003DECLARE",{}]},{"entry":[{},"\u2003{",{}]},{"entry":[{},"\u2003\u2003INSTANCE cond_reg_idx;",{}]},{"entry":[{},"\u2003\u2003INSTANCE read_conditon_register_or_forward_dc;",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"\u2003CODING {0b11 cond_reg_idx }",{}]},{"entry":[{},"\u2003SYNTAX {\u201cif\u201d \u201c(\u201c \u201c!\u201d ~cond_reg_idx ~\u201d)\u201d }",{}]},{"entry":[{},"\u2003BEHAVIOR",{}]},{"entry":[{},"\u2003{",{}]},{"entry":[{},"\u2003\u2003dc_cond_reg=cond_reg_idx;",{}]},{"entry":[{},"\u2003\u2003if(dc_cond_reg!=0){",{}]},{"entry":[{},"\u2003\u2003\u2003read_conditon_register_or_forward dc( );",{}]},{"entry":[{},"\u2003\u2003\u2003PIPELINE_REGISTER(pipe,DC\/EX).exec_",{}]},{"entry":[{},"true=(dc_cond_value==0);",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003\u2003else{",{}]},{"entry":[{},"\u2003\u2003\u2003PIPELINE_REGISTER (pipe, DC\/EX).exec_true=0;",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"}",{}]},{"entry":[{},"\u00a9 2003, Coware, Inc.",{}]},{"entry":[{},"****************************************************"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0209","num":"0219"},"figref":["FIG. 11","FIG. 1","FIG. 1"],"b":["100","180","184","170","100","160","100","100","99","101","102","99","101","103","99","101","100","104","99"]},"With reference still to , system  also includes an alphanumeric input device  including alphanumeric and function keys coupled to bus  for communicating information and command selections to central processor unit . System  also includes a cursor control device  coupled to bus  for communicating user input information and command selections to central processor unit . System  of the present embodiment also includes a display device  coupled to bus  for displaying information. A signal input\/output communication device  coupled to bus  provides communication with external devices.","The preferred embodiment of the present invention, a process and system for semi-automatically generating a compiler description from an architecture description are thus described. While the present invention has been described in particular embodiments, it should be appreciated that the present invention should not be construed as limited by such embodiments, but rather construed according to the below claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIGS. 7A-7N"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 11"}]},"DETDESC":[{},{}]}
