---
title: Cancellation mechanism for cancellable tasks including stolen task and descendent of stolen tasks from the cancellable taskgroup
abstract: A scheduler in a process of a computer system schedules tasks of a task group for concurrent execution by multiple execution contexts. The scheduler provides a mechanism that allows the task group to be cancelled by an arbitrary execution context or an asynchronous error state. When a task group is cancelled, the scheduler sets a cancel indicator in each execution context that is executing tasks corresponding to the cancelled task group and performs a cancellation process on each of the execution contexts where a cancel indicator is set. The scheduler also creates local aliases to allow task groups to be used without synchronization by execution contexts that are not directly bound to the task groups.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08959517&OS=08959517&RS=08959517
owner: Microsoft Corporation
number: 08959517
owner_city: Redmond
owner_country: US
publication_date: 20090610
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["Processes executed in a computer system may include execution context schedulers that schedule tasks of processes for execution in the computer system. A scheduler may create execution contexts (e.g., threads, fibers, or child processes) in order to execute tasks. During execution, the scheduler maintains control over these execution contexts and maintains control of the processing resources allocated to the scheduler.","The scheduler may allow the process to express parallelism so that different parts of the process may be executed concurrently. In doing so, however, the scheduler may limit the ability of the process to control the execution. For example, the scheduler may make it difficult for the process to cancel concurrently executing parts of the process. In addition, the scheduler may place restrictions on which execution contexts can execute or control concurrently executing parts of the process.","This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter.","A scheduler in a process of a computer system schedules tasks of a task group for concurrent execution by multiple execution contexts. The scheduler provides a mechanism that allows the task group to be cancelled by an arbitrary execution context or an asynchronous error state. When a task group is cancelled, the scheduler sets a cancel indicator in each execution context that is executing tasks corresponding to the cancelled task group and performs a cancellation process on each of the execution contexts where a cancel indicator is set. The scheduler also creates local aliases to allow task groups to be used without synchronization by execution contexts that are not directly bound to the task groups.","In the following Detailed Description, reference is made to the accompanying drawings, which form a part hereof, and in which is shown, by way of illustration, specific embodiments in which the invention may be practiced. In this regard, directional terminology, such as \u201ctop,\u201d \u201cbottom,\u201d \u201cfront,\u201d \u201cback,\u201d \u201cleading,\u201d \u201ctrailing,\u201d etc., is used with reference to the orientation of the Figure(s) being described. Because components of embodiments can be positioned in a number of different orientations, the directional terminology is used for purposes of illustration and is in no way limiting. It is to be understood that other embodiments may be utilized and structural or logical changes may be made without departing from the scope of the present invention. The following detailed description, therefore, is not to be taken in a limiting sense, and the scope of the present invention is defined by the appended claims.","It is to be understood that the features of the various exemplary embodiments described herein may be combined with each other, unless specifically noted otherwise.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1","b":["22","12","10","22"]},"Runtime environment  represents a runtime mode of operation in a computer system, such as a computer system  shown in  and described in additional detail below, where the computer system is executing instructions. The computer system generates runtime environment  from a runtime platform such as a runtime platform  shown in  and described in additional detail below.","Runtime environment  includes an least one invoked process , a resource management layer , and a set of hardware threads ()-(M), where M is an integer that is greater than or equal to one and denotes the Mth hardware thread (M). Runtime environment  allows tasks from process  to be executed, along with tasks from any other processes that co-exist with process  (not shown), using an operating system (OS) such as an OS  shown in  and described in additional detail below, resource management layer , and hardware threads ()-(M). Runtime environment  operates in conjunction with the OS and\/or resource management layer  to allow process  to obtain processor and other resources of the computer system (e.g., hardware threads ()-(M)).","Runtime environment  includes a scheduler function that generates scheduler . In one embodiment, the scheduler function is implemented as a scheduler application programming interface (API). In other embodiments, the scheduler function may be implemented using other suitable programming constructs. When invoked, the scheduler function creates scheduler  in process  where scheduler  operates to schedule tasks of process  for execution by one or more hardware threads ()-(M). Runtime environment  may exploit fine grained concurrency that application or library developers express in their programs (e.g., process ) using accompanying tools that are aware of the facilities that the scheduler function provides.","Process  includes an allocation of processing and other resources that hosts one or more execution contexts (viz., threads, fibers, or child processes). Process  obtains access to the processing and other resources in the computer system (e.g., hardware threads ()-(M)) from the OS and\/or resource management layer . Process  causes tasks to be executed using the processing and other resources.","Process  generates work in tasks of variable length where each task is associated with an execution context in scheduler . Each task includes a sequence of instructions that perform a unit of work when executed by the computer system. Each execution context forms a thread, fiber, or child process that executes associated tasks on allocated processing resources. Each execution context includes program state and machine state information. Execution contexts may terminate when there are no more tasks left to execute. For each task, runtime environment  and\/or process  either assign the task to scheduler  to be scheduled for execution or otherwise cause the task to be executed without using scheduler .","Process  may be configured to operate in a computer system based on any suitable execution model, such as a stack model or an interpreter model, and may represent any suitable type of code, such as an application, a library function, or an operating system service. Process  has a program state and machine state associated with a set of allocated resources that include a defined memory address space. Process  executes autonomously or substantially autonomously from any co-existing processes in runtime environment . Accordingly, process  does not adversely alter the program state of co-existing processes or the machine state of any resources allocated to co-existing processes. Similarly, co-existing processes do not adversely alter the program state of process  or the machine state of any resources allocated to process .","Resource management layer  allocates processing resources to process  by assigning one or more hardware threads  to process . Resource management layer  exists separately from the OS in the embodiment of . In other embodiments, resource management layer  or some or all of the functions thereof may be included in the OS.","Hardware threads  reside in execution cores of a set or one or more processor packages (e.g., processor packages  shown in  and described in additional detail below) of the computer system. Each hardware thread  is configured to execute instructions independently or substantially independently from the other execution cores and includes a machine state. Hardware threads  may be included in a single processor package or may be distributed across multiple processor packages. Each execution core in a processor package may include one or more hardware threads .","Process  implicitly or explicitly causes scheduler  to be created via the scheduler function provided by runtime environment . Scheduler instance  may be implicitly created when process  uses APIs available in the computer system or programming language features. In response to the API or programming language features, runtime environment  creates scheduler  with a default policy. To explicitly create a scheduler , process  may invoke the scheduler function provided by runtime environment  and specify one or more policies for scheduler .","Scheduler  interacts with resource management layer  to negotiate processing and other resources of the computer system in a manner that is transparent to process . Resource management layer  allocates hardware threads  to scheduler  based on supply and demand and any policies of scheduler .","In the embodiment shown in , scheduler  manages the processing resources by creating virtual processors  that form an abstraction of underlying hardware threads . Scheduler  includes a set of virtual processors ()-(N) where N is an integer greater than or equal to one and denotes the Nth virtual processor (N). Scheduler  multiplexes virtual processors  onto hardware threads  by mapping each virtual processor  to a hardware thread . Scheduler  may map more than one virtual processor  onto a particular hardware thread  but maps only one hardware thread  to each virtual processor . In other embodiments, scheduler  manages processing resources in other suitable ways to cause instructions of process  to be executed by hardware threads .","The set of execution contexts in scheduler  includes a set of execution contexts ()-(N) with respective, associated tasks ()-(N) that are being executed by respective virtual processors ()-(N) and, at any point during the execution of process , a set of zero or more runnable execution contexts  and a set of zero or more blocked (i.e., wait-dependent) execution contexts . Each execution context , , and  includes state information that indicates whether an execution context , , or  is executing, runnable (e.g., in response to becoming unblocked or added to scheduler ), or blocked. Execution contexts  that are executing have been attached to a virtual processor  and are currently executing. Execution contexts  that are runnable include an associated task  and are ready to be executed by an available virtual processor . Execution contexts  that are blocked also include an associated task  and are waiting for data, a message, or an event that is being generated by another execution context  or will be generated by another execution context  or .","Each execution context  executing on a virtual processor  may generate, in the course of its execution, additional tasks , which are organized in any suitable way (e.g., added to work queues (not shown in )). Work may be created by using either application programming interfaces (APIs) provided by runtime environment  or programming language features and corresponding tools in one embodiment. When processing resources are available to scheduler , tasks are assigned to execution contexts  or  that execute them to completion on virtual processors  before picking up new tasks. An execution context  executing on a virtual processor  may also unblock other execution contexts  by generating data, a message, or an event that will be used by other execution contexts .","Each task in scheduler  may be realized (e.g., realized tasks  and ), which indicates that an execution context  or  has been or will be attached to the task and the task is ready to execute. Realized tasks typically include light-weight tasks and agents and may be associated with an execution context  or  just before executing or in advance of execution. A task that is not realized is termed unrealized. Unrealized tasks (e.g., tasks ) may be created as child tasks generated by the execution of parent tasks and may be generated by parallel constructs (e.g., parallel or parallel for) or included in task groups  (shown in , A, , and ). Scheduler  may be organized into a synchronized collection (e.g., a stack and\/or a queue) for logically independent tasks with execution contexts (i.e., realized tasks) along with a list of workstealing queues for dependent tasks (i.e., unrealized tasks).","Prior to executing tasks, scheduler  obtains execution contexts , , and  from runtime environment , resource management layer , or the operating system. Available virtual processors  locate and execute execution contexts  to begin executing tasks. Virtual processors  become available again in response to an execution context  completing, blocking, or otherwise being interrupted (e.g., explicit yielding or forced preemption). When virtual processors  become available, the available virtual processor  may switch to a runnable execution context  to execute an associated task . The available virtual processor  may also execute a next task  or  as a continuation on a current execution context  if the previous task  executed by the current execution context  completed.","Scheduler  searches for a runnable execution context , a realized task , or an unrealized task  to attach to the available virtual processor  for execution in any suitable way. For example, scheduler  may search for a runnable execution context  to execute before searching for a realized task  or an unrealized task  to execute. Scheduler  continues attaching execution contexts  to available virtual processors  for execution until all tasks and execution contexts  of scheduler  have been executed. In other embodiments, runnable execution contexts  and realized tasks  may be merged into single concept from the perspective of schedulers .","In one embodiment, process  organizes unrealized tasks  into one or more task groups  as shown in . Each task group  includes a set  of one or more unrealized tasks  that are suitable for concurrent execution by available execution contexts  and  on virtual processors . Each task group  may be generated using an API or other suitable programming construct that sets forth the set  of unrealized tasks . The tasks  may be executed inline by the execution context  that created the task group  and\/or may be stolen by any available virtual processors  in scheduler . Each task group  may be used to form a fork and join pattern where the set  of tasks  may be forked out to multiple virtual processors  for execution and subsequently joined by a virtual processor  before proceeding. In addition, each task  may generate additional task groups  to create depths of task groups  in execution contexts .","Scheduler  is configured to allow task groups  to be arbitrarily cancelled by any execution context  or in response to asynchronous error state. An execution context  that cancels a task group  may or may not be executing a task  from the task group  or a task descended from a task  of the task group . In response to an asynchronous error state, scheduler  may initiate the cancellation of one or more task groups . Scheduler  may do so for error states that meet any suitable predefined conditions such as an exception that flows through a task  from a task group  without being caught by the task .","Scheduler  binds each task group  to an execution context  that created the task group  by storing a context identifier  with each task group  that identifies the bound execution context  as shown in . In the embodiment of , scheduler  also stores a depth indicator  to indicate the task group depth of the task group  in the bound execution context . Scheduler  also stores a cancel indicator  with each task group  that may be set by an arbitrary execution context  to indicate that the task group  has been cancelled.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 2B","b":["60","34","66","60","34","66","60","34","34","60","34","60","42","60","42","42","60","34","66","60","22","34","66","34","34","60"]},"In the embodiment of , each execution context  maintains a list  of execution contexts  that stole tasks  from task groups  bound to the execution context  along with the depths in the bound execution context  from which tasks  where stolen. Scheduler  adds each execution context  that steals a task  from a task group  to the list  of the bound execution context . In each list , a context identifier  identifies a stealing execution context  and a task group depth indicator  that indicates the depth of the task group  in the bound execution context  from which the task  was stolen.","The process of cancelling a task group  using the embodiments of  will now be described with reference to embodiments of methods for cancelling task groups  shown in . The embodiments of  will also be described with reference to an example of a runtime environment A executing tasks  from task groups  shown in .",{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 3A","FIG. 3A"],"b":["34","42","60","42","42","60","60","70","34","60","60","22"]},"Any time that an execution context  or an asynchronous error state cancels a task group , scheduler  sets the cancel indicator  in the corresponding task group  to indicate that the task group  is cancelled as indicated in a block . Scheduler  also increments the counter  in the bound execution context  as indicated in a block . Scheduler  identifies the bound execution context  using context ID  in the cancelled task group .","Scheduler  further increments the counter  in each execution context  that is executing or blocked on a stolen task  from the cancelled task group  or any task  descended from a stolen task  from the cancelled task group  using lists , potentially recursively, as indicated in a block . Scheduler  first accesses the list  in the bound execution context  to identify execution contexts  that stole tasks  from the cancelled task group . Scheduler  increments the counter  in each execution context  that is identified by a context ID  in list  if the corresponding depth indicator  is greater than or equal to the depth indicator  of the cancelled task group . By doing so, scheduler  begins the process of cancelling the stolen tasks  of the cancelled task group  as well as any tasks  created by (i.e., descended from) the stolen tasks  in the execution contexts  whose counters  have been incremented.","As noted above, stolen tasks  may create additional task groups  with tasks  that may be further stolen by other execution contexts . To cancel these additional stolen tasks  as well as any tasks  descended there from, scheduler  accesses the list  in each execution context  where stolen tasks  are being cancelled (i.e., where counter  has been incremented by scheduler ) and increments the counter  in each execution context  that is identified by a context ID  in each list  from execution contexts  where stolen tasks  are being cancelled. Scheduler  continues this recursive process of accessing lists  and incrementing counters  until all execution contexts  that are executing tasks  descended from stolen tasks from the cancelled task group  have had their corresponding counters  incremented.","In the example of , execution context () executed task () to create task group () with tasks ()()-()(). Execution context () executed task ()() inline to create task group () with tasks ()()-()(), and then executed ()() inline. Execution context () stole task ()() and executed task ()() to create task group () with tasks ()()-()(). Execution context () then executed task ()() inline to create task group () with tasks ()()-()() and executed task ()() inline. Execution context () stole task ()(), executed task ()() to create task group () with task ()(), and executed task ()() inline. Execution context () stole task ()(), executed task ()() to create task group () with tasks ()()-()(), and executed task ()() inline. Tasks ()() and ()() are waiting to be picked up for execution.","If task group () is cancelled, scheduler  sets the cancel indicator  in the task group () and increments the counter  in the bound execution context (). Scheduler  also accesses list  of execution context () which indicates that execution contexts () and () have stolen tasks from task groups  that are at or below the depth of the cancelled task group (). Accordingly, scheduler  increments the counters  in the execution contexts () and (). Scheduler  further accesses lists  of execution contexts () and (). Because the list  of execution context () indicates that execution contexts () stole a task (i.e., task ()()) from a task group  of execution context (), scheduler  also increments the counter  in execution context (). In this example, scheduler  increments the counters  in all execution contexts ()-() to cause tasks ()()-()() from task group () and all descendent tasks  to be cancelled.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 3B","FIG. 3B"],"b":["42","60","22","34","34","22","34"]},"In , scheduler  determines whether a counter  of an execution context  indicates a cancellation of a task group  as indicated in a block . If the counter  is non-zero (i.e., the counter  has been incremented by scheduler  to indicate a cancellation as described above), then scheduler  initiates the cancellation of tasks  of the cancelled task group  and\/or tasks  descended from a task  of the cancelled task group  in the execution context . To do so, scheduler  throws an exception in the execution context  that propagates up through the tasks  of the execution context  until the exception reaches a join point or an entry point of the execution context . If the exception reaches a join point as indicated in a block , scheduler  causes the task group  corresponding to the join point to be cancelled as indicated in a block . Scheduler  cancels the execution of the inline task  and any unexecuted tasks  of the task group .","Scheduler  determines whether an entry point of the execution context  or the cancelled task group  has been reached as indicated in a block . If scheduler  cancelled a task group  in block , scheduler  accesses the cancel indicator  of the task group  to determine whether the task group  is the one that was explicitly cancelled. If the cancel indicator  indicates that the task group  was the one that was explicitly cancelled, then scheduler  decrements the counter  of the execution context  as indicated in a block  and repeats the function of block . If the cancel indicator  does not indicate that the task group  was the one that was explicitly cancelled, then scheduler  re-throws the exception and repeats the function of block  for the next task group . If scheduler  did not cancel a task group  in block , then the exception has reached an entry point of the execution context . In this case, scheduler  decrements the counter  of the execution context  as indicated in block  and repeats the function of block .","In the example of  where task group () is cancelled as described above with reference to , scheduler  detects that the counters  of each execution context ()-() are non-zero when each execution context ()-() interacts with scheduler  in an interruptible way.","When scheduler  detects that the counter  of execution context () indicates that a task group  corresponding to execution context () has been cancelled, scheduler  throws an exception in execution context (). Because execution context () is executing task ()() inline, task group () catches the exception. Scheduler  cancels the execution of the inline task ()() and task group (). Scheduler  accesses the cancel indicator  of task group () which indicates that task group () was not explicitly cancelled. Thus, scheduler  re-throws the exception in execution context () which is caught by task group () because execution context () is executing task ()() inline. Scheduler  cancels the execution of the inline task ()(), unexecuted task ()(), and task group (). Scheduler  accesses the cancel indicator  of task group () which indicates that task group () was explicitly cancelled and, as a result, decrements the counter  of execution context (). Because the counter  of execution context () is now zero in this example, scheduler  halts the cancellation process in execution context () and makes execution context () available to execute new tasks.","When scheduler  detects that the counter  of execution context () is non-zero, scheduler  throws an exception in execution context (). Task group () first catches the exception and scheduler  cancels the execution of the inline task ()(), unexecuted task ()(), and task group (). Scheduler  re-throws the exception in execution context () which is caught by task group (). Scheduler  cancels the execution of the inline task ()() and task group () and again re-throws the exception. This time, the exception reaches the entry point of execution context () because task ()() is executed as a stolen task and not an inline task. Scheduler  decrements the counter  of execution context () and, because the counter  is now zero, scheduler  halts the cancellation process in execution context () and makes execution context () available to execute new tasks.","Scheduler  handles the cancellation process of execution contexts () and () as described for execution context ().","In the above embodiments, scheduler  may prevent execution contexts  from stealing tasks  from cancelled task groups  (i.e., task groups  with cancel indicators  set to indicate that the task groups are cancelled). Accordingly, scheduler  may prevent contention between work stealing and cancellation processes.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 5","b":["10","60","10","60","13","42","60","10","60","11","60","12","42","60","11","60","13","22","66","34","60","10","60","13","60","60"]},"For example, at least counter  in the bound execution context  of task group () will be incremented if task group () is cancelled. Assuming that neither of task groups () or () are also cancelled, scheduler  will stop the cancellation process when the counter  in the bound execution context  is decremented to zero upon cancelling task group (). If, however, one or both of task groups () or () are also cancelled, scheduler  will detect that the counter  in the bound execution context  is non-zero after being decremented zero upon cancelling task group (). Accordingly, scheduler  will continue the cancellation process into task group () and, if task group () is cancelled, into task groups () and ().","In the embodiments described above with reference to  and A-B, a list  in each execution context  was used to track other execution contexts  that stole tasks  from task groups . In another embodiment shown in , the lists  in execution contexts  may be replaced with lists  in task groups  and the depth indicators  in each task group  may be omitted.","As shown in , each task group  includes maintains a list  of execution contexts  that stole tasks  from the corresponding task group . Scheduler  adds each execution context  that steals a task  from a task group  to the list  in that task group . In each list , a context identifier  identifies each execution context  that stole a task  from a corresponding task group .","As shown in , each execution context  maintains a counter  that indicates that one or more task groups  corresponding to the execution context  have been cancelled and is incremented and decremented as described above with reference to .","The process of cancelling a task group  using the embodiments of  will now be described with reference to embodiments of methods for cancelling task groups  shown in . The embodiments of  will also be described with reference to the example of .",{"@attributes":{"id":"p-0063","num":"0062"},"figref":["FIG. 7A","FIG. 7A","FIG. 3A"],"b":["34","42","60","42","42","60","22","70","71","72"]},"Scheduler  increments the counter  in each execution context  identified in the list  of the cancelled task group  as indicated in a block . Because list  includes execution contexts  that stole tasks  from the cancelled task group , scheduler  increments the counter  in each execution context  in list  to a non-zero value to initiate a cancellation process on the execution contexts . By doing so, scheduler  begins the process of cancelling the stolen tasks  of the cancelled task group .","Referring back to the example of  where task group () is cancelled, scheduler  sets the cancel indicator  in the task group () and increments the counter  in the bound execution context (). Scheduler  also accesses list  of the cancelled task group () which indicates that execution context () has stolen a task from task group (). Accordingly, scheduler  increments the counter  in the execution context (). At this point, scheduler  does not know that execution contexts () and () are executing tasks  that descended from tasks  of the cancelled task group . The counters  for these execution contexts () and () will be set during the cancellation processes of execution contexts () and (), respectively, as described below.",{"@attributes":{"id":"p-0066","num":"0065"},"figref":["FIG. 7B","FIG. 7B"],"b":["42","60","22","34","34","22","34"]},"In , scheduler  performs the functions of blocks , , and  as described above with reference to . For each task group  encountered, scheduler  accesses the list  of the task group  and increments the counter  in each execution context  identified in the list  of the encountered task group  as indicated in a block . Because list  includes execution contexts  that stole tasks  from the encountered task group , scheduler  increments the counter  in each execution context  in list  to a non-zero value to initiate a cancellation process on the execution contexts . By doing so, scheduler  begins the process of cancelling the stolen tasks  of the encountered task group . Scheduler  then performs the functions of blocks  and  described with reference to  above to continue and eventually complete the cancellation once the cancelled task group  or an entry point of the execution context  is encountered by the exception.","In the example of  where task group () is cancelled as described above with reference to , scheduler  detects that the counters  of execution contexts () and () are non-zero when each execution context () and () interacts with scheduler  in an interruptible way.","In performing the cancellation process on execution context () as described above with reference to , scheduler  accesses the list  of task group () and increments the counter  in execution context () which stole task ()() from task group (). Similarly, scheduler  accesses the list  of task group () and increments the counter  in execution context () which stole task ()() from task group () in performing the cancellation process on execution context () as described above with reference to . In this way, scheduler  begins the cancellation process on execution contexts () and ().","In a further embodiment, the above embodiments may be partially combined such that execution contexts  include lists  as shown in  and task groups  include depth indicators  as shown in  and, in some cases, lists  as shown in . A task group  may be created by a first execution context  and passed to a second execution context  in this embodiment. If the first execution context  exits, then the list  of the first execution context is moved to the task group  and stored as a list . Accordingly, the cancellation process uses lists  and lists , if present, to identify all task groups  to be cancelled.","In addition to being cancellable, task groups  may be used by different execution contexts  while maintaining thread safety between the execution contexts . In particular, arbitrary execution contexts  may add tasks  to task groups  that are bound to other execution contexts  and execute these added tasks  inline. Execution contexts  that use task groups  that are bound to other execution contexts  are referred to herein as non-bound execution contexts . Scheduler  creates and uses local aliases of task groups  that are used by non-bound execution contexts  to ensure thread safety as described with reference to the embodiments of , , and .",{"@attributes":{"id":"p-0072","num":"0071"},"figref":["FIG. 8","FIG. 8"],"b":["60","34","22","60","34","87","22","60","88","89","22","34","60","34","60"]},"Scheduler  creates either an indirect alias  (shown in ) or a direct alias  (shown in ) for each use of each task group  by a non-bound execution context .","Scheduler  creates an indirect alias  any time that a non-bound execution context  is executing a task  stolen from a task group  and the stolen task  uses the task group  as illustrated in . In , execution context () executes a task  or  that creates a task group  with a set of tasks  as indicated by an arrow . Scheduler  binds the task group  to execution context () by storing an identifier of execution context () in context ID  of task group . Execution context () steals a task  from the set  in task group  and executes the stolen task . When scheduler  detects that the stolen task  attempts to use task group , scheduler  creates indirect alias  and stores an identifier of execution context () in a context ID  of indirect alias . Scheduler  also stores information in a map table () of execution context () that maps task group  to indirect alias . Scheduler  then allows only execution context () to use indirect alias .","Any time that execution context () attempts to use task group , execution context () detects that task group  maps to indirect alias  and uses indirect alias  instead of task group  as indicated by an arrow . Accordingly, execution context () adds a set  of one or more tasks  to the indirect alias  and may inline execute some or all of the tasks  from indirect alias . After the stolen task  finishes execution, execution context () performs a join operation on the indirect alias  and potentially inline executes any tasks  that were queued in the indirect alias  by the stolen task .","Because execution context () will not complete task group  until the stolen task  is completed, execution context () will not complete the join operation on task group  until all tasks  from the indirect alias  complete and the stolen task  performs a join operation on the indirect alias . As a result, the use of a task group  by non-bound execution context () is handled by wait transitivity where the bound execution context () waits until the stolen task  completes a join operation on the indirect alias  before completing a join operation on the task group .","Referring to , scheduler  creates a direct alias  any time that a task group  is passed to an execution context  that is unrelated to a work tree that includes the task group  or passed to an execution context  two or more layers down a work tree that includes the task group . As in the embodiment of , execution context () executes a task  or  that creates a task group  with a set of tasks  as indicated by arrow  and scheduler  binds the task group  to execution context () using context ID  of task group . While executing a task  or , execution context () attempts to use task group . The task  or  of execution context () may be an arbitrary task  or  that is not descended from a stolen task  of task group  or may be a task  that is descended from a task  of task group . Scheduler  creates direct alias  in response to the attempt by execution context () to use task group  and adds the direct alias  to a lock-free linked list of direct aliases  (not shown) that point back to the task group . Scheduler  forms the linked list using alias list pointers  in each direct alias . Scheduler  also stores an identifier of execution context () in a context ID  of direct alias , stores information in a map table () of execution context () that maps task group  to direct alias , and allows only execution context () to use direct alias .","Any time that execution context () attempts to use task group , execution context () detects that task group  maps to direct alias  and uses direct alias  instead of task group  as indicated by an arrow . Accordingly, execution context () adds a set  of one or more tasks  to the direct alias  and may inline execute some or all of the tasks  from direct alias . Subsequent to the execution of all tasks  from the direct alias , execution context () may steal or attempt to steal tasks  from other direct aliases  before performing a join operation on the direct alias .","Task group  and direct alias  each include a counter  and an event indicator . Each counter  indicates the number of uncompleted tasks  in a corresponding task group  or direct alias . A counter  is incremented each time that a task  is added to a corresponding task group  or direct alias  and decremented each time that a task  of a corresponding task group  or direct alias  is completed. Each event indicators  is cleared any time that uncompleted tasks  are present in a corresponding task group  or direct alias  and set any time that uncompleted tasks  are not present in a corresponding task group  or direct alias .","When a join operation is performed on task group  by execution context (), execution context () attempts to inline execute any tasks  that have not been stolen or completed in task group . After all tasks  of task group  have been stolen or completed, execution context () iterates through the linked list of direct aliases  and gathers the events in event indicators  in task group  and each direct alias . Execution context () then performs a wait-for-all on these events to wait until event indicators  are cleared to indicate that all tasks  of task group  and all direct aliases  have completed. Scheduler  (or other execution contexts ) will eventually complete all of the tasks  and signal the events which will then allow the join operation in execution context () to proceed.","If the join operation for task group  is performed by execution context () or another non-bound execution context , then execution context () attempts to inline execute any tasks  that have not been stolen or completed in the direct alias . After all tasks  of the direct alias  have been stolen or completed, execution context () iterates through the linked list of direct aliases  and task group  and gathers the events in event indicators  in task group  and each direct alias . Execution context () then performs a wait-for-all on these events to wait until event indicators  are cleared to indicate that all tasks  of task group  and all direct aliases  have completed. Scheduler  (or other execution contexts ) will eventually complete all of the tasks  and signal the events which will then allow the join operation in execution context () to proceed.","Indirect aliases  are inherently canceled in the cancellation process described above with reference to  as follows. Because each indirect alias  was created subsequent to an execution context  stealing a task  from a task group , the execution context  that stole the task  appears in a list  for the embodiment of  or a list  for the embodiment of . If the task group  is cancelled, then the stolen task  and any tasks and\/or task groups  that descend from the stolen task  will be cancelled as part of the cancellation process for the task group  when the execution context  that stole the task  is identified using a list  or .","For direct aliases  in the cancellation process, scheduler  traverses the linked list of direct aliases indicated by map table  and cancels each direct alias  in each canceled task group  as follows. If an execution context  is executing a task  of a direct alias  inline, then scheduler  performs the cancellation as described above with reference to . If an execution context  is not executing a task  of the direct alias  inline, then scheduler  defers the cancellation of the execution context  until the execution context  attempts to execute a task  of the direct alias  inline. The scheduler  also cancels any tasks that descended from a task  of the direct alias  using the list or lists  for the embodiments of  or the list or lists  for the embodiment of .","The above embodiments may provide scalable and efficient mechanisms for expressing parallel work constructs such as a fork and join pattern. The embodiments may allow for scalable usage on multiple execution contexts and cancellation at arbitrary levels of a work tree.",{"@attributes":{"id":"p-0085","num":"0084"},"figref":"FIG. 11","b":["100","10","22","22"]},"Computer system  includes one or more processor packages , a memory system , zero or more input\/output devices , zero or more display devices , zero or more peripheral devices , and zero or more network devices . Processor packages , memory system , input\/output devices , display devices , peripheral devices , and network devices  communicate using a set of interconnections  that includes any suitable type, number, and configuration of controllers, buses, interfaces, and\/or other wired or wireless connections.","Computer system  represents any suitable processing device configured for a general purpose or a specific purpose. Examples of computer system  include a server, a personal computer, a laptop computer, a tablet computer, a personal digital assistant (PDA), a mobile telephone, and an audio\/video device. The components of computer system  (i.e., processor packages , memory system , input\/output devices , display devices , peripheral devices , network devices , and interconnections ) may be contained in a common housing (not shown) or in any suitable number of separate housings (not shown).","Processor packages  include hardware threads ()-(M). Each processor package  may include hardware threads  with the same or different architectures and\/or instruction sets. For example, hardware threads  may include any combination of in-order execution cores, superscalar execution cores, and GPGPU execution cores. Each hardware thread  in processor packages  is configured to access and execute instructions stored in memory system . The instructions may include a basic input output system (BIOS) or firmware (not shown), OS , a runtime platform , applications , and resource management layer  (also shown in ). Each hardware thread  may execute the instructions in conjunction with or in response to information received from input\/output devices , display devices , peripheral devices , and\/or network devices .","Computer system  boots and executes OS . OS  includes instructions executable by hardware threads  to manage the components of computer system  and provide a set of functions that allow applications  to access and use the components. In one embodiment, OS  is the Windows operating system. In other embodiments, OS  is another operating system suitable for use with computer system .","Resource management layer  includes instructions that are executable in conjunction with OS  to allocate resources of computer system  including hardware threads  as described above with reference to . Resource management layer  may be included in computer system  as a library of functions available to one or more applications  or as an integrated part of OS .","Runtime platform  includes instructions that are executable in conjunction with OS  and resource management layer  to generate runtime environment  and provide runtime functions to applications . These runtime functions include a scheduler function as described in additional detail above with reference to . The runtime functions may be included in computer system  as part of an application , as a library of functions available to one or more applications , or as an integrated part of OS  and or resource management layer .","Each application  includes instructions that are executable in conjunction with OS , resource management layer , and\/or runtime platform  to cause desired operations to be performed by computer system . Each application  represents one or more processes, such as process  as described above, that may execute with scheduler  as provided by runtime platform .","Memory system  includes any suitable type, number, and configuration of volatile or non-volatile storage devices configured to store instructions and data. Memory system  may include any suitable cache hierarchy, be configured as a shared or distributed memory system, and may embody a locality scheme such as a non-uniform memory access (NUMA) scheme. In addition, memory system  may be configured as a single instruction stream multiple different memory store (SIMD) system, a multiple instruction stream multiple different memory store (MIMD) system, or a computer cluster coupled through a messaging protocol such as concurrent read, concurrent write (CRCW), concurrent read, exclusive write (CREW), or parallel random access machine (PRAM).","The storage devices of memory system  represent computer readable storage media that store computer-executable instructions including OS , resource management layer , runtime platform , and applications . The instructions are executable by computer system to perform the functions and methods of OS , resource management layer , runtime platform , and applications  described herein. Examples of storage devices in memory system  include hard disk drives, random access memory (RAM), read only memory (ROM), flash memory drives and cards, and magnetic and optical disks.","Memory system  stores instructions and data received from processor packages , input\/output devices , display devices , peripheral devices , and network devices . Memory system  provides stored instructions and data to processor packages , input\/output devices , display devices , peripheral devices , and network devices .","Input\/output devices  include any suitable type, number, and configuration of input\/output devices configured to input instructions or data from a user to computer system  and output instructions or data from computer system  to the user. Examples of input\/output devices  include a keyboard, a mouse, a touchpad, a touchscreen, buttons, dials, knobs, and switches.","Display devices  include any suitable type, number, and configuration of display devices configured to output textual and\/or graphical information to a user of computer system . Examples of display devices  include a monitor, a display screen, and a projector.","Peripheral devices  include any suitable type, number, and configuration of peripheral devices configured to operate with one or more other components in computer system  to perform general or specific processing functions.","Network devices  include any suitable type, number, and configuration of network devices configured to allow computer system  to communicate across one or more networks (not shown). Network devices  may operate according to any suitable networking protocol and\/or configuration to allow information to be transmitted by computer system  to a network or received by computer system  from a network.","Although specific embodiments have been illustrated and described herein, it will be appreciated by those of ordinary skill in the art that a variety of alternate and\/or equivalent implementations may be substituted for the specific embodiments shown and described without departing from the scope of the present invention. This application is intended to cover any adaptations or variations of the specific embodiments discussed herein. Therefore, it is intended that this invention be limited only by the claims and the equivalents thereof."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The accompanying drawings are included to provide a further understanding of embodiments and are incorporated in and constitute a part of this specification. The drawings illustrate embodiments and together with the description serve to explain principles of embodiments. Other embodiments and many of the intended advantages of embodiments will be readily appreciated as they become better understood by reference to the following detailed description. The elements of the drawings are not necessarily to scale relative to each other. Like reference numerals designate corresponding similar parts.",{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIGS. 2A-2B"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIGS. 3A-3B"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIGS. 6A-6B"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIGS. 7A-7B"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 11"}]},"DETDESC":[{},{}]}
