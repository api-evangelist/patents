---
title: Multi-service management architecture employed within a clustered node configuration
abstract: A monitoring system is described which simplifies the management of complex, multi-tiered networks such as those used in large enterprises. One embodiment of the system is implemented on a cluster of application servers which are communicatively coupled together on a network to serve applications over the network to a plurality of clients. One embodiment of the monitoring system is built from a group of services. An administration service generates a plurality of runtime management beans (“MBeans”) on each of the server nodes of the cluster and associates each of the runtime MBeans with specified server node resources. In addition, in one embodiment, a notification service generates cluster-wide notifications in response to certain specified events associated with certain resources of certain MBeans. The notification service distributes the notifications across all, or a subset of, the server nodes of the cluster. In addition, a monitor service generates monitor MBeans corresponding to selected runtime MBeans. The monitor MBeans are arranged in a hierarchical tree structure and are configured to receive monitoring data from associated runtime MBeans.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07941521&OS=07941521&RS=07941521
owner: SAP AG
number: 07941521
owner_city: Walldorf
owner_country: DE
publication_date: 20031230
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS","Java Management Extensions (\u201cJMX\u201d)","An Exemplary Application Server System","Embodiments of a Management Architecture"],"p":["1. Field of the Invention","This invention relates generally to the field of data processing systems. More particularly, the invention relates to a notification architecture employed within a clustered node configuration.","2. Description of the Related Art","Multi-Tier Enterprise Application Systems","Traditional client-server systems employ a two-tiered architecture such as that illustrated in . Applications  executed on the client side  of the two-tiered architecture are comprised of a monolithic set of program code including a graphical user interface component, presentation logic, business logic and a network interface that enables the client  to communicate over a network  with one or more servers . A database  maintained on the server  provides non-volatile storage for the data accessed and\/or processed by the application .","As is known in the art, the \u201cbusiness logic\u201d component of the application represents the core of the application, i.e., the rules governing the underlying business process (or other functionality) provided by the application. The \u201cpresentation logic\u201d describes the specific manner in which the results of the business logic are formatted for display on the user interface. The \u201cdatabase\u201d  includes data access logic used by the business logic to store and retrieve data.","The limitations of the two-tiered architecture illustrated in become apparent when employed within a large enterprise. For example, installing and maintaining up-to-date client-side applications on a large number of different clients is a difficult task, even with the aid of automated administration tools. Moreover, a tight coupling of business logic, presentation logic and the user interface logic makes the client-side code very brittle. Changing the client-side user interface of such applications is extremely hard without breaking the business logic, and vice versa. This problem is aggravated by the fact that, in a dynamic enterprise environment, the business logic may be changed frequently in response to changing business rules. Accordingly, the two-tiered architecture is an inefficient solution for enterprise systems.","In response to limitations associated with the two-tiered client-server architecture, a multi-tiered architecture has been developed, as illustrated in . In the multi-tiered system, the presentation logic , business logic  and database  are logically separated from the user interface  of the application. These layers are moved off of the client  to one or more dedicated servers on the network . For example, the presentation logic , the business logic , and the database  may each be maintained on separate servers, ,  and , respectively.","This separation of logic components and the user interface provides a more flexible and scalable architecture compared to that provided by the two-tier model. For example, the separation ensures that all clients  share a single implementation of business logic . If business rules change, changing the current implementation of business logic  to a new version may not require updating any client-side program code. In addition, presentation logic  may be provided which generates code for a variety of different user interfaces , which may be standard browsers such as Internet Explorer\u00ae or Netscape Navigator\u00ae.","The multi-tiered architecture illustrated in may be implemented using a variety of different application technologies at each of the layers of the multi-tier architecture, including those based on the Java 2 Enterprise Edition\u2122 (\u201cJ2EE\u201d) standard, the Microsoft. NET standard and\/or the Advanced Business Application Programming (\u201cABAP\u201d) standard developed by SAP AG. For example, in a J2EE environment, the business layer , which handles the core business logic of the application, is comprised of Enterprise Java Bean (\u201cEJB\u201d) components with support for EJB containers. Within a J2EE environment, the presentation layer  is responsible for generating servlets and Java Server Pages (\u201cJSP\u201d) interpretable by different types of browsers at the user interface layer .","Although multi-tiered systems such as that illustrated in provide a more flexible and scalable architecture, they are extremely complex and difficult to manage. For example, providing management capabilities for multiple clusters of presentation layer servers, business layer servers and databases, and the dependencies between them requires a significant amount of administration overhead. In fact, many enterprise networks today employ a patchwork of incompatible and\/or proprietary management software, resulting in a burden on end users and network administrators. While new management technologies such as the Java Management Extensions (\u201cJMX\u201d) specification provide improved integration of management features, these technologies fail to address certain characteristics of large enterprise systems. Accordingly, new technologies which simplify the management of large enterprise networks are desirable.","A monitoring system is described which simplifies the management of complex, multi-tiered networks such as those used in large enterprises. One embodiment of the system is implemented on a cluster of application servers which are communicatively coupled together on a network to serve applications over the network to a plurality of clients. One embodiment of the monitoring system is built from a group of services. An administration service generates a plurality of runtime management beans (\u201cMBeans\u201d) on each of the server nodes of the cluster and associates each of the runtime MBeans with specified server node resources. In addition, in one embodiment, a notification service generates cluster-wide notifications in response to certain specified events associated with certain resources of certain MBeans. The notification service distributes the notifications across all, or a subset of, the server nodes of the cluster. In addition, a monitor service generates monitor MBeans corresponding to selected runtime MBeans. The monitor MBeans are arranged in a hierarchical tree structure and are configured to receive monitoring data from associated runtime MBeans.","Described below is a system and method for managing multiple application server clusters using a central management arrangement. Throughout the description, for the purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent, however, to one skilled in the art that the present invention may be practiced without some of these specific details. In other instances, well-known structures and devices are shown in block diagram form to avoid obscuring the underlying principles of the present invention.","Note that in this detailed description, references to \u201cone embodiment\u201d or \u201can embodiment\u201d mean that the feature being referred to is included in at least one embodiment of the invention. Moreover, separate references to \u201cone embodiment\u201d in this description do not necessarily refer to the same embodiment; however, neither are such embodiments mutually exclusive, unless so stated, and except as will be readily apparent to those skilled in the art. Thus, the invention can include any variety of combinations and\/or integrations of the embodiments described herein.","In many modern computing systems and networks, including those described above which utilize complex, multi-tier architectures, monitoring of system resources and components is of significant importance to ensure not only the reliability and security of information flow, but also to promptly detect system deficiencies so that they are corrected in a timely manner. The Java Management Extensions (\u201cJMX\u201d) specification defines an architecture for application and network management and monitoring in a J2EE environment. Using JMX, developers of Java technology-based applications can instrument Java platform code, create smart agents and managers in the Java programming language, and implement distributed management functionality into existing systems.","As illustrated in , the JMX architecture is divided into three levels: an \u201cinstrumentation\u201d level ; an \u201cagent\u201d level ; and a \u201cmanager\u201d level . At the instrumentation level , Java management beans (\u201cMBeans\u201d) ,  are used to manage manageable system resources , , respectively. A \u201cmanageable\u201d resource is a resource that has been instrumented in accordance with the JMX instrumentation-level specification. By way of example, a manageable resource may include components of a business application, a device, or the implementation of a service or policy. MBeans ,  are Java objects that represent the JMX manageable resources , .","An MBean server  at the agent level  is a registry for MBeans. A JMX \u201cagent\u201d is composed of an MBean server , a set of MBeans ,  registered with the MBean server  (i.e., representing managed resources , ), and one or more protocol adaptors and\/or connectors . The MBean server  is a J2EE component which provides services that allow the manipulation of MBeans. All management operations performed on MBeans are performed via the MBean server .","The manager level  provides management components that can operate as a manager or agent for distribution and consolidation of management services. Different management interfaces may be employed at the management level such as Web Browsers  and\/or proprietary management applications , . JMX managers  implemented within the manager level  provide an interface for management applications to interact with the agent, distribute or consolidate management information, and provide security.","A detailed description of the JMX Specification can be obtained from Sun Microsystems.","In one embodiment of the invention, the management techniques which are the focus of this application are used to manage resources within a cluster of application servers. An exemplary application server architecture will now be described, followed by a detailed description of the management architecture and associated processes.","An application server architecture employed in one embodiment of the invention is illustrated in . The architecture includes a central services \u201cinstance\u201d  and a plurality of application server \u201cinstances\u201d , . As used herein, the application server instances,  and , each include a group of server nodes , ,  and , , , respectively, and a dispatcher, , , respectively. The central services instance  includes a locking service  and a messaging service  (described below). The combination of all of the application instances ,  and the central services instance  is referred to herein as a \u201ccluster.\u201d Although the following description will focus solely on instance  for the purpose of explanation, the same principles apply to other instances such as instance .","The server nodes , ,  within instance  provide the business and\/or presentation logic for the network applications supported by the system. Each of the server nodes , ,  within a particular instance  may be configured with a redundant set of application logic and associated data. In one embodiment, the dispatcher  distributes service requests from clients to one or more of the server nodes , ,  based on the load on each of the servers. For example, in one embodiment, the dispatcher  implements a round-robin policy of distributing service requests (although various alternate load balancing techniques may be employed).","In one embodiment of the invention, the server nodes , ,  are Java 2 Enterprise Edition (\u201cJ2EE\u201d) server nodes which support Enterprise Java Bean (\u201cEJB\u201d) components and EJB containers (at the business layer) and Servlets and Java Server Pages (\u201cJSP\u201d) (at the presentation layer). Of course, certain aspects of the invention described herein may be implemented in the context of other software platforms including, by way of example, Microsoft. NET platforms and\/or the Advanced Business Application Programming (\u201cABAP\u201d) platforms developed by SAP AG, the assignee of the present application.","In one embodiment, communication and synchronization between each of the instances ,  is enabled via the central services instance . As illustrated in , the central services instance  includes a messaging service  and a locking service . The message service  allows each of the servers within each of the instances to communicate with one another via a message passing protocol. For example, messages from one server may be broadcast to all other servers within the cluster via the messaging service . In addition, messages may be addressed directly to specific servers within the cluster (i.e., rather than being broadcast to all servers).","In one embodiment, the locking service  disables access to (i.e., locks) certain specified portions of configuration data and\/or program code stored within a central database . A locking manager ,  employed within the server nodes locks data on behalf of various system components which need to synchronize access to specific types of data and program code (e.g., such as the configuration managers ,  illustrated in ). As described in detail below, in one embodiment, the locking service  enables a distributed caching architecture for caching copies of server\/dispatcher configuration data.","In one embodiment, the messaging service  and the locking service  are each implemented on dedicated servers. However, the messaging service  and the locking service  may be implemented on a single server or across multiple servers while still complying with the underlying principles of the invention.","As illustrated in , each application server (e.g., , ) includes a lock manager ,  for communicating with the locking service ; a cluster manager ,  for communicating with the messaging service ; and a configuration manager ,  for communicating with a central database  (e.g., to store\/retrieve configuration data). Although the lock manager , , cluster manager ,  and configuration manager ,  are illustrated with respect to particular server nodes,  and , in , each of the server nodes , ,  and  and\/or on the dispatchers ,  may be equipped with equivalent lock managers, cluster managers and configuration managers.","Referring now to , in one embodiment, configuration data  defining the configuration of the central services instance  and\/or the server nodes and dispatchers within instances  and , is stored within the central database . By way of example, the configuration data may include an indication of the kernel, applications and libraries required by each dispatcher and server; network information related to each dispatcher and server (e.g., address\/port number); an indication of the binaries required during the boot process for each dispatcher and server, parameters defining the software and\/or hardware configuration of each dispatcher and server (e.g., defining cache size, memory allocation, . . . etc); information related to the network management configuration for each server\/dispatcher (e.g., as described below); and various other types of information related to the cluster.","In one embodiment of the invention, to improve the speed at which the servers and dispatchers access the configuration data, the configuration managers ,  cache configuration data locally within configuration caches , . As such, to ensure that the configuration data within the configuration caches ,  remains up-to-date, the configuration managers ,  may implement cache synchronization policies.","One embodiment of a method for synchronizing configuration data across each of the application server instances ,  and the central services instance  is illustrated in . It is assumed initially that certain portions of the configuration data from the central database is cached locally within configuration cache  and configuration cache .","At  (), a user or network administrator attempts to modify the configuration data stored within configuration cache  on application server . In response, the configuration manager  attempts to acquire a lock on the relevant portions of the configuration data by transmitting a lock request to the locking service . If the configuration data is not being currently modified by another transaction, then the locking service locks the configuration data on behalf of the configuration manager . Once locked, the configuration managers  of other server nodes  will not be permitted to access or acquire a lock on the configuration data.","At , the configuration data within the configuration cache  of application server  is modified. At , the cluster manager  broadcasts an indication of the modified data to the cluster manager  on server node  and the cluster manager of other server nodes (i.e., via the messaging service ). At , the modifications to the configuration data are committed to the central database . At , the cluster manager  notifies the cluster manager  on server node  and the cluster managers of other server nodes of the central database update. In response, the configuration manager  invalidates the modified configuration data from its cache  and, at , loads the new configuration data from the central database . In one embodiment, the configuration manager  only downloads the portion of the configuration data which has been modified (i.e., rather than the entire set of configuration data). To determine whether it needs to update its configuration data, the configuration manager  compares the version of its configuration data with the version of the configuration data stored the central database.","In one embodiment of the invention, a management architecture specifically adapted to a clustered enterprise environment is employed within the application server system described with respect to . Specifically, in one embodiment, each server, dispatcher, and\/or central services instance (referred to generally as \u201cnodes\u201d) within the system is provided with a dedicated MBean server to register MBeans for monitoring specified system resources.","Virtually any type of system resource may be monitored in this manner including, but not limited to application resources, kernel resources, services, managers, components, interfaces and libraries associated with the individual nodes within the system. By way of example, within a J2EE engine, state information related to memory management, thread management, locking and licensing may be of particular importance. Once collected, this information may be combined and provided in a comprehensive manner to the end user or system administrator.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 6","FIGS. 3-4"],"b":["604","610","620","604","610","620","312","318","300"]},"In the illustrated embodiment, separate MBean servers , , and , are executed on each of the nodes , , and , respectively. Different types of MBeans may register with each of the MBean servers to monitor different types of system\/node resources. For the purpose of illustration, only two MBeans are shown registered with each MBean server in . Specifically, MBeans  and  are registered with MBean server  on node ; MBeans  and  are registered with MBean server  on node ; and MBeans  and  are registered with MBean server  on node . It will be appreciated that, in an actual implementation, significantly more MBeans may be registered with each MBean server and a significantly greater number of nodes may be employed on the system.","In one embodiment, a central monitoring service  employed within the distributed configuration hides the clusterization of the various MBean servers and provides a unified view of managed resources at the manager level . Specifically, monitor integration logic  associated with the central monitoring service  combines the monitoring data collected from each of the individual MBean servers , ,  and generates an comprehensive, logical view of the monitored resources. The monitoring data may then be displayed on a visual administrator  and\/or any other type of graphical user interface  (e.g., such as a standard Web browser). In one embodiment, the integration logic  combines the monitoring data based on monitor configuration information  (e.g., node layout, monitoring parameters, . . . etc) stored within the central database . As described below with respect to -, in one embodiment, the monitor integration logic  includes monitor MBeans arranged in a logical monitor tree hierarchy.","The central monitor service , clients  and\/or any other module\/object may communicate with the MBean servers , ,  via protocol adapters and\/or connectors, represented in  as blocks , , , , , and . Protocol adapters and connectors are similar in that they serve the same general purpose\u2014i.e., to expose an MBean server to managing entities. The primary difference between them is how they accomplish this task. Protocol adapters generally listen for incoming messages that are constructed in a particular protocol (e.g., such as like HTTP or SNMP). As such, protocol adapters are comprised of only one component that resides in the MBean server. For example, if client  is a browser-equipped client, it may communicate with the MBean server  via an HTTP protocol adapter .","By contrast, connectors are generally comprised of two components, one which resides on the MBean server and the other which resides on the client-side applications. Thus, connectors hide the underlying protocol being used to contact the MBean server (i.e., the entire process happens between the connector's two components). Throughout this detailed description, it is assumed that communication with an MBean server occurs via a protocol adapter and\/or connector of that MBean server, notwithstanding the fact that the protocol adapter\/connector may not be explicitly described or illustrated.",{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 7","i":"a ","b":["700","600","701","701","600","640"],"sub":["\u2014","\u2014"]},{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIG. 7","FIGS. 7"],"i":["b ","a","b "],"b":["700","705","706","706"]},"As described above, MBeans may be used to represent and provide data related to virtually any type of system resource (e.g., a manager, service, application, . . . etc). In one embodiment of the invention, during runtime, data may either be pulled periodically from the underlying MBean\/resource (\u201cpassive instrumentation\u201d) or, alternatively, the MBean\/resource may be configured to push the monitoring data to the monitor service using a specified event mechanism (\u201cactive instrumentation\u201d).","One particular embodiment, illustrated in , employs two different types of MBeans to perform passive and\/or active instrumentation functions: resource MBeans  (also referred to herein as \u201cruntime\u201d MBeans) and monitor MBeans . Resource MBeans, also referred to herein as \u201cruntime\u201d MBeans, are associated with the underlying system resources such as kernel resources, components, libraries, . . . etc. Monitor MBeans are generated by the central monitor service  and are mapped to the resource MBeans according to the monitoring configuration data  stored within the central database .",{"@attributes":{"id":"p-0059","num":"0058"},"figref":["FIG. 8","FIG. 8","FIG. 13"],"i":["b ","a"],"b":["850","852","805","854","805","805","640","230","805","600","230"]},"At , the central monitor service  installs the monitor MBeans  based on the monitor configuration data  stored within the central database . In one embodiment, the central monitor service  arranges the Monitor MBeans  within a hierarchical monitor tree , representing the logical relationships between the resources in each of the nodes in the cluster. As mentioned above, monitor information from the monitor tree  (or subsections thereof) may be displayed within a graphical visual administrator  or other user interface.","At , resource MBeans  are mapped to monitor MBeans  within the monitor tree , thereby establishing a link between each monitor MBean and the resource which it represents. For example, each monitor MBean  within the monitor tree  may have a resource identifier associated therewith, identifying the resource (or resource MBean) which it represents. Once the mapping is complete, the monitoring architecture is executed and, at , monitor updates are provided from the resource MBeans to their associated monitor MBeans. The monitor updates may then be displayed as a monitor tree within the visual administrator .","As mentioned above, different types of monitor updates may be employed within the system. By way of example, and not limitation, this may include string monitors which monitor text as a string value; integer monitors which monitor an \u2018int\u2019 value; table monitors which monitor a table containing a header and contents (e.g., wherein each header element is a string and each table element is a serializable object); state monitors which are similar to string monitors but have the additional property of assigning colors (e.g., green, yellow, red) to the string values (e.g., for indicating the state of the associated resource within the visual administrator); availability monitors which monitor a boolean value indicating whether the resource is available; frequency monitors which compute a frequency according to reported number of events given at specific times; quality rate monitors which compute an average (and actual) quality rate according to reported number of total tries and successful tries (e.g., one successful try from a total amount of 10 tries would result in a quality rate of 10%); pool monitors which monitor a pool characterized by (a) configurable values for minimum\/maximum pool size, initial pool size and increment size when increasing the pool, and (b) runtime values for the number of current used objects and current pool size; and cache monitors which monitor a cache characterized by a configurable maximum cache size and\/or the number of current used objects. It should be noted, however, that the foregoing examples are for the purpose of illustration only. The underlying principles of the invention are not limited to any particular monitor types.","In addition, as mentioned above, resource data may either be pulled periodically from the underlying resource MBean (\u201cpassive instrumentation\u201d) or, alternatively, the resource MBean may be configured to push the monitoring data to the monitor service using a specified event mechanism (\u201cactive instrumentation\u201d). Different examples of resource data transmission are described below with respect to -",{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 9","i":"a ","b":["802","803","802","803"]},"BY contrast, illustrates an embodiment in which the runtime MBean  transmits a runtime notification  to the monitor bean , thereby notifying the monitor MBean that new monitoring data is related to the associated resource  is available. Upon receiving the notification  from the runtime MBean , the monitor bean  may send a request  to the runtime MBean  requesting the new monitoring data. In response, the runtime MBean  transmits the information  including monitoring data regarding the associated resource  to the monitor MBean .",{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 9","i":"c ","b":["802","902","803","906","801","812","810","812","906"]},{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 10","b":["640","600","1000","800","1004","1006","1005","230"]},"In one embodiment, the XML technology is integrated with a Java 2 Platform Enterprise Edition (J2EE) engine for electronic data interchange, and due to XML's characteristics of being broad and relatively easy to use. To support and build the XML technology, including the XML file , in the J2EE engine, application programming interfaces (\u201cAPIs\u201d)  may be employed to use the XML file  to configure various components and application modules. For example, the XML file  may be used to facilitate components and modules of the monitor service  to generate the monitor tree .","According to one embodiment, the API  may is a Java-compliant API. Examples of Java APIs include the J2EE XML API, Java API for XML Processing (\u201cJAXP\u201d), Java Messaging Service (\u201cJMS\u201d) API, Java API for XML Messaging (\u201cJAXM\u201d), Java Transaction API (\u201cJTA\u201d), Java API for XML-Remote Procedure Call (\u201cJAX-RPC\u201d), Java API XML Binding (\u201cJAXB\u201d), and Java API for XML Registries (\u201cJAXR\u201d), to name a few. The API  may facilitate both the creation and customization of the monitor tree  as well as the reporting of the monitoring information and values. Multiple XML files may be used and similarly, multiple API may be used to generate the monitor tree .","As mentioned above, the XML file  may include semantics  and directives  used by the monitor service  to generate the monitor tree . The semantics  of the XML file  comprises the primary information about the monitor tree , the monitor MBeans (monitor beans), and the resources to be monitored by each of the MBeans. The semantics  include a code or a set of instructions for generating the monitor tree . The set of instructions may include, for example, the instructions for setting color-coded marks representing corresponding status of the resources within the visual administrator  or other graphical interface or system  (e.g., within the displayed monitor tree). For example, in one embodiment, a green mark indicates monitoring of the corresponding resource; a yellow mark indicates continuous monitoring of the corresponding resource, and may also indicate that the resource being monitored may be reaching a critical value or stage; and a red mark indicates that the corresponding resource may have reached a critical value. Finally, a white mark may indicate inactivity, or that the corresponding resource is not being monitored. Of course, the underlying principles of the invention are not limited to any particular set of color-coded marks.","According to one embodiment, the directives  specify the form in which the monitor tree  is generated. Stated differently, the directives  provide installation instructions on how the semantics  are to be implemented. For example, the directives  may include one or more templates to match various monitor beans with corresponding associated resources at various nodes of the monitor tree . The monitor service  employs the API  to generate the monitor tree  based on the semantics  and the directives .","The semantics  and the directives  of the XML file  may include elements (e.g., similar to HyperText Markup Language (\u201cHTML\u201d) tags) to provide context to the information contained within the XML file . The XML file  may be document-centric to be used by humans or data-centric to be used by another software application or module containing data extracted from a database, such as the central database , and may be submitted to the API .",{"@attributes":{"id":"p-0073","num":"0072"},"figref":"FIG. 11","b":["1005","1004","1006","1005","1102","1005","1106","1005","1102","1004","1006","1005"]},"The XML parser  may provide an application  (or other type of software module) with access to the elements of the XML file  to establish a link between the XML file  and other components or modules, such as the application programming interface (\u201cAPI\u201d) , of the monitoring architecture . For example, the API  and the XML parser  may be used to generate the monitor tree  (e.g., by assigning the various monitor MBeans  to their associated resources at various nodes within the monitor tree ). According to one embodiment, for the purposes of customizing the monitor tree , the API  may include a bootstrapper which includes a code or a sequence of codes to initiate relationships between component agents and the MBeans . Customizing of the monitor tree  may include establishing values (e.g., thresholds, descriptions, . . . etc) that may be registered along with each monitor MBean .","The XML file  may be parsed in several ways including using the Document Object Model (\u201cDOM\u201d), which reads the entire XML file  and forms a tree structure, or using the Simple API for XML (\u201cSAX\u201d), which is regarded as an event-driven parser that reads the XML file  in segments. The API  may be a Java Management Extensions (JMX)-based API. Examples of Java or JMX-based APIs include J2EE XML API, Java API for XML Processing (\u201cJAXP\u201d), Java Messaging Service (\u201cJMS\u201d) API, Java API for XML Messaging (\u201cJAXM\u201d), Java Transaction API (\u201cJTA\u201d), Java API for XML-Remote Procedure Call (\u201cJAX-RPC\u201d), Java API XML Binding (\u201cJAXB\u201d), and Java API for XML Registries (\u201cJAXR\u201d).","As described above with respect to , runtime MBeans  may be configured to actively transmit monitoring information related to the resource  with which they are associated. In addition, one embodiment illustrated in , employs a notification service  to provide a comprehensive view of all of the notifications generated by the runtime MBeans across the entire cluster. For example, certain MBeans may be configured to generate active \u201cnotifications\u201d to the notification service  on certain specified events such as start\/stop, get\/set properties, etc, of their associated resources. The notification service  then provides a cluster-wide indication of these specified events to any visual administrator (or other type of client) coupled to any node within the cluster. Two different users connected via two different machines may use the notification service to view a comprehensive, up-to-date state of the system.","Thus, referring to the specific example illustrated in , MBean  may be configured to generate active notifications in response to certain specified events. In response to detecting one of the events, the MBean  generates a notification which is received by the notification service  (i.e., via MBean server ). The notification service  then communicates the MBean notification to all other nodes within the cluster and provides the notification to any objects that are registered with the notification service  as listeners. Accordingly, the notification will be viewable from client  coupled directly to node , as well as client , coupled directly to the node on which the notification was generated. In other words, a single, unified view of cluster-wide notifications is available from any of the nodes in the cluster. In one embodiment, the notification service  utilizes the message passing architecture provided via the central services instance  shown in  to enable cluster-wide communication of MBean notifications (e.g., by exchanging notifications via the messaging service ).","Notifications may take on various forms while still complying with the underlying principles of the invention. In one embodiment, each notification will have a time stamp, sequence number, and a human-readable message indicating the type of notification, and the reason for the notification (e.g., a particular threshold value was reached, a resource went offline, . . . etc).","In one embodiment, a notification application programming interface is defined to enable use of notifications. For example, a \u201cNotification Broadcaster\u201d class may be employed for notification generators (e.g., MBean  in the previous example). In addition, a \u201cNotification Listener\u201d class may be employed for any objects interested in receiving notifications. In one embodiment, a \u201cNotification Filter\u201d class may also be defined for filtering out certain types of notifications (e.g., on behalf of certain specified Notification Listeners).",{"@attributes":{"id":"p-0080","num":"0079"},"figref":"FIG. 13","b":["600","1201","805","1308"]},"As described above with respect to -, the administration service  provides instrumentation of certain modules and components (e.g., libraries and interfaces) and also facilitates registration of MBeans with the MBean server  via the monitor service . Recall that monitor MBeans  registered with the MBean server  represent individual tree nodes (nodes) of the monitor tree . Each of the monitor MBeans  may be used, for example, for reboot and shutdown, as well as for defining the type of nodes (e.g., dispatcher or server type nodes) and the resources associated with each of the nodes, for which monitoring information may be retrieved from runtime MBeans . The runtime MBeans  may be used for monitoring of all clusters and associated resources .","In one embodiment, the administration service  provides for registration of two logical types of MBeans: standard MBeans and specific beans. Standard MBeans may provide standard functionality of start\/stop and get\/set properties of their associated resources. Standard MBeans may be registered by default for all deployed components or resources (e.g., kernel, libraries, interfaces, services, etc). By contrast, specific beans may provide component-specific functionalities that may vary from one component to another. To have specific beans, a component may register an object that may implement a specific interface to list the processes available for its management and to extend the management interface (e.g., \u201ccom.company.engine.frame.state. ManagementInterface\u201d).","For kernel resources, a standard bean may be registered with each manager having a specific bean. A prerequisite for this may be to return a non-null value in a method (e.g., getManagementInterface( )) from the manager interface. For libraries and interfaces, only standard beans may be registered. For services, except for the already registered standard beans, each of the services may register specific beans, and implementation of the management interface may also cause a specific bean to be registered for that particular service.","The adapter service  employed in one embodiment of the invention is part of the manager level  of the monitoring architecture (see, e.g., ). In one embodiment, the adapter service  includes (1) a remote connector ; (2) a \u201cconvenience\u201d interface ; (3) a \u201cswing-based\u201d Graphical User Interface (\u201cGUI\u201d) ; and (4) a shell command interface . The adapter service  provides remote access to the MBean server  via The remote connector . For example, users may connect from a remote client and view monitoring information relating to monitored resources  via the remote connector . Moreover, when used in conjunction with the notification service , users will be provided with a comprehensive view of monitoring data from the entire cluster, as described above with respect to .","The convenience interface  may allow users to remotely access the MBean server  using remote administration tools. Remotely accessing the MBean server  may include remotely accessing and working with the MBeans as registered by the administration service  based on the semantics of the resources  that are instrumented and monitored by the MBeans. Stated differently, the adapter service  provides a high-level view of the MBean server  and all other MBean servers within the cluster (e.g., as represented by the monitor tree ). This higher level view may be represented by a monitor tree, the root of which is an MBean that instruments the cluster. The adapter service  may interpret the monitor tree  and provide interfaces for managing each type of node within the monitor tree . Various different node types may be defined. By way of example, the node types within the monitor tree may include a root node representing the cluster (\u201cTYPE_CLUSTER_MBEAN\u201d), a basic cluster node type representing a node within the cluster (\u201cTYPE_CLUSTER_NODE_MBEAN\u201d), a standard MBean that instruments the kernel of a cluster node (\u201cTYPE_KERNEL_MBEAN\u201d), a standard MBean that instruments a service (\u201cTYPE_SERVICE_MBEAN\u201d), a standard MBean that instruments a library (\u201cTYPE_LIBRARY_MBEAN\u201d), a standard MBean that instruments an interface (\u201cTYPE_INTERFACE_MBEAN\u201d), a standard MBean that instruments a defined group of clusters (\u201cTYPE_GROUP\u201d), and all other MBeans (\u201cTYPE_UNSPECIFIED_MBEAN\u201d). It should be noted, however, that the underlying principles of the invention are not limited to any particular set of MBean types.","The swing-based GUI  employed in one embodiment of the invention may use the convenience interface  and the monitor tree  to represent the management functionality of the monitoring architecture to a network administrator or end user. The console counterpart of the GUI administrator may consist of various shell commands  that may be grouped together in an administration command group.","Embodiments of the invention may include various steps as set forth above. The steps may be embodied in machine-executable instructions which cause a general-purpose or special-purpose processor to perform certain steps. Alternatively, these steps may be performed by specific hardware components that contain hardwired logic for performing the steps, or by any combination of programmed computer components and custom hardware components.","Elements of the present invention may also be provided as a machine-readable medium for storing the machine-executable instructions. The machine-readable medium may include, but is not limited to, flash memory, optical disks, CD-ROMs, DVD ROMs, RAMs, EPROMs, EEPROMs, magnetic or optical cards, propagation media or other type of machine-readable media suitable for storing electronic instructions. For example, the present invention may be downloaded as a computer program which may be transferred from a remote computer (e.g., a server) to a requesting computer (e.g., a client) by way of data signals embodied in a carrier wave or other propagation medium via a communication link (e.g., a modem or network connection).","Throughout the foregoing description, for the purposes of explanation, numerous specific details were set forth in order to provide a thorough understanding of the invention. It will be apparent, however, to one skilled in the art that the invention may be practiced without some of these specific details. For example, although the embodiments of the invention described above focus on a JMX implementation within a J2EE environment, certain underlying principles of the invention are not limited to any particular specification. For example, the invention may be implemented within the context of other object-oriented and non-object-oriented programming environments, and may also be employed within future releases of the Java standard, or other standards (e.g., Microsoft's. NET standard).","Accordingly, the scope and spirit of the invention should be judged in terms of the claims which follow."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["A better understanding of the present invention can be obtained from the following detailed description in conjunction with the following drawings, in which:",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1","i":"a "},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1","i":"b "},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIGS. 7","i":["a","b "]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 8","i":"a "},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 8","i":"b "},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIGS. 9","i":["a","c "]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIGS. 10-11"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 13"}]},"DETDESC":[{},{}]}
