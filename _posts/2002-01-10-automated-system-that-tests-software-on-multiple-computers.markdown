---
title: Automated system that tests software on multiple computers
abstract: A system by which a software product may be tested on multiple client computers on various platforms. Product developers submit requests for tests on their products, in the form of test packets, to a test component, via an API. For each platform and language (i.e., group) on which a product developer wants a product tested, the product developer provides a test packet that defines tests that the product developer wants conducted on the product in that group. The test component searches, via an autolab component, for an available client machine for performing the tests in the test packet. The autolab component finds an available client computer, and the client machine is assigned the test packet. The client machine performs the tasks in the test packet, and forwards the results back to the test component.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07437713&OS=07437713&RS=07437713
owner: Microsoft Corporation
number: 07437713
owner_city: Redmond
owner_country: US
publication_date: 20020110
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["This invention relates generally to software, and more particularly to software testing.","Contemporary tests on software are performed in large labs that have multiple computers. To provide test data from a variety of platforms, testing may be performed on a variety of computers having different platforms (e.g., operating systems and upgrade levels), and\/or languages. To limit the number of computers that are to be used in the lab, some of the individual computers may have several different platforms that are available on the computers, so that tests may be conducted on the same computers in multiple platforms.","To test the performance of a task within a particular software application, the software is loaded (if not already present) into a number of the computers and operators perform the task on each of the computers. For example, an application may be loaded and a particular user interface of the application may be displayed. Attempts may be made to display the user interface in several different platforms and\/or languages. In the process of testing multiple platforms, a technician may run the task in one platform on a computer, reboot the computer to another platform, and run the test again. In addition, multiple computers having multiple platforms may be available, and technicians may perform the task on each of the multiple computers. In either situation, although a single technician may be able to perform tests on multiple machines, simultaneously performing tasks on multiple computers is an expensive process, requiring a large number of technicians to maintain several machines. In practice, only a subset of the available computers is used, and other computers sit idle between test processes, which wastes resources.","The present invention provides a system by which a software product may be tested on multiple clients in various environments and with minimal input from test technicians. To this end, one implementation of the present invention provides a test component that includes a database (e.g., a Structured Query Language (SQL) database). Product developers submit requests for tests on their products, e.g., in the form of test packets, to the test component, via an Application Programming Interface (API). For each platform and language (i.e., group) on which a product developer wants a product tested, the product developer provides a test packet that defines tests that the product developer wants conducted on the product in that group. The test packet includes a header having any pre-processing information, a list of specific tests that are to be run, and footer information, such as specifying clean-up information for the tests.","The test component places a new test packet in a database where it is placed in \u201cpending\u201d status. The test component then searches, via an autolab component, for an available client machine for performing the tests in the test packet. The client computers may be available to the test technicians, or may be located remotely. The autolab component finds an available client computer, and then places the new test packet in \u201cassigned\u201d status. The available client computer is then assigned the test packet.","In accordance with another aspect of the present invention, the client computers that are used with the test component are partitioned into three components: test (lab client daemon), control (lab client manager), and image. The lab client daemon is a standalone application capable of communicating with the test component directly (e.g., via ActiveX Data Objects (ADO)), or via a thin client, which may be used to translate the a communication from a client computer that is a different protocol (e.g., via the Transmission Control Protocol and the Internet Protocol (TCP\/IP)) than the protocol of the test component to a protocol understood by the test component. When the client machine is not performing a task, the lab client daemon continually polls the test component to inform the test component that the client is available for performing tests. When the autolab component sends a test packet to the client, the lab client daemon receives the test packet and instructs the lab client manager to perform the tests within the client, which may include loading of a particular operating system and\/or setting a particular language, and performing particular pre-processing steps as defined via the header. The lab client manager reports the results to the lab client daemon, and the lab client daemon sends results to the test component, e.g., \u201cpass\u201d or \u201cfail.\u201d The pass or fail information is stored in a \u201ccomplete\u201d status file at the test component. The lab client daemon then resumes pinging of the test component to indicate that it is available for another test packet.","Other advantages will become apparent from the following detailed description when taken in conjunction with the drawings, in which:","Exemplary Operating Environment",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1","b":["100","100","100","100"]},"The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers, server computers, hand-held or laptop devices, multiprocessor systems, microcontroller-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like.","The invention may be described in the general context of computer-executable instructions, such as program modules, being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, and so forth, which perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.","With reference to , an exemplary system for implementing the invention includes a general-purpose computing device in the form of a computer . Components of the computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus also known as Mezzanine bus.","Computer  typically includes a variety of computer-readable media. Computer-readable media can be any available media that can be accessed by the computer  and includes both volatile and nonvolatile media, and removable and non-removable media. By way of example, and not limitation, computer-readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer-readable instructions, data structures, program modules, or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can accessed by the computer . Communication media typically embodies computer-readable instructions, data structures, program modules, or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer-readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile optical disk  such as a CD ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  though a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media, discussed above and illustrated in , provide storage of computer-readable instructions, data structures, program modules, and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers herein to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices such as a keyboard  and pointing device , commonly referred to as a mouse, trackball or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, a touch-sensitive screen of a handheld PC or other writing tablet, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . In addition to the monitor, computers may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface  or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are Exemplary and other means of establishing a communications link between the computers may be used.","Automated System that Tests Software on Multiple Computers",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 2","b":["200","200","202","2041","204","204","206","208","210","202","206","208","210","212","212","212","214","214","214","202"],"sub":["2 ","K","1","2 ","P","1","2 ","Q"]},"The test component  may be provided, for example, on a server computer (e.g., the remote computer ). Alternatively, the elements of the test component  may be distributed over a number of computers. Moreover, many of the elements of the test component  may be combined to form a single component, or the functions of the many components may be spread over multiple elements on the same machine or on multiple machines.","Test conditions may be provided to the test component  in a number of different ways. In general, the test conditions are provided as tasks that a product developer client  would like to be performed in particular platform(s) and language(s). Hereinafter, for ease of discussion, a selected platform and language are referred to herein as a \u201cgroup.\u201d In the embodiment shown in , each product developer client  provides a separate test packet , ,  for each group on which the product developer wants a product tested. The separate test packet defines tasks that the product developer wants conducted on the product in that group. The number of test packets , ,  generated is set by the product developer client , and, in the example shown, the product developer client provides L test packets, the product developer client provides M test packets, and the product developer client provides N test packets. A product developer client  may provide only one test packet, or may provide several test packets, depending upon the scope of the testing desired.","Test conditions may be generated or produced in other ways. For example, the test component  may be provided test conditions, along with a list of groups in which a product developer client is interested, and from that information may generate the appropriate number of test packets.","An example of the structure of a test packet  is shown in . The test packet  includes a header  having pre-processing information, such as a list of files that are to be copied onto a client machine  or  before testing begins. The test packet  further includes the test steps, or tasks , that are to be conducted (e.g., the command lines of the test), and footer information , such as information that specifies clean-up information for the tests.","The test component  includes an application programming interface (API)  for receiving the test packets , , . A database  is located in, or otherwise is associated with, the test component . The database  is preferably a relational database, and may be distributed over several machines. As an example, the database may utilize Microsoft Corporation's SQL Server technology, but other database products may be used.","The test component  also includes a high-level interface  for communicating with clients having compatible communication software (i.e., that can communicate using the protocol utilized by the interface ). The interface  permits client computers (e.g., client test computers , . . . ) that operate under compatible protocols to communicate with the test component  directly. As an example, the high-level interface  may be a high-level interface such as is provided in Microsoft Corporation's ActiveX\u00ae Data Objects (ADO) programming model, and the client computers , . . . may include communication software that is capable of communicating with the high-level interface. The interface of the ADO provides enhanced data access support, but other interfaces that utilize protocols that provide direct communication between the client computers , . . . , and the test component  may be used.","If desired, a thin client  may be provided that is in communication with, or is otherwise associated with, the interface . The thin client  provides a translation of a protocol not compatible with the high-level interface  (e.g., TCP\/IP) to a protocol that is compatible (e.g., ADO). For client computers that are not configured to communicate directly through the high-level interface  with the test component , the thin client  provides a means to communicate with the high-level interface . For example, the thin client  may be configured to permit client computers , . . . to communicate with the test component  via TCP\/IP protocol. In addition, the thin client  permits a client computer  to communicate with the test component before a direct connection is established with the high-level interface , as is further described below. To this end, the thin client  performs a translation of the information sent by the client computer so that the information may be utilized by the high-level interface . Although using direct communication between client computers is desired (e.g., direct communication between the interface  and the client computers , . . . ), use of the thin client  permits other client computers (e.g., the client computers , . . . ) to be used with the test system , despite the their lack of the necessary software to directly communicate via the high-level interface .","The test component  also includes an autolab component  that is configured to search for client computers  or  that are available to run a test, and assigns the tests to available client computers. The function and operation of the autolab component  is further described below.","In accordance with one aspect of the present invention, as can be seen in , the client machines ,  that are used with the test component  are partitioned into three components: test (lab client daemon) , control (lab client manager) , and image . The lab client daemon  is a standalone application configured to communicate with the test component . The lab client daemon  may communicate with the test component directly through the high-level interface  (e.g., via ADO), or may communicate via the thin client  (e.g., via TCP\/IP). The lab client manager  is configured to cause the tests and other tasks in a test packet to be performed in the image . The functions and operation of each of these components are further described below.","Turning now to an explanation of the operation of the present invention, , , , and  generally show processes that may be performed by the test component  in accordance with the present invention.  shows a general overview of a process for testing software on multiple client machines in accordance with one aspect of the present invention. As described above, tasks in a test packet may be conducted by a client machine  or a client machine , depending upon the protocol available on the client machine. For ease of reference, unless specific to one of the client machines  or , the operations herein will be discussed as being performed by a client machine \u201c, ,\u201d emphasizing that either may be used.","In any event, beginning at step , the test component  receives a test packet (e.g., one of the test packets , , from the product developer client ) via the API . The received test packet is placed in a \u201cpending\u201d status file  () in the database  at step .","At step , the autolab component  retrieves one of the pending test packets from the database . A determination is made if all tests have been run on the packet at step  (e.g., whether a record count is zero), and, if so, the process loops back and the next packet is retrieved at step . If not, then step  branches to step , where the test component  searches, via the autolab component , for an available client machine ,  for performing the tests in the test packet. As further described below, an available client machine ,  may be idle and awaiting a test packet, or may already be running the tasks in a test packet, but should be capable of (e.g., includes the proper groups and applications for) running the tasks of the test packet.","At step , the autolab component  configures the test packet to a personalized test package for the available client computer , . The test package is then placed, at step , in an \u201cassigned\u201d status file  (). The client machine ,  is then assigned the test packet at step . Configuring and assigning the test package is described further in connection with , below.","The tasks in the test packet are conducted by the client computer ,  at step  (described further in connection with ). The client computer ,  forwards the results of the test (pass or fail) to the test component  (step ), and the results are placed in a completed status file  (), and the record count for the test packet is incremented, at step . The process then loops back to step , where a determination is made whether all tests for the test packet have been conducted (e.g., whether the record count for the test packet is zero).",{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 7","FIG. 10"],"b":["700","212","214","212","214"]},"If a client computer ,  is available, step  branches to step , where the test component  checks to see if the computer is usable. That is, the autolab component  determines whether the client computer includes a group and application that meets the requirements of a pending test packet. If not, the process branches back to step , where a check is made for other idle client computers , . If the client computer includes a group and application that meets the requirements of a pending test packet, then step  branches to step , where the client computer is assigned a test packet ().",{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 8","b":["212","214","800","230","212","214","802","212","214","802","804"]},"If there are not pending test packets that can be run on the client computer, then step  branches to step , where a determination is made whether there are pending test packets that may be run on the client computer ,  with reimaging. That is, although the existing group may not be used, a determination is made whether the computer includes a group that may be used. Using such a group may require rebooting of the client computer ,  to a different operating system and\/or installation of software on which to run the tests.","If the client computer does not include a group and application that may be used, then step  branches to step , where the client computer ,  is not assigned a test packet. If the computer does include a group and application(s) that may be used, then step  branches to step , where the reimage time of imaging the proper group and\/or applications is calculated. At step , operating system installation commands are prepended to (i.e., attached to the beginning of) the test packet, and at step  application installation commands required by the test are prepended to the test packet. The process then proceeds to step , where a personalized test package is built for the client, which may include, for example, the prepended operating system installation commands and application installation commands, and application commands.","At step , the execution time for the package is calculated. If desired, an execution time may be defined at which the test component may not allow the tasks to be performed by the computer. If too long, then step  branches back to step , where a new package is formed. If not too long, then step  branches to step , where the changes in the package are committed to the database (e.g., saved in the assigned status file ).","The autolab component  may include managing abilities, such as in a management component  (), that permit the autolab component  to pre-assign test packages to a client computer ,  based upon the client computer's imaging abilities. The available client machine may be idle, or may be capable of performing the tasks, but at the time of assignment of the task, is already performing another task. If the client computer ,  is already performing another task, the test packages may be maintained, for example, in a message queue  () for a client computer that is maintained, for example, in the database . A separate message queue , . . . may be maintained for each client computer , . Items may be placed in the message queue  based upon the relative availability of the client computer ,  (e.g., how few tasks are in a respective client computer's message queue as compared to the number of tasks in other computer's message queue). The client computer , , after completing a task, may check its message queue  for the next task or bundle of tasks (a \u201cjob\u201d). In this manner, test packets and\/or tasks may efficiently be assigned to client computers ,  before the client computers are idle. Thus, one or more test packages may be available for the client computer ,  immediately after the tasks of a previous test package have been completed. In accordance with one aspect of the present invention, the management component  may even reorder test packets, or tasks within those packets, for more efficient running of the client computer , .",{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 9","FIG. 6"],"b":["232","900","212","214","212","214","902","232","904","608","906","608"]},"After the subtasks have been reordered, the reconstructed job is inserted into the client computer's message queue  (step ). The reconstructed job may then be accessed by the client computer when the client computer is next available (step ). The tasks of the restructured job may be accessed one task at the time by a client computer , , or may be issued to the client computer as a job.","Some processes performed by the client machines ,  are generally shown in .  shows a general overview of the operation of the lab client daemon  in accordance with one aspect of the present invention. Beginning at step , a client computer ,  starts up and connects to the test component  via the thin client . The lab client daemon  posts a message to the test component  (step ), and at step , the test component tries to initiate connection through the high-level interface  (e.g., ADO). If successful, then step  branches to step , where the lab client daemon  calls the test component  to request a task.","The request to initiate connection through the high-level interface  may fail, either because of a lack of an answer to the request, or because the client computer ,  is not capable of communicating via the high-level interface. If the request returns failure, then step  branches to step , where the connection is established through the thin client . The lab client daemon  then calls the test component  to request a task at step .","At step , a determination is made whether a work item, such as a test package, task, or job, has been returned by the test component . If not, the process loops back to step , where the lab client daemon  again requests a task. This process continues, so that when the client machine ,  is not performing a task, the lab client daemon  continually polls the test component to inform the test component that the client is available for performing tests. The lab client daemon  pings the test component  (e.g., on an interval) until the lab client daemon receives a task.","If the autolab component  sends a test package to the client computer, step  branches to step , where the lab client daemon  receives the test package and instructs the lab client manager  to perform the tasks within the image . These tasks may include loading of a particular operating system and\/or setting a particular language, and performing particular pre-processing steps as defined via the header. The lab client manager  reports the results to the lab client daemon  (step ), and the lab client daemon sends a \u201cpass\u201d or \u201cfail\u201d to the test component (step ). As described earlier, the pass or fail information is stored in the complete status file  at the test component . The process then loops back to step , where the lab client daemon  resumes pinging of the test component  to indicate that it is available for another test package or job.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 11","b":["404","404","402","404","404","202"]},"In any event, beginning at step , upon start of the lab client manager , the lab client manager requests a task or list of tasks to perform (e.g., from the test component  via the lab client daemon ). The task or tasks are returned at step , and the lab client manager  begins operation of a task in step .","At step , a determination is made whether a status request is included in the task. A status request calls for a report of the status of the task at a particular point in the operation of the task, such as at imaging of a particular window, or at completion of the task. If a status request is not present, step  branches to step , where a determination is made whether the task has been completed. If a status request is present, then step  branches to step , where the lab client manager  provides status information (e.g. to the test component  via the lab client daemon ). The process then proceeds to step , where a determination is made whether all tasks have been completed. If not, step  branches back to step , where operation of the task continues. If the task is complete, then step  branches back to step , where the lab client manager  requests another task.","The present invention provides a number of benefits over prior art testing systems. The testing system is designed so that it may be used with remote client test computers. In addition, the test component  efficiently assigns tasks and\/or test packages to the client computers so that an optimal number of the computers may be utilized at one time. The operations may be performed with minimal test technician involvement, thus providing an inexpensive test solution.","While the invention is susceptible to various modifications and alternative constructions, a certain illustrated embodiment thereof is shown in the drawings and has been described above in detail. It should be understood, however, that there is no intention to limit the invention to the specific form or forms disclosed, but on the contrary, the intention is to cover all modifications, alternative constructions, and equivalents falling within the spirit and scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0012","num":"0011"},"figref":["FIG. 4","FIG. 2"]},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 6","FIG. 2"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 9","FIG. 2"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 10","FIG. 2"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 11","FIG. 2"]}]},"DETDESC":[{},{}]}
