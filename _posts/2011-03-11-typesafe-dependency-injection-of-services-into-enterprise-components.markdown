---
title: Type-safe dependency injection of services into enterprise components
abstract: A system, method, and medium are disclosed for implementing an application component container. The container is configured to detect that a component managed by the container is dependent on an interface that is implemented by a dynamic module provided by a dynamic module system. The container uses a dependency injection framework to inject the implementation into the dependent component in a type-safe manner.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08856734&OS=08856734&RS=08856734
owner: Oracle International Corporation
number: 08856734
owner_city: Redwood City
owner_country: US
publication_date: 20110311
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF EMBODIMENTS"],"p":["As software systems have become more complex, code modularity has become an increasingly important design goal. Building software systems using modular components enables developers to reuse code, modify software quickly when requirements evolve, mitigate costs of producing multiple versions, and reduce development time by integrating pre-written, third-party components.","Many tools and frameworks have been proposed for facilitating modular software development. For example, Java Enterprise Edition\u2122 (Java EE) is a widely used application server environment for enterprise server programming in Java\u2122. The platform includes a component container that provides a set of services, application programming interfaces (APIs), and protocols that facilitate modular software development. The container also provides runtime support, such as lifecycle management, security frameworks, deployment services, automatic threading, transaction management, and other services. A container that provides such services, such as the Java EE container, may be referred to herein generally as an application server container or component container. The components to which the container provides such services are said to be managed by the container.","Using Java EE standards, developers can define web-tier components (e.g., Servlets), business-tier components (e.g., Enterprise Java Beans\u2122 or EJBs\u2122), components for accessing enterprise information systems (e.g., JDBC\u2122), and others, and assemble applications from these components. At runtime, the assembled application can be deployed on the container as a package of components (e.g., using a JAR). The container provides the application components with services, such as lifecycle management, security, deployment, threading, transaction management, persistence, remote invocation, context propagation, and others. By providing such services, an application server component container, such as that provided by Java EE, enables programmers to concentrate on developing application logic rather than on wiring components together and implementing commonly required and\/or low-level functionality.","There has also been much interest in service-oriented architectures and dynamic module systems. A dynamic module system is a framework that allows components to be deployed as independent modules and to dynamically discover and use one another during runtime. Such systems are \u201cdynamic\u201d in that components may enter and\/or exit the system independently of other components. For example, OSGi is a module system for building modular, service-oriented Java\u2122 applications. OSGi provides a service registry where developers can register and unregister services. Each service listed by the service registry may have multiple implementations and an OSGi component may query the service registry to discover and retrieve various implementations of a particular service. In response to a service query, an OSGi container may determine an appropriate implementation that satisfies the query and return it to the querying component. Using the handle, the discovering object may then invoke the service. Related services are often deployed in OSGi as a group of implementing classes known as a bundle or module. Such a module may define a set of capabilities (i.e., service interfaces), requirements (i.e., dependencies), and classes (i.e., implementations). OSGi includes a lifecycle layer that enables modules to be dynamically installed, started, stopped, updated, and uninstalled during runtime, which enables reconfiguration without system downtime.","A system, method, and medium are disclosed for implementing an application component container. The container is configured to detect that a component managed by the container is dependent on an interface that is implemented by a dynamic module, which is provided by a dynamic module system. The container uses a dependency injection framework to inject the implementation into the dependent component in a type-safe manner. In some embodiments, the component container may correspond to a Java EE component container and the dynamic module system may correspond to an OSGi implementation.","In some embodiments, the container, or a subcomponent such as a CDI portable extension, may receive notification of a deployment event of the component. In response, the container or subcomponent may scan the component to detect an annotation of a given dependency, which indicates that the dependency is on a dynamic module.","In some embodiments, the dependency injection framework may be configured to inject a proxy component into the dependent component. Such a proxy component may expose the required interface to the component, but hide the dynamism of the implementation from the component. For example, the proxy component may handle dynamic service events of the implementation (e.g., the implementation is modified or disappears at runtime) in a manner that is transparent to the dependent component.","While the invention is described herein by way of example for several embodiments and illustrative drawings, those skilled in the art will recognize that the invention is not limited to the embodiments or drawings described. It should be understood that the drawings and detailed description hereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the invention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims. Any headings used herein are for organizational purposes only and are not meant to limit the scope of the description or the claims. As used herein, the word \u201cmay\u201d is used in a permissive sense (i.e., meaning having the potential to) rather than the mandatory sense (i.e. meaning must). Similarly, the words \u201cinclude\u201d, \u201cincluding\u201d, and \u201cincludes\u201d mean including, but not limited to.","Application server component containers (e.g., that provided by Java EE) and dynamic module systems (e.g., OSGi) each provide valuable tools that help programmers develop and manage modular software applications. For example, enterprise services typically require transactional access to data systems such as relational database servers, message-oriented middleware, CORBA, ERP systems (e.g., SAP, PeopleSoft, etc.), legacy systems, and\/or others, which may be integrated with a security policy of an underlying system. The Java EE component container provides well-established APIs for building services with transactional access to such data systems, whereas OSGi does not. On the other hand, OSGi provides a dynamic modular runtime that enables components to be inserted, discovered, updated, and removed dynamically at runtime. It is therefore desirable to build hybrid applications that can be deployed in an environment that integrates the benefits of an enterprise application server component container with those of a dynamic module system.","According to various embodiments, an application server may be deployed with both a component container usable to manage application components and a dynamic module system usable to provide dynamic services to those components. Thus, applications executing on the hybrid server may leverage both the benefits of a component container as well as those of the dynamic module system. Such applications may be referred to herein as hybrid applications and may be implemented as a group of independently deployable modules (or bundles) in the dynamic module system. As used herein, a bundle is a unit of deployment in a dynamic module system, such as OSGi.","In some embodiments, the application server may be a Java EE-compliant application server (e.g., GlassFish), which may itself be deployed as bundles of a dynamic module system (e.g., an OSGi implementation, such as Felix, Equinox, Knopflerfish, etc.). Although many of the embodiments described herein are illustrated in terms of a Java EE application server and an OSGi dynamic module framework, the systems and techniques described herein are not intended to be limited to those technologies alone. In recognition that particular standards evolve and that alternatives become available, it is intended that the embodiments described herein be applicable to any application server, component container, and dynamic module system.",{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 1","FIG. 1"],"b":["105","130","135","135","105","130","135","140"]},"According to , hybrid application server  comprises various components and libraries, such as Java EE server bundles , Java EE server extensions , and other libraries . In some embodiments, server  may itself be implemented as an OSGi application. For example, Java EE server bundles  may be a number of OSGi bundles that together implement a Java EE application server and\/or various other server functionalities. Such functionality may implement a Java EE server standard. In addition to the standard implementation, extensions  may include third party OSGi bundles used to implement functionality beyond that defined by the standard server (i.e., in bundles ) and libraries  may implement various other functionality usable by the server and\/or hybrid applications .","According to , hybrid application  comprises various components, such as OSGi service components , Java EE components , and hybrid components . Any of components - may be organized into modules of hybrid application .","An OSGi service component, such as in , may be defined as part of an OSGi bundle that includes various classes implementing one or more services. An OSGi bundle may also include OSGi metadata that describes the implemented services and\/or other configuration information usable to deploy the components. Hybrid application server  may use this metadata to deploy OSGi service components  as dynamic services in OSGi container .","According to the illustrated embodiment, a hybrid application may further comprise Java EE components . Java EE components may be written as self-contained, reusable components (e.g., EJBs, Servlets, etc.) that are deployable on an application server and are managed by a configurable Java EE container. Before deploying a Java EE component into production on the Java EE container, the application server  may verify that the component is well formed and in compliance with a Java EE specification.","The Java EE container may be implemented by application server  (e.g., in Java EE server bundles ) and configured using various configuration files. A Java EE container may provide Java EE components with different services, such as security, transaction management, Java Naming and Directory Interface (JNDI) lookup functionality, remote connectivity, and\/or other services. For example, the Java EE container may be configured with a given security model such that a managed component (e.g., an EJB) that is managed by the container prevents access by unauthorized users to restricted system resources. In another example, the container may implement a transaction model that allows programmers to define atomic transactions by specifying relationships among methods of one or more components that make up the transaction; the container may then ensure that all methods in the transaction are executed together as a single atomic unit without the need for the particular components to implement the low-level atomicity mechanisms. In some embodiments, the container may expose lookup interfaces (e.g., JNDI) that provide the managed components with a unified interface to various naming and directory services in an enterprise. Similarly, a container may also provide Java EE components with interfaces to remote components, such that a Java EE component can transparently access a remote component as though it is local.","Because the Java EE container provides a configurable context in which components execute, application components can be made to behave differently based on the particular container configuration in which they are deployed. For example, a particular EJB may have security settings that allow it a certain level of access to a database in one production environment and another level in a different production environment. Therefore, programmers can develop application components that are modular and reusable to implement different behavior as determined by the particular container in which they are deployed.","In some embodiments, a container may also provide other services, such as enterprise bean and servlet lifecycle management, database connection resource pooling, data persistence, dependency injection services, and provide access to various other Java EE container APIs. In some embodiments, application server  may implement multiple containers and\/or sub-containers, such as separate EJB and web containers for managing business logic components (e.g., EJBs) and web components (e.g., JSPs\/Servlets) respectively.","In some embodiments, multiple ones of Java EE components  may be bundled together as an archive (e.g., JAR file). Such an archive may include multiple classes implementing one or more Java EE components. The archive may also include various Java EE metadata that describes deployment settings of the one or more Java EE components. For example, the Java EE metadata may be declared in an XML-file (i.e., a deployment descriptor) that provides deployment metadata such as transaction attributes and security authorizations for the Java EE components. Therefore, an administrator may change the deployment descriptor to implement new functionality without the need to modify the source code implementing the Java EE components themselves. At runtime, server  may read the deployment descriptor and act upon Java EE components  accordingly.","In various embodiments, different types of Java EE components  may be packaged in different archives that include different metadata. For example, EJBs may be archived in a JAR archive that includes an EJB-specific deployment descriptor while JSPs, servlets, image files, and\/or other web-tier components may be packaged in a WAR archive that includes a web-specific deployment descriptor.","In addition to (or instead of) deploying components that take advantage of either the OSGi framework or the Java EE framework, it may be desirable for a hybrid application to deploy hybrid components (e.g., ) that can take advantage both of the benefits provided by the OSGi container  and of those provided by the Java EE container (implemented by server ). For example, a hybrid component may be deployed as a Java EE component (which is managed by and can take advantage of a Java EE container implemented in server ), but that are also visible as OSGi services managed by OSGi container . Such a component may take advantage of being a Java EE-managed component (e.g., transaction management, security framework, dependency injection framework, etc.) and also of being an OSGi-managed service (e.g., modularity, dynamic, service-oriented architecture, etc.). Accordingly, hybrid components  may be implemented as part of Java EE components  and\/or of OSGi service components .","In , hybrid application  includes one or more hybrid components , which are implemented as both OSGi service components and Java EE components. In various embodiments, hybrid components  may correspond to a hybrid module and\/or an entire hybrid application. Hybrid components  may be packaged together in a hybrid archive that includes various classes, OSGi metadata, and Java EE metadata.",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 2"},"According to the illustrated embodiment, hybrid archive  includes classes . Classes  may include compiled code, source code, byte-code and\/or any other encoding of the object classes that implement application functionality. For example, classes  may implement various Java EE components (e.g., EJBs), which may be configured to run within and be manageable by a Java EE container. Components defined in classes  may be configured to expose different interfaces and\/or services.","Hybrid archive  also includes Java EE metadata . Java EE metadata  may describe deployment settings of the Java EE components defined by classes , such that those components may be deployed on a Java EE container. In some embodiments, the Java EE metadata may be analogous to that used to deploy Java EE components  of . For example, the Java EE metadata may be declared in an XML-file of the archive (i.e., a deployment descriptor) that provides deployment metadata such as transaction attributes and security authorizations for the Java EE components. In some embodiments, some or all of Java EE metadata  may be expressed using annotations within classes  rather than only in a deployment descriptor. Java EE metadata  may enable the Java EE components defined in classes  to be deployed into a Java EE container.","Hybrid archive  also includes OSGi metadata . OSGi metadata  may describe deployment settings of one or more services exposed by classes , such that those services may be deployed into an OSGi container, such as  in , as an OSGi bundle. In various embodiments, OSGi metadata  may include a manifest file describing the contents of archive  and\/or other information about the bundle, such as interfaces to the services the bundle will expose, dependency information, a unique identifier for the bundle, a human-readable name, the name of an activator class, a class path, and\/or other metadata usable to deploy classes  as an OSGi service. In some embodiments, OSGi metadata  may further include optional documentation, such as that commonly included in an OSGI-OPT directory of OSGi bundles.","In various embodiments, Java EE metadata  and OSGi metadata  may be specified in separate files, together in a single file, using annotations within classes , or any combination thereof. For example, in some embodiments, a single deployment descriptor file may contain portions of Java EE metadata  and OSGi metadata , such that some common metadata (e.g., manifest of classes ) need not be repeated in separate locations.","As describe above, a hybrid archive, such as , may be used to deploy a hybrid module, hybrid application, and\/or various hybrid components. Such components may utilize both the benefits of the Java EE container and those of the OSGi container. For example, in some embodiments, hybrid archive  may be used to package and deploy one or more OSGi-enabled Java EE components, such as EJBs. In some embodiments, deploying components in such an archive may include deploying components on both the OSGi container and Java EE container. Therefore, such a hybrid archive may be considered an OSGi-enabled Java EE bundle.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 3","FIG. 1"],"b":"130"},"According to the illustrated embodiment, method  begins by installing an extender bundle in the OSGi runtime, as in . In some embodiments, the extender bundle may be a component or module packaged as an OSGi bundle. Such a bundle may be distributed as part of a hybrid application server.","Once the extender bundle is deployed on the OSGi container, it may listen for state transitions of OSGi-enabled Java EE bundles to determine when such a bundle has been deployed on the OSGi container. In some embodiments, the extender bundle may utilize built-in notification mechanisms of the OSGi container to detect deployment of OSGi-enabled Java EE bundles. For example, the extender bundle may register its interest with the OSGi container in receiving state transition notifications of newly deployed bundles. When the extender bundle receives notification of a newly deployed OSGi bundle, the extender bundle may examine the newly deployed bundle to determine whether the newly deployed bundle is a hybrid that should be deployed in the Java EE container.","According to the illustrated embodiment, after the extender bundle is installed in , an OSGi-enabled Java EE bundle is deployed to the OSGi container in . Such a bundle may include both OSGi and Java EE metadata and be packaged in a hybrid archive, such as  of .","After or while the OSGi-enabled Java EE bundle is deployed (as in ), the extender bundle receives event notifications regarding the status of the OSGi-enabled Java EE bundle. In , the extender bundle determines that the OSGi-enabled Java EE bundle is ready to be deployed to the Java EE container. The specific details of when a bundle is ready may vary across bundles and\/or dynamic module system implementations. For example, in various embodiments, a bundle may be ready when the OSGi container has resolved all of the bundle's dependencies and\/or when the container has invoked one or more appropriate activation methods of the bundle.  and the accompanying description below illustrate how the extender bundle may determine, as in , that an OSGi-enabled Java EE component is ready to be deployed to the Java EE container, according to some embodiments.",{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 4","FIG. 4"]},"According to , an OSGi bundle may start in INSTALLED state , where it has been detected and is waiting for all of its dependencies to be resolved. That is, the OSGi framework attempts to find each class on which the installed bundle depends (e.g., that the installed bundle references). Once all of a bundle's dependencies are resolved, the bundle enters the RESOLVED state . In some embodiments, the framework moves the bundle into RESOLVED state  after ensuring that the runtime environment meets or exceeds the environment required by the bundle and dependencies (e.g., packages imported by the bundle or other bundles required by the bundle) are present and either in the RESOLVED state  themselves or can be resolved at the same time as the bundle.","According to the illustrated embodiment, the STARTING state  is a transitional state between RESOLVED state  and ACTIVE state . During the STARTING state , the container may create the resources required by the bundle. When the resources are created, the container may call the start( ) function on the bundle's activator (if one is provided), as indicated by the transition to ACTIVE state . If the bundle has an activation policy, the bundle may remain in the STARTING phase  until the bundle is activated according to its activation policy. For example, if the bundle has a LAZY activation policy (i.e., a policy mandating that the bundle be activated upon the first successful request to load a class from that bundle), then the bundle may not become active until the first successful request to load a class from the bundle.","Once a bundle is activated, it may enter ACTIVE state  and become ready to be invoked and perform functionality defined by its classes. Services in an OSGi container can be stopped and started dynamically, such as by invoking a stop method on the bundle's activator. While a bundle is being stopped (e.g., after the stop method is called on the activator, but before the stop method returns), the bundle may be in STOPPING stage . Once the container fully stops the bundle, the bundle may return to the RESOLVED state .","According to the illustrated embodiment, determining when a given bundle is ready for deployment to the Java EE container may depend on the given bundle's activation policy. For example, if the bundle has a default activation policy, then the extender bundle may determine that the given bundle is ready when the given bundle enters the ACTIVE state . However, if the given bundle has a lazy activation policy, then the extender bundle may determine that the given bundle is ready when it is in the STARTING state.","In  of , the extender bundle detects a state transition that indicates the bundle is ready to be deployed to the Java EE container. In , the extender bundle examines the bundle to determine whether it is a Java EE bundle. For example, in , the extender bundle may examine the bundle metadata to determine if it contains Java EE component metadata (e.g.,  of hybrid archive ) that would allow one or more components in the bundle to be deployed as Java EE components in a Java EE container.","In response to determining that the bundle is an OSGi-enabled, Java EE bundle (as in ) and is ready for deployment (as in ), the extender bundle deploys the Java EE bundle to the Java EE container, as in . In , the extender determines whether the newly deployed OSGi-enabled Java EE bundle contains any components that should be registered with the OSGi container as services. For example, in some embodiments, the OSGi-enabled Java EE bundle may include metadata (e.g., in an \u201cExport-EJB\u201d header) that indicates various Java EE components (e.g., EJBs) and\/or interfaces to expose via OSGi. In different instances, the metadata may indicate that all, none, or some subset of the components and\/or interfaces defined in the Java EE bundle should be exposed as OSGi services.","Once the extender bundle has determined one or more Java EE components or interfaces to expose as OSGi services (as in ), the extender instantiates the components as objects in the Java EE container, as in . In , the extender bundle registers the instantiated components (or references to the instantiated components), in the OSGi service registry, as in , so that the components are available for clients to discover and use. In some embodiments, registering a component may comprise registering all the component interfaces of the components as OSGi service interfaces.","In some embodiments, the extender bundle may determine whether a given Java EE component meets one or more deployment criteria, such as compatibility with the OSGi scoping model, before deploying the component as OSGi service. For example, an EJB that is designated as \u201cstateful\u201d is typically created by and\/or for a given client, performs work on behalf of the client, and maintains state between invocations by the client. However, an OSGi scoping model may only be able to support singleton or singleton-per-bundle services. Because such services may be shared between multiple bundles, it may be incompatible to back such a service with a stateful bean. In some embodiments, the extender bundle may detect such scoping incompatibilities and avoid registering the incompatibly scoped Java EE component as an OSGi service.","Once a Java EE component interface is registered as an OSGi service in the OSGi service registry, the component may be available both as a Java EE component managed by the Java EE container and as an OSGi service available via the OSGi registry and managed by the OSGi container. The fact that the OSGi service is backed by a Java EE component may be transparent to clients who may discover and access Java EE-backed services in the OSGi service registry in the same manner as discovering and accessing normal OSGi services.",{"@attributes":{"id":"p-0055","num":"0054"},"figref":["FIG. 5","FIG. 1","FIG. 3"],"b":["500","130","300","500","505"]},"According to the illustrated embodiment, method  begins when the OSGi container receives a query for an OSGi service, as in . For example, in some embodiments, a client component may use a lookup service provided by its bundle context to query the OSGi container for a particular service. In some embodiments, the query may include a variety of selection criteria that the OSGi container can use to identify the appropriate service, such as a class name and\/or additional tags.","In , the OSGi container uses the query data to determine the Java EE-backed service requested by the client component. In some embodiments, the OSGi container may locate the proxy handle registered by the extender bundle for the Java EE-component.","After determining the Java EE-backed service in , the server locates the corresponding delegate Java EE-component instance that backs the service, as in . In some embodiments, the server may locate the appropriate Java EE component by performing a lookup using a lookup interface, such as JNDI. For example, the server may use the portable JNDI name of the Java EE component to perform a JNDI lookup. Once the server discovers the delegate Java EE component (as in ), it may forward invocations of the service to the delegate Java EE component for processing, as in .","As described with regard to , a client may utilize a Java EE-component backed OSGi service transparently as though it were a normal OSGi service. However, because the service is backed by a Java EE component executing in a Java EE container, the backing component still enjoys the benefits of Java EE container management. For example, if an OSGi client begins a transaction using the OSGi\/JTA API, then a method invocation of the underlying Java EE component (e.g., an EJB) occurs in the context of the same transaction, which may allow the Java EE component developer to control the transactional behavior of the component through transactional attributes.",{"@attributes":{"id":"p-0060","num":"0059"},"figref":["FIG. 6","FIG. 6","FIG. 1"],"b":["600","130"]},"According to the illustrated embodiment, system  comprises OSGi container  and Java EE container . However, in various embodiments, OSGi container  may correspond to a container of another dynamic module system and Java EE container  may correspond to a component container other than Java EE.","OSGi container comprises a variety of deployed bundles , including an OSGi-enabled EJB bundle  and Java EE extender bundle . OSGi-enabled EJB bundle  may be a type of OSGi-enabled Java EE bundle (as described in reference to ) that contains EJB components. In some embodiments, OSGi-enabled EJB bundle  may be deployed using a hybrid archive, such as , that includes both Java EE and OSGi metadata, such as  and .","In some embodiments, Java EE extender bundle  may be configured to listen for state transition events of bundles on OSGi container , as described herein with reference to , and to deploy bundle  onto Java EE container  when bundle  becomes ready. For example, in response to detecting that OSGi-enabled EJB bundle  is ready for deployment (e.g., as described in reference to ) and that the bundle is an OSGi-enabled EJB bundle (e.g., as described in reference to ), Java EE extender bundle  may deploy bundle  onto Java EE container  as EJB bundle .","Java EE extender bundle  may read deployment metadata of EJB bundle  to determine which EJBs and\/or interfaces should be exposed as OSGi services. For example, Java EE extender bundle  may determine which EJBs and\/or services of EJBs to register as OSGi services by reading an \u201cExport-EJB\u201d header in the metadata of EJB bundle . In various instances, the header may indicate that all EJBs should be made available as OSGi services, that none should be, that only a subset should be (e.g., by class name), and\/or that only a subset of methods of any given EJB should be registered.","In response to determining that a given EJB (i.e., Java EE component) defined by EJB bundle  should be made available as an OSGi service, extender bundle  may create a corresponding EJB instance to back such a service. For example, in the illustrated embodiment, Java EE extender bundle  has instantiated EJB instance  from its definition in EJB bundle .","In system , extender bundle  creates EJB proxy handle , which corresponds to EJB instance , and registers it in OSGi service registry . The proxy handle  may be registered using the EJB class name and\/or various other metadata that enables clients to discover the service by querying OSGi registry . The fact that the service is an EJB-backed service may be transparent to clients, which may discover and invoke the service just like any other OSGi service. When a client invokes the service provided by EJB proxy handle , the server may transparently locate the corresponding delegate EJB instance  using a lookup service, such as JNDI, and forward the method invocation to that delegate.","Though a client component may discover EJB-backed service  through traditional service-lookup APIs of OSGi container , in some embodiments, a component may reach the service by utilizing container services. For example, in the illustrated embodiment, client component  is an OSGi client to Java EE component .","In various embodiments, Java EE container  may include mechanisms, such as a dependency injection framework (e.g., Contexts and Dependency Injection for the Java EE platform [CDI]), that may manage dependencies between components. In some embodiments, a dependency injection framework of the component container may be modified such that it may inject OSGi services into a client component in a modular and type-safe fashion.","Dependency injection (DI) is a design technique employed by programmers wherein a component declares its dependency on a given interface (e.g., declares an instance variable of the interface type) and a separate entity supplies the component with an object that implements that interface. Thus, the choice of which implementation to use and the complexity of instantiating the chosen implementation is removed from the dependent component.","Various DI frameworks (e.g., Java\u2122 CDI, Guice, Spring, etc.) define special syntaxes usable to declare a component's dependencies and specify which implementations should satisfy those dependencies. Such declarations and specifications may be specified within the component code, in external configuration files (e.g., XML), or using other means. The DI framework uses these declarations to determine which classes to instantiate for each interface and, at runtime, instantiates and supplies those classes to the dependant components as needed.","As discussed above, a DI framework must read dependency declarations and decide which classes should satisfy those dependencies. To support such decisions, some DI frameworks (e.g., OSGi Blueprint Container Specification Version 1.0) require that the user specify class dependencies and interrelations in an external, XML configuration file. At runtime, the DI framework reads the configuration file to discover the dependency structure and which classes should satisfy which dependencies. Unfortunately, because the dependency information is specified outside of the code, such DI frameworks and\/or compilers cannot discover errors (e.g., missing classes, wrong class names, etc) in the dependency information until runtime. Discovering a dependency error at runtime may cause the program to throw an exception or experience another error. Because such frameworks cannot recognize errors before runtime, they are said to not be type-safe. A type-safe mechanism can detect type errors before runtime, such as during code compilation time or deployment.","Other DI frameworks, such as Java\u2122 Contexts and Dependency Injection for the Java EE platform (CDI), provide type-safe dependency injection by allowing programmers to declare dependency information within code using annotations. In-code annotations provide context that allows a compiler and\/or CDI implementation to determine, before runtime, which classes should satisfy various dependencies, whether those classes are available, and\/or whether the classes are of the proper type required by the dependent code. If any required classes are not available or are of the wrong type, the compiler and\/or CDI implementation can detect the error before runtime (e.g., compile time, deployment time, etc.). Therefore, a programmer can catch and correct dependency and type errors before runtime, which results in more stable programs.","According to various embodiments, an application server container (e.g., Java EE container ) may include a type-safe DI framework configured to inject dynamic services (e.g., OSGi services, such as those in ) into a managed component (e.g., servlets, EJBs, etc.) that specifies a dependency to that service. In various embodiments, the type-safe DI framework may be configured to inject different types of services into the managed component, such as dynamic OSGi services, web services, and\/or any other services. Such injection may be performed transparently to the managed component and in a type-safe manner.",{"@attributes":{"id":"p-0074","num":"0073"},"figref":["FIG. 7","FIG. 7"],"b":["700","700"]},"According to the illustrated embodiment, method  begins when a CDI extension is installed, as in . In some embodiments, the extension may be implemented as a CDI portable extension, which can provide its own beans, interceptors, and decorators to the Java EE container. In some embodiments, such a portable extension may also be capable of injecting dependencies into its own objects (e.g., using the dependency injection services of CDI), providing a context implementation for a custom scope, augmenting or overriding annotation-based metadata, and\/or other capabilities. A CDI portable extension may be registered with the Java EE container as a service provider. In some embodiments, the container may be configured to instantiate the portable extension during the initialization process, before other Java EE components (e.g., EJBs, contexts) exist.","During initialization, the Java EE container may fire a series of deployment events, such as BeforeBeanDiscovery, ProcessAnnotatedType, ProcessInjectionTarget, ProcessProducer, etc. in response to lifecycle events of different components being deployed. The portable extension may be configured to listen for such events, as in .","In response to detecting a deployment event that indicates a hybrid application is being deployed (as in ), the extension may inspect the hybrid application to discover injection points that declare an OSGi service dependency (as in ). For example, in some embodiments, a programmer may designate an injection point by annotating a dependency (e.g., instance variable, method, etc.) within the code using an \u201c@Inject\u201d annotation. The programmer may further indicate that the dependency is on an OSGi service by using an additional annotation (e.g., \u201c@OSGiService\u201d). In some embodiments, the programmer may further indicate that the service is a dynamic service (e.g., \u201c@OSGiService(dynamic=true)\u201d).","To illustrate, consider the following example. Suppose an OSGi bundle B defines a service contract named com.acme.Foo and exports the service interface com.acme for use by other components. Suppose further that bundle B provides a service implementation Foo_Implementation of the com.acme.Foo interface. Bundle B then registers Foo_Implementation as a service interface with the OSGi service registry as an implementation of the com.acme.Foo interface. Bundle B, a hybrid application (i.e., OSGi-aware Java EE bundle) imports the com.acme package and includes a Java EE component named ServletClass. According to some embodiments, ServletClass may expresses a dependency on com.acme.Foo by adding a field\/setter method and qualifying it as an injection point using \u201c@Inject @OSGiService (dynamic=true)\u201d. For example, ServletClass may be written as:\n\n","For the above example, the CDI extension may detect the deployment of hybrid bundle B in . In , the CDI extension may inspect the ServletClass class and detect that the class contains the service injection point at line (3). In response to detecting the service injection point, the extension may dynamically create a respective bean corresponding to the service injection point, as in .","At runtime, when the ServletClass is being instantiated, the CDI framework must determine the proper class for the myDependency variable at (4). In , the CDI runtime invokes the respective bean corresponding to the injection point at (4). In , the bean discovers an appropriate OSGi service, such as the Foo_Implementation class, and returns it to the CDI framework. In , the CDI framework then injects the Foo_Implementation class into the ServletClass class.","In different embodiments, the bean may discover the appropriate OSGi service (as in ) in different ways. For example, in some embodiments, the bean may be configured to query the OSGi service registry directly to discover an appropriate implementation of com.acme.Foo, such as by submitting a query to the registry that includes the interface name com.acme.Foo and\/or additional requirements. In other embodiments, the bean may invoke the CDI extension to acquire the appropriate class. Such an extra level of indirection may enable the extension to enhance the service that it returns with additional capabilities. For example, in some embodiments, the bean may discover the corresponding OSGi service (as in ) by invoking a factory class of the extension. In various embodiments, a factory class may include one or more static constructors for different classes. The extension may then create, and return to the bean, a service proxy for the OSGi service implementation. The service proxy may be configured to provide additional service capabilities, such as transparent handling of dynamic service events. For example, the service proxy returned by the extension may include logic that transparently handles dynamic service events, such as when the underlying OSGi service is updated or becomes unavailable. The service proxy may be configured to detect such events and in response, to switch to a different implementation of the OSGi service transparently to the client component. Thus, the CDI extension and service proxy scheme may hide the complexity of handling dynamic services from Java EE components into which such services are injected.",{"@attributes":{"id":"p-0082","num":"0086"},"figref":["FIG. 8","FIG. 8","FIG. 1"],"b":["800","130"]},"According to the illustrated embodiment, system  includes an OSGi container  and Java EE container . However, these particular technologies are chosen for purposes of illustration and not intended to be limiting. In different embodiments, OSGi container  may be replaced with a different dynamic module system and Java EE container  may be replaced with a different application component container. OSGi container  and Java EE container  may correspond to containers  and  of  respectively. Furthermore, various ones of the components displayed within Java EE container  may also be deployed as bundles on OSGi container . The separation of Java EE container components from OSGi components in  is intended to be conceptual rather than necessarily indicative of a strict separation of components.","OSGi container  includes an OSGi service registry  and one or more deployed bundles . OSGi service registry  includes service interface , which may be discoverable and usable by various components. For example, service interface  may declare the com.acme.Foo interface described in the example above. Deployed bundles  include bundles  and , which may provide different implementations of service . For example, bundle  may correspond to bundle B above, which provides the Foo_Implementation implementation of the com.acme.Foo interface, and bundle  may correspond to a different bundle providing a different implementation of the come.acme.Foo interface.","According to the illustrated embodiment, Java EE container  includes portable extension , which may be implemented as a CDI portable extension and be configured to listen for various deployment events fired by the Java EE container . In response to detecting a deployment event indicating that a Java EE component is deployed and determining that the component includes an injection annotation referencing a dynamic OSGi service (as in  of ), the portable extension  may create a respective bean, such as injection-point bean , for injecting the service. The process of creating the injection-point bean and injecting the service may correspond to steps - of .","In the illustrated embodiment, Java EE container  includes Java EE component , which may correspond to an EJB, servlet (e.g., ServletClass), or other Java EE component. When Java EE component  is deployed, portable extension  discovers that the Java EE component includes an annotation declaring a dependency on OSGi service  (e.g., to com.acme.Foo). In response, portable extension  creates injection-point bean , which corresponds to the annotated injection point (e.g., at line (3)). When the Java EE container needs to resolve the dependency at the injection point (e.g., to instantiate the myDependency variable), CDI framework  invokes the corresponding injection point bean . Injection point bean  invokes a factory class of portable extension  to get an object satisfying the declared service dependency. The factory class queries service registry  for an implementation of service  (e.g., Foo_Implemenation implemented by bundle ) and packages the service in service proxy . In some embodiments, service proxy  may be configured to handle the service dynamism of service . For example, service proxy  may detect and handle dynamic changes to service  while Java EE component  is using it. Such dynamic changes may include changes in service quality, the non-availability of the implementing class, and\/or other events. For instance, if bundle  is removed, thereby removing the Foo_Implementation class, service proxy  may transparently discover and utilize a different implementation of the com.acme.Foo interface, such as that implemented by bundle . In some embodiments, service proxy  may perform the transparent service without the knowledge or participation of the client component .",{"@attributes":{"id":"p-0087","num":"0091"},"figref":"FIG. 9","b":"900"},"The hybrid server, applications, dynamic module systems, application component container, and\/or code to execute various methods described herein may be provided as a computer program product, or software, that may include a computer-readable storage medium having stored thereon instructions, which may be used to program a computer system (or other electronic devices) to perform a process according to various embodiments. A computer-readable storage medium may include any mechanism for storing information in a form (e.g., software, processing application) readable by a machine (e.g., a computer). The computer-readable storage medium may include, but is not limited to, magnetic storage medium (e.g., floppy diskette); optical storage medium (e.g., CD-ROM); magneto-optical storage medium; read only memory (ROM); random access memory (RAM); erasable programmable memory (e.g., EPROM and EEPROM); flash memory; electrical, or other types of medium suitable for storing program instructions. In addition, program instructions may be communicated using optical, acoustical or other form of propagated signal (e.g., infrared signals, digital signals, etc.)","A computer system  may include one or more processors , each of which may include multiple cores, any of which may be single or multi-threaded. The computer system  may also include one or more persistent storage devices  (e.g. optical storage, magnetic storage, hard drive, tape drive, solid state memory, etc), which may persistently store, for example, data such as program source code , executable code , and\/or various outputs  as shown in .","According to the illustrated embodiment, computer system  may include one or more memories  (e.g., one or more of cache, SRAM, DRAM, RDRAM, EDO RAM, DDR  RAM, SDRAM, Rambus RAM, EEPROM, etc.). The one or more processors , the storage device(s) , and the system memory  may be coupled to an interconnect . Various embodiments may include fewer or additional components not illustrated in  (e.g., video cards, audio cards, additional network interfaces, peripheral devices, a network interface such as an A\u2122 interface, an Ethernet interface, a Frame Relay interface, monitors, keyboards, speakers, etc.).","One or more of the system memories  may contain program instructions . Program instructions  may be encoded in platform native binary, any interpreted language such as Java\u2122 byte-code, in any high-level programming language such as C\/C++, Java\u2122, etc., or in any combination thereof. Program instructions  may include instructions executable to implement various applications , such as hybrid web applications, application module, and\/or application components. Such applications may be executed on an application server, such as .","In the illustrated embodiment, program instructions  include instructions executable to implement compiler , which may be usable to compile source code representations of programs and\/or components into an executable form (e.g., native binary or interpreted language). Compiler  may be configured to validate source code for type safety, including for that of injected dependencies, as described herein. In the illustrated embodiment, program instructions  may also include one or more runtime environments . Runtime environments  may include a Java\u2122 runtime, Java EE container, OSGi container, or various runtime support mechanisms as described herein.","In some embodiments, memory  may include any number of in-memory variables and\/or data structures, such as . Variables and data structures may comprise any number of variables and\/or data structures allocated by executing programs, such as applications , server , compiler , and runtime environments .","Although the embodiments above have been described in considerable detail, numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
