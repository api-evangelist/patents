---
title: Method and apparatus for encrypting data in a wireless communication system
abstract: In a communications system, a method of transforming a set of message signals representing a message comprising the steps of first encoding one of the set of message signals in accordance with a first keyed transformation, a second encoding of the one of the set of message signals in accordance with at least one additional keyed transformation, a third encoding of the one of the set of message signals in accordance with a self inverting transformation in which at least one of the set of message signals is altered, a fourth encoding of the one of the set of message signals in accordance with at least one additional inverse keyed transformation wherein each of the at least one additional inverse keyed transformation is a corresponding inverse of at least one additional keyed transformation, and fifth encoding the one of the set of message signals in accordance with first inverse keyed transformation wherein the first inverse keyed transformation is the inverse of the first keyed transformation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07995751&OS=07995751&RS=07995751
owner: QUALCOMM Incorporated
number: 07995751
owner_city: San Diego
owner_country: US
publication_date: 20040330
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["This application is a continuation of U.S. patent application Ser. No. 10\/434,749 filed May 9, 2003, now U.S. Pat. No. 6,768,797, which is a continuation of U.S. patent Ser. No. 10\/081,750, filed Feb. 21, 2002, now abandoned, which is a continuation of application Ser. No. 09\/369,382, filed Aug. 5, 1999, now U.S. Pat. No. 6,385,316, issued May 7, 2002, which is a continuation of application Ser. No. 08\/815,347, filed Mar. 11, 1997, now U.S. Pat. No. 6,075,859, issued Jun. 13, 2000, all assigned to the assignee hereof and hereby expressly incorporated herein.","I. Field of the Invention","The present invention relates to communications systems. More particularly, the present invention relates to a novel and improved method for encrypting data for security in wireless communication systems.","II. Description of the Related Art","In a wireless communication system, it is desirable for the service provider to be able to verify that a request for service from a remote station is from a valid user. In some current cellular telephone systems, such as those deploying the AMPS analog technology, no provision is made to deter unauthorized access to the system. Consequently, fraud is rampant in these systems. One fraudulent means for obtaining service is known as cloning, in which an unauthorized user intercepts the information necessary to initiate a call. Subsequently, the unauthorized user can program a mobile telephone using the intercepted information and use that telephone to fraudulently receive telephone service.","To overcome these and other difficulties, many cellular telephone systems have implemented authentication schemes such as that standardized by the Telecommunications Industry Association (TIA) in EIA\/TIA\/IS-54-B. One facet of this authentication scheme is encryption of information, transmitted over the air, that is required to receive service. This information is encrypted using the Cellular Message Encryption Algorithm (CMEA). The CMEA algorithm is disclosed in U.S. Pat. No. 5,159,634, entitled \u201cCRYPTOSYSTEM FOR CELLULAR TELEPHONY\u201d, incorporated by reference herein.","Several major weaknesses have been discovered in CMEA which allow encrypted information to be deciphered using current standard computational equipment in a relatively short period of time. These weaknesses will be thoroughly outlined hereinafter followed by a description of the present invention which overcomes these weaknesses. CMEA has been published on the Internet, hence these weaknesses are open for discovery by anyone with an interest in doing so. Thus, a new algorithm for encryption is desirable to replace CMEA to avoid the interception and fraudulent use of authentication information necessary to initiate cellular service.","The present invention is a novel and improved method for data encryption. The present invention is referred to herein as Block Encryption Variable Length (BEVL) encoding, which overcomes the identified weaknesses of the CMEA algorithm. The preferred embodiment of the present invention has the following properties:\n\n","The first weakness identified in CMEA is that the CAVE (Cellular Authentication Voice Privacy and Encryption) table used for table lookups is incomplete. It yields only 164 distinct values instead of 256. The existence of a large number of impossible values makes it possible to guess return values of tbox( ) or key bytes, and verify the guesses. This first weakness is mitigated in the present invention by replacing the CAVE table with two different tables chosen to eliminate the exploitable statistical characteristics of the CAVE table. These tables, called tbox and tbox, are strict permutations of the 256 8-bit integers, where no entry appears at its own index position. In addition, tbox[i] does not equal tbox[i], for all values of i. These two tables were randomly generated with candidates being discarded which did not meet the above criteria.","The second weakness of CMEA is the repeated use of the value of a function called tbox( ), evaluated at zero. The value tbox() is used twice in the encryption of the first byte. This makes it possible to guess tbox() and use the guess in determining other information about the ciphering process, notably the result of the first step of CMEA for the last byte, and the arguments of the two values of tbox( ) used in encrypting the second byte. It also makes it possible, through a chosen-plaintext attack, to determine tbox( ) by trying various plaintext values until a recognized pattern appears in the ciphertext. This second weakness is mitigated by changing the self-inverting procedures used in CMEA to a preferred set of procedures providing better mixing. This is done by introducing a second pass using a different table (tbox). In this situation there are two values of tbox( ) derived from different tables with equal significance which serve to mask each other.","A related weakness in CMEA is that information gathered from analyzing texts of different lengths can generally be combined. The use of the second critical tbox( ) entry in BEVL depends on the length of the message and makes combining the analysis of different length texts less feasible.","A third weakness discovered in CMEA is incomplete mixing of upper buffer entries. The last n\/2 bytes of the plaintext are encrypted by simply adding one tbox( ) value and then subtracting another value, the intermediate step affecting only the first half of the bytes. The difference between ciphertext and plaintext is the difference between the two values of tbox( ). BEVL addresses this third weakness by performing five passes over the data instead of three. The mixing, performed by CMEA only in the middle pass, is done in the second and fourth passes which mix data from the end of the buffer back toward the front. The middle pass of CMEA also guarantees alteration of at least some of the bytes to ensure that the third pass does not decrypt. In an improved manner, BEVL achieves this goal in the middle pass by making a key dependent transformation of the buffer in such a way that at most a single byte remains unchanged.","CMEA's fourth weakness is a lack of encryption of the least significant bit (LSB) of the first byte. The repeated use of tbox() and the fixed inversion of the LSB in the second step of CMEA results in the LSB of the first byte of ciphertext being simply the inverse of the LSB of the first byte of plaintext. BEVL avoids this fourth weakness through a key dependent alteration of the buffer during the middle pass which makes the LSB of the first byte unpredictable on buffers of two bytes or more in length.","A fifth weakness of CMEA is that the effective key size is 60 rather than 64 bits. As such, each key is equivalent to 15 others. BEVL increases the number of table lookups while decreasing the number of arithmetic operations, ensuring that all 64 bits of the key are significant.","Finally, CMEA's tbox( ) function can be efficiently compromised by a meet-in-the-middle attack. Once four tbox( ) values are derived, the meet-in-the-middle attack can be accomplished with space and time requirements on the order of 2^30, independent of the composition of the CAVE table. BEVL addresses this in a number of ways. The construction of the tbox( ) function recovers two unused bits of the key. The repetition of the combination with the least 8 bits of the encryption key at both the beginning and end of tbox( ) means that the minimum computation and space should be increased by eight bits. Since there are two sides of each table, and two different tables, the minimum complexity should be increased by another two bits, leading to a minimum space and time requirement on the order of 2^42. Further, the meet-in-the-middle attack on CMEA requires the recovery of at least some of the tbox( ) entries. This is made more difficult using BEVL, which requires simultaneous attacks on two separate sets of tbox( ) values, which tend to disguise each other.","The exemplary embodiment of the present invention consists of a first station  encrypting data for wireless transmission to a second receiving station , as depicted in . First station  can be a remote station transmitting to a second station , which could be a base station. Alternatively, first station  could be a base station transmitting to a second station , which could be a remote station. In all likelihood, both remote and base stations will have encryption and decryption means, as well as transmission and reception means, but the simplified system shown in  shows clearly the elements required to enable the present invention. Further, the benefits of this invention are not limited to wireless communications but can be readily applied in any situation where secure data must be transmitted over a medium which is susceptible to interception, as will be well understood by those skilled in the relevant art.","In , memory  containing the necessary data for encryption according to the BEVL algorithm of the present invention is connected with processor . In the exemplary embodiment, processor  is a relatively simple 8-bit microprocessor, capable of executing instructions stored in BEVL code . Processor  contains an arithmetic logic unit (ALU, not shown) capable of performing simple 8-bit instructions such as bitwise exclusive OR (referred to simply as XOR or denoted\u2248 hereinafter), integer addition and subtraction, and the like. Processor  is also capable of general program flow instructions and the ability to load and store values from a memory, such as memory . Those skilled in the art will recognize that these requirements are quite minimal, making the present invention quite suitable to applications where size and\/or cost requirements make simple microprocessors desirable, such as in portable devices. Clearly the present invention can easily be implemented using more powerful microprocessors as well.","Memory  contains tables tbox  and tbox , an encryption key , and the code to be executed (BEVL code) . Data to be encrypted is input to processor , which stores that data in memory  in a location referred to as data . Although FIG.  depicts all these elements in a single memory, it is understood that a plurality of memory devices could be used. In the preferred embodiment, the tables  and  as well as BEVL code  are stored in non-volatile memory such as EEPROM or FLASH memory. These portions of the memory need not be writeable.","Encryption key  can be generated by a number of means that are well known in the art. A simple embodiment may have key  in non-volatile memory that is programmed once at the time the station is activated for service. In the exemplary embodiment, key  is generated and changed according to the protocol as set forth in the aforementioned EIA\/TIA\/IS-54-B.","The data to be encrypted, data , is stored in random access memory (RAM). The encryption will be performed \u201cin place\u201d, which means the memory locations holding the unencrypted data at the beginning of procedure will also hold the intermediate values as well as the final encrypted data.","Data  is encrypted in processor  according to BEVL code , utilizing tbox , tbox , and encryption key . A description of the encryption process is detailed hereinafter.","Encrypted data  is delivered by processor  to transmitter  where it is modulated, amplified and upconverted for transmission on antenna .","Antenna  receives the data and passes it to receiver  where the data is downconverted, amplified, demodulated, and delivered to processor . In the exemplary embodiment, the format for the wireless communication between the two stations depicted in  is described in \u201cMobile Station-Base Station Compatibility Standard for Dual-Mode Wide Band Spread Spectrum Cellular System\u201d, TIA\/EIA\/IS-95-A. The use of CDMA techniques in a multiple access communication system such as a wireless telephone system is disclosed in U.S. Pat. No. 4,901,307, entitled \u201cSPREAD SPECTRUM MULTIPLE ACCESS COMMUNICATION SYSTEM USING SATELLITE OR TERRESTRIAL REPEATERS,\u201d assigned to the assignee of the present invention, and incorporated by reference herein. The use of CDMA techniques in a multiple access communication system is further disclosed in U.S. Pat. No. 5,103,459, entitled \u201cSYSTEM AND METHOD FOR GENERATING SIGNAL WAVEFORMS IN A CDMA CELLULAR TELEPHONE SYSTEM,\u201d also assigned to the assignee of the present invention, and incorporated by reference herein.","Processor , which has the same requirements as processor , is coupled to memory . Memory  is comprised of memories , , , , and  which are analogous to memories , , , , and , respectively. Processor  stores the encrypted data in data memory . Key  is determined in like fashion to key , described previously. Tables  and  are identical to tables  and . Since the data processing in this invention is self-inverting, BEVL code , identical to BEVL code , is executed in processor  in conjunction with tbox , tbox , and key  on encrypted data , just as was done in the encryption process of data . As before, the data processing is performed \u201cin place\u201d, and the result in data  will be the decrypted data. Processor  retrieves the decrypted data from memory  and delivers it for subsequent use through the data output. In the exemplary embodiment, the resultant data will be used in authentication procedures as disclosed in EIA\/TIA\/IS-54-B.",{"@attributes":{"id":"p-0032","num":"0036"},"figref":["FIG. 2","FIG. 1","FIG. 1"],"b":["20","70","10","80"]},"Block  marks the beginning of the encryption process. An array of characters named buf[ ] is used to describe the characters to be encrypted as stored in data memory . The variable n denotes the length of the message to be encrypted in terms of number of characters. As stated previously, one of the improvements present in the BEVL process is the five pass encryption that takes place. Each of the five passes has been blocked out in dashed lines and labeled - to make them easy to distinguish. Each pass has notable similarities and differences. Passes , , and  use the table tbox  and work from the beginning of the buffer towards the end. Passes  and  use the table tbox  and work from the end of the buffer until the beginning is reached. BEVL's self-inverting property comes from the fact that pass  is self-inverting, while pass  is the inverse of pass  and pass  is the inverse of pass .","In the preferred embodiment of the present invention, the passes are made in opposite directions. In alternative embodiments, passes could progress in the same direction, with alternating passes using the same or different tables (re-using the same table in multiple passes does make the encryption more robust, but not as robust as when different tables are used). Inserting additional passes is another alternative which can be used in combination with either approach. In the situation where passes are made in the same direction, modifications to the first buffer entry are more predictable, with predictability decreasing in modifications further down the buffer. When alternating opposite pass directions are used, the modification to the first byte in the buffer is fairly predictable. However, the modification to that byte in the second pass depends on all the bytes in the buffer, making it much less predictable. In similar fashion, the modification to the last byte in the buffer depends on all the bytes in the buffer during the first pass, while a more predictable change is made in the second. Since the predictability of change is distributed more evenly using passes in opposite directions, doing so is much preferable to using multiple passes in the same direction. Note that pass  doesn't really have a direction, since the change made would be identical either way.","In each pass, a function tbox( ) is used. It is in this function that key  is incorporated. The parameters passed to function tbox( ) consist of a 256 byte table which will either be passed tbox  or tbox , and an index labeled tv. In the exemplary embodiment, tbox( ) is defined as:\n\nbox()=0]+1]\u22482]+3]\u22484]+5]\u22486]+7]\u22480],\u2003\u2003(1)\n\nwhere\n\n","In an alternative embodiment, where a key of a certain length provides encryption that is considered too strong, the key strength can be artificially limited without changing the length of the key by altering the tbox( ) function. For example, a 64 bit key can be artificially limited to 40 bits by using the 64 bit key in such a manner that it is in an equivalence class of 2^24 others while still ensuring that any single bit change to the key will produce a different result. The following definition of tbox( ) exhibits the recommended variation to render a 64 bit key effectively a 40 bit key:",{"@attributes":{"id":"p-0037","num":"0045"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"mi":"tbox","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["B","tv"],"mo":","}}},{"mi":"B","mo":"[","mrow":{"mi":"B","mo":"[","mrow":{"mi":"B","mo":"[","mrow":{"mi":"B","mo":"[","mrow":{"mi":"B","mo":"[","mrow":{"mi":"B","mo":"[","mrow":{"mi":"B","mo":"[","mrow":{"mi":"B","mo":"\u2061","mrow":{"mo":["[","]"],"mrow":{"mrow":{"mi":"B","mo":"\u2061","mrow":{"mo":["[","]"],"mrow":{"mi":["tv","k0"],"mo":"\u2248"}}},"mo":"+","mi":"k1"}}}}}}}}}}],"mo":["=","\u2062"],"mi":{}}}},{"mtd":{"mrow":{"mrow":{"mrow":[{"mrow":{"mo":["\u2248","\u2062"],"mi":{},"mrow":{"mo":["(",")"],"mrow":{"mi":["k2","k3"],"mo":"\u2248"}}},"mo":"]"},{"mo":["(",")"],"mrow":{"mi":["k2","k3"],"mo":"\u2248"}}],"mo":"+"},"mo":"]"}}},{"mtd":{"mrow":{"mrow":{"mrow":[{"mrow":{"mo":["\u2248","\u2062"],"mi":{},"mrow":{"mo":["(",")"],"mrow":{"mi":["k4","k5"],"mo":"\u2248"}}},"mo":"]"},{"mo":["(",")"],"mrow":{"mi":["k4","k5"],"mo":"\u2248"}}],"mo":"+"},"mo":"]"}}},{"mtd":{"mrow":{"mrow":{"mrow":{"mrow":{"mrow":{"mrow":[{"mrow":{"mo":["\u2248","\u2062"],"mi":{},"mrow":{"mo":["(",")"],"mrow":{"mi":["k6","k7"],"mo":"\u2248"}}},"mo":"]"},{"mo":["(",")"],"mrow":{"mi":["k6","k7"],"mo":"\u2248"}}],"mo":"+"},"mo":"]"},"mo":"\u2248","mi":"k0"},"mo":"]"},"mo":","}}}]}},{"mrow":{"mo":["(",")"],"mn":"2"}}]}}}},"br":{},"ul":{"@attributes":{"id":"ul0005","list-style":"none"},"li":{"@attributes":{"id":"ul0005-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0006","list-style":"none"},"li":["k through k denote eight 8-bit segments which when concatenated form the 64-bit key ;","B[x] is the xth 8-bit element of an array B;","\u2248 denotes the bit-wise exclusive OR operation; and","+ represents modulo 256 addition."]}}}},"The tbox( ) function is designed such that each of the intermediate operations are permutations, meaning each input has a one-to-one mapping to an output. In the exemplary embodiment, the operations used are modulo 256 addition and logical exclusive OR. If the input value passed to tbox( ) is a permutation, and the table lookup is as well, the use of these functions guarantees that the output of tbox( ) will also be a one-to-one function. In other words, the tbox( ) function as a whole is guaranteed to be a permutation if the table passed to it also is. This is not the case for CMEA, where the steps in the tbox( ) function are not one-to-one. Therefore, in CMEA, even if the CAVE table, which is not a permutation, were to be replaced with a table which is a permutation, the output of tbox( ) still would not be a permutation. Conversely for BEVL, any choice of one-to-one functions for combining key material to generate the final permutation would be acceptable. The exemplary embodiment is one such method. Alternative methods can easily be substituted by those skilled in the art which still conform to this permutation principle of the present invention. Intermediate functions which do not preserve the one-to-one nature of the output can alternatively be employed in the BEVL tbox( ) function, but the results would be sub-optimal.","A further improvement included in the definition of tbox( ) is that some of the key bits are used both at the beginning and at the end. In the exemplary embodiment key byte k is used, but alternative embodiments can employ any of the key bits and accomplish the same improvement. The use of the same value defeats the meet-in-the-middle attack. Failing to reuse at least some of the key information at both the beginning and end allows a straightforward, albeit computationally complex, derivation of the key from a small number of values of the tbox( ) function. With this reuse, tables used in efforts to attack the encryption require much more space and computations required to find a solution are much more extensive.","The exemplary embodiment of BEVL details the use of the tbox( ) function in conjunction with the two tables tbox and tbox The resultant outputs are key-dependent permutations of the possible inputs. However, since the values of the function depend only on the key, not on the data, the function can alternatively be pre-computed for the 256 possible inputs and two possible tables with the results stored in memory. Thus a table look up can replace the reevaluation of the function. Those skilled in the art will recognize that these two methods are functionally equivalent, and will be able to make the time versus space tradeoff when employing an embodiment of the present invention. An equivalent alternative is to start with tables initialized with a permutation of the 256 possible inputs, and perform a key-dependent shuffling of those tables when the key is initialized. Then, during subsequent encryption, a table index operation would be used instead of the current calls to tbox( ), with equal effect.","The tables tbox and tbox are strict permutations, where no entry in the table is equal to its index. This strictness guarantees that there exists no key which is weaker than any other key by allowing an intermediate value in a tbox( ) computation to remain unchanged. The fact that the tables are permutations is important, as described previously in reference to function tbox( ). If the tables were not permutations, then after the table lookup in the tbox( ) function, there would be some values which could not be the result. These impossible values would allow guesses for return values from tbox( ) and parts of the key to be eliminated, reducing the work to guess the 64 bit key significantly. Alternative embodiments could employ tables which are not permutations, but the encryption would be sub-optimal.","Any form of crypt analysis of CMEA must begin by deriving values of the tbox( ) function. A complete analysis, where all outputs for the 256 possible inputs are known, allows CMEA to be applied even without knowing the initial key. However, recovery of the key is possible knowing as few as four distinct values of the function. Thus BEVL places emphasis on disguising the outputs from tbox( ) with other outputs, particularly the value of tbox(). A number of alternatives are envisioned to accomplish this disguise. The preferred embodiment uses a second different table, tbox, and an added pair of passes each which are performed in opposite directions. Any of these three modifications, or sub-combinations thereof, would address the problem to some extent. However, the combination of all three provides the most security.","In the preferred embodiment, the forward and backward passes use different tables, tbox and tbox, in conjunction with the tbox( ) function. This is done so that crypt analysis would require discovery of two complementary sets of function values, rather than just one set. Since the passes tend to disguise each other, two tables provide the best security. Alternative embodiments are envisioned which employ only a single table. While these methods are still secure, they are less secure than those where two tables are employed.","Begin pass  by proceeding from block  to block , where variable v and buffer index i are initialized to zero. Then, in block , each character buf[i] is modified by adding to itself the result of function call tbox(tbox, v\u2248i). The variable v is subsequently updated by XORing itself with the new value of buf[i]. The buffer index i is then incremented. In block , if i<n, the pass is not complete and flow returns to block . When all characters have been modified according to block , i will equal n and pass  will be complete. Note that the characters were modified beginning with buf[] working towards the end, buf[n\u22121].","Begin pass  by proceeding from block  to block , where variable v is initialized to the value n and buffer index i is initialized to the value n\u22121. Then, in block , each character buf[i] is modified by adding to itself the result of function call tbox(tbox, v\u2248i). The variable v is subsequently updated by XORing itself with the new value of buf[i]. The buffer index i is then decremented. In block , if i\u22670, the pass is not complete and the flow returns to block . When all characters have been modified according to block , i will equal \u22121 and pass  will be complete. Note that, unlike pass , the characters were modified beginning with buf[n\u22121] working towards the beginning, buf[], and the table tbox  was used instead of table tbox .","Pass  begins in block . Buffer index i is initialized to zero. Variable v is not used in this pass. Then, in block , each character buf[i] is modified by XORing with itself the result of function call tbox(tbox, i+1). The buffer index i is then incremented. In block , if i<n, the pass is not complete and the flow returns to block . When all characters have been modified according to block , i will equal n and pass  will be complete. Note that, like in pass , the characters were modified beginning with buf[] working towards the end, buf[n\u22121], and table tbox  was used. As stated before, however, the direction of pass  is not important, since the identical result is achieved with either direction.","In pass , a different output from tbox( ) is combined with each buf[ ] entry. Because the outputs from tbox( ) form a permutation, at most only one such value can possibly be zero. Whether or not there will be a zero depends on the key. In BEVL, the change in the buffer is key-dependent and very difficult to predict. On average, the chance that one of the values will be zero is n\/256, where n is the length of the buffer. Any self-inverting key-dependent or data-dependent change which guarantees that the values in the buffer will be altered is sufficient to ensure encryption. This is an important improvement for BEVL, since, in CMEA, values which remain unchanged lead to cases where the algorithm fails to encrypt at all.","Begin pass  by proceeding from block  to block , where variable v is initialized to n and buffer index i is initialized to the value n\u22121. Then, in block , a temporary variable t is assigned the value returned by the function call tbox(tbox, v\u2248i). The variable v is subsequently updated by XORing itself with the current value of buf[i]. Each character buf[i] is then modified by subtracting from itself the value of temporary variable t. The buffer index i is then decremented. In block , if i\u22670, the pass is not complete and the flow returns to block . When all characters have been modified according to block , i will equal \u22121 and pass  will be complete. Note that, like in pass , the characters were modified beginning with buf[n\u22121] working towards the beginning, buf[], and table tbox  was used.","Begin pass  by proceeding from block  to block , where variable v and buffer index i are initialized to the value zero. Then, in block , a temporary variable t is assigned the value returned by the function call tbox(tbox, v\u2248i). The variable v is subsequently updated by XORing itself with the current value of buf[i]. Each character buf[i] is then modified by subtracting from itself the value of temporary variable t. The buffer index i is then incremented. In block , if i<n, the pass is not complete and the flow returns to block . When all characters have been modified according to block , i will equal n and pass  will be complete. Note that, like in passes  and , the characters were modified beginning with buf[n\u22121] working towards the beginning, buf[], and table tbox  was used.","Proceed now to block . Encryption is now complete. Buf[ ] now contains the encrypted characters for secure transmission.","A \u201cC\u201d program implementing the operation described above is provided in . Table tbox  is provided in \u201cC\u201d in . Table tbox  is provided in \u201cC\u201d in .","The previous description of the preferred embodiments is provided to enable any person skilled in the art to make or use the present invention. The various modifications to these embodiments will be readily apparent to those skilled in the art, and the generic principles defined herein may be applied to other embodiments without the use of the inventive faculty. Thus, the present invention is not intended to be limited to the embodiments shown herein but is to be accorded the widest scope consistent with the principles and novel features disclosed herein."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The features, objects, and advantages of the present invention will become more apparent from the detailed description set forth below when taken in conjunction with the drawings in which like reference characters identify correspondingly throughout and wherein:",{"@attributes":{"id":"p-0018","num":"0022"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0019","num":"0023"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0020","num":"0024"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0021","num":"0025"},"figref":"FIG. 4","b":"1"},{"@attributes":{"id":"p-0022","num":"0026"},"figref":"FIG. 5","b":"2"}]},"DETDESC":[{},{}]}
