---
title: Use of server processing of temporary results for stateless paging over arbitrary user queries
abstract: A query processor's capabilities may be employed to identify a range rows resulting from a user query to be returned. A server cursor may be declared, opened, fetched from and closed in a single batched request in order to avoid keeping state on a database server between requests. A single block fetch may be used within the batch to retrieve a requisite number of rows from a specified ordinal position. Where server cursors are not available, an intermediate table may be used to hold a subset of the rows resulting from the user query, and row numbers may be added to facilitate selecting the range of rows from that intermediate table. Intelligence within a query processor may be leveraged to support identifying the range of rows to be returned without maintaining state between client requests.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07849109&OS=07849109&RS=07849109
owner: Microsoft Corporation
number: 07849109
owner_city: Redmond
owner_country: US
publication_date: 20040730
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENTS","Overview"],"p":["The invention relates to paging data and in particular to the transient use of server cursors or temporary tables for stateless paging over arbitrary user queries.","OLTP (on-line transaction processing) refers to software that facilitates and manages transaction-oriented applications. OLTP is commonly used for data entry and retrieval transactions in a number of industries, including banking, airlines, mail-order, supermarkets, and manufacturers. OLTP today typically includes programs that allow real-time inputting, recording, and retrieval of data to and from a networked system. The speed of recording the data and the reaction time of the system is critical.","Historically, OLTP employs relational databases which maintain the state of the OLTP world. Previously, it was common for all the database interactions to be performed in batch mode at the direction of a database administrator who typically set up reports to be run, or operations to execute and so on within the context of the database. The data from the OLTP database was typically read out in a forward-only manner. A manager who wanted a report on sales in region three typically would request the report from the MIS (Management Information Systems) department and would have to wait some period of time until the report was produced.","As time passed, interactions with the OLTP data became more interactive. These early interactive interactions were typically small and quick transactional interactions. For example, an OLTP database might hold bank account information, which could be queried by a bank teller. The bank teller could often request a customer's banking activity over a period of time and would typically receive a stream of results, in a read only fashion. In time there was the ability, when positioned on one of those results, to modify the row positioned on. Such an operation is called a cursored operation, the term cursor referring to the current focus (e.g., a particular row) in a set of results. Hence, the bank teller now was able to update or delete records by positioning within the set results.","In addition to cursored operations are searched operations, enabling modification of records based on selected criteria. Searched operations require the record to be operated on to be uniquely identified. Typically this is done via a primary key. For example, if a deposit to account number 034 made on June 3 is to be deleted, the deposit may be assigned a transaction identifier, say 76342. To delete the deposit record, a request may be sent to the database system to delete transaction number 76342. Thus, searched operations are frequently more performant and scalable because positioning on a row and locking the row is avoided.","Cursored operations were originally designed to be run within the process of the database or if in an external process, at least programmatically, and thus are typically very fast because a program rather than a user is performing the operation. Because the processing was done programmatically, data was typically returned as a highly optimized forward-only stream of results. Operations such as viewing a previous record or moving to an arbitrary position in the result were not supported.","Problems with scalability emerge when users directly access the data because users are slow in comparison to the speed at which computers process data. For example, suppose a program retrieves certain specified activities, processes through those activities, and periodically updates, deletes or inserts a row. While a program could perform these tasks efficiently and minimize the contention for resources, a user performs tasks much less efficiently and the database is required to keep state for the user. Keeping state limits the number of people able to access the database at the same time because the database has to track usage and lock and unlock records as records are used and released.","Today, individuals want direct access to the data in real time. The Internet has been a driving force in this change in user expectations. For example, a user expects to be able to bid on an item at an auction site in real-time at the same time that other users are accessing that data. Now, however, the number of users sharing access to the data is enormous. When multiple people try to change or access the same records, contention results. Contention is a major factor limiting scalability.","Even in read-only scenarios, having to track state such as connection, sort order, aggregate and grouping values, temporary results, cursor position, etc., as each user navigates through a set of query results severely limits the ability of the database to scale to the number of concurrent users supported by common enterprise, let alone Internet, applications.","Pushing per-user state down to the client application typically improves scalability of the system by reducing the per-user state being maintained by the database. However, with an ever increasing sea of data, the number of results matching any particular query can be extremely large, and retrieving all of those results to keep state on the client can be expensive in terms of latency, network bandwidth, database and server resources, and client memory.","A common alternative to retrieving all of the results from a potentially large query is to return a range of results, for example the first 10 records, followed by the next 10, and so on. This is referred to as paging. However, paging is typically difficult to implement, particularly over ad-hoc user queries and stored queries or procedures.","In the absence of an easy-to-use paging mechanism, applications often query more data than needed and simply ignore results in excess of a single current page. Even when the results in excess of a single current page are ignored, the results may still be materialized and transmitted to a client, resulting in response delays and wasted resources.","It would be helpful if there were a way to easily request a range of rows from within a result set without holding state between requests.","Server side processing of temporary results is employed to identity a range of rows from within a result to be returned.","A query processor's cursoring capabilities may be employed to identify rows to be returned. The cursor may be declared using the query from a client, opened, fetched from and closed in a single batched request in order to avoid keeping state on a database server between requests. A single block fetch may be used within the batch to retrieve a requisite number of rows from a specified ordinal position. Intelligence within a query processor may be leveraged to support server cursors without maintaining state between client requests.","Where server cursors are not supported, the client query may be used to select results into a temporary table, further processing performed on the server to identify the rows to be returned to the user, and only those rows of interest returned to the user. Returning only a subset of rows reduces the data that has to flow from the server to the client, reducing network and client resource usage. Releasing the table before returning control to the user may avoid state being held on the server between user requests.","To execute a database command that returns a stream of results, a connection to a database to be accessed may be created and opened. A database command may be created including a query to be executed, and an execution command called to return an enumerator over the stream of results.","An execute page reader method to execute a command and return a single page from within an arbitrary result may be added to the database command object. The added method may receive a starting row ordinal and a number of rows to read, and return an enumerator, or reader, over a stream of results including only those rows within the specified range.","When the execute page reader method is called, the database command object may generate a batch statement that declares and opens a dynamic, server-side cursor over the user's query, calls a fetch method specifying an offset comprising the start row and a batch size of the size of the page. The cursor may be closed and de-allocated. Although a server-cursor may be used to efficiently position and retrieve the requested rows from the result, the server-cursor may be closed and de-allocated by the time the reader is returned. The results for the page may be read in a forward-only, read-only fashion, so the usage pattern is still focused on retrieving the data as a stream and then working with the results in a disconnected fashion.","Using this method, when a request is received for a range of rows from within a potentially large result, a server cursor is opened, positioned to the starting row, the number of requested rows are retrieved and any resources associated with the cursor are released prior to returning any results to the client. Cursor declaration, open, position, fetch, close and de-allocation actions may be done in a batch or as individual operations. The requested rows may be retrieved either in a single block fetch, multiple block fetches or each row individually.","Alternatively, when the execute page reader method is called, the database command object may generate a command to select the query results into a temporary table, for example, using a SELECT INTO statement. The results selected into the temporary table may be a subset of the full query results, for example the TOP statement may be used to limit the results to the number of rows before the starting row in the range plus the number of rows in the range. Further processing is performed on the server to identify the rows to be returned to the user, for example the addition of row numbers to the temporary table against which a predicate may be applied to select the rows of interest, or server commands to read past the rows to be skipped and return only those rows of interest. Selection into the temporary table on the server provides a mechanism for processing the results and returning only those within the desired range.","When a request is received for a range of rows from within a potentially large result, a temporary table may be created, processing performed to position on the starting row, the number of requested rows retrieved, and any resources associated with the temporary table released prior to returning any results to the client. Temporary table population, positioning, return of rows, and removal may be done in a batch or as individual operations. The results for the page may be read in a forward-only, read-only fashion, so the usage pattern is still focused on retrieving the data as a stream and then working with the results in a disconnected fashion.","In today's world, a user may make a request that resolves to a potentially large set of matches (for example, the results of a search engine search on the Internet). Where the number of rows in the result exceed what can be shown on a single screen, users expect to be able to navigate, or \u201cscroll\u201d, forward and backward through the results, displaying a screen full of data at a time. When the number of rows in the result is very large, having to wait until all the results are transmitted to the client machine may be very undesirable, both in terms of user delay as well as the use of database, network, and client memory and processing resources.","Server Cursors","Many databases offer the ability to scroll through a set of results through the use of \u201cServer Cursors\u201d (result set cursors maintained within the database). Server cursors provide a convenient model for traversing potentially large sets of results. Server cursors may support the ability to move, forward, backward, or to an arbitrary position within a result and fetch one or more rows from the current position, matching the types of operations a user may perform when scrolling through a set of results, for example, in a grid.","Types of scrollable server cursors include a static or snapshot cursor, a keyset cursor and a dynamic cursor. With a snapshot cursor, a temporary copy is made of the entire result. Cursor operations scroll over the temporary copy of the data. Because the copy is a snapshot of the data as it exists in a moment of time is captured, changes made to the database for data in the snapshot is not reflected in the copy made and therefore is not visible to a user of the data for the lifetime of that cursor.","A keyset cursor maintains a list of indexes to rows requested in a query. As a user scrolls through the data, he is actually scrolling through the index and when a value is requested for the row, the current value associated with the chosen index is retrieved from the database. Thus, if a change is made to a row in the database, the change will be visible to the user. If, however, a new record is added that would logically have been part of the set selected by the user, the new record will not be visible because the index of the new record is not within the list of indexes the user can view. Similarly if someone changes the values of an existing row in the result such that it no longer matches the criteria specified for the result, changes the values of an existing row outside of the result such that it now matches the criteria and logically belongs as part of the result, or changes a value on which the result is sorted, the set and order of rows visible to the user remains unchanged and does not reflect the corresponding expected removal from, addition to, or change in ordering of, the result.","A dynamic cursor requires a unique index across a set of results. As the user scrolls through the data, next or previous records are calculated dynamically, based on a combination of the original query and the value of the current row. Changes made to the database are visible to the user as are insertions and deletions made to the database.","Each of these types of scrollable server cursors require the database server to maintain state for each set of results between database requests, and may require the client to release that state when the results are no longer in use. These requirements may become problematic in a large enterprise or web environment where holding state between requests for each client is expensive, and the lifetime of that state may be indeterminate.","Building a scalable, distributed system such as is required for today's enterprise applications is advanced by minimizing state held in shared resources. In particular, databases often become the bottleneck in the scalability of a system since they represent the true, persistent state of information often shared by multiple resources. Accordingly, scalability is achieved by limiting applications to short interactions with the persisted data, and not holding user state in the database between interactions.","It will be apparent that the desire of users to interact richly with data is at odds with scalability. To improve scalability while still offering a rich user experience, enterprise applications are moving to more of a disconnected model, where transient state is kept on the client and the database contains only durable state. Interactions with the durable state are generally kept to simple retrieval or update operations, with no user state held on the database in between. The advantage of a disconnected programming model lies in the fact that the database is able to share connections across multiple different clients instead of holding many open connections and other user state at the same time. More state is maintained on the client, and interactions are generally well defined and short lived. In short, the concept of disconnected programming is key in building scalable applications.","Client Cursors","The three types of scrollable cursors may also be implemented on the client. To implement the static or snapshot cursor on the client, the entire set of rows requested from the database are copied to the client machine. For large results this has the affect of copying and holding a potentially large amount of data to the client that the user may never view, resulting in high latency, increased network traffic, increased database load, and excessive memory consumption on the client.","A keyset cursor may also be implemented on the client where keys are available for each row of the result by retrieving the set of keys and querying the database for the remaining row values based on the key each time the application requests a row. However, similar to the static or snapshot cursor, a keyset cursor over a large result must download keys for every row in the potentially large result. Additionally, each scrolling operation results in additional queries against the database for the corresponding row values. Finally, this mechanism doesn't work well for results that don't have unique keys for each row, such as joined, grouped or aggregated results, or results returned by a stored query or procedure.","To implement a dynamic cursor on the client, knowledge of the sort order and the keys of the database is required so that a user's query can be rewritten to find a value greater than or less than sorted key values of the current row. Again, in addition to the complications of rewriting the query on the client, such keys may not be available for certain types of results.","Paging","In cases where the results of a query are potentially large, enterprise applications generally employ a strategy known as paging wherein each client request retrieves a moderately sized subset (page) of the data. Pages are typically defined by the ordinals of the rows they contain. For example, a user can request to see the first ten results. Typically an option exists to get the next ten and the previous ten as well, if those results exist. When a user clicks \u201cnext\u201d, for example, the request is typically sent out again to the database requesting results -, and so on.","The simplest way to do paging is to request all the results, and disregard those outside of the current page. Let's say the application retrieves ten rows for the first page, and disregards the rest of the results by closing the result. If the user subsequently requests the next page, the same query is sent, all the results are again received but the first ten results are ignored and results are displayed starting with the 11result. The database may well have performed a lot of additional needless work, wasting processing power and time.","Typically closing the results is implemented by calling a close method on the result object. A disadvantage of using this method is that some or all of the remaining results from the database may have to be read to clear off the wire (that is to clear off the pipe or connection). Some database systems are optimized so that once the database starts sending data, data continues to be written into the pipe until all of the results have been sent. For example, if a search engine search on the Internet has been done, and the user has looked at the first ten records, to clear the pipe, a million records may have to be read off the wire.","A cancel method for the command may exist that may be issued on a back channel to cancel the reading of data into the pipe, but some number of cached up results may still have to be read. Additionally, the database may have done other unnecessary processing to get to that point.","So, while there are ways to mitigate the handling of the first several pages, if a user asks for rows  thru , the first 1000 records are read and ignored, the application closes the result, and another buffer full of records has to be processed in order to process the stop command, a noticeable decrease in performance is likely to result.","To address the problem of limiting the number of results returned, a TOP clause may be specified in a query so that only the first n records are retrieved and the database stops. This addresses the problem of selection the first set of records. The TOP clause, however, is not useful if a user requests a set of records starting at row . Additionally, TOP queries may not be supported in conjunction with results returned from stored queries or procedures.","Where queries are known in advance, paging can be implemented on the client through a parameterized query that accepts starting and\/or ending values for an ordered key, or by dynamically generating a query in order to select the requested subset of data from the server. However, this generally requires knowledge of the query's sort order, key columns, and\/or result row numbering support in the query processor in order to generate the proper queries. This information is difficult to obtain for an arbitrary query, which would in turn have to be parsed and rewritten to limit results to a single page of values. Since this parsing and rewriting occurs on the client, ensuring that semantics of the server query are maintained is particularly problematic.","In addition, client results are often obtained by executing stored queries or procedures defined within the database. The use of stored queries and procedures improves performance and enhances manageability of the database logic. However, since the stored queries or procedures are defined within the database, not on the client, they don't lend themselves to the type of client-side rewriting needed to support cursoring on the client.","For all of these reasons, efficient paging has long been a challenge, particularly where the queries are generated by the client in an ad-hoc fashion.","In accordance with the invention, a series of commands is provided to the server in order to identify and return a range of rows within a query result. Commands may be issued to create a temporary result on the server, position to the first row to be returned, return the requested range of rows, and then release the temporary result. These commands may be sent to the database in a single batch in order to avoid keeping state on the database server between requests.","In one embodiment of the invention, the query processor's cursoring capabilities are exploited not to hold state between request but rather to identify a range of rows to be returned by a single request. The cursor may be declared, opened, fetched from, closed and deallocated in a single batched request in order to avoid keeping state on the database server between requests. A single block fetch may be used within the batch to retrieve the requisite number of rows from the specified ordinal position. This approach is able to exploit intelligence built in to the query processor to support server cursors while avoiding maintaining state between client requests and without having to further parse or understand the query on the client.","In an alternate embodiment of the invention, database statements are used select a range of results from a temporary table created to hold the results of the query. The temporary table may be populated, the desired rows retrieved, and the temporary table released in a single batched request in order to avoid keeping state on the database server between client requests. This approach minimizes the data sent to the client while avoiding maintaining state between client requests without the need to parse or understand the query on the client.","In yet another embodiment of the invention, a simple forward only cursor may be substituted for the temporary table, and further processing may include database commands (for example, transact sql (TSQL) statements) to read past the rows to be skipped and return only those rows of interest.","Exemplary Computing Environment",{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 1"},"Although not required, the invention can be implemented via an application programming interface (API), for use by a developer, and\/or included within the network browsing software which will be described in the general context of computer-executable instructions, such as program modules, being executed by one or more computers, such as client workstations, servers, or other devices. Generally, program modules include routines, programs, objects, components, data structures and the like that perform particular tasks or implement particular abstract data types. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments. Moreover, those skilled in the art will appreciate that the invention may be practiced with other computer system configurations. Other well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers (PCs), automated teller machines, server computers, hand-held or laptop devices, multi-processor systems, microprocessor-based systems, programmable consumer electronics, network PCs, minicomputers, mainframe computers, and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network or other data transmission medium. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 1","b":["100","100","100","100"]},"With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus (also known as Mezzanine bus).","Computer  typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer  and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CDROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared, and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk , such as a CD ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in  provide storage of computer readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices such as a keyboard  and pointing device , commonly referred to as a mouse, trackball or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus , but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB).","A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . A graphics interface , such as Northbridge, may also be connected to the system bus . Northbridge is a chipset that communicates with the CPU, or host processing unit , and assumes responsibility for accelerated graphics port (AGP) communications. One or more graphics processing units (GPUs)  may communicate with graphics interface . In this regard, GPUs  generally include on-chip memory storage, such as register storage and GPUs  communicate with a video memory . GPUs , however, are but one example of a coprocessor and thus a variety of coprocessing devices may be included in computer . A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface , which may in turn communicate with video memory . In addition to monitor , computers may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","One of ordinary skill in the art can appreciate that a computer  or other client device can be deployed as part of a computer network. In this regard, the present invention pertains to any computer system having any number of memory or storage units, and any number of applications and processes occurring across any number of storage units or volumes. The present invention may apply to an environment with server computers and client computers deployed in a network environment, having remote or local storage. The present invention may also apply to a standalone computing device, having programming language functionality, interpretation and execution capabilities.","Use of Server Processing for Stateless Paging over Arbitrary User Queries",{"@attributes":{"id":"p-0068","num":"0067"},"figref":["FIG. 2","FIG. 2","FIG. 1"],"b":["200","202","204","202","204","110","180","202","206","208","208","208","212","208","204","212"]},"Client side processing through a common data access layer  encapsulates common functionality against database accessing code . Data access layer  may be part of database accessing code  or may be a separate component that abstracts possibly multiple calls to database accessing code  in response to a single method invocation from application . Application  running on client  may communicate with data access layer . For example, application  may request data access layer  to connect to database . In response, data access layer  may request database accessing code  to open a connection to database . Application  may provide a string to data access layer . The string may comprise a query to be made against database . An exemplary string may be:","SELECT*FROM customers.","Alternatively, the client application  may provide input to data access layer  from which data access layer  generates a database request .","The client-side database accessing code  may send the request  to the corresponding server-side database . The request may be interpreted, optimized and executed and the results  may be packaged up and sent back to the client .","If results are viewed through a static or, where possible, keyset or dynamic server cursors, state may be maintained by the database for each result with uncertain lifetime semantics. Alternatively, if the results are viewed via implementation of a static or snapshot cursor on the client, the results sent from the database  are typically a copy of all of the rows selected by the query. If on the client, the results are viewed via implementation of a keyset server cursor, the key for each row are typically retrieved with additional server requests each time values for a particular row are requested. Implementing a keyset or dynamic cursor on the client requires additional information and query rewriting that does not lend itself to many types of ad-hoc or stored queries or procedures.","Hence, the problem of only bringing across the rows requested without holding unnecessary state on the database between requests remains. To address this problem, in accordance with some embodiments of the invention, the data access layer may create a temporary result within the database, such as a scrollable cursor or temporary table. The data access layer may position to a particular place within a set of results, and fetch a certain number of rows from that position. That is, in response to receiving a request for a range of records, the data access layer may request the database to create a scrollable cursor or temporary table for the fields of the database specified, position at a particular row and return the next specified number of rows. This is in contrast to a user interacting with the database and holding state between different requests.","This technique has the advantage that it is not necessary to parse the query at the client, instead the query is passed to the database with the following instructions: create a temporary result within the database, position to the position specified, return the specified number of rows and release the temporary result. Hence, the database avoids maintaining state on the client between requests.",{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 3","b":["302","304","306","308","310","312","314"]},{"@attributes":{"id":"p-0077","num":"0076"},"figref":"FIG. 4","b":["308","402","404","406","408"]},"Processing temporary results on the database server to return only a subset of rows reduces the data that has to flow from the server to the client, reducing network and client resource usage. Releasing the temporary results before returning control to the user avoids state being held on the server between user requests. The creation of the temporary results, additional server processing of results to identify and return rows within a specified range, and disposal of the temporary results may be done as individual statements, or some or all of the steps may be combined as in a batch. In any case, the use of the temporary results allows a subset of the results to be programmatically determined without parsing or obtaining additional knowledge regarding the original query.","In some embodiments of the invention, a single call is made (e.g., in some embodiments of the invention, execute page reader is the name of the call). Hence state is not held, only the requested rows have been read over the wire, state has been released, the database has been given the opportunity to optimize that batch of statements and how it positions and retrieves that set of rows.",{"@attributes":{"id":"p-0080","num":"0079"},"figref":["FIG. 5","FIG. 4"],"b":["502","504","506","508","510"]},"In some embodiments of the invention, the commands may be batched together and sent to the server in a single datastream. To request a server cursor, rather than calling an execution command to execute the database query, a set of commands may be called. These commands can be batched together and may include:","instead of executing the query statement, declare a cursor, using a supplied query string and parameters","open the cursor","fetch from that cursor starting at position x for y number of rows","close the cursor","de-allocate the cursor.","In some embodiments of the invention, the client-side database software batches the above commands into a single statement, separated for example by semicolons, and sends the statement to the database. The database may parse the statement, optimize it, process it, declare the cursor, open the cursor, position to the specified row number, get the indicated rows, send the indicated rows back to the client, close and de-allocate the cursor. In some embodiments of the invention, all these steps are accomplished in one round trip. Batching the steps into a single request may result in greater efficiency and minimize the length of time the connection is held open and the state on the database is maintained.",{"@attributes":{"id":"p-0088","num":"0087"},"figref":["FIG. 6","FIG. 4"],"b":["602","604","606","608"]},"In some embodiments of the invention, the commands may be batched together and sent to the server in a single datastream. To perform additional server processing to limit the rows returned, rather than calling an execution command to execute the database query, a set of commands may be called. These commands can be batched together and may include:","instead of executing the query statement, select a subset of the results into a temporary table using a supplied query string and parameters","position to the starting row in the temporary table","fetch the requested number of rows from the temporary table","delete the temporary table","In some embodiments of the invention, the client-side database software batches the above commands into a single statement, separated for example by semicolons, and sends the statement to the database. The database may parse the statement, optimize it, process it, create and populate a temporary table to hold a subset of the results, position to the specified row number, get the indicated rows, send the indicated rows back to the client, and drop the table. In some embodiments of the invention, all these steps are accomplished in one round trip. Batching the steps into a single request may result in greater efficiency and minimize the length of time the connection is held open and the state on the database is maintained.",{"@attributes":{"id":"p-0095","num":"0094"},"figref":["FIG. 7","FIG. 4"],"b":["702","704","704","702","706","708"]},"In some embodiments of the invention, the commands may be batched together and sent to the server in a single datastream. To perform additional server processing to limit the rows returned, rather than calling an execution command to execute the database query, a set of commands may be called. These commands can be batched together and may include:","instead of executing the query statement, select a subset of the results into a temporary using a supplied query string and parameters","add row numbers to the temporary table","select the range of rows to be returned to the client using the added row numbers","delete the temporary table","In some embodiments of the invention, the client-side database software batches the above commands into a single statement, separated for example by semicolons, and sends the statement to the database. The database may parse the statement, optimize it, process it, create and populate a temporary table to hold a subset of the results, add row numbers, select a range of rows to return to the client using the row numbers, and drop the table. In some embodiments of the invention, all these steps are accomplished in one round trip. Batching the steps into a single request may result in greater efficiency and minimize the length of time the connection is held open and the state on the database is maintained.","In some embodiments of the invention, database client code may be written to a specific database about which additional information is known. Such information may include how the database creates, executes and retrieves the data from that server cursor in the database.","The various techniques described herein may be implemented in connection with hardware or software or, where appropriate, with a combination of both. Thus, the methods and apparatus of the present invention, or certain aspects or portions thereof, may take the form of program code (i.e., instructions) embodied in tangible media, such as floppy diskettes, CD-ROMs, hard drives, or any other machine-readable storage medium, wherein, when the program code is loaded into and executed by a machine, such as a computer, the machine becomes an apparatus for practicing the invention. In the case of program code execution on programmable computers, the computing device will generally include a processor, a storage medium readable by the processor (including volatile and non-volatile memory and\/or storage elements), at least one input device, and at least one output device. One or more programs that may utilize the creation and\/or implementation of domain-specific programming models aspects of the present invention, e.g., through the use of a data processing API or the like, are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However, the program(s) can be implemented in assembly or machine language, if desired. In any case, the language may be a compiled or interpreted language, and combined with hardware implementations.","While the present invention has been described in connection with the preferred embodiments of the various figures, it is to be understood that other similar embodiments may be used or modifications and additions may be made to the described embodiments for performing the same function of the present invention without deviating therefrom. Therefore, the present invention should not be limited to any single embodiment, but rather should be construed in breadth and scope in accordance with the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing summary, as well as the following detailed description of illustrative embodiments, is better understood when read in conjunction with the appended drawings. For the purpose of illustrating the invention, there is shown in the drawings exemplary constructions of the invention; however, the invention is not limited to the specific methods and instrumentalities disclosed. In the drawings:",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 6","FIG. 4"]},{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 7","FIG. 4"]}]},"DETDESC":[{},{}]}
