---
title: Dynamic manipulation of archive files
abstract: A method, apparatus, and article of manufacture provide the ability to edit in-place a ZIP™ archive file. A file and a first file block (FFB) in a first block location are opened and modified. If the first block location can accommodate the modified FFB, the modified FFB is saved, in-place, in the first block location without rewriting the entire archive. However, if the first block location cannot accommodate the modified FFB, a second file block is copied from a second block location to a third block location located at an end of a file data section of the archive. A portion of the second block location is marked as a free block and the modified FFB is saved without rewriting the entire ZIP™ archive. The archive is then saved by updating and saving both the central directory and end of central directory.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08024382&OS=08024382&RS=08024382
owner: Autodesk, Inc.
number: 08024382
owner_city: San Rafael
owner_country: US
publication_date: 20090120
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS","Example","CONCLUSION"],"p":["1. Field of the Invention","The present invention relates generally to ZIP\u2122 archive files, and in particular, to a method, apparatus, and article of manufacture for the dynamic manipulation of ZIP\u2122 archive files supporting efficient read-write access for in-place editing, growth, defragmentation and recoverable deletion.","2. Description of the Related Art","Files and folders can consume a considerable amount of memory and storage. The electronic transmission of large files and folders can be slow based on the limited bandwidth of the available transmission medium. Additionally, it is often desirable to archive files and folders. To overcome such size and transmission constraints as well as to support archiving, files and folders are often compressed and\/or stored in an archival format. The ZIP\u2122 file format is one such data compression and archival format. However, in the prior art, when any file stored in a ZIP\u2122 file has been edited, the entire file must be rewritten. Accordingly, there is a limited capability and aversion to performing any read-write manipulation of an interior file or subsection of data within an archive. These problems may be better understood with an explanation of the ZIP\u2122 specification and prior art solutions.","Fundamentally, the ZIP\u2122 specification describes a delimited linear arrangement of embedded files each preceded by an informational header and the whole file suffixed by a central directory or table of contents. Such a format is a convenient read-only, write-once archive suitable for collecting hierarchies of files and folders. However, this design does not lend itself well for read-write manipulation of any interior file or subsection of data within. Traditionally, such limitations have been overlooked or left unchallenged as the format has primarily been used as an archival mechanism. Increasingly though, applications are venturing into using openly accessible multi-part formats such as ZIP for native data storage. It is not new that application files are of this nature but the open ZIP format is becoming (if it has not already become) the de facto standard for such implementations. The appeal is that a multitude of free and for-fee applications and libraries exist for reliably manipulating file archives of this format. The specification is open and available and source code exists in the public domain for reference and usage.","In view of the above, some prior art products either do not use ZIP\u2122 files for native data storage and instead write custom solutions, use structured storage (e.g., Microsoft\u2122 structured storage) or simply rewrite the entire archive file with every change. However, such solutions are limited and inflexible.",{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1","b":["102","102","104","104","102","102","104","104","106","106","104","104","102","102"]},"The data descriptors \/N exists only if bit 3 of the general purpose bit flag is set. It is byte aligned and immediately follows the last byte of compressed data. This descriptor is used only when it was not possible to seek in the output .ZIP file, e.g., when the output .ZIP file was standard output or a non-seekable device. For ZIP64\u2122 format archives, the compressed and uncompressed sizes are 8 bytes each. It includes a 32-bit checksum value to detect the accidental alteration of data during transmission or storage, the compressed and uncompressed sizes of the file data \/N.","The archive decryption header  is part of the ZIP archive strong encryption scheme and precedes an encrypted data segment (i.e., the archive extra data record  and the encrypted central directory structure data ). The archive decryption header  contains information relating to the encryption of the encrypted data segment \/ including an encryption algorithm identifier, a bit length of the encryption key, processing flags needed for decryption, etc.","The archive extra data record  is part of the ZIP archive strong encryption scheme, immediately precedes the central directory data structure  and provides a signature, an extra field length, and extra field data that is used as part of the strong encryption scheme.","The central directory structure  consists of a series of file headers that provide the relative offset of each local file header \/N as follows:\n\n","Each file header in the central directory contains versioning information, modification date and times, compression information (for the file header), the compressed and uncompressed file sizes (i.e., of the file data \/N), various fields and their lengths (including a file name, extra field and file comment) as well as various file attributes. Lastly, the central directory contains the relative offsets of the local file headers \/N.","The ZIP\u212264 End of Central Directory Record  includes versioning information (for extraction of the file data \/N), the total number of entries in the central directory, the size of the central directory, and the offset of the start of the central directory.","The ZIP\u212264 End of Central Directory Locator  provides the location (i.e., the relative offset) of the ZIP\u212264 End of Central Directory Record .","The End of Central Directory Record  provides the total number of entries in the central directory, the size of the central directory, and the offset of the start of the central directory.","In view of the above, it can be seen, that the location of a file \/N is indicated in the central directory  which is located at the end of the ZIP\u2122 file. In this regard, each file data \/N is introduced by a local header with information such as the comment, file size, and file name. The central directory  consists of the headers holding the relative offset of the local headers \/N for each file. The end of central directory information - (which is at the very end of the ZIP\u2122 file) provides the information (i.e., offset) to find the beginning of the central directory  so that local file header information \/N can be retrieved from the central directory .","As can be seen, the above described structure provides a convenient read-only, write-once archive suitable for collecting hierarchies of files and folders. However, there is no capability to modify the ZIP\u2122 file without writing the file from start to finish. In this regard, every time a ZIP\u2122 file is modified, the entire ZIP\u2122 file is required to be rewritten. What is needed is the capability to easily and efficiently perform in-place editing of a ZIP\u2122 file while complying with the ZIP\u2122 file format specification (which is set forth in \u201cAPPNOTE.TXT\u2014ZIP File Format Specification, Version 6.3.2, Sep. 28, 2007, by PKWare, Inc.\u201d which is fully incorporated by reference herein).","One or more embodiments of the invention build, maintain and leverages a free-block list, where a block is characterized as interior (ZIP\u2122 local) files, such that space allocated to the ZIP\u2122 archive may best be leveraged for efficient use and reuse. Blocks can be valid files or \u201cdead zones\u201d invisible to archive directory. Allocated block space may be reused for other blocks to maximize allocation commitment data saturation.","Embodiments further allow for a ZIP\u2122 archive to be accessed in a read-write fashion such that ranges of bytes (data strides) may be queried, decompressed, modified, recompressed and stored without incurring a rewrite of the entire file. In this regard, two different modes\u2014an append mode, and an automatic growth\/reclamation mode may be available.","In the append mode, modified blocks are appended to the file stream rather than being manipulated in pre-allocated space. Such a configuration supports efficient \u201cin-place\u201d growth of data by eliminating the need to rebuild the entire file. This process leaves orphaned \u201cfree\u201d blocks in the archive stream that may be reclaimed at a later time.","In automatic growth\/reclamation mode, all blocks are subject to consideration by the algorithm for relocation within the allocation commitment (of the archive file stream). Free blocks may be reclaimed to optimize allocation and minimize unused space. New blocks may be appended to the end of the stream to satisfy growth commitments. Such a configuration eliminates the need to rewrite the file entirely, instead leveraging random access to modify the data stream.","Accordingly, embodiments of the invention allow ZIP\u2122 archived data to be \u201cundeleted\u201d in whole or in part. As the archive grows \u201cin place\u201d, it is possible that data blocks are simply abandoned in the archive. These blocks are tracked and can be recovered. If all of the blocks that compose the logical archived file are in existence, the entire data can be recovered.","Further, embodiments can dynamically determine the need for either ZIP32\u2122 or ZIP64\u2122 specification compliance and automatically modify the internal file structure to ensure said compliance. ZIP32\u2122 is the traditional and most widely support specification set but is constrained by the 32-bit address space. ZIP64\u2122 uses a full 64-bit address space and may at times be required to correctly describe the contents of the archive. The combination of the data blocking and dynamic determination of data content provides the ability to author archive files using either strategy. Embodiments may also leverage the 32-bit deflate\/inflate algorithms for all data regardless of the specification compliance.","In addition, embodiments of the invention are performed within the constraints of the ZIP\u2122 specification such that any and all ZIP\u2122 files produced are valid.","In the following description, reference is made to the accompanying drawings which form a part hereof, and which is shown, by way of illustration, several embodiments of the present invention. It is understood that other embodiments may be utilized and structural changes may be made without departing from the scope of the present invention.","Hardware and Software Environment",{"@attributes":{"id":"p-0042","num":"0043"},"figref":"FIG. 2","b":["200","202","204","206","200"]},"One or more embodiments of the invention are implemented by a computer-implemented program , wherein the program  is represented by a window displayed on the display device . Generally, the program  comprises logic and\/or data embodied in, or readable from a device, media, carrier, or signal, e.g., one or more fixed and\/or removable data storage devices  connected directly or indirectly to the computer , one or more remote devices coupled to the computer  via a data communications device, etc.","In one or more embodiments, instructions implementing the program  are tangibly embodied in a computer-readable medium, e.g., data storage device , which could include one or more fixed or removable data storage devices, such as a zip drive, floppy disc drive, hard drive, CD-ROM drive, DVD drive, tape drive, etc. Further, the program  is comprised of instructions which, when read and executed by the computer , causes the computer  to perform the steps necessary to implement and\/or use the present invention. Program  and\/or operating instructions may also be tangibly embodied in a memory and\/or data communication devices of computer , thereby making a computer program product or article of manufacture according to the invention. As such, the terms \u201carticle of manufacture\u201d and \u201ccomputer program product\u201d as used herein are intended to encompass a computer program accessible from any computer readable device or media.","Those skilled in the art will recognize that the exemplary environment illustrated in  is not intended to limit the present invention. Indeed, those skilled in the art will recognize that other alternative environments may be used without departing from the scope of the present invention.","Structural Overview","One or more embodiments of the invention implement a program  in the form of a compression or archive application that enables in-place editing of ZIP\u2122 files. To provide such capabilities and to overcome the disadvantages of the prior art, embodiments of the invention utilize the concept of a logical data block where different ZIP\u2122 archive data sections are abstracted as different type of blocks. As used herein, a block is a logical representation of a physical file segment, and has one or more of the following attributes which combined together can identify a block: block offset, block size, block dirty flag, and block types. The different block types may include a local file block, and indexing\/metadata block, and a raw data block.","Local File Block","A local file block is a logical representation of a ZIP\u2122 [archive] entry. Mapped to physical storage, a local file block includes the local file header \/N, local file data \/N, and local file descriptor \/N (if provided). Note that for local file data \/N, the local file block is virtually linked to the data by recording the attributes of the data, such as start offset and length, dirty state, and so forth instead of maintaining an entire copy of the data in memory. A local file block has the same signature as the ZIP\u2122 local file header (0x04034b50) \/N.","Indexing\/Metadata Block","An indexing block (also referred to as a metadata block) doesn't contain any ZIP\u2122 entry data. Instead, an indexing block serves the sole purpose as indexes to local file blocks. These blocks may represent various blocks from the ZIP64\u2122 or ZIP32\u2122 format and may include a central directory block , end of central directory block , ZIP64\u2122 end of central directory block , and\/or ZIP64\u2122 end of central directory locator block . Among these block types, the central directory block  and the end of central directory block  are applicable for both ZIP32\u2122 and ZIP64\u2122 archive format; the ZIP64\u2122 end of central block  and ZIP64\u2122 end of central directory locator block  are only applicable to the ZIP64\u2122 archive format. Each index block has the same signature of a corresponding zip header \/N. For example, the signature of the central directory block  has the same signature of the ZIP\u2122 central directory file header (0x02014b50) (also referred to as the archive decryption header ).","Raw Data Block","A raw data block is a block which is neither a local file block, nor an indexing block. A raw block isn't registered with the indexing information (offsets) in indexing blocks; in other words, a raw block is isolated\u2014a \u201cdead zone\u201d\u2014that is completely hidden from a ZIP\u2122 implementation which uses indexing blocks as the only authorized source for locating blocks. A raw block can have a signature or not, since the algorithm to discover a raw block doesn't depend on the signature. In implementation, for convenience, 4 bytes may be reserved as a raw block signature, and another 8 bytes to store the block size value as follows (the signature is 0x02014c48):",{"@attributes":{"id":"p-0053","num":"0054"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Header: 12 bytes (4 byte signature + 8 byte block size)"]},{"entry":[{},"Block data"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Given the special signature, the implementation might not need to consult the free block list for finding free blocks. For example, at the end offset of a local file block, implementation can \u201cpeek\u201d next 4 bytes, if it's equal to the raw data block signature, then it's safe to draw the conclusion that a raw data block is following the current local file block. Such an implementation may be useful for in place editing because a local file block can decide in this simple way whether or not there are some growth spaces immediately after it, without looking up the free block list previously built by the dynamic free block locating algorithm as described in further detail below. However, a free block list may also be maintained and cached.","One note here is that since the minimum block size for a raw block with signature may be 12 bytes or more; this implies not all orphaned blocks can be marked this way. For example, a block with only two (2) bytes doesn't have enough space for a signature to fit in. For these small blocks, a search of the invention may still find the small blocks, and one or more implementations can defragment pieces of these blocks by moving and merging them together to achieve better space usage efficiency.","Infrastructure","With the concept of block, an infrastructure that can manage the blocks is useful. Embodiments of the invention utilize a ZIP\u2122 object model, which is a virtual file system laying on top of the physical ZIP\u2122 archive. This virtual file system is I\/O agnostic as it operates on top of a generic stream model which only requires implementations of stream concepts, like read, write, seek, etc. The implementation is free to choose different existing IO mechanisms, like basic C input output, std iostream, memory mapped files, etc. to implement the stream concepts","Block Processing","Load Process of Blocks","As described above, various blocks are used in the ZIP\u2122 file. Some of the blocks (i.e., local file blocks) are indexed (i.e., via the central directory or indexing blocks stored in the central directory) while others (i.e., raw data blocks) are not. To properly address and establish the ZIP\u2122 capabilities of embodiments of the invention, the various blocks may initially be loaded. This loading process essentially establishes the structure of the file system to be used.","To locate and load the various blocks, the central directory  is used. The initial task is determining where the central directory  starts and ends. The end of central directory record  is used for this purpose. As illustrated in  (and the text above), for any valid ZIP\u2122 file (ZIP32\u2122 or ZIP64\u2122) the end of central directory record  must be present. So the signature of end of central directory  (0x06054b50) (which is the first entry in the end of central directory record ) is the bootstrap signature where the entire loading process is fired. In other words, regardless of whether the files ZIP32\u2122 or ZIP64\u2122, all ZIP\u2122 files have the end of central directory record .","To find the beginning of the end of the central directory record  (i.e., the signature), a back scan of the ZIP\u2122 archive is performed. The backscan is performed from an offset (that is calculated based on the characteristic of the end of central directory record ) to the end of ZIP\u2122 archive. The minimum and maximum sizes of the end of central directory record  are known (based on the standard data in the end of central directory record ). In addition, the end of central directory  is always continuously stored as the last chunk of data in the ZIP\u2122 archive. Accordingly, only part of the file ZIP\u2122 file needs to be scanned, instead of from the start of ZIP\u2122 archive (offset 0), thereby minimizing I\/O and improving performance.","The backscan essentially scans four bytes at a time until the entire end of central directory record  is loaded. However, to load the actual data blocks, a determination must be made regarding whether the ZIP\u2122 file is ZIP32\u2122 or ZIP64\u2122 compliant. In this regard, different loading may need to be performed depending on whether the ZIP\u2122 file is a ZIP64\u2122 or ZIP32\u2122. Accordingly, to determine where the other indexing blocks are (which will point to the correct locations of the file blocks themselves) the process must determine the type of ZIP\u2122 file. Based on the data in the end of central directory record  that has been loaded, a determination can be made regarding whether the ZIP\u2122 file is ZIP32\u2122 or ZIP64\u2122 compliant. For example, the following properties in the end of central directory record  may be used to determine the type of ZIP\u2122 file: number of the disk, the number of the disk with the start of the central directory, the total number of entries in the central directory on this disk, the total number of entries in the central directory, the size of the central directory, and the offset of the start of the central directory with respect to the starting disk number. In this regard, if any of these fields in the zip end of central directory record  is in its maximum size (0xffff for 16 bits, 0xffffffff for 32 bits), the ZIP\u2122 archive is a ZIP64\u2122 format file.","Once it has been determined whether the ZIP\u2122 archive is a ZIP32\u2122 or ZIP64\u2122 archive, the loading process for the ZIP\u2122 files can be initiated.","For ZIP32\u2122 files, the central directory  starting offset is indexed directly in the end of central directory record  field \u201coff set of start of central directory\u201d. Thus, after locating and loading the central directory , each central file header \/N can be used to index the offset of each local file block. Thereafter, each local file block is located and loaded.","For ZIP64\u2122 files, the central directory  starting offset is indexed in the ZIP64\u2122 end of central directory record . The ZIP64\u2122 end of central directory record  is indexed in the ZIP64\u2122 end of central directory locator . Thus, to index the central directory , the ZIP64\u2122 end of central directory locator  must be located. This locator  is immediately layout adjacent to the end of central directory record . Accordingly, the end of central directory locator  can be easily located and all of the blocks can be loaded thereafter.",{"@attributes":{"id":"p-0066","num":"0067"},"figref":"FIG. 3","b":["300","118","302","118"]},"At step , a determination is made regarding whether the ZIP\u2122 archive is ZIP32\u2122 or ZIP64\u2122. If the archive is ZIP32\u2122, the central directory  is loaded based on the data in the end of central directory record  at step . However, if the archive is ZIP64\u2122, the ZIP64\u2122 end of central directory locator  is used\/loaded at step  to find the ZIP64\u2122 end of central directory record  which is read at step  and which in turn is used to identify the location of the central directory  which is loaded at step . Thereafter, based on the data in the central directory , the local data blocks are loaded at step .","Saving Process","When a block in the archive (e.g., a ZIP\u2122 entry) is modified\/updated, the updates should be saved within the archive or they will be lost. The saving process updates the modified or dirty ZIP\u2122 entry. Each block (including the central directory  entry) in the ZIP\u2122 archive has a dirty flag that indicates whether the block has been modified since the last save operation.","Thus, when conducting a save operation, a loop checks the dirty flag for each block entry. However, if a block is dirty, it must update and mark all of the block's references as also being dirty (or as requiring an update). Thus, every block will first perform a pre-save refresh to update its references. For example, each entry in the central directory  (i.e., the central file header) has a reference to the corresponding local file block \/N, so before every central directory  entry (i.e., central file header) is saved, it needs to update the information from the local file block \/N\/header \/N.","As an example, suppose a local file block \/N has been modified. Once modified, the presave operation would update the local file header \/N information. The central directory  and headers within the central directory reference each local file block \/N. Accordingly, the central directory  headers are dirty (since the local file block \/N has been modified). The central directory  headers are updated with the up-to-date local header \/N information. Once complete, the central directory is up-to-date. Thereafter, the end of central directory records - must be updated to reflect the accurate information (e.g., the total number of entries in the central directory and end of central directory or ZIP64\u2122 end of central directory pointers).","In view of the above,  illustrates the logical flow for performing a save sequence to update a ZIP\u2122 archive file in accordance with one or more embodiments of the invention. At step , the local file blocks \/N are saved. At step , the central directory  is updated with the up-to-date information from the local file blocks \/N and local file header \/N information. At step , the ZIP64\u2122 end of central directory record  is updated (e.g., if it is in the ZIP64\u2122 format). At step , the ZIP64\u2122 end of central directory locator  is updated with the most recent information (if it is in the ZIP64\u2122 format). Lastly, at step , the end of central directory record  is updated with all of the updated information.","In one or more embodiments of the invention, a local file block map must be maintained. The local file block map is a data structure with key-value pairs that maintains the valid local blocks. The key for a block map entry is the name of the zip entry associated with the local file block \/N, and the value is a pointer pointed to a local file block runtime object. The local file block map can be used at run time to locate a local file block quickly. The local file block map is merely provided with a key and the location or the actual local file block is returned.","Dynamic Building of Free Block List","The free block list is a list of the free blocks (i.e., the blocks available to store information in the ZIP\u2122 archive. The list is based on the offsets stored in the central directory . The concept is that if there are no free blocks, every offset stored in the central directory  will form a continuous linear layout (e.g., sequential) of the local file. If such a sequence cannot be formed, then there is a missing piece that can be assumed to be a free block.","Accordingly, the free block list is built dynamically based on a map storing valid information of all local file blocks. Since each block is stored physically continuous, concatenating every block forms a contiguous valid ZIP\u2122 entry available for storage. For each block, if it's not an orphaned free block (an orphaned free block is also referred to as a raw data block), it must be registered in the central directory . Accordingly, each block that is indexed by the central directory  is processed by checking its start offset and end offset to build an offset range for block n. All of the registered blocks are concatenated together and compared with the whole address space of the entire ZIP\u2122 archive to find out the missing segments; these missing segments are free blocks that are not indexed by central directory .","Various implementations are possible. In one or more embodiments, two maps may be used\u2014one map stores the start offset of an indexed block as a key, and the other map stores the end offset of the indexed block as a key. Subsequently, each indexed block is processed wherein the indexed block's adjacent offsets are checked (i.e., start offset \u22121 and end offset +1) to see if the two offsets are indexed in the two previously built maps. If either offset is not indexed in the two maps, then it may be assumed that the non-indexed offsets must be either start offset or end offset of a free block. Such offsets are then added to the two lists. Further, a two way merge may be used to iterate both lists and obtain the final free block list\u2014a map with key:value pairs as start offset:end offset of free blocks.","In view of the above, the list of free blocks is dynamically generated at run time by processing\/iterating through the known valid information for the local blocks in the central directory .  illustrates the layout of a ZIP\u2122 file with some free blocks in accordance with one or more embodiments of the invention. The striped blocks ,  and  are free blocks. The [START] field indicates the start offset of each block. The [END] field indicates the end offset of each block and the [SIZE] field indicates the size of each block. If not explicitly stated, all of the offsets are the distance (in bytes) from the start of the file. The dotted blocks  and  are local file blocks (i.e., a ZIP\u2122 entry).","Local file blocks - each contain a local file header (e.g., \/N) which stores various information such as size, compression info, date time, entry name etc., and a local file data section (e.g., \/N) which stores (either compressed or not) data of the ZIP\u2122 entry. The data stored in a local file block - must layout continuously; it can't be fragmented into several sections. Accordingly, a local file block - is an atomic block that can not be segmented anymore.","In , there are two local file blocks, L  and L . There are also three free blocks, F , F , and F . Only local file blocks - are visible, since they both have a central file header representative in the central directory : Central File Header  points to L , and Central File Header  points to L . All three free blocks, L , L , L  are invisible (to 3rd party ZIP\u2122 such as WINZIP\u2122, WINRAR\u2122, etc.) since their corresponding central file headers - are not in the central directory  (these three blocks - may not have a local file header \/N which is within the ZIP\u2122 format). In this regard, since a free block - can contain any content within the block, a free block - does not have to have a legal ZIP\u2122 local file header in it.","To obtain a ZIP\u2122 file with free blocks -, embodiments of the invention may provide an application programming interface (API) routine that deletes a ZIP\u2122 entry and reclaims its local storage by filling junk data in it.","Referring again to , suppose the illustrated file is being processed with the free blocks -. As described above, a local block map may be established at the loading process. The local block map stores each runtime object of the local block -. Each runtime object of the local block -, in turn, can provide the offset of the local block -, and the size of the local file block -.",{"@attributes":{"id":"p-0083","num":"0084"},"figref":["FIG. 6","FIG. 6"],"b":["508","510","502","506","508","510","508","510","508","510","508","510","508","510","508","510","508","510"]},"At step , the LowWatermark value is set equal to the current block offset (i.e., nLowWatermark=block.offset). At step , the value\/key in the low watermark map\/array at the low watermark value is set equal to the block size (i.e., lowWatermarkMap[nLowWatermark]=block.size). At step , the HighWatermark value is set equal to the current offset plus the block size minus 1 (i.e., nHighWatermark=block.offset+block.size\u22121). At step , the value\/key in the high watermark map\/array at the high watermark value is set equal to the block size (i.e., highWatermarkMap[nHighWatermark]=block.size).","The processing performed in  may be more easily understood by referring to . The steps of  are processed for the first time with the first local file block L  where the start is 100, end is 239, and size is 140. Once processed via , the values of the various properties are:\n\n","Thus, the content of the lowWaterMarkMap and highWaterMarkMap are:\n\n","In the second loop performance of , the second local file block L  is processed wherein the start is 360, end is 609, and size is 250. Once processed via , the values of the various properties are:\n\n","Since there are only two local file blocks - in , the loop is complete and the steps of  are not processed again. Once complete, the following properties in the map have been established:\n\n","Once the above two maps have been established per the steps of , the next step is to determine and to index the free blocks within the archive. To index the free block maps, a free block watermark map is created that records the watermark information of the free blocks. The key is the start offset of a free block and the value is the end offset of the free block. The process of creating the free block watermark map is based on the fact that for any local file block, its adjacent block, either before or after it, should be either a local file block - or a free block -.  illustrates the relationship between offsets of blocks in an archive in accordance with one or more embodiments of the invention. As illustrated, a local file block  has an offset (i.e., a start offset) of N and an end offset of N. N\u22121 is the end offset of the previous block , and N+1 is the start offset of the subsequent block . The three blocks are continuous. In view of the above, embodiments of the invention may dynamically create four maps\u2014(1) a low watermark map for local file blocks -; (2) a high watermark map for local file blocks -; (3) a free high watermark map for free file blocks -; and (4) a free low watermark map for free file blocks -.",{"@attributes":{"id":"p-0090","num":"0099"},"figref":["FIG. 8","FIG. 8"],"b":["508","510","802"]},"At step , a determination is made regarding whether the current block offset (i.e., of the first local file block) is greater than 0 (i.e., whether it is at the beginning of the archive or not). If the current block offset is greater than 0, a test is conducted to determine if the offset located at one less than the current offset is in the list\/map of high watermarks for the local file blocks. To conduct such a test, the high free watermark value is set to the current block offset \u22121 at step  and the high watermark map is searched to see if the high free watermark value is in the map at step . If the high free watermark value is not in the map, one may assume that it is the high watermark of a free block - and the value is added to the free high watermark list\/map (again at step ). If it is in the map, then the offset is for a local file block - and no further action may be necessary.","At step , the low free watermark value is set to the current block offset (i.e., of the current local file block - being processed)+the block size of the current local file block -.","At step , a determination is made regarding whether the low free watermark value is less than the offset of the central directory . In other words a determination is made regarding whether the offset currently being examined is part of the central directory  or not. If not part of the central directory , the low water map (containing the low watermarks of the local file blocks -) is searched for the low free watermark value at step . If the low free watermark value is not in the low watermark map, one can assume that it is a low watermark for a free block - and it is added to the free low watermark list\/map at step .","To ensure accurate processing, the system may then check for various boundary conditions before concluding at step . For example, one boundary condition determines if a free block is the first block in the archive and adds the block to the free low watermark list\/map if necessary. Another condition checks if the last block before the central directory  is a free block and updates the free high watermark list\/map if necessary. Such completion of processing may further sort the free low and high watermark list\/maps as well as instantiate a single free watermark map with appropriate keys and values if necessary.","To better illustrate the processing of , one may examine  and how the blocks therein are processed. The first block to be processed is that of local file block L . Since the offset of local file block L  is greater than 0 (e.g., at step ), the high watermark free block value is set to 100\u22121=99.","From the processing of , the high watermark map (of local file blocks -) consists of {239:140}, {609, 250}. This map is searched for the high watermark free block value of 99 at step . The value 99 is neither 239 nor 609. It may be noted that only keys are searched and not the values. In this regard, 140 and 250 are values and not keys of the map (and hence are not searched at this time). Since the high watermark map of the local file blocks - should contain all local file block's - end offsets, one can safely assume that 99 is the end offset of a free block immediately preceding L . In this regard, if 99 were an offset of a local file block -, it would appear in the high watermark map of the local file blocks -. Thus, the value 99 is added to the free high watermark map for free file blocks - (which is a list contains all end offsets of free blocks -).","The processing of  then proceeds to step  wherein the low free watermark value is set to the current block offset plus the block size:\n\nLowWaterMarkFreeBlock=1.offset+1.size=100+140=240.\n","The value 240 is then compared to the start offset of the ZIP\u2122 central directory (i.e., 810) at step . Since 240<810, the process continues with step . As described above, the map of the low watermarks for the local file blocks - contains {100:140}, {360, 250}. The value 240 is not either 100 nor 360, which are all keys in the low watermark map. Since the low watermark map for the local file blocks - should contain all local file block's - start offsets, one can safely assume that 240 is the start offset of a free block immediately after L  (i.e., for free block F ). Accordingly, the value 240 is added to the free low watermark map for free file blocks -.","To this point, the loop of  has been iterated for the first block, L . The loop is iterated again for the second local file block L . Based on the above described process, the high free watermark value is set to the block offset 360\u22121=359 and the low free watermark value is set to the block offset plus the block size (360+250=610). The value 359 is not in the low watermark map for local file blocks - and  is not in the high watermark map for local file blocks -. Accordingly, both values are added to the corresponding free block maps.","Thus, after processing through step  for both the first block  and the second block , the high free watermark map contains {99, 359} and the low free watermark map contains {240, 610}.","The processing then continues with the boundary cases at step . The value 0 is not in the low watermark map for local file blocks -: {100:140}, {360, 250}. Accordingly, 0 must be a low watermark for a free block (i.e., free block F  and is added to the free low watermark map. In addition, the value of the central directory offset minus one (i.e., 810\u22121=809) is not in the high watermark map for the local file blocks -: {239:120}, {609, 250}. Thus, the value 809 is added to the free high watermark map.","The resulting high and low free watermark maps are:",{"@attributes":{"id":"p-0102","num":"0000"},"ul":{"@attributes":{"id":"ul0011","list-style":"none"},"li":{"@attributes":{"id":"ul0011-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0012","list-style":"none"},"li":["High: {99, 359, 809}","Low: {0,240,610}"]}}}},"From these two maps, the list of all free blocks may be dynamically generated:\n\n","Updating a ZIP\u2122 Entry In Place","In the prior art, all ZIP\u2122 entries are fixed in the sense that their size, position, and offset are fixed. If a ZIP\u2122 entry is updated, the data may expand or shrink. Accordingly, to maintain the ZIP\u2122 file, adjacent data must move, shrink or expand which results in the rewrite of the entire ZIP\u2122 file.","To provide many advantages, one or more embodiments of the invention provide the ability to perform in place editing of a ZIP\u2122 entry without requiring the rewriting of the entire ZIP\u2122 file. There are at least two different modes that can enable such in place editing: (1) Append Mode; and (2) Automatic Growth\/Reclamation Mode. Embodiments of the invention may allow the user to establish\/select which mode\/model to use.","Append Mode","In the append mode, when a ZIP\u2122 entry is edited, the ZIP\u2122 local file header of the entry is copied and appended to the end of the ZIP\u2122 archive. Further, the corresponding central file header in the central directory is updated to point to the local file header near the end of archive, instead of the original one. This effectively orphans the old local file block (header+entry data), so the original location of the entry may then be freed up for new data.","Before any writes (updates) to the ZIP\u2122 entry, the current local file block associated with the entry will be reincarnated (e.g., cloned) by being moved (only local file header section, old data doesn't move) to the start offset of the central directory . The central directory  is marked as dirty after the local file block is reincarnated. Then the write is performed, directly to the new local file block data section at the end of ZIP\u2122 archive. The old orphaned local file block can be either killed, or just left intact. When the local file block is killed, the ZIP\u2122 saving process will fill the old local block with zeros, thus making recover of the old block not possible. When the local file block is left intact, recovery of the old block, as well as data it contains, is possible which is further discussed below. The central directory  now knows its final persistent offset which is immediately following the last byte of the bytes just written to the updated block, at the end of archive. However, if the archive is created via a streaming scenario, then the local file descriptor follows the last data byte, in which case, the offset of the central directory  immediately follows the local file descriptor. The central directory  triggers the indexing blocks saving process (as described above), and each block is updated with references and saved to the correct offset.",{"@attributes":{"id":"p-0110","num":"0121"},"figref":["FIGS. 9A","FIG. 9B"],"b":["9","9","1","902"]},{"@attributes":{"id":"p-0111","num":"0122"},"figref":"FIG. 9A","b":["904","906","908","1","902","1","902"]},{"@attributes":{"id":"p-0112","num":"0123"},"figref":"FIG. 9C","b":["902","902","910","1","902","1","902"]},"Correspondingly, the central header B stored in the central directory  mapping to ZIP\u2122 Entry  B changes its reference from the \u201cold\u201d ZIP\u2122 Entry  B to the newly created entry C at the end of ZIP\u2122 archive. Accordingly, the old ZIP\u2122 Entry  C is invisible to the outside world. The bytes occupied by old ZIP\u2122 Entry  B may be zeroed out and this local file block now becomes a free block C. Such an append operation may have a significant performance bonus over the prior art rewriting approach of .",{"@attributes":{"id":"p-0114","num":"0125"},"figref":"FIG. 10","b":["1002","908","908","1002"]},"At step , the old ZIP\u2122 entry  is copied\/cloned\/reincarnated to the start offset of the old location of the central directory .","At step , the central directory  is marked as dirty since it now points to the new location C of the entry (so that it is updated when the indexing save process is performed).","At step , the cloned entry  is updated by appending\/writing any data to the new location at the end of the ZIP\u2122 archive (resulting in updated entry C).","At step , the central directory  is updated to reflect the updated entry and location.","At step , the old ZIP\u2122 entry C is now orphaned and killed (e.g., filled with NULL characters) to provide the ability to store new data in the future.","The process concludes at step  with the index block saving process which updates all of the data in the various records of the ZIP\u2122 archive.","Automatic Growth\/Reclamation Mode","In the automatic growth\/reclamation mode, entries are not cloned (e.g., as in the append mode) but entries are modified in place and utilize free blocks if possible. Before a write occurs, a determination needs to be made where to write the new bytes. A determination is made regarding whether the current allocated local data space can accommodate the new bytes or not. In this regard, there are two possibilities: (1) existing space can accommodate the new bytes, or (2) existing space cannot accommodate the new bytes.","If the current allocated local data space can fill\/accommodate the new bytes, the update will be performed in the (old) place. Any unused space will be treated as future growth space for this entry (runtime will decide to mark the block as a raw block, or simply leave it there if the overhead of the marker is too large for the unused spaces).",{"@attributes":{"id":"p-0124","num":"0135"},"figref":["FIGS. 11A","FIG. 11A"],"b":["11","11","1102","1104","1106","1104","1104","1104"]},{"@attributes":{"id":"p-0125","num":"0136"},"figref":"FIG. 11B","b":["1104","1104","1104","1108"]},"In , a second update is performed with the previously allocated space still accommodating the update. In such a situation, the second updated entry C is performed in place and the free space B shrinks to accommodate the update and provides a smaller free block C.","Alternatively, if the current allocated local data space cannot fill\/accommodate the new bytes, some data may need to be moved. A sequence of steps may be performed to determine which entry should be moved, where it should be moved to (at runtime), to find the optimal place to persist the new updated entry local file block and its data, and to minimize data that will be moved to improve I\/O performance. In one or more embodiments, the list of free blocks is searched to see if there is a free block of a size that can accommodate the updated entry. If so, the entry may be moved there. Alternatively, embodiments of the invention may either switch to append mode or may move some blocks immediately following the current entry being modified to a new location (e.g., to a free block that can accommodate the entry or to the end of the archive). Once the appropriate blocks are moved to accommodate the update, all of the offsets are updated as described above.",{"@attributes":{"id":"p-0128","num":"0139"},"figref":["FIGS. 12A","FIG. 12A","FIG. 12B","FIG. 12C","FIG. 12A"],"b":["12","12","0","3","1202","1208","1","1204"]},{"@attributes":{"id":"p-0129","num":"0140"},"figref":"FIG. 12B","b":["1","1204","1","1204","2","1206","1206","2","1206","1210","1","1204","2","1206","1","1204","2","1206","1","1204"]},{"@attributes":{"id":"p-0130","num":"0141"},"figref":"FIG. 12C","b":["0","1202","0","1202","0","1202","1","1204","0","1202","0","1202","1210","0","1202","1202","0","1212","1210","1210","0","1202"]},{"@attributes":{"id":"p-0131","num":"0142"},"figref":"FIG. 13","b":["1302","1304","1306"]},"At step , a determination is made regarding whether a free block is large enough to accommodate the block being updated or the subsequent block. If a free block is large enough, the block being updated or the subsequent block is moved to the free block at step . Alternatively, if no free block is large enough, the append mode is used and the block being updated or the subsequent block is moved to the end of the archive ate step . At step , the save process if performed to update all of the records and offset values as described above.","Delete\/Recover a ZIP\u2122 Entry","Prior art ZIP\u2122 tools rewrite the entire archive when deleting an entry (or entries). One or more embodiments of the invention avoid rewriting. Instead, the local file block associated with the deleted ZIP\u2122 entry will be left intact when logically deleting the entry or filled with NULL characters when physically deleting the entry. This implies that the archive file size will never shrink when deleting entries \u201cfrom\u201d it. As a consequence, the speed of a delete operation is much faster than a rewrite operation, and logically deleted entries can be reclaimed if the local file block associated with this entry remains intact.","Logical (Soft) Deletion","In a logical\/soft deletion, the central file header associated with the entry is removed from the central directory block, leaving the local file block (and file block header) intact. However, as the central file header is removed, the central directory size will shrink. In this regard, if the central directory is saved in the same offset, the end of central directory record  will not reach the end of the physical ZIP\u2122 archive. Instead, there will be \u201cjunk\u201d data left at the end of ZIP\u2122 archive. One choice is to force the truncation of the archive file but this is an expensive operation. Alternatively, the archive may not be truncated and instead, the central directory and other indexing blocks may be pushed towards the end of ZIP\u2122 archive, with the distance equal to the central file header (or headers) size. Such an embodiment, to two results: (1) the ZIP\u2122 archive is valid and remains the same size as the old one, and (2) the last local file block now has a free block immediately following it with the free block size equal to the distance stride described above.","Physical (Hard) Deletion","With a physical\/hard deletion, the logical\/soft deletion is first performed. In addition, the local file block associated with the entry is marked as a raw block by burning the 12 byte marker (4 bytes signature+8 bytes block size) at the start offset of the block. Such a marking facilitates finding empty blocks. In this regard, even for blocks not marked as raw, such blocks may still be bound since it doesn't depend on these markers; the local file block list is the only source that is accessed.","Recover a Deleted ZIP\u2122 Entry (Undelete)","A ZIP\u2122 entry can be reclaimed only if the local file block associated with the entry is intact. Two scenario of entry recovery may occur: (1) in-process recovery, and (2) out-of-process recovery.","To perform an in-process recovery, the ZIP\u2122 entry must have been deleted in process without closing the (library) process. To perform the recovery, the central file header associated with the entry is removed from central directory header list and the local file block is not removed from the local block map. To recover, the local file block map maintained by ZIP\u2122 file system is queried. If a local block with the exact the same name as the name of the entry to be recovered is found (and also if such a local block is not dirty\u2014i.e., its data has not changed), the central file header is simply recreated based on the local file block information stored in the local block map. The central file header is then merely added back to the central directory block.","For an out-of-process recovery, the ZIP\u2122 entry is deleted in one process and the process is exited. Another application is then launched to load the ZIP\u2122 archive. In other words, the process' cache no longer contains the entry and it must be regenerated. In such a scenario, the local file block map can't be consulted as an authorized source. Accordingly, the local file blocks are scanned to determine if the local file block can be recovered. Initially, a free block list is built based on the process described above. Thereafter, each free block list is scanned to locate the string of the entry name. If no block contains a string matching the ZIP\u2122 entry name, the entry can't be reclaimed. If one or more blocks contain the entry name string, a validation procedure is fired to check if the block is a valid local file block (with valid signature, sizes, CRC, etc.). If the check shows that the data is verified, then the local file block is reincarnated and activated by performing two actions: (1) the local file block is added to the local block map, and (2) a central file header is created from the local file block and added to the central directory block file header list.",{"@attributes":{"id":"p-0143","num":"0154"},"figref":["FIGS. 14A","FIG. 14A","FIG. 14B","FIG. 14C","FIG. 14D"],"b":["14","14","14","1","4","1402","1408","1","4","1410","1416","2","1404","1412","2","1412","2","1412","1404"]},"Defragment","One consequence of the above described process is that different free blocks may exist in various different locations of the ZIP\u2122 archive. In other words, ZIP\u2122 archive files may have various dead zones with free block segments. The defragment process may be used to compact free blocks into one area. Such a defragmentation process can optimize interior files within an archive without (potentially) rewriting the same archive. Defragment is needed as after many in place editing activities as described above, the physical storage may become divided into many small pieces over time and each small free space is too small to satisfy applications needs. For example a free block with size 4096 bytes might be requested by the application but the largest continuous free block only has a 500 byte block\u2014in this case the free block is completely useless. Defragmentation solves this problem by reorganizing physical storage to move the small free blocks together and combine them into a larger free block. Accordingly, many local file blocks may be moved, along with the data stored in them, and indexing blocks will need to be updated to point to new local file blocks after they are moved.","One special case in defragmentation is to gather and combine free blocks into a large free block, and place this free block at the end of physical file, after the ZIP\u2122 end of central directory record. Different embodiments may elect to truncate the file in which case a fragmentation free, 100% ZIP\u2122 complaint ZIP\u2122 archive will be produced.","Dynamic ZIP32\u2122 to ZIP64\u2122 Switch","As described above, there are two different types of ZIP\u2122 files\u2014ZIP32\u2122 and ZIP64\u2122. One of the differences between the two formats is the maximum archive size. One or more embodiments of the invention automatically (e.g., without additional user input) and dynamically convert\/switch the ZIP32\u2122 format to ZIP64\u2122 format to allow\/accommodate a large archive file.","The ZIP64\u2122 library may already create the most compatible ZIP\u2122 format automatically (e.g., ZIP32\u2122). However, the ZIP64\u2122 library will not deliberately generate an enhanced ZIP64\u2122 file unless it is actually need to exceed the old format's limitations (e.g., total items exceeding 65535 bytes or a single item exceeding 4 GB). Embodiments of the invention will automatically switch to the ZIP64\u2122 model\/format during processing when needed.","For example, during the process of creating a new ZIP\u2122 item, embodiments may determine that there are too many ZIP\u2122 items (>65535), or a single ZIP\u2122 item's compressed size is too big (>4 G). In such a situation, a ZIP64\u2122 package may be automatically created.","Logical Flow","There are various mechanisms for implementing and practicing embodiments of the invention. In this regard, a method, apparatus, and article of manufacture may each enable the ability to perform in-place editing of a ZIP\u2122 archive file in one or more of such embodiments. To perform such editing, a ZIP\u2122 archive file and a first file block (stored in a first block location of the archive file) are both opened. Thereafter, the first file block is modified resulting in a modified first file block.","If the first block location can accommodate the modified first file block, the modified block is stored in the first block location without rewriting the entire ZIP\u2122 archive file. However, if the first block location cannot accommodate the modified first file block, a second file block is copied from a second block location to a third block location located at an end of a file data section of the ZIP\u2122 archive file. Additionally, one or more portions of the second block location are marked as a free block. The process continues by saving the modified first file block without rewriting the archive file in its entirety. Lastly, the archive itself is saved by updating and saving both the central directory and end of central directory record in the ZIP\u2122 archive file.","It can be seen, that if the first file block and the second file block are the same block, the user may enter an append mode thereby copying, moving, and saving the first file block in the third block location. In addition, once moved, the first block location is marked as a free block (in its entirety).","If the first file block and the second file block are different consecutive blocks in the archive, the application may either enter append mode or the reclamation mode. Depending on whether the first block or second block is larger, different actions may ensue. In one embodiment, the first file block is larger and the second file block is moved to the end of the archive and the first file block expands to utilize space of the second file block's prior location. Any portion of the space not used by the expansion is marked as a free block.","Alternatively, as described above, the invention may attempt to move a modified block (e.g., the first or second block, if modified) to an existing free block space. Such a determination would then save the modified block in the free block space (including the respective central directory and end of central directory record) without rewriting the entire ZIP\u2122 archive file.","Once the archive file contains free blocks (or consistent with the invention prior to creating any free blocks), embodiments o the invention may attempt to create a list of free blocks. To create such a list, the first and second file blocks are first loaded. Such a loading performs a backscan of the archive file to load the end of central directory record which is then loaded. Based on the end of central directory record, the central directory is then loaded as well. Thereafter, the first file block and second file block are loaded based on data in the central directory.","The central directory's loading may change depending on whether the archive is in the ZIP32\u2122 format or ZIP64\u2122 format. If in the ZIP32\u2122 format, the central directory may be loaded based on the data in the end of central directory record. However, if the archive is in the ZIP64\u2122 format, the ZIP64\u2122 end of central directory locator is loaded to determine (and read\/load) the ZIP64\u2122 end of central directory record location. Thereafter, the central directory can be loaded based on the data in the ZIP64\u2122 end of central directory record.","Embodiments of the invention may further dynamically build a list of free blocks. To build the list, a list of the local file blocks (e.g., the first file block and the second file block) may first be dynamically built based on data in the central directory. Thereafter, an address space of the first file block and the second file block from the central directory is dynamically compared to an address space of the entire ZIP\u2122 archive file. The list of free blocks may be dynamically constructed based on segments missing from the central directory as determined from the address space comparison. The lists of local file blocks may consist of a map of low watermark offsets and high watermarks offsets of the local file blocks. Further, the comparison may look at offsets adjacent to the low watermark offsets and the high watermark offsets to determine if they are in the list of the local file blocks. If they are not in the list of local file blocks, one can assume they are for free blocks. Accordingly, the appropriate adjacent offset may be added to the list of free blocks.","To further enhance in-place editing capability without rewriting an entire archive, a soft delete may also be performed that deletes a file block by deleting a central file header in the central directory corresponding to the deleted file block while leaving the file block itself intact. Such a soft deleted file block may later be recovered by recreating the central file header based on information found in a list of the local file blocks (e.g., a list containing the first file block and second file block). Alternatively, a hard\/physical delete may be performed which not only deletes the central file header but also marks the first file block itself as a raw block by burning a signature located at a start offset of the first file block.","This concludes the description of the preferred embodiment of the invention. The following describes some alternative embodiments for accomplishing the present invention. For example, any type of computer, such as a mainframe, minicomputer, or personal computer, or computer configuration, such as a timesharing mainframe, local area network, or standalone personal computer, could be used with the present invention. In summary, embodiments of the invention provide support for the dynamic, in-place growth, allocated space re-use and dynamic ZIP32\u2122\/ZIP64\u2122 compliance switching.","The foregoing description of the preferred embodiment of the invention has been presented for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. It is intended that the scope of the invention be limited not by this detailed description, but rather by the claims appended hereto."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Referring now to the drawings in which like reference numbers represent corresponding parts throughout:",{"@attributes":{"id":"p-0027","num":"0028"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0028","num":"0029"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0029","num":"0030"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0030","num":"0031"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0031","num":"0032"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0032","num":"0033"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0033","num":"0034"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0034","num":"0035"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0035","num":"0036"},"figref":"FIGS. 9A","b":["9","9"]},{"@attributes":{"id":"p-0036","num":"0037"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0037","num":"0038"},"figref":"FIGS. 11A","b":["11","11"]},{"@attributes":{"id":"p-0038","num":"0039"},"figref":["FIGS. 12A","FIG. 12A","FIG. 12B","FIG. 12C"],"b":["12","12"]},{"@attributes":{"id":"p-0039","num":"0040"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0040","num":"0041"},"figref":"FIGS. 14A","b":["14","14","14"]}]},"DETDESC":[{},{}]}
