---
title: Hardware and software co-simulation using estimated adjustable timing annotations
abstract: A system and method for co-simulation of hardware and software includes determining hardware executable times, associated with each of a plurality of functions included within an application code. Estimated timing annotations, which correspond to the determined hardware executable times, are then inserted into each of the functions. The application code is compiled for simulation and the compiled application code is then executed on a host computer system. Adjustments may be made to the estimated timing annotations to evaluate potential architecture changes in either target hardware or software algorithms.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07308393&OS=07308393&RS=07308393
owner: Delphi Technologies, Inc.
number: 07308393
owner_city: Troy
owner_country: US
publication_date: 20030422
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DESCRIPTION OF THE PREFERRED EMBODIMENT(S)"],"p":["The present invention is generally directed to hardware and software co-simulation and, more specifically, hardware and software co-simulation using estimated adjustable timing annotations.","In general, hardware and software co-simulation is defined as the ability to execute target microprocessor software within a simulated hardware environment for the purpose of analyzing, debugging and implementing the hardware and the software. In general, hardware and software co-simulation reduces a product's time-to-market, reduces the cost of the product (as co-simulation can eliminate multiple manufacturing builds) and allows software development prior to hardware availability. Currently, hardware and software co-simulations are accomplished through the use of functional models, timed functional simulation models, instruction-set simulation models and\/or cycle accurate simulation models. When functional models are utilized to co-simulate hardware and software, the hardware and software are typically described in a high-level language, e.g., C, or with visual tools that execute on a general purpose computing platform. In general, functional models contain little or no timing information associated with the hardware and\/or software execution.","With timed functional simulation models, the hardware executes on a scheduled interval, typically with respect to a clock, and the software may be synchronized with the hardware model at discrete time intervals. In general, the application software for the timed functional simulation model executes directly on a host computer system. The timed functional model has the advantage of fast simulation and less computations, but with an overall reduced fidelity and accuracy of the hardware\/software simulation. In the instruction set simulation model, the application software is cross-compiled to a target processor instruction set, which is emulated on the host computer system, which acts as an instruction set simulator. In this manner, the instruction set simulator executes in synchronization, on instruction boundaries, with the hardware model.","In the cycle accurate simulation model, the application software is cross-compiled to a target processor instruction set and the instructions are executed on a cycle-by-cycle basis in synchronization with a scheduled hardware model. The cycle accurate simulation model and the instruction set simulation model are often referred to as co-verification models.","A prior technique for implementing a timed functional simulation model, which is described in U.S. Pat. No. 6,230,114, includes an analysis step that adds timing information to the application software to achieve a relatively high fidelity model. In this timed functional simulation model, synchronization points are inserted at each linear block of code. These synchronization points account for target processor instruction timing and pipeline effects and provide a highly accurate simulation model, whose accuracy approaches that of the final system, without performing continual context switching. However, this timed functional simulation model, in general, provides greater accuracy than required during software analysis, design and prototyping stages. The timed functional simulation model also does not allow for the adjustment of timing synchronization points to aid in exploration of target software execution times.","What is needed is a hardware and software co-simulation technique that facilitates exploration of different architectures and provides acceptable accuracy, while simultaneously reducing co-simulation time.","The present invention is directed to a system and method for co-simulation of hardware and software. Initially, hardware executable times associated with each of a plurality of functions, included within an application code, are determined. Then, estimated timing annotations, which correspond to the determined hardware executable times for one of each of the plurality of functions, are inserted into each of the plurality of functions. Next, the application code is compiled for simulation and the compiled code is then executed on a host computer system.","In one embodiment, each of the estimated timing annotations includes a minimum and maximum number of cycles for executing an associated one of the functions. In this manner, the estimated timing annotations can be adjusted during simulation to evaluate different target processors and architectural choices.","These and other features, advantages and objects of the present invention will be further understood and appreciated by those skilled in the art by reference to the following specification, claims and appended drawings.","According to an embodiment of the present invention, a technique is described that improves upon current timed functional simulation models. It should be appreciated, however, that the advantages provided by the present invention are not limited to the timed functional simulation model. As previously mentioned, in general, timed functional simulation models offer accuracy near that of a final system. Typically, timed functional simulations run at about forty percent of the speed of an associated host computer system, while instruction set simulation and cycle accurate simulation models are often limited to speeds less than one percent of the speed of an associated host computer system.","With reference to , an exemplary host computer system , for co-simulating execution of application code for a target processor and peripherals of the target processor, includes a host processor , which is coupled to a printer , a mass storage device , a keyboard\/mouse , a memory subsystem  and a display . It should be appreciated that the computer system  may take various forms, e.g., a workstation or a personal computer (PC). The co-simulation technique, described herein, provides a level of modeling that offers a reasonable tradeoff between simulation speed and accuracy for use in hardware\/software partitioning studies, as well as in software development.","In general, the co-simulation technique inserts fewer synchronization points than prior timed functional simulation models. These synchronization points are, generally, estimates of the software execution time associated with a specific target processor. The present invention then allows for adjustment of these estimates dynamically, during timed functional simulation, in order to allow for full analysis of the hardware and software designs, as well as the interactions between the hardware and software.","Implementing the co-simulation techniques, described herein, allow a designer to explore different architectures with adequate simulation speed and accuracy. Thus, instead of inserting synchronization points for each linear block of a code, the co-simulation technique performs analysis on entire functions of the application code. In general, the goal is to obtain an arbitrary timing accuracy of, for example, +\/\u2212 twenty percent of actual hardware execution times. Such abstraction is generally necessary to increase the simulation speed and to lower the computational requirements of computing the synchronization points.","The inserted synchronization points have only a minor affect on the system software execution and are generally referred to herein as estimated timing annotations. The estimated timing annotations describe the minimum and maximum number of cycles for executing the function (which may infrequently be a linear block of code). The estimated timing annotations only affect execution when the code is compiled for simulation, as they are removed (via conditional code macros) when the code is cross-compiled for a target processor. During simulation, the estimated timing annotations temporarily halt the application software execution and allow the hardware simulation to execute the specified number of cycles. In this manner, the hardware simulation may be brought into synchronization with the software execution and the hardware essentially catches up to the estimated software execution time. Any pending interrupts generated by the hardware simulation may then cause execution of an appropriate target application code interrupt handling routine, prior to resuming the original application software execution.","During simulation, the user of the system may adjust the synchronization of the hardware and application software by specifying a ratio of execution cycles to the estimated timing annotations. Thus, a designer has a wide variety of options, such as using a maximum estimated execution time, a minimum estimated execution time, a percentage between the minimum and maximum execution times or even a percentage that exceeds the maximum execution time. In this manner, a user may evaluate the robustness of the software design when executing on a selected hardware architecture. Further, because the software design is at a high level of abstraction, the user has the ability to explore alternative hardware and software designs.","As previously mentioned, the estimated timing annotations are typically added near the last execution line of each function. The estimated timing annotations may be based upon the users domain knowledge of the function, or preferably by static analysis of the cross-compiled code. The source code is cross-compiled for the target processor and cycles are counted to determine a minimum and maximum execution pass through the function. For example, an internally developed program available from Delphi (timstk.exe) automates the cycle counting process for certain target processors. As previously mentioned, the timing annotations are added through a line of code, such as a Simulate_HW_Cycles(min, max) function, where \u2018min\u2019 is the minimum cycles to execute the region of code and \u2018max\u2019 is the maximum cycles to execute the region of code.","Set forth below is an exemplary application code function, i.e., bool IO_Serial EEPROM_Is_Busy(void), which shows an appropriate use of the Simulate_HW_Cycles function.",{"@attributes":{"id":"p-0022","num":"0021"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"bool IO_Serial_EEPROM_Is_Busy(void)"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"interrupt_state_t\u2003\u2003\u2003interrupt_state;"]},{"entry":[{},"interrupt_state = Get_Interrupt_State(\u2009);"]},{"entry":[{},"Disable_Interrupts(\u2009);\u2003\u2003\u2003\/* INTERRUPTS DISABLED *\/"]},{"entry":[{},"\/* Inquire the external device status when we think it is busy from"]},{"entry":[{},"* a previous write operation."]},{"entry":[{},"*\/"]},{"entry":[{},"if (in_use & SERIAL_EE_BUSY)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/* Select and enable the EEPROM to read the status register *\/"]},{"entry":[{},"HW_Select_And_Write_SPI(HW_SERIAL_EE_ID,"]},{"entry":[{},"READ_STATUS_REG_COMMAND);"]},{"entry":[{},"\/* Read the status *\/"]},{"entry":[{},"(void)HW_Read_And_Write_SPI(INVALID_COMMAND);"]},{"entry":[{},"\/* If device \u201cnot ready\u201d flag is clear, then operation"]},{"entry":[{},"is complete *\/"]},{"entry":[{},"if (!(DEVICE_NOT_READY & HW_Read_SPI( )))"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"in_use &= ~SERIAL_EE_BUSY;"]},{"entry":[{},"\/* Read modify write *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"HW_Deselect_SPI(HW_SERIAL_EE_ID);"]},{"entry":[{},"Simulate_HW_Cycles(34, 43);"]},{"entry":[{},"}"]},{"entry":[{},"Set_Interrupt_State(interrupt_state); \/* INTERRUPT STATE"]},{"entry":[{},"RESTORED *\/"]},{"entry":[{},"Simulate_HW_Cycles(19, 62-43);"]},{"entry":[{},"return ((in_use & SERIAL_EE_BUSY));"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Occasionally, it may be necessary to add timing annotations within loops and lengthy conditional branches. To achieve an overall arbitrary accuracy of, for example, +\/\u2212 twenty percent, one checks each annotation to determine if the minimum is greater than eighty percent of the maximum. In the above example, the entire function requires a minimum of 19 cycles and a maximum of 62 cycles. While this annotation can be used, it does not meet the desired simulation accuracy of +\/\u2212 twenty percent. To increase the simulation accuracy, a second annotation may be added inside the major \u201cif\u201d statement to reflect the timing of that branch of code, i.e., 34 to 43 cycles. Since the 62 cycles includes the maximum path of 43 cycles, the parameter for the last Simulate_HW_Cycles function is modified to reflect the second added annotation, i.e., 62 minus 43.","It should be appreciated that static analysis will not typically enable a user to determine the number of times that a loop is executed. Thus, an annotation may be added within a loop body to estimate the execution time for the loop body. Other control statements of the source language, i.e., switch statements or else statements, may optionally include timing annotation statements within their respective branches, as well. Timing annotations may be measured using static timing analysis from cross-compiled code or they may be estimated by human inspection.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIGS. 2A-2B","b":["200","202","200","204","206","208","100","210","100"]},"Then, in step , the designer may review the results of the simulation, e.g., via the display , and may print the simulation results on the printer . Next, in decision step , the designer determines if the system simulation performs as expected and may optimize the application software to use less hardware cycles and\/or reconfigure the simulation to analyze a different target architecture that uses more or less hardware cycles. Thus, when control passes to step , the designer modifies the minimum and\/or the maximum number of cycles for one or more function calls, at which point the application is re-compiled in step . If the designer does not desire to manipulate the hardware cycles in step , control passes to step  where the process  terminates.","Set forth below is a hardware simulator example that illustrates the use of the variable \u201cPercent_Thruput,\u201d which may be used to adjust software and hardware synchronization. In the example set forth below, the function sc_start( ) is a call to a hardware simulator to cause execution of the hardware simulation for a specified amount of time.",{"@attributes":{"id":"p-0028","num":"0027"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"int Percent_Thruput = 100;"},{"entry":"void Simulate_HW_Cycles(unsigned int min_cycles, unsigned int"},{"entry":"max_cycles)"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/* Execute the hardware to catch up with the SW elapsed execution *\/"]},{"entry":[{},"\/* 8 MHz (125 ns period) HC08 clock assumed *\/"]},{"entry":[{},"sc_start(min_cycles + (max_cycles-min_cycles) *"]},{"entry":[{},"Percent_thruput\/100.0 * 125.0, SC_NS);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if(interrupt_may_be_pending)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Evaluate_Interrupts( );"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} \/* Simulate_HW_Cycles( ) *\/"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The adjustable annotations may also be applied to instruction set simulation or cycle accurate simulation as well. For these types of simulations, the execution time of the instruction or hardware cycle predetermines the software execution time. Accumulated together, the aggregate instructions or cycles predetermine the software execution time of the plurality of functions. The simulation is adjusted to modify the hardware and software synchronization with a \u201cPercent_thruput\u201d control that allows the designer to observe the system behavior for a range of target processor capabilities.","Accordingly, techniques have been described herein which improve upon prior co-simulation models by allowing a user to couple an accurate but fast hardware simulation to estimates of the software application execution times. The estimates may be based upon prior knowledge of the system, measured execution times of cross-compiled code, or actual simulation times of cross-compiled code. Utilizing the co-simulation techniques described herein, a user may explore the hardware and software tradeoffs to achieve an optimum system\/subsystem design. This may be achieved by adjusting the annotations, during the timed functional simulation for the plurality of functions. The adjustments are made to evaluate potential architecture changes in either target hardware or software algorithms. Thus, the software and hardware can be fully tested in a virtual environment prior to committing to a specific hardware platform.","The above description is considered that of the preferred embodiments only. Modifications of the invention will occur to those skilled in the art and to those who make or use the invention. Therefore, it is understood that the embodiments shown in the drawings and described above are merely for illustrative purposes and not intended to limit the scope of the invention, which is defined by the following claims as interpreted according to the principles of patent law, including the Doctrine of Equivalents."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention will now be described, by way of example, with reference to the accompanying drawings, in which:",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIGS. 2A-2B"}]},"DETDESC":[{},{}]}
