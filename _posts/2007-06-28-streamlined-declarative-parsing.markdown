---
title: Streamlined declarative parsing
abstract: Programming mechanisms for data parsing facilitate both clear code specification and efficient execution. Declarative style code can be employed to enable clear and concise specification of data parsing. Further, an efficient parsing approach can be utilized that enables processing of a data structure without first materializing the entire structure to memory. More specifically, streaming and/or selective materialization of portions of data to memory can be employed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08005848&OS=08005848&RS=08005848
owner: Microsoft Corporation
number: 08005848
owner_city: Redmond
owner_country: US
publication_date: 20070628
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The pervasiveness of computers and other processor-based devices has resulted in data proliferation such that vast amounts of digital data are created and stored daily. Although originally the sole domain of well-funded companies and research institutions, technology advancements and cost reductions over time have enabled computers and other electronic devices to become commonplace in the lives of most everyone. As a result, both businesses and consumers create and interact with large amounts of digital data.","Traditionally, a database management system (DBMS) is employed to manage interaction with database data. The DBMS efficiently manages requests or queries from users and programs so that these entities are free from having to know specifics pertaining to how and where data is physically stored. Furthermore, in handling requests, the DBMS ensures integrity and security with respect to the data. The most common DBMS is a relational database management system (RDBMS). In this system, data is stored in a tabular format wherein data resides at intersections of rows and columns.","With the advent and growing popularity of the Internet and other networking technologies, various other structured data languages or formats have been developed to facilitate storing and sharing of information across different technology systems. One such language is XML (eXtensible Markup Language), which is a standard language that allows entities and\/or groups to share information in a convenient fashion. This language uses tags or symbols to markup or describe content. Another format or scripting language that enables sharing of data is JSON (JavaScript\u2122 Object Notation). JSON is a lightweight data exchange format rather than a markup language that utilizes a collection of name-value pairs and arrays of values to represent data. XML and JSON can capture various computer data structures (e.g., objects, lists, trees . . . ) for storage and\/or transmission.","A myriad of application programming interfaces (APIs) and\/or language implementations can be employed to process structured data. For example, XML data can be formatted, queried and\/or transformed by XSLT, XQuery and\/or XPath. These and other conventional mechanisms operate by loading an entire data structure in memory and subsequently performing operations over the materialized data structure.","The following presents a simplified summary in order to provide a basic understanding of some aspects of the claimed subject matter. This summary is not an extensive overview. It is not intended to identify key\/critical elements or to delineate the scope of the claimed subject matter. Its sole purpose is to present some concepts in a simplified form as a prelude to the more detailed description that is presented later.","Briefly described, the subject disclosure pertains to data parsing in a computer environment. More particularly, data is parsed serially in accordance with declarative code. The size of a data structure that can be processed in-memory is limited by available memory. As a result, certain scenarios, including those involving a large amount of data, may not be feasible or affordable with in-memory processing. In accordance with one aspect of this disclosure, such issues can be remedied by parsing data without first requiring materialization of an entire structure to memory. Various streaming or serial parsing semantics can be employed alone or in combination with selective materialization of portions of data to facilitate efficient processing. Furthermore, data parsing can be described clearly and concisely with declarative style code, rather than lower level or imperative style code.","To the accomplishment of the foregoing and related ends, certain illustrative aspects of the claimed subject matter are described herein in connection with the following description and the annexed drawings. These aspects are indicative of various ways in which the subject matter may be practiced, all of which are intended to be within the scope of the claimed subject matter. Other advantages and novel features may become apparent from the following detailed description when considered in conjunction with the drawings.","Systems and methods are provided hereinafter for affording a declarative manner of parsing data without loading an entire structure to memory. In other words, data can be described in a clear and concise manner and processed efficiently. Efficient processing is accomplished utilizing data streaming or and\/or selective materialization. Further, various mechanisms are disclosed to confront specific processing circumstances. For example, mechanisms are provided for efficiently processing nested queries and branch queries.","Various aspects of the subject disclosure are now described with reference to the annexed drawings, wherein like numerals refer to like or corresponding elements throughout. It should be understood, however, that the drawings and detailed description relating thereto are not intended to limit the claimed subject matter to the particular form disclosed. Rather, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the claimed subject matter.","Referring initially to , a data parsing system  is illustrated in accordance with an aspect of the claimed subject matter. The data parsing system  provides a mechanism for parsing a data structure in accordance with a particular specification thereof. Parsing refers generally to querying, consuming or otherwise extracting data or information from an input. For example and not limitation, the data parsing system  can facilitate querying or retrieving data from a structured data source such as XML. The system  includes an interface component  and parse component .","The interface component  receives, retrieves or otherwise acquires or obtains code that describes data to be parsed. According to an aspect of this disclosure, the code can be specified in a declarative style or fashion. Declarative specification relates to generally declaring what needs to be done, rather than specifically outlining actual steps that need to be performed (e.g., imperative specification). By way of example, and not limitation, a declarative specification can correspond to a SQL (Structured Query Language) \u201cselect, from, where\u201d query, FLWOR (For, Let, Where, Order Return) expression or the like. In one implementation, declarative code can be included as a language integrated query, wherein query operations, like SQL statements, are natively supported as first class citizens of a programming language.","The parse component  can receive or retrieve declarative code directly or indirectly from the interface component . Upon receipt or access, the parse component  can parse or process an identified data structure  in accordance with the declarative code and optionally return a result dependent upon an operation. In one instance, the declarative code can correspond to a query that returns a subset of data from the data structure , which can include, without limitation, XML (eXtensible Markup Language), objects (e.g., scripting language objects in JSON\u2014JavaScript\u2122 Object Notation), directories, comma separated files (CVS), database tables, data streams, music and video.","Moreover, parse component  can process data efficiently without requiring an entire data structure to be materialized in memory. In many cases, data structures are very large collections of data. As a result, loading the entire structure to memory prior to performing any operations thereon may be impossible and\/or unaffordable. Furthermore, even when a structure is smaller, materialization of the whole structure may be inefficient in terms of processing and\/or resource allocation. The parse component  addresses these concerns by utilizing data streaming alone or in conjunction with selective and\/or transient materialization. Data can be processed serially or iteratively one element at a time where possible. In this manner, a memory footprint is limited substantially to the size of each element or a small group of elements. Memory space can also be reused or made available for recapture (e.g., garbage collection) after each element is processed. Additionally or alternatively, portions of a data structure can be materialized to memory, for example, where an operation or group of operations is unable to be effectuated in a single pass or serial manner.","It is to be appreciated that the system  can be implemented in many different manners. In one instance, system  and\/or components thereof can be implemented as an application programming interface (API). For example, functionality provided by the parse component  and\/or interface component  can be embodied as external program method calls (e.g., \u201cstream( ),\u201d \u201cmaterialize( )\u201d . . . ). Alternatively, the functionality can be incorporated within a program language (e.g., XPath, XQuery . . . ), among other things, to facilitate efficient code generation and\/or query execution, for instance.","For purposes of clarity and understanding, consider a problem of consuming or parsing huge amounts of XML. For the sake of a concrete example, consider the following book list:",{"@attributes":{"id":"p-0027","num":"0026"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<books>"]},{"entry":[{},"\u2003<book publisher=\u201cIDG books\u201d on-loan=\u201cSanjay\u201d>"]},{"entry":[{},"\u2003\u2003<title>XML Bible<\/title>"]},{"entry":[{},"\u2003\u2003<author>Elliotte Rusty Harold<\/author>"]},{"entry":[{},"\u2003<\/book>"]},{"entry":[{},"\u2003<book publisher=\u201cAddison-Wesley\u201d>"]},{"entry":[{},"\u2003\u2003<title>The Mythical Man Month<\/title>"]},{"entry":[{},"\u2003\u2003<author>Frederick Brooks<\/author>"]},{"entry":[{},"\u2003<\/book>"]},{"entry":[{},"\u2003<book publisher=\u201cWROX\u201d>"]},{"entry":[{},"\u2003\u2003<title>Professional XSLT 2nd Edition<\/title>"]},{"entry":[{},"\u2003\u2003<author>Michael Kay<\/author>"]},{"entry":[{},"\u2003<\/book>"]},{"entry":[{},"\u2003<book publisher=\u201cPrentice Hall\u201d on-loan=\u201cSander\u201d>"]},{"entry":[{},"\u2003\u2003<title>Definitive XML Schema<\/title>"]},{"entry":[{},"\u2003\u2003<author>Priscilla Walmsley<\/author>"]},{"entry":[{},"\u2003<\/book>"]},{"entry":[{},"\u2003<book publisher=\u201cAPress\u201d>"]},{"entry":[{},"\u2003\u2003<title>A Programmer's Introduction to C#<\/title>"]},{"entry":[{},"\u2003\u2003<author>Eric Gunnerson<\/author>"]},{"entry":[{},"\u2003<\/book>"]},{"entry":[{},". . ."]},{"entry":[{},"<\/books>"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},{"@attributes":{"id":"p-0028","num":"0027"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"var books = XElement.Load(\u201cBooks.xml\u201d);"]},{"entry":[{},"var count ="]},{"entry":[{},"\u2003\u2002(from b in books.Elements(\u201cbook\u201d)"]},{"entry":[{},"\u2003\u2002let title = (string)b.Element(\u201ctitle\u201d)"]},{"entry":[{},"\u2003\u2002where title.IndexOf(\u201cXML\u201d) != \u22121"]},{"entry":[{},"\u2003\u2002select title"]},{"entry":[{},"\u2003).Count( );"]},{"entry":[{},"Console.WriteLine(count);"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"One problem with conventional query-enabled XML APIs as well as language implementations (e.g., XPath, XQuery, XSLT . . . ) is that they assume an in-memory representation for XML trees. However, as previously mentioned, an in-memory representation may not be possible and\/or affordable. Accordingly, more efficient query semantics (or parsing approach) is needed such that serialized input is processed (say parsed) more directly and smaller portions are materialized in memory transiently.","In principle, low-level parsing APIs can be employed to process XML without loading it into memory. However, these low-level APIs require special programming skills and are cumbersome as well as error-prone. More specifically, use of such technology requires developers write specialized and complicated code to keep track of what they have seen before against that for which they are looking, essentially managing state. This becomes increasingly difficult as a function of data size, so much so that it is essentially impossible to do complicated things because the complexity quickly overwhelms a developer.","The data parsing system  provides a solution to identified issues with conventional technology. In particular, declarative style code can be employed utilizing functional programming-like idioms such as SQL (Structured Language Query)\/LINQ (Language Integrated Query)\/FLWOR (For, Let, Where, Order Return)-like queries over serialized and\/or selectively materialized data. As a result, queries can be both efficiently written and executed.","In the example, an XML data source can be open for parsing, rather than loading the entire content. In this case, the code segment \u201cvar books=XElement.Load(\u201cBooks.xml\u201d);\u201d can be replaced with \u201cvar books=XElement.Open(\u201cBooks.xml\u201d);\u201d or the like. The original, in-memory query provided above can be preserved, as is, \u2014if a suitable semantics is assumed of API members. Essentially, the query should be executed as a single sequential pass over the input. The query in question is indeed simple enough to lend itself to such an execution. As a result, the declarative style of an API for in-memory XML queries is preserved where the input is not to be loaded into memory but instead serialized.","The above example pertains to a simple data structure and query conducive to a full streaming implementation. It is to be appreciated that a number of more complicated scenarios can be addressed with differing mechanisms can be to preserve both code and execution efficiency. In effect, an optimal point can be located in a spectrum from fully serialized to fully materialized as a function of declarative code and\/or a data structure. Similarly, degree of code declarativeness can also be impacted by the same or like factors.","Turning to , a representative parsing component  is illustrated in accordance with an aspect of the claimed subject matter. As described with respect to system  of , the parsing component  can evaluate and\/or extract data from a structure in a memory efficient fashion as a function of declarative-style code. In some instances, queries or like code can be nested or chained. Nested queries are those queries that include at least one other query or sub-query embedded within them. These queries are more complicated than un-nested queries and do not lend themselves to straightforward serial processing. In fact, nested queries by definition query into a data structure multiple times. This is works fine when a structure is fully materialized in memory. However, it is problematic where single-pass, serial or streaming semantics are to be employed. To resolve this issue, the parse component  includes a load component  and a stream component .","The load component  provides a mechanism for shallow loading of data in memory  (e.g., cache, RAM, volatile storage . . . ). In accordance with an aspect of the claimed subject matter, portions of code can be explicitly or implicitly designated for streaming at each level of a structure or iteration. This designated code is also referred to as a payload. Information not identified as a payload can be referred to as a preamble. All or part of a preamble can be materialized to support serialization of a payload. Load component  can open a file and perform shallow loading of memory with such information.","The stream component  evaluates designated data serially. Elements are retrieved iteratively and materialized to memory . Once the element is evaluated from memory, it can be replaced with subsequent element or alternatively made available for recapture by a garbage collector, for example. It should be appreciated that the stream component  can also utilize other information loaded to memory  by the load component . Further yet, the stream component  can also employ the load component  to perform shallow loading of data to facilitate nested evaluation.","The parse component  can generate a serialized structure  in memory  as depicted in . The serialized structure  can include a plurality of preamble components  and payload components . The preamble components  can include materialized data prior to a designated payload. This data can be completely materialized and parented such that elements thereof can be queried in a normal unrestricted manner. In other words, it is not restricted to iterate-once or serial interaction. The payload components  can include a pointer or other identifier into a data structure to facilitate serialization or iteration across a portion of data such as a sub-tree. Amongst other reasons, the serialized structure  is beneficial in that it occupies a relatively small amount of memory space as compared to complete structure materialization.","The load component  and stream component  effectively allow streaming or sliding over an input. During this process, some data such as that corresponding to preamble information can be loaded to memory. Other data can be iteratively processed. Further yet, the iterative processing of data can utilize preamble information loaded in memory, among other things to aid data evaluation. Accordingly, parse component  is not limited to extremely rigid data. It can easily handle variations in structure such as where there is preamble information before elements of interest.","A concrete example is now provided to clarify aspects not to limit the claimed subject matter thereto. Consider the following XML tree for a product catalog (e.g., a wine catalog), whose products are further grouped in categories.",{"@attributes":{"id":"p-0040","num":"0039"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<catalog>"]},{"entry":[{},"\u2003<header>Ralf's opinionated wine catalog<\/header>"]},{"entry":[{},"\u2003<category>"]},{"entry":[{},"\u2003\u2003<id>extra-super<\/id>"]},{"entry":[{},"\u2003\u2003<header>1st level favorites<\/header>"]},{"entry":[{},"\u2003\u2003<doc>Please, bring those!<\/doc>"]},{"entry":[{},"\u2003\u2003<product id=\u201c1\u201d country=\u201cFrance\u201d>"]},{"entry":[{},"\u2003\u2003\u2003\u2003Bordeaux, Ch\u00e2teau Mouton-Rothschild"]},{"entry":[{},"\u2003\u2003\u2003<\/product>"]},{"entry":[{},"\u2003\u2003<product id=\u201c2\u201d country=\u201cFrance\u201d>"]},{"entry":[{},"\u2003\u2003\u2003\u2003Bordeaux, Ch\u00e2teau Brane-Cantenac"]},{"entry":[{},"\u2003\u2003\u2003<\/product>"]},{"entry":[{},"\u2003\u2003<product id=\u201c3\u201d country=\u201cPortugal\u201d>"]},{"entry":[{},"\u2003\u2003\u2003\u2003Vinho Verde, Alian\u00e7a"]},{"entry":[{},"\u2003\u2003\u2003<\/product>"]},{"entry":[{},"\u2003<\/category>"]},{"entry":[{},"\u2003<category>"]},{"entry":[{},"\u2003\u2003<id>still-super<\/id>"]},{"entry":[{},"\u2003\u2003<header>2nd level favorites<\/header>"]},{"entry":[{},"\u2003\u2003<doc>Please, bring those, too!<\/doc>"]},{"entry":[{},"\u2003\u2003<product id=\u201c4\u201d country=\u201cFrance\u201d>"]},{"entry":[{},"\u2003\u2003\u2003\u2003Bordeaux, Ch\u00e2teau Pouget"]},{"entry":[{},"\u2003\u2003\u2003<\/product>"]},{"entry":[{},"\u2003\u2003<product id=\u201c5\u201d country=\u201cItaly\u201d>"]},{"entry":[{},"\u2003\u2003\u2003\u2003Pinot Grigio, Ecco Domani"]},{"entry":[{},"\u2003\u2003\u2003<\/product>"]},{"entry":[{},"\u2003<\/category>"]},{"entry":[{},"<\/catalog>"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},{"@attributes":{"id":"p-0041","num":"0040"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Load XML data source into memory"]},{"entry":[{},"var wines = XElement.Load(\u201cWines.xml\u201d);"]},{"entry":[{},"\/\/ A query that iterates"]},{"entry":[{},"var products ="]},{"entry":[{},"\u2003from category in wines.Elements(\u201ccategory\u201d)"]},{"entry":[{},"\u2003\u2003where (string)category.Element(\u201cid\u201d) == \u201cextra-super\u201d"]},{"entry":[{},"\u2003\u2003\u2003from product in category.Elements(\u201cproduct\u201d)"]},{"entry":[{},"\u2003\u2003\u2003\u2003select product.Value;"]},{"entry":[{},"\/\/ Print the result of the lazy query"]},{"entry":[{},"foreach (var p in products)"]},{"entry":[{},"\u2003Console.WriteLine(p);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The trouble with this query is that there are no reasonable parsing semantics for executing the query in a single-pass manner. The crux of the problem is that iteration is expressed over products of a \u201ccategory\u201d element while the \u201cid\u201d element of a category needs to be looked up. In general, the same element should not be queried twice under a single-pass parsing semantics. In addition, one should not assume that both queries can be performed in a single pass (in a sort of interleaved fashion), although this may be possible, because of order constraints on the results of the two queries. In the example, the \u201cid\u201d element should be inspected first and then \u201cproduct\u201d elements filtered based thereon. The original query does not promise this particular order among \u201cid\u201d and \u201cproduct\u201d elements.","This problem can be solved by requiring a programmer to list up-front element labels for iteration at each level of the tree, when the XML data source is set up. Alternatively, these labels may be able to be omitted where they can be inferred or otherwise determined automatically. The identified elements are also called the payload of parsing (say streaming) (or simply payload), whereas all elements before such payload elements compromise what is referred to as the preamble. In the example, categories and products amount to the payload at the two levels under the rooting catalog element, wherein the \u201cid\u201d element appears in the preamble of the \u201ccategory\u201d elements (e.g., before the payload of the \u201ccategory\u201d elements, which are the \u201cproduct\u201d elements).","The capability of nested iteration can be added to an existing in-memory API as follows. Instead of a complete Load(. . . ), a LoadStream(. . . ) operation can be utilized, which sets up the element labels for the payload:",{"@attributes":{"id":"p-0045","num":"0044"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Open XML data source and perform shallow load"]},{"entry":[{},"var wines = XElement.LoadStream("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003\u201cWines.xml\u201d,","\/\/ The XML data source"]},{"entry":[{},"\u2003\u2003\u201ccatalog\u201d,","\/\/ The rooting element label"]},{"entry":[{},"\u2003\u2003\u201ccategory\u201d, \u201cproduct\u201d","\/\/ Element labels for payload"]},{"entry":[{},"\u2003\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},{"@attributes":{"id":"p-0046","num":"0045"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<catalog>"]},{"entry":[{},"\u2003<header>Ralf's opinionated wine catalog<\/header>"]},{"entry":[{},"<\/catalog>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"In general, preamble elements are materialized and parented. Hence, preamble elements can be queried in a conventional manner. The payload is accessed by a designated Stream( ) method (a new axis so to say) which parses the payload in its serialized form. Clearly, one can iterate over the payload only once.","The earlier in-memory query for printing selected product names evolves as follows: queries for the payload (based on the Elements axis) are basically replaced by a new Stream axis and the query regarding the preamble remains unchanged as shown below:",{"@attributes":{"id":"p-0049","num":"0048"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ A query that uses the new Stream axis"]},{"entry":[{},"var products ="]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u2003from category in wines.Stream( )","\/\/ Elements(\u201ccategory\u201d)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u2003where (string)category.Element(\u201cid\u201d) == \u201cextra-super\u201d"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003from product in category.Stream( )","\/\/ Elements(\u201cproduct\u201d)"]},{"entry":[{},"\u2003select product.Value;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},{"@attributes":{"id":"p-0050","num":"0049"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"foreach (var p in products)"]},{"entry":[{},"\u2003\u2003Console.WriteLine(p);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Now consider execution and memory state of the above code. First, the \u201cwines.xml\u201d file can be opened and some verification performed to unsure a valid starting state. The catalog element is then shallow loaded until it hits the first category element, because that is a designated element over which iteration is to occur. At this point the memory state resembles:",{"@attributes":{"id":"p-0052","num":"0051"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<catalog>"]},{"entry":[{},"\u2003<header>Ralf's opinionated wine catalog<\/header>"]},{"entry":[{},"<\/catalog>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The remainder of execution is driven by the query. The first line says iterate over the stream of \u201ccategory\u201d elements in the \u201cwine\u201d catalog. Elements returned by this streaming are again trees that subject to a new level of distinction between materialized preamble and iterate-once payload. In this case, the payload is the nested product element. Accordingly, shallow loading can be performed loading preamble information up until the \u201cproduct\u201d element. The resulting memory state resembles:",{"@attributes":{"id":"p-0054","num":"0053"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<catalog>"]},{"entry":[{},"\u2003<header>Ralf's opinionated wine catalog<\/header>"]},{"entry":[{},"\u2003<category>"]},{"entry":[{},"\u2003\u2003<id>extra-super<\/id>"]},{"entry":[{},"\u2003\u2003<header>1st level favorites<\/header>"]},{"entry":[{},"\u2003\u2003<doc>Please, bring those!<\/doc>"]},{"entry":[{},"\u2003<\/category>"]},{"entry":[{},"\u2003<category>"]},{"entry":[{},"\u2003\u2003<id>still-super<\/id>"]},{"entry":[{},"\u2003\u2003<header>2nd level favorites<\/header>"]},{"entry":[{},"\u2003\u2003<doc>Please, bring those, too!<\/doc>"]},{"entry":[{},"\u2003<\/category>"]},{"entry":[{},"<\/catalog>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Next or concurrently, the data can be filtered by the \u201cwhere\u201d clause to identify only categories of including the id \u201cextra-super.\u201d As a result, categories that are not labled \u201cextra-super\u201d can be thrown away or alternatively information pertaining thereto never materailized. The resulting memory state resembles:",{"@attributes":{"id":"p-0056","num":"0055"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<catalog>"]},{"entry":[{},"\u2003<header>Ralf's opinionated wine catalog<\/header>"]},{"entry":[{},"\u2003<category>"]},{"entry":[{},"\u2003\u2003<id>extra-super<\/id>"]},{"entry":[{},"\u2003\u2003<header>1st level favorites<\/header>"]},{"entry":[{},"\u2003\u2003<doc>Please, bring those!<\/doc>"]},{"entry":[{},"\u2003<\/category>"]},{"entry":[{},"<\/catalog>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Finally, products for this single category can be iterated over and printed to a screen. The result identifies three wines \u201cBordeaux, Ch\u00e2teau Mouton-Rothschild,\u201d \u201cBordeaux, Ch\u00e2teau Brane-Cantenac\u201d and \u201cVinho Verde, Alianca.\u201d Since there is no preamble information for products, they can simply be materialized, evaluated, and thrown away one by one. Accordingly, \u201cproduct\u201d element need only be transiently resident such that only one element is in memory at a time. For the first element the memory state can resemble:",{"@attributes":{"id":"p-0058","num":"0057"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<catalog>"]},{"entry":[{},"\u2003<header>Ralf's opinionated wine catalog<\/header>"]},{"entry":[{},"\u2003<category>"]},{"entry":[{},"\u2003\u2003<id>extra-super<\/id>"]},{"entry":[{},"\u2003\u2003<header>1st level favorites<\/header>"]},{"entry":[{},"\u2003\u2003<doc>Please, bring those!<\/doc>"]},{"entry":[{},"\u2003\u2003<product id=\u201c1\u201d country=\u201cFrance\u201d>"]},{"entry":[{},"\u2003\u2003\u2003\u2003Bordeaux, Ch\u00e2teau Mouton-Rothschild"]},{"entry":[{},"\u2003\u2003\u2003<\/product>"]},{"entry":[{},"\u2003\u2003\u2003<\/product>"]},{"entry":[{},"\u2003<\/category>"]},{"entry":[{},"<\/catalog>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"As can be observed, streaming processing of nested queries results in substantially less memory utilization than full materialization. Although a rudimentary statistic, the above example results in a total of approximately twelve lines of code materailized compared to twenty-eight for complete structure materialization. Furthermore, memory state fluxates such that the average amount of code is even less. This translates to enormous memory savings for much larger structures.","To summarize, XML trees are loaded into the memory in a shallow fashion such that loading stops at the previously identified payload of the XML input. While the preamble of the payload can be queried in the normal manner, the payload is queried at most once by a special streaming member. The reliable distinction between preamble and payload rests on up-front identification of labels for payload elements through all levels of nesting. Each element returned by the streaming member is again a shallow XML tree that is subjected to a new level of distinction between materialized preamble and iterate-once payload. These shallow elements are never parented and hence can be easily recovered by garbage collection.","The previously described exemplary idiom may be limited in some ways. For instance, the descendant axis and the provision of functional updates would require non-trivial elaborations of the idiom. Additionally, diverse use of the original XML-tree type for preamble elements and non-parented payload elements may count as pragmatic.","A more general and principled approach is to designate a new object type to serialize a data structure, for example \u201cXElementReader\u201d to serialized XML trees. An instance of the object can denote a pointer to a serialized structure. Object methods and\/or functions can be similar to that of an in-memory object except that a method can exist for opening streaming data rather than loading data into memory. Similarly, rather than returning materialized sub-trees, pointers to serialized trees can be returned. In this manner, very similar programming models can exist for both in-memory and streaming semantics, if there are two implementations. One that works in memory and the other that reads over serialized structures.","In terms of XML and the previous example, an XElementReader instance can denote a pointer to a serialized tree:\n\n","In sum, parsing semantics opens a data source, and query execution seeks into the serialized structure driven by a downward query. Many of these axes can be executed under a parsing semantics. Essentially, all axes for downward queries are conveniently enabled for the parsing semantics, while some additional forward queries could also be enabled. However, the parsing semantics can be limited such that at most one query can be applied to each given node. This restriction is implied by the single-pass sequential nature of parsing semantics. The following is a table of typical XML queries and comments on serial parsing semantics:",{"@attributes":{"id":"p-0065","num":"0066"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE A"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Query form (axis)","Parsing semantics"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Element label","Store label when pointer is positioned"]},{"entry":["Attributes (all or by name)","Store attributes when pointer is positioned"]},{"entry":["Children (all or by name)","Seek to serialized sub-trees of current tree"]},{"entry":["Simple-typed content access","Read content of current tree"]},{"entry":["Descendants (all or by name)","Semantics questionable"]},{"entry":["Top-most descendants","Seek to serialized descendants"]},{"entry":["by name","of current tree"]},{"entry":["Parent","No declarative semantics"]},{"entry":["Ancestors","No declarative semantics"]},{"entry":["Preceding siblings","Violation of one-pass sequential model"]},{"entry":["Following sibling","Possible"]},{"entry":["Preceding nodes in","Violation of one-pass sequential model"]},{"entry":"document order"},{"entry":["Following nodes","Possible"]},{"entry":"in document order"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Referring to , another representative data parse component  is illustrated in accordance with an aspect of the claimed subject matter. Similar to , the parse component  include the load component  and stream component , as previously described. In brief, the load component  provides a mechanism for shallow loading portions of a data structure in memory  and stream component  streams through data iteratively interacting with the load component  and memory  where necessary. In essence, the components  and  facilitate serial processing of a data structure including nested iteration.","However, in some instance, serial or iterate-once processing may not be desirable or even possible. Accordingly, the parse component  can include a native, or interact with a foreign, materialization component . The materialization component  is a mechanism for materializing portions of a data structure to memory  (e.g., implicitly or explicitly) to facilitate evaluation. In one instance, the materialization component  can be utilized as an escape from serial processing to richer in-memory processing. However, materialized portions need not be parented with other portions of structures thereby making them available for garbage collection after use. Further yet, it should also be appreciated that materialization component  can be employed to add in-memory processing such that a portions of a structure are evaluated in-memory and others serially.","To aid understanding, consider the problem of listing all books on loan from an XML document of a large number of books. The following is a reference solution utilizing an in-memory language integrated query.",{"@attributes":{"id":"p-0069","num":"0070"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"var books = XElement.Load(\u201cBooks.xml\u201d);"]},{"entry":[{},"var loans ="]},{"entry":[{},"\u2003\u2003from b in books.Elements(\u201cbook\u201d)"]},{"entry":[{},"\u2003\u2003where b.Attribute(\u201con-loan\u201d) != null"]},{"entry":[{},"\u2003\u2003select b;"]},{"entry":[{},"foreach (var l in loans)"]},{"entry":[{},"\u2003\u2003Console.WriteLine("]},{"entry":[{},"\u2003\u2003\u201cborrower:\u201d + (string)l.Attribute(\u201con-loan\u201d) + \u201c; \u201d +"]},{"entry":[{},"\u2003\u2003\u201ctitle:\u201d + (string)l.Element(\u201ctitle\u201d) + \u201c; \u201d +"]},{"entry":[{},"\u2003\u2003\u201cauthor:\u201d + (string)l.Element(\u201cauthor\u201d));"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The sample code evolves as follows (note the use of the new object type \u201cXElementReader\u201d previously described):",{"@attributes":{"id":"p-0071","num":"0072"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"var books = XElementReader.Open(\u201cBooks.xml\u201d);"]},{"entry":[{},"var loans ="]},{"entry":[{},"\u2003\u2003from b in books.Elements(\u201cbook\u201d)"]},{"entry":[{},"\u2003\u2003where b.Attribute(\u201con-loan\u201d) != null"]},{"entry":[{},"\u2003\u2003select b.Materialize( );"]},{"entry":[{},"foreach (var l in loans)"]},{"entry":[{},"\u2003\u2003Console.WriteLine("]},{"entry":[{},"\u2003\u2003\u2003\u201cborrower:\u201d + (string)l.Attribute(\u201con-loan\u201d) + \u201c; \u201d +"]},{"entry":[{},"\u2003\u2003\u201ctitle:\u201d + (string)l.Element(\u201ctitle\u201d) + \u201c; \u201d +"]},{"entry":[{},"\u2003\u2003\u201cauthor:\u201d + (string)l.Element(\u201cauthor\u201d));"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The materialization component  can also be utilized to facilitate specification of order constraints, which normally are not done in in-memory cases. More specifically, the materialization component  can interact with the load component , memory  and\/or stream component  to materialize a portion of data up until a certain designated point (e.g., MaterializeUntil(x)). Further yet, a serialized structure can be constructed including a preamble and payload as previously described with respect to nested iteration.","The query axes as discussed so far, for \u201cXElementReader\u201d for example, cover chaining but branching is not valid. For instance, the following code pattern is invalid; an attempt is made to \u201cdot\u201d twice into the same \u201cXElementReader\u201d instance \u201cxre:\u201d",{"@attributes":{"id":"p-0074","num":"0075"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Console.WriteLine(xre.Element(\u201cfoo\u201d) != null);"]},{"entry":[{},"foreach (var x in xre.Elements(\u201cbar\u201d))"]},{"entry":[{},"\u2003\u2003Console.WriteLine((string)x.Attribute(\u201cid\u201d));"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The distinction between preamble and payload that was already made for nested iteration can be re-enabled here. To this end, an original axis, \u201cMaterializeUntil,\u201d for ordered, branching queries with parsing semantics is added. Here is the necessary revision of the branching query:",{"@attributes":{"id":"p-0076","num":"0077"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"var branch = xre.MaterializeUntil(\u201cbar\u201d);"]},{"entry":[{},"Console.WriteLine(branch.Element(\u201cfoo\u201d) != null);"]},{"entry":[{},"foreach (var x in branch.Stream(\u201cbar\u201d))"]},{"entry":[{},"\u2003Console.WriteLine((string)x.Attribute(\u201cid\u201d));"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"ul":{"@attributes":{"id":"ul0003","list-style":"none"},"li":["This pattern is read as follows: materialize \u201cxre\u201d until before the first \u201cbar\u201d (if, any); the result, \u201cbranch,\u201d provides access to the materialized preamble and to the payload. The insight regarding this form of branching queries is that for every \u201cXElementReader\u201d instance \u201cxre\u201d and every label \u201cn,\u201d the following two queries are equivalent:","xre.Elements(n)=xre.MaterializeUntil(n).Stream( )","The point is that the second form (e.g., for ordered, branching queries) additionally provides access to the preamble, that is, all the children that appear before the stream of elements labeled \u201cn.\u201d By materializing the preamble, it can be queried multiple times and regardless of the progress with the stream. The specific idiom of nested iteration can now be fully subsumed by the additional query axis of the \u201cXElementReader\u201d type and an associated \u201cMaterializeUntil\u201d method. Hence, the sample that we used to for nested iteration can be reconstructed in this form as follows:"]}},{"@attributes":{"id":"p-0077","num":"0081"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Open XML data source"]},{"entry":[{},"var wines = XElementReader.Open(\u201cWines.xml\u201d);"]},{"entry":[{},"\/\/ A query that iterates"]},{"entry":[{},"var products ="]},{"entry":[{},"\u2003from category in wines.Elements(\u201ccategory\u201d)"]},{"entry":[{},"\u2003let branch = category.MaterializeUntil(\u201cproduct\u201d)"]},{"entry":[{},"\u2003where (string)branch.Element(\u201cid\u201d) == \u201cextra-super\u201d"]},{"entry":[{},"\u2003from product in branch.Stream( )"]},{"entry":[{},"\u2003select product.Value;"]},{"entry":[{},"\/\/ Print the result of the lazy query"]},{"entry":[{},"foreach (var p in products)"]},{"entry":[{},"\u2003Console.WriteLine(p);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The aforementioned systems, architectures and the like have been described with respect to interaction between several components. It should be appreciated that such systems and components can include those components or sub-components specified therein, some of the specified components or sub-components, and\/or additional components. Sub-components could also be implemented as components communicatively coupled to other components rather than included within parent components. Further yet, one or more components and\/or sub-components may be combined into a single component to provide aggregate functionality. Communication between systems, components and\/or sub-components can be accomplished in accordance with either a push and\/or pull model. The components may also interact with one or more other components not specifically described herein for the sake of brevity, but known by those of skill in the art.","Furthermore, as will be appreciated, various portions of the disclosed systems and methods may include or consist of artificial intelligence, machine learning, or knowledge or rule based components, sub-components, processes, means, methodologies, or mechanisms (e.g., support vector machines, neural networks, expert systems, Bayesian belief networks, fuzzy logic, data fusion engines, classifiers . . . ). Such components, inter alia, can automate certain mechanisms or processes performed thereby to make portions of the systems and methods more adaptive as well as efficient and intelligent. By way of example and not limitation, the parse component  can utilize such mechanisms to infer element labels for payloads and\/or implicitly identify and initialize materialization of structure where need for code parsing that employs serial parsing semantics.","In view of the exemplary systems described supra, methodologies that may be implemented in accordance with the disclosed subject matter will be better appreciated with reference to the flow charts of . While for purposes of simplicity of explanation, the methodologies are shown and described as a series of blocks, it is to be understood and appreciated that the claimed subject matter is not limited by the order of the blocks, as some blocks may occur in different orders and\/or concurrently with other blocks from what is depicted and described herein. Moreover, not all illustrated blocks may be required to implement the methodologies described hereinafter.","Referring to , a method of data parsing  is illustrated in accordance with an aspect of the claimed subject matter. At reference numeral , declarative code is identified for data parsing (e.g., querying, extracting, consuming, transforming . . . ). Declarative code identifies what action should be taken, rather than how an action is to be performed, which is characteristic of imperative code. Examples of declarative style code can be found in SQL, LINQ and FLWOR expressions. For instance, a data source can be identified and elements of the source selected as a function of a description of the data such as products sold in the United States. At numeral , the declarative code is processes serially over an input source. The input source can be opened and serial parsing semantics implemented to parse or process data elements one by one in a streaming fashion in accordance with the declarative code without first loading an entire relevant data source in memory. Accordingly, method  preserves overall convenience of writing declarative code while providing underlying semantics for memory efficient processing of data in a serial or iterative manner.",{"@attributes":{"id":"p-0082","num":"0086"},"figref":"FIG. 6","b":["600","610","620","630","640","610"]},{"@attributes":{"id":"p-0083","num":"0087"},"figref":"FIG. 7","b":["700","710","720","730"]},{"@attributes":{"id":"p-0084","num":"0088"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"static double Total(XElementReader company)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003return"]},{"entry":[{},"\u2003\u2003\u2003\u2003(from s in company.Topmosts(\u201csalary\u201d)"]},{"entry":[{},"\u2003\u2003\u2003\u2003select (double) s.Materialize( )"]},{"entry":[{},"\u2003\u2003\u2003\u2003).Sum( );"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"Turning attention to , a method of parsing branching queries, aggregations and\/or transformations  is illustrated in accordance with an aspect of the claimed subject matter. Branching queries can be defined as multiple queries departing from the same node of a tree or other structure. By way of example, if a data structure includes \u201celement\u201d nodes queries or other parsing semantics are to be performed with respect to two particular elements \u201cfoo\u201d and \u201cbar,\u201d a single pass problem can occur such that while looking for elements \u201cfoo,\u201d elements \u201cbar\u201d will be passed without identification. This problem can be solved by explicit ordering of queries and use of materialization.","At reference numeral , a source is open for serial parsing. A select portion of data can be materialized in memory at , for example of in accordance with a \u201cMaterializeUntil\u201d method. In one instance, a serialized structure can be creates as described with respect to nesting such that a preamble is materialized up to a pointer to a payload to be iteratively processed. At reference , a first branch query is processed utilizing the in-memory data structure. At numeral , a second branch query or the like can be serially evaluated. This scenario assumes that elements described by the first query appear in order before elements of the second query.","It is to be appreciated that the branch query method  incorporates aspects described regarding nested queries including utilizing a serialized structure including preambles and payloads. Moreover, it is to be noted that method  can applied to nested query processing.","As used herein, the terms \u201ccomponent,\u201d \u201csystem\u201d and the like are intended to refer to a computer-related entity, either hardware, a combination of hardware and software, software, or software in execution. For example, a component may be, but is not limited to being, a process running on a processor, a processor, an object, an instance, an executable, a thread of execution, a program, and\/or a computer. By way of illustration, both an application running on a computer and the computer can be a component. One or more components may reside within a process and\/or thread of execution and a component may be localized on one computer and\/or distributed between two or more computers.","The word \u201cexemplary\u201d is used herein to mean serving as an example, instance or illustration. Any aspect or design described herein as \u201cexemplary\u201d is not necessarily to be construed as preferred or advantageous over other aspects or designs. Furthermore, examples are provided solely for purposes of clarity and understanding and are not meant to limit the subject innovation or relevant portion thereof in any manner. It is to be appreciated that a myriad of additional or alternate examples could have been presented, but have been omitted for purposes of brevity.","As used herein, the term \u201cinference\u201d or \u201cinfer\u201d refers generally to the process of reasoning about or inferring states of the system, environment, and\/or user from a set of observations as captured via events and\/or data. Inference can be employed to identify a specific context or action, or can generate a probability distribution over states, for example. The inference can be probabilistic\u2014that is, the computation of a probability distribution over states of interest based on a consideration of data and events. Inference can also refer to techniques employed for composing higher-level events from a set of events and\/or data. Such inference results in the construction of new events or actions from a set of observed events and\/or stored event data, whether or not the events are correlated in close temporal proximity, and whether the events and data come from one or several event and data sources. Various classification schemes and\/or systems (e.g., support vector machines, neural networks, expert systems, Bayesian belief networks, fuzzy logic, data fusion engines . . . ) can be employed in connection with performing automatic and\/or inferred action in connection with the subject innovation.","Furthermore, all or portions of the subject innovation may be implemented as a method, apparatus or article of manufacture using standard programming and\/or engineering techniques to produce software, firmware, hardware, or any combination thereof to control a computer to implement the disclosed innovation. The term \u201carticle of manufacture\u201d as used herein is intended to encompass a computer program accessible from any computer-readable device or media. For example, computer readable media can include but are not limited to magnetic storage devices (e.g., hard disk, floppy disk, magnetic strips . . . ), optical disks (e.g., compact disk (CD), digital versatile disk (DVD) . . . ), smart cards, and flash memory devices (e.g., card, stick, key drive . . . ). Additionally it should be appreciated that a carrier wave can be employed to carry computer-readable electronic data such as those used in transmitting and receiving electronic mail or in accessing a network such as the Internet or a local area network (LAN). Of course, those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.","In order to provide a context for the various aspects of the disclosed subject matter,  as well as the following discussion are intended to provide a brief, general description of a suitable environment in which the various aspects of the disclosed subject matter may be implemented. While the subject matter has been described above in the general context of computer-executable instructions of a program that runs on one or more computers, those skilled in the art will recognize that the subject innovation also may be implemented in combination with other program modules. Generally, program modules include routines, programs, components, data structures, etc. that perform particular tasks and\/or implement particular abstract data types. Moreover, those skilled in the art will appreciate that the systems\/methods may be practiced with other computer system configurations, including single-processor, multiprocessor or multi-core processor computer systems, mini-computing devices, mainframe computers, as well as personal computers, hand-held computing devices (e.g., personal digital assistant (PDA), phone, watch . . . ), microprocessor-based or programmable consumer or industrial electronics, and the like. The illustrated aspects may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. However, some, if not all aspects of the claimed subject matter can be practiced on stand-alone computers. In a distributed computing environment, program modules may be located in both local and remote memory storage devices.","With reference to , an exemplary environment  for implementing various aspects disclosed herein includes a computer  (e.g., desktop, laptop, server, hand held, programmable consumer or industrial electronics . . . ). The computer  includes a processing unit , a system memory  and a system bus . The system bus  couples system components including, but not limited to, the system memory  to the processing unit . The processing unit  can be any of various available microprocessors. It is to be appreciated that dual microprocessors, multi-core and other multiprocessor architectures can be employed as the processing unit .","The system memory  includes volatile and nonvolatile memory. The basic input\/output system (BIOS), containing the basic routines to transfer information between elements within the computer , such as during start-up, is stored in nonvolatile memory. By way of illustration, and not limitation, nonvolatile memory can include read only memory (ROM). Volatile memory includes random access memory (RAM), which can act as external cache memory to facilitate processing.","Computer  also includes removable\/non-removable, volatile\/non-volatile computer storage media.  illustrates, for example, mass storage . Mass storage  includes, but is not limited to, devices like a magnetic or optical disk drive, floppy disk drive, flash memory or memory stick. In addition, mass storage  can include storage media separately or in combination with other storage media.",{"@attributes":{"id":"p-0096","num":"0100"},"figref":"FIG. 9","b":["928","910","928","924","912","916","924"]},"The computer  also includes one or more interface components  that are communicatively coupled to the bus  and facilitate interaction with the computer . By way of example, the interface component  can be a port (e.g., serial, parallel, PCMCIA, USB, FireWire\u2122 port . . . ) or an interface card (e.g., sound, video, network . . . ) or the like. The interface component  can receive input and provide output (wired or wirelessly). For instance, input can be received from devices including but not limited to, a pointing device such as a mouse, trackball, stylus, touch pad, keyboard, microphone, joystick, game pad, satellite dish, scanner, camera, other computer and the like. Output can also be supplied by the computer  to output device(s) via interface component . Output devices can include displays (e.g., CRT, LCD, plasma . . . ), speakers, printers and other computers, among other things.",{"@attributes":{"id":"p-0098","num":"0102"},"figref":"FIG. 10","b":["1000","1000","1010","1010","1000","1030","1000","1030","1030","1010","1030"]},"The system  includes a communication framework  that can be employed to facilitate communications between the client(s)  and the server(s) . The client(s)  are operatively connected to one or more client data store(s)  that can be employed to store information local to the client(s) . Similarly, the server(s)  are operatively connected to one or more server data store(s)  that can be employed to store information local to the servers . For example, data housed in server store  can be parsed on a client  wherein the data is streamed from a server  to a client  over the communication framework .","What has been described above includes examples of aspects of the claimed subject matter. It is, of course, not possible to describe every conceivable combination of components or methodologies for purposes of describing the claimed subject matter, but one of ordinary skill in the art may recognize that many further combinations and permutations of the disclosed subject matter are possible. Accordingly, the disclosed subject matter is intended to embrace all such alterations, modifications and variations that fall within the spirit and scope of the appended claims. Furthermore, to the extent that the terms \u201cincludes,\u201d \u201chas\u201d or \u201chaving\u201d or variations in form thereof are used in either the detailed description or the claims, such terms are intended to be inclusive in a manner similar to the term \u201ccomprising\u201d as \u201ccomprising\u201d is interpreted when employed as a transitional word in a claim."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
