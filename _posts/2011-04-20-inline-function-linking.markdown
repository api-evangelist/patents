---
title: Inline function linking
abstract: In general, techniques are described for performing a form of inline dead code elimination. An apparatus comprising a storage unit and a processor may implement these techniques. The storage unit stores two source files and a destination file. The processor copies a first one of the source files to the destination file. This first source file includes a reference to a portion of a second one of the source files. The processor then evaluates the destination file to determine whether the portion of the second source file referenced in the first source file is used by the destination file. Based on the determination that the portion of the second source file referenced in the first source file is used by the destination file, the processor selectively copies the portion of the second source file to the destination file to generate an updated destination file.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08935683&OS=08935683&RS=08935683
owner: QUALCOMM Incorporated
number: 08935683
owner_city: San Diego
owner_country: US
publication_date: 20110420
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This disclosure relates to computing devices and, more particularly, the generation of instructions for execution by computing devices.","A computer programmer generally creates software programs using a high-level programming language, such as C++, JAVA, VISUAL BASIC, or the like. The computer programmer may define his\/her own functions within the computer program using the high-level programming language or may rely on libraries of functions that are already defined and provided to the computer programmer via the programming environment. For example, a computer programmer may develop his\/her own functions to create a user interface or rely on functions specified in libraries of functions (which are usually referred to as \u201clibraries\u201d) provided by MICROSOFT, APPLE or other operating system developers. These libraries are often large and the computer programmer generally only uses a small subset of the functions made available by these libraries when coding any one program. In this sense, the libraries may be large but sparsely utilized on a per-program basis.","Once the computer programmer has finished writing a computer program using the high-level programming language, the computer programmer invokes a computer program, referred to as a compiler, to reduce the high-level code to lower-level code, outputting the lower-level code in the form of a destination file. This lower-level code is often referred to as \u201cintermediate representation\u201d or \u201cIR\u201d code. The compiler may perform some forms of optimization on the IR code to reduce the size of the IR code. For example, the compiler may determine that one or more functions of the original high-level code will never be executed during operation (such as debugging functions) and removes portions of the IR code to remove these functions. The compiler then translates the IR code into compiled code, which may be IR code written in a different IR programming language or machine or assembly language code executable by a computing device. The compiler may then output the compiled code along with link data defining how to link this compiled code with the one or more libraries referenced and used by the high-level code.","A program referred to as a \u201clinker\u201d receives the compiled code and the data defining how to link this compiled code with the libraries. The linker then copies the libraries into the correct location relative to the compiled code in accordance with the link data provided by the compiler. In essence, this linker may represent a symbol-based copier, as the libraries and compiled code are nothing more than abstract symbols to the linker, in that it does not perform any form of syntax, semantic or other checks, optimization or the like. The linker copies these libraries in their entirety into the compiled code to form destination data. The libraries include compiled code defining the various functions so that these do not need to be compiled by a compiler again. In this way, the linker may arrange disparate data from multiple sources, e.g., libraries and user-defined compiled code, into a destination data, which may eventually be output as a destination file. The destination file may comprise an executable file in some instances.","As noted above, these libraries are large and may typically include tens, hundreds, if not thousands of functions. Moreover, the user-defined code may only sparsely utilize these functions in that this code only utilizes a small subset or percentage of the functions provided by the library. Considering that libraries of this size may require significant amounts of memory when copied into the destination file, the linker may invoke a computer program referred to as a \u201clink time optimizer\u201d to perform dead code elimination so as to reduce the amount of memory consumed by the resulting libraries and user-defined code. The link time optimizer may copy the libraries over to the executable file and then evaluate the destination file to eliminate any dead code, i.e., code that would not be reachable during execution. However, this linker-level dead code elimination often takes a large amount of time and involves significant processing power that consumes a substantial amount of energy, as a result of having to evaluate potentially thousands of functions to determine whether these functions are invoked or, in other words, used. As a result of these inefficiencies, the linker-level dead code elimination is often limited in its applicability especially when this form of linker-level dead code elimination is required to be implemented in real-time or near real-time or by power-sensitive devices, such as mobile phones, mobile media players, mobile gaming devices and the like.","In general, this disclosure describes techniques for providing a form of \u201clazy\u201d linking that copies libraries reachable by the user-defined code without first copying an entire library of functions into the destination file. In this way, the techniques of this disclosure may avoid expensive memory copies (and thereby may reduce power consumption by avoiding these memory copies) by copying only what is reachable by the user-defined code. Hence, the techniques may identify libraries that are reachable by the user-defined code, and copy the identified libraries. Accordingly, the technique may avoid copying an entire library of functions into the destination file. Moreover, the techniques of this disclosure may perform an inline form of dead code elimination in that code is eliminated by virtue of only copying what is reachable. Thus, rather than perform an after-the-fact form of dead code elimination, in which code is eliminated after copying the entire library, and linking this library with the user-defined compiled code, the techniques discussed in this disclosure may avoid copying at least some of the entire library to exclude at least some functions that are not reachable. In some examples, the technique may be only copy those functions that are reachable.","In one example, a method for copying data from two source files to a destination file is described. The method comprises copying a first one of the two source files to the destination file with a processor, wherein the first one of the source files includes a reference to a portion of a second one of the two source files and evaluating, with the processor, the destination file to determine whether the portion of the second one of the two source files referenced in the first one of the two source files is used by the destination file. The method also comprises, based on the determination that the portion of the second one of the two source files referenced in the first one of the two source files is used by the destination file, selectively copying the portion of the second one of the two source files to the destination file with the processor to generate an updated destination file.","In another example, an apparatus for copying data from two source files to a destination file is described. The apparatus comprises means for copying a first one of the two source files to the destination file, wherein the first one of the source files includes a reference to a portion of a second one of the two source files, means for evaluating the destination file to determine whether the portion of the second one of the two source files referenced in the first one of the two source files is used by the destination file and, based on the determination that the portion of the second one of the two source files referenced in the first one of the two source files is used by the destination file, means for selectively copying the portion of the second one of the two source files to the destination file to generate an updated destination file.","In another example, an apparatus for copying data from two source files to a destination file is described. The apparatus comprises a storage unit that stores the two source files and the destination file and one or more processors that copy a first one of the two source files to the destination file, wherein the first one of the source files includes a reference to a portion of a second one of the two source files, evaluate the destination file to determine whether the portion of the second one of the two source files referenced in the first one of the two source files is used by the destination file and, based on the determination that the portion of the second one of the two source files referenced in the first one of the two source files is used by the destination file, selectively copy the portion of the second one of the two source files to the destination file to generate an updated destination file.","In another example, a non-transitory computer-readable medium comprising instructions that, when executed, cause one or more processors to copy a first one of the two source files to the destination file with a processor, wherein the first one of the source files includes a reference to a portion of a second one of the two source files, evaluate, with the processor, the destination file to determine whether the portion of the second one of the two source files referenced in the first one of the two source files is used by the destination file and, based on the determination that the portion of the second one of the two source files referenced in the first one of the two source files is used by the destination file, selectively copy the portion of the second one of the two source files to the destination file with the processor to generate an updated destination file.","The details of one or more examples are set forth in the accompanying drawings and the description below. Other features, objects, and advantages will be apparent from the description and drawings, and from the claims.",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1","b":["12","12","12"]},"In the example of , computing device  includes a control unit . Control unit  may represent one or more processors (not shown in ) that execute software instructions, such as those used to define a software or computer program, stored to a computer-readable storage medium (again, not shown in ), such as a storage device (e.g., a disk drive, or an optical drive), or memory (such as Flash memory, random access memory or RAM) or any other type of volatile or non-volatile memory, that stores instructions to cause a programmable processor to perform the techniques described herein. Alternatively, control unit  may represent dedicated hardware, such as one or more integrated circuits, one or more Application Specific Integrated Circuits (ASICs), one or more Application Specific Special Processors (ASSPs), one or more Field Programmable Gate Arrays (FPGAs), or any combination of one or more of the foregoing examples of dedicated hardware, for performing the techniques described herein.","Control unit  includes compute devices A-N (\u201ccompute devices \u201d). Compute devices  each represent an abstraction of an underlying execution unit of computing device . Each of computing devices  may represent, for example, a central processing unit (CPU), a graphics processing unit (GPU), a digital signal processor (DSP), or any other type of processor or hardware unit capable of executing instructions. Each of compute devices  includes a respective one or more of compute units A-N (\u201ccompute units \u201d). For compute units  associated with compute devices  that represent CPU's, compute units  each represent a processing unit or so-called \u201ccore\u201d in instances where the corresponding one of compute devices  represents a so-called \u201cmulti-core processor.\u201d A multi-core processor is a processor that includes two or more processors, which are referred to as \u201ccores\u201d in this multi-core context, integrated into a single integrated circuit die or that are provided using multiple circuit dies but that share a single chip package. Those of compute devices  that represent a multi-core processor express each of these cores as a different one of corresponding compute units . Each of compute units  may further each include one or more processing elements (PEs) A-N (\u201cprocessing elements \u201d or \u201cPEs \u201d). Each of processing elements  represents a thread processor, as many processors or \u201ccores\u201d in the context of multicore processors may be multithreaded, meaning that these processors may execute multiple hardware threads at once and\/or virtualize execution of multiple hardware threads at once.","For compute units  associated with compute devices  that represent GPUs, compute units  may represent single instruction multiple data (SIMD) processing units. Many GPUs may include multiple SIMD processing units, each of which includes processing elements  in the form of thread processors. In this sense, compute devices , compute units  and processing elements  represent a hierarchical abstraction of the underlying CPUs, GPUs and other processing units of computing device . This abstraction provides for a framework in which any type of underlying computing unit may be represented such that an application can be executed across different computing units. A coding language referred to as \u201cOpen Computing Language\u201d or \u201cOpenCL\u201d provides this abstraction to enable execution of a single application across different computing units.","That is, OpenCL provides a framework for writing or otherwise coding programs, such as host program  (which may be referred to as an application  or app ), that are capable of being executed across heterogeneous platforms consisting of CPUs, GPUs, and any other type of processor, such as a digital signal processor (DSP). OpenCL includes a programming language that is based on another program language commonly known as C99 (which itself is a modern adaption of the C programming language) for writing so-called \u201ckernels.\u201d These kernels represent OpenCL functions that are capable of being executed by computing devices that support OpenCL, such as computing device . OpenCL also defines an application programming interface (API) that is used by developers to define and then control the platform. The OpenCL API may provide an interface by which to identify a computing context or, in other words, identify compute devices , compute units  and processing elements . The OpenCL API may also provide an interface by which to control this computing context. For example, the OpenCL API may provide an interface by which a developer may assign kernels to identified compute devices , compute units  and\/or processing elements  to control the execution of the kernel.","In the example of , control unit  executes host program , which includes one or more kernels . As described above, host program  is assumed for purposes of illustration to represent an OpenCL host program that includes one or more OpenCL kernels . These kernels  may each represent a source file that is defined by a user. In this sense, kernels  may be considered as user-defined source files. The OpenCL framework provides for a real-time or near-real-time form of compilation that may be referred to as just-in-time (JIT) compilation. JIT compilation involves compiling source code writing in a high-level programming language, such as C99, immediately before the execution of the resulting compiled code, hence the name just-in-time compilation. JIT compilation may be employed in instances where host program  may be executed across a wide number of different platforms. Rather than pre-compile all of the code in host program  for each of the different platforms prior to distribution of host program  (which is both time consuming and may result in hundreds of different compiled versions of host program ), developers may develop and pre-compile certain aspects of host program , leaving other portions or aspects of host program  un-compiled in the form of kernels . These kernels  therefore represent functions or other portions of host program  that have not yet been compiled. As a result of not being compiled, kernels  are defined within host program  using a high-level programming language, i.e., the C99 programming language in the context of OpenCL.","To illustrate the benefits of JIT compilation, consider the emerging mobile device market, where there are any number of different mobile devices, such as computing device , that may include various different types of CPUs, GPUs and other types of processing units. Moreover, in this mobile device market, new mobile devices are introduced nearly every day that feature different, often more advanced, CPUs, GPUs and other types of processing units. These more advanced CPUs, GPUs and other types of processing units may be adapted in certain ways to more efficiently execute OpenCL host programs including their kernels. If OpenCL featured only pre-compilation, developers of OpenCL host programs would have to continually recompile these host programs for each mobile device and then distribute these mobile device-specific host programs to each of the corresponding mobile devices. Yet, the mobile device market is not adapted to such a form of direct distribution. Commonly, so-called \u201capp markets\u201d are being provided where users of mobile devices may download so-called \u201capps\u201d of which some may be OpenCL host programs similar to host program . These app markets do not generally provide for this form of direct distribution due to the complexity of implementing such a system. Instead, OpenCL provides for JIT compilation so that the mobile devices themselves may compile certain aspects of these host programs in a manner that makes best use of these devices' underlying processing unit hardware. This form of JIT compilation thereby makes development of host programs much easier in that the host program need not be separately compiled and then maintained for the different iterations and combinations of mobile device hardware.","In executing host program  in this JIT compilation framework, control unit  identifies kernels  and forwards these kernels  to runtime module . Runtime module  represents software that is executed by control unit  to manage JIT compilation and other real-time or near-real-time aspects of executing host program . Runtime module  may forward kernels  to compiler . Compiler  represents a software module that compiles or otherwise translates high-level code written in a high-level programming language into lower-level code written in a lower-level programming language. In this instance, kernels  are written in a high-level programming language referred to as C99 and compiler  translates this C99 to a lower-level code that is generally referred to as intermediate representation (IR) code. This IR code is not often directly executed by one of compute devices  and generally requires further compilation to reduce the IR code to a low-level assembly or machine programming language. IR code is often produced to enable optimization of the code to reduce its size or otherwise enhance execution of the resulting code. Generally, compiler  outputs IR code that requires further compilation when the one of compute devices  that is to execute this code represents a GPU. In instances where the one of compute devices  that is to execute the resulting code is a CPU, compiler  may generate low-level code written in a machine or assembly programming language such that this resulting low-level code can be directly executed by the CPU.","In this instance, compiler  may generally represent a compiler\/linker\/optimizer. That is, the term \u201ccompiler\u201d as used in this disclosure may refer to a compiler that has been integrated with a linker software module and a post-link optimizer software module to perform all operations necessary to generate a destination file. Compiler  therefore may include a translator or compiler that translates user-defined high-level code into lower-level object code. The linker software module of compiler  represents a module that copies or otherwise links the object code output by the translator and object code of libraries  into a destination file , which may store either machine or assembly code or the IR code discussed above.","While referred to as destination file , use of the term \u201cfile\u201d may commonly denote that this destination file is stored to a file of a storage device, although the techniques should not be limited in this respect. Destination file  generally refers to any collection of related data, which may be stored to a memory (and, thus, may not technically be conventionally considered as a file) or a storage device (and, thus, may technically be conventionally considered as a file). For this reason, destination file  may be referred to herein as \u201cdestination data\u201d and the terms \u201cdestination file\u201d and \u201cdestination data\u201d may be used interchangeably to refer to this collection of related data.","Libraries  may represent a repository of common functions that can be referenced or invoked by any host program, including host program . Libraries  permit software developers to reference these common functions to provide some functionality without having to develop this functionality themselves for each host program or application they develop. This linker or linker software module may therefore represent a module that actually copies the invoked functions of libraries  into destination file .","The optimizer aspect of compiler  then optimizes the code stored to destination file  to, for example, reduce the size of destination file  and\/or improve the subsequent execution of this code stored to destination file  or a derivative thereof (such as in instances where subsequent compilation is performed to further compile IR code into assembly or machine code). While described as an integrated compiler\/linker\/optimizer, compiler  need not necessarily be implemented in this manner. Thus, while described with respect to such an integrated compiler , the translator or compiler, linker and optimizer aspects of compiler  may be implemented as separate modules. The techniques should not therefore be limited to the exemplary implementation shown in the example of .","Compiler  outputs destination file  to runtime module , which proceeds to forward destination file  to one of compute devices . Host program  may identify the one of compute devices  that should execute destination file  and pass an identifier to runtime module  that identifies the identified one of compute devices  that is to execute destination file . Although described as executing destination file , such execution of destination file  may involve additional compilation to translate IR code to machine or assembly code that is capable of being executed by a particular one of compute devices . In this sense, destination file  may not be executed but a derivative thereof. For example, destination file  may undergo further compilation to further reduce destination file  to a lower level programming language, such as common machine or assembly programming languages, and this derivative of destination file  may be executed. Reference to execution of destination file  in this disclosure therefore refers to execution of destination file  or a derivative thereof.","In response to receiving destination file , the identified one of compute devices  executes destination file , returning the result of executing destination file  to runtime module  in the form of results . Runtime module  then passes results  back to host program , which uses results  in any number of ways. For example, host program  may present results  to a user of computing device  via a user interface. Alternatively, host program  may utilize results  in computing a total, sum, or other mathematical value. In any event, host program  receives and utilizes results .","Of particular importance to many users of mobile computing devices, which computing device  is assumed to represent for purposes of illustration, is the duration during which the mobile device may be used before the battery powering the mobile device requires recharging. This so-called \u201cbattery life\u201d is generally inversely proportional to the complexity of the operations performed by control unit . To illustrate, a complex operation may involve executing a large number of instructions to complete the operation, where execution of each instruction may consume some amount of power, thereby decreasing battery life. Developers of mobile devices, such as computing device , are increasingly attempting to lengthen battery life despite the increasingly more complex operations that users of mobile devices expect their mobile devices to perform. These mobile device developers are increasingly optimizing mobile devices to reduce battery consumption by way of employing low voltage processing units, low voltage memories and other hardware advances to accommodate reduced power consumption.","In terms of software, however, many software developers are more concerned with functionality and convenience rather than the power efficiency of their programs. JIT compilation is one such example where software developers prefer convenience over power efficiency considering that JIT compilation allows developers to accommodate many different types of mobile device hardware profiles but involves significant power consumption to compile kernels  in near-real-time or real-time. One aspect of JIT compilation that consumes significant amount of power is the linking of one or more of libraries  into destination file  and the subsequent optimization. Typically, memory copies consume significant amounts of power. In the context of linking one or more of libraries , conventional linkers link or copy in their entirety one or more of libraries , even though kernels  may only invoke one or more of the potentially hundreds or thousands of functions specified in each of these one or more linked libraries , where each of libraries  may be generally referred to as a source file in this disclosure, considering that these are a source of functions accessible by user-defined code. This sparse utilization of library functions by kernels  results in a copying or linking of a large number of unused functions, which consumes significant amounts of battery power in the form of the library copy.","Copying these one or more libraries  in their entirety also impacts the resulting size of destination file . Developers of compilers, however, have addressed this size issue by providing for post-link optimization. The above noted optimizer of compiler  may optimize the code stored to destination file  by performing a form of dead code elimination, which eliminates those library functions and other user-defined functions that are copied into destination file  but that are not invoked or otherwise referenced by the active or executable portions of the code stored to destination file . That is, the optimizer implements dead code elimination to identify those functions that are not invoked or reachable by the active portions of the code stored to destination file  and then deletes the identified functions from destination file .","This process of linking libraries  in their entirety and subsequent optimization through dead code elimination was first introduced in the context of desktop computing where power was less of a concern and then carried over to the mobile computing context without much thought of the resulting power inefficiencies due to the limited amount of JIT compilation or any compilation in the mobile device context. Yet, the rise of programming frameworks, such as OpenCL, that frequently employ JIT compilation to compile kernels , the process of linking libraries  in their entirety and subsequent dead code elimination, has resulted in an increasing consumption of power that is negatively impacting battery life.","In accordance with the techniques described in this disclosure, compiler  performs a form of inline dead code elimination during linking, that may greatly reduce memory copies, by linking only those functions that are reachable into destination file . By reducing the number of memory copies, the techniques may significantly reduce the power consumed when performing linking during JIT compilation. Again, compilation in this disclosure may be used to refer to translating (or compilation), linking, and optimization, although these may be technically considered as separate operations. Moreover, subsequent post-link dead code elimination may be performed more efficiently in that it may only need to evaluate those functions that are included in destination file  after the inline form of dead code elimination performed by the linker, in accordance with the techniques described in this disclosure. In this way, the techniques may avoid costly (in terms of power consumption) memory copies of sparsely utilized libraries  and facilitate the application of post-link dead code elimination. While the techniques may eliminate post-link dead code elimination in some instances, compiler  may still perform post-link dead code elimination as the techniques s may only be applied to the linkage of functions from libraries , whereas post-link dead code elimination evaluates both user-defined functions and library functions.","To illustrate, compiler  may receive one of kernels  and translate the high-level code that defines this one of kernels  into lower-level object code. Compiler  then invokes a linker software module (which is not shown in the example of  for ease of illustration purposes) that has been adapted or otherwise configured to perform the techniques described in this disclosure. This linker receives this lower-level object code and copies the lower-level object code generated from translating kernel  to destination file . It is assumed that this lower-level object code represents user-defined code having a reference to at least one of the functions of one of libraries .","After copying the lower-level object code generated through translation of one of kernels  to destination file , the linker evaluates destination file  to determine whether the at least one of the functions of one of libraries  referenced in the lower-level object code is reachable or, in other words, may be executed during subsequent execution of the destination file. In some instances, the linker may encounter function pointers that are capable of referencing or otherwise pointing to one of many functions stored to a table or other data structure. The linker may evaluate this function pointer and determine that all of the functions stored to the table may be executed during subsequent execution of the destination file. In any event, based on the determination that the one of the functions of one of libraries  defined in the user-defined code will be executed, the linker selectively copies the one of the functions of the corresponding one of libraries  to destination file  prior to the execution of this destination file, without copying any other of the functions of this one of libraries  that were not referenced by the lower-level object code.","The linker then repeats this process with respect to updated destination file , which has been updated in the sense that the linker copied the determined one of the functions of the one of libraries  to destination file . That is, the linker once again evaluates destination file  to determine whether the object code stored to destination file  references at least one of the functions of one of libraries  that has not yet been linked into destination file . Upon determining that the object code of destination file  references at least one of the functions of one of libraries  that has not been linked into destination file , the linker then determines whether this one of the functions of one of libraries  will be executed during subsequent execution of the destination file. If the linker determines this function is not reachable, the linker determines that it need not link in this one of the functions of the one of libraries . However, if the linker determines that this function is reachable, the linker links this additional one of functions of the one of libraries  into destination file . The linker of compiler  continues in this manner until the linker evaluates destination file  and determines that there are no additional functions of libraries  that need be linked into destination file  that have not already been linked into destination file .","The linker outputs this destination file to the optimizer of compiler , which may proceed to perform post-link dead code elimination, in addition to other post-link optimizations. This post-link dead code elimination, as noted above, removes so-called \u201cdead code\u201d or code that will not be executed during subsequent execution of destination file . The optimizer performs this dead code elimination with respect to both the user-defined code and the linked in library functions and removes any code that is not reachable. This post-link form of dead code elimination can be differentiated from the inline form of dead code elimination performed by the linker in accordance with the techniques described herein in two ways. First, the post-link form of dead code elimination may evaluate both the user defined object code and the linked library functions to eliminate dead code, while the inline form of dead code elimination only evaluates library functions to eliminate extraneous linking of library functions that are not referenced by the user-defined object code. Second, the post-link form of dead code elimination occurs after linking while the inline form of dead code elimination occurs during linking of the object code into destination file .","After completing the post-link form of dead code elimination and any other code optimization procedures, the optimizer of compiler  outputs destination file  to runtime module . As noted above, runtime module  forwards destination file  to one of compute devices A, which proceeds to execute destination file  or a derivative thereof and return results . Runtime module  receives these results  and forwards them to host program , which continues to execute in view of results  in the manner described above.","In this way, computing device  performs a form of inline dead code elimination during object code linking in accordance with the techniques described in this disclosure. As noted above, these techniques may greatly reduce memory copies by linking only those functions that are reachable into destination file . By reducing the number of memory copies, the techniques may significantly reduce the power consumed when performing linking during JIT compilation. Moreover, the techniques may facilitate subsequent post-link dead code elimination in that the this post-link dead code elimination may only need to evaluate those functions that are included in destination file , which may have been greatly reduced in number due to application of the inline form of dead code elimination performed in accordance with the techniques described in this disclosure. As a result, the techniques may avoid costly (in terms of power consumption) memory copies of sparsely utilized libraries  and facilitate the application of post-link dead code elimination.","While described in this disclosure with respect to OpenCL, the techniques may be performed with respect to any other type of programming frameworks that allows for real-time, near real-time or just-in-time (JIT) compilation of kernels, functions, or code generally. Examples of these other types of programming frameworks includes program frameworks referred to as \u201ccompute unified device architecture\u201d or \u201cCUDA\u201d and \u201cDirectCompute.\u201d Moreover, while these example programming frameworks provide for execution of applications across different types of compute units, the techniques may be implemented with respect to programming frameworks that do not permit such cross-compute unit execution. Moreover, the techniques described in this disclosure may be applied to compilers of any type, not just those that provide for real-time, near real-time or JIT compilation so as to improve compile times by reducing the amount of data linked into the destination data.",{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 2","FIG. 1","FIG. 2"],"b":["28","28","40","42","44","40","24","40","46","42"]},"Linker  includes a function identification module  and a function link module . Function identification module  represents a module that performs the above noted evaluation of user-defined object code  to determine whether the user-defined object code  includes a reference to the at least one function defined within one of libraries . Function link module  represents a module that links functions identified by function identification module  into destination file . In response to receiving user-defined object code , linker  invokes function identification module , which proceeds to evaluate user-defined object code  to determine whether this object code includes a reference to at least one function defined within one of libraries . It is assumed for purposes of illustration that user-defined object code  includes a reference to at least one function defined within one of libraries .","Typically, function identification module  performs this evaluation of user-defined object code  by first identifying all symbols in this code  and then searching for the definition of these symbols first in object code  and then in those of libraries  that have been identified by function identification module  as being referenced or incorporated by object code . The term symbol in this context refers to a combination of characters that identify a variable, function, pointer or other type of object. When defining kernels , the software developer typically indicates those of libraries  that are incorporated into each of kernels . Linker  analyzes object code  to determine the one or more of libraries  that have been incorporated into object code . After failing to find a definition of any unresolved symbol in object code , function identification module  determines that the unresolved symbol is defined within one of the identified set of libraries .","In some instances, two or more libraries may be linked by user-defined object code . In these instances, linker  may determine which of the linked libraries is largest and most sparsely utilized. Linker  determine a size of each these two or more linked libraries and link the one of these two or more libraries having the largest size (in terms of bytes) last under the assumption that the largest one of the two or more libraries is more than likely sparsely utilized by user-defined object code . Alternatively, linker  may perform a more thorough analysis with respect to the utilization of the two or more libraries and determine a percent utilization for each of the two or more libraries, selecting to link the one of the two or more libraries with the lowest determined percent utilization. Those of the two or more libraries determined to be less sparsely utilized may be linked in their entirety, while linker  implements the in-line DCE techniques described in this disclosure to link the one of the two or more libraries determined to be most sparsely utilized. This aspect of the techniques may be employed when linking of user-defined libraries is not allowed, such as in version 1.1 and below of OpenCL, where linker  may appropriately determine what may be referred to as a \u201cfinal link\u201d (which refers to the one of the libraries that is linked last).","In response to determining that this unresolved symbol is defined within one of the identified set of libraries , function identification module  then determines whether this unresolved symbol refers to a library function that will be reached or executed during subsequent execution of the destination file or a derivative thereof. In some instances, depending on certain branch and other characteristics of the data and state of execution of host program , function identification module  may be able to determine that one branch or conditional instruction will result in a function that cannot be reached (or, in other words, a function that will be skipped during subsequent execution). In some instances, function identification module  may encounter a function pointer that points to a table of functions, where function identification module  cannot determine whether any one of the functions stored to the table will in fact be reached given the dynamic nature of function pointers. Function identification module  may, in this function pointer instance, indicate that all of the functions stored to the table of functions can be reached. Generally, function identification module  indicates that a function can be reached during subsequent execution if there is any chance that this function might be reached. In this respect, function identification module  is inclusive and only excludes functions for which it can positively determine that there is no chance the identified function will be executed. Function identification module  stores the symbol for each of the functions that it identified as unresolved and reachable to reachable function list or table . After storing the symbols representative of these unresolved and reachable functions to unresolved reachable function list , linker  invokes function link module .","Once invoked, function link module  accesses unresolved reachable function list  and parses the symbols from this list . Function link module  also receives from function identification module  data identifying those of libraries  that were incorporated into kernel . Function link module  then reads only the declaration of functions included within each of these incorporated set of libraries  without reading this set of libraries  in their entirety. Function link module  attempts to resolve the unresolved symbol by determining whether the symbol is defined within these function declarations. Assuming that each of the functions stored to list  are properly defined within the function declarations of the incorporated set of libraries  (otherwise, linking fails and an error is returned), function link module  resolves each of these symbols and locates, based on the appropriate one of the function declarations associated with the incorporate set of libraries , each of the referenced functions in their respective one of libraries . Function link module  then copies this functions into destination file .","After linking in these functions to destination file , linker  then performs another iteration of these techniques described above with respect to this updated destination file . That is, linker  invokes function identification module  to once again identify those symbols that correspond to a function and that are unresolved and reachable and store these symbols to unresolved reachable function list . Linker  also invokes function link module  to once again link in any of the functions associated with the symbols stored to unresolved reachable function list . This process continues until function identification module  analyzes updated destination file  in its entirety and does not identify any symbol that has not been resolved. In response to this empty unresolved reachable function list , linker  outputs destination file  to post-link optimization module .","Post-link optimization module  receives destination file  and invokes dead code elimination (DCE) module  (\u201cDCE module \u201d), which performs dead code elimination with respect to destination file  in the manner described above. This post-link dead code elimination performed by DCE module  may be necessary to remove any unused or unreachable user-defined object code. To illustrate, software developers commonly provide a set of debug or other functions or software instructions used to test or otherwise debug their user-defined code. These functions or software instructions are commonly enabled when a specific constant global variable is set to a particular value but disabled when this global variable is set to a different value. DCE module  may remove these debug functions or software instructions from the user defined object code when the constant global variable is set to the value that disables these debug software functions or instructions, as these debug software functions or instructions would be considered as unreachable. The inline form of dead code elimination described in this disclosure may not remove these functions but only those library functions determined to be unreachable. Post-link optimization module  may perform other optimizations, including integrity or other checks to ensure proper memory management, proper code definitions and the like, as well as optimization that improve the subsequent execution of destination file  or a derivative thereof. Once optimization is complete, post-link optimization module  outputs destination file  to runtime module , which coordinates the execution of this destination file  or the derivative thereof, as described above.",{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 3","FIG. 1","FIG. 1","FIG. 1"],"b":["10","14","12","22","60","12","22","14","22","14","22"]},"In any event, control unit  may, when executing host program , encounter un-compiled code, which in this example is referred to as kernels  (). Until these so-called kernels  are encountered (\u201cNO\u201d ), control unit  continues to execute host program  (). Upon encountering kernels  or other types of un-compiled code (\u201cYES\u201d ), host program  invokes runtime module . Once invoked, host program  may forward kernel  to runtime module , which manages the near-real-time, real-time or runtime compilation of kernel . Runtime module , upon receiving kernel , invokes compiler  and forwards kernel  to compiler  so that compiler  can compile kernel  to generate destination file .","Although described as involving runtime module , the techniques may be implemented in such a manner that runtime module  is not required or bypassed. In these instances, host program  may invoke compiler  directly and then forward kernels  to compiler  without involving runtime module . The techniques should not therefore be limited in this respect to require or otherwise utilize a runtime module, such as runtime module .","Compiler  receives kernel . In particular, referring to , translator  receives kernel  and translates kernel  to intermediate representation (IR) code  in the manner described above (). Translator  forwards IR code  to linker . Linker  receives IR code  and links or, in other words, copies IR code  into destination file  (). Linker  then invokes function identification module  after linking IR code  into destination file . Function identification module  examines IR code , as linked into destination file , to determine those library functions reachable during execution of the corresponding compiled code, as described above ().","This evaluation may involve analyzing symbols (which generally represent function invocations and variables) included within IR code  and attempting first to resolve the symbols internally within the IR code or without reference to any other file, such as libraries . Often, a programmer or software developer will define their own functions and include these functions in kernel , such that a reference to this function or symbol can be resolved internally in that the function definition that corresponds to the referenced function can be located within the same file or group of files (i.e., kernel  in this example) as that in which references this function. If these symbols cannot be resolved internally to destination file , function identification module  next determines whether these functions are reachable.","In some instances, some functions referenced by kernel  may not be reachable or otherwise required for proper execution of the corresponding compiled code, such as functions relied on for debugging or other purposes unrelated to consumer execution of host program  or other functions that are not called or executed by host program . Function identification module  eliminates these so-called \u201cunreachable\u201d functions from further evaluation. Function identification module  next determines a set of one or more of libraries  that have been identified by kernel  as required to compile kernel . Function identification module  then retrieves only enough information from each of these identified ones of libraries  to determine whether these ones of libraries  include the unresolved, but reachable, symbols (which may represent an invocation of a reachable function of one of these libraries). Upon identifying one of the set of the incorporated ones of libraries  that includes this function, function identification module  stores the location of this function to unresolved reachable function list  (which is specified by the information retrieved from the ones of libraries ) along with the symbol or function and the location of this unresolved symbol in destination file . In this way, function identification module  generates unresolved reachable function list  based on the examination of destination file  ().","After all of the internally unresolved symbols have been resolved with respect to the identified set of one or more of libraries  and the above noted information is stored for each of these unresolved, but reachable, symbols to unresolved reachable function list , linker  invokes function link module . Function link module  retrieves unresolved reachable function list  and determines if list  is empty or otherwise does not specify any unresolved but reachable external functions (). If function link module  determines that unresolved reachable function list  is not empty, function link module  links (which is another way to refer to copying) those functions from library  identified by unresolved reachable function list  into destination file  in the manner described above (). If function link module  determines that unresolved reachable function list  is empty (\u201cYES\u201d ), function link module  returns control to linker , which in turn invokes post-link optimization module .","Post-link optimization module  may further optimize destination file  for subsequent execution (). In some instances, post-link optimization module  invokes DCE module , which performs conventional dead code elimination. Post-link optimization module  then outputs a post-link destination file . In some instances, this destination file  is output to runtime module , which coordinates further runtime or near-runtime processing, such as additional compilation to generate a derivative destination file or an executable file. Runtime module  may forward destination file  or a derivative thereof to one of compute devices , where the one of compute devices  selected to execute this destination file  or a derivative thereof may be specified by the user prior to runtime or otherwise determined during runtime. In any event, this one of compute devices  executes destination file  or the derivative thereof (). This one of compute devices  then returns result  to host program  via runtime module , as described above (). Host program  may continue to execute in this manner until a user ends or otherwise stops execution of host program  or host program  terminates (-).  is a block diagram illustrating another computing device  that may implement the techniques described in this disclosure. In the example of , computing device  represents a mobile device, such as any combination of a cellular phone (including so-called \u201csmart phones\u201d), a laptop computer, and a so-called \u201cnetbook,\u201d or a personal digital assistant (PDA), a geographical positioning system (GPS) unit, an embedded system, a portable media systems, or any other type of computing device that typically implement or support OpenCL in accordance with the OpenCL specification.","In the example of , computing device  includes a central processing unit (CPU) , a graphics processing unit (GPU) , a storage unit , a display unit , a display buffer unit , and a user interface unit . In one example, control unit  shown in the example of  may comprise units -. Although CPU  and GPU  are illustrated as separate units in the example of , CPU  and GPU  may be integrated into a single unit, such as in the case when the GPU is integrated into the CPU. Each of CPU  and GPU  may represent one or more processors that are capable of executing machine or low-level (LL) instructions. GPU  represents one or more dedicated processors for performing graphical operations. In some instances, GPU  may provide three levels of parallelism. GPU  may provide a first level of parallelism in the form of parallel processing of four color channels. GPU  may provide a second level of parallelism in the form of hardware thread interleaving to process pixels and a second level of parallelism in the form of dynamic software thread interleaving.","Storage unit  may comprise one or more computer-readable storage media. Examples of storage unit  include, but are not limited to, non-transitory computer-readable media, such as a random access memory (RAM), a read only memory (ROM), an electrically erasable programmable read-only memory (EEPROM), CD-ROM or other optical disk storage, magnetic disk storage, or other magnetic storage devices, flash memory, or any other medium that can be used to store desired program code in the form of instructions or data structures and that can be accessed by a computer or a processor. In some example implementations, storage device  may include instructions that cause CPU  and\/or GPU  to perform the techniques set forth in this disclosure. Storage unit  may, in some examples, be considered as a non-transitory storage medium. The term \u201cnon-transitory\u201d may indicate that the storage medium is not embodied in a carrier wave or a propagated signal. However, the term \u201cnon-transitory\u201d should not be interpreted to mean that storage unit  is non-movable. As one example, storage unit  may be removed from computing device , and moved to another device. As another example, a storage unit, substantially similar to storage unit , may be inserted into computing device . In certain examples, a non-transitory storage medium may store data that can, over time, change (e.g., in RAM).","Display unit  represents a unit capable of displaying video data, images, text or any other type of data for consumption by a viewer. Display unit  may include a liquid-crystal display (LCD), a light emitting diode (LED) display, an organic LED (OLED), an active-matrix OLED (AMOLED) display, or the like. Display buffer unit  represents a memory or storage device dedicated to storing data for display unit . User interface unit  represents a unit with which a user may interact with or otherwise interface to communicate with other units of computing device , such as CPU . Examples of user interface unit  include, but are not limited to, a trackball, a mouse, a keyboard, and other types of input devices. User interface unit  may also be a touch screen and may be incorporated as a part of display unit .","Computing device  may include additional modules or units not shown in  for purposes of clarity. For example, computing device  may include a speaker and a microphone, neither of which are shown in , to effectuate telephonic communications in examples where computing device  is a mobile wireless telephone, or a speaker where computing device  is a media player. In some instances, user interface unit  and display unit  may be external to computing device  in examples where computing device  is a desktop computer or other device that is equipped to interface with an external user interface or display.","As illustrated in the example of , storage unit  stores host program , runtime module , compiler  and GPU driver . Host program  may be substantially similar to host program  described above by way of example with respect to . Runtime module  may be substantially similar to runtime module  described above by way of example with respect to . Compiler  may be substantially similar to compiler  described above by way of example with respect to . GPU driver  represents an instructions that, when executed, cause CPU  to provide an interface by which to communicate with GPU . GPU driver  includes a GPU compiler  that enables runtime compilation of IR into a machine or other low level (LL) programming language supported by GPU .","CPU  may execute host program  (where such execution is generally shown in  as a dash-lined box that corresponds to those shown within storage unit ) in the manner described above. Upon encountering the so-called \u201ckernels\u201d or embedded un-compiled code, host program  causes CPU  to execute, invoke or otherwise transfer control of execution to runtime module . Runtime module  then facilitates the compilation of this kernel by passing this kernel to compiler , which implements the techniques described in this disclosure to generate a destination file similar to destination file  described above. Compiler  passes this destination file back to runtime module , which either causes CPU  to execute this destination file or otherwise causes this destination file to undergo additional compilation.","In this example, it is assumed that the returned destination file is not an executable file but requires additional compilation. Runtime module  may determine whether any given destination file requires additional compilation depending on whether destination file is to be executed by GPU  or CPU . As noted above, compute devices  may each represent either a GPU or a CPU, to name one of many potential types of compute devices. In this example, each of CPU  or GPU  is abstracted as a different compute device. Runtime module  may determine, for each compute device, whether additional compilation of destination file is required prior to execution of the destination file by each of these compute devices.","In this instance, it is assumed that runtime module  determines that the returned destination file is to be executed by a compute device representing GPU  and that this compute device requires additional compilation. Runtime module  may be configured or, in some instances, may dynamically determine that, prior to execution of the destination file by the compute device representing GPU , the destination file requires further compilation by GPU compiler . Runtime module  may pass the destination file to GPU driver , which invokes GPU compiler  to further compile this destination file into runtime compiled code . GPU compiler  may store this runtime compiled code  to storage unit  until GPU  is available to execute runtime compiled code . At some point, GPU  executes runtime compiled code , generating a result, which is passed back to runtime module . Runtime module  may return the result to host program , which may utilize the result in further computations, calculations or operations. Computing device  may continue to execute in this manner until host program  has finished executing or terminated by a user or other event.","In some implementations, runtime module  may be provided as a separate driver, such as an OpenCL driver. This OpenCL driver may include a CPU driver comprising compiler . This OpenCL driver may also include GPU driver , which, as shown in the example of , includes GPU compiler . In some instances, the CPU driver and GPU driver  are integrated into a single CPU\/GPU driver, where compiler  and GPU compiler  may also be integrated into a single compiler. Moreover, while described above with respect to this OpenCL framework, the techniques may be implemented with respect to any type of compiler, including those executing on desktop computers or other non-mobile devices. Outside of the OpenCL framework, a runtime component is typically not provided when users initiate compilation themselves. The techniques therefore should not be limited in this respect to the example of .","In one or more examples, the functions described may be implemented in hardware, software, firmware, or any combination thereof. If implemented in software, the functions may be stored on or transmitted over as one or more instructions or code on a computer-readable medium. Computer-readable media may include computer data storage media or communication media including any medium that facilitates transfer of a computer program from one place to another. Data storage media may be any available media that can be accessed by one or more computers or one or more processors to retrieve instructions, code and\/or data structures for implementation of the techniques described in this disclosure. By way of example, and not limitation, such computer-readable media can comprise RAM, ROM, EEPROM, CD-ROM or other optical disk storage, magnetic disk storage, or other magnetic storage devices, flash memory, or any other medium that can be used to carry or store desired program code in the form of instructions or data structures and that can be accessed by a computer. Also, any connection is properly termed a computer-readable medium. For example, if the software is transmitted from a website, server, or other remote source using a coaxial cable, fiber optic cable, twisted pair, digital subscriber line (DSL), or wireless technologies such as infrared, radio, and microwave, then the coaxial cable, fiber optic cable, twisted pair, DSL, or wireless technologies such as infrared, radio, and microwave are included in the definition of medium. Disk and disc, as used herein, includes compact disc (CD), laser disc, optical disc, digital versatile disc (DVD), floppy disk and Blu-ray disc where disks usually reproduce data magnetically, while discs reproduce data optically with lasers. Combinations of the above should also be included within the scope of computer-readable media.","The code may be executed by one or more processors, such as one or more digital signal processors (DSPs), general purpose microprocessors, application specific integrated circuits (ASICs), field programmable logic arrays (FPGAs), or other equivalent integrated or discrete logic circuitry. Accordingly, the term \u201cprocessor,\u201d as used herein may refer to any of the foregoing structure or any other structure suitable for implementation of the techniques described herein. In addition, in some aspects, the functionality described herein may be provided within dedicated hardware and\/or software modules configured for encoding and decoding, or incorporated in a combined codec. Also, the techniques could be fully implemented in one or more circuits or logic elements.","The techniques of this disclosure may be implemented in a wide variety of devices or apparatuses, including a wireless handset, an integrated circuit (IC) or a set of ICs (e.g., a chip set). Various components, modules, or units are described in this disclosure to emphasize functional aspects of devices configured to perform the disclosed techniques, but do not necessarily require realization by different hardware units. Rather, as described above, various units may be combined in a codec hardware unit or provided by a collection of inter-operative hardware units, including one or more processors as described above, in conjunction with suitable software and\/or firmware.","Various examples have been described. These and other examples are within the scope of the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
