---
title: Apparatus, method, and system to allocate redundant components with subsets of the redundant components
abstract: In general, various methods, apparatuses, and systems are described in which logic executes, in series, a plurality of repair algorithms to generate a repair signature for a memory. The memory has a full set of redundant components associated with the memory. At least one or more of the repair algorithms employ a subset of redundant components that contains less than all of the redundant components in the full set when attempting to generate the repair signature.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07149921&OS=07149921&RS=07149921
owner: Virage Logic Corporation
number: 07149921
owner_city: Fremont
owner_country: US
publication_date: 20020906
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DISCUSSION"],"p":["This application is a continuation in part of U.S. patent application Ser. No. 09\/962,761, filed on Sep. 24, 2001, and also claims the filing date of provisional U.S. Patent Application Ser. No. 60\/301,901, filed on Jun. 29, 2001.","The present invention relates generally to integrated circuits consisting of stand-alone memory devices or embedded memories, and more specifically to a memory having a column and\/or row redundancy scheme.","Random defects occurring during the manufacturing of an integrated circuit with embedded memory blocks can render certain non-redundant elements of an integrated circuit memory device, such as a memory column, defective. For example, particle contamination during the manufacturing process may cause broken or shorted out columns and bit defects.","Redundant elements in an integrated circuit memory device, such as redundant columns, are used to compensate for these random defects. Initial testing of an integrated circuit memory occurs after the manufacturing process. During initial testing of an integrated circuit memory device, defective elements are replaced by non-defective elements referred to as redundant elements. Thus, redundant columns may be used in a scheme to replace defective non-redundant columns, discovered during initial testing of the integrated circuit memory device. The use of redundant elements is important in increasing the overall yield of an integrated circuit memory device.","Repair algorithms allocate these redundant elements to substitute for known defective elements. A more complicated repair algorithm usually has a higher success rate in repairing a given memory but also takes up more space on a chip.","An example of such a complete repair algorithm starts the repair analysis with the full set of redundant elements associated with that memory. The repair analysis also runs various sequences of the potential repair algorithms in parallel.","However, a disadvantage to logic that runs the various repair algorithms in parallel is the physical space required on the chip for each engine running one of the algorithms. Each repair algorithm run in parallel uses a separate logic engine. Each logic engine takes up space on the chip that could be used for extra memory capacity or processing power on that chip.","Another disadvantage is when starting a repair of a memory with full set of redundant components, the resultant repair signature may not be the most efficient repair with the redundant components available. When later defects occur in other memory bank that share the same redundant components or defects occur in that memory during field operations, then the redundant components may not be available to fix the memory faults.",{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},"For example, in the RRCC sequence, the first defective memory cell address is repaired by allocating a redundant row to repair the defect. The second defective memory cell address is also repaired by allocating a redundant row to repair the defect. The third defective memory cell address is repaired by allocating a redundant column to repair the defect. The fourth defective memory cell address is also repaired by allocating a redundant column to repair the defect.","Multiple repair sequences can repair the memory such as CCRR and CRRC.  illustrates graphically how the two repair sequences would repair the memory. However, the CRRC is more efficient because this repair sequence only needs to allocate one redundant row and two redundant columns to completely repair the memory. Thus, one redundant row remains not allocated. Nonetheless, when all the repair sequences are run in parallel, then no guarantee exists that the eventual repair signature will be based upon the CRRC repair sequence.","In general, a method, apparatus, and system in which logic executes, in series, a plurality of repair algorithms to generate a repair signature for the memory. The memory has a full set of redundant components associated with the memory. At least one or more of the repair algorithms employ a subset of redundant components that contains less than all of the redundant components in the full set when attempting to generate the repair signature.","While the invention is subject to various modifications and alternative forms, specific embodiments thereof have been shown by way of example in the drawings and will herein be described in detail. The invention should be understood to not be limited to the particular forms disclosed, but on the contrary, the intention is to cover all modifications, equivalents, and alternatives falling within the spirit and scope of the invention.","In the following description, numerous specific details are set forth, such as examples of specific data signals, named components, connections, types of repair algorithms, etc., in order to provide a thorough understanding of the present invention. It will be apparent, however, to one skilled in the art that the present invention may be practiced without these specific details. In other instances, well known components or methods have not been described in detail but rather in a block diagram in order to avoid unnecessarily obscuring the present invention. Thus, the specific details set forth are merely exemplary. The specific details may be varied from and still be contemplated to be within the spirit and scope of the present invention.","In general, various methods, apparatuses, and systems are described in which logic executes, in series, a plurality of repair algorithms to generate a repair signature for a memory. The memory has a full set of redundant components associated with the memory. At least one or more of the repair algorithms employ a subset of redundant components that contains less than all of the redundant components in the full set when attempting to generate the repair signature. In an embodiment, the execution of the plurality of repair algorithms is ordered from the most efficient repair algorithm in preserving redundant component repair capacity to least efficient in preserving redundant component repair capacity. In an embodiment, a processor contains the logic to execute the plurality of repair algorithms, as well as additional logic to test each memory for defects and to allocate redundant components to substitute for non-redundant components associated with the defects.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 2","b":["202","204","206","208","210","212","214","216","218","204","206","204","208","210"]},"The processor  enables a complete embedded memory self-test and repair function to be included on-chip . The processor  increases the yield of useable memories  by repairing defective memory components at a very high rate. In an embodiment, the processor  contains multiple engines to determine how much redundancy is needed and how to partition the redundant components throughout each unique memory array. The processor  understands the redundancy scheme, the failure history of the process being used, and how the unit has failed.","The processor  on the chip  that automatically tests the memory  allocates redundancy resources and coordinates or performs any necessary repairs. In an embodiment, the processor  tests the memory instances  at speed; that is, at the speed they will run in the application. After testing and repair of the memory instances , the processor  turns the memory operation over to the normal address, data and control busses on the SoC.","The repair data signature created by the processor  is sent to an external tester (not shown) via the one or more external interfaces . In an embodiment, the processor  communicates the repair data signature during wafer probe. In an embodiment, the laser repair equipment (not shown) programs the fuse box  with the necessary repair information. The fuse box  retains the permanent memory repair signature unique to that individual SoC . The signature can be executed either at wafer sort or at system power-on. In an embodiment, the processor  determines and stores the repair data signature in order to eliminate the need for a fuse box . In an embodiment, the processor  after system power-on transfers the corresponding repair data signature directly into the scan flip-flops contained within each unique memory instance  in the SoC .","In an embodiment, the processor  may perform all the appropriate testing and repair coordination of the memory instances  in order to increase yield, eliminate expensive external memory testers, and allow test and repair functions to occur in the field rather than at the factory. In an embodiment, the only factory testing required is to test the logic portion of the SoC  and, if applicable, coordinate the fuse box  programming. Thus, testing and repair of the memory instances  may occur in the field. In an embodiment, the processor  reduces the previous techniques of having four external test stages (memory test, laser repair, memory re-test, logic test) to one external test stage (logic test). In an embodiment, if a hard repair is used then there may be three external test stages, i.e. memory test, laser repair, and memory retest.","The system supports both factory and field repair methods. Factory repair takes place during wafer probe in the factory, using the laser programmed fuse box . Field repair uses a test and repair function residing in the processor  to make repairs after product deployment.","The factory repair has the advantage of performing test and repair at the wafer level. The wafer  can be subjected to a variety of stringent conditions during testing that helps insure high memory instance  and SoC  reliability during extended voltage, temperature and frequency conditions.","The field repair operation tests and repairs memory instances  each time the end product powers up or is reset. The processor  initiates and operates the test program, determines defective memory locations (if any), allocates redundancy resources, and produces a repair signature that resides in a location on the memory . This volatile repair signature is applied to the redundancy control logic and remains there as long as power is applied.","The field repair feature allows a new test every time the processor  is powered up or reset under control of the application's software but it is performed at ambient temperature and typically under non-stressful conditions.","The SoC  supports both repair functions: factory repair for manufacturing defects, and field repair for any subsequent problems that may materialize over the life of the end product.",{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 3","b":["302","304","306","308"]},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 4","b":["402","404","402","406","404"]},"Referring to , the processor can use the BISD engine  to find the defects and the BIRA engine  to repair the memory. The BIST engine  runs a test program to detect faults in the memory array. The BIRA engine  allocates the available redundant components to repair the memory and sends the repair information to the Reconfiguration Data engine . The Reconfiguration Data engine  translates redundancy allocation into a memory-specific repair signature that can be both sent to the external memory tester to be programmed into a fuse box or sent directly to scan chain registers in the memories themselves.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 5","b":["502","504","506","508","510","502","504","506","508","510","502","502","512","504","506","508","510","504","506","508","510","514","516","512","504","506","508","510","516","516","504","506","508","510","512"]},"In an embodiment, an extension of the processor is the Intelligent Wrapper (IW)  for example, at the first memory. The intelligent wrapper  associated with each memory instance , , ,  is used in conjunction with the processor  to perform test and repair of the memory as well as allow normal memory functioning in the system. The intelligent wrapper  contains functions such as address counters, registers, data comparators and multiplexors. The intelligent wrapper  is located close to the memory core to allow at-speed testing of these functions. Thus, the processor  in conjunction with its intelligent wrapper  increase useable memory yields due to the processor's ,  ability to detect nearly all defects, including performance defects that external memory testers commonly miss because they cannot run tests at chip speed. Further, the processor's ,  on-chip repair function allows in the factory repairs and in the field repairs. The external interface , such as the standard JTAG 1149.1 port, enables the one or more processors to communicate with the chip's other IP cores.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 6","b":["602","604","606","608","610","612","614","616","602","608","614","602","608","604","606","604","606","612"]},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 7","b":["700","700","700","704","706","708","710","700","704","706","704","708","710","700","700","712","714","716","718","700","712","704","714","706","716","704","706","720","704","704","716","720","704","722","706","718","704","706"]},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 8","b":["802","804"]},"In an embodiment, the plurality of registers may be as follows. Row register-Row_ , and row register Row_  record the faulty row addresses. Thus, each row register ,  may identify and store the address of a faulty row. In an embodiment, the amount of row registers equals the number of redundant rows. Status bit register-En  and status bit register-En  record the status of redundant row registers. These status bits indicate that the corresponding addresses recorded must be selected for repair if the memory is declared repairable after BIST. Thus, the status bit registers ,  indicate whether the corresponding redundant row is available or unavailable as a substitute row. In an embodiment, the BIST and BIRA operations are performed simultaneously.","Similarly, status bit register-CL (not shown) and status bit register-CH (not shown) record the status of redundant column registers. The status bit registers indicate whether the corresponding redundant column is available or unavailable as a substitute column. Column register Col_L  and column register Col_H  record the faulty column addresses located in the lower bank and upper bank, respectively. In an embodiment, the total amount of status bit registers equals the number of redundant rows plus the number of redundant columns.","Cross-reference row register-Row_L  and cross-reference row register Row_H  record the row addresses connected with the faults recorded in column registers Col_L  and Col_H . Each cross reference register allows an assigned redundant column, thus unavailable, to be released and reset to available status, if an assigned redundant row will also be substituting for the defective memory cell that the assigned redundant column was substituted for. In an embodiment, the BIRA engine  may couple to additional registers, such as sub input output registers which together with the column registers ,  specify the faulty column addresses of sub input output circuits associated with each memory array.","The BIRA engine  processes one or more built-in-redundancy-analysis algorithms to determine whether a memory is repairable. The BIRA engine  takes into consideration the process failure history, address mapping, and examines information about available redundancy, and the current fault data that is specific to each unique memory. The BIRA engine  combines this information and sends the information to the Reconfiguration Data engine to translate the redundancy allocation into a memory-specific repair signature.","In an embodiment, the organization and sequence of how the BIRA engine  assigns the redundant components determines whether a memory array will be repairable or not repairable, thereby, increasing or decreasing the yield of useable memories on the chip. The BIRA engine  may use many discrete algorithms, however, a one or more algorithms will be described and illustrated to demonstrate aspects of the invention.","A first Built-In-Redundancy-Analysis algorithm is based on the following main logic steps.","First, if at least two faulty cells are encountered in a word either in the lower bank or the upper bank of the memory array, then the row requires repair with a redundant row. If an available redundant row does not exist, then the memory array is considered unrepairable.","Second, if a single faulty cell is encountered in a word either in the lower bank or the upper bank of the memory array then a redundant column is used for repair, if available. If no spare column is available but a spare row is available, then a redundant row is used for repair. Otherwise, the memory array is considered unrepairable.","Third, the BIRA engine  works in parallel with the BIST logic providing the fault data. Thus, the BIRA engine  may possess three states of decision regarding the assignment of redundant components to substitute for defects in the memory detected by BIST logic. In an embodiment, the three states of decision are not set, tentatively set, and locked in. The starting state of decision for redundant rows and redundant columns is not set. Not set means that the component is available to be assigned to substitute for a defective component.","As noted in the first logic step, if at least two faulty cells are encountered in a word, then a redundant row is assigned to substitute for the defective component. In this case, the BIRA engine  locks in the state of decision for this redundant row to substitute for the defective row. Thus, this particular redundant row is now unavailable to be assigned to replace another defective component. Note, the redundant row globally replaces the entire row in both the lower bank and the upper bank irrespective of whether the two fault cells exist in the upper bank or in the lower bank or in both","As noted in the second logic step, if a single faulty cell is encountered in a word, then a redundant column is the first choice to substitute for the defective component. The BIRA engine  tentatively sets the state of decision for this redundant column to substitute for the defective component. Thus, this particular redundant column is currently unavailable to be assigned to replace another defective component; however, the status of this redundant column may be released back to available upon certain conditions. If a new fault is encountered requiring repair with a redundant row, (i.e. at least two faulty cells are encountered in a word) and a faulty row is connected with an assigned redundant column, i.e. the corresponding cross-referencing registers contain the same address as the faulty row, then the corresponding column register is reset together with the status bit register and cross referencing register. The released redundant column has become available for further repair purposes and the newly assigned redundant row satisfies the first logic step to have a locked in state of decision. If an available redundant row does not exist, then the memory array is considered unrepairable.","Fourth, the BIRA algorithm may use a marching algorithm, which sequentially examines the addresses of the memory array. The BIRA algorithm may make several passes to attempt to repair a memory. If at least one of the BIRA algorithms passes eliminates all of the defective components in the memory through redundant component substitution, then the state of decision for each redundant memory component is locked in. The memory is repaired. The BIRA engine  sends the repair information to the Reconfiguration Data generation engine.",{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 9","b":["902","904"]},"On the third pass , the BIRA algorithm alters the second logic step to choose to replace a single defective memory cell with a redundant row rather than a redundant column. The BIRA engine sets the state of decision for that assigned redundant row as tentatively set. On the fourth pass , the BIRA algorithm does both alter the second logic step to choose to replace a single defective memory cell with a redundant row rather than a redundant column and examines the memory array in the backward direction.",{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 10","b":["1002","1004","1006","1008","1010","1012","1014","1016"]},"The memory array  is split into two halves a lower bank  and an upper bank . Many word lines exist in each bank. For example, the top horizontal grouping of memory blocks is a word line, in the lower bank . Similarly, the top horizontal grouping of memory blocks in the upper bank  is an example of a word line. The row address spans from row address   through row address  . And the column address spans from address  through address . Note this is just an exemplary memory array  and how a first BIRA algorithm might be employed.","The BIST program sends data to the BIRA engine indicating the location of faulty memory cells, such as a first faulty memory cell  located in the first word line  contained within the lower bank . The first faulty memory cell  is located at row address   and also at column address . Located next to the first faulty cell , going horizontally, is a second faulty memory cell  constituting a second fault or defect with in the first word line . In an embodiment, when the BIRA algorithm encounters two faulty cells in a single word line, a first logical steps dictates that a redundant row will be substituted for the defective component.","A faulty memory cell could be an actual faulty defective bit cell within the memory, a defective multiplexor or sense amp going to that bit cell, a faulty input output circuit routing to that cell, some interconnection between those components going to that cell or some other condition to render the memory location inoperable. In an embodiment, a redundant component, such as either the redundant row or the redundant column, has the necessary components within the redundant component to substitute for any of those defects.","The exemplary use of the BIRA algorithm assumes that the memory array  has two redundant columns, a first redundant column and a second redundant column as shown in . The exemplary use of the BIRA algorithm also assumes that the memory has two redundant rows, a first redundant row and a second redundant row. Additionally assumed is that the memory array  has been split into an upper bank  and a lower bank . The specific amounts of components and the types of components are just examples to illustrate an embodiment of the invention. One or more of any of these components could exist. In an embodiment, the BIRA algorithm examines these variables as shown in .",{"@attributes":{"id":"p-0070","num":"0069"},"figref":["FIG. 11","FIG. 15"],"b":["0","1022","1","1012","0","1022","1","1016","1","1016","1032","2","1020","1","1012","1018"]},"Referring to , the BIRA algorithm continues marching in a forward direction on the first pass through the addresses of the memory array . The BIRA algorithm finishes its analysis of row address   and starts its analysis of row address- . The BIRA algorithm detects a fourth faulty cell in the upper bank  in the second word line. The BIRA algorithm determines that this is a single faulty cell contained in a word line and therefore follows the second logical step to replace the single faulty cell with a redundant column. The BIRA engine changes the contents in column register-Col_H  from a logical 0 to a logical 1 to indicate the column address of the defective component. The cross-reference register Row_H  changes it's content to reflect a 1 which is the row address connecting or cross referencing the defective row with the defective column.","Referring to ,  illustrates the first BIRA algorithm continuing its forward march on the first pass through the memory array . The BIRA algorithm detects a fifth faulty memory cell in the third word line contained in the lower bank . According to the second logical step, since the BIRA algorithm detects only a single error, the BIRA algorithm assigns a redundant column to substitute for the defective faulty component. Thus, the BIRA engine changes the contents in column register Col_L  to record a logical 1 in memory block corresponding with fifth column address to indicate that the second redundant column has been assigned to substitute for the fifth memory column in the fifth address slot. The BIRA engine changes the contents in cross reference register Row_L  to record row address  , in order to reflect the row address corresponding to the defect which caused the redundant row to be assigned to that defective column. The second redundant column replaces the defective column in fifth address slot, which is reflected by the contents in the column register Col_L  and cross reference register Row_L .","Referring to ,  illustrates the BIRA algorithm continuing a forward march through the memory array  on the first pass. The BIRA algorithm examines the fourth word line in both the lower bank  and in the upper bank . The BIRA algorithm detects a sixth memory fault in the lower bank  occurring in the fifth column address. The BIRA algorithm references the BIRA registers and detects that the second redundant column has been assigned to substitute for this defective memory cell already through contents of column register Col_L . The BIRA algorithm then continues its forward march through the memory array  and discovers a single defect in the seventh faulty memory cell located within the upper bank  occurring in column address . The BIRA algorithm references the BIRA registers and detects that the first redundant column has substituted for this defective component already. The BIRA algorithm references the column register Col_H  and detects that the contents reflect column address .","Referring to ,  illustrates the first BIRA algorithms continued march through the memory array  on the first pass. The BIRA algorithm examines defects in the fifth word line contained in the memory array . The BIRA algorithm detects a single fault occurring in the fifth word line contained in the lower bank . The eighth faulty memory cell is located in column address . The BIRA algorithm does not have any redundant columns left to replace this single fault with a redundant column, therefore according to the second logical step, the BIRA algorithm uses an available redundant row to replace this defective component.","Thus, the BIRA engine assigns the second redundant row to globally replace the bottom word line in the lower bank  and the bottom word line in the upper bank . The BIRA registers reflect this change. The BIRA engine changes the contents in row register Row  to reflect row address number  and stores the faulty row address in its contents. The BIRA engine changes the contents in status bit register En  to a logical 1 to indicate that the second redundant row is not longer available to substitute for the defective component. However, since a single fault was detected, then the state of decision for this redundant row is only tentatively set. The BIRA algorithm then proceeds to examine the memory addresses in the upper bank  and detects multiple faults, a ninth faulty memory cell existing in column address  and a tenth faulty memory cell existing in column address . The BIRA algorithm references the BIRA registers and detects that row register Row  assigns the second redundant row to replace row address  . Therefore, the BIRA algorithm determines that these errors are already covered by a redundant component.","The BIRA algorithm then goes to the fourth logical step, once the highest memory address is achieved and checks to see if all the faults in this memory array  were substituted by redundant components. In this example, the redundant components substitute for the defective components in order to replace every defect that occurred in this memory array . The BIRA algorithm then determines that this memory array  is repaired on the first pass. Therefore, the BIRA algorithm need not continue the BIRA algorithm with a second testing pattern such as a second pass, third pass, or fourth pass through this memory array .","Once the BIRA algorithm determines that one of passes or testing techniques, in this case the first pass, was successful, then the BIRA algorithm locks in the state of decision contained in the BIRA registers for each redundant component and sends the fault information onto the reconfiguration data engine. Thus, this example illustrates an embodiment of how the BIRA algorithm performs dynamic allocation and swapping of redundant components while still testing or detecting faults in the memory. The BIRA algorithm may optimize the final organization and allocation of assigning redundant components in order to replace defective components associated with the memory.",{"@attributes":{"id":"p-0078","num":"0077"},"figref":["FIG. 16","FIG. 25","FIG. 16"],"b":["1632","1618","6","1618","5","1618","1620","1","1620","2","1620"]},"Referring to , the BIRA algorithm starts with the first pass. The BIRA algorithm encounters a first memory defect in the lower bank  in the sixth column address. In a single fault failure the BIRA engine assigns a redundant column to replace the defective component and sets the state of decision as tentatively set. Column register Col_L  changes the contents of its register to a logical 1 in the sixth column address position to reflect that the first redundant column has been assigned to replace the column in the sixth column address. Cross reference register Row_L  changes the content in its register to read a logical 0 to indicate the first defective memory cell is also found in row address  .","Referring to , the BIRA algorithm continues a forward march through the memory addresses by proceeding to the second word line. The second word line in the lower bank  contains no defects. The BIRA algorithm does detect a defect in the second word line in the upper bank  contained in column address . Upon detecting a single fault failure the BIRA engine assigns a second redundant column to replace the defective component. Column register Col_H  changes the contents of its register to a logical 1 in the first column address position to reflect that the second redundant column has been assigned to replace column . Cross reference register Row_L  changes the contents in its register to reflect that the memory defect covered by the second redundant column also occurs in row address  .","Referring to , the BIRA algorithm continues its march through the first pass of the memory addresses of the memory array . The BIRA algorithm detects a fault in the third word line contained in the lower bank  occurring in column address . Upon detecting a single fault failure, the BIRA algorithm would assign a redundant column to substitute for the defective component. However, according to the second logical step, if no redundant columns are available, then the BIRA algorithm assigns a redundant row. Row register Row   reflects the assignment of the first redundant row by recording the row address   in its contents. Status bit register En  changes the contents in its register to a logical 1 to reflect that the first redundant row is no longer available to be assigned to substitute for a defective memory component.","Referring to , the BIRA algorithm continues its forward march using the first pass through the memory array  starting at the fourth word line in the lower bank . The BIRA algorithm detects a single fault failure in the fourth word line in the lower bank  occurring in column address . The BIRA algorithm having no redundant columns available assigns a redundant row to substitute for this defect. The BIRA registers reflect the assignment of the second redundant row by row register Row  changing the contents of its register to record row address  . Status bit register En  changes the contents in its register to a logical 1 to indicate that the second redundant row in no longer available to substitute for a defective component. The BIRA algorithm then proceeds to detect a defective memory cell in the upper bank  contained in row address  . The BIRA algorithm references the BIRA registers to detect that the row register Row  contains a row address   already, thereby, substituting the second redundant row covering that defective component.","Referring to , the BIRA algorithm continues the forward march using the first pass though the memory array . The BIRA algorithm detects a fault in the fifth word line in the upper bank  in the column address . Upon detecting a single fault, the BIRA algorithm attempts to use a second logical step to assign a redundant column, however in this case all of the redundant columns have already been assigned. The BIRA algorithm references the BIRA registers and both column registers indicate that the redundant columns have been assigned and their corresponding status bit registers for those columns (not shown) indicate that those redundant columns have been assigned. The BIRA algorithm then tries to proceed to the second part of the second logical step and assign a redundant row to fix this error. However, the BIRA algorithm references the BIRA registers and discovers that the status bit registers for both redundant rows indicate that neither of the redundant rows is available to be assigned to substitute for a defective component. Therefore the BIRA algorithm determines that it has no available redundant components to assign to substitute for the defect found in the fifth word line in the upper bank . The BIRA algorithm determines that the redundant component cannot be substituted and cover all the defects in the memory array . The BIRA algorithm then proceeds by resetting all the registers and starting a second pass to try to repair this memory array .",{"@attributes":{"id":"p-0084","num":"0083"},"figref":"FIG. 22","b":["1632","1632","1632","1632","1632"]},"As noted, the BIRA algorithm commences the second pass by starting at the highest memory address and proceeding to the lowest memory address. The BIRA algorithm commences its sequential march through the memory addresses in the upper bank  in the fifth word line. The BIRA algorithm detects a faulty memory cell in column address . The BIRA algorithm detects a single fault in the fifth word line and therefore, in accordance with the second logical step, assigns a redundant column to substitute for that defective component. The BIRA registers reflect the assignment of the first redundant column. Column register Col_H  changes the its content to correspond to column address  to indicate that a first redundant column has been assigned to substitute for the defective second column. Cross-reference register Row_H  changes the contents in its register to store the address of the corresponding row of this defective memory cell. Thus, cross-reference register Row_H  changes its contents to reflect column address .",{"@attributes":{"id":"p-0086","num":"0085"},"figref":"FIG. 22","b":["1632","1620","2","3","1628","1602","3","1628"]},"Referring to , the BIRA algorithm continues with its backwards march through the memory address in row address  . In the lower bank , the BIRA algorithm detects a fault memory cell in the lower bank  in column address . Upon detecting a single fault, the BIRA algorithm assigns a redundant column to replace the defective component. The BIRA registers reflect this assignment of the second redundant column. Column registers Col_L  changes the content in the register corresponding to the fifth column address location to a logical 1. This indicates that the second redundant column has been assigned to substitute for a fifth column contained within the lower bank . Additionally the cross-reference register Row_L  changes its contents to reflect the row address that cross references to this faulty memory cell that has been replaced by a redundant column. The cross-reference register changes its content to read row address  .","The BIRA algorithm continues with its backwards march through the addresses. In row address  , the BIRA algorithm detects no errors in the upper bank . However, the BIRA engine detects an error in row address   and column address  of the lower bank . The BIRA engine references the BIRA registers and detects that this defect occurs in the fifth column. Thus, the second redundant row already substitutes for this defective component. The BIRA algorithm then may proceed with its backwards march of the next row of addresses.","Referring to , the BIRA algorithm detects a defect in row address   in the first column contained within the upper bank . The BIRA algorithm according to the second logical step first tries to assign a redundant column to repair this single defect in a word, however, the BIRA engine determines that both the first redundant column and second redundant column are unavailable to be assigned as substitutes. Therefore, according to the second logical step, the BIRA engine assigns the first redundant row to substitute for the defective component containing this faulty memory cell. The BIRA registers reflect this assignment of this first redundant row. Accordingly, row register Row   changes the content of its register to a logical 1 to represent the row address of the component containing the defect that it is substituting. Status bit register En  changes the content of its registers to a logical 1 to indicate that the first redundant row is no longer available to be assigned as a substitute component.","The BIRA algorithm continues its backward march through the memory array  and detects no faults in the second word contained in the lower bank . Also, the BIRA algorithm detects no faults in the top word contained in the upper bank .","Referring to , the BIRA algorithm detects a fault in column address  and row address   of the lower bank . According to the second logical step, the BIRA algorithm checks and sees that there are no redundant columns available and thus assigns a redundant row to replace a this single defect that it discovered in the first word line in the lower bank . The BIRA registers reflect this assignment of the second redundant row. The row register Row  changes the content in its register to reflect the address of the defective component, in this case the defective row, row address  . The status bit register En  changes the content in its register to reflect logical 1 to indicate that the second redundant row is no longer available to be assigned as a substitute component.","The BIRA algorithm reaches the lowest address in the memory array  and proceeds to the fourth logical step. Upon proceeding to the fourth logical step, the BIRA algorithm determines that this memory is repaired because all the defects have been substituted for by redundant components. The BIRA algorithm then changes the state of decision for the redundant components to locked in and sends the repair information onto the reconfiguration data engine.",{"@attributes":{"id":"p-0093","num":"0092"},"figref":["FIG. 26","FIG. 30","FIG. 26"],"b":["2618","2620","0","2622","2","2626","3","2628","2620","1","2","2626","4","2630","2632","2632"]},"The third pass sequentially marches through the memory array  addresses from lowest to highest, however the second logical step is altered to replace the very first single memory fault encountered with a redundant row rather than with a redundant column. Thus,  illustrates the starting condition of the BIRA algorithm and the BIRA registers after being reset at the completion of the unsuccessful second pass. The BIRA registers including the column register the cross-reference register the row register and the status bit registers are reset to a condition of a logical 0.","Referring to , the BIRA engine commences the BIRA algorithm by analyzing row address   and detects a faulty memory cell in the first word line in the lower bank  at column address . Upon detecting the single fault, the BIRA algorithm then replaces the single fault with a redundant row vice a redundant column. The BIRA engine assigns the first redundant row to substitute for the defective component. The BIRA registers reflect this assignment. The column register Row  changes its content to the row address that corresponds to the faulty memory cell and thus contains row address  . The status bit register En   changes its contents to reflect a logical 1 to indicate that the first redundant row is no longer available to be substituted for a defective component.","Referring to , the BIRA algorithm continues marching though the memory array  and detects no errors in the first word line in the upper bank  at row address  . The BIRA algorithm then checks row address   of the lower bank  and detects no errors. The BIRA algorithm then detects a single fault in the second word line in the upper bank  contained within row address  . The BIRA algorithm, in accordance with the second logical, replaces the single fault failure in that word with a redundant column.","The BIRA registers reflect this assignment of a redundant column to replace the faulty memory cell. Column register Col_H  changes its content in the bit position corresponding to column address  to reflect that the first redundant column has been assigned to substitute for column  in the upper bank . The cross reference register Row_H  also changes the contents to a logical 1 to indicate that the faulty memory cell now substituted by the first redundant column cross references to row address  . Thus, cross-reference register Row_H  stores a logical 1.","Referring to , the BIRA algorithm continues to sequentially march through the addresses of the memory array  and detects the next defect in the third word line contained within the lower bank . Column address  contains the faulty memory cell. Upon detecting a single fault failure in the word line, the BIRA algorithm, in accordance with the second logical step, replaces a single fault failure with a second redundant column. The BIRA registers reflect this assignment of the second redundant column. The column register Col_L  changes the content of its register corresponding to column address  to a logical 1. The cross-reference register Row_L  changes its contents to reflect the row address that cross references to the second redundant column. Thus the cross-reference register in this case changes its contents to row address .","The BIRA algorithm then continues to march on and finds a defect in the third word line contained in the upper bank  at column address . The BIRA algorithm references the BIRA registers and detects that the first redundant column substituting for the second column in the upper bank  already covers this faulty memory cell.","The BIRA algorithm continues to march forward through the memory addresses in the memory array . The BIRA algorithm detects a faulty memory cell in row address   of the lower bank . The faulty memory cell is also located in column address . The BIRA algorithm references the BIRA registers and detects that the faulty memory cell in column address  in the lower bank  is already covered by substitution of the second redundant column. Column register Col_L  contains column address . Thus, the BIRA algorithm continues to march through the memory addresses and detects no further errors in row address  .","Referring to , the BIRA algorithm continues the forward march through the memory addresses starting at column address  and detects no errors in the fifth word line contained within the lower bank . The BIRA algorithm then detects a fault in the fifth word line contained in the upper bank . The faulty memory cell exists in the row address   and also in column address . The BIRA registers and finds that this faulty cell is not covered by any redundant component at this point.","Being a single fault failure within a single word, the BIRA engine, in accordance with the second logical step, checks to see if any redundant rows are available to substitute for the defective component containing this faulty memory cell. The status bits for the redundant columns (not shown) indicate that the first redundant column and the second redundant column are unavailable to be assigned as substitute components.","The BIRA algorithm then checks to see if any redundant rows are available to be assigned as a substitute component to replace the component containing this faulty memory cell. The BIRA engine detects that after referencing the BIRA registers that the second redundant row is available to be assigned as a substitute component. The BIRA engine then assigns the second redundant row to replace this faulty memory cell found in the row address  . The BIRA engine reflects this assignment. Row register Row  changes its content within its register to indicate row address  . The status bit register En  changes its contents to a logical 1 to indicate that the second redundant row is no longer available to be used as a substitute component.","The BIRA algorithm eventually reaches the highest address in the memory array  and determines that no further faults exist. The BIRA algorithm proceeds to the fourth logical step. The BIRA algorithm has covered all of the existing defects in the memory array  with redundant components and determines that the memory is repaired. The BIRA engine then changes the state of decision for the redundant components stored in the BIRA registers to a locked in state of decision and sends the repair information and fault information to the reconfiguration data engine.","If the BIRA engine had not successfully repaired this memory array  then the BIRA engine would have reset the BIRA registers and preceded with the fourth pass thorough this memory array  in an attempt to repair this memory array . This allocation of redundant components to repair faults found in the memory can occur at power up or start up. In an embodiment, each time this redundancy allocation can differ and change in the field as different defects occur to the memory array .",{"@attributes":{"id":"p-0106","num":"0105"},"figref":"FIG. 31"},"The Built-In Redundancy Allocation (BIRA) logic contains multiple repair algorithms which when executed provide complete repairability of the memory with sub sets of the N number of redundant columns and N number of redundant rows. For example,  illustrates the BIRA logic executing a sequence of three repair algorithms using subsets of the redundant components to generate a repair signature that completely repairs the memory as well as six repair algorithms using full sets of the redundant components to generate a repair signature that completely repairs the memory. The BIRA logic executes these multiple repair algorithms in series in order to generate a repair signature for the memory.","In an embodiment, the execution of the series of repair algorithms is ordered from the most efficient repair algorithm in preserving redundant component repair capacity to least efficient in preserving redundant component repair capacity. The BIRA logic generally starts by applying the repair algorithms that use a sub set of the full set of redundant components to repair the memory. Further, the repair algorithm that preserves the most amount of redundant component repair capacity for future field repairs of the memory or later repair of a bank sharing a redundant component is applied to the memory first.","If the BIRA logic was unsuccessful in repairing the memory with the various combinations of the subset of redundant components, then the BIRA logic progresses to attempt repair of the memory using repair algorithms that utilize the full set of redundant components. The particular repair algorithm that uses all of the redundant components in the full set to repair the memory and starts the repair with redundant components shared by two or more memory banks is applied last. That repair algorithm is least efficient in preserving repair capacity because when later defects are detected in other memory banks or in the field, then the redundant components may already be assigned and not available to fix the newly detected memory faults.","When the BIRA logic applies a repair algorithm that does completely repair the memory, then the BIRA logic may halt executing the series of repair algorithms. The repair algorithm that preserves the most amount of redundant component repair capacity for future repairs of the memory has been selected because the repair algorithms are sequentially executed from the best at preserving redundant component repair capacity to the repair algorithm that uses every redundant component if successful in repairing the memory. The BIRA logic then generates a repair signature based upon the repair algorithm that completely repairs the memory. Next, the BIRA logic allocates one or more of the redundant components to substitute for the one or more non-redundant components based upon the repair signature.","As noted, the BIRA logic in this example applies in a sequential order three repair algorithms using subsets of the redundant components to generate a repair signature that completely repairs the memory. If the three repair algorithms using subsets of the redundant components are unsuccessful in repairing the memory, then the BIRA logic applies repair algorithms that use the full set of redundant components. The BIRA logic applies to the memory six repair algorithms using full sets of the redundant components to generate a repair signature that completely repairs the memory. The full set of redundant component available to repair this exemplary memory consists of two redundant rows and two redundant columns.","In block , the first repair algorithm uses a subset of redundant component consisting of two redundant columns and a redundant row applied to repair defects detected in the memory in a column, column, row (CCR) sequence. The first repair algorithm repairs the first defective memory cell address detected with a redundant column. The first repair algorithm repairs the second defective memory cell address detected with a redundant column. Note, the BIRA logic does not assign another redundant component to repair a detected defect, if the defective memory cell address is already covered by a redundant component. If there are no redundant columns available and a redundant row is available then the defective memory cell address is repaired with the redundant row.","In block , the BIRA logic checks whether all of the memory cell addresses having defects have been substituted for by redundant components. If yes, then two things happen. 1) The BIRA logic sends a signal to a counter  to increment up by one. The counter increments up by one to represent the number of memory banks that have been successfully by the repair signature. 2) The BIRA algorithm runs the same repair algorithm on any remaining banks to be tested and repaired with those same redundant components. The comparator  monitors the count of the counter . If the count equal the total number of banks sharing at least some of those redundant components, then that means all of the banks have been successfully repaired  with the last executed repair algorithm. If no, than the BIRA logic proceeds to block  to check whether a particular type of defect exists and then to block  to apply a second repair algorithm to attempt a repair on the memory.","In block , the second repair algorithm executes using two redundant columns and a redundant row applied to the memory in a column, row, column, (CRC) sequence. The second repair algorithm repairs the first defective memory cell address detected with a redundant column. The second repair algorithm repairs the second defective memory cell address detected with a redundant row. The second repair algorithm repairs the third defective memory cell address detected with a redundant column.","In block , the BIRA logic checks whether to bypass execution of one or more the repair algorithms using subsets of redundant components to attempt repair on the memory if a first type of fault is detected. For example, if the first repair algorithm starting a repair with two redundant columns could not successfully repair the memory and the first memory cell having a defect occurs in a half word that contains at least two faulty cells, then this second repair algorithm using a CRC sequence won't be able to completely repair the memory either. Therefore, the BIRA logic bypasses executing the second repair algorithm and proceeds to executing the third repair algorithm in block . Either through statistical or logical methods, the BIRA logic can be preprogrammed on which repair algorithm sequences that should be bypassed if a certain type of defect is detected.","Similar to block , in block , the BIRA logic checks whether all of the memory cell addresses having defects have been substituted for by redundant components. If yes, the BIRA logic sends a signal to a counter  to increment up by one. Also, the BIRA algorithm runs the same repair algorithm on any remaining banks to be tested and repaired with those same redundant components. If the count in the counter  equals the total number of banks sharing at least some of those redundant components, then all of the banks have been successfully repaired  with the second repair algorithm. If no, than the BIRA logic proceeds to block  to apply a third repair algorithm to attempt a repair on the memory.","In block , the third repair algorithm executes using two redundant columns and a redundant row applied to the memory in a row, column, column, (RCC) sequence. The second repair algorithm repairs the first defective memory cell address detected with a redundant row. The second repair algorithm repairs the second defective memory cell address detected with a redundant column. The second repair algorithm repairs the third defective memory cell address detected with a redundant column.","In this example, a redundant row provides the most amount of redundant component repair capacity for future repairs of the memory. The first repair algorithm, second repair algorithm, and third repair algorithm all attempt to repair the memory without using both of the redundant row included in the full set. If the first repair algorithm repaired the memory with only using the first two redundant columns, then both redundant rows in the full set are available for future repairs.","Similar to block , in block , the BIRA logic checks whether all of the memory cell addresses having defects have been substituted for by redundant components. If yes, the BIRA logic sends a signal to a counter  to increment up by one. Also, the BIRA algorithm runs the same repair algorithm on any remaining banks to be tested and repaired with those same redundant components. If the count in the counter  equals the total number of banks sharing at least some of those redundant components, then all of the banks have been successfully repaired  with the second repair algorithm. If no, than the BIRA logic proceeds to block  to apply a fourth repair algorithm to attempt a repair on the memory.","Note, the memory may be a single bank architecture. Therefore, if given repair algorithm repairs the memory, then the BIRA logic will stop executing repair algorithms when the counter reaches a count of one. If this is a multi-bank architecture, then the BIRA logic can bypass the repair algorithms that didn't successfully repair the previous bank.","In blocks \u2013, the BIRA logic sequentially executes the fourth through nine repair algorithms to attempt repair of the memory with the full set of redundant components. Each repair algorithm applies the redundant component to repair the memory in different sequence, CCRR thru RCRC. If any of the repair algorithms is successful, the BIRA logic sends a signal to a counter  to increment up by one. Also, the BIRA algorithm runs the same repair algorithm on any remaining banks to be tested and repaired with those same redundant components. If the count in the counter  equals the total number of banks sharing at least some of those redundant components, then all of the banks have been successfully repaired .","The repair algorithm that preserves the most amount of redundant component repair capacity for future repairs of the memory may be determined in a number of ways. Some examples follow. Combinations may be used as well. The BIRA logic may start the sequence with a column, column, row repair because based upon statistical analysis of that memory's architecture starting a repair with the combination of two redundant columns completely repairs all the defects in that memory's architecture more than any other starting combination using less than all of the redundant components. The BIRA logic may start the sequence with a column, column, row repair because the redundant rows are shared across two or more banks of a multibank memory architecture. The BIRA logic may start the sequence with a column, column, row repair because defects occur more often in a line of columns rather than a line of rows for that memories architecture.","In an embodiment, the BIRA logic may start with repair algorithms that use two redundant components when attempting to repair the memory. For example, repair algorithms could use a row-column sequence or column-column sequence to attempt repair on the memory. The amount of redundant components in the full set of redundant components associated with that memory will vary depending upon the architecture of that memory. In an embodiment, the BIRA logic does not use status bits and the test and repair allocation algorithms use a very high frequency timing mechanism.","Note, as discussed previously, in an embodiment, the BIRA logic allows test and repair functions to occur in the field rather than at the factory. The BIRA logic may augment a hard repair signature generated at the factory with a soft repair signature determined each time the memory is powered up in the field. The BIRA logic may used fuses blown at the factory to establish the hard repair signature. The BIRA logic may then detect a new faulty memory cell address not covered by the redundant components assigned by the hard repair signature. The BIRA logic may then assign an available redundant component to substitute for the new detected faulty memory cell address. The hard repair signature is augmented with the soft repair information determine the allocation of all the redundant components for that memory. The augmented soft repair signature may be stored in registers, such as scan chain registers, to determine the allocation of the redundant components.","The sequence of operations for the algorithms may be stored in a machine-readable medium. A machine-readable medium includes any mechanism that provides (i.e., stores and\/or transmits) information in a form readable by a machine (e.g., a computer). For example, a machine-readable medium includes read only memory (ROM); random access memory (RAM); magnetic disk storage media; optical storage media; flash memory devices; electrical, optical, acoustical or other form of propagated signals (e.g., carrier waves, infrared signals, digital signals, etc.).",{"@attributes":{"id":"p-0126","num":"0125"},"figref":"FIG. 32"},"In block , the designs for each memory component for the embedded memory are supplied to the memory compiler. A memory compiler may be a software program comprised of multiple algorithms and designs for the purpose of generating a circuit design and a layout in a space available on a target chip. The set of application-specific algorithms and interfaces of the memory compiler may be used by system IC integrators to rapidly create hundreds of silicon-proven memory cores. The memory compiler receives designs of memory component and utilizes those memory component designs in conjunction with memory circuit designs to optimize a circuit design and layout in the space available on a target chip. A memory having a test and repair logic section may be a basic memory building block utilized in the memory compiler.","In block , the memory compiler generates a circuit design and layout in the space available on a target chip. The memory compiler stores the data representing the embedded memory typically on a machine-readable medium. The memory compiler then provides design to be used to generate one or more lithographic masks to be used in the fabrication of that embedded memory.","In block , the machine to generate the lithographic masks receives the circuit design and layout from the memory compiler. The machine generates one or more lithographic masks to be used to transfer that circuit design onto the chip.","In block , a fabrication facility fabricates the chips with the embedded memories using the lithographic masks generated from the memory compiler's circuit design and layout. Fabrication facilities may use standard CMOS logic process employing 1.0 um, 0.50 um, 0.35 um, 0.25 um, 0.18 um, 0.13 um, 0.10 um, or less, technologies to fabricate the chips. The size of the CMOS logic process employed typically defines the smallest minimum lithographic dimension that can be fabricated on the chip using the lithographic masks, which in turn determines minimum component size. In an embodiment, light is shown through these lithographic masks onto the chip to transfer the circuit design and layout for the embedded memory onto the chip itself.","In an embodiment, the embedded memory containing one or more memories having a test and repair logic section can be embedded into the System on Chip. The embedded memories can be fabricated in a state-of-the-art, leading edge standard logic process. In an embodiment, the memory compiler is designed for embedded applications in the standard CMOS logic process.","In an embodiment, an exemplary memory compiler may also include the following. A graphic user interface, a common set of processing elements, and a library of files containing design elements such as circuits, control logic, and cell arrays that define the compiler. The library of files may also contain other files such as global parameter files, configuration files and other similar files. In an embodiment, object code in a set of executable software programs may form one or more of the compiler's function blocks.","As noted, in an embodiment, a designer chooses the specifics of the memory configuration to produce the set of files defining the requested memory instances. A memory instance may include front-end views and back-end files. The front-end views support documentation, simulation, debugging, and testing. The back-end files, such as a layout, physical LEF, etc. are for layout and fabrication.","In one embodiment, the software used to facilitate the compiler can be embodied onto a machine-readable medium. A machine-readable medium includes any mechanism that provides (e.g., stores and\/or transmits) information in a form readable by a machine (e.g., a computer). For example, a machine-readable medium includes read only memory (ROM); random access memory (RAM); magnetic disk storage media; optical storage media; flash memory devices; DVD's, electrical, optical, acoustical or other form of propagated signals (e.g., carrier waves, infrared signals, digital signals, EPROMs, EEPROMs, FLASH, magnetic or optical cards, or any type of media suitable for storing electronic instructions. Slower mediums could be cached to a faster, more practical, medium.","Some portions of the detailed descriptions above are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here, and generally, conceived to be a self-consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually, though not necessarily, these quantities take the form of electrical or magnetic signals capable of being stored, transferred, combined, compared, and otherwise manipulated. It has proven convenient at times, principally for reasons of common usage, to refer to these signals as bits, values, elements, symbols, characters, terms, numbers, or the like.","It should be borne in mind, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussions, it is appreciated that throughout the description, discussions utilizing terms such as \u201cprocessing\u201d or \u201ccomputing\u201d or \u201ccalculating\u201d or \u201cdetermining\u201d or the like, may refer to the action and processes of a computer system, or similar electronic computing device, that manipulates and transforms data represented as physical (electronic) quantities within the computer system's registers and memories into other data similarly represented as physical quantities within the computer system memories or registers, or other such information storage, transmission or display devices.","While some specific embodiments of the invention have been shown the invention is not to be limited to these embodiments. For example, most functions performed by electronic hardware components may be duplicated by software emulation. Thus, a software program written to accomplish those same functions may emulate the functionality of the hardware components in input-output circuitry. The application specific processor may be a finite state machine. The BIRA algorithm may make one or more passes through the memory array and alter how redundant components are assigned. The invention is to be understood as not limited by the specific embodiments described herein, but only by scope of the appended claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The drawings refer to the invention in which:",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 11","FIG. 15"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 16","FIG. 25"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 26","FIG. 30"]},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 32"}]},"DETDESC":[{},{}]}
