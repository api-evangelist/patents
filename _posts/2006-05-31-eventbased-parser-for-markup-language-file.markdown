---
title: Event-based parser for markup language file
abstract: A parser uses SAX-like APIs for efficiency and provides DOM-like APIs for simplicity and convenience. The parser can read an XML document, for example, and parse its contents into a set of abstract information containers called nodes. The nodes are used to represent the structure and content of the document, which allows applications to read and manipulate the information in the document while not having to explicitly understand XML syntax. After a document is parsed, the nodes can be explored in any direction; they are not limited to straight-through text file processing.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07930630&OS=07930630&RS=07930630
owner: Microsoft Corporation
number: 07930630
owner_city: Redmond
owner_country: US
publication_date: 20060531
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["A Document Object Model (DOM) is often used to parse XML data. DOM is often implemented in XML editors to provide a programmatic representation of XML documents, fragments, nodes, or node-sets. DOM can also be used to provide an application programming interface for working with XML data. As an XML representation, DOM typically conforms to the W3C DOM standard. As a set of application programmer interfaces (APIs), XML DOM objects are usually COM objects that can expose interfaces and be used in XML applications written in programming languages such as C\/C++, Visual Basic, VBScript, and JScript.","When executed, the DOM loads the entire XML document in memory and represents as a tree structure that can be accessed by the set of provided APIs. However, this parsing by DOMs is often not very efficient (especially in a server software environment) because the server often processes several files at a time and each processed file can be arbitrary long. Loading whole files that are being processed in memory can unacceptably slow down the overall performance of the server and also cause Denial of Service situations.","Another parser, SAX (Simple API for XML), is a conventional standard for event-based parsing of XML documents. SAX typically defines an abstract programmatic interface that models the XML information set (\u201cinfoset\u201d) through a linear sequence of method calls. Although SAX and DOM are different, SAX and DOM both provide a different projection of the XML infoset onto programmatic types. Because SAX does not demand resources for an in-memory representation of the document, SAX provides a good alternative to the Document Object Model (DOM) and usually works especially well for arbitrarily large files.","SAX facilitates the search of large documents by extracting small pieces of information from a large document and allowing processing to be aborted after the information is located. However, the benefit of low memory usage requirements of SAX is offset by other disadvantages. For example, SAX often has difficulties managing context during processing when performing advanced queries.","This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the detailed description. This summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended as an aid in determining the scope of the claimed subject matter.","The present disclosure is directed to a parser for parsing documents in markup (or markup-like) languages. The parser uses SAX-like APIs for efficiency and provides DOM-like APIs for simplicity and convenience. The parser can read a markup language document and parse its contents into a set of abstract information containers called nodes. The nodes are used to represent the structure and content of the document, which allows applications to read and manipulate the information in the document while not having to explicitly understand XML syntax, for example. After a document is parsed, the nodes can be explored in any direction; they are not limited to straight-through text file processing.","The parser can be an event-based XML parser that provides a DOM-like method for accessing serial XML data. The XML parser manages the local parser state in state machine form, which provides a set of events for nodes in XML parsing. A DOM-like XML parsing method is built on top of an event-based parser in which only a minimal number of events are read to generate a next node in the XML node tree.","These and other features and advantages will be apparent from a reading of the following detailed description and a review of the associated drawings. It is to be understood that both the foregoing general description and the following detailed description are explanatory only and are not restrictive of the invention as claimed. Among other things, the various embodiments described herein may be embodied as methods, devices, or a combination thereof. Likewise, the various embodiments may take the form of an entirely hardware embodiment, an entirely software embodiment or an embodiment combining software and hardware aspects. Furthermore, various markup languages can be used to provide the functionality of XML. The disclosure herein is, therefore, not to be taken in a limiting sense.","As briefly described above, embodiments are directed to an event-based XML parser. With reference to , one example system for implementing event-based parsing includes a computing device, such as computing device . Computing device  may be configured as a client, a server, a mobile device, or any other computing device that interacts with data in a network based collaboration system. In a very basic configuration, computing device  typically includes at least one processing unit  and system memory . Depending on the exact configuration and type of computing device, system memory  may be volatile (such as RAM), non-volatile (such as ROM, flash memory, etc.) or some combination of the two. System memory  typically includes an operating system , one or more applications , and may include program data . Event-based parsing , which is described in detail below with reference to , is implemented within system memory .","Computing device  may have additional features or functionality. For example, computing device  may also include additional data storage devices (removable and\/or non-removable) such as, for example, magnetic disks, optical disks, or tape. Such additional storage is illustrated in  by removable storage  and non-removable storage . Computer storage media may include volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information, such as computer readable instructions, data structures, program modules, or other data. System memory , removable storage  and non-removable storage  are all examples of computer storage media. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computing device . Any such computer storage media may be part of device . Computing device  may also have input device(s)  such as keyboard, mouse, pen, voice input device, touch input device, etc. Output device(s)  such as a display, speakers, printer, etc. may also be included.","Computing device  also contains communication connections  that allow the device to communicate with other computing devices , such as over a network. Networks include local area networks and wide area networks, as well as other large scale networks including, but not limited to, intranets and extranets. Communication connection  is one example of communication media. Communication media may typically be embodied by computer readable instructions, data structures, program modules, or other data in a modulated data signal, such as a carrier wave or other transport mechanism, and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. The term computer readable media as used herein includes both storage media and communication media.",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2","b":"200"},"Parser  comprises an external API class called CDAXParser  that implements ISAXContentHandler  callback methods (discussed below). CDAXParser  also comprises an internal class CStateMachine  to manage the state of the parser. In order to suspend and resume parser , the IMXReaderControl  interface is normally used.","ISAXContentHandler  callback methods comprise \u201cCOM\u201d methods. The startDocument method is used for receiving notification of the beginning of an XML document to be parsed. The endDocument method is used for receiving notification of the end of a document. The startElement method is used for receiving notification of the beginning of an element. The endElement method is used for receiving notification of the end of an element. The characters method is used for receiving notification of character data.","The ignoreable Whitespace method is used for receiving notification of ignorable white space in element content. In various embodiments, this method is not called where the implementation is nonvalidating. The startPrefixMapping method is used for indicating the beginning of a namespace prefix that maps to a URI (universal resource indicator). The endPrefixMapping method is used to indicate the end of a namespace prefix that maps to a URI. The processingInstruction method is used for receiving notification of a processing instruction. The skippedEntry method is used for receiving notification of when an entity is skipped.","Any application which uses parser  typically implements a content handler class by implementing an ISAXContentHandler interface. When the parsing starts, the content handler class starts receiving notifications through above-mentioned implemented methods. The content handler class typically reacts in response to these notifications to successfully parse the input document.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 3","b":["310","320","350","330","350","340"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 4","FIG. 3"],"b":["400","220","210","401","402","403","404","405","406","407"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 5","b":["500","510","520","530","540","550","560"]},"SAX Controller  is typically created by the CDAXParser class. SAX Controller  is a SAX-like IMXReaderControl interface for controlling an event-based parser. By using suspend, resume, and abort methods, parser  can suspend or resume SAX-like parsing at any SAX notification completion boundary. In an embodiment, the whole implementation of DAX API methods  can rely upon suspending and resuming parser  at the appropriate state.","CDAXParser allows creating element contexts  for subsequent traversal of context nodes. Element Context  is a \u201cremembered\u201d parent element whose child elements (or the parent element itself) is currently being processed. A parent element can be remembered by storing the element context on context stack . Element Context  also marks the boundary for suspending parser . Every time parser  completes parsing any of the element contexts, parsing is normally suspended. Element Context  is used for searching a particular element from child elements of an XML element or focusing the parsing at a specific element and the element's children. A client of CDAXParser class can create multiple contexts on different elements.","As mentioned above, an element context  can be pushed in a context stack  every time the element context is created. When each endElement notification occurs, the element context stack  is checked to determine whether the last element context is completed or is currently being processed. If the final pushed context is completed, parsing can be suspended.","A list of states used by parser  is given in Table 1 as follows.",{"@attributes":{"id":"p-0031","num":"0030"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["STATE_PARSER_START","DAX parser has been initialized."]},{"entry":["STATE_PARSER_END","DAX parser has been ended."]},{"entry":["STATE_START_DOCUMENT","Set at ISAXCiontentHandler.startDocument notification"]},{"entry":["STATE_END_DOCUMENT","Set at ISAXCiontentHandler.endDocument notification"]},{"entry":["STATE_START_ELEMENT","Set at ISAXCiontentHandler.startElement notification"]},{"entry":["STATE_END_ELEMENT","Set at ISAXCiontentHandler.endElement notification"]},{"entry":["STATE_CHARACTERS","Set at ISAXCiontentHandler.characters notification"]},{"entry":["STATE_SEARCH_ELEMENT","Set when searching an xml element."]},{"entry":["STATE_CHILD_ELEMENT","Set when searching first child xml element."]},{"entry":["STATE_SIBLING_ELEMENT","Set when searching sibling xml element."]},{"entry":["STATE_SIMPLE_ELEMENT","Set at ISAXCiontentHandler.endElement notification"]},{"entry":[{},"when a simple element is parsed. A simple xml element is an element"]},{"entry":[{},"which does not has any children and has no value. e.g. <Heading\/>,"]},{"entry":[{},"<Test id=\u201d123\u201d\/>"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"A list of state machine methods used by parser  is given in Table 2 as follows:",{"@attributes":{"id":"p-0033","num":"0032"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"280pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Init","Initialize State machine. CDAXParser Calls init with STATE_PARSER_START"]},{"entry":["SetState","Sets the current state of CADXParser. If startDocument notification is received set the current"]},{"entry":[{},"state to STATE_START_DOCUMENT, if startElement notification is received then set the"]},{"entry":[{},"current state to STATE_START_ELEMENT, and the like."]},{"entry":[{},"With the SetState call, the current state of state machine becomes the previous state."]},{"entry":["GetElement","Search for an XML element in the read XML content or remaining XML context if called within"]},{"entry":[{},"an XML context."]},{"entry":["UpdateState","Update the current state. CStaeMachine allows composite states as well."]},{"entry":["CheckState","Compare the current state with the asked for state."]},{"entry":["SetNextState","Set the next state. CDAXParser sets the next state to that state where parsing is to be"]},{"entry":[{},"suspended."]},{"entry":["CheckNextState","Compare the next state with the asked state."]},{"entry":["CheckPreviousState","Compare the previous state with the asked state."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"A list of API methods used by parser  is given in Table 3 as follows:",{"@attributes":{"id":"p-0035","num":"0034"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"280pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Init","Initialize DAX parser for given XML file name or stream"]},{"entry":["GetNextElement","Get next available xml element. If document is ended return FALSE."]},{"entry":["GetElement","Search an XML element in the reaming xml content or remaining xml context if called within an"]},{"entry":[{},"xml context."]},{"entry":["GetCurrentElement","Get the current XML element being processed."]},{"entry":["GetFirstChildElement","Get First child element of the current element. If there are no child elements then return FALSE"]},{"entry":[{},"and suspend parsing at the next available element."]},{"entry":["GetNextSiblingElement","Get next sibling element child element of the current element. If there are no remaining sibling"]},{"entry":[{},"elements then return FALSE and suspend parsing at the end of document."]},{"entry":["GetValue","Get value of current XML element. If this element. Returns FALSE if no value is available."]},{"entry":["GetAttributes","Get list of attributes of the current element."]},{"entry":[{},"Returns FALSE if no attribute is available."]},{"entry":["GetAttribute","Get attribute based on attribute name. Returns FALSE if attribute is not available."]},{"entry":["PushContext","Push context at the current element being processed and return context id"]},{"entry":["PopContext","Pop the last pushed context"]},{"entry":["CheckContext","Compare specified context id with the current context id"]},{"entry":["IsDocumentEnd","Is parsing of the whole document has ended."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 6","b":"610"},"In operation , the current state of the state machine is changed in response to notifications received by the parser class. The notifications comprise events such as start of document, end of document, start of element, end of element, character elements, and other notifications useful for parsing. Composite states (and parallel state machines) can be implemented in various embodiments.","Additionally, the process can be used to allow client applications to read XML from an input file in a forward direction (as in a SAX-like parser), or in both directions (as in a DOM-like parser). Reading in both directions can be implemented by incorporating caching of a subset of nodes to allow reverse reading of that subset of node.","In operation , context events are stored in response to the notifications and changes in state of the state machine. Every time a context is created, the created context is pushed in a context stack. The context stack can be used to \u201cremember\u201d the hierarchy (e.g., context) of the parsed elements. The element context is a remembered parent element whose child elements or the parent element itself is currently being processed. The boundary for suspending the parser also occurs during the boundary of the element context. The parser is typically suspended when the parser completes parsing of an element context.","In operation , the client application is called to provide the client application with the results of the process. The client application can be called with calls to ISAXContentHandler when, for example, results are available from the process.","In operation , the context stacked is checked upon each endElement notification to determine whether the context has been completed. If the final pushed context has been completed, parsing is suspended.","Pseudo-code that is suitable for implementing parser  is given as follows:",{"@attributes":{"id":"p-0043","num":"0042"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"357pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Method: CDAXParser::Init"},{"entry":"Parameters: xml Filename or Stream"},{"entry":"Return Value: Status"},{"entry":"PseudoCode:"},{"entry":"\u2003\u20031. \u2003Initialize State Machine with state (STATE_PARSER_START)"},{"entry":"\u2003\u20032. \u2003Initialize SAX with a given xml file name or xml stream"},{"entry":"\u2003\u20033. \u2003SetNextState(STATE_START_DOCUMENT) and ResumeSAXParser"},{"entry":"Method: CDAXParser::GetNextElement"},{"entry":"Parameters: None"},{"entry":"Return Value: xmlElement"},{"entry":"PseudoCode:"},{"entry":"\u2003\u20031. \u2003IF CheckState(STATE_END_DOCUMENT) return FALSE"},{"entry":"\u2003\u20032. \u2003SetNextState (STATE_START_ELEMENT OR STATE_END_DOCUMENT) and ResumeSAXParser"},{"entry":"\u2003\u20033. \u2003IF CheckState (STATE_START_ELEMENT OR STATE_SIMPLE_ELEMENT )"},{"entry":"\u2003\u20034. \u2003THEN return currentXmlElement"},{"entry":"\u2003\u20035. \u2003ELSE return FALSE."},{"entry":"Method: CDAXParser::GetElement"},{"entry":"Parameters: xmlSearchElement"},{"entry":"Return Value: xmlElement"},{"entry":"PseudoCode:"},{"entry":"\u2003\u20031. \u2003IF CheckState(STATE_END_DOCUMENT) return FALSE"},{"entry":"\u2003\u20032. \u2003Store xmlSearchElement"},{"entry":"\u2003\u20033. \u2003SetNextState(STATE_SEARCH_ELEMENT OR STATE_END_DOCUMENT) and ResumeSAXParser"},{"entry":"\u2003\u20034. \u2003IF CheckState(STATE_SEARCH_ELEMENT)"},{"entry":"\u2003\u20035. \u2003THEN return currentXMLElement"},{"entry":"\u2003\u20036. \u2003ELSE return FALSE."},{"entry":"Method: CDAXParser:: GetCurrentElement"},{"entry":"Parameters: None"},{"entry":"Return Value: xmlElement"},{"entry":"PseudoCode:"},{"entry":"\u2003\u20031. \u2003IF CheckState(STATE_START_DOCUMENT OR STATE_END_DOCUMENT) return FALSE"},{"entry":"\u2003\u20032. \u2003ELSE return currentXmlElement."},{"entry":"Method: CDAXParser:: GetFirstChildElement"},{"entry":"Parameters: None"},{"entry":"Return Value: xmlElement"},{"entry":"PseudoCode:"},{"entry":"\u2003\u20031. \u2003IF CheckState(STATE_END_DOCUMENT OR STATE_END_ELEMENT) return FALSE"},{"entry":"\u2003\u20032. \u2003SetNextState(STATE_CHILD_ELEMENT OR STATE_END_DOCUMENT) and ResumeSAXParser"},{"entry":"\u2003\u20033. \u2003IF CheckState(STATE_CHILD_ELEMENT)"},{"entry":"\u2003\u20034. \u2003THEN return currentXMLElement"},{"entry":"\u2003\u20035. \u2003ELSE return FALSE."},{"entry":"Method: CDAXParser:: GetNextSiblingElement"},{"entry":"Parameters: None"},{"entry":"Return Value: xmlElement"},{"entry":"PseudoCode:"},{"entry":"\u2003\u20031. \u2003IF CheckState(STATE_END_DOCUMENT) return FALSE"},{"entry":"\u2003\u20032. \u2003SetNextState(STATE_SIBLING_ELEMENT OR STATE_END_DOCUMENT) and ResumeSAXParser"},{"entry":"\u2003\u20033. \u2003IF CheckState(STATE_SIBLING_ELEMENT)"},{"entry":"\u2003\u20034. \u2003THEN return currentXMLElement"},{"entry":"\u2003\u20035. \u2003ELSE return FALSE."},{"entry":"Method: CDAXParser:: GetValue"},{"entry":"Return Value: valueBuffer"},{"entry":"PseudoCode:"},{"entry":"\u2003\u20031. \u2003IF CheckState(STATE_END_DOCUMENT OR STATE_END_ELEMENT) return FALSE"},{"entry":"\u2003\u20032. \u2003SetNextState(STATE_CHARACTERS OR STATE_START_ELEMENT OR STATE_END_ELEMENT OR"},{"entry":"\u2003\u2003\u2003\u2009\u2003STATE_END_DOCUMENT) and ResumeSAXParser"},{"entry":"\u2003\u20033. \u2003IF CheckState(STATE_CHARACTERS) THEN return valueBuffer"},{"entry":"\u2003\u20034. \u2003ELSE return FALSE."},{"entry":"Method: CDAXParser:: GetAttributes"},{"entry":"Return Value: attributeValue List"},{"entry":"PseudoCode:"},{"entry":"\u2003\u20031. \u2003IF CheckState(STATE_END_DOCUMENT ) return FALSE"},{"entry":"\u2003\u20032. \u2003Get stored xmlAttributes list of currentXmlElement if list is not empty return xmlAttributes list"},{"entry":"\u2003\u20033. \u2003ELSE return FALSE."},{"entry":"Method: CDAXParser:: GetAttribute"},{"entry":"Parameter: attributeName"},{"entry":"Return Value: attributeValue"},{"entry":"PseudoCode:"},{"entry":"\u2003\u20031. \u2003IF CheckState(STATE_END_DOCUMENT ) return FALSE"},{"entry":"\u2003\u20032. \u2003Get xmlAttributes list of currentXmlElement IF list is not empty"},{"entry":"\u2003\u20033. \u2003THEN search for the attributeName IF found return attributeValue"},{"entry":"\u2003\u20034. \u2003ELSE return FALSE."},{"entry":"\u2003\u20035. \u2003ELSE return FALSE."},{"entry":"Method: CDAXParser:: PushContext"},{"entry":"Parameter: None"},{"entry":"Return Value: contextID"},{"entry":"PseudoCode:"},{"entry":"\u2003\u20031. \u2003IF CheckState(STATE_END_DOCUMENT OR STATE_END_ELEMENT) return FALSE"},{"entry":"\u2003\u20032. \u2003Create new contextID"},{"entry":"\u2003\u20033. \u2003Insert contextID in contextIDList."},{"entry":"\u2003\u20034. \u2003Push contextID and currentXmlElement in contextIDStack"},{"entry":"\u2003\u20035. \u2003return contextID"},{"entry":"Method: CDAXParser:: PopContext"},{"entry":"Parameter: None"},{"entry":"Return Value: None"},{"entry":"PseudoCode:"},{"entry":"\u2003\u20031. \u2003IF length of contextIDStack is greater than 0"},{"entry":"\u2003\u20032. \u2003THEN Pop contextID and xmlElement from contextIDStack and Remove contextID from contextIDList"},{"entry":"Method: CDAXParser:: CheckContext"},{"entry":"Parameter: contextID"},{"entry":"Return Value: Status"},{"entry":"PseudoCode:"},{"entry":"\u2003\u20031. \u2003IF found contextID in contextIDList"},{"entry":"\u2003\u20032. \u2003THEN return TRUE"},{"entry":"\u2003\u20033. \u2003ELSE return FALSE"},{"entry":"Method: CDAXParser:: IsDocumentEnd"},{"entry":"Parameter: None"},{"entry":"Return Value: Status"},{"entry":"PseudoCode:"},{"entry":"\u2003\u20031. \u2003IF CheckState(STATE_END_DOCUMENT )"},{"entry":"\u2003\u20032. \u2003THEN return TRUE"},{"entry":"\u2003\u20033. \u2003ELSE return FALSE"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Pseudo-code for an implementation of SAXContentHandler  interface methods is given below. The listed methods are usually private to CDAXParser. The listed methods are typically called by parser  during parsing.",{"@attributes":{"id":"p-0045","num":"0044"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"364pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Method: CDAXParser:: startDocument"},{"entry":"Parameter: None"},{"entry":"Return Value: None"},{"entry":"PseudoCode:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"350pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1.","SetState(STATE_START_DOCUMENT )"]},{"entry":["2.","IF CheckNextState(STATE_START_DOCUMENT ) THEN SuspendSAXParser"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"364pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Method: CDAXParser:: endDocument"},{"entry":"Parameter: None"},{"entry":"Return Value: None"},{"entry":"PseudoCode:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"350pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1.","SetState(STATE_END_DOCUMENT )"]},{"entry":["2.","IF CheckNextState(STATE_END_DOCUMENT ) THEN SuspendSAXParser"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"364pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Method: CDAXParser:: startElement"},{"entry":"Parameter: SAX's currentXmlElement, SAX's xmlAttributes"},{"entry":"Return Value: None"},{"entry":"PseudoCode:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"350pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1.","SetState(STATE_START_ELEMENT)"]},{"entry":["2.","Save SAX's currentXmlElement"]},{"entry":["3.","Save SAX's xmlAttributes"]},{"entry":["4.","Increment xmlElementDepth"]},{"entry":["5.","IF CheckNextState(STATE_START_ELEMENT) THEN SuspendSAXParser and Return"]},{"entry":["6.","IF CheckNextState(STATE_SIBLING_ELEMENT) AND xmlElementDepth == xmlSearchDepth"]},{"entry":["7.","THEN UpdateState(STATE_SIBLING_ELEMENT) and SuspendSAXParser and Return"]},{"entry":["8.","IF CheckNextState(STATE_SEARCH_ELEMENT) AND currentXmlElement == xmlSearchElement"]},{"entry":["9.","THEN UpdateState(STATE_SEARCH_ELEMENT) and SuspendSAXParser and Return"]},{"entry":["10.","IF CheckNextState(STATE_CHILD_ELEMENT)"]},{"entry":["11.","THEN UpdateState(STATE_CHILD_ELEMENT) and SuspendSAXParser and Return"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"364pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Method: CDAXParser:: endElement"},{"entry":"Parameter: SAX'S currentXmlElement"},{"entry":"Return Value: None"},{"entry":"PseudoCode:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"350pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1.","Set State(STATE_END_ELEMENT)"]},{"entry":["2.","decrement xmlElementDepth"]},{"entry":["3.","IF length of contextIDStack is greater than 0 AND elementDepth of top of contextIDStack is greater than"]},{"entry":[{},"xmlElementDepth"]},{"entry":["4.","THEN PopContext and SuspendSAXParser"]},{"entry":["5.","IF CheckPreviousState (STAE_START_ELEMENT) THEN UpdateState(STATE_SIMPLE_ELEMENT)"]},{"entry":["6.","IF CheckNextState(STATE_END_ELEMENT) THEN SuspendSAXParser and Return"]},{"entry":"7."},{"entry":["8.","IF CheckNextState(STATE_SIBLING_ELEMENT) AND xmlElementDepth less than xmlSearchDepth"]},{"entry":["9.","THEN set xmlSearchDepth = 0 and SuspendSAXParser and Return"]},{"entry":["10.","IF CheckCurrentState is (STATE_SIMPLE_ELEMENT) AND CheckNextState(STATE_SEARCH_ELEMENT) AND"]},{"entry":[{},"currentXmlElement == xmlSearchElement"]},{"entry":["11.","THEN UpdateState (STATE_SEARCH_ELEMENT) and SuspendSAXParser and Return"]},{"entry":["12.","IF CheckState(STATE_SIMPLE_ELEMENT) AND CheckNextState (STATE_CHILD_ELEMENT)"]},{"entry":["13.","THEN SuspendSAXParser and Return"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"364pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Method: CDAXParser:: characters"},{"entry":"Parameter: SAX's valueBuffer"},{"entry":"Return Value: None"},{"entry":"PseudoCode:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"right"}},{"@attributes":{"colname":"2","colwidth":"350pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1.","IF CheckState (STATE_START_ELEMENT) == FALSE THEN return"]},{"entry":["2.","SetState (STATE_CHARACTERS)"]},{"entry":["3.","IF CheckNextState(STATE_CHARACTERS)"]},{"entry":["4.","THEN store SAX's valueBuffer and SuspendSAXParser"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The above specification, examples and data provide a complete description of the manufacture and use of the composition of the invention. Since many embodiments of the invention can be made without departing from the spirit and scope of the invention, the invention resides in the claims hereinafter appended."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
