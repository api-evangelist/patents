---
title: Operating system debugger extensions for hypervisor debugging
abstract: A data processing system, method, and product are disclosed for debugging partition management firmware from an existing operating system debugger. The partition management firmware is also called a hypervisor. The data processing system is logically partitioned and includes an operating system debugger and hypervisor software. An operating system and the operating system debugger are stored in one of the logical partitions. Extensions are included within the operating system debugger. The extensions are then utilized by the existing operating system debugger to debug the hypervisor.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06839892&OS=06839892&RS=06839892
owner: International Business Machines Corporation
number: 06839892
owner_city: Armonk
owner_country: US
publication_date: 20010712
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT"],"p":["1. Technical Field","The present invention relates generally to the field of computer systems and, more specifically to a data processing system, method, and product for including extensions in an existing operating system debugger that may be used to debug hypervisor software.","2. Description of Related Art","A logical partitioning option (LPAR) within a data processing system (platform) allows multiple copies of a single operating system (OS) or multiple heterogeneous operating systems to be simultaneously run on a single data processing system hardware platform. A partition, within which an operating system image runs, is assigned a non-overlapping subset of the platform's hardware resources. These platform allocable resources include one or more architecturally distinct processors with their interrupt management area, regions of system memory, and input\/output (I\/O) adapter bus slots. The partition's resources are represented by its own open firmware device tree to the OS image.","Each distinct OS or image of an OS running within the platform is protected from each other such that software errors on one logical partition can not affect the correct operation of any of the other partitions. This is provided by allocating a disjoint set of platform resources to be directly managed by each OS image and by providing mechanisms for ensuring that the various images can not control any resources that have not been allocated to it. Furthermore, software errors in the control of an operating system's allocated resources are prevented from affecting the resources of any other image. Thus, each image of the OS (or each different OS) directly controls a distinct set of allocable resources within the platform.","Many logically partitioned systems make use of a hypervisor. A hypervisor is a layer of privileged software between the hardware and logical partitions that manages and enforces partition protection boundaries. The hypervisor is also referred to as partition management firmware. The hypervisor is responsible for configuring, servicing, and running multiple logical systems on the same physical hardware. The hypervisor is typically responsible for allocating resources to a partition, installing an operating system in a partition, starting and stopping the operating system in a partition, dumping main storage of a partition, communicating between partitions, and providing other functions. In order to implement these functions, a hypervisor also has to implement its own low level operations like main storage management, synchronization primitives, I\/O facilities, heap management, and other functions.","During development, software, such as a hypervisor, often includes one or more inadvertent errors. Locating and removing the errors in software is generally known in the industry as \u201cdebugging\u201d the software, with errors being referred to as \u201cbugs\u201d.","Known systems for debugging a hypervisor require the use of a dedicated hypervisor debugger which is written specifically for use by the hypervisor. Time, and therefore money, is required during development of systems in order to develop a dedicated hypervisor debugger.","Operating system debuggers are known in the art and are widely available. Operating system debuggers are utilized to debug an operating system. Known operating system debuggers may not be used to debug a hypervisor however, because operating systems are prohibited from directly accessing the hypervisor's resources.","Therefore, a need exists for a method, system, and product whereby an existing operating system debugger is modified by adding hypervisor extensions which enable the operating system debugger to directly access a hypervisor's resources in order to debug the hypervisor. In this manner, valuable development time and expense is saved by using a modified, existing operating system to debug hypervisor software.","A data processing system, method, and product are disclosed for debugging partition management firmware utilizing an existing operating system debugger. The partition management firmware is also called a hypervisor. The data processing system is logically partitioned and includes an operating system debugger and hypervisor software. An operating system and the operating system debugger are stored in one of the logical partitions.","In known systems, operating systems and operating system debuggers are not permitted to directly access resources controlled by the hypervisor, such as the physical memory. The present invention describes modifying an existing operating system debugger by adding extensions to the existing operating system debugger. The extensions may be utilized by the existing operating system debugger to directly access hypervisor resources and thus to debug the hypervisor.","These extensions include an event handler routine which is code which exists within the existing operating system debugger which is alerted by the hypervisor when hypervisor events occur. In response to these events, the existing operating system debugger may then invoke other extensions to cause the hypervisor to read data from physical memory locations specified by the operating system debugger, to cause the hypervisor to write specified data to physical memory locations specified by the operating system debugger, and to perform other hypervisor functions.","In this manner, an existing operating system debugger may be modified and used to debug hypervisor software without the need for writing a dedicated hypervisor debugger that exists within the hypervisor for debugging the hypervisor.","The above as well as additional objectives, features, and advantages of the present invention will become apparent in the following detailed written description.","A preferred embodiment of the present invention and its advantages are better understood by referring to the figures, like numerals being used for like and corresponding parts of the accompanying figures.",{"@attributes":{"id":"P-00024","num":"00024"},"figref":"FIG. 1","b":["10","10","12","10","12"]},"In the depicted example, a server  is connected to network  along with storage unit . In addition, clients , , and  also are connected to network . Network  may include permanent connections, such as wire or fiber optic cables, or temporary connections made through telephone connections. The communications network  also can include other public and\/or private wide area networks, local area networks, wireless networks, data communication networks or connections, intranets, routers, satellite links, microwave links, cellular or telephone networks, radio links, fiber optic transmission lines, ISDN lines, T1 lines, DSL, etc. In some embodiments, a user device may be connected directly to a server  without departing from the scope of the present invention. Moreover, as used herein, communications include those enabled by wired or wireless technology.","Clients , , and  may be, for example, personal computers, portable computers, mobile or fixed user stations, workstations, network terminals or servers, cellular telephones, kiosks, dumb terminals, personal digital assistants, two-way pagers, smart phones, information appliances, or network computers. For purposes of this application, a network computer is any computer, coupled to a network, which receives a program or other application from another computer coupled to the network.","In the depicted example, server  provides data, such as boot files, operating system images, and applications to clients -. Clients , , and  are clients to server . Network data processing system  may include additional servers, clients, and other devices not shown. In the depicted example, network data processing system  is the Internet with network  representing a worldwide collection of networks and gateways that use the TCP\/IP suite of protocols to communicate with one another. At the heart of the Internet is a backbone of high-speed data communication lines between major nodes or host computers, consisting of thousands of commercial, government, educational and other computer systems that route data and messages. Of course, network data processing system  also may be implemented as a number of different types of networks, such as for example, an intranet, a local area network (LAN), or a wide area network (WAN).  is intended as an example, and not as an architectural limitation for the present invention.",{"@attributes":{"id":"P-00028","num":"00028"},"figref":"FIG. 2","b":["100","101","102","103","104","106","100","106","108","160","163","110","106","112","108","110"]},"Data processing system  is a logically partitioned data processing system. Thus, data processing system  may have multiple heterogeneous operating systems (or multiple instances of a single operating system) running simultaneously. Each of these multiple operating systems may have any number of software programs executing within in it. Data processing system  is logically partitioned such that different I\/O adapters -, -, , and - may be assigned to different logical partitions.","Thus, for example, suppose data processing system  is divided into three logical partitions, P, P, and P. Each of I\/O adapters -, -, , and -, each of processors -, and each of local memories - is assigned to one of the three partitions. For example, processor , memory , and I\/O adapters , , and  may be assigned to logical partition P; processors -, memory , and I\/O adapters  and  may be assigned to partition P; and processor , memories -, and I\/O adapters - may be assigned to logical partition P.","Each operating system executing within data processing system  is assigned to a different logical partition. Thus, each operating system executing within data processing system  may access only those I\/O units that are within its logical partition.","Peripheral component interconnect (PCI) Host bridge  connected to I\/O bus  provides an interface to PCI local bus . A number of Input\/Output adapters - may be connected to PCI bus . Typical PCI bus implementations will support between four and eight I\/O adapters (i.e. expansion slots for add-in connectors). Each I\/O Adapter - provides an interface between data processing system  and input\/output devices such as, for example, other network computers, which are clients to data processing system .","An additional PCI host bridge  provide an interface for an additional PCI bus . PCI bus  is connected to a plurality of PCI I\/O adapters - by a PCI bus -. Thus, additional I\/O devices, such as, for example, modems or network adapters may be supported through each of PCI I\/O adapters -. In this manner, data processing system  allows connections to multiple network computers.","A memory mapped graphics adapter  may be connected to I\/O bus  through PCI Host Bridge  and EADS  (PCI-PCI bridge) via PCI buses  and  as depicted. Also, a hard disk  may also be connected to I\/O bus  through PCI Host Bridge  and EADS  via PCI buses  and  as depicted.","A PCI host bridge  provides an interface for a PCI bus  to connect to I\/O bus . PCI bus  connects PCI host bridge  to the service processor mailbox interface and ISA bus access pass-through logic  and EADS . The ISA bus access pass-through logic  forwards PCI accesses destined to the PCI\/ISA bridge . The NV-RAM storage is connected to the ISA bus . The Service processor  is coupled to the service processor mailbox interface  through its local PCI bus . Service processor  is also connected to processors - via a plurality of JTAG\/IC buses . JTAG\/IC buses  are a combination of JTAG\/scan busses (see IEEE 1149.1) and Phillips IC busses. However, alternatively, JTAG\/IC buses  may be replaced by only Phillips IC busses or only JTAG\/scan busses. All SP-ATTN signals of the host processors , , , and  are connected together to an interrupt input signal of the service processor. The service processor  has its own local memory , and has access to the hardware op-panel .","When data processing system  is initially powered up, service processor  uses the JTAG\/scan buses  to interrogate the system (Host) processors -, memory controller , and I\/O bridge . At completion of this step, service processor  has an inventory and topology understanding of data processing system . Service processor  also executes Built-In-Self-Tests (BISTs), Basic Assurance Tests (BATs), and memory tests on all elements found by interrogating the system processors -, memory controller , and I\/O bridge . Any error information for failures detected during the BISTs, BATs, and memory tests are gathered and reported by service processor .","If a meaningful\/valid configuration of system resources is still possible after taking out the elements found to be faulty during the BISTs, BATS, and memory tests, then data processing system  is allowed to proceed to load executable code into local (Host) memories -. Service processor  then releases the Host processors - for execution of the code loaded into Host memory -. While the Host processors - are executing code from respective operating systems within the data processing system , service processor  enters a mode of monitoring and reporting errors. The type of items monitored by service processor include, for example, the cooling fan speed and operation, thermal sensors, power supply regulators, and recoverable and non-recoverable errors reported by processors -, memories -, and bus-bridge controller .","Service processor  is responsible for saving and reporting error information related to all the monitored items in data processing system . Service processor  also takes action based on the type of errors and defined thresholds. For example, service processor  may take note of excessive recoverable errors on a processor's cache memory and decide that this is predictive of a hard failure. Based on this determination, service processor  may mark that resource for reconfiguration during the current running session and future Initial Program Loads (IPLs). IPLs are also sometimes referred to as a \u201cboot\u201d or \u201cbootstrap\u201d.","Those of ordinary skill in the art will appreciate that the hardware depicted in  may vary. For example, other peripheral devices, such as optical disk drives and the like, also may be used in addition to or in place of the hardware depicted. The depicted example is not meant to imply architectural limitations with respect to the present invention.",{"@attributes":{"id":"P-00040","num":"00040"},"figref":"FIG. 3","b":["200","230","210","201","204","201","204","201","204","201","204","200"],"i":["a","a ","a","a "]},"Partitioned hardware  includes a plurality of processors -, a plurality of system memory units -, a plurality of input\/output (I\/O) adapters -, and a storage unit . Each of the processors -, memory units -, NV-RAM storage , and I\/O adapters - may be assigned to one of multiple partitions -.","Partition management firmware (hypervisor)  performs a number of functions and services for partitions - to create and enforce the partitioning of logically partitioned platform . Hypervisor  is a firmware implemented virtual machine identical to the underlying hardware. Firmware is \u201csoftware\u201d stored in a memory chip that holds its content without electrical power, such as, for example, read-only memory (ROM), programmable ROM (PROM), erasable programmable ROM (EPROM), electrically erasable programmable ROM (EEPROM), and non-volatile random access memory (non-volatile RAM). Thus, hypervisor  allows the simultaneous execution of independent OS images -by virtualizing all the hardware resources of logically partitioned platform . Hypervisor  may attach I\/O devices through I\/O adapters - to single virtual machines in an exclusive mode for use by one of OS images -","A debugger may be included in each operating system. These debuggers are existing pieces of software which may be utilized to debug the operating system in which the debugger resides. For example, operating system includes debugger . Operating system includes debugger . Operating system includes debugger . And, operating system includes debugger .","These debuggers were written to debug the operating system in which they are included. In prior art systems, these debuggers can access only the logical memory assigned to the partition within which the debugger resides. In the prior art, these debuggers could not directly access the physical memory, which is controlled by hypervisor .","According to the present invention, hypervisor extensions are added to an existing operating system debugger to enable the existing OS debugger to debug the hypervisor code. The extensions permit the existing operating system debuggers to directly access the physical memory space. The extensions are application programming interface (API) calls that can be invoked by the existing operating system debugger that then cause the hypervisor to perform specified low-level hypervisor operations such as reading from or writing to physical memory locations, reading from or writing to hypervisor registers, or any other hypervisor operation.",{"@attributes":{"id":"P-00046","num":"00046"},"figref":"FIG. 4","b":["400","402"],"ul":{"@attributes":{"id":"ul200001","list-style":"none"},"li":["int","h_debug_handler(\n    \n    ",")\n\nThe input parameter for this API is \u201chandler\u201d. This is the name of the event handler within the existing operating system debugger. The return values for this API are either a \u201c0\u201d to indicate that the event handler was successfully registered, or an \u201cENODEV\u201d parameter to indicate that hypervisor debugging is not enabled.\n"]}},"The process then passes to block  which depicts establishing a \u201cRead Physical Address Space\u201d API within the existing operating system debugger that will cause the hypervisor to read a physical address and return the value to the operating system debugger. The \u201cRead Physical Address Space\u201d API is another operating system extension. The following is an example of a \u201cRead Physical Address Space\u201d API:\n\n","Next, block  illustrates establishing a \u201cWrite Physical Address Space\u201d API within the existing operating system debugger that will cause the hypervisor to write a particular value into a physical address. The \u201cWrite Physical Address Space\u201d API is another operating system extension. The following is an example of a \u201cWrite Physical Address Space\u201d API:\n\n","Typically, an operating system and other software executing within a partition can gain access only to the logical memory assigned to that partition. The operating system and other software cannot normally directly access a physical address space. The two APIs described above permit an operating system debugger to read directly from or write directly to a specified physical address. These two APIs are used by an existing operating system debugger to gain direct read\/write access to the entire system's physical address space.","Thereafter, block  depicts establishing other APIs within the existing operating system debugger as hypervisor extensions to the existing operating system debugger. For example, an API could be established that would cause the hypervisor to read one of its registers and return the value to the operating system debugger. As another example, an API could be established that would cause the hypervisor to write a value specified within the API to one of the hypervisor's registers. The process then terminates as depicted by block .",{"@attributes":{"id":"P-00068","num":"00068"},"figref":"FIG. 5","b":["500","502","290"]},"If a determination is made that debugging is not enabled within the hypervisor, the process passes to block . Referring again to block , if a determination is made that debugging is enabled, the process passes to block  which depicts a determination of whether or not an event handler has been registered within the hypervisor. An event handler is code that resides within the OS debugger that is invoked asynchronously by the hypervisor to notify the OS debugger of events that may be of interest to the OS debugger. An event handler must be registered within the hypervisor in order to permit debugging by the existing operating system debugger. If a determination is made that an event handler is not registered with the hypervisor, the process passes to block .","Referring again to block , if a determination is made that an event handler is registered with the hypervisor, the process passes to block  which illustrates a determination of whether or not an event has been received by the event handler. If a determination is made that an event has not been received by the event handler, the process passes back to block . Referring again to block , if a determination is made that an event been received by the event handler, the process passes to block  which depicts the existing operating system debugger determining an appropriate debug action to take in response to the received event.","The operating system debugger process of determining an appropriate debug action is known in the art and is not described herein. Any suitable method of making such a determination may be utilized. Further, a user may make this determination instead of the operating system debug software.","Once an appropriate debug action is determined, the action is translated, as depicted in block , into low level hypervisor operations, such as read memory, write memory, read registers, write registers, etc. Again, the process of translating the debug action into appropriate low level hypervisor actions is known in the art and is not described herein.","Describing again the present invention, the process then passes to block  which illustrates the existing operating system debugger invoking API calls to cause the hypervisor to execute these low level operations. Next, block  depicts the hypervisor executing the low level operations and returning return codes and\/or data as required by the API calls invoked by the operating system debugger. Thereafter, block  illustrates the existing operating system debugger interrupting the information returned from the hypervisor as necessary. For example, the value stored in a particular physical address space is returned in response to invoking a \u201cRead Physical Address Space\u201d API. The existing operating system debugger should interrupt this information returned by the hypervisor. In response to invoking other API calls, a return value may be returned which should then be interrupted.","The process then passes to block  which depicts a determination of whether or not the hypervisor reported an error. For example, if debugging has been disabled by the service processor, a return code will be reported by the hypervisor indicating that the debugging option is not enabled. In response to a determination that the hypervisor reported an error, the process passes to block . Referring again to block , if a determination is made that the hypervisor did not report an error, the process passes to block  which illustrates a determination of whether or not to continue debugging. If a determination is made to continue debugging, the process passes back to block . Referring again to block , if a determination is made to discontinue debugging, the process terminates as depicted by block .","It is important to note that while the present invention has been described in the context of a fully functioning data processing system, those of ordinary skill in the art will appreciate that the processes of the present invention are capable of being distributed in the form of a computer readable medium of instructions and a variety of forms and that the present invention applies equally regardless of the particular type of signal bearing media actually used to carry out the distribution. Examples of computer readable media include recordable-type media, such as a floppy disk, a hard disk drive, a RAM, CD-ROMs, DVD-ROMs, and transmission-type media, such as digital and analog communications links, wired or wireless communications links using transmission forms, such as, for example, radio frequency and light wave transmissions. The computer readable media may take the form of coded formats that are decoded for actual use in a particular data processing system.","The description of the present invention has been presented for purposes of illustration and description, and is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain the principles of the invention, the practical application, and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The novel features believed characteristic of the invention are set forth in the appended claims. The invention itself, however, as well as a preferred mode of use, further objectives and advantages thereof, will best be understood by reference to the following detailed description of an illustrative embodiment when read in conjunction with the accompanying drawings, wherein:",{"@attributes":{"id":"P-00018","num":"00018"},"figref":"FIG. 1"},{"@attributes":{"id":"P-00019","num":"00019"},"figref":"FIG. 2"},{"@attributes":{"id":"P-00020","num":"00020"},"figref":"FIG. 3"},{"@attributes":{"id":"P-00021","num":"00021"},"figref":"FIG. 4"},{"@attributes":{"id":"P-00022","num":"00022"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
