---
title: Method for enhancing object-oriented programming through extending metadata associated with class-body class-head by adding additional metadata to the database
abstract: The invention relates to a method for enhancing an object-oriented programming language. The method includes declaring one or more class structures in databases having metadata describing characteristics defining the class structures. The method also includes extending the metadata associated with the class structures by adding any number of additional metadata to the databases.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07130863&OS=07130863&RS=07130863
owner: TableCode Software Corporation
number: 07130863
owner_city: Amherst
owner_country: US
publication_date: 20040617
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","TECHNICAL FIELD","BACKGROUND","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","Overview","1. The Class-Body Definition","2. The Class-Head Definition","3. The Application Definition","4. Extending the Object Hierarchy to Include an Application's Characteristics","5. Creating a Relationship Between the Data Object and the Project\/Document Object","6. The Extension Programming Language Used to Write Member Functions","7. Creating an Object-Oriented Structure in Memory from the Tables","8. Run-time Deployment of an Application","9. Resolving the Genericity (Parameterized Classes or Generics)","10. The Member Function Overloading","11. Reusability of Applications, Classes and Patterns","12. Techniques to Simplify the Development of an Application","13. Object Persistent Storage","14. Proxy Entity","15. Business & Industry Standards\u2014Predefined Reusable Database Tables","16. Project and Innovation Management","17. Apparatus (Virtual Engine) to Directly Deploy an Application","18. Operational Processes","19. Other Embodiments of the Present Invention","20. Hardware Architecture of a Computer System","21. Advantages of the Present Invention"],"p":["This application claims the benefit of U.S. Provisional Application No. 60\/505,908, entitled \u201cDirect deployment of an object-oriented application written as a set of relational database tables,\u201d filed Sep. 24, 2003. The provisional application Ser. No. 60\/505,908 is incorporated by reference herein.","The present invention relates to an object-oriented programming environment that uses relational database management system techniques for the software development.","Innovation in the modern business world is often an unquenchable necessity which demands more from, and imposes more complexity upon, software. Conventional software development is itself frequently a complex process typically consisting of authoring source code using a particular programming language. Most modern-day software applications are created using a high level object-oriented programming language (\u201cOOPL\u201d) such as C++, Smalltalk, or Java\u00ae. The object-oriented approach to programming subsists around \u201cobjects,\u201d which are structured software entities comprising, for example, data elements (or attributes) and methods (or functions). The attributes and functions can enable objects to model virtually any real-world entity in terms of the entity's characteristics. In object-oriented programming, the programmer traditionally designs a program as a set of cooperating objects rather than as a set of cooperating functions.","Although the object-oriented approach is generally intended to model objects and help create structure, current OOPLs instead, and perhaps ironically, typically require programming codes to be written in an unstructured text environment understood only by those skilled in the art of programming. That is, using a particular OOPL typically requires thorough familiarity with, and adherence to, grammatical rules, syntax and language for that OOPL, and written code can quickly become voluminous and hard to manage for a software project. As a result, the development, design, comprehension and\/or maintenance of software is often burdensome and difficult.","Further, software programs are conventionally compiled and delivered in binary format, which cannot be comprehended or modified. Finally, OOPLs typically do not support multi-applications documents. Instead, OOPLs generally support single application documents because they are produced for a single software application.","Thus, an expert in a particular field (i.e., a domain expert) or business usually cannot read, write, customize, enhance or modify an object-oriented program that the domain expert uses for personal or business computing.","Meanwhile, relational database tools currently represent a relatively mature and popular technology with which software developers and non-developers alike have extensive familiarity. Database tables are clean, self descriptive, intuitive and able to organize complex information while remaining easy to work with. Adding an object-oriented paradigm to database management systems (DBMS) has been known in the art for some time, and emerged as a new breed of database technology. However, software development continues to be done in the traditional, difficult, time-consuming, and costly way of text-based source code.","As software is increasingly looked for to be a vehicle and catalyst for innovation, the methodology for software development should be as simple as possible, yet still yield high quality applications. In other words, the true rewards of software lie in the destination (applications) and not the voyage (coding). Unfortunately, the voyage throughout the lifecycle of any software project using traditional development tools is, more often than not, a difficult and costly one\u2014inviting complexity with maybe a million lines of code, lowering productivity between developers trying to make the \u201cpuzzle fit,\u201d increasing costs, decelerating time-to-market, and widening the chasm between software development and domain knowledge. And, as generally difficult as it may be for a professional programmer to design, develop, deploy and manage software, it is nearly impossible for a domain expert or businessperson to do so using traditional OOPLs. The solution to these obstacles may be found in the language of tables.","Accordingly, a tabular software development environment that allows domain experts to author, deploy and manage object-oriented software applications is needed to solve the shortcomings of software and software development described above.","In one aspect, the invention relates to a method for enhancing an object-oriented programming language. The method includes declaring one or more class structures in databases having metadata describing characteristics defining the class structures. The method also includes extending the metadata associated with the class structures by adding any number of additional metadata to the databases.","In one embodiment, the declaring further includes declaring a class-head comprising class-head metadata describing characteristics defining the class-head. The declaring can also include declaring a class-body comprising body members. Each body member includes class-body member metadata in the plurality of metadata. The class-body member metadata describes characteristics defining the class-body member. The declaring a class-body further includes storing the class-body into rows and columns in one or more database. Each row represents a class-body member definition and each column represents metadata defining a single characteristic of the class-body member.","In one embodiment, the database storing the class-body member metadata includes a metatable. Further, the class-body member metadata can include object-oriented definition data for a class-body member. The class-body member metadata can also include relational database definition data for an attribute type and\/or definition data to store specific programming information about the class-body member. The class-body member metadata can also include definition data for classifying the class-body members into different categories.","The declaring of the class-head can also include declaring the metadata defining the characteristics of the class-head for each class and\/or extending the object-oriented metadata associated with the class-heads by adding additional metadata to the database. The method can also include organizing the metadata describing the class-head metadata into rows and columns, each row representing a class-head definition and each column representing metadata defining a single characteristic of the class-head. The database storing the class-head metadata can also include a metatable.","In one embodiment, the class-head metadata can include object-oriented definition data for a class-head. The class-head metadata can also include relational database definition data for a database table type. In yet another embodiment, the method includes storing programming information about the class in the class-head metadata. The classes can also be classified into different categories.","The metadata can also be updated to develop an object-oriented software application. In another embodiment, the method includes declaring metadata defining the characteristics for the software application in a database table. The metadata describing the software application can be organized into rows and columns of a database. The rows can represent a software application definition and the columns can represent metadata defining a single characteristic of the software application. In one embodiment, the database table further includes a metatable. The metadata definition can include a unique identifier for the software application.","The method can also include storing programming information about the application in definition data of the metadata definition. The method can also include using definition data to classify the software application into a category. The software application can also be deployed from the class structures and the metadata associated with the class structures. The method can also include reading the metadata and the any number of additional metadata for the software application.","In yet another embodiment, the method includes generating data structures in memory for each class structure. Each data structure can include metadata describing characteristics defining a software application, metadata describing characteristics defining the class-heads of the application, and metadata describing characteristics defining the class-body members for the classes of the deployed software application. In one embodiment, the method includes recursively resolving inheritance for the deployed application. Genericity for the deployed application and\/or for each class structure can also be recursively resolved.","In one embodiment, the method includes initializing instances of the data structures from the class-body member metadata. In one embodiment, a document manager application is used to create a document to be used as a container for instances created by applications used by the document. The method can also include using the software application metadata, the class-heads metadata, and the class-body metadata to dynamically create a menu system for the software application. In one embodiment, the method includes using the software application metadata, the class-head metadata, and the class-body members' metadata to dynamically create a help system for the software application. In another embodiment, the method further includes using the software application metadata, the class-head metadata, and the class-body members' metadata to dynamically create a user interface. In one embodiment, a domain expert extends the metadata by adding additional metadata to the databases.","A class is a description tool used in a program to define a set of attributes and a set of methods that characterize the members of an object. The definition of classes in OOPL is comparable to the definition of types in languages such as C or Pascal. For example, in C++ a class is defined as a structure that contains data elements as well as functions that manipulate these data elements.","The benefits of an object-oriented approach arise out of three basic principles: encapsulation, polymorphism and inheritance. Generally speaking, from a programming point of view, an object model is a unifying set of rules that describe object structure, object lifecycle, and inter-object communication. Object structure relates to the physical layout of objects in memory. Object lifecycle refers to how applications create and destroy objects. Inter-object communication refers to protocols by which objects communicate with one another. Most OOPLs do not specify true object models, but merely specify syntax and semantics of a basic object implementation without specifying the actual rules that unify object systems.","A goal of an embodiment of the present invention is to have an object-oriented programming environment (OOPE) to create software programs that can be designed and developed by a domain expert without, or with minimum help, from a software developer. The OOPE also is portable and platform independent. A software application created by the present invention can support inheritance, encapsulation, information-hiding, genericity or parameterized classes, and\/or operator overloading or polymorphism. In one embodiment, the present invention has debugging capabilities, modularity and object reusability.","The present invention was developed around the concepts of (1) defining the classes of an object-oriented program in a database table; (2) using well tested, reusable classes existing in libraries or repositories; (3) applying relational databases techniques to object-oriented programming; and (4) giving the objects' entities in the storage repositories a universal immutable Unique ID to create an environment where multi-applications can be used to place entities on the same document and where an object can be referenced from another document without loosing its identity.","Defining the Classes of an Object-Oriented Program in a Database Table","A table or a database is a repository of data that is self descriptive and holds a clean representation of data (or information). Traditional OOPLs are structured languages (i.e., a class is a structure) but this structure is represented in the source code as text\u2014a non-structured fashion. The present invention defines the classes in one or more database tables, enabling a self descriptive, clean presentation of the data. Moreover, when the data are stored in a database, several relational database techniques can be applied which can greatly enhance the capability of the object-oriented languages and systems. This may also have many other advantages including:\n\n","Using Well Tested, Reusable Classes Existing in Libraries or Repositories","One way to simplify the software development is to use well-tested, reusable classes existing in libraries or repositories. But in systems of prior art, it is often not an easy task for a developer to find, select and modify the required class to perform a certain task from these libraries, as normally he or she must carefully study these libraries before starting to modify its contents. The present invention describes means to organize and automate the usage of reusable classes by extending a class definition as follows:","A. The Purposes:\n\n","B. The Means:","The present invention also describes several means for extending the class definition horizontally and vertically.\n\n","Applying Relational Databases Techniques to Object-Oriented Programming","The present invention applies relational databases techniques to object-oriented programming, such as:\n\n","Giving the Objects' Entities an Immutable Universal Unique ID","Giving the objects' entities, in the storage repositories, an immutable universal unique ID (Entity Unique ID) based upon their Application ID, their Class ID and their Own Entity ID, as well as their Project ID and Document ID, creates an environment where multi-applications can be used to place entities on the same document, and where an object can be referenced from another document without loosing its identity.","Enabling the development of object-oriented software applications using the preferred embodiment of the present invention can be regarded as the execution of the several steps of  that represent the \u201cdesign stage\u201d of a software application, and of  that represents the \u201crun-time stage\u201d for the direct deployment of the software from the above design stage as follows:","Design Stage:  is a block diagram schematically depicting an embodiment of the present invention. The first step \u2013 depicts how the traditional C++ class definition  (a sample is shown in ) is represented in relational database tables . The metadata representing the class-head is stored as a record in the Application Table as seen in . The metadata representing each members of the class-body are stored in the Class Table as seen in . The second step \u2013 depicts how the metadata describing the characteristics of the class-head and the characteristics of the member of the class-body are horizontally extended with more metadata to represent additional characteristics for the class definition. These additional characteristics are used by the present invention to simplify the development of the application by classifying the classes and the members into different categories, to enable automating the reusability of classes.  further details these extended metadata representation of the class definition. The third step \u2013 in  depicts how the plurality of the classes that represent an application have their class-head characteristics stored in the Application Table. This Application Table is used to automatically link the different classes at run-time. The fourth step \u2013 in  depicts how the plurality of the applications on a computer system have their characteristics represented as metadata stored as records in the Software Catalog Table. This represents how the information about the classes is vertically extended by the metadata that represent their application. The fifth step \u2013 in  depicts the relationship between two applications used to create and\/or edit a user document. The first represents the Project\/Document Application, and the second represents the Data Application which is used to place entities in the document. This combination of the two application further vertically extends the metadata definition of the objects to enable further automation of the processes that compose a software application based on the characteristics of the Document\/Project used.  further depicts these two applications and their relationship.","Run-time Stage:  depicts a block diagram further illustrating how the different tables that represent a Document Application and a Data Application work together at run-time. The Software Catalog Table , Application Table , the Class Table , the functions' source code , and the user document  application are loaded in memory to form an object-oriented data structure for each object, and, together, represent a running program. The functions' source code  are compiled at run-time to platform independent bytecodes and saved in memory . The end-user opens or creates a document , and creates or selects a layout. The document data tables (e.g., as shown in ) are indexed and the indices are saved in memory . Pointers to the functions' bytecodes  and pointers to the data tables and their indices  are saved with the object-oriented data structure \u2013 for each object. Image for memories of the functions' bytecodes  and the tables' indices are saved as cache on a hard disk or any networked storage structure to increase performance when the document or the application is re-opened\/re-loaded at a later time. The detailed description of the present invention is now sub-divided into the following 21 sections.","Similar to the C++ OOPL, the class definition for the present invention has two parts: the class-head and the class-body.","The present invention defines the object-oriented class-body, with similarity to the C++ class layout, in a database table called the \u201cClass Table.\u201d This Class Table contains the metadata, or data about data, for object-oriented definitions of the class members.","Furthermore, the present invention extends the object-oriented C++ class member characteristics by adding more metadata to represent other, new characteristics to the member definition. This extended metadata includes:\n\n","As in a DBMS, the Class Table has a metatable. A metatable is a database table that defines (i.e., contains metadata about) another database table. Thus, the metatable is an underlying record source that specifies the format and contents of the records in the Class Table. Further, metatables can be nested.",{"@attributes":{"id":"p-0095","num":"0112"},"figref":"FIG. 1","b":["100","101","102","102","1","103","104","1","107","108","106","101","1","109","110","105","111","114","115","113","116"]},"For background purposes only,  demonstrates an embodiment of a traditional C++ class definition, composed of include files , a class-head , and a class-body \u2013. The class-body has a plurality of members, each defined either by standard keywords or metadata such as protected , public , double , void  and int ; or by the name of another class, \u201cother_object\u201d .",{"@attributes":{"id":"p-0097","num":"0114"},"figref":["FIG. 3","FIG. 3","FIG. 2"],"b":["302","202","207","2","301","201","204","303","304"]},{"@attributes":{"id":"p-0098","num":"0115"},"figref":"FIG. 7","b":["702","700","701","701","700","700","703"]},{"@attributes":{"id":"p-0099","num":"0116"},"figref":["FIG. 14","FIG. 15","FIG. 16"],"b":["1400","701","1400","700"]},{"@attributes":{"id":"p-0100","num":"0117"},"figref":["FIG. 15","FIG. 15-A","FIG. 15-B"],"b":["1500","1500"]},{"@attributes":{"id":"p-0101","num":"0118"},"figref":["FIG. 16","FIG. 16-A","FIG. 16-B"],"b":["1600","1600"]},"The information stored as columns in the Class Tables ,  of  and  may be classified into categories, such as:\n\n","Justification: In one embodiment, this is how the data in each field (column) is justified.","The Justification information can be, for instance, NotNull or Maximum\/Minimum values for real numbers and integers.","Moreover, all the above class members' metadata, except the MemberID, can be set to the keyword \u201cGeneric\u201d to support \u201cgenericity\u201d or parameterized classes. This is a more extended type of genericity than that used in the C++ programming language as it allows modifying the member name and the other characteristics of the members not used in C++.","The present invention defines the object-oriented class-head, as defined in the C++ OOPL class layout, for the plurality of classes that compose an application in a database table called the \u201cApplication Table.\u201d Each record in this Application Table represents a single class-head definition. Furthermore, the current invention extends the object-oriented C++ class-head characteristics by adding more metadata to represent other, new characteristics to the class-head definition. This extended metadata includes:\n\n","As in DBMS, the Application Table has a metatable (underlying record source) that specifies the format and contents of the Application Table records.","This Application Table, besides storing the characteristics of the class-heads, also serves to list the classes to be linked at run-time to form the application.",{"@attributes":{"id":"p-0109","num":"0178"},"figref":["FIG. 4","FIG. 4","FIG. 4","FIG. 4"],"b":["208","403","401","403","402","406","405","404"]},{"@attributes":{"id":"p-0110","num":"0179"},"figref":"FIG. 6","b":["602","600","601"]},{"@attributes":{"id":"p-0111","num":"0180"},"figref":["FIG. 12","FIG. 13"],"b":"1200"},{"@attributes":{"id":"p-0112","num":"0181"},"figref":["FIG. 13","FIG. 13","FIG. 13-A","FIG. 13-B"],"b":"1300"},"The information stored in each column in the sample Application Table  of  is detailed as follows:\n\n",{"@attributes":{"id":"p-0114","num":"0187"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Access in","Base Class","Access in"]},{"entry":[{},"Base Class","Inherited as","Derived Class"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Public","Public","Public"]},{"entry":[{},"Protected",{},"Protected"]},{"entry":[{},"Private",{},"No access"]},{"entry":[{},"Public","Protected","Protected"]},{"entry":[{},"Protected",{},"Protected"]},{"entry":[{},"Private",{},"No access"]},{"entry":[{},"Public","Private","Private"]},{"entry":[{},"Protected",{},"Private"]},{"entry":[{},"Private",{},"No access"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"ul":{"@attributes":{"id":"ul0023","list-style":"none"},"li":[{"@attributes":{"id":"ul0023-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0024","list-style":"none"},"li":["d. Parameters  in  is specified by the record which has MetaID equal to 10 in . A \u201cnon-null value\u201d specifies that a class is a template class. This is a list of class members' metadata values separated by commas as seen in . The \u201cParameters\u201d are distinguished by the order of appearance of the keyword \u201cGeneric\u201d in the corresponding Class Table defining the members of the class.","e. Virtual  in  is specified by the record whose MetaID is equal to 11 in . This is a Boolean value set to True or False and may specify a base class as virtual."]}},"2. Object-oriented information not having similarities to the C++ grammar for the class-head declaration:\n    \n    ","3. Other information:\n    \n    "]}},"Moreover, all the above class-heads' metadata, except the OID, can be set to the keyword \u201cGeneric,\u201d to support \u201cgenericity\u201d or parameterized types. This is a more extended type of genericity than that used in the C++ programming language as it allows modifying the class name and the other characteristics of the members not used in the C++.","The present invention also stores information about the plurality of applications, made from the present invention, on a computer network in a database, called the \u201cSoftware Catalog Table.\u201d These are:\n\n","In one embodiment, this Software Catalog Table, besides storing the characteristics of an application, also defines and stores the inheritance relationship between applications to simplify the development of the software applications.","As in DBMSs, the Software Catalog Table has a metatable (underlying record source) that specifies the format and contents of the Software Catalog Table's records.",{"@attributes":{"id":"p-0119","num":"0220"},"figref":"FIG. 5","b":["502","500","501"]},{"@attributes":{"id":"p-0120","num":"0221"},"figref":["FIG. 10","FIG. 11"],"b":"1000"},{"@attributes":{"id":"p-0121","num":"0222"},"figref":["FIG. 11","FIG. 11-A","FIG. 11-B"],"b":["1100","1100"]},"The information stored in each column in the sample Software Catalog Table of  is as follows:\n\n","Other roles for the applications are added when needed.\n\n","The present invention extends the definition of the object hierarchy of the object as shown in the following figures:",{"@attributes":{"id":"p-0125","num":"0241"},"figref":["FIG. 8-A","FIGS. 5\u20137"],"b":["801","802","801"]},{"@attributes":{"id":"p-0126","num":"0242"},"figref":"FIG. 8-B","b":["810","812","816","820","822","824","826","828"]},{"@attributes":{"id":"p-0127","num":"0243"},"figref":["FIG. 9","FIGS. 5\u20137"]},"The Design Stage is where an application modeler\/domain expert of an application fills the tables with information. This stage contains the details of the three levels defined in FIG. -A. Each level has a metatable , ,  that defines the tables , ,  which contain the records , ,  for each Application, Class or Member as designed by the application modeler\/domain expert.","The Run-time Stage is where an end-user instantiates an object according to his or her specification  as designed by the application modeler\/domain expert in the design stage. The objects instantiated  are placed as records  in the Objects' Data Table  which is located in a document folder  that is specified by an end-user. In one embodiment, only the fields  (attributes) of the object which have scope-level equal to \u201cInstance-Level\u201d are stored. The Document Manager Object  is an object independent of the data application, and has a Layout relationship , a Layer relationship  and other common properties' relationship . The Document folder \u2014which can be a folder or an archive file\u2014the Layer  and the layout  are created, defined and selected by an end-user prior to instantiating the objects . The entities placed in the Data Table  have complex unique IDs which are composed of the current application (AID), the current class (OID), the current layout (LID), and the current entity unique ID (EID). This design enables placing entities in a document having different applications and different layouts or space model.","To increase modularity of software programs and to extend the documents' capabilities to include instances created from several Data Applications, one embodiment of the present invention divides a created program into two separate objects simultaneously loaded at run-time: (a) the \u201cDocument Manager Object\u201d and (b) the current \u201cData Object.\u201d These objects work together at run-time, each with a specific task, as follows:\n\n","The values of the data members (attributes), the function members and the metadata at the three levels for both the Document Manager Object and the Data Object are visible to each other at run-time.","An example of the object hierarchies is shown in , -A, -B and -C.  is composed of two parts: The left-side part is shown in , and the right-side part is shown in .  collectively depicts an embodiment of a fragment of a sample Line Class Table  (\u201cSchLine.pdf\u201d of ) after being loaded at run-time in memory, and wherein the class inheritance as specified in the class-head stored in the Application Table of  (under  and ) has been solved as follows:\n\nObjectName=Line (OID=3) inherits OID=1(EntityHeader)\n\nThe members of the two classes are concatenated at run-time according to their virtual status. Multi-inheritance is resolved the same way.\n",{"@attributes":{"id":"p-0133","num":"0258"},"figref":["FIG. 17-C","FIG. 17","FIG. 11-A","FIG. 13-A","FIG. 13-A"],"b":["1713","1725","1101","1301"]},{"@attributes":{"id":"p-0134","num":"0259"},"figref":["FIG. 25-A","FIG. 9"]},{"@attributes":{"id":"p-0135","num":"0260"},"figref":["FIG. 25-B","FIG. 9"],"ul":{"@attributes":{"id":"ul0034","list-style":"none"},"li":["1. The Document Manager Object  has the same tasks as described in the previous section 4 and in . Further, the Document Manager Object  works as a host for the Project\/Document Object  and the Data Object . In one embodiment, at run-time this Document Manager object is loaded first in memory.","2. Project\/Document Object  with tasks to specify the project and document definition from a Document Application  and  with ApplRole , =Document. In one embodiment, at run-time this object is loaded second in memory.","3. Data Object  specifies the definition of the data entities from a Data Application ,  with ApplRole , =Data. In one embodiment, at run-time this Data Object is loaded third in memory. Other tasks of the Data Object may include:\n    \n    "]}},"The values of the data members, the function members and the metadata at the three levels for the Document Manager Object , the current Project\/DocumentObject  and the Current Data Object  are visible to each other at run-time. In one embodiment, the metadata variables of the Document Manager Object  are loaded first in memory before the Data Application; hence the Document Manager Object can be used to send metadata information for genericity use. For example, this metadata information can be used to automatically modify parametric class-heads and parametric class-members during loading a new Data Application.  further depicts this relationship between the Document Application  and the Data Application .","Furthermore,  is a flowchart illustrating an embodiment of the details of the hierarchical relationship of the three levels (as shown in ) that compose the entire source code of a Data Application, and wherein their relationship with the Documents Manager Object ,  has been extended to include a hierarchy defining the Project\/Document Object ,  as follows:\n\n","The following is an example of an embodiment of how the Document DID and the Object OID work together at the Run-time Stage:\n\n","The relationship between the Project Object and the Document Object is illustrated in . The Project Object  defines the characteristics of a project, and has one or more Document Object. Instantiated Project Objects are saved in a table in, for example, the Corporate Standard Directory. The Document Object  defines the characteristics of a Document. Instantiated Document Objects are saved in a table in the Project Directory.","The advantages of creating a relationship between the Project\/Document Object and the Data object may be summarized as follows. First, metadata defining and classifying the Project\/Document Application may be used as parameters to a Data Application to customize its Parameteric Data Application, its Parameteric Data Classes and its Parametric Data Class Members (see Genericity in section 9 below). Second, metadata holding information about the Project\/Document Object may be used as parameters to member functions of the Data Object. It is also possible to customize the type of Data Applications to use with each type of Project according to its classification.","The present invention describes authoring the class-head and class-body of an object. The member functions present in the Class Table are defined as links to their source code in an external file in which they are written using an extension programming language. The extension programming language can be with or without object orientation paradigms.","One embodiment of the present invention uses a non-OOPL such as, for instance, \u201cMINERtools,\u201d developed by Expert-InfoCAD of Amherst, N.H. with some additional, extended functionalities. The non-OOPL can have different libraries of low level routines system functions and\/or debugging capabilities. Examples of the extended functionalities include the following:\n\n","One embodiment of the present invention contains a run-time compiler that compiles the member functions to platform independent bytecodes. To increase performance of a created program, the steps for executing a member function are as follows:\n\n","At run-time, when an application is selected from the Software Catalog Table (for example the Application  \u201cCorpCAD\u201d in  column ), the application metadata is loaded in memory as a structure , . The corresponding application file, \u201cApplFile,\u201d (corp-cad.dbf shown  column ) is opened and the class-heads' characteristics from the Application file (Corp-Cad.pdf shown in , ) are loaded in memory to form an array of object-oriented sub-structures ,  (class  to n) to the structure . And, for each class-head, its \u201cClass-File\u201d ( column ) is opened and the class-members are loaded as another sub-structure ,  (member  to n) to the structures . Each class table is represented by Items , , . In one embodiment, Abstract Classes (e.g.,  column ) are not loaded in memory except when they are called by inheritance (column ) from a concrete class (column ). At run-time, when loading a class-head to store it in the object-oriented structure, if the class-head contains inheritance , it is resolved first, i.e., the members of the inherited super-class (attributes and methods) are read and loaded into memory in the object-oriented structure, recursively, and from left to right before loading the derived-class members. If a member (attribute or method) has the same name (Title) as a member that is already loaded in memory for the same object, the previously loaded attribute can be overwritten and replaced by this attribute according to the virtual properties of the member and the object, with similarity to the C++ OOPL grammar.","An example for loading a class object-oriented structure that has inheritance is illustrated in , ,  and . The Application Table ( of ) for this sample CAD application is loaded first in memory, followed by loading the objects as listed in the column entitled \u201cObjectName\u201d ( column ) from top to bottom as follows:\n\n","The remaining classes shown in  are similarly loaded. BrickWall Object (OID=11) has multi-inheritance equal to the OID  and . It has the Object \u201cLine\u201d (OID=3) as a supper-class which recursively has the \u201cEntity Header\u201d (OID=1) as another super-class. First, the \u201cEntityHeader\u201d schema is loaded, followed by the \u201cLine\u201d schema (OID=3); then the \u201cWall\u201d schema (OID=6)\u2014as the second inheritance\u2014is loaded.","Loading the application classes' object-oriented structure in memory is similar to linking the objects during building an application in the C\/C++ programming languages.","Genericity for parameretized applications, classes and members are resolved after resolving all the inheritances (again, more details on genericity are illustrated in section 9 below).","As described in the above sections, the object-oriented class declarations are saved in database tables which are structured files representing the class object-oriented structures. This allows loading the classes' object-oriented structure of an application directly in a computer memory without the need for compilation, using techniques similar to that used in DBMS. The loaded classes' object-oriented structure, together with the member functions compiled at run-time, represent a running program.","A main advantage of directly deploying the application from its source code is that it creates an open system representing an application in self-descriptive database tables. \u201cOpen\u201d here refers to both the straightforward recognition of data in tables (as opposed to having to understand and master language rules of traditional OOPL) and to the unconcealed nature of the deliverables that the present invention may beget (i.e., delivering pre-deployed applications as tables as opposed to the closed binary format which is common in the commercial software industry). Hence, the present invention has much more clarity in the codes than conventional OOPLs and directly produces a running program which may be easily customized, modified or added to by subsequent users. Such an open system can spur and foster innovation by domain experts in an ad-hoc fashion similar to the conventional database techniques.",{"@attributes":{"id":"p-0151","num":"0304"},"figref":"FIG. 18-B","b":["1802","1803","1807","1811","1801","1811","1810","1801","905","1809","1802","1813","1803","1807","1810"]},{"@attributes":{"id":"p-0152","num":"0305"},"figref":["FIG. 19","FIG. 14","FIG.14"],"b":["1901","1902","1903","1904","1905","16","1906","4","1907","1908"]},{"@attributes":{"id":"p-0153","num":"0306"},"figref":"FIG. 20","b":["2001","2002","2003","2004","2005","2006","2010","2007","2008","2009","2002"]},"Another advantage of the current invention over traditional applications is that it saves with each object its universal unique ID in the persistence repository, and is also saved with the image of entities in the display list. The entity's universal unique ID is a complex string containing the application ID and the class ID from where this entity was instantiated. This allows creating an end-user document which is created or edited using more than one application. This, in turn, permits the creation of small size applications that can be used as reusable components of a larger virtual application\u2014composed of the smaller applications\u2014selected by an end-user at run-time.",{"@attributes":{"id":"p-0155","num":"0308"},"figref":["FIG. 21","FIG. 14"],"b":["2101","2102","16","2103","2104","2105","2106","2107","2108"]},{"@attributes":{"id":"p-0156","num":"0309"},"figref":"FIG. 22","b":["2201","2202","2203","2205","2206","2204","2207","2208","2202","2209","2208","2209","2202"]},"If an end-user selects an entity from the graphic screen, its Entity Unique ID is retrieved from the display list as saved in memory; and the entity information is retrieved from the entity table .",{"@attributes":{"id":"p-0158","num":"0311"},"figref":"FIG. 23","b":["2301","2302","2303","2305","2306","2304","2307","2308","2309","2302"]},"The present invention uses two methods to support parameterized classes. \u201cGenericity\u201d herein means a way to pass information from a low level table to a higher level table in order to change the structure or the inheritance of a template class. The present invention details two methods to apply genericity as follows:","1. Parameters Method: Passing Parameters from Low Level Tables to the Next, Higher Level Tables.","Referring to , the metadata at level 2  and level 3 , except the Object IDs and member IDs, can be assigned the keyword \u201cGeneric\u201d by the application modeler, to be replaced by a parameter passed from a lower level at run-time to support \u201cgenericity\u201d or parameterized types. The parameters are stored in the lower level in a column called \u201cParameters\u201d that stores a parameters list. A non-null value in this column specifies that the class called by this record is a \u201cTemplate Class.\u201d The parameters list is distinguished by the order of appearance of the keyword \u201cGeneric\u201d in the corresponding Application Table or Class Table defining the members of the class-head and class-body, respectively. This is a more extended type of genericity than that used in the C++ OOPL. The parameters, passed to the class-head or the class-body, compose the signature for the class to support class overloading as well as the needed function overloading if the parameters to the function contain metadata.  is a diagrammatic representation of a fragment of one preferred embodiment of the present invention that depicts how this \u201cParameters Method\u201d works to support parameterized classes. The Software Catalog Table , at level 1, has the column  called \u201cParameters.\u201d The record with AID=6, for the application \u201cMyAppl\u201d which has a link to an ApplFile table \u201cMyAppl.dbf,\u201d contains a list of four parameters in the Parameters column .  demonstrates how the parameters list at level 1 replaces the fields at the next, higher level in the table \u201cMyAppl.dbf\u201d for each instance of the keyword \u201cGeneric\u201d in the table, in the order it appears in that table from top to bottom and left to right (as, for example, the first element in the list \u201cInsert\u201d replaces the first occurrence of the keyword \u201cGeneric\u201d in the cell ). Similarly, the Class Table  \u201cMyAppl.dbf\u201d at level 2 also has a column called \u201cParameters\u201d . The record with OID=4 for the class \u201cEntityB\u201d which has a link to a ClassFile \u201cEntB.dbf\u201d table contains, in the Parameters column, a list of three parameters .  also demonstrates that this parameters list at level 2 replaces the fields at the next, higher level in the table \u201cEntB.dbf  for each instance of the keyword \u201cGeneric\u201d in the table, in the order it appears in that table from top to bottom and left to right (as, for example, the second element in the parameters list \u201cCA.dbf\u201d replaces the second occurrence of the keyword \u201cGeneric\u201d in the cell ). A sample use of the above method is shown in .","2. Metadata-Variable Method: The Parameters from a Lower Level Table to Any of the Higher Level Tables are Passed as Metadata Variables.","A metadata variable is the metadata field's title preceded by a particular character such as the dollar sign operator (\u201c$\u201d) as, for example, the variable \u201c$Authorization.\u201d  is a diagrammatic representation of a fragment of one preferred embodiment of the present invention that depicts how the Metadata-Variable Method works to support parameterized classes. The Software Catalog Table , at level 1, has the column  called \u201cAuthorization.\u201d The record with AID=6 for the application \u201cTheAppl\u201d which has a link to an ApplFile table \u201cTheAppl.dbf\u201d contains a value=16 for the Authorization field . The linked file \u201cTheAppl.dbf\u201d  has a column with title Auth_level, that has a value equal to $authorization for the record with OID=3. The word $authorization is a variable for the metadata, from the table  at level 1 having a value=16. The value for Auth_Level field  for the record with OID=3 is set to 16. Similarly, an embodiment of the table \u201cEntA.dbf\u201d  at level 3 has fields set to values by metadata variable as follows:","$authorization  at the record with MID=2 receives a value of 16 from level 1.","$auth_level  at the record with MID=5 also receives a value of 16 from  at level 2.","$transaction  at the record with MID=5 receives a value of TransacA.","Another embodiment of a similar table \u201cEntB.dbf\u201d  at level 3 has fields set to values by metadata variable as follows:\n\n","Moreover, the present invention also enables passing parameters from the Document Application to the loaded Data Application into this document to any of the three levels 1, 2 and\/or 3. For example, the metadata variables used in the \u201cDocs Manager\u201d for the currently-loaded document from the Projects Catalog Table  (level 1) and the Project Table  (level 2) can also be used as variables\u2014at any level\u2014in the Data Application Tables loaded at run-time.","If two fields have the same Title at different levels, the value of the lower level prevails and is used. Similarly, if two fields have the same Title in the Applications Table and the Docs Manager Table, the value in the Docs Manager Table prevails and is used.","A function is declared once in the Class Table with a return type but without parameters. The function is defined in the source code file. The function can have more than one definition with several parameter signatures. The signature also includes the ID of the calling object. This allows the modeler to create different versions of the object using genericity or parametric classes. In one embodiment, the member functions are called from two locations: from within another function or from the menu system as follows:","a) Calling a function from within another function, with the required parameters that match any of signatures the functions defined in the source code file. If no matching signature was found, an error is issued; or","b) Calling a function from the dynamically created menu system: The members' functions are then called with no parameters or a NULL.","Functions called with a NULL parameter\u2014either from the Menu or from another function\u2014search for their definition with a NULL parameter and use it. Otherwise, an inference engine that matches each of the source code functions' parameters name with the current class-member name uses its value (if this is not NULL) until the parameters of a function are satisfied; or else an error message is issued.","Reusable classes and reusable patterns (i.e., patterns of source code) as, for example, parameterized classes, are well known in the software development arts. The present invention also extends the reusability to applications.","Reusable Classes","The virtual engine, detailed below and which is part of an embodiment of the present invention, is provided with libraries of the most common reusable classes. In one embodiment and for programming languages that are designed to allow application programs to be built that can be run on any platform without having to be rewritten or recompiled by the programmer for each separate platform, the virtual engine is software that mimics the performance of a hardware device and acts as an interface between the application program and the microprocessor (or hardware platform) that actually performs the program's instructions. An example of such application programs are the programs written with the Java\u00ae programming language (developed by Sun Microsystems, Inc. of Santa Clara, Calif.). For many of these reusable classes, more than one type or mode may exist in the libraries. For example, for a locking mechanism, there are:\n\n","And, because the present invention is an open system that can easily be understood and enhanced, these libraries can grow larger over time by the participation of domain experts and other users from different disciplines.","Moreover, the virtual engine of the current invention also has the capability to use operating system compatible class libraries stored on a computer system as archives of sharable objects\u2014or as dynamic link libraries (dll files)\u2014by providing the name of the class library in the column \u201cMap_Lib\u201d (not shown in the drawings) in the Application Table, and creates a class table defining the members (with similar names) that are needed for an application. These are, for example, the different Microsoft Foundation class libraries, developed by Microsoft Corporation of Redmond, Wash., or the Rogue Wave reusable object-oriented libraries developed by Rogue Wave of Boulder, Colo.","Reusable Applications","An advantage of the present invention over traditional OOPLs is that the present invention adds information about an application in the Software Catalog Table and such information is inherited by each object used by an application. Having the characteristics for each application defined separately in a table (Software Catalog Table representing the application characteristics or Application-Head) allows one or more of the following:\n\n","One goal of the present invention is to provide a programming environment that enables an expert in a certain field to design, author and\/or enhance his or her own software program without, or with minimum help, from a professional software programmer. However, there are aspects of software development which go beyond the scope of one's domain expertise, but which are needed, however routine they may be, for the full realization of a functional application. These may include the creation of a user interface, icon, a help system and several common routines for a certain type of application. For this purpose, the present invention details methods and techniques to simplify the development of many parts of an application to be within the functional capacity of the domain expert or application modeler as much as possible.","The following is a list of techniques used by an embodiment of the present invention. Some of these techniques have been described above.","1. First, the present invention defines the classes of an application in RDB tables. This by itself is a major simplification to software development because database tables are self-descriptive, clean, have clarity and allow editing in an ad-hoc fashion. The different tables needed to define the classes are created using standard forms previously saved in metatable. These forms guide the domain expert or modeler, during input, on how to fill the tables with the metadata information, and can also be used to automatically check on the syntax and integrity of the input metadata.","2. Another benefit for defining the class declaration in RDB tables is applying proven techniques used in RDBMS to the object-oriented software development to directly deploy an application without compilation of the source code, as detailed in sections 7 and 8 above. Moreover, applying indexing and memory management to the object-oriented data structure similar to the proven techniques used in the RDBMS increases performance, even amidst quantitiave complexity as these techniques can handle very large data. Further, as mentioned already, directly deploying an application from the source code without creating an intermediate binary file creates an open system. Also, the present invention programming environment provides a run-time tool to track and display the changes in the current class data members' values, and to track the local variables inside a running member's functions.","3. The present invention provides a means to create a new application that inherits one or more applications, as described above (e.g., the Inherit metadata illustrated in  row  and , ). This feature greatly facilitates the software development.","4. Moreover, the virtual engine detailed with the present invention has intelligence at run-time to recover from missing information. For example, a class-member with a \u201cNotNull\u201d metadata set to \u201cON\u201d automatically prompts an end-user for the member value, as explained in section 1 above.","5. Moreover, an intelligent inference engine can match an overloaded function with the appropriate parameters, as explained in section 10 above.","6. Adding more intelligence, organizing and managing software on a computer system is possible by extending the object hierarchy to incorporate additional information about the application itself for classifying and describing its type (as defined in section 4) which is inherited by the objects used by the application and thus can be used to modify their behavior using parametric classes.","7. Moreover, the present invention details techniques to add more intelligence, and means to organize and manage the projects and documents created by the object-oriented applications on a computer system through the additional hierarchies of classes for the project and the document linked with the software applications, as detailed in  and . Characteristics of projects and objects are linked to the application's objects and thus can be used to modify their behavior by passing parameters or using metadata variables.","8. The domain expert or modeler can classify the objects and the members of the classes into different categories by using the database-enabled capability to add metadata in an ad hoc fashion. This additional metadata can be used to facilitate the development of the software as follows: (a) Proper classification enables the built-in functions in the virtual engine to select and call the proper routines\u2014with the proper parameters\u2014as intended by the modeler, directly from the information in the tables, without writing source code; (b) The current invention has Genericity or parameterized type (similar to template classes in C++) capability which can be defined in the Software Catalog Table, the Application Table, the Class Tables and\/or the Documents Tables; (c) The modeler can use metadata to classify the projects, the documents, the applications, the classes, and the class-members into different categories to enable using common functions and\/or common objects for these categories, and which may be automatically selected at run-time according to their categories; (d) The modeler can use metadata to store information about the projects, the documents, the applications, the classes or the class-members. This information can directly be passed as parameters to member functions or a program's pre-built system functions.","9. As detailed above, defining an object according to the present invention is composed of creating a Class Table containing different members of the class, and writing the member functions in a source code file. The member functions, for a certain object, handle a set of operations that may be performed on the object. These operations are divided into two types:\n\n","10. The object universal identifier defines the object instance, its class and application, as well as the document and project where it is located. Thus, this universal identifier can be used to hyperlink or to reference the object from another specified or remote location in the same or another document. Users can activate and edit or query this object from the specified location. Three types of links can be used: (a) a normal hyperlink, similar to that used in markup languages, i.e., the link is attached to another object or element; (b) a View-link, for objects that have proxy image, the image is displayed at the specified location, and the view can have different properties such as scale, rotation and color; and (c) a Copy-link where an insert entity referencing the object is inserted at the new location, and similar to the View-link the proxy image is displayed at the new location, but a new identical entity occurrence is inserted at the new location (the new entity occurrence can have its own scale, rotation and other properties). Similarly a whole document can be referenced or linked using its Document identified.","The present invention has techniques to automate and facilitate the usage of reusable classes and patterns by using database table capabilities to add, in an ad-hoc fashion, (a) metadata to classify the objects and the members of the classes and (b) metadata containing information specific for a project, document, application, object or class-member. Proper classification enables a program created by the present invention to select and call the proper routines, with the proper parameters, as intended by the modeler, directly from the information in the tables, without writing source code.",{"@attributes":{"id":"p-0194","num":"0361"},"figref":"FIG. 24","ul":{"@attributes":{"id":"ul0053","list-style":"none"},"li":["1. Application (level 1) : Additional metadata stored in the Software Catalog Table . In one embodiment, two types of metadata are used to simplify the object-oriented development as follows:\n    \n    ","2. Object (level 2) : Additional metadata stored in the Application Table . In one embodiment, two types of metadata are used to simplify the object-oriented development, such as the following:\n    \n    ","3. Member (level 3) : Additional metadata stored in the Class Table . In one embodiment, two types of metadata are used to simplify the object-oriented development, such as the following:\n    \n    "]}},"An example demonstrating how the above techniques are used is illustrated in .  depicts an embodiment of a flowchart of the steps performed when an object is instantiated. The information in the class object metadata, as designed by the modeler, is used to automate selection of methods from different, pre-existing standard options available in a library. These methods are the common functions that are used by most of the traditional database management systems. The metadata name and ID used in this example are from  and . This is illustrated as follows: when an object is instantiated (step ), (a) it gets the name of the permission function (step ) to use as saved in the object metadata AID.OID!Auth-Level; (b) it gets the name of the locking function (step ) to use as saved in the object metadata AID.OID!Locking; (c) it gets the name of the recovery function (step ) to use as saved in the object metadata AID.OID!Recovery; (d) it gets the name of the transaction function (step ) to use as saved in the object metadata AID.OID!Transaction; and finally, (e) it gets the type of the repository (step ) to use as saved in the object metadata AID.OID!StorageType.","A second example demonstrating how the above techniques are used to create a dynamic menu system based on classification of the object by the modeler is shown in , which represents a sample menu created for a CAD system. The methods to create this menu are detailed as follows:\n\n","The present invention is an OOPE that mainly operates on data. Data persistence beyond the lifetime of a single program execution, if required, may be saved in any format required by a modeler. In one embodiment, the members of a class that have a scope level equal to \u201cinstance\u201d are stored. A user document is saved on the hard disk in a folder or in an archive file, both of which will have a document name. The instances created for each of the Concrete Objects that are listed in the Application Table are saved in their own file format as specified in \u201cStorageType\u201d (e.g., StorageType  shown in ).","The present invention has several techniques to facilitate the development of object persistence, such as the following:\n\n","An embodiment of these techniques is summarized as follows:\n\n","Some graphical entities, such as vector graphics (CAD) entities and raster (pixels) images, have an image that can be displayed on the screen or printed. An image proxy object may be used that has the same universal unique EID as the entity in the database, has its own methods to display itself when queried to do so, and act as a stand-in for the real image. The proxy entities are maintained in a separate database called the \u201cdisplay list.\u201d A record added to the database document may also have its image composed of one or more display records added to a display list database. These display records can hold the object universal unique EID. The virtual engine detailed in the present invention has a built-in display list management system that includes navigation tools on the document proxy image on the screen and entities-selection capabilities. The member functions in proxy objects should specify how the object displays using the system functions supplied with the graphic functions library.","The display list may be maintained in memory in binary format. The display list can be regenerated from the document database. And the display list for each document can also be dumped on the hard disk as binary files for each table, for increased performance during re-opening of the document database. Provision is provided to re-create any Concrete table display list if its Database-table file has a more recent creation\/modification date than the saved display-list file.",{"@attributes":{"id":"p-0202","num":"0430"},"figref":"FIG. 26","b":["2603","2604","2605","2606","2607","2608"]},"Reusability is not only for the application and classes. The current invention extends reusability to information saved in the database tables. During designing an application, the developer or modeler can instantiate many of the objects that compose the application to place some constraint on the data that the end-user uses, in his or her design of the document, to force some business standard to be applied in order to increase performance, quality and productivity.","In one embodiment, the object classes defined in the Application Tables are sub-divided according to the object role (ObjRole ) that they perform in the application into four categories:\n\n","The above categories can be empty tables and filled or edited by the end-user at run-time if permission for such edit is granted as defined in the \u201cAuth\u201d metadata (e.g., \u201cAuth\u201d metadata  in ).",{"@attributes":{"id":"p-0206","num":"0438"},"figref":"FIG. 27-A","b":["2703","2702","2701"]},{"@attributes":{"id":"p-0207","num":"0439"},"figref":"FIG. 27-B"},{"@attributes":{"id":"p-0208","num":"0440"},"figref":"FIG. 32","ul":{"@attributes":{"id":"ul0072","list-style":"none"},"li":["1. Each end-user has his or her own directory called the \u201cUser Folder\u201d . The User Folder contains one or more projects, each project has a folder and this folder is the \u201cSmall Project Folder\u201d . Each small project has one or more folder for each document. This is the current \u201cDocument Folder\u201d .","2. Each business, office or group has a Standard Directory. This is called the \u201cCorporate\/Standard Folder\u201d  and is designed to be a directory in which corporate and office standard files, shared files and data common to all projects are stored. In a network environment, it is a directory on the network so that common office standard data may be found and used by everyone on the network. The standard directory also has a folder for each large project shared by several users called the \u201cLarge Project Folder\u201d  and this contains one or more document folders .","3. The program files directory called the \u201cProgram Folder\u201d  is where the virtual machine program may be installed, contains files common to all users and contains also the reusable applications and classes provided with the virtual program. It also contains the main standard applications that are adopted by a firm.","4. An Internet directory called the \u201cInternet Folder\u201d  is a directory or repository on the World Wide Web, accessible to users of the virtual engine. The repository is constantly managed and updated by the virtual program vendor. It contains reusable applications and reusable classes that have been tested and approved by the vendor and\/or a selected a group of end-users and domain experts."]}},"In one embodiment, the User Folder and Corporate\/Standard Folder are defined to a running program by the two Environment Variables saved during installation of the virtual program in an .ini file or in a .cshrc or .login file for a specific end-user. At run-time, the currently-loaded document defines the Document Folder and the Project folder.","During loading an Application (from any directory), the program may look for one of the following:\n\n","The above order permits making a copy of a file from the Internet or the Program Folder and modifying its contents, including its new version, and putting it in the Document Folder to be used within the scope of the document. Putting it in the Project Folder can make it visible to all documents in that project. This feature encourages end-users to innovate with and within the software without disturbing the other current work in progress. Accepted innovation can move to lower levels in the above directories' order after being properly tested on different documents and projects.","The Project\/Document objects supplied with an embodiment of the present invention contain objects that perform the following:\n\n","The virtual engine detailed with the present invention has several built-in routines to perform the following functions:\n\n","A virtual program (also called a \u201cvirtual engine\u201d or \u201cvirtual machine\u201d) is used to deploy an application created from the present invention and saved on the computer system. This virtual program is a software product designed to enable the development and deployment of an object-oriented application created by the present invention. This virtual program does not contain any knowledge or information; rather, it is like the shell of an executable object-oriented program. The program can interpret a tabular object-oriented program created by the present invention. One advantage of shells is that the user does not have to write the program himself. Therefore, the shell is reusable over many different topics.","Running this virtual program displays a minimized menu with, for example, the commands \u201cOpen a Document,\u201d \u201cLoad an Application\u201d and \u201cHelp.\u201d","Opening an existing document can bring a menu associated with the type of application which has been used on with this document, and display the document on the screen.","In one embodiment, if a user chooses \u201cLoad an Application,\u201d a pop-up with the list of data applications available on the computer system is displayed. Selecting an application to load brings a special menu associated with the type of application loaded and opens an empty document whose type is also associated with the type of application loaded. The special menu displays a set of pull-down menus on the screen, each containing a set of built-in commands common for applications of that type. A sample of the special menu for one embodiment of the present invention that represents a CAD application is shown in . The Main-Frame \u2013 with its pull-down menus and sub-commands is shown in , and is composed of: File , Edit , View , Tools , Windows  and Help .","The virtual program also contains the following engines designed to deploy a selected application and load the document:\n\n","From any of these menus, an end-user selects an object to be current. By default, the first Concrete object displays as the current object . The attributes of the current object are divided into two lists: (a) Attributes (Atomic or Complex) list and (b) Methods list. The methods list is displayed in a scrollable menu \u2013. This scrollable menu has a title \u201cCOMMANDS.\u201d The Atomic and Complex attributes list is displayed on the screen in another scrollable menu \u2013, and, near each attribute, its current value is also displayed. This scrollable menu has a title \u201cVARIABLES.\u201d","The area in the middle of the screen contains (a) a scrollable database table  containing the current object database table and (b) several scrollable screens  for each Layout of the current document. Each screen area displays the proxy objects of the document associated with a certain Layout.","The area at the bottom of the screen contains (a) a message area  to display a message to the end-user associated with the current prompt and (b) a prompt area  to prompt the end-user with the prompt message to get an input.\n\n","The following are sample operational processes and methods utilized in an embodiment of the invention.","Loading an Application","In one embodiment, when an end-user loads an application, the list of the different non-abstract objects available (as listed in the Application Table) display on the menus. A new database can be opened with the application. The end-user can select an object from the menu or from the Screen Area to become the current object. The class inheritance is then resolved, which means that the object properties and inherited properties form an object-oriented structure in memory. The member function displays in the COMMANDS scrollable menu , and the data members display with their value in the VARIABLES scrollable menu . Complex objects may have a value equal to the foreign key, but stay normalized. By selecting an atomic attribute box, the end-user is prompted in the prompt area  with the attribute Prompt Message saved as metadata  in the Class Table () of the current object, and the metadata message  displays in display area . The end-user can enter a new value that is displayed in the Attribute Box \u2013. By selecting a complex attribute in the Attribute Box  (Join table) a pop-up menu displays with the list of the primary keys from this Joined table. The end-user may select a new key and its value displays in the Attribute Box . Selecting a function from the COMMANDS Menu  executes this function. The steps for executing a function include: (a) if the bytecodes of the function is previously loaded in memory, it is used; otherwise, (b) if a saved bytecodes version of the function is saved on the hard disk and has a more recent date than the source code of the function, it is loaded and used; otherwise, (c) the function's source code is compiled and the bytecodes is loaded in memory, executed and also saved on the disk as bytecodes. If the function, for example, was Draw , it is executed. The results of executing the Draw command  are two records: (i) a record formatted as the current object schema (class members' table) with inheritance resolved. This goes to the database document in memory  for this object and, optionally, is also saved to the database document on the disk if the application is so designed. A universal unique EID (Entity ID) is created for this record composed of the AID and OID (current Application-ID and current Object-ID) and a unique number for this record in the database document is added to it. (ii) One or more records holding the same entity universal unique identifier are created by the proxy object  and are added to the display list database  in memory to represent the proxy image of this object; and, optionally, are also saved to the hard disk. The newly-created proxy objects are also displayed on the screen area .","Opening a Database Document","Opening an existing database document loads in memory each of the concrete object database files from the hard disk and, if the display list files have a date more recent than the database file, the display list files are also loaded in memory. Otherwise, the display list is re-created from the database files and is displayed on the screen area.","Inserting an Instance of the Current Entity in the Database","First, the end-user edits the attributes in the Variables area  by choosing an attribute (e.g., attribute ) to enter its new value, and cursor input is allowed. When attributes are edited, the end-user then selects the method to use for insertion from the Commands area . The method for the specific object is then executed. The processes performed are illustrated in .","Selecting a Single Entity from the Screen","In one embodiment, selecting an entity with the cursor from the screen selects the entity with the same coordinates from the display list in memory. The selected entity EID is retrieved from the display list and the entities in the display list holding the same EID are highlighted on the screen. The entity in the database holding the same EID is simultaneously selected and its attribute information and methods display on the COMMANDS and VARIABLES menus (e.g., shown in ).","Modifying\/Deleting a Selected Entity in the Database","In one embodiment, an end-user selects, one at a time, the variable to edit from the Variables-Menu , and the end-user is then prompted to enter new value(s). The end-user then selects the required commands from the Commands Menu . The record in the database and the display list is modified to reflect these changes on the selected entity, keeping the same EID. The processes performed are illustrated in .","Selecting a Group of Entities in the Database by Area Selection","The OID of each entity selected is retrieved. The selected OID is saved in memory as a list representing the current selection set.","Modifying\/Deleting a Group of Selected Entities in the Database","An end-user may change the variables' values and then select a command from the command area. The selected command is executed repeatedly against each OID in the current selection set.","Cut, Copy and Paste to the Clipboard","The list of entities' EIDs selected is saved in the Clipboard (a temporary repository for data); and the proper selected function is executed repeatedly against each OID saved in the list.",{"@attributes":{"id":"p-0239","num":"0000"},"ul":{"@attributes":{"id":"ul0083","list-style":"none"},"li":"1. As a Plug-In to Other Computer Software that has an Application Programming Language Interface"}},"Another embodiment of the present invention is its use as a plug-in to other software applications that have an application interface programming language interface. This can allow using the hosting software interface programming language, with its provided system library, in writing the object members' functions. Moreover, no display list engine is needed as the hosting software can perform the task. The present invention can add capabilities to create and add complex entities to the hosting software. For example, in the CAD industry, the invention can translate the user sketches directly to complete 2D construction documents customized to the end-user's office standards; or translate sketches to 3D design.\n\n","Another embodiment of the present invention is the use of the present invention's method and apparatus as an object-oriented modeling, design and testing tool. For example, a Pilot Project for complex application domains, such as Mechanical Engineering, Very Large Scale Integration (VLSI) Design, Architecture and Computer Integrated Manufacturing Applications can use the present invention to thoroughly design and test a new object-oriented program before its final development.\n\n","Another embodiment of the present invention is to build a version of the Virtual Machine apparatus as a cross-platform independent virtual machine with extra capability to browse the Internet and load applications from remote websites. An object-oriented application that uses the invention, as described, can be composed of a set of RDB tables and methods, both of which can be ASCII files and can be sent over the Internet and other networks to be executed on an end-user's computer. The Application is loaded directly to the end user's virtual machine for testing and\/or pay-per-use purposes. Large corporations with several office locations may use this embodiment for better control of the applications' versioning and maintenance.","Another embodiment is to send over the Internet the compiled methods instead of their source code for better performance. The methods, when compiled, consist of bytecodes, which are also architecture and operating system independent, and can be sent over the Internet and other networks. The RDB tables and the bytecodes are actually executed on a particular platform by means of a virtual machine which allows the object-oriented application to run on any platform, regardless of how or where the application program was developed on; and regardless of the particular platform which attempts to run the program.","Referring now to , an embodiment of a block diagram is shown illustrating a generalized hardware architecture of a computer system suitable for implementing the current invention as described in detail herein. The computer systems may also be coupled via a network such as, for example, Internet, Intranet, etc., to connect the computer to other computers, such as a client computer (not shown in ), or for emerging \u201cgrid\u201d or \u201cutility\u201d computing. The exemplary computer system of  is for descriptive purposes only, and may comprise the following:\n\n","Accordingly, software components including instructions or code for performing the methodologies of the present invention, as described herein, may be stored (e.g., as an article of manufacture) in one or more of the associated memory devices (e.g., ROM, fixed or removable memory) and, when ready to be utilized, loaded in part or in whole (e.g., into RAM) and executed by a CPU.","The previously described versions of the present invention have many advantages, including those summarized below. The present invention does not require that all the advantageous features and all the advantages need to be incorporated into every embodiment of the invention.","Simplifying and Improving Software Development","The present invention enables software development tasks to be accomplished by authoring (i.e., filling in) and\/or editing a set of database tables, as opposed to the traditional, cumbersome source code writing and compilation. The database tables combine and link the data in an organized manner that is more easily understood, and visible as a whole, to a programmer, domain expert or modeler. Moreover, these tables are accompanied by forms (i.e., metatables) which serve to guide a user's input with descriptions; and they can also be used for syntax checking, limiting the input to a set of legal values and including help messages about each entry. It is thus easier to control the design of a software program, especially a large one, written in tables than if written in the prior art, text format as a collection of classes. Also, tables facilitate working as a team on a software project. It is well known that tables can be modified in an ad hoc fashion without loosing the integrity of the design or the program data.","Thus, the techniques used in DBMSs that handle the management of databases, are incorporated in the present invention to simplify and improve the software development process. For example, a programmer using the present invention can add, view and update table data using online forms (i.e., metatables); find and retrieve just the data needed by using queries, and the data can be retrieved from several tables based on relationships; and analyze or print data in a specific layout. All this will result in more control, better quality and faster development for a software project.","While simplification and seamless management of software development are goals of the present invention, it would be for naught if the quality of resulting applications is at all compromised. In fact, the tables in the present invention serve to improve the quality and capability of software. Examples of such improvement include: creating inheritance between applications; using more than one application to edit or create entities (input) into a document; and allowing for modularity, where each application performs a single defined task on a certain document (e.g., in one document, a CAD application only does graphics entities, Text inserted in a drawing is done using a Word-Processor, and Tables are inserted in a drawing using a Spreadsheet). Some of these improvements are discussed below.","Further, the present invention can serve as a tool for domain experts, who have little or no traditional programming experience, to create or modify software simply by working with a database system. Indeed, it is the domain expert, and not the programmer, who is best suited to represent knowledge and address software needs within a particular expertise. Now, the domain expert is given that power by working with tables, which have descriptive text and help messages about each piece of information required.","In short, using a system of database tables for a complete programming environment has significant benefits as tables are, at once, clean, self-descriptive and dynamically powerful.","Dynamic Creation and Updates","By using an embodiment of the present invention, software applications can be developed, deployed and modified much faster than traditional applications. The techniques involved in traditional software development, including authoring source code, compiling, linking and debugging are often time consuming. The present invention, with its DBMS approach, is dynamic and can modify applications simply by changing a value in a table (e.g., the Class Table in ) that is part of the database which composes a program. Thus, software created using the present invention can be created or edited \u201cin real-time\u201d to represent dynamic data, or to incorporate new ideas, findings, and desired functionalities as they arise.","Modularity Usage and Performance","Embodiments of the present invention allow for applications to be created and deployed in a piecemeal fashion, instead of a \u201cbulky\u201d end-product approach typically used by software makers. Modules created using the present invention can be selected, commingled and run by an end-user at that user's discretion. This advantage can be viewed, generally, as twofold.","First, multidiscipline know-how, represented in the tables, can be brought together in an application to truly address an end-user's (or project's) unique and changing software needs. Typically, traditional applications are created for a very particular market-need and, thus, generally address only issues common to that market. Ancillary software needs require additional investment (often from a different software vendor) from the end-user, with a cautious eye towards \u201ccompatibility\u201d issues between applications. The present invention is suited to easily append \u201coutside\u201d additions to an application (or have multi-applications running in one document as mentioned below) to form a heterogeneous computing environment. A \u201csoftware application\u201d under the present invention thus describes something dynamic, focus being more on the utility aspects of a program, rather than seeing a program as a semi-static commodity.","Second, end-users may be given freedom to choose exactly what functionalities they want (and are willing to pay for) in a program, unlike the typical scenario where the user will use only a fraction of an application's capabilities, despite paying the \u201cfull\u201d price.","Reusability","Further, another advantage of the present invention is the automation of reusability. With additional metadata to classify objects and class members, the application modeler can select a standard method from available lists to use, and the program which is being created will, behind the scene, automatically use the proper routine based on the classifying metadata at run-time. Additionally, the present invention enables an application to have its own characteristics saved as metadata in the Software Catalog Table (e.g., ), and these characteristics can be sent to the classes and their members to overwrite or assign a new object and member classification. The result is that the same object-class called from different applications will behave differently, according to the calling application's characteristics.","Application Inheritance","Another advantage of the present invention is that applications can inherit one another. For example, large applications can be created by selecting a plurality of smaller applications and embedding them together. This can viewed as another aspect of modularity.","Platform Independency","Applications created by the present invention are platform independent and can run on any operating system (OS). Systems of prior art are particularly suited to have software written and run on a particular platform and OS. The present invention overcomes these limitations. Here, the object-oriented source code are written in tables, which are platform independent, similar to a text file; and the methods' source code are written in a text format. Both are acceptable inputs into any platform or OS, and thus can directly be the input to the present invention's virtual engine (which is platform dependent) to create a running application. Thus, software created by the present invention can be developed, deployed and maintained on any platform or OS (e.g., Windows, Linux, Sun Solaris).","The present invention is also suitable for running over the World Wide Web. Programs can be created and sent over the Internet (because they can be read and understood by the virtual engine) to be downloaded and run on a user's computer. Programs can also be stored over a network or the Internet, instead of on a user's machine. Further, a program on the Internet can be continuously updated from a central location to reflect the latest changes made to the program.","Interoperability","Another advantage is that the software applications creating using the present invention are interoperable, allowing for an exchange of information between multiple heterogeneous applications due to their open, commonly-understood, homogenous table code database. That is, because the component objects can be designed by an expert in a field, or any one using industry-standard or agreed-upon meanings and concepts, the components can be made interoperable for most people working in that field or industry.","Multi-Application Document","Another advantage is that the present invention can bestow multi-application documents. Each single entity (i.e., instance of an object) stored in a document, stores with it the object universal ID that created that entity. Thus, that entity's original object structure can be restored back during editing of the entity, including the data and methods that describe the behavior of that object. The end-result is that one can have a document containing several simultaneously-running applications. Furthermore, as mentioned above, applications can be smaller with more granularity. Thus, for example, a CAD system can have its text writing capability accomplished by a word processor application, both of which can exist concurrently in the same document.","Availability of New Features","Moreover, by using a universal entity ID that is saved with each instantiated entity, it is possible herewith to have new features not known in traditional software applications. For example, using \u201cCut and Paste\u201d between different documents, say, Document-A and Document-B, it is now possible to keep, with each copied entity, that entity's original characteristics and original application using the present invention. Thus, the copied entity can now be edited using its original application. Moreover, if the copied entity is saved in Document-B as a linked entity, one will be able to edit the entities in Document-A directly from Document-B, or vice-versa. A more detailed illustration is as follows: If we Cut one or more cell(s) from a spreadsheet document and paste it into a word-processor document as a reference, the pasted cell(s) will keep a universal ID to its source document and source application. We can then edit the value in the pasted cell(s) in the word-processor document using the cell's original spreadsheet application; or vice-versa. Finally, as another example, in a CAD drawing, if we cut an area and paste it into another drawing as linked entities, any edit to an entity in the pasted area (in either drawing) can show up in the other drawing; and any other new entities which, when inserted were linked to a location to the entities pasted, will change their location if the pasted entity moves in either drawing. This can greatly enhance security and privacy as, for example, changes in the base document can be made by small changes in other documents without revealing the base document.","Security and Safety","Traditional systems are made with pointers' usage. These are generally insecure because you do not know what is \u201cbehind them.\u201d The present invention is in an open system that can be easily checked manually by end-users, or at run-time, during loading the tables in computer memory by a simple code security object that runs before compiling the member functions. This can reduce a modeler's liability because he can specify the set of operations his code is allowed to perform as well as restricted operations of his code. Code access security can also help minimize the damage that can result from security vulnerabilities in the code.","Moreover, security and accessibility of the data for the present invention is now a design issue (through the database tables) and not a development issue (through writing traditional source code). Thus, security can be well managed throughout the lifecycle of a project. Special techniques can also be easily applied to many parts of a program created using the present invention such as implementing industry guidelines, office standards, and\/or business rules.","Data Mining","The present invention is ideal for data mining as additional metadata can be added to the tables to classify the data, thereby enabling important information to be mined, or even captured directly\u2014at the source end, when the data is created\u2014and appended to the data repositories for faster, less expensive and more accurate results.","Open Innovation and Diffusion of Functional Knowledge","Finally, another advantage of the present invention is that the design and development (and, at the user's option, the delivery) is made in an open, self-descriptive environment which creates a hotbed for innovation. Unlike traditional OOPLs, the table-oriented environment here is concise and self-descriptive (e.g., ) and thus, for example, can minimize potential for programming error while work on a program is done in a collaborative fashion. This is because the tables provide a general view of the complete scope of work and any input can be guided by a form (i.e., metatable) with description, help and checks on input. Further, the deliverables of the present invention are, ideally, the database tables themselves. The tables belonging to the selected application are loaded in memory at run-time to form a running application, in stark contrast to the traditional method of sending (closed) binaries. This optional elimination of the deliverable binaries allows subsequent users to read and comprehend the table code, add to it, share and innovate freely.","Additional, the present invention, by helping to put software development in the hands of domain experts, may assist in the functional diffusion of the sciences and useful arts. Generally, software firms have solely a profit incentive to create software products. If a market is not lucrative enough, then would-be applications may never see the light of day, no matter how beneficial they may be to a particular domain or branch of science. Domain experts, however, may have other incentives to create applications using the present invention, such as the diffusion of knowledge across many disciplines, problem solving for a specific field, or research. Thus, by giving domain experts a tool for software development, the present invention may help diffuse knowledge and solve problems by giving birth to applications that, though not necessarily \u201cmarket winners,\u201d are beneficial across a variety of disciplines.","Although illustrative embodiments of the present invention have been described herein with reference to the accompanying drawings, it is to be understood that the invention is not limited to those precise embodiments, and that various other changes and modifications may be affected therein without departing from the scope or spirit of the invention.","Although the present invention has been described with reference to specific details, it is not intended that such details should be regarded as limitations upon the scope of the invention, except as and to the extent that they are included in the accompanying claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["In the drawings, like reference characters generally refer to the same parts throughout the different views. Also, the drawings are not necessarily to scale, emphasis instead generally being placed on illustrating the principles of the technology.",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 4","FIG. 2"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 8-A","FIGS. 5\u20137"]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 8-B"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 9","FIGS. 5\u20137"]},{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 10","FIG. 11"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 11-A","FIG. 11"]},{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 11-B","FIG. 11"]},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 13-A","FIG. 13"]},{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 13-B","FIG. 13"]},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 15-A","FIG. 15"]},{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 15-B","FIG. 15"]},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 16-A","FIG. 16"]},{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 16-B","FIG. 16"]},{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 17","FIG. 16"]},{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 17A","FIG. 17"]},{"@attributes":{"id":"p-0048","num":"0047"},"figref":["FIG. 17-B","FIG. 17"]},{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 17-C","FIG. 17"]},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 18-A"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 18-B"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 22","b":["2201","2202"]},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 23","b":["2301","2302"]},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0058","num":"0057"},"figref":["FIG. 25-A","FIG. 9"]},{"@attributes":{"id":"p-0059","num":"0058"},"figref":["FIG. 25-B","FIG. 9"]},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 27-A"},{"@attributes":{"id":"p-0062","num":"0061"},"figref":["FIG. 27-B","FIG. 13-A"],"b":"1306"},{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0064","num":"0063"},"figref":["FIG. 29","FIG. 28"]},{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 32"},{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 33"},{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 34-A"},{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 34-B"},{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIG. 35"},{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 36"}]},"DETDESC":[{},{}]}
