---
title: Detection of memory access violation in simulations
abstract: An apparatus and method for detecting memory access violations in simulations is disclosed herein. A detection tool is designed to automatically perform a violation check for each memory read or write operation simulated in a modeled system. The detection tool is capable of handling a modeled system including one or more memories and/or one or more processors.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08838430&OS=08838430&RS=08838430
owner: Cadence Design Systems, Inc.
number: 08838430
owner_city: San Jose
owner_country: US
publication_date: 20110826
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","BRIEF SUMMARY","DETAILED DESCRIPTION"],"p":["The present invention relates to the field of simulations. More particularly, the present invention relates to detecting errors present in simulations.","Simulations are used to model physical devices to facilitate device design, prototyping, and\/or testing. A computer system typically runs simulations by executing a set of instructions or code representative of devices and the functionalities\/interactions that occur between these devices. A modeled device may comprise a component on an integrated chip (e.g., a transistor, processor, bus, clock, memory, etc.), the entire integrated circuit (IC), a system including an IC, or other components of an electronic system. During simulation, devices are modeled as modules, and operations or transactions involving the devices may be modeled at a designer-specified level of detail. Transaction level modeling (TLM) specification by Open SystemC Initiative (OSCI) is an example of a discrete event simulation.","As devices become increasingly complex, designers correspondingly turn to simulators to increase design productivity. Errors can be introduced into the simulation either because there is a design flaw in the device being modeled or the coding of the design into the simulator is incorrect (thus, the model does not accurately reflect the design). This error may go unnoticed until the simulation is complete and results analyzed, the simulator crashes, or the designer manually notices the error. Given market demands for rapid design development, it would be beneficial for designers to become aware of such errors early in the simulation process rather than later.","For example, when simulating memory devices, early detection of memory access violations would be helpful in the design process. To effectively model memory devices, transport function calls representing read and write operations to and from memory are simulated. Transport function calls include address information specifying actions involving particular memory locations of a particular memory module. If the address information in a transport function call does not correspond to a valid memory location for the associated memory module, then the transport function call includes a memory access violation. Detection of such a memory access violation may indicate the presence of a design flaw and\/or coding flaw in the model representing a device design.","Thus, it would be beneficial to provide early detection of memory access violations in simulations. A designer would benefit from knowing about a memory access violation in real-time or near real-time, preferably before the simulation is complete. Early detection of memory access violation serves as an effective debugging feature in a software debugging environment. Early detection of memory access violation also permits real-time or near real-time pin point of simulator error. Providing early detection information may allow the designer to make design changes or correct modeling of the design in the simulator as soon as possible, thereby potentially preventing a simulator crash or unnecessarily lengthening the overall design time. Another benefit is having the early detection feature automatically within a known simulation environment\u2014the designer need not concern him or herself with additional or special code to perform special checks.","An apparatus and method for providing early detection of memory access violations occurring in simulations of device designs is disclosed herein. A tool automatically intercepts transport function calls involving memory devices. The tool checks the memory address information passed to each transport function call against a memory map. Memory address information inconsistent with the address space specified in the memory map represents a memory access violation. Each violation may be reported for debugging purposes to facilitate device design correction or more accurate modeling of the device design. The tool is capable of handling modeled systems implementing one or more memory devices and\/or one or more processors. The tool integrates seamlessly with discrete event simulators, without requiring additional or special inputs or consideration by designers and others involved in setting up\/running the simulations.","Other features and aspects of embodiments will become apparent from the following detailed description, taken in conjunction with the accompanying drawings which illustrate, by way of example, the features in accordance with the embodiments.","The headings provided herein are for convenience only and do not necessarily affect the scope or meaning of the terms used.","Described in detail below is an apparatus and method for providing early detection of memory access violations occurring in simulations of device designs. A tool automatically intercepts transport function calls involving memory devices. The tool checks the memory address information pertaining to each transport function call against a memory map. Memory address information inconsistent with the address space specified in the memory map represents a memory access violation. Each violation can be reported for debugging purposes to facilitate device design correction or more accurate modeling of the device design.","The following description is presented to enable any person skilled in the art to create and use a computer system configuration and related method and article of manufacture to automatically check for memory access violations occurring in device simulations. Various modifications to the preferred embodiments will be readily apparent to those skilled in the art, and the generic principles defined herein may be applied to other embodiments and applications without departing from the spirit and scope of the invention. Moreover, in the following description, numerous details are set forth for the purpose of explanation. However, one of ordinary skill in the art will realize that the invention might be practiced without the use of these specific details. In other instances, well-known structures and processes are shown in block diagram form in order not to obscure the description of the invention with unnecessary detail. Thus, the present invention is not intended to be limited to the embodiments shown, but is to be accorded the widest scope consistent with the principles and features disclosed herein.","Simulations permit modeling of systems in which components of a system are represented as modules, and communication between components are represented as transport function calls. A system may comprise a component on an integrated chip (e.g., a transistor, processor, bus, clock, memory, etc.), the entire integrated circuit (IC), an IC and other components, or otherwise one or more components of an electronic system. Simulation models aid in system or component design, prototyping, and\/or testing.","The designer coding the simulation may specify the level of detail to which the simulation should reflect the corresponding physical system being modeled. For example, a system may be modeled at a transaction or event level, more granularly at a clock cycle level or across clock cycles, or at other levels of abstraction. An example of a discrete event simulation modeling is transaction level modeling (TLM 2.0) sponsored by Open SystemC Initiative (OSCI). One of the devices that can be modeled by TLM 2.0 is memory. TLM 2.0 permits creation of memory mapped bus models in which memory read and write operations are simulated. Memory read and write operations include passing memory address information as part of operating parameters.","A computer program tool configures a computer system to work in conjunction with simulation models to identify memory access violations occurring in simulated memory read and write operations. Although the tool is described in the context of TLM 2.0 designs, it should be understood that the tool is not limited to implementation with TLM 2.0. Instead, the tool may provide the automatic detection capability for a variety of simulation environments that pass address information as part of the modeling. For example, memory read\/write operations may be modeled as C\/C++ function calls independent of TLM 2.0.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1","b":["100","100","102","104","106","108","102","104","106","108"]},"Server  comprises one or more computers or processors configured to communicate with clients  via network . Server  may be located at one or more geographically distributed locations. Server  hosts one or more applications accessed by clients  and\/or facilitates access to the content of database . Database  comprises one or more databases configured to communicate with server  and\/or clients  via network . Although not shown, database  may also communicate with server  without needing network . Database  may be located at one or more geographically distributed locations from each other and also from server . Alternatively, database  may in included within server . Database  comprises a storage device for storing data for use by server  and\/or clients .","Each of clients  comprises a computer or other computing device, including but not limited to, work stations, personal computers, general purpose computers, Internet appliances, hand-held devices, wireless devices, portable devices, wearable computers, cellular or mobile phones, portable digital assistants (PDAs), smart phones, multi-processor systems, microprocessor-based or programmable consumer electronics, game consoles, set-top boxes, network PCs, mini-computers, and the like. Clients  include applications (e.g., web browser application such as Internet Explorer, Firefox, Safari, etc.) or other necessary interface capabilities to communicate with server  and database  via network . Clients  may be located geographically dispersed from each other, server , and\/or database . Although three clients  are shown in , more or less than three clients may be included in system . Device designers access a discrete event simulator and memory access violation detection tool via clients .","Network  comprises a communications network, such as a local area network (LAN), a wireless LAN (WLAN), a wide area network (WAN), a wireless WAN (WWAN), a metropolitan area network (MAN), an ad hoc network, an intranet, an extranet, a virtual private network (VPN), a portion of the Internet, the Internet, a portion of a public switched telephone network (PSTN), a cellular network, another type of network, or a combination of two or more such networks. When network  comprises a public network, security features (e.g., VPN\/SSL secure transport) may be included to ensure authorized access within system .","The discrete event simulator and the detection tool may be hosted by the same component or different components within system . In one embodiment, the discrete event simulator and the detection tool are hosted on server  and they are remotely accessed by clients  via network . In another embodiment, the discrete event simulator and the detection tool reside locally on clients . Server  may be involved for purposes of updating and\/or monitoring the simulator or detection tool on clients . Server  may also facilitate interaction with database  by clients . In still another embodiment, each of the simulator or detection tool may reside partly in each of server  and clients . Moreover, the detection tool and the discrete event simulator need not be hosted at the same component, e.g., server  hosts the detection tool and clients  hosts the simulator, or server  hosts the simulator and clients  hosts the detection tool.","Alternatively, clients  may be standalone stations not connected to a network. In this case, database  (or similar functionality) may be included in clients  to provide information used by the detection tool, as described in detail below.","As will be described in detail below, the detection tool does not require modifications to the discrete event simulation, or other integration between the simulation and the detection tool. The detection tool is configured to provide memory access violation detection automatically upon evoking the tool.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 2","b":["200","200","202","206","202","202","206","204","204","202","205","204"]},"When target  represents a model of a memory, transport function calls (also referred to as transport calls or transport functions) to target  represent read and write operations to and from memory. Such transport function calls are initiated by initiator  representing a processor or central processing unit (CPU). Exemplary interconnect  (if modeled in the chain of modules to the target) may comprise buses, routers, bridges, etc.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIGS. 3A-3G","FIGS. 4-7","FIG. 3A"],"b":["3","3","300","302","304","310","312","314","318"]},"At the generate memory map block , the designer (or other user) specifies an address space for each memory modeled within the discrete event simulation. In other words, the entire system address space is specified in a memory map. The memory map can be expressed as a text file, an XML file, or in any other suitable format recognized by the tool. The memory map may be stored in database  () or locally at clients  when in a standalone configuration.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 4","b":["400","400","402","404","406","408","410"]},"Once a memory map has been defined, the detection tool is configured to look for initiation of a transport function call involving a target memory (block ). In TLM 2.0 designs, there are typically three types of transport function calls: b_transport, nb_transport_fw, and nb_transport_bw. Calls to b_transport are made to emulate blocking read or write operations. Calls to nb_transport_fw and nb_transport_bw are made to emulate non-blocking read or write operations. Block  monitors the simulation for any of these transport function calls.","If no transport function call involving a memory has been initiated (no branch ), then the detection tool continues to wait for a call initiation. Otherwise, if a call has been initiated (yes branch ), then the detection tool is configured to intercept the initiated transport function call before it passes to the first module in the chain of modules to the target (block ). In other words, intercept the function call before information included in or pertaining to the function call could be changed or transformed. For example, the address included in the function call could be modified or transformed by one or more interconnects in the chain of modules to the target. Because of this possible address modification, configuring the detection tool to intercept the function call after passing to a first module (or later module) in the chain of modules to the target is generally undesirable.","The detection tool \u201cintercepts\u201d the transport function call in any number of ways as long as it is able to examine the contents of the transport function call in order to check for memory access violation as described below. In one embodiment, intercept block  comprises a create intercept module block and an insert intercept module between the initiator and the first module in the chain of modules to the target block ().  correspondingly illustrates intercepting by automatically creating and inserting an intercept module  (also referred to as an intermediate block) between initiator  and the first module in the chain of modules to the target . Intercept module  accepts the transport function call initiated by initiator  to perform the check and then passes the call to the first module in the chain of modules to the target .","In another embodiment, intercept block  comprises a create shadow module block and a pass transport call to the shadow module and first module in the chain of modules to the target block ().  illustrates this form of interception, in which an automatically created shadow module  receives from the initiator  the transport function call initiated by initiator  to perform the check. The transport function call also (normally) passes to the first of interconnect modules  (e.g., the first module in the chain of modules to target ). The transport function call may be passed simultaneously or sequentially to each of shadow module  and the first of interconnect modules  from initiator . The shadow module  performs the memory address violation check independent of activities occurring within the regular modules. Because the transport function call has already been passed to interconnect module , shadow module  need not pass the transport function call again to interconnect module  (i.e., passing blocks  and  in , C, and D can be omitted).","In still another embodiment, intercept block  comprises execution of an application programming interface (API) included in the code base of the discrete event simulation model. An API of function calls may be provided to designers. During coding of the simulation model, the designer may insert the provided API into their code just before and after the point at which a transport function call would be initiated by an initiator. Consequently, during runtime of the simulation model, the API causes the transport function call to be passed to the detection tool. The detection tool performs the memory address violation check independent of activities occurring within the regular modules. Since the transport function call passes normally to the first module in the chain of modules to the target, there is no need to pass the transport function call again to the first module in the chain (i.e., passing blocks  and  in , C, and D can be omitted).","Next at block , one or more parameters passed to the intercepted transport function call is examined and checked against the memory map previously generated (see block ). The detection tool looks for the memory address field(s) passed to the transport function call and compares the contents of those field(s) against the memory map associated with the intended target memory. The detection tool takes advantage of standard fields or parameters in discrete event simulation specifications to extract the necessary address information to perform the check. For example, in TLM 2.0 designs, each transport function call involving a target memory (which are read and write operations to and from memory) includes, among other things, a TLM 2.0 generic payload object as one of its parameters.  shows a table providing the fields of the TLM 2.0 generic payload object. In the case of TLM 2.0 simulations, the contents of the m_address field (representing the transaction address of the target memory involved in the transaction) and the m_length field (representing the number of bytes being read or written) of the generic payload object are examined. In other words, the detection tool intercepts each function call (e.g., b_transport, nb_transport_bw, and nb_transport_fw function calls in the case of TLM 2.0 designs) to examine the contents of the m_address and m_length fields of its generic payload object.","As an example, consider the following TLM 2.0 code snippet of an exemplary transport function call from an initiator CPU, making a call to read 64 bytes from memory address 0x50000:",". . . .","trans.set_command (TLM_READ_COMMAND); \/\/Specifies a read operation","trans.set_address (0x50000); \/\/This transaction address is a memory violation compared to the addresses specified in the memory map of ","trans.set_data_ptr (reinterpret_cast<unsigned char*>(&data));","trans.set_length (64); \/\/Specifies 64 bytes","socket\u2192b_transport (trans, zerotime);",". . . .","Examining the contents of the trans.set_address and trans.set_length fields above, it can be seen that the transaction address lies outside of any of the memory regions specified in the memory map. Thus, the memory access specified in the transport function call qualifies as an access violation.","If the transaction address and transaction length in the generic payload object lie within any of the memory regions provided in the memory map (block ), then the access is deemed to be valid (yes branch ). Otherwise, if the transaction address or transaction length in the generic payload object lies outside any of the memory regions provided in the memory map (block ), then the access is deemed to be invalid and a memory access violation has been detected (no branch ).","In the case of a valid access detection (yes branch ), the transport function call that was intercepted to perform the check can be passed (from intercept module ) to the first module in the original chain to the target memory (block ). The detection tool continues to monitor transport function calls to provide memory access violation detection.","In the case of an invalid access detection (no branch ), the detection tool is robust enough to handle the detection information in any one or more of the following ways: provide violation detection notification, permanently interrupt the transport function call containing the violation, halt the simulation, and\/or provide corrective guidance. Such detection information is provided to the designer via a display, printout, storage device, or the like.","In one embodiment, a statement can be provided to a user informing him or her that a memory access violation has occurred in the simulation (block ). The statement can be provided as soon as the violation is detected, e.g., in real- or near real-time, or at a later point in time. The violation detection notification may be a stand-alone statement or a part of a larger report pertaining to the performance of the simulation. As shown in , the transport function call containing the violation need not be passed to the target (since the transaction cannot be completed anyway due to the out-of-range address information specified). The tool may continue monitoring other transport function calls for access violations.","In another embodiment, the reporting function of block  can be performed before, simultaneous, or after passing the transport function call from the intercept module  to the first module in the chain to the target (block  in ). Again, the tool continues to monitor other transport function calls for access violations.","In still another embodiment, in , in addition to reporting the violation (block ) and passing the transport function call (block ), in any possible order relative to each other as discussed above, the detection tool can also provide recommendations for corrective measures to prevent future access violations (block ). Corrective recommendations may include more specificity regarding the violation (e.g., transaction address X in field Y is out of range) and\/or instructions to correct specific lines of code (and how to correct the code) to prevent future access violations. Such corrective recommendations may similarly be provided in any order or simultaneously relative to blocks  or .","Lastly as shown in , yet still another embodiment may involve the detection tool reporting the violation (block ) and providing corrective recommendations (block )-again in any order or simultaneously relative to each other\u2014and halting the simulation (block ). It may be the case that the memory access violation detected in a transport function call has a cascading effect on the continuing simulation. Cascading effects may encompass the simulation crashing, introduction of errors into subsequent operations making it more difficult to identify the actual source of the error, or other unintended side effects. In such cases, it may be beneficial to halt the simulation as soon as a violation is detected so that the designer can address the problem before continuing with the rest of the simulation.","Although passing the transport function call to the first module in the chain to the target is shown occurring after blocks , , and  in , it is understood that the passing function may occur simultaneously with any of blocks , , or . Moreover, depending on the method by which the transport function call was intercepted (block ), these passing blocks may be omitted as discussed above.","Memory map  of  pertains to a multi-memory system. The detection tool is equally effective for a multi-initiator system. In a multi-initiator system, each initiator accesses the same or a different region(s) of memory(s) from other initiators. Each initiator can thus be associated with a unique address map or memory subsystems.",{"@attributes":{"id":"p-0060","num":"0059"},"figref":["FIG. 7","FIG. 4"],"b":["700","700","400","700","702","704"]},"For example, if sc_main.processor0 initiates a function call specifying transaction address 0x30000, a general memory violation check (as illustrated in ) would not detect a violation because transaction address 0x30000 lies within one of the memory regions specified in memory map . However, an access violation is detectable when the detection tool restricts the check to the particular initiator subsystem map corresponding to the particular initiator that initiated the function call. In this example, that would be initiator subsystem map  for sc_main.processor0. Thus, during simulation of a multi-initiator system, the detection tool is operable to perform more than one kind of memory violation check, or perform a more refined violation check taking into account the particular initiator that initiated the function call.","Continuing the example, a violation check specific to the initiator can be carried out as follows. In block  of , the detection tool additionally obtains the name\/identifier of the initiator (e.g., sc_main.processor0) in order to use the appropriate initiator subsystem map within memory map . The subsystem_instance name within memory map  (e.g., subsystem sc_main.processor0 in initiator subsystem map ) that exactly matches the name\/identifier of the initiator identifies the proper memory regions to check. If none of the subsystem instance names within memory map  matches the name\/identifier of the initiator, either the first initiator subsystem map (or some other initiator subsystem map) or all of memory map  may be used to compare against the address information within the function call. Otherwise the rest of the discussion above for  is applicable when performing a violation check for a multi-initiator system.","Although several embodiments are discussed above for using the violation detection information, other additional or different uses may also be implemented. As appreciated by one skilled in the art, detection of a specific error in a complex system, in of itself, is of great value in correcting the error, especially when the detection is automatic, transparent to the end user, and may be provided in real- or near-real time. A user designing, coding, or running a discrete event simulation need not be concerned with factoring in the detection tool into the simulation (e.g., someone coding the models does not need to write special code to perform the check). Instead, the detection tool provides automatic and seamless debugging capability.","In this manner, an automatic detection tool is provided for systems modeled in discrete event simulations. The detection tool is configured to perform a violation check for each memory read or write operation simulated in a modeled system. The detection tool is capable of handling modeled systems that implement one or more target memories and\/or one or more initiator processors. The detection tool integrates seamlessly with discrete event simulators, without requiring additional or special inputs or consideration by designers and others involved in setting up\/running the simulations.",{"@attributes":{"id":"p-0065","num":"0064"},"figref":["FIG. 8","FIG. 1"],"b":["800","800","102","106","800","800","804","804","804","802"]},"Computing system  can also include a main memory , such as random access memory (RAM) or other dynamic memory, for storing information, code, software, data, and\/or instructions to be executed by processor . Main memory  can also be used for storing temporary variables or other intermediate information during execution of instructions to be executed by processor . Computing system  may likewise include a read only memory (ROM) or other static storage device coupled to bus  for storing static information and instructions for processor .","Computing system  can additionally include a storage system , which may include, for example, a media drive  and a removable storage interface . The media drive  may include a drive or other mechanism to support fixed or removable storage media, such as a hard disk drive, a floppy disk drive, a magnetic tape drive, an optical disk drive, a CD or DVD drive (R or RW), thumb drive, or other removable or fixed media drive. Storage media  may include, for example, a hard disk, floppy disk, magnetic tape, optical disk, CD or DVD, thumb drive, or other fixed or removable medium that is read by and written to by media drive . Storage media  may include a computer-readable storage medium that stores particular computer software, instructions, code, and\/or data.","In alternative embodiments, storage system  may include other similar components to allow computer programs or other instructions or data to be loaded in and\/or executed by computing system . Such components may include, for example, a removable storage unit  and a storage unit interface , such as a program cartridge and cartridge interface, a removable memory (for example, a flash memory or other removable memory module) and memory slot, and other removable storage units  and interfaces  that allow executable instructions and data to be transferred from storage media  to computing system .","Computing system  can also include a communications interface . Communications interface  also permits executable instructions and data to be transferred between computing system  and external devices. Examples of communications interface  includes a modem, a network interface (such as an Ethernet or other NIC card), a communications port (such as for example, a USB port), a PCMCIA slot and card, etc. Software and data transferred via communications interface  are in the form of signals which can be electronic, electromagnetic, optical, or other signals capable of being received by communications interface . These signals are provided to communications interface  via a channel . Channel  may carry signals and be implemented using a wireless medium, wire or cable, fiber optics, or other communications medium. Some examples of a channel include a phone line, a cellular phone link, an RF link, a network interface, a local or wide area network, and other communications channels  to perform features or functions of some embodiments.","The terms \u201ccomputer program product,\u201d \u201ccomputer-readable medium,\u201d and the like are used generally to refer to media such as memory , storage device , storage unit , server , database , or client . These and other forms of computer-readable media may be involved in storing one or more sequence of one or more instructions for use by processor , server , or client , to cause the processor to perform specified operations. Such instructions, generally referred to as \u201ccomputer program code\u201d (which may be grouped in the form of computer programs or other groupings), when executed, enable the computing system  to perform features or functions of some embodiments. Software, instructions, code, and\/or data in computing system  may directly cause the processor to perform specific operations, be compiled to do so, and\/or be combined with other software, hardware, and\/or firmware elements (e.g., libraries for performing standard functions) to do so.","In an embodiment where the elements are implemented using software, the software may be stored in a computer-readable medium and loaded into computing system  using, for example, removable storage interface , drive  or communications interface . The control logic (in this example, software instructions or computer program code), when executed by the processor , causes the processor  to perform the functions of some embodiments as described herein.","It will be appreciated that, for clarity purposes, the above description describes some embodiments with reference to different functional units and processors. However, it will be apparent that any suitable distribution of functionality between different functional units, processors or domains may be used without detracting from the invention. For example, functionality illustrated to be performed by separate processors or controllers may be performed by the same processor or controller. Hence, references to specific functional units are only to be seen as references to suitable means for providing the described functionality, rather than indicative of a strict logical or physical structure or organization.","Although the present invention has been described in connection with some embodiments, it is not intended to be limited to the specific form set forth herein. Rather, the scope of the present invention is limited only by the claims. Additionally, although a feature may appear to be described in connection with particular embodiments, one skilled in the art would recognize that various features of the described embodiments may be combined in accordance with the invention.","Furthermore, although individually listed, a plurality of means, elements or method steps may be implemented by, for example, a single unit or processor. Additionally, although individual features may be included in different claims, these may possibly be advantageously combined, and the inclusion in different claims does not imply that a combination of features is not feasible and\/or advantageous. Also, the inclusion of a feature in one category of claims does not imply a limitation to this category, but rather the feature may be equally applicable to other claim categories, as appropriate.","Moreover, it will be appreciated that various modifications and alterations may be made by those skilled in the art without departing from the spirit and scope of the invention. The invention is not to be limited by the foregoing illustrative details, but is to be defined according to the claims.","Although only certain exemplary embodiments have been described in detail above, those skilled in the art will readily appreciate that many modifications are possible in the exemplary embodiments without materially departing from the novel teachings and advantages of this invention. Accordingly, all such modifications are intended to be included within the scope of this invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["In the drawings, which are not necessarily drawn to scale, like numerals may describe similar components in different views. Like numerals having different letter suffixes may represent different instances of similar components. The drawings illustrate generally, by way of example, but not by way of limitation, various embodiments discussed in the present document.",{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIGS. 3A-3G"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 4","FIGS. 3A-3G"]},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIGS. 5A-5B"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 7","FIGS. 3A-3G"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
