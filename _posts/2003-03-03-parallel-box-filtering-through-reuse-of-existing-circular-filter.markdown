---
title: Parallel box filtering through reuse of existing circular filter
abstract: A sample filtering system and method for concurrently filtering sample data for two or more sequential pixels (in a scan-line) are disclosed. The system may include a sample cache, a control register, a read cache controller, and a sample-to-pixel calculation unit. The read cache controller reads a first set of S samples from the sample cache, and outputs a second set of S samples to the sample-to-pixel calculation unit. The second set of samples may have one or more subsets of samples, with each subset of samples selected to cover the filter region for one of the sequential pixels. The sample-to-pixel calculation unit may process each subset separately and concurrently.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06927775&OS=06927775&RS=06927775
owner: Sun Microsystems, Inc.
number: 06927775
owner_city: Santa Clara
owner_country: US
publication_date: 20030303
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["1. Field of the Invention","This invention relates generally to the field of high performance computer graphics systems and, more particularly, to sample-to-pixel filtering systems.","2. Description of the Related Art","In recent years, the demand for high performance graphics systems that can render complex three-dimensional (3D) objects and scenes realistically has increased substantially. Modem high performance graphics systems also support special effects such as anti-aliasing, texturing, shading, fogging, alpha-blending, and specular highlighting. The increase in demand for better performance is at least in part due to new applications such as computer-generated animation for motion pictures, virtual reality simulators\/trainers, and interactive computer games. These new applications place tremendous computational loads upon graphics systems. Modem computer displays have also improved and have a significantly higher pixel resolution, greater color depth, and are able to display more complex images with higher refresh rates than earlier models. Consequently, modern high performance graphics systems incorporate graphics processors with a great deal of complexity and power that generate multiple samples per pixel, and the color value of one pixel may be the result of many calculations involving filtering hundreds of samples.","With each new generation of graphics system, there is more image data to process, the processing is more complex, and there is less time in which to process it. This need for more processing power is being met with the combination of more hardware resources and more efficient processes.","One embodiment of the invention comprises a high-speed graphics system that utilizes a sample filtering system and method for concurrently filtering sample data for two or more sequential pixels (in a scan-line). The system may include a sample cache, a control register, a read cache controller, and a sample-to-pixel calculation unit. A sample may include data for one or more of colors, transparency, depth, and location.","The method may be initiated by selecting a filter type and a filter region, setting a control register to a value that enables concurrent filtering of P sequential pixels, where P is a positive integer, and identifying an array of sample bins in the sample cache that overlap the P filter regions centered on the P sequential pixel locations.","The sample cache stores sample data from a sample buffer in an array of sample bins. The control register specifies a number P of sequential pixels to filter concurrently. If the control register is set to a first value, the sample-to-pixel calculation unit may filter one pixel at a time and may use a specified filter of larger width. If the control register is set to a second value, the sample-to-pixel calculation unit may filter two sequential pixels concurrently and may use a filter of smaller width for each pixel. The control register may also be set to other values that select more than two sequential pixels to be filtered sequentially.","The read cache controller reads a first set of samples from the sample cache, and outputs a second set of S samples to the sample-to-pixel calculation unit. The second set of S samples may comprise P subsets of samples, with each subset of samples selected to cover the filter region for a corresponding one of the P pixels.","The sample-to-pixel calculation unit may include a sample weight calculation unit, a filter multiplier tree, a weight accumulator, and one or more pixel normalizers.","The sample weight calculation unit may determine sample weights for each of the S sample locations as a function of one or more of the distance between the sample location and the corresponding pixel location, the specified filter type, and the specified filter region. If a sample location is outside a specified filter region, the sample weight may be set to zero. In some embodiments, the sample data read from the sample cache may not include sample locations. Sample locations may be specified according to a pre-selected pattern of sample positions (such as a regular grid, a perturbed regular grid, a stochastic grid, or a specified permutation of a stored set of selected sample locations).","The filter multiplier tree receives one or more cycles of S samples grouped in P subsets from the sample cache reader and corresponding S weights from the sample weight calculation unit, multiplies each sample by the corresponding weight, sums the weighted samples for each subset of samples, and adds the sum to an accumulated sum from prior cycles for each subset. (The number of cycles is a function of the specified number of samples per pixel.) When processing one pixel at a time, the normal input of S samples may be received, processed, and accumulated. When processing two pixels concurrently, two subsets may be received. A multiplexer separates the filter multiplier tree into two separate units. The two subsets of samples may then be processed and accumulated separately.","The weight accumulator may receive one or more cycles of S weights from the sample weight calculation unit in P subsets, accumulate a weight sum for the one or more cycles, and calculate a reciprocal of the accumulated weight sum for each subset.","One or more pixel normalizers may receive the accumulated sum of the weighted samples from the filter multiplier tree and the reciprocal of the accumulated weight sum from the weight accumulator and output the product as a pixel value for each subset. In some embodiments, one normalizer may be used to output the pixel values in sequence. In other embodiments, P normalizers may be used to output the pixel values concurrently.","Computer System\u2014",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 1","b":"80"},"As shown, the computer system  includes a system unit  and a video monitor or display device  coupled to the system unit . The display device  may be any of various types of display monitors or devices (e.g., a CRT, LCD, or gas-plasma display). Various input devices may be connected to the computer system, including a keyboard  and\/or a mouse , or other input device (e.g., a trackball, digitizer, tablet, six-degree of freedom input device, head tracker, eye tracker, data glove, or body sensors). Application software may be executed by the computer system  to display graphical objects on display device .","Computer System Block Diagram\u2014",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 2","b":["1","80","102","104","104","106","104"]},"Host processor  may include one or more processors of varying types, e.g., microprocessors, multi-processors and CPUs. The system memory  may include any combination of different types of memory subsystems such as random access memories (e.g., static random access memories or \u201cSRAMs,\u201d synchronous dynamic random access memories or \u201cSDRAMs,\u201d and Rambus dynamic random access memories or \u201cRDRAMs,\u201d among others), read-only memories, and mass storage devices. The system bus or host bus  may include one or more communication or host computer buses (for communication between host processors, CPUs, and memory subsystems) as well as specialized subsystem buses.","In , a graphics system  is coupled to the high-speed memory bus . The graphics system  may be coupled to the bus  by, for example, a crossbar switch or other bus connectivity logic. It is assumed that various other peripheral devices, or other buses, may be connected to the high-speed memory bus . It is noted that the graphics system  may be coupled to one or more of the buses in computer system  and\/or may be coupled to various types of buses. In addition, the graphics system  may be coupled to a communication port and thereby directly receive graphics data from an external source, e.g., the Internet or a network. As shown in the figure, one or more display devices  may be connected to the graphics system .","Host CPU  may transfer information to and from the graphics system  according to a programmed input\/output (I\/O) protocol over host bus . Alternately, graphics system  may access system memory  according to a direct memory access (DMA) protocol or through intelligent bus mastering.","A graphics application program conforming to an application programming interface (API) such as OpenGL\u00ae or Java 3D\u2122 may execute on host CPU  and generate commands and graphics data that define geometric primitives such as polygons for output on display device . Host processor  may transfer the graphics data to system memory . Thereafter, the host processor  may operate to transfer the graphics data to the graphics system  over the host bus . In another embodiment, the graphics system  may read in geometry data arrays over the host bus  using DMA access cycles. In yet another embodiment, the graphics system  may be coupled to the system memory  through a direct port, such as the Advanced Graphics Port (AGP) promulgated by Intel Corporation.","The graphics system may receive graphics data from any of various sources, including host CPU  and\/or system memory , other memory, or from an external source such as a network (e.g. the Internet), or from a broadcast medium, e.g., television, or from other sources.","Note while graphics system  is depicted as part of computer system , graphics system  may also be configured as a stand-alone device (e.g., with its own built-in display). Graphics system  may also be configured as a single chip device or as part of a system-on-a-chip or a multi-chip module. Additionally, in some embodiments, certain of the processing operations performed by elements of the illustrated graphics system  may be implemented in software.","Graphics System\u2014",{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 3","b":["112","112","112","14","18","20","22","24","112","26","28","14","18"]},"In some embodiments, one or more of these components may be removed. For example, the texture buffer may not be included in an embodiment that does not provide texture mapping. In other embodiments, all or part of the functionality incorporated in either or both of the media processor or the hardware accelerator may be implemented in software.","In one set of embodiments, media processor  is one integrated circuit and hardware accelerator is another integrated circuit. In other embodiments, media processor  and hardware accelerator  may be incorporated within the same integrated circuit. In some embodiments, portions of media processor  and\/or hardware accelerator  may be included in separate integrated circuits.","As shown, graphics system  may include an interface to a host bus such as host bus  in  to enable graphics system  to communicate with a host system such as computer system . More particularly, host bus  may allow a host processor to send commands to the graphics system . In one embodiment, host bus  may be a bi-directional bus.","Media Processor\u2014",{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 4","b":["14","14","112","80","80","112","14"]},"Transformation refers to the spatial manipulation of objects (or portions of objects) and includes translation, scaling (e.g. stretching or shrinking), rotation, reflection, or combinations thereof. More generally, transformation may include linear mappings (e.g. matrix multiplications), nonlinear mappings, and combinations thereof.","Lighting refers to calculating the illumination of the objects within the displayed image to determine what color values and\/or brightness values each individual object will have. Depending upon the shading algorithm being used (e.g., constant, Gourand, or Phong), lighting may be evaluated at a number of different spatial locations.","As illustrated, media processor  may be configured to receive graphics data via host interface . A graphics queue  may be included in media processor  to buffer a stream of data received via the accelerated port of host interface . The received graphics data may include one or more graphics primitives. As used herein, the term graphics primitive may include polygons, parametric surfaces, splines, NURBS (non-uniform rational B-splines), sub-divisions surfaces, fractals, volume primitives, voxels (i.e., three-dimensional pixels), and particle systems. In one embodiment, media processor  may also include a geometry data preprocessor  and one or more microprocessor units (MPUs) . MPUs  may be configured to perform vertex transformation, lighting calculations and other programmable functions, and to send the results to hardware accelerator . MPUs  may also have read\/write access to texels (i.e. the smallest addressable unit of a texture map) and pixels in the hardware accelerator . Geometry data preprocessor  may be configured to decompress geometry, to convert and format vertex data, to dispatch vertices and instructions to the MPUs , and to send vertex and attribute tags or register data to hardware accelerator .","As shown, media processor  may have other possible interfaces, including an interface to one or more memories. For example, as shown, media processor  may include direct Rambus interface  to a direct Rambus DRAM (DRDRAM) . A memory such as DRDRAM  may be used for program and\/or data storage for MPUs . DRDRAM  may also be used to store display lists and\/or vertex texture maps.","Media processor  may also include interfaces to other functional components of graphics system . For example, media processor  may have an interface to another specialized processor such as hardware accelerator . In the illustrated embodiment, controller  includes an accelerated port path that allows media processor  to control hardware accelerator . Media processor  may also include a direct interface such as bus interface unit (BIU) . Bus interface unit  provides a path to memory  and a path to hardware accelerator  and video output processor  via controller .","Hardware Accelerator\u2014","One or more hardware accelerators  may be configured to receive graphics instructions and data from media processor  and to perform a number of functions on the received data according to the received instructions. For example, hardware accelerator  may be configured to perform rasterization, 2D and\/or 3D texturing, pixel transfers, imaging, fragment processing, clipping, depth cueing, transparency processing, set-up, and\/or screen space rendering of various graphics primitives occurring within the graphics data.","Clipping refers to the elimination of graphics primitives or portions of graphics primitives that lie outside of a 3D view volume in world space. The 3D view volume may represent that portion of world space that is visible to a virtual observer (or virtual camera) situated in world space. For example, the view volume may be a solid truncated pyramid generated by a 2D view window, a viewpoint located in world space, a front clipping plane and a back clipping plane. The viewpoint may represent the world space location of the virtual observer. In most cases, primitives or portions of primitives that lie outside the 3D view volume are not currently visible and may be eliminated from further processing. Primitives or portions of primitives that lie inside the 3D view volume are candidates for projection onto the 2D view window.","Set-up refers to mapping primitives to a three-dimensional viewport. This involves translating and transforming the objects from their original \u201cworld-coordinate\u201d system to the established viewport's coordinates. This creates the correct perspective for three-dimensional objects displayed on the screen.","Screen-space rendering refers to the calculations performed to generate the data used to form each pixel that will be displayed. For example, hardware accelerator  may calculate \u201csamples.\u201d Samples are points that have color information but no real area. Samples allow hardware accelerator  to \u201csuper-sample,\u201d or calculate more than one sample per pixel. Super-sampling may result in a higher quality image.","Hardware accelerator  may also include several interfaces. For example, in the illustrated embodiment, hardware accelerator  has four interfaces. Hardware accelerator  has an interface  (referred to as the \u201cNorth Interface\u201d) to communicate with media processor . Hardware accelerator  may receive commands and\/or data from media processor  through interface . Additionally, hardware accelerator  may include an interface  to bus . Bus  may connect hardware accelerator  to boot PROM  and\/or video output processor . Boot PROM  may be configured to store system initialization data and\/or control code for frame buffer . Hardware accelerator  may also include an interface to a texture buffer . For example, hardware accelerator  may interface to texture buffer  using an eight-way interleaved texel bus that allows hardware accelerator  to read from and write to texture buffer . Hardware accelerator  may also interface to a frame buffer . For example, hardware accelerator  may be configured to read from and\/or write to frame buffer  using a four-way interleaved pixel bus.","The vertex processor  may be configured to use the vertex tags received from the media processor  to perform ordered assembly of the vertex data from the MPUs . Vertices may be saved in and\/or retrieved from a mesh buffer .","The render pipeline  may be configured to rasterize 2D window system primitives and 3D primitives into fragments. A fragment may contain one or more samples. Each sample may contain a vector of color data and perhaps other data such as alpha and control tags. 2D primitives include objects such as dots, fonts, Bresenham lines and 2D polygons. 3D primitives include objects such as smooth and large dots, smooth and wide DDA (Digital Differential Analyzer) lines and 3D polygons (e.g. 3D triangles).","For example, the render pipeline  may be configured to receive vertices defining a triangle, to identify fragments that intersect the triangle.","The render pipeline  may be configured to handle full-screen size primitives, to calculate plane and edge slopes, and to interpolate data (such as color) down to tile resolution (or fragment resolution) using interpolants or components such as:\n\n","In embodiments using supersampling, the sample generator  may be configured to generate samples from the fragments output by the render pipeline  and to determine which samples are inside the rasterization edge. Sample positions may be defined by user-loadable tables to enable stochastic sample-positioning patterns.","Hardware accelerator  may be configured to write textured fragments from 3D primitives to frame buffer . The render pipeline  may send pixel tiles defining r, s, t and w to the texture address unit . The texture address unit  may use the r, s, t and w texture coordinates to compute texel addresses (e.g. addresses for a set of neighboring texels) and to determine interpolation coefficients for the texture filter . The texel addresses are used to access texture data (i.e. texels) from texture buffer . The texture buffer  may be interleaved to obtain as many neighboring texels as possible in each clock. The texture filter  may perform bilinear, trilinear or quadlinear interpolation. The pixel transfer unit  may also scale and bias and\/or lookup texels. The texture environment  may apply texels to samples produced by the sample generator . The texture environment  may also be used to perform geometric transformations on images (e.g., bilinear scale, rotate, flip) as well as to perform other image filtering operations on texture buffer image data (e.g., bicubic scale and convolutions).","In the illustrated embodiment, the pixel transfer MUX  controls the input to the pixel transfer unit . The pixel transfer unit  may selectively unpack pixel data received via north interface , select channels from either the frame buffer  or the texture buffer , or select data received from the texture filter  or sample filter .","The pixel transfer unit  may be used to perform scale, bias, and\/or color matrix operations, color lookup operations, histogram operations, accumulation operations, normalization operations, and\/or min\/max functions. Depending on the source of (and operations performed on) the processed data, the pixel transfer unit  may output the processed data to the texture buffer  (via the texture buffer MUX ), the frame buffer  (via the texture environment unit  and the fragment processor ), or to the host (via north interface ). For example, in one embodiment, when the pixel transfer unit  receives pixel data from the host via the pixel transfer MUX , the pixel transfer unit  may be used to perform a scale and bias or color matrix operation, followed by a color lookup or histogram operation, followed by a min\/max function. The pixel transfer unit  may then output data to either the texture buffer  or the frame buffer .","Fragment processor  may be used to perform standard fragment processing operations such as the OpenGL\u00ae fragment processing operations. For example, the fragment processor  may be configured to perform the following operations: fog, area pattern, scissor, alpha\/color test, ownership test (WID), stencil test, depth test, alpha blends or logic ops (ROP), plane masking, buffer selection, pick hit\/occlusion detection, and\/or auxiliary clipping in order to accelerate overlapping windows.","Texture Buffer ","Texture buffer  may include several SDRAMs. Texture buffer  may be configured to store texture maps, image processing buffers, and accumulation buffers for hardware accelerator . Texture buffer  may have many different capacities (e.g., depending on the type of SDRAM included in texture buffer ). In some embodiments, each pair of SDRAMs may be independently row and column addressable.","Frame Buffer ","Graphics system  may also include a frame buffer . In one embodiment, frame buffer  may include multiple 3D-RAM memory devices (e.g. 3D-RAM64 memory devices) manufactured by Mitsubishi Electric Corporation. Frame buffer  may be configured as a display pixel buffer, an offscreen pixel buffer, and\/or a supersample buffer. Furthermore, in one embodiment, certain portions of frame buffer  may be used as a display pixel buffer, while other portions may be used as an offscreen pixel buffer and sample buffer.","Video Output Processor\u2014","A video output processor  may also be included within graphics system . Video output processor  may buffer and process pixels output from frame buffer . For example, video output processor  may be configured to read bursts of pixels from frame buffer . Video output processor  may also be configured to perform double buffer selection (dbsel) if the frame buffer  is double-buffered, overlay transparency (using transparency\/overlay unit ), plane group extraction, gamma correction, psuedocolor or color lookup or bypass, and\/or cursor generation. For example, in the illustrated embodiment, the output processor  includes WID (Window ID) lookup tables (WLUTs)  and gamma and color map lookup tables (GLUTs, CLUTs) . In one embodiment, frame buffer  may include multiple 3DRAM64s  that include the transparency overlay  and all or some of the WLUTs . Video output processor  may also be configured to support two video output streams to two displays using the two independent video raster timing generators . For example, one raster (e.g., A) may drive a 1280\u00d71024 CRT while the other (e.g., B) may drive a NTSC or PAL device with encoded television video.","DAC  may operate as the final output stage of graphics system . The DAC  translates the digital pixel data received from GLUT\/CLUTs\/Cursor unit  into analog video signals that are then sent to a display device. In one embodiment, DAC  may be bypassed or omitted completely in order to output digital pixel data in lieu of analog video signals. This may be useful when a display device is based on a digital technology (e.g., an LCD-type display or a digital micro-mirror display).","DAC  may be a red-green-blue digital-to-analog converter configured to provide an analog video output to a display device such as a cathode ray tube (CRT) monitor. In one embodiment, DAC  may be configured to provide a high resolution RGB analog video output at dot rates of 240 MHz. Similarly, encoder  may be configured to supply an encoded video signal to a display. For example, encoder  may provide encoded NTSC or PAL video to an S-Video or composite video television monitor or recording device.","In other embodiments, the video output processor  may output pixel data to other combinations of displays. For example, by outputting pixel data to two DACs  (instead of one DAC  and one encoder ), video output processor  may drive two CRTs. Alternately, by using two encoders , video output processor  may supply appropriate video input to two television monitors. Generally, many different combinations of display devices may be supported by supplying the proper output device and\/or converter for that display device.","Sample-to-Pixel Processing Flow","In one set of embodiments, hardware accelerator  may receive geometric parameters defining primitives such as triangles from media processor , and render the primitives in terms of samples. The samples may be stored in a sample buffer portion of frame buffer  (also referred to as sample buffer  or super-sample buffer ). The samples are then read from the sample buffer  and filtered by sample filter  to generate pixels. The pixels are stored in a pixel storage portion of frame buffer . The pixel storage portion may be double-buffered. Video output processor  reads the pixels from frame buffer  and generates a video stream from the pixels. The video stream may be provided to one or more display devices (e.g. monitors, projectors, head-mounted displays, and so forth) through DAC  and\/or video encoder .","The samples are computed at positions in a two-dimensional sample space (also referred to as rendering space). The sample space may be partitioned into an array of bins (also referred to herein as fragments). The storage of samples in the sample buffer  may be organized according to bins (e.g. bin ) as illustrated in FIG. . Each bin may contain one or more samples. The number of samples per bin may be a programmable parameter.","Super-Sampling with Sample Cache\u2014","One embodiment of super-sampling hardware is shown in FIG. . The frame buffer  is segmented into 3 portions: a sample buffer , a frame buffer A , and a frame buffer B . The hardware accelerator  has subsections comprising a sample filter , a sample cache , and a sample-to-pixel calculation unit .","In one embodiment, 8 copies of 96 deep, 30 bit wide, two read and two write addressable memories are used as the sample cache  to store the 30 bit samples read out from the sample buffer . Other semiconductor memory types including SRAM, SDRAM, RDRAM, SGRAM, VRAM, 3D-RAM, or 3D-RAM 64 are possible and contemplated for the sample cache . The sample cache  acts as temporary storage for the sample data while the sample-to-pixel calculation unit  filters the sample data together (the sample-to-pixel calculation unit may also be referred to as a calculation unit). The sample cache  also resides at the transition from an f clock rate (clock rate for the frame buffer ) to a g clock rate (clock rate for the hardware accelerator ), and therefore may act as the interface between the 2 clock domains. Since the sample cache  and the sample-to-pixel calculation unit  both operate at the higher g clock rate the time required to filter many samples into one pixel may be reduced.","One embodiment of a method that uses a super-sample approach for rendering objects is illustrated by the flowchart in FIG. . The hardware accelerator  selects a sample position grid (step ), calculates sample values for each sample position (step ), stores the sample values in the appropriate bins in the sample buffer  (step ), and sets the filter type and filter boundary (step ). Sample filter  may select an appropriate array of bins in the sample buffer  to accommodate the filter type and extent (step ) and copy the contents of the bin array to the sample cache  (step ). The sample-to-pixel calculation unit  may determine relative weights for the samples that are within the filter extent (step ), possibly by using look-up tables (step ), and calculate pixel values as a weighted sum of the sample values of the samples selected (step ). The sample filter  may store the pixel values in the appropriate memory address in the frame buffer A  or frame buffer B , depending on which buffer is being used by the video output processor  (step ).","Sample Filtering\u2014,,,,& ","There may be a plurality of samples for each pixel of display space, and therefore a filtration process (also referred to as a convolution or calculation process) may be utilized to determine the color values for each pixel. This process may include the steps of selecting a filter type, defining a region of sample space for each filter type, calculating a relative weight for each sample included in the selected region, and summing the weighted color values for all the included samples.","The filter center corresponds to the location of the pixel to be evaluated. The samples that are within the filter's extent may potentially contribute to the color values of the pixel. A square grid subdivides sample space, where each grid square defines a bin. A bin may have an area corresponding to the size of one pixel and may include multiple samples, but other configurations are also possible and contemplated. Each sample may be weighted according to a selected filter function. Filter weights may also be interpolated from a lookup table. A filter size may vary to include samples from 1 to 25 bins. A 5\u00d75 array of bins with 16 samples per bin may involve up to 400 samples in the calculation to determine a single pixel's color values. Other filter size ranges are possible and contemplated.",{"@attributes":{"id":"p-0079","num":"0083"},"figref":["FIGS. 10","FIG. 10","FIG. 10","FIG. 10","FIG. 11","FIG. 11"],"i":["a","b","c","a","b ","a ","b","c ","a","b "],"b":["10","10","11","11"]},"The filter calculates the distance d between the filter center and the sample point. If d is greater than the filter radius, then the weight may be set equal to zero. If d is less than the filter radius, the sample weight may be set equal to a value interpolated from lookup tables of tabulated values for the specific filter function, or calculated directly from a functional expression relating a weight value to the distance d between the filter center and the sample point. The filter calculations may use approximations for the distance to improve throughput, and in some embodiments, the filter calculations may use din lieu of d to improve calculation times (the lookup tables would be tabulated for values of d).","System for Concurrently Filtering Sequential Pixels\u2014, , & ","One set of embodiments of a sample filter  for concurrently filtering sample data for two sequential pixels (in a scan-line) is illustrated in FIG. . The sample filter state machine  may have overall control of the sample filtering process and may generate write addresses for the write cache controller  and read addresses for the read cache controller . The fragment filter queue  carries filter instructions from an f clock domain to a g clock domain.","The sample cache  may store sample data read from a sample buffer  in an array of sample bins. In some embodiments, the sample cache  may be configured to store samples in at least an N by N array of sample bins (N is a positive integer). The sample bins correspond to screen space areas, and the samples within a particular sample bin share common maximum possible and minimum possible x and y coordinates.","A control register  (also referred to herein as a box filter control register) may specify a number P of sequential pixels to filter concurrently (P is a positive integer). In the set of embodiments shown in , P=2, N=5, and there are multiple samples per bin. If the control register is set to a first value, the sample-to-pixel calculation unit may filter one pixel at a time. If the control register is set to a second value, the sample-to-pixel calculation unit may filter two sequential pixels concurrently and may use a box filter of width 1 for each pixel. The control register  may be set in response to user input. In other embodiments, the control register  may be set programmatically based on various metrics or conditions.","A read cache controller  (also referred to as a sample cache reader) may be configured to read a first set of S samples from the sample cache, and output a second set of S samples (S is a positive integer). The second set of S samples may comprise P subsets of samples, and each subset may be selected from the first set of samples to cover the filter region for one of the P pixels. The combined number of samples in the P subsets may be less than or equal to S. In some embodiments, the read cache controller may be configured to output n times N samples at a time from a row of N sample bins and in this case S=nN (n is a positive integer). This process is detailed in and for P=2, N=5, and n=2.","Sample weight calculation unit  may determine sample weights for each of the S samples. If a sample position is outside a specified filter radius, the sample weight may be set to zero. If a box filter is specified, and if two times either an x or y component of the separation between a sample position and a pixel location is greater than a box filter width, then the sample weight calculation unit  may assign a weight of zero to the sample position.","A filter multiplier tree  may be configured to a) receive one or more cycles of S samples grouped in P subsets from the sample cache reader and corresponding S weights from the sample weight calculation unit, b) multiply each sample by the corresponding weight, c) sum the weighted samples for each subset of samples, and d) add the sum to an accumulated sum from prior cycles for each subset.  provides a more detailed representation of the filter multiplier tree  for P=2. When processing one pixel at a time, the normal inputs of samples s through s are received, processed, and accumulated in the normal accumulator . When processing two pixels concurrently, two subsets are received. The first subset may have samples s through s, and the second subset may have samples s through s. The multiplexer  may separate the filter multiplier tree  into two separate units. The two subsets of samples may then be processed separately and accumulated in the box accumulator  and the normal accumulator . The filter multiplier tree  processes the number of cycles of S samples needed to include all samples within the filter regions for each of the P pixels.","A weight accumulator  may be configured to receive one or more cycles of S weights from the sample weight calculation unit in P subsets, accumulate a weight sum for the one or more cycles, and calculate a reciprocal of the accumulated weight sum for each subset. The weight accumulator  may comprise an adder tree with one or more multiplexers to separate portions of the adder tree (similar to the design of the filter multiplier tree ).","Two pixel normalizers A & B may receive the accumulated sum of the weighted samples from the filter multiplier tree and the reciprocal of the accumulated weight sum from the weight accumulator and output the product as a pixel value for each of the two subsets. In some embodiments, one normalizer may be used to output the pixel values in sequence. In other embodiments, P normalizers may be used to output the pixel values concurrently.","Method for Concurrently Filtering Sequential Pixels\u2014","The flowchart in  illustrates one embodiment of a method to filter two or more sequential pixels concurrently. The method may be initiated by selecting a filter type and a filter region (step ), setting a control register  to a value that enables concurrent filtering of P sequential pixels (P is a positive integer) (step ), and identifying a region R (an array A of sample bins) in the sample cache  that includes the sample bins intersected by the P filter regions centered on the P sequential pixel locations (step ).","A user, a host computer, or a graphics processor may specify a filter type and a filter region. The control register may also be set in response to user input. If the control register is set to a first value, the system may filter one pixel at a time using the specified filter. If the control register is set to a second value, the system may filter two sequential pixels concurrently using the specified filter. If the control register is set to a Pvalue, then the system may filter P sequential pixels concurrently using the specified filter. The sample cache may store samples in an N by N array of sample bins and each sample bin may contain one or more samples (N is a positive integer). The sample bins correspond to screen space areas and the samples within a particular sample bin share common maximum possible and minimum possible x and y coordinates.","A set of S samples may be selected from the array A of sample bins in the sample cache  (S is a positive integer). The array A of sample bins may include one or more sets of S samples. Each set of S samples may comprise P subsets of samples corresponding to the P sequential pixels, and each subset may comprise one or more samples from one or more of the sample bins of the array A of sample bins (step ). A sample includes data for one or more of colors, transparency, depth, and location. The sample cache reader  may read n times N samples at a time from a row of N sample bins where n is a positive integer.","In some embodiments, the sample data read from the sample cache  may not include sample locations. The sample weights calculation unit  may then determine sample locations for each sample in the set of S samples (step ). Sample locations may be specified according to a pre-selected pattern of sample positions (such as a regular grid, a perturbed regular grid, a stochastic grid, or a specified permutation of a stored set of selected sample locations).","The sample weights calculation unit  may determine a weight for each of the S sample locations as a function of the distance between the sample location and the corresponding pixel location, the specified filter type, and the specified filter region (step ). A weight of zero may be assigned to a sample location that lies outside a specified filter region. The weight may be interpolated from a look-up table. The weight accumulator  sums the weights for each subset of samples and accumulates a weight sum after each cycle of S sample locations (step ).","The filter multiplier tree  may multiply each sample value by the corresponding sample weight and sum the weighted samples for each subset (step ). The filter multiplier tree  may add the sum of weighted samples to an accumulated sum for each subset of samples (step ) after each cycle of S samples. Steps  through  may be repeated to process S additional samples from the array A of sample bins (step ), until all samples in array A have been processed. Pixel normalizers A & B may then calculate pixel values by dividing the accumulated weighted sample sum by the accumulated weight sum for each subset of samples (step ), and may output pixel values for the P sequential pixels (step ).","Although the embodiments above have been described in considerable detail, other versions are possible. Numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications. Note the section headings used herein are for organizational purposes only and are not meant to limit the description provided herein or the claims attached hereto."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing, as well as other objects, features, and advantages of this invention may be more completely understood by reference to the following detailed description when read together with the accompanying drawings in which:",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 5","FIG. 3"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 6","FIG. 3"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 8","FIG. 3"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIGS. 10","i":["a","b","c "],"b":["10","10"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIGS. 11","i":["a","b "],"b":"11"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIGS. 13","i":["a ","b "],"b":"13"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 15"},"While the invention is susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood, however, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents, and alternatives falling within the spirit and scope of the present invention as defined by the appended claims. Note, the headings are for organizational purposes only and are not meant to be used to limit or interpret the description or claims. Furthermore, note that the word \u201cmay\u201d is used throughout this application in a permissive sense (i.e., having the potential to, being able to), not a mandatory sense (i.e., must).\u201d The term \u201cinclude\u201d, and derivations thereof, mean \u201cincluding, but not limited to\u201d. The term \u201cconnected\u201d means \u201cdirectly or indirectly connected\u201d, and the term \u201ccoupled\u201d means \u201cdirectly or indirectly connected\u201d."]},"DETDESC":[{},{}]}
