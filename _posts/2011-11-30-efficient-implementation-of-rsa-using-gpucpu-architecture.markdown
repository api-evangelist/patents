---
title: Efficient implementation of RSA using GPU/CPU architecture
abstract: Various embodiments are directed to a heterogeneous processor architecture comprised of a CPU and a GPU on the same processor die. The heterogeneous processor architecture may optimize source code in a GPU compiler using vector strip mining to reduce instructions of arbitrary vector lengths into GPU supported vector lengths and loop peeling. It may be first determined that the source code is eligible for optimization if more than one machine code instruction of compiled source code under-utilizes GPU instruction bandwidth limitations. The initial vector strip mining results may be discarded and the first iteration of the inner loop body may be peeled out of the loop. The type of operands in the source code may be lowered and the peeled out inner loop body of source code may be vector strip mined again to obtain optimized source code.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09262166&OS=09262166&RS=09262166
owner: INTEL CORPORATION
number: 09262166
owner_city: Santa Clara
owner_country: US
publication_date: 20111130
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","DETAILED DESCRIPTION"],"p":["General-purpose computing on graphics processing units (GPGPU) is the technique of using a graphics processing unit (GPU), which typically handles computations only for computer graphics, to perform computations for applications traditionally handled by the CPU. GPUs are increasingly being used for general purpose computing. GPUs are well suited for throughput-oriented workloads with abundant parallelism such as task parallel (coarse grained) or data parallel (fine grained) computing. By contrast, CPUs are better suited for applications that are latency-sensitive and have implicit instruction-level parallelism.","One particular example that may benefit from GPGPU is RSA processing. RSA is an algorithm for public-key cryptography. The acronym RSA stands for Rivest, Shamir, and Adleman who were the individuals to first publicly describe the algorithm. RSA encryption and decryption is a computationally expensive algorithm. More research efforts are focusing on accelerating RSA decryptions because decryption is significantly more expensive computationally than encryption. The best CPU implementations of RSA decryption on the latest CPU still cost about 0.7 million cycles. Offloading such an expensive operation to the GPU can increase efficiency and free the CPU for other tasks. However, straightforward porting of a CPU RSA implementation to a GPU would lead to poor performance without utilizing the parallel processing power of the GPU. Accordingly, there may be a need for improved techniques to solve these and other problems.","Heterogeneous processor architectures integrate GPUs along with CPUs on the same die. While CPUs are better suited for applications that are latency-sensitive and have implicit instruction-level parallelism, GPUs target throughput-oriented workloads with abundant parallelism. When both throughput-oriented and latency-oriented processing cores exist on the same die, one may wish to exploit such cores operating in tandem to address heterogeneous workloads. From a performance perspective, GPUs placed on the processor die may receive a boost from cutting-edge CPU manufacturing processes and access to a large on-chip cache. Furthermore, the overhead of transferring data between CPU and GPU memory can virtually be eliminated through sharing the same main memory. In order to take full advantage of such an efficient integrated architecture, however, a programming platform that can seamlessly leverage GPU acceleration within an existing development environment is needed.","The C-for-media (Cm) platform is just such a platform. The Cm platform was originally developed to enable vendor-specific proprietary video-processing algorithms on integrated GPUs. Traditionally, acceleration of video processing phases was achieved through kernels embedded in the graphics driver. A driver would then access and execute these kernels to provide acceleration services when an application made application programming interface (API) calls.","The Cm platform may be characterized as a collaborative execution environment for exploiting both the CPUs and GPUs in heterogeneous processor architectures. Components of the Cm platform may include the Cm language, its implementation (e.g., a compiler) and the Cm runtime. The Cm language may be a simple extension to C\/C++ that provides an intuitive interface to express data-parallelism at a higher level of abstraction. The Cm language was designed to efficiently leverage the single instruction multiple data (SIMD) capability of the GPU. The Cm runtime manages the execution environment while supporting an API that enables developers to easily invoke the GPU from their existing C\/C++ application. The Cm compiler may generate optimized GPU machine code instructions from the GPU-targeted source code written in Cm in which as much parallelism as possible is extracted from the underlying GPU hardware. The Cm compiler may also include a Just-in-Time translator (Jitter) that enables running Cm programs on GPUs.","A goal of the Cm platform is to allow programmers to keep their existing applications, which are parallelized and\/or optimized for the CPUs, but delegate the data-parallel or \u2018massively-parallel\u2019 segments of the application to the on-die GPUs. Modern CPUs are ideal for minimizing execution time of sequential programs through various architectural techniques to hide memory-latency and extract instruction-level parallelism. Moreover, multiple CPUs along with multi-threading capability per CPU are better suited for coarse-grained task-level parallelism. GPUs, on the other hand, are throughput-oriented processors primarily designed for embarrassingly parallel graphics applications. Consequently, in their general-purpose and programmable form GPUs are naturally suited for data-parallel program segments with abundant parallelism. The Cm platform provides a unified programming environment to exploit the full potential of a heterogeneous processor that includes both CPUs and GPUs.","As mentioned above, RSA encryption and especially decryption is a computationally expensive public key cryptography algorithm. Offloading such an expensive operation to the GPU can free the CPU for other tasks. The Cm platform can exploit both the CPU and GPU cores in heterogeneous processor architectures to improve RSA processing by having the CPU set up the GPU environment, execute the main RSA function, and pass data to the GPU that performs the actual calculations.","RSA Processing","RSA involves a public key and a private key. The public key can be known to everyone and is used for encrypting messages. Messages encrypted with the public key can only be decrypted using the private key. A typical RSA implementation involves three steps: key generation, encryption and decryption.","Key Generation","The public and private keys for an RSA algorithm may be generated as follows. The communicating parties may choose two random prime numbers p and q. For security purposes, the integers p and q should be chosen at random, and should be of similar bit-length. The communicating parties may then compute the product as n=pq. n may then be used as the modulus for both the public and private keys. \u03c6(n)=(p\u22121)(q\u22121) may then be computed where \u03c6 is Euler's totient function. An integer e may be chosen such that e and \u03c6(n) are co-prime or relatively prime. e may then be released as the public key exponent. A private key exponent, d, may be determined from the equation (d*e)mod \u03c6(n)=1. The public key may be comprised of the modulus n and the public (or encryption) exponent e. The private key consists of the modulus n and the private (or decryption) exponent d which must be kept secret.","Encryption","As an example, a first party may transmit its public key (n,e) to a second party and keep the private key (d) secret. Suppose the second party then wishes to send message M to the first party. The second party may first turn M into an integer m, such that 0<m<n by using an agreed-upon reversible protocol known as a padding scheme. The second party then computes a ciphertext c according to:\n\nc=mmod n\n","This may be done quickly using the method of exponentiation by squaring. The second party may then transmit c to the first party.","Decryption","The first party may then recover m from c by using its private key exponent d by computing:\n\nm=cmod n\n","Given m, the first party can recover the original message M by reversing the padding scheme. In practice, there may be more efficient methods of calculating cusing pre-computed values. For example, using the Chinese Remainder Algorithm and the following pre-computed values stored as part of the private key for optimization: p and q, d=d (mod p\u22121), d=d (mod q\u22121) and q=qmod p, the recipient may compute the exponentiation m=cmod pq more efficiently as follows:\n\nmmod p\n\nmmod q\n\n*()mod \n\n+()\n","This may be more efficient than computing m=cmod pq even though two modular exponentiations are to be computed. The reason is that these two modular exponentiations both use a smaller exponent and a smaller modulus.","Existing RSA computer implementations are generally designed for CPU execution and do not take advantage of the GPU's single instruction multiple data (SIMD) instruction set. However, a straightforward porting of the above CPU implemented RSA algorithm to the GPU would lead to poor performance without utilizing the parallel processing power of the GPU. An RSA computer implementation is presented that is tailored to the GPU's hardware supported SIMD sizes and alignment requirements and the ability to use SIMD instructions on the GPU to accelerate RSA processing. The end result may be a significant improvement in RSA processing.","To utilize the parallel processing power of the GPU a compiler optimization technique may be implemented that may be referred to herein as loop peeling. Loop peeling may obtain more efficient vector code for execution on the GPU.","Reference is now made to the drawings, wherein like reference numerals are used to refer to like elements throughout. In the following description, for purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding thereof. It may be evident, however, that the novel embodiments can be practiced without these specific details. In other instances, well known structures and devices are shown in block diagram form in order to facilitate a description thereof. The intention is to cover all modifications, equivalents, and alternatives falling within the spirit and scope of the claimed subject matter.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1","b":["110","120","110","115","115","125","130","135","120","110","120","125","130","135","115","110","125","130","135","125","130","135"]},"The RSA main function  may pass the data parameters of the Chinese Remainder Theorem to the GPU functions , , . The parameters described above can be restated as:\n\n=((mod )(mod mod )mod )*mod \n\nin which M represents the plain text of the encrypted message subject to RSA processing. The RSA decryption formula for M may be forwarded to the GPU  for computation. First, the RSA parameters passed by the CPU  may be loaded. The sliding window function  may utilize the mulredc function  to compute two modular exponentiations with half size as:\n\nCmod p\n\nCmod q\n\nThe mulredc function  may then be utilized to compute the rest of the formula to derive M using modular multiplication operations with word by word reduction in Montgomery space and return the result back to the CPU . In computing M, the mulredc function  may call the addmul function  to perform the big number multiplication operations needed to complete the computation of M. The addmul function may be the most frequently called function in computing for M and may provide greater RSA processing efficiency if it can be optimized.\n",{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 2","FIG. 3"]},"From a programmer's perspective, an application (e.g., RSA) using a Cm programming model  includes two modules: a host application  to be executed on CPUs, and GPU Cm kernels  targeted for a GPU . The host application  may be a normal C\/C++ program that can be compiled by a C++ compiler  to a binary application  for execution on a CPU . However, to utilize a GPU  to accelerate certain segments of the code, developers may need to setup and invoke the GPU  through Cm runtime API calls inserted into the host application . The GPU targeted code may need to be organized into GPU Cm kernels  that may be written in the Cm language and may be processed by a Cm compiler  to create machine code that may execute on a GPU . A GPU Cm kernel  may be instantiated into a user-specified number of threads -. Each thread -may then be scheduled to run on an in-order SIMD processing unit called an Execution Unit (EU) -. Unlike the Open Computing Language (OpenCL) or the Compute Unified Device Architecture (CUDA), a single thread -in Cm operates on a block -of data. SIMD computations over the block -of data are expressed in Cm and efficiently translated to an instruction set architecture (ISA) file  by the Cm compiler .","As an example, a host main( ) function  is shown in  that is to be executed on a CPU . The host main( ) function  may include code to initialize and setup the GPU  and GPU kernels  (lines  and ), invoke the GPU  to execute the GPU kernels  (line ), and read the output back (line ). For clarity, macros have been used to hide actual runtime APIs. The function test( )  shown below the function host main( )  may be annotated with the Cm keyword \u201c_GPU_MAIN_\u201d to indicate that the function test( )  may be a Cm GPU kernel  to be executed on a GPU . Threads -instantiated from the GPU Cm kernel  may operate on user-determined blocks -of the data space  and may be dispatched by thread dispatcher  to run on one or more EUs -in the GPU . There may be threads -from multiple GPU Cm kernels  in a single GPU invocation. Only one thread -can be executed on a single EU -until its completion, but every EU -can have multiple co-resident threads -that are time-sliced to increase overall execution throughput. Each EU -may include multiple SIMD lanes  that may be used to execute its SIMD instructions that may be part of its ISA and generated by the Cm compiler  from the GPU Cm kernels . Every EU -may also have access to a large general register file (GRF)  to reduce memory-access overhead. For optimal performance, it may be advisable to keep the entire working-set of a kernel within the GRF . Memory-access latency may be further hidden from the EUs -through a common GPU cache  inside the GPU  and the large processor-level cache  which may be shared with all the CPUs.","In the illustrated Cm parallel processing model  of , programmers may identify data-level parallelism in the algorithm and refactor existing sequential code, if needed, to expose fine-grained parallelism in the GPU Cm kernels . Conceptually, the data space  may need to be divided into thread and EU-friendly blocks -and computations on them expressed in GPU Cm kernels . As exemplified in the function test( )  GPU Cm kernel , a typical computation cycle in this particular GPU Cm kernel  may include: (i) read data blocks from memory  to GRF  (lines  and ), (ii) operations on the read data (lines -), and (iii) write the computed output from GRF  to memory  (line ). Programmers may be encouraged to expose as much parallelism as possible within a block -of data as the Cm compiler  may be responsible for reducing the degree of parallelism to match resources available in an EU -","As shown in , the GPU Cm kernels  may be compiled by the Cm compiler  to an intermediate language common ISA file . Common ISA is a high-level, generic assembly language that may be translated to run on any current or future GPUs. At runtime, a Cm JIT compiler  may translate the common ISA file  into GPU executable code. Next, a host application  may be compiled into a binary application  by a C++ compiler . At runtime, the binary application  may call the Cm-runtime APIs to setup and execute on the GPU . The Cm runtime  may provide the desired hardware abstraction layer to the application. The Cm runtime  may manage device creation, set up input and output buffers, perform kernel creation, set up thread arguments, and dispatch kernels to the GPU . During kernel creation, the Cm runtime  may invoke the Cm JIT compiler  to generate GPU binary from the common ISA file . Subsequently, thread creation and scheduling may be performed entirely in hardware by the GPU's thread dispatcher . Thus, the CPU  is responsible for creating a command queue, queuing tasks, creating memory, passing data to the GPU, and obtaining results from GPU  while the GPU  performs the real RSA calculation(s).","Included herein are one or more flow charts representative of exemplary methodologies for performing novel aspects of the disclosed architecture. While, for purposes of simplicity of explanation, the one or more methodologies shown herein, for example, in the form of a flow chart or flow diagram, are shown and described as a series of acts, it is to be understood and appreciated that the methodologies are not limited by the order of acts, as some acts may, in accordance therewith, occur in a different order and\/or concurrently with other acts from that shown and described herein. For example, those skilled in the art will understand and appreciate that a methodology could alternatively be represented as a series of interrelated states or events, such as in a state diagram. Moreover, not all acts illustrated in a methodology may be required for a novel implementation.",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 4","b":"400"},"In the illustrated embodiment shown in , the logic flow  may pass RSA parameters from the CPU  to the GPU  at block . For example, the parameters C, C, p, q, d, d, and qmod p may be passed from the RSA main function  executed by CPU  to the sliding window function  executed by GPU . The embodiments are not limited to this example.","The logic flow  may compute modular exponentiations at block . For example, the sliding window function  may receive the RSA parameters C, C, p, q, d, d, and qmod p and may begin processing them to solve for M, the encrypted message. The logic flow  may utilize the sliding window function  having a window size=5 to compute two modular exponentiations of half size, Cmod p, and Cmod q. Inside the sliding window function , sixteen (16) calls to the mulredc function  may be made to pre-compute a table for the parameters C, C, p, q, d, d, and qmod p. Once the table is pre-computed, the mulredc function  may be called again inside the conditional branches of the inner loop. The embodiments are not limited to this example.","The logic flow  may compute the rest of the formula to derive M at block . For example, the sliding window function  may call the mulredc function  to perform, for instance, multiple modular multiplication operations along with sub, add, mul, mulredc, redc operations to compute the rest of the formula to derive M. For the big number modular exponentiation operation, a sliding window method as performed by the sliding window function  may be more efficient than a binary scan method. This is because the sliding window function  uses fewer modular multiplication operations to perform the modular exponentiation operation. A window size of five (5) may be chosen as a reasonable tradeoff between speed and memory requirements needed to store the pre-computed parameter table. The math function sub may perform large number subtraction. The math function add may perform big number addition. The math function mul may perform modular multiplication. The math function redc may perform modular reduction. mulredc and redc may be used in the sliding window function. sub may be used by mulredc. sub and add may also be used in the main RSA computation process to derive M. The embodiments are not limited to this example.","The logic flow  may call the addmul  at block . For example, the mulredc function  may call the addmul function  to perform big number multiplication operations. The addmul function  may be optimized using vector strip mining and loop peeling techniques. The embodiments are not limited to this example.","The logic flow  may return the deciphered value for M to the CPU  at block . For example, the GPU  upon completing its calculations and computing M may return its results to the RSA main function  executing on CPU . The embodiments are not limited to this example.","Loop Peeling","A first RSA optimization technique may be termed loop peeling. Loop peeling results in better vector codes by better conforming vector operands to specific hardware supported SIMD sizes and alignment requirements. The loop peeling technique may be implemented for the addmul function to significantly improve RSA processing efficiency since addmul is the most called function when computing M.","The process of optimally reducing high level instructions of arbitrary vector lengths, particularly within a loop, into hardware supported vector widths may be referred to as \u201cvector strip mining\u201d. Loop peeling may improve vector strip mining compiler optimization by generating fewer instructions of higher vector widths that better utilize the available instruction bandwidth within the critical inner loop. For example, the loop peeling and code optimization example described herein may be able to cut the shift operation in the inner loop from 7 movs to 3 movs of machine code. This reduction may result in improved RSA processing efficiency. The critical inner loop for the RSA algorithm may currently be coded in Table 1 as:",{"@attributes":{"id":"p-0042","num":"0041"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003","vector<uint,16> prod;"]},{"entry":[{},". . ."]},{"entry":[{},"vector<uint,16> shift;"]},{"entry":[{},"shift = 0;"]},{"entry":[{},"do {"]},{"entry":[{},"\u2003shift.select<15,1>(1)=prod.select<15,1>(0);"]},{"entry":[{},"\u2003temp += shift;"]},{"entry":[{},"\u2003prod.merge(1,0, temp < shift);"]},{"entry":[{},"\u2003res += prod(15);"]},{"entry":[{},"} while (prod.any( ));"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The shift operation above may be compiled by, for instance, a Cm compiler into machine code for GPU execution that comprises seven (7) movs when conforming to hardware supported SIMD sizes and alignment requirements of the GPU as shown in Table 2.",{"@attributes":{"id":"p-0044","num":"0043"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 2"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003","mov (4) r54.1<1>:ud r50.0<4;4,1>:ud {Align1}"]},{"entry":[{},{},"mov (2) r54.5<1>:ud r50.4<2;2,1>:ud {Align1}"]},{"entry":[{},{},"mov (1) r54.7<1>:ud r50.6<0;1,0>:ud {Align1}"]},{"entry":[{},{},"mov (1) r55.0<1>:ud r50.7<0;1,0>:ud {Align1}"]},{"entry":[{},{},"mov (4) r55.1<1>:ud r51.0<4;4,1>:ud {Align1}"]},{"entry":[{},{},"mov (2) r55.5<1>:ud r51.4<2;2,1>:ud {Align1}"]},{"entry":[{},{},"mov (1) r55.7<1>:ud r51.6<0;1,0>:ud {Align1}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"A key compiler optimization for a vector language such as Cm involves reducing high level Cm source code instructions of arbitrarily large vector lengths into a sequence of component source code instructions of smaller vector lengths that are equal to or less than the maximum vector length supported by an instruction in hardware. The GPU compiler optimization goal is to maximize the vector lengths of the compiled machine code instructions to better utilize the instruction bandwidth provided by the hardware and thus maximize performance. For a GPU, achieving an instruction width of eight (8) or sixteen (16) best utilizes the available instruction bandwidth because the instruction pipeline will internally reduce instructions having vector lengths of sixteen (16) into component instructions having vector lengths of eight (8). An impediment to the goal of this optimization is that the reduced instruction operands must be aligned according to the operand alignment rules of the hardware.","In classic vector strip mining the input source code instructions are scalar instructions. The compiler must unroll a loop of code by a factor generally equal to the maximum vector length supported by the hardware so that (i) the unrolled instructions may be combined into vector instructions of widths equal to the maximum hardware supported width, and (ii) the instruction operands respect the operand alignment requirements of the hardware. In the Cm platform, however, the source code already includes vector instructions. Thus, there is no need for the compiler to unroll the loop. The source code is already in vector form albeit of widths larger than the hardware supported widths. The problem becomes that of decomposing the vector instructions into constituent vector instructions wherein each constituent vector instruction (i) has a vector width equal to or less than the maximum hardware supported width, and (ii) the instruction operands respect the operand alignment requirements of the hardware. The optimization described herein maximizes the vector length of the constituent vector instructions to the available instruction bandwidth.","In general, strip mining code that is already in vector form should yield significantly better results compared to classic vector strip mining. This is because the input source code used in classic vector strip mining is in scalar form where it is not always possible to unroll loops by the required factor very easily.","For the critical inner loop of the RSA kernel source code, the maximum hardware width permitted for a native vector instruction of type Dword is eight (8). Because of the unaligned destination region (r54.1:d) in the critical shift operation, the source code cannot be compiled into reduced instructions of this width and the instruction cannot be strip mined efficiently. As shown above, the source code may be compiled into seven (7) machine code instructions of widths 4, 2, 1, 1, 4, 2, 1 for the critical shift operation. Since the width of all the compiled machine code instructions is less than eight (8), none of the machine code instructions optimally utilize the available instruction bandwidth and overall performance suffers.","The strip mining optimization phase may be improved to take advantage of two compiler derived observations to generate more efficient code for the shift in the critical inner loop.","First, the compiler may obtain higher SIMD sizes for operations if the operands are of smaller sizes. This may be achieved using ushort operands instead of uint operands. A single uncompressed instruction in a GPU can operate on sixteen (16) shorts or eight (8) ints.","Second, from the second iteration of the critical inner loop of the source code, the shifted values are either 0s or 1s that can be represented by using a ushort type. This is determined based on constructed definition use links. In the example shown in Table 1, there are two definitions for the use of the variable prod in the inner loop. One definition is the initialization for prod which is outside the loop, while the other definition is loop carried from the merge statement inside the same loop. Additionally, it can be determined that while the result of the initialization definition of prod from outside the loop requires Dword precision, the result of the loop carried definition being only 1s and 0s requires only word precision.","Based on the two observations, the first iteration of the inner loop may be peeled out prior to strip mining. The type for the operand prod used in the critical shift operation in the remainder of the inner loop may then be lowered from u32 to u16. The type for the shift may be lowered as well because its initialization definition outside the loop is zero (0) which can be represented in ushort and its loop carried definition is prod which was just lowered to word type in the peeled out remainder of the inner loop. The loop peeling step may be performed only if it is anticipated that doing so would enable the subsequent vector strip mining optimization to generate better vector code.","Based on the above, the optimized transformed code for the inner loop may be re-written as shown in Table 3 in which the type lowered operands used in the peeled out loop are named wshift and wprod.",{"@attributes":{"id":"p-0054","num":"0053"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003 ","vector<uint,16> prod;"]},{"entry":[{},". . ."]},{"entry":[{},"vector<uint,16> shift;"]},{"entry":[{},"vector<ushort, 16> wprod;"]},{"entry":[{},"shift = 0;"]},{"entry":[{},"shift.select<15,1>(1) = prod.select<15,1>(0);"]},{"entry":[{},"temp += shift;"]},{"entry":[{},"wprod.merge(1,0, temp < shift);"]},{"entry":[{},"res += prod(15);"]},{"entry":[{},"vector<ushort,16> wshift;"]},{"entry":[{},"wshift(0) = 0"]},{"entry":[{},"while (wprod.any( )) {"]},{"entry":[{},"\u2003wshift.select<15,1>(1)=wprod.select<15,1>(0);"]},{"entry":[{},"\u2003temp += wshift;"]},{"entry":[{},"\u2003wprod.merge(1,0, temp < wshift);"]},{"entry":[{},"\u2003res += wprod(15);"]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The above optimized code may be compiled into machine code instructions comprising four (4) movs as shown in Table 4.",{"@attributes":{"id":"p-0056","num":"0055"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003","mov (8) r19.1<1>:uw r17.0<8;8,1>:uw {Align1}"]},{"entry":[{},"mov (4) r19.9<1>:uw r17.8<4;4,1>:uw {Align1}"]},{"entry":[{},"mov (2) r19.13<1>:uw r17.12<2;2,1>:uw {Align1}"]},{"entry":[{},"mov (1) r19.15<1>:uw r17.14<0;1,0>:uw {Align1}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"It is noted that only the first mov in the machine code instruction sequence shown in Table 4 optimally utilizes the available instruction bandwidth for the GPU hardware, while the other three (3) mov instructions still under-utilize the available instruction bandwidth. Nevertheless, the compiled instruction throughput is better than the original un-optimized code that was compiled into machine code that comprised seven (7) under-utilized movs (See, Table 2).","At this point an additional optimization to the layout of type lowered variables may be made to further reduce the number of the movs in the inner loop. The 16-wide wshift variable may be split into two 9-wide wshift1 and wshift2 variables. This improved layout may result in the following transformed optimized source code shown in Table 5 in which the type lowered operands used in the peeled out inner loop are named wshift1, wshift2, and wprod.",{"@attributes":{"id":"p-0059","num":"0058"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003","vector<uint,16> shift;"]},{"entry":[{},"shift(0) = 0;"]},{"entry":[{},"shift.select<15,1>(1)=prod.select<15,1>(0);"]},{"entry":[{},"temp += shift;"]},{"entry":[{},"vector<ushort,16> wprod;"]},{"entry":[{},"wprod.merge(1,0, temp < shift);"]},{"entry":[{},"res += wprod(15);"]},{"entry":[{},"vector<ushort,9> wshift1;"]},{"entry":[{},"vector<ushort,9> wshift2;"]},{"entry":[{},"wshift1(0) = 0;"]},{"entry":[{},"while (wprod.any( )) {"]},{"entry":[{},"\u2003wshift1.select<8,1>(1)=wprod.select<8,1>(0);"]},{"entry":[{},"\u2003wshift2(0) = wprod(7);"]},{"entry":[{},"\u2003wshift2.select<8,1>(1)=wprod.select<8,1>(8);"]},{"entry":[{},"\u2003temp.select<8,1>(0) += wshift1.select<8,1>(0);"]},{"entry":[{},"\u2003temp.select<8,1>(8) += wshift2.select<8,1>(0);"]},{"entry":[{},"\u2003wprod.select<8,1>(0).merge(1,0, temp.select<8,1>(0) <"]},{"entry":[{},"\u2003wshift1.select<8,1>(0));"]},{"entry":[{},"\u2003wprod.select<8,1>(8).merge(1,0, temp.select<8,1>(8) <"]},{"entry":[{},"\u2003wshift2.select<8,1>(0));"]},{"entry":[{},"\u2003res += wprod(15);"]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The shift operation sequence in the inner loop may now be compiled into machine code instructions comprising 3 movs as shown in Table 6 below.",{"@attributes":{"id":"p-0061","num":"0060"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 6"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003","mov (8) r19.1<1>:uw r17.0<8;8,1>:uw {Align1}"]},{"entry":[{},{},"mov (1) r22.0<1>:uw r17.7<0;1,0>:uw {Align1}"]},{"entry":[{},{},"mov (8) r22.1<1>:uw r17.8<8;8,1>:uw {Align1}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"This may be the optimal machine code instruction sequence because only one instruction in the shift operation underutilizes the available bandwidth which cannot be avoided. Although the SIMD16 merge instruction has been split into two SIMD8 instructions, the instruction throughput remains the same because the instruction pipeline will internally break down the SIMD16 instruction into two SIMD8 instructions automatically.",{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 5","b":["500","500"]},"Direct porting of RSA processing from a CPU only implementation to a combination of CPU and GPU will not likely result in the most efficient use of the available resources. The RSA code written for the CPU may not be optimized to run on a GPU. Through vector strip mining and loop peeling, the RSA code may be optimized to run more efficiently on a heterogeneous CPU\/GPU platform.","In the illustrated embodiment shown in , the logic flow  may perform an initial vector strip mining on the inner loop body of source code at block . Vector strip mining is a process of optimally reducing high level instructions of arbitrary vector lengths, particularly within a loop of source code, into hardware supported vector widths. For example, the shift operation (see, Table 1) for the vector strip mined code that was written for a CPU only implementation may have resulted in seven (7) machine code instructions (see, Table 2). However, none of the seven (7) machine code instructions utilizes the GPU's maximum available instruction hardware bandwidth of eight (8) causing overall performance to suffer.","The logic flow  may determine if more than one instruction of machine code compiled from the inner loop is below the GPU instruction bandwidth utilization threshold at block . From above, the initial vector strip mined code may have resulted in seven (7) machine code instructions, none of which utilize the total available instruction bandwidth. Thus, the inner loop may be a candidate for optimization provided certain additional conditions can be met. If the machine code instruction set includes no more than one underutilized instruction there may be no need for further optimization. The embodiments are not limited to this example.","The logic flow  may determine if an underutilized machine code instruction meets three (3) additional criteria at block . For example, a first criteria may be to determine whether an underutilized machine code instruction is associated with two (2) definitions in the source code. The first definition being an initialization definition that occurs outside the inner loop and the second definition being a loop carried definition. A second criteria may be to determine if the initialization definition has an operation type of dword while the loop carried definition has an operation type of word or byte. A third criteria may be to determine whether the destination of the initialization definition and the loop carried definition is identical and of the type dword. If all three (3) of the above criteria are not met, the code may not be eligible for the type of optimization described herein. The embodiments are not limited to this example.","The logic flow  may discard the initial vector strip mining results at block . For example, if the three (3) criteria set out above are met, the inner loop source code may be optimizable by the compiler. In such case, the initial vector strip mining results obtained at block  may be discarded. The embodiments are not limited to this example.","The logic flow  may perform a loop peeling procedure at block . For example, the first iteration of the inner loop may be peeled out prior to strip mining the code. The logic flow  may then lower the type for the operand prod identified in block  from u32 to u16 used in the critical shift operation in the remainder of the inner loop of code. The type for shift may be lowered as well because its initialization definition outside the loop is zero (0) which can be represented in ushort and its other loop carried definition is prod which was just lowered to word type in the peeled out remainder of the inner loop of code. The embodiments are not limited to this example.","The logic flow  may re-perform the vector strip mining optimization of the inner loop at block . For example, the optimized transformed code for the inner loop may be re-written after vector strip mining as shown in Table 5. The type lowered operands used in the peeled out loop are now named wshift and wprod. The embodiments are not limited to this example.","The logic flow  may again determine if more than one instruction of machine code compiled from the inner loop of source code is below the instruction bandwidth utilization threshold at block . After block  above, the re-performed vector strip mined code may have resulted in four (4) machine code instructions, only one of which utilizes the total available instruction bandwidth. Thus, the inner loop of source code may be a candidate for further optimization because there remain more than one underutilized machine code instruction. If there are less than two machine code instructions that underutilize the available GPU hardware bandwidth then the RSA code optimization process is complete. The embodiments are not limited to this example.","The logic flow  may attempt further code optimization to improve variable layout to generate better strip mining results at block . For example, an additional optimization to the layout of type lowered variables may be made to further reduce the number of the movs after compiling the inner loop of source code. For instance, the 16-wide wshift variable may be split into two 9-wide wshift1 and wshift2 variables. This improved layout may result in the transformed code shown in Table 5 in which the type lowered operands used in the peeled out loop of source code are now named wshift1, wshift2, and wprod. The embodiments are not limited to this example.","The logic flow  may re-perform the vector strip mining of the inner loop of source code at block . For example, compiling the code generated at block  may yield three (3) machine code mov instructions. This may be the optimal sequence because only one of the machine code instructions in the shift operation underutilizes the available GPU hardware bandwidth which cannot be avoided. Although the SIMD16 merge instruction has been split into two SIMD8 instructions, the instruction throughput remains the same as the instruction pipeline will internally break down the SIMD16 instruction into two SIMD8 instructions automatically. The embodiments are not limited to this example.","Various embodiments may be implemented using hardware elements, software elements, or a combination of both. Examples of hardware elements may include processors, microprocessors, circuits, circuit elements (e.g., transistors, resistors, capacitors, inductors, and so forth), integrated circuits, application specific integrated circuits (ASIC), programmable logic devices (PLD), digital signal processors (DSP), field programmable gate array (FPGA), logic gates, registers, semiconductor device, chips, microchips, chip sets, and so forth. Examples of software may include software components, programs, applications, computer programs, application programs, system programs, machine programs, operating system software, middleware, firmware, software modules, routines, subroutines, functions, methods, procedures, software interfaces, application program interfaces (API), instruction sets, computing code, computer code, code segments, computer code segments, words, values, symbols, or any combination thereof. Determining whether an embodiment is implemented using hardware elements and\/or software elements may vary in accordance with any number of factors, such as desired computational rate, power levels, heat tolerances, processing cycle budget, input data rates, output data rates, memory resources, data bus speeds and other design or performance constraints.",{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIG. 6","b":["600","600","600","600"]},"In embodiments, system  comprises a platform  coupled to a display . Platform  may receive content from a content device such as content services device(s)  or content delivery device(s)  or other similar content sources. A navigation controller  comprising one or more navigation features may be used to interact with, for example, platform  and\/or display . Each of these components is described in more detail below.","In embodiments, platform  may comprise any combination of a chipset , processor(s) , memory , storage , graphics subsystem , applications  and\/or radio . Chipset  may provide intercommunication among processor , memory , storage , graphics subsystem , applications  and\/or radio . For example, chipset  may include a storage adapter (not depicted) capable of providing intercommunication with storage .","Processor(s)  may be implemented as Complex Instruction Set Computer (CISC) or Reduced Instruction Set Computer (RISC) processors, x86 instruction set compatible processors, multi-core, or any other microprocessor or central processing unit (CPU). In embodiments, processor(s)  may comprise dual-core processor(s), dual-core mobile processor(s), and so forth.","Memory  may be implemented as a volatile memory device such as, but not limited to, a Random Access Memory (RAM), Dynamic Random Access Memory (DRAM), or Static RAM (SRAM).","Storage  may be implemented as a non-volatile storage device such as, but not limited to, a magnetic disk drive, optical disk drive, tape drive, an internal storage device, an attached storage device, flash memory, battery backed-up SDRAM (synchronous DRAM), and\/or a network accessible storage device. In embodiments, storage  may comprise technology to increase the storage performance enhanced protection for valuable digital media when multiple hard drives are included, for example.","Graphics subsystem  may perform processing of images such as still or video for display. Graphics subsystem  may be a graphics processing unit (GPU) or a visual processing unit (VPU), for example. An analog or digital interface may be used to communicatively couple graphics subsystem  and display . For example, the interface may be any of a High-Definition Multimedia Interface, DisplayPort, wireless HDMI, and\/or wireless HD compliant techniques. Graphics subsystem  could be integrated into processor  or chipset . Graphics subsystem  could be a stand-alone card communicatively coupled to chipset .","The graphics and\/or video processing techniques described herein may be implemented in various hardware architectures. For example, graphics and\/or video functionality may be integrated within a chipset. Alternatively, a discrete graphics and\/or video processor may be used. As still another embodiment, the graphics and\/or video functions may be implemented by a general purpose processor, including a multi-core processor. In a further embodiment, the functions may be implemented in a consumer electronics device.","Radio  may include one or more radios capable of transmitting and receiving signals using various suitable wireless communications techniques. Such techniques may involve communications across one or more wireless networks. Exemplary wireless networks include (but are not limited to) wireless local area networks (WLANs), wireless personal area networks (WPANs), wireless metropolitan area network (WMANs), cellular networks, and satellite networks. In communicating across such networks, radio  may operate in accordance with one or more applicable standards in any version.","In embodiments, display  may comprise any television type monitor or display. Display  may comprise, for example, a computer display screen, touch screen display, video monitor, television-like device, and\/or a television. Display  may be digital and\/or analog. In embodiments, display  may be a holographic display. Also, display  may be a transparent surface that may receive a visual projection. Such projections may convey various forms of information, images, and\/or objects. For example, such projections may be a visual overlay for a mobile augmented reality (MAR) application. Under the control of one or more software applications , platform  may display user interface  on display .","In embodiments, content services device(s)  may be hosted by any national, international and\/or independent service and thus accessible to platform  via the Internet, for example. Content services device(s)  may be coupled to platform  and\/or to display . Platform  and\/or content services device(s)  may be coupled to a network  to communicate (e.g., send and\/or receive) media information to and from network . Content delivery device(s)  also may be coupled to platform  and\/or to display .","In embodiments, content services device(s)  may comprise a cable television box, personal computer, network, telephone, Internet enabled devices or appliance capable of delivering digital information and\/or content, and any other similar device capable of unidirectionally or bidirectionally communicating content between content providers and platform  and\/display , via network  or directly. It will be appreciated that the content may be communicated unidirectionally and\/or bidirectionally to and from any one of the components in system  and a content provider via network . Examples of content may include any media information including, for example, video, music, medical and gaming information, and so forth.","Content services device(s)  receives content such as cable television programming including media information, digital information, and\/or other content. Examples of content providers may include any cable or satellite television or radio or Internet content providers. The provided examples are not meant to limit embodiments of the invention.","In embodiments, platform  may receive control signals from navigation controller  having one or more navigation features. The navigation features of controller  may be used to interact with user interface , for example. In embodiments, navigation controller  may be a pointing device that may be a computer hardware component (specifically human interface device) that allows a user to input spatial (e.g., continuous and multi-dimensional) data into a computer. Many systems such as graphical user interfaces (GUI), and televisions and monitors allow the user to control and provide data to the computer or television using physical gestures.","Movements of the navigation features of controller  may be echoed on a display (e.g., display ) by movements of a pointer, cursor, focus ring, or other visual indicators displayed on the display. For example, under the control of software applications , the navigation features located on navigation controller  may be mapped to virtual navigation features displayed on user interface , for example. In embodiments, controller  may not be a separate component but integrated into platform  and\/or display . Embodiments, however, are not limited to the elements or in the context shown or described herein.","In embodiments, drivers (not shown) may comprise technology to enable users to instantly turn on and off platform  like a television with the touch of a button after initial boot-up, when enabled, for example. Program logic may allow platform  to stream content to media adaptors or other content services device(s)  or content delivery device(s)  when the platform is turned \u201coff.\u201d In addition, chip set  may comprise hardware and\/or software support for 5.1 surround sound audio and\/or high definition 6.1 surround sound audio, for example. Drivers may include a graphics driver for integrated graphics platforms. In embodiments, the graphics driver may comprise a peripheral component interconnect (PCI) Express graphics card.","In various embodiments, any one or more of the components shown in system  may be integrated. For example, platform  and content services device(s)  may be integrated, or platform  and content delivery device(s)  may be integrated, or platform , content services device(s) , and content delivery device(s)  may be integrated, for example. In various embodiments, platform  and display  may be an integrated unit. Display  and content service device(s)  may be integrated, or display  and content delivery device(s)  may be integrated, for example. These examples are not meant to limit the invention.","In various embodiments, system  may be implemented as a wireless system, a wired system, or a combination of both. When implemented as a wireless system, system  may include components and interfaces suitable for communicating over a wireless shared media, such as one or more antennas, transmitters, receivers, transceivers, amplifiers, filters, control logic, and so forth. An example of wireless shared media may include portions of a wireless spectrum, such as the RF spectrum and so forth. When implemented as a wired system, system  may include components and interfaces suitable for communicating over wired communications media, such as input\/output (I\/O) adapters, physical connectors to connect the I\/O adapter with a corresponding wired communications medium, a network interface card (NIC), disc controller, video controller, audio controller, and so forth. Examples of wired communications media may include a wire, cable, metal leads, printed circuit board (PCB), backplane, switch fabric, semiconductor material, twisted-pair wire, co-axial cable, fiber optics, and so forth.","Platform  may establish one or more logical or physical channels to communicate information. The information may include media information and control information. Media information may refer to any data representing content meant for a user. Examples of content may include, for example, data from a voice conversation, videoconference, streaming video, electronic mail (\u201cemail\u201d) message, voice mail message, alphanumeric symbols, graphics, image, video, text and so forth. Data from a voice conversation may be, for example, speech information, silence periods, background noise, comfort noise, tones and so forth. Control information may refer to any data representing commands, instructions or control words meant for an automated system. For example, control information may be used to route media information through a system, or instruct a node to process the media information in a predetermined manner. The embodiments, however, are not limited to the elements or in the context shown or described in .","As described above, system  may be embodied in varying physical styles or form factors.  illustrates embodiments of a small form factor device  in which system  may be embodied. In embodiments, for example, device  may be implemented as a mobile computing device having wireless capabilities. A mobile computing device may refer to any device having a processing system and a mobile power source or supply, such as one or more batteries, for example.","As described above, examples of a mobile computing device may include a personal computer (PC), laptop computer, ultra-laptop computer, tablet, touch pad, portable computer, handheld computer, palmtop computer, personal digital assistant (PDA), cellular telephone, combination cellular telephone\/PDA, television, smart device (e.g., smart phone, smart tablet or smart television), mobile internet device (MID), messaging device, data communication device, and so forth.","Examples of a mobile computing device also may include computers that are arranged to be worn by a person, such as a wrist computer, finger computer, ring computer, eyeglass computer, belt-clip computer, arm-band computer, shoe computers, clothing computers, and other wearable computers. In embodiments, for example, a mobile computing device may be implemented as a smart phone capable of executing computer applications, as well as voice communications and\/or data communications. Although some embodiments may be described with a mobile computing device implemented as a smart phone by way of example, it may be appreciated that other embodiments may be implemented using other wireless mobile computing devices as well. The embodiments are not limited in this context.","As shown in , device  may comprise a housing , a display , an input\/output (I\/O) device , and an antenna . Device  also may comprise navigation features . Display  may comprise any suitable display unit for displaying information appropriate for a mobile computing device. I\/O device  may comprise any suitable I\/O device for entering information into a mobile computing device. Examples for I\/O device  may include an alphanumeric keyboard, a numeric keypad, a touch pad, input keys, buttons, switches, rocker switches, microphones, speakers, voice recognition device and software, and so forth. Information also may be entered into device  by way of microphone. Such information may be digitized by a voice recognition device. The embodiments are not limited in this context.","Various embodiments may be implemented using hardware elements, software elements, or a combination of both. Examples of hardware elements may include processors, microprocessors, circuits, circuit elements (e.g., transistors, resistors, capacitors, inductors, and so forth), integrated circuits, application specific integrated circuits (ASIC), programmable logic devices (PLD), digital signal processors (DSP), field programmable gate array (FPGA), logic gates, registers, semiconductor device, chips, microchips, chip sets, and so forth. Examples of software may include software components, programs, applications, computer programs, application programs, system programs, machine programs, operating system software, middleware, firmware, software modules, routines, subroutines, functions, methods, procedures, software interfaces, application program interfaces (API), instruction sets, computing code, computer code, code segments, computer code segments, words, values, symbols, or any combination thereof. Determining whether an embodiment is implemented using hardware elements and\/or software elements may vary in accordance with any number of factors, such as desired computational rate, power levels, heat tolerances, processing cycle budget, input data rates, output data rates, memory resources, data bus speeds and other design or performance constraints.","One or more aspects of at least one embodiment may be implemented by representative instructions stored on a machine-readable medium which represents various logic within the processor, which when read by a machine causes the machine to fabricate logic to perform the techniques described herein. Such representations, known as \u201cIP cores\u201d may be stored on a tangible, machine readable medium and supplied to various customers or manufacturing facilities to load into the fabrication machines that actually make the logic or processor.","One or more aspects of at least one embodiment may be implemented by representative instructions stored on a machine-readable medium which represents various logic within the processor, which when read by a machine causes the machine to fabricate logic to perform the techniques described herein. Such representations, known as \u201cIP cores\u201d may be stored on a tangible, machine readable medium and supplied to various customers or manufacturing facilities to load into the fabrication machines that actually make the logic or processor.","Some embodiments may be described using the expression \u201cone embodiment\u201d or \u201can embodiment\u201d along with their derivatives. These terms mean that a particular feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment. The appearances of the phrase \u201cin one embodiment\u201d in various places in the specification are not necessarily all referring to the same embodiment. Further, some embodiments may be described using the expression \u201ccoupled\u201d and \u201cconnected\u201d along with their derivatives. These terms are not necessarily intended as synonyms for each other. For example, some embodiments may be described using the terms \u201cconnected\u201d and\/or \u201ccoupled\u201d to indicate that two or more elements are in direct physical or electrical contact with each other. The term \u201ccoupled,\u201d however, may also mean that two or more elements are not in direct contact with each other, but yet still co-operate or interact with each other.","It is emphasized that the Abstract of the Disclosure is provided to allow a reader to quickly ascertain the nature of the technical disclosure. It is submitted with the understanding that it will not be used to interpret or limit the scope or meaning of the claims. In addition, in the foregoing Detailed Description, it can be seen that various features are grouped together in a single embodiment for the purpose of streamlining the disclosure. This method of disclosure is not to be interpreted as reflecting an intention that the claimed embodiments require more features than are expressly recited in each claim. Rather, as the following claims reflect, inventive subject matter lies in less than all features of a single disclosed embodiment. Thus the following claims are hereby incorporated into the Detailed Description, with each claim standing on its own as a separate embodiment. In the appended claims, the terms \u201cincluding\u201d and \u201cin which\u201d are used as the plain-English equivalents of the respective terms \u201ccomprising\u201d and \u201cwherein,\u201d respectively. Moreover, the terms \u201cfirst,\u201d \u201csecond,\u201d \u201cthird,\u201d and so forth, are used merely as labels, and are not intended to impose numerical requirements on their objects.","What has been described above includes examples of the disclosed architecture. It is, of course, not possible to describe every conceivable combination of components and\/or methodologies, but one of ordinary skill in the art may recognize that many further combinations and permutations are possible. Accordingly, the novel architecture is intended to embrace all such alterations, modifications and variations that fall within the spirit and scope of the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0004","num":"0003"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":["FIG. 7","FIG. 6"]}]},"DETDESC":[{},{}]}
