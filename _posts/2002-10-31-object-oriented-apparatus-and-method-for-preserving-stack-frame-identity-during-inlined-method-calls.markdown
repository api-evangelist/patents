---
title: Object oriented apparatus and method for preserving stack frame identity during inlined method calls
abstract: An object oriented mechanism and method provide exact information about the current invocation stack even when methods are inlined. A virtual stack frame mechanism determines whether a called method has been inlined, and counts both virtual frames and real frames when determining information corresponding to a called method. The virtual stack frame mechanism is preferably implemented in an object oriented class that provides methods for determining information corresponding to a called method.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07080368&OS=07080368&RS=07080368
owner: International Business Machines Corporation
number: 07080368
owner_city: Armonk
owner_country: US
publication_date: 20021031
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","DISCLOSURE OF INVENTION","BEST MODE FOR CARRYING OUT THE INVENTION","OVERVIEW","Object Oriented Technology v. Procedural Technology","Java Programming Language","Invocation Stacks in Java","DETAILED DESCRIPTION"],"p":["1. Technical Field","This invention generally relates to computer systems. More specifically, this invention relates to identifying stack frames corresponding to called methods in object oriented systems.","2. Background Art","Since the dawn of the computer age, computer systems have evolved into extremely sophisticated devices, and computer systems may be found in many different settings. Computer systems typically include a combination of hardware, such as semiconductors and circuit boards, and software, also known as computer programs. As advances in semiconductor processing and computer architecture push the performance of the computer hardware higher, more sophisticated computer software has evolved to take advantage of the higher performance of the hardware, resulting in computer systems today that are much more powerful than just a few years ago.","Computer systems typically include operating system software that controls the basic function of the computer, and one or more software application programs that run under the control of the operating system to perform desired tasks. For example, a typical IBM Personal Computer may run a Microsoft Windows operating system, and under the control of the operating system, a user may execute an application program, such as a word processor. As the capabilities of computer systems have increased, the application software programs designed for high performance computer systems have become extremely powerful. Additionally, software development costs have continued to rise because more powerful and complex programs take more time, and hence more money, to produce.","One way in which the performance of application software programs has been improved while the associated development costs have been reduced is by using object oriented programming concepts. The goal of using object oriented programming is to create small, reusable sections of program code known as \u201cobjects\u201d that can be quickly and easily combined and re-used to create new programs. This is similar to the idea of using the same set of building blocks again and again to create many different structures. The modular and re-usable aspects of objects will typically speed development of new programs, thereby reducing the costs associated with the development cycle. In addition, by creating and re-using a comprehensive set of well-tested objects, a more stable, uniform, and consistent approach to developing new computer programs can be achieved.","The Java programming language developed by Sun Microsystems is one modern object oriented programming language that has become very popular in recent years. Java creates one or more invocation stacks at run-time that are used to store information when a method is called (or invoked). When a method is invoked, a new stack frame is typically allocated that contains information for the called method. Java includes several classes that contain methods which require exact information to be gathered about the current invocation stack.","One thing that can complicate or even preclude the gathering of exact information about the current invocation stack is the inlining of methods. In some circumstances code can be optimized by incorporating (or inlining) code from one method into another method. By inlining a method into another method, only one invocation stack frame exists where there would normally be two, one of each method. As a result, inlining has been generally viewed as being incompatible with gathering exact information about the current invocation stack. To be fully compatible with Java, the capability of gathering exact information about the current invocation stack is an absolute necessity. As a result, computer system manufacturers are faced with the dilemma of either enabling inlining to optimize code at the expense of full compatibility with Java, or disabling inlining to assure full compatibility with Java. Without a way to provide exact invocation stack information when one of more stack frames include inlined methods, the computer industry will continue to suffer from Java-compliant code that cannot benefit from inlining of methods, or non-compliant code that benefits from the inlining of methods.","According to the preferred embodiments, an object oriented mechanism and method provide exact information about the current invocation stack even when methods are inlined. A virtual stack frame mechanism determines whether a called method has been inlined, and counts both virtual frames and real frames when determining information corresponding to a called method. The virtual stack frame mechanism is preferably implemented in an object oriented class that provides methods for determining information corresponding to a called method.","The present invention relates to the execution of object oriented programs. For those individuals who are not generally familiar with object oriented programs, the Overview section below presents many of the concepts that will help to understand the invention.","Object oriented programming is a method of implementation in which programs are organized as cooperative collections of objects, each of which represents an instance of some class, and whose classes are all members of a hierarchy of classes united via inheritance relationships. Object oriented programming differs from standard procedural programming in that it uses objects, not algorithms, as the fundamental building blocks for creating computer programs. This difference stems from the fact that the design focus of object oriented programming technology is wholly different than that of procedural programming technology.","The focus of procedural-based design is on the overall process that solves the problem; whereas, the focus of object oriented design is on how the problem can be broken down into a set of autonomous entities that can work together to provide a solution. The autonomous entities of object oriented technology are, of course, objects. Said another way, object oriented technology is significantly different from procedural technology because problems are broken down into sets of cooperating objects instead of into hierarchies of nested computer programs or procedures.","Thus, a pure object oriented program is made up of code entities called objects. Each object is an identifiable, encapsulated piece of code that provides one or more object interface and internal object data. In particular, all data is encapsulated by the object interface such that other objects must communicate with that object through its object interface. The only way to retrieve, process or otherwise operate on the encapsulated data is through the methods defined on the object. This protects the internal data portion of the object from outside tampering. Additionally, because outside objects have no access to the internal implementation of an object, that internal implementation can change without affecting other aspects of the program.","In this way, the object system isolates the requestor of services (client objects) from the providers of services (server objects) by a well defined encapsulating interface. Thus, in the classic object model, a client object sends request messages (e.g., method calls) to server objects to perform any necessary or desired function. The message identifies a particular server object and specifies what method is to be performed by the server object, and also supplies any required parameters. The server object receives and interprets the message, and can then determine what service to perform.","A central concept in object oriented programming is the class. A class is a template that defines a type of object. A class outlines the makeup of objects that belong to that class. By defining a class, objects can be created that belong to the class without having to rewrite the entire definition for each new object as it is created. This feature of object oriented programming promotes the reusability of existing definitions and promotes efficient use of program code.","There are many computer languages that presently support object oriented programming techniques. For example, Smalltalk, Object Pascal, C++ and Java are all examples of programming languages that support object oriented programming to one degree of another.","Java is a modern object oriented programming language designed by Sun Microsystems that has grown in popularity in recent years. Java offers many features and advantages that makes it a desirable programming language to use. First, Java is specifically designed to create small application programs, commonly called \u201capplets,\u201d that can reside on the network in centralized servers, and which are delivered to the client machine only when needed. Second, Java is completely platform independent. A Java program can be written once and can then run on any type of platform that contains a Java Virtual Machine (JVM). The JVM model is supported by most computer vendors, thereby allowing a software vendor to have access to hardware, and software systems produced by many different companies. Finally, Java is an object oriented language, meaning that software written in Java can take advantage of the benefits of object oriented programming techniques.","As in other objects oriented systems, operations in Java are performed by one object calling a method on another object. These objects can reside locally on the same machine or on separate JVM's physically located on separate computers or systems.","The Java programming language defines one or more invocation stacks that are used to store information when a method is called (or invoked).  shows various views of an invocation stack  in different states. Referring to , invocation stack  is shown before any methods are invoked, with its stack pointer  at the bottom of the stack. Entries are stored on the stack bottom up. Note that the stack pointer could equally be at the top of the stack, with the entries stored on the stack top down.  illustrates what happens when method A is invoked. An invocation stack frame  for A is pushed on the stack, and the stack pointer  is then moved to the next available location on the stack.","An invocation stack frame can contain many different types of data. For example, an invocation stack frame can contain the stored state of all processor registers when the method was invoked, so that some or all of these values can be restored when the method has completed. An invocation stack frame can also contain storage for any variables that are local to the method. Thus, if an integer m is declared as a local variable, the invocation stack frame would contain the memory allocation for m. A stack frame may also contain any amount of information describing the state of the machine and\/or the state of the executing program that existed at the time the method was called. A stack frame within the scope of the preferred embodiments can include any and all data that corresponds to a called method.","Referring to , we assume that in the execution of method A, method B is invoked, so that stack frame  for method B is pushed on the invocation stack , and the stack pointer  is moved to the next available location. We assume that method B calls itself, which causes another instance  of a stack frame for method B to be stored on the invocation stack , with the stack pointer  moved to the next available location, as shown in . We assume that the second invocation of method B then calls method C, so that stack frame  for method C is then pushed onto the invocation stack and stack pointer  is moved to the next available location, as shown in . At this point we assume that method C does not call any other methods, and runs to completion. This causes the stack pointer  to move down to the beginning of the stack frame for method C, effectively reclaiming the area of the invocation stack  that was used for stack frame , as shown in .","An apparatus and method in accordance with the preferred embodiments allow returning exact invocation stack frame information even when methods are inlined and thus do not appear on the invocation stack. In this manner, a computer program can benefit from inlining while also remaining compliant with requirements to accurately return stack frame information.","Referring now to , a computer system  is one suitable implementation of an apparatus in accordance with the preferred embodiments of the invention. Computer system  is an IBM iSeries computer system. However, those skilled in the art will appreciate that the mechanisms and apparatus of the present invention apply equally to any computer system, regardless of whether the computer system is a complicated multi-user computing apparatus, a single user workstation, or an embedded control system. As shown in , computer system  comprises a processor , a main memory , a mass storage interface , a display interface , and a network interface . These system components are interconnected through the use of a system bus . Mass storage interface  is used to connect mass storage devices (such as a direct access storage device ) to computer system . One specific type of direct access storage device  is a readable and writable CD-RW drive, which may store data to and read data from a CD-RW 195.","Main memory  in accordance with the preferred embodiments contains data , an operating system , a computer program , an invocation stack , and a virtual stack frame mechanism . Computer program  preferably includes one or more inlined methods . Invocation stack  preferably includes one or more stack frames . Computer system  utilizes well known virtual addressing mechanisms that allow the programs of computer system  to behave as if they only have access to a large, single storage entity instead of access to multiple, smaller storage entities such as main memory  and DASD device . Therefore, while data , operating system , computer programs , and invocation stack  are shown to reside in main memory , those skilled in the art will recognize that these items are not necessarily all completely contained in main memory  at the same time. It should also be noted that the term \u201cmemory\u201d is used herein to generically refer to the entire virtual memory of computer system , and may include the virtual memory of other computer systems coupled to computer system .","Data  represents any data that serves as input to or output from any program in computer system . Operating system  is a multitasking operating system known in the industry as OS\/400; however, those skilled in the art will appreciate that the spirit and scope of the present invention is not limited to any one operating system. Computer program  is a computer program that is executed by processor . Computer program  is preferably a computer program written in an object oriented language. Invocation stack  is a run-time data structure that is used to store information relating to methods called in the computer program . Invocation stack  is preferably comprised of a plurality of stack frames , as is known in the art. Virtual stack frame mechanism  is preferably an object oriented mechanism that returns correct stack frame information corresponding to a called method even when one or more inlined methods  are present in the computer program . Virtual stack frame mechanism  thus distinguishes between real stack frames  on the invocation stack and virtual stack frames that result from the inlining of method(s). Virtual stack frame mechanism  thus assures that correct stack frame information will always be returned, even in the presence of inlined methods. In this manner, virtual stack frame mechanism  provides a solution that is fully compliant while still benefitting from inlining of methods.","Processor  may be constructed from one or more microprocessors and\/or integrated circuits. Processor  executes program instructions stored in main memory . Main memory  stores programs and data that processor  may access. When computer system  starts up, processor  initially executes the program instructions that make up operating system . Operating system  is a sophisticated program that manages the resources of computer system . Some of these resources are processor , main memory , mass storage interface , display interface , network interface , and system bus .","Although computer system  is shown to contain only a single processor and a single system bus, those skilled in the art will appreciate that the present invention may be practiced using a computer system that has multiple processors and\/or multiple buses. In addition, the interfaces that are used in the preferred embodiment each include separate, fully programmed microprocessors that are used to off-load compute-intensive processing from processor . However, those skilled in the art will appreciate that the present invention applies equally to computer systems that simply use I\/O adapters to perform similar functions.","Display interface  is used to directly connect one or more displays  to computer system . These displays , which may be non-intelligent (i.e., dumb) terminals or fully programmable workstations, are used to allow system administrators and users to communicate with computer system . Note, however, that while display interface  is provided to support communication with one or more displays , computer system  does not necessarily require a display , because all needed interaction with users and other processes may occur via network interface .","Network interface  is used to connect other computer systems and\/or workstations (e.g.,  in ) to computer system  across a network . The present invention applies equally no matter how computer system  may be connected to other computer systems and\/or workstations, regardless of whether the network connection  is made using present-day analog and\/or digital techniques or via some networking mechanism of the future. In addition, many different network protocols can be used to implement a network. These protocols are specialized computer programs that allow computers to communicate across network . TCP\/IP (Transmission Control Protocol\/Internet Protocol) is an example of a suitable network protocol.","At this point, it is important to note that while the present invention has been and will continue to be described in the context of a fully functional computer system, those skilled in the art will appreciate that the present invention is capable of being distributed as a program product in a variety of forms, and that the present invention applies equally regardless of the particular type of signal bearing media used to actually carry out the distribution. Examples of suitable signal bearing media include: recordable type media such as floppy disks and CD-RW (e.g.,  of ), and transmission type media such as digital and analog communications links.","An example is now presented to illustrate the concepts of the preferred embodiments.  shows sample code that defines a class Example whose main() method invokes the ExampleHelper() class shown in . Two variables y and z are defined at lines  and . The main() method in  is shown at line , which creates an instance of ExampleHelper at line , sets variable y to a value of 1 at line , invokes method m() on the ExampleHelper instance at line , and sets variable z to a value of 1 at line . The ExampleHelper class is shown in , which defines two variables j and k at lines  and , and which defines initialization code at lines  and  that is executed when an instance of ExampleHelper is created. ExampleHelper further defines three methods, m() at line , m() at line , and m() at line . Method m() has three instructions shown at lines ,  and . Note that the instruction at line  invokes method m(). Method m() has three instructions shown at lines ,  and . Note that the instruction at line  invokes method m(). Method m() has two instructions shown at lines  and . The instructions at line  calls a method getCallerClass() on a class provided in the Sun Java application programming interface (API). The getCallerClass() method preferably calls to native code that invokes the virtual stack frame mechanism  shown in . The numerical parameter passed when the getCallerClass() method is called (i.e., the number  in the example of ), tells the getCallerClass() method how many frames back in the invocation stack to skip.",{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 5","FIGS. 3 and 4","FIGS. 3 and 4","FIG. 5"],"b":["500","510","5","4","3","2","1"]},"Now we consider the case of inlined methods.  shows an invocation stack  for a method main() that includes inlined methods. We assume for this example that the following methods have been inlined into the main() method in the Example class: the <init> method  on the ExampleHelper class, and methods m()  and m()  in the ExampleHelper class. The inlining of these methods is shown in detail in block  , which shows what the generated code looks like after inlining. Note that code block  is one simple example of a portion of a computer program  that contains inlined methods  (see ). In the inlined version of code shown in , a new instance of the ExampleHelper class is created at , but the initialization of variables j and k to zero at line  is inlined at . The instruction y=1 at line  corresponds to the same instruction at line  in . The call to m() at line  is then inlined, as shown at ,  and  of . Note that m() calls m(), which is also inlined at . Finally, the instruction at line  of  is executed at .","Executing the version of main() that contains inlined methods <init>, m() and m() as shown in  results in the invocation stack  shown in . Note that there are only three stack frames in , while there are five stack frames in . We see from this simple example that inlining has changed the number of real stack frames. As a result, there is no longer a one-to-one correspondence between methods and stack frames. If the prior art invoked getCallerClass(2) with the stack of , the class of the method in stack frame  would be returned, namely ExampleHelper. If the prior art invoked getCallerClass(2) with the stack of , however, the class of the method in stack frame  would be returned, namely Example. The inlining of methods in  and  has therefore created a problem with prior art methods for determining stack frame information  graphically illustrate the problem encountered in the prior art when methods are inlined in an object oriented program.","Java includes native methods, such as getCallerClass(), that are used to assure the currently-executing Java code is not allowed to access system resources it does not have permission to access. For this reason, achieving full compatibility with Java requires that correct stack frame information always be returned. Because inlining can result in incorrect stack frame information, some prior art systems require inlining to be turned off in some cases in order to achieve full Java compatibility. The result is that the maximum benefits of inlining are not available in a fully Java-compliant system in the prior art. The preferred embodiments overcome this overcome this obstacle by differentiating between real Java stack frames, and \u201cvirtual\u201d stack frames that relate to an inlined method, and by counting both when traversing the invocation stack.","In the preferred embodiments, the virtual stack frame mechanism  in  counts real Java stack frames, and also determines when a method has been inlined, thus allowing a determination of virtual stack frames. Thus, when getCallerClass(3) is invoked for the invocation stack  that includes inlined methods, the getCallerClass() method invokes the virtual stack frame mechanism , passing the number  as a parameter. This tells the virtual stack frame mechanism  to return the class of the stack frame after skipping three stack frames. This is done by traversing the stack unit it finds the first stack frame that was stacked by a Java program (or until there are no frames left in the stack). Once the first Java stack frame is located, data structures are initialized about the inline depth at the frame's suspend point, and the method that caused the current real stack frame to be created on the stack. Once this information is initialized, the number of specified frames are skipped, whether the frames be real stack frames or virtual stack frames.","For the specific example in , ,  and , the method main() is invoked in the Example class. This method creates a new ExampleHelper object. The m() method is invoked on the ExampleHelper object. The m() method invokes m(), which in turn invokes m(). Method m() invokes the sun.reflect.Reflection.getCallerClass(3) method. This method calls to Java native code, which invokes the virtual stack frame mechanism  to find the class of the caller, skipping past the first three frames it encounters. The invocation stack  is traversed until stack frame  is located. Stack frame  is the last stack frame that was stacked by a Java program. Information about the inline depth at the suspend point for stack frame  is retrieved. The inline depth for stack frame  is zero, because there are no inlined methods at the suspend point. Because the inline depth for stack frame  is zero, we skip over real stack frame  and search for the next real stack frame stacked by a Java program, which is stack frame . Information about the inline depth at the suspend point for stack frame  is retrieved. The inline depth for stack frame  is zero, because there are no inlined methods at the suspend point. Because the inline depth for stack frame  is zero, we skip over real stack frame  and search for the next real stack frame stacked by a Java program, which is stack frame . Information about the inline depth at the suspend point for stack frame  is retrieved. In this example, the inline depth is two, one for the inlined method m(), and one for the method (), which is called from m() as was also inlined into main(). This means that at this particular suspend point, there are two virtual stack frames as well as the real stack frame. The one real stack frame  thus corresponds to three method invocations, two of which were inlined. The virtual stack frame mechanism  \u201ctraverses\u201d stack frame  by returning first the data of the deepest method, namely m(), then returning the data of the next deepest method, namely m(), then returning the data for the real stack frame . In this example, the virtual stack frame mechanism  has already skipped two frames, so it skips one more stack frame, the virtual stack frame for method m(). The virtual stack frame mechanism  has thus skipped three frames, as requested by getCallerClass(3), so the virtual stack frame mechanism  returns the class of the current method m(), namely Example.","We see from this simple example that the virtual stack frame mechanism  accounts for inlining by treating inlined methods as having virtual stack frames. As a result, the same stack frame information is returned when getCallerClass(3) is involved whether or not inlining of methods has occurred. Thus we see from the invocation stack  in  that getCallerClass(3) skips the first three stack frames (,  and ), and returns the class of the method in stack frame , namely Example. Note that calling getCallClass(3) on the stack frame  of  using the prior art methods would result in an error, because after skipping three actual stack frames (,  and ), there are no more stack frames left. However, calling getCallerClass(3) on the stack frame  of  using the virtual stack frame mechanism  herein results in returning the class of method m(), namely Example. The preferred embodiments thus provide accurate stack frame information even when one or more methods have been inlined into one or more stack frames.","In the preferred embodiments, the virtual stack frame mechanism  is implemented in an object oriented class that we denote herein JavaVirtualFrame. Referring to , the JavaVirtualFrame class defines a number of different methods that allow the JavaVirtualFrame class to count both virtual stack frames and real stack frames when traversing an invocation stack. The JavaVirtualFrame() method is invoked by the sun.reflect.Reflection.getCallerClass() method, and the numerical parameter passed to the getCallerClass() method that represents the number of stack frames to skip is also passed to the JavaVirtualFrame() method. The JavaVirtualFrame class defines variables JavaVirtualFrame, JavaRealFrame, virtualFrameMethod, and method_info. The getPreviouslyJavaFrameMethod() method is used to set the state of the JavaVirtualFrame to the previous Java method invocation. It is invoked to move to the next stack frame in the invocation stack. This method is sensitive to methods that may have been inlined within the same JavaRealFrame. So calling this method would set the internal virtualFrameMethod to the previous method_info, but it may be within the same JavaRealFrame. The method_info returned is the internal. virtualFrameMethod.method_info.","The getMethodInfo() method retrieves method info for a JavaVirtualFrame or a JavaRealFrame. The getExecutingClass() method returns the class for the current virtualFrameMethod. The getRealFrame() method returns the current Java real stack frame, but this method must be used carefully because there may be several JavaVirtualFrames associated with the same JavaRealFrame when methods have been inlined.","The following methods shown in  are preferably static methods that are provided to encapsulate internal stack operations and provide a specific function on behalf of the client. The getClassForCurrnetMethod() class returns the class corresponding to the last (most recent) Java method found on the stack. The getClassForCallerOfCurrentMethod() class returns the class for the second to last Java method found on the stack. The getNearestClassWithLoader() methods finds the last (most recent) classloader on the stack and returns its class. The getClassContext() method returns an array of runtime class objects found on the stack as an array of Java objects. The getMethodNameList() method returns an array of method names found on the stack as an array of Java objects. The getClassForJavaFrame() method returns the class for the nth Java method found on the stack, where n represents a parameter passed when the method is called. When n=0, the current method's class is returned; when n=1, the class of the caller of the current method is returned, and so on.","The findJavaFrame() method is a private method that should not be exposed to clients. It determines if the input JavaRealFrame has a Java program. If it does, this method updates the JavaVirtualFrame's data members for the current real stack frame. If the current real stack frame does not have a Java program, it looks in the previous frames until one is found, or there are no more frames.","Many different functions can be performed using the methods shown in . An example of how client code may use JavVirtualFrame follows. The client code first invokes the JavaVirtualFrame constructor. The JavaVirtualFrame constructor invokes the findJavaFrame() method, which iterates through the stack until it finds the first stack frame created by a Java program. It then initializes the JavaVirtualFrame object's internal data members based on the stack frame it found. The client code can continue to traverse through stack frames, both virtual and real, until the requested number of stack frames have been skipped. When moving from the current stack frame to the previous stack frame, the getPreviousJavaFrameMethod() method is invoked. Once the specified number of stack frames have been skipped, the client code can extract whatever information it needs from the current stack frame, whether it be a real stack frame or a virtual stack frame.","Referring now to , a method  in accordance with the preferred embodiments begins with a call to the sun.reflect.Reflection.getCallerClass() method, passing M as a parameter (step ). In response, JavaVirtualFrame is used to find the class of the caller, skipping past the first M Java frames it encounters (step ), whether those frames are real frames or virtual frames. Method  graphically represents one of the significant advantages of the preferred embodiments. The presence of inline methods are handled by JavaVirtualFrame under the covers, thus hiding the effect of inlining on the invocation stack from the caller. JavaVirtualFrame provides a Java-compliant solution by always returning correct stack frame information, while still allowing the benefit of inlining of methods. The preferred embodiments thus provide a significant improvement over the prior art, which requires inlining to be disabled in some cases to be fully Java-compliant.","It is conceivable that one could write code to detect at run-time when methods on an invocation stack are inlined, and to manage an invocation stack at run-time to account for inlined methods. The preferred embodiments, however, provide a significant advantage by effectively shifting the overhead of managing the invocation stack from run-time to compile-time. The JavaVirtualFrame class, once compiled, will allow correct stack frame information to always be returned with very little run-time cost.","A virtual stack frame mechanism of the preferred embodiments handles requests to traverse a stack frame, and treats inlined methods as having their own virtual stack frames. If the virtual stack frame mechanism is asked to return the called of a method after skipping three stack frames, the virtual stack frame mechanism determines depth of inlining where needed, and treats each inlined method as having its own virtual stack frame. A virtual stack frame is thus treated the same as a real stack frame, allowing methods to be inlined while always returning correct stack frame information. The identity of stack frame information is thus preserved, even when methods have been inlined.","The embodiments and examples set forth herein were presented in order to best explain the present invention and its practical application and to thereby enable those skilled in the art to make and use the invention. However, those skilled in the art will recognize that the foregoing description and examples have been presented for the purposes of illustration and example only. The description as set forth is not intended to be exhaustive or to limit the invention to the precise form disclosed. Many modifications and variations are possible in light of the above teaching without departing from the spirit and scope of the forthcoming claims. For example, while the preferred embodiments are described as having practical application to computer programs written in Java, the preferred embodiments are not limited to any particular object oriented language."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":["The preferred exemplary embodiments of the present invention will hereinafter be described in conjunction with the appended drawings, where like designations denote like elements, and:",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIGS. 2A\u20132F"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 5","FIGS. 3 and 4"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 6","FIGS. 3 and 4"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 7","FIG. 6"],"b":"620"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 8","FIG. 1"],"b":"128"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
