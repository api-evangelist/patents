---
title: Administering registered virtual addresses in a hybrid computing environment including maintaining a cache of ranges of currently registered virtual addresses
abstract: Administering registered virtual addresses in a hybrid computing environment that includes a host computer, an accelerator, the accelerator architecture optimized, with respect to the host computer architecture, for speed of execution of a particular class of computing functions, the host computer and the accelerator adapted to one another for data communications by a system level message passing module, where administering registered virtual addresses includes maintaining a cache of ranges of currently registered virtual addresses, the cache including entries associating a range of currently registered virtual addresses, a handle representing physical addresses mapped to the range of currently registered virtual addresses, and a counter; determining whether to register ranges of virtual addresses in dependence upon the cache of ranges of currently registered virtual addresses; and determining whether to deregister ranges of virtual addresses in dependence upon the cache of ranges of currently registered virtual addresses.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09286232&OS=09286232&RS=09286232
owner: International Business Machines Corporation
number: 09286232
owner_city: Armonk
owner_country: US
publication_date: 20090126
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF EXEMPLARY EMBODIMENTS"],"p":["1. Field of the Invention","The field of the invention is data processing, or, more specifically, methods, apparatus, and products for administering registered virtual addresses in a hybrid computing environment.","2. Description of Related Art","The development of the EDVAC computer system of 1948 is often cited as the beginning of the computer era. Since that time, computer systems have evolved into extremely complicated devices. Today's computers are much more sophisticated than early systems such as the EDVAC. Computer systems typically include a combination of hardware and software components, application programs, operating systems, processors, buses, memory, input\/output (\u2018I\/O\u2019) devices, and so on. As advances in semiconductor processing and computer architecture push the performance of the computer higher and higher, more sophisticated computer software has evolved to take advantage of the higher performance of the hardware, resulting in computer systems today that are much more powerful than just a few years ago.","Computer systems today have advanced such that some computing environments now include core components of different architectures which operate together to complete data processing tasks. Such computing environments are described in this specification as \u2018hybrid\u2019 environments, denoting that such environments include host computers and accelerators having different architectures. Although hybrid computing environments are more computationally powerful and efficient in data processing than many non-hybrid computing environments, such hybrid computing environments still present substantial challenges to the science of automated computing machinery.","Methods, apparatus, and products for administering registered virtual addresses in a hybrid computing environment, the hybrid computing environment configured with a host computer having a host computer architecture, an accelerator having an accelerator architecture, the accelerator architecture optimized, with respect to the host computer architecture, for speed of execution of a particular class of computing functions, the host computer and the accelerator adapted to one another for data communications by a system level message passing module. In embodiments of the present invention administering registered virtual addresses in such a hybrid computing environment includes maintaining, by the system level message passing module, a cache of ranges of currently registered virtual addresses, the cache including entries associating a range of currently registered virtual addresses, a handle representing physical addresses mapped to the range of currently registered virtual addresses, and a counter; determining, by the system level message passing module, whether to register ranges of virtual addresses in dependence upon the cache of ranges of currently registered virtual addresses; and determining, by the system level message passing module, whether to deregister ranges of virtual addresses in dependence upon the cache of ranges of currently registered virtual addresses. The foregoing and other objects, features and advantages of the invention will be apparent from the following more particular descriptions of exemplary embodiments of the invention as illustrated in the accompanying drawings wherein like reference numbers generally represent like parts of exemplary embodiments of the invention.","Exemplary methods, apparatus, and products for administering registered virtual addresses in a hybrid computing environment according to embodiments of the present invention are described with reference to the accompanying drawings, beginning with .  sets forth a diagram of an example hybrid computing environment () useful for administering registered virtual addresses according to embodiments of the present invention. A \u2018hybrid computing environment,\u2019 as the term is used in this specification, is a computing environment in that it includes computer processors operatively coupled to computer memory so as to implement data processing in the form of execution of computer program instructions stored in the memory and executed on the processors. In addition, the hybrid computing environment () in the example of  includes at least one host computer having a host architecture that operates in cooperation with an accelerator having an accelerator architecture where the host architecture and accelerator architecture are different architectures. The host and accelerator architectures in this example are characterized by architectural registers, registers that are accessible by computer program instructions that execute on each architecture, registers such as, for example, an instruction register, a program counter, memory index registers, stack pointers, and the like. That is, the number, type, structure, and relations among the architectural registers of the two architectures are different, so different that computer program instructions compiled for execution on the host computer of a hybrid computing environment typically cannot be executed natively by any associated accelerator of the hybrid computing environment.","Examples of hybrid computing environments include a data processing system that in turn includes one or more host computers, each having an x86 processor, and accelerators whose architectural registers implement the PowerPC instruction set. Computer program instructions compiled for execution on the x86 processors in the host computers cannot be executed natively by the PowerPC processors in the accelerators. Readers will recognize in addition that some of the example hybrid computing environments described in this specification are based upon the Los Alamos National Laboratory (\u2018LANL\u2019) supercomputer architecture developed in the LANL Roadrunner project (named for the state bird of New Mexico), the supercomputer architecture that famously first generated a \u2018petaflop,\u2019 a million billion floating point operations per second. The LANL supercomputer architecture includes many host computers with dual-core AMD Opteron processors coupled to many accelerators with IBM Cell processors, the Opteron processors and the Cell processors having different architectures.","The example hybrid computing environment () of  includes a plurality of compute nodes (), I\/O nodes (), and a service node (). The compute nodes () are coupled through network () for data communications with one another and with the I\/O nodes () and the service node (). The data communications network () may be implemented as an Ethernet, Internet Protocol (\u2018IP\u2019), PCIe, Infiniband, Fibre Channel, or other network as will occur to readers of skill in the art.","In the example hybrid computing environment () of , the compute nodes carry out principal user-level computer program execution, accepting administrative services, such as initial program loads and the like, from the service application () executing on the service node () and gaining access to data storage () and I\/O functionality (, ) through the I\/O nodes (). In the example of , the I\/O nodes () are connected for data communications to I\/O devices (, , ) through a local area network (\u2018LAN\u2019) () implemented using high-speed Ethernet or a data communications fabric of another fabric type as will occur to those of skill in the art. I\/O devices in the example hybrid computing environment () of  include non-volatile memory for the computing environment in the form of data storage device (), an output device for the hybrid computing environment in the form of printer (), and a user () I\/O device in the form of computer terminal () that executes a service application interface () that provides to a user an interface for configuring compute nodes in the hybrid computing environment and initiating execution by the compute nodes of principal user-level computer program instructions.","In the example of , each compute node includes a host computer () having a host computer architecture and one or more accelerators () having an accelerator architecture. A host computer () is a \u2018host\u2019 in the sense that it is the host computer that carries out interface functions between a compute node and other components of the hybrid computing environment external to any particular compute node. That is, it is the host computer that executes initial boot procedures, power on self tests, basic I\/O functions, accepts user-level program loads from service nodes, and so on. An accelerator () is an \u2018accelerator\u2019 in that each accelerator has an accelerator architecture that is optimized, with respect to the host computer architecture, for speed of execution of a particular class of computing functions. Such accelerated computing functions include, for example, vector processing, floating point operations, and others as will occur to those of skill in the art.","Because each of the compute nodes in the example of  includes a host computer and an accelerator, readers of skill in the art will recognize that each compute node represents a smaller, separate hybrid computing environment within the larger hybrid computing environment () of . That is, not only may the combination of the compute nodes () form a hybrid computing environment (), but it is also the case that each individual compute node may also be viewed as a separate, smaller hybrid computing environment. The hybrid computing environment () in the example of  then, may be viewed as composed of nine separate, smaller hybrid computing environments, one for each compute node, which taken together form the hybrid computing environment () of .","Within each compute node () of , a host computer () and one or more accelerators () are adapted to one another for data communications by a system level message passing module (\u2018SLMPM\u2019) () and by two or more data communications fabrics (, ) of at least two different fabric types. An SLMPM () is a module or library of computer program instructions that exposes an application programming interface (\u2018API\u2019) to user-level applications for carrying out message-based data communications between the host computer () and the accelerator (). Examples of message-based data communications libraries that may be improved for use as an SLMPM according to embodiments of the present invention include:\n\n","A data communications fabric (, ) is a configuration of data communications hardware and software that implements a data communications coupling between a host computer and an accelerator. Examples of data communications fabric types include Peripheral Component Interconnect (\u2018PCI\u2019), PCI express (\u2018PCIe\u2019), Ethernet, Infiniband, Fibre Channel, Small Computer System Interface (\u2018SCSI\u2019), External Serial Advanced Technology Attachment (\u2018eSATA\u2019), Universal Serial Bus (\u2018USB\u2019), and so on as will occur to those of skill in the art.","The arrangement of compute nodes, data communications fabrics, networks, I\/O devices, service nodes, I\/O nodes, and so on, making up the hybrid computing environment () as illustrated in  are for explanation only, not for limitation of the present invention. Hybrid computing environments capable of administering registered virtual addresses according to embodiments of the present invention may include additional nodes, networks, devices, and architectures, not shown in , as will occur to those of skill in the art. Although the hybrid computing environment () in the example of  includes only nine compute nodes (), readers will note that hybrid computing environments according to embodiments of the present invention may include any number of compute nodes. The LANL supercomputer, taken as an example of a hybrid computing environment with multiple compute nodes, contains as of this writing more than 12,000 compute nodes. Networks and data communications fabrics in such hybrid computing environments may support many data communications protocols including for example TCP (Transmission Control Protocol), IP (Internet Protocol), and others as will occur to those of skill in the art. Various embodiments of the present invention may be implemented on a variety of hardware platforms in addition to those illustrated in .","The example hybrid computing environment () of  is configured for administering registered virtual addresses according to embodiments of the present invention. Registering a virtual address, also called pinning in this specification, is a process effected by an operating system () for a virtual address or range of virtual addresses that insures those virtual addresses are not paged from primary computer memory, such as RAM, to an alternative computer memory, such as a hard disk drive, which typically requires greater time to access than the primary computer memory. That is, in some embodiments, a registered virtual address is always mapped to a real physical address in RAM. Registering a virtual address and deregistering a virtual address, however, is an expensive, processor intensive operation that requires a large amount of time to carry out in relation to the execution of other computer program instructions or processes. Registering a range of virtual addresses also removes the physical addresses mapped to the registered virtual address range from reallocation by the operating system as virtual addresses to other applications. That is, once a memory range is pinned, the amount of available computer memory resources for virtual address management is reduced. Ranges of memory virtual addresses may be registered and deregistered for many reasons. A host application (), for example, as part of an initial run-time procedure may request an allocation of a virtual address range through a call to a library function provided by an operating system such as the call \u2018malloc (size)\u2019 where the argument \u2018size\u2019 is a size of the virtual address range for which the host application is requesting allocation from the operating system. In some operating systems () of the prior art, in addition to allocating the virtual address range to the host application (), the \u2018malloc\u2019 function provided by the operating system may also register the virtual address range and then deregister the virtual address range, insuring that the most recent application to request memory resources, the host application (), is the most likely to access real physical memory through virtual address allocated to the application. In hybrid computing environments the SLMPM () or the host application () may from time to time register and deregister memory to enable direct memory access between the host computer () and an accelerator () through the SLMPM (). Reducing the number of registering and deregistering operations carried out in a hybrid computing environment that administers registered virtual addresses in accordance with embodiments of the present invention may increase efficiency in data communications between host computers () and accelerators (), increase efficiency in resource allocation, and increase efficiency in data processing in the hybrid computing environment (), among other benefits as will occur to readers of skill in the art.","The SLMPM () in the example of  may operate generally for administering registered virtual addresses in the hybrid computing environment () by maintaining a cache () of ranges of currently registered virtual addresses, where the cache includes entries () associating a range () of currently registered virtual addresses, a handle () representing physical addresses mapped to the range of currently registered virtual addresses, and a counter (); determining whether to register ranges of virtual addresses in dependence upon the cache of ranges of currently registered virtual addresses and determining whether to deregister ranges of virtual addresses in dependence upon the cache of ranges of currently registered virtual addresses.","Although the example of  depicts only the SLMPM () of the host computer () configured for administering registered virtual addresses in the hybrid computing environment (), readers of skill in the art will recognize that any computing device in a hybrid computing environment capable of registering virtual addresses may execute an SLMPM () configured for administering registered virtual addresses in the hybrid computing environment () according to embodiments of the present invention. Consider, as just one example of such a computing device, the accelerators () of , which may execute an operating system that provides registering and deregistering functions and an SLMPM () that administers registered virtual addresses according to embodiments of the present invention.","For further explanation,  sets forth a block diagram of an exemplary hybrid computing environment () useful for administering registered virtual addresses according to embodiments of the present invention. The hybrid computing environment () of  includes four compute nodes. Similar to the compute nodes of , each of the compute nodes in the example of  may represent a small, separate hybrid computing environment which taken together make up a larger hybrid computing environment. One compute node () in the example of  is illustrated in an expanded view to aid a more detailed explanation of such a hybrid computing environment (). As shown in the expanded view of compute node (), each of the compute nodes (, ) in the example of  includes a host computer (). The host computer () includes a computer processor () operatively coupled to computer memory, Random Access Memory (\u2018RAM\u2019) (), through a high speed memory bus (). The processor () in each host computer () has a set of architectural registers () that defines the host computer architecture.","Each of the compute nodes also includes one or more accelerators (, ). Each accelerator (, ) includes a computer processor () operatively coupled to RAM () through a high speed memory bus (). Stored in RAM (,) of the host computer and the accelerators (, ) is an operating system (). Operating systems useful in host computers and accelerators of hybrid computing environments according to embodiments of the present invention include UNIX\u2122, Linux\u2122, Microsoft XP\u2122, Microsoft Vista\u2122, Microsoft NT\u2122, AIX\u2122, IBM's i5\/OS\u2122, and others as will occur to those of skill in the art. There is no requirement that the operating system in the host computers should be the same operating system used on the accelerators.","The processor () of each accelerator (, ) has a set of architectural registers () that defines the accelerator architecture. The architectural registers () of the processor () of each accelerator are different from the architectural registers () of the processor () in the host computer (). With differing architectures, it would be uncommon, although possible, for a host computer and an accelerator to support the same instruction sets. As such, computer program instructions compiled for execution on the processor () of an accelerator () generally would not be expected to execute natively on the processor () of the host computer () and vice versa. Moreover, because of the typical differences in hardware architectures between host processors and accelerators, computer program instructions compiled for execution on the processor () of a host computer () generally would not be expected to execute natively on the processor () of an accelerator () even if the accelerator supported the instruction set of the host. The accelerator architecture in example of  is optimized, with respect to the host computer architecture, for speed of execution of a particular class of computing functions. That is, for the function or functions for which the accelerator is optimized, execution of those functions will proceed faster on the accelerator than if they were executed on the processor of the host computer.","In the example of , the host computer () and the accelerators (, ) are adapted to one another for data communications by a system level message passing module (\u2018SLMPM\u2019) () and two data communications fabrics (, ) of at least two different fabric types. In this example, to support message-based data communications between the host computer () and the accelerator (), both the host computer () and the accelerator () have an SLMPM () so that message-based communications can both originate and be received on both sides of any coupling for data communications. Also in the example of , the host computer () and the accelerators (, ) are adapted to one another for data communications by a PCIe fabric () through PCIe communications adapters () and an Ethernet fabric () through Ethernet communications adapters (). The use of PCIe and Ethernet is for explanation, not for limitation of the invention. Readers of skill in the art will immediately recognize that hybrid computing environments according to embodiments of the present invention may include fabrics of other fabric types such as, for example, PCI, Infiniband, Fibre Channel, SCSI, eSATA, USB, and so on.","The SLMPM () in this example operates generally for data processing in a hybrid computing environment () by monitoring data communications performance for a plurality of data communications modes between the host computer () and the accelerators (, ), receiving a request () to transmit data according to a data communications mode from the host computer to an accelerator, determining whether to transmit the data according to the requested data communications mode, and if the data is not to be transmitted according to the requested data communications mode: selecting another data communications mode and transmitting the data according to the selected data communications mode. In the example of , the monitored performance is illustrated as monitored performance data () stored by the SLMPM () in RAM () of the host computer () during operation of the compute node ().","A data communications mode specifies a data communications fabric type, a data communications link, and a data communications protocol (). A data communications link () is data communications connection between a host computer and an accelerator. In the example of , a link () between the host computer () and the accelerator () may include the PCIe connection () or the Ethernet connection (, ) through the Ethernet network (). A link () between the host computer () and the accelerator () in the example of , may include the PCIe connection () or the Ethernet connection (, ) through the Ethernet network (). Although only one link for each fabric type is illustrated between the host computer and the accelerator in the example of , readers of skill in the art will immediately recognize that there may any number of links for each fabric type.","A data communications protocol is a set of standard rules for data representation, signaling, authentication and error detection required to send information from a host computer () to an accelerator (). In the example of , the SLMPM () may select one of several protocols () for data communications between the host computer () and the accelerator. Examples of such protocols () include shared memory transfers (\u2018SMT\u2019) () executed with a send and receive operations (), and direct memory access (\u2018DMA\u2019) () executed with PUT and GET operations ().","Shared memory transfer is a data communications protocol for passing data between a host computer and an accelerator into shared memory space () allocated for such a purpose such that only one instance of the data resides in memory at any time. Consider the following as an example shared memory transfer between the host computer () and the accelerator () of . An application () requests () a transmission of data () from the host computer () to the accelerator () in accordance with the SMT () protocol. Such a request () may include a memory address allocated for such shared memory. In this example, the shared memory segment () is illustrated in a memory location on the accelerator (), but readers will recognize that shared memory segments may be located on the accelerator (), on the host computer (), on both the host computer and the accelerator, or even off the local compute node () entirely\u2014so long as the segment is accessible as needed by the host and the accelerator. To carry out a shared memory transfer, the SLMPM () on the host computer () establishes a data communications connection with the SLMPM () executing on the accelerator () by a handshaking procedure similar to that in the TCP protocol. The SLMPM () then creates a message () that includes a header and a payload data and inserts the message into a message transmit queue for a particular link of a particular fabric. In creating the message, the SLMPM inserts, in the header of the message, an identification of the accelerator and an identification of a process executing on the accelerator. The SLMPM also inserts the memory address from the request () into the message, either in the header or as part of the payload data. The SLMPM also inserts the data () to be transmitted in the message () as part of the message payload data. The message is then transmitted by a communications adapter (, ) across a fabric (, ) to the SLMPM executing on the accelerator () where the SLMPM stores the payload data, the data () that was transmitted, in shared memory space () in RAM () in accordance with the memory address in the message.","Direct memory access (\u2018DMA\u2019) is a data communications protocol for passing data between a host computer and an accelerator with reduced operational burden on the computer processor (). A DMA transfer essentially effects a copy of a block of memory from one location to another, typically from a host computer to an accelerator or vice versa. Either or both a host computer and accelerator may include DMA engine, an aggregation of computer hardware and software for direct memory access. Direct memory access includes reading and writing to memory of accelerators and host computers with reduced operational burden on their processors. A DMA engine of an accelerator, for example, may write to or read from memory allocated for DMA purposes, while the processor of the accelerator executes computer program instructions, or otherwise continues to operate. That is, a computer processor may issue an instruction to execute a DMA transfer, but the DMA engine, not the processor, carries out the transfer.","In the example of , only the accelerator () includes a DMA engine () while the host computer does not. In this embodiment the processor () on the host computer initiates a DMA transfer of data from the host to the accelerator by sending a message according to the SMT protocol to the accelerator, instructing the accelerator to perform a remote \u2018GET\u2019 operation. The configuration illustrated in the example of  in which the accelerator () is the only device containing a DMA engine is for explanation only, not for limitation. Readers of skill in the art will immediately recognize that in many embodiments, both a host computer and an accelerator may include a DMA engine, while in yet other embodiments only a host computer includes a DMA engine.","To implement a DMA protocol in the hybrid computing environment of  some memory region is allocated for access by the DMA engine. Allocating such memory may be carried out independently from other accelerators or host computers, or may be initiated by and completed in cooperation with another accelerator or host computer. Shared memory regions, allocated according to the SMA protocol, for example, may be memory regions made available to a DMA engine. That is, the initial setup and implementation of DMA data communications in the hybrid computing environment () of  may be carried out, at least in part, through shared memory transfers or another out-of-band data communications protocol, out-of-band with respect to a DMA engine. Allocation of memory to implement DMA transfers is relatively high in latency, but once allocated, the DMA protocol provides for high bandwidth data communications that requires less processor utilization than many other data communications protocols.","A direct \u2018PUT\u2019 operation is a mode of transmitting data from a DMA engine on an origin device to a DMA engine on a target device. A direct \u2018PUT\u2019 operation allows data to be transmitted and stored on the target device with little involvement from the target device's processor. To effect minimal involvement from the target device's processor in the direct \u2018PUT\u2019 operation, the origin DMA engine transfers the data to be stored on the target device along with a specific identification of a storage location on the target device. The origin DMA knows the specific storage location on the target device because the specific storage location for storing the data on the target device has been previously provided by the target DMA engine to the origin DMA engine.","A remote \u2018GET\u2019 operation, sometimes denominated an \u2018rGET,\u2019 is another mode of transmitting data from a DMA engine on an origin device to a DMA engine on a target device. A remote \u2018GET\u2019 operation allows data to be transmitted and stored on the target device with little involvement from the origin device's processor. To effect minimal involvement from the origin device's processor in the remote \u2018GET\u2019 operation, the origin DMA engine stores the data in an storage location accessible by the target DMA engine, notifies the target DMA engine, directly or out-of-band through a shared memory transmission, of the storage location and the size of the data ready to be transmitted, and the target DMA engine retrieves the data from storage location.","Monitoring data communications performance for a plurality of data communications modes may include monitoring a number of requests () in a message transmit request queue (-) for a data communications link (). In the example of , each message transmit request queue (-) is associated with one particular data communications link (). Each queue (-) includes entries for messages () that include data () to be transmitted by the communications adapters (, ) along a data communications link () associated with queue.","Monitoring data communications performance for a plurality of data communications modes may also include monitoring utilization of a shared memory space (). In the example of , shared memory space () is allocated in RAM () of the accelerator. Utilization is the proportion of the allocated shared memory space to which data has been stored for sending to a target device and has not yet been read or received by the target device, monitored by tracking the writes and reads to and from the allocated shared memory. In the hybrid computing environment () of , shared memory space, any memory in fact, is limited. As such, a shared memory space () may be filled during execution of an application program () such that transmission of data from the host computer () to an accelerator may be slowed, or even stopped, due to space limitations in the shared memory space.","In some embodiments of the present invention, the hybrid computing environment () of  may be configured to operate as a parallel computing environment in which two or more instances the application program () executes on two or more host computers () in the parallel computing environment. In such embodiments, monitoring data communications performance across data communications modes may also include aggregating data communications performance information () across a plurality of instances of the application program () executing on two or more host computers in a parallel computing environment. The aggregated performance information () may be used to calculate average communications latencies for data communications modes, average number of requests in data communications links of a particular fabric type, average shared memory utilization among the plurality of host computers and accelerators in the parallel computing environment, and so on as will occur to those of skill in the art. Any combination of such measures may be used by the SLMPM for both determining whether to transmit the data according to requested data communications mode and selecting another data communications mode for transmitting the data if the data is not to be transmitted according to the requested data communications mode.","The SLMPM () of  receives, from an application program () on the host computer (), a request () to transmit data () according to a data communications mode from the host computer () to the accelerator (). Such data () may include computer program instructions compiled for execution by the accelerator (), work piece data for an application program executing on the accelerator (), or some combination of computer program instructions and work piece data. Receiving a request () to transmit data () according to a data communications mode may include receiving a request to transmit data by a specified fabric type, receiving a request to transmit data through a specified data communications link from the host computer to the accelerator, or receiving a request to transmit data from the host computer to the accelerator according to a protocol.","A request () to transmit data () according to a data communications mode may be implemented as a user-level application function call through an API to the SLMPM (), a call that expressly specifies a data communications mode according to protocol, fabric type, and link. A request implemented as a function call may specify a protocol according to the operation of the function call itself. A dacs_put( ) function call, for example, may represent a call through an API exposed by an SLMPM implemented as a DACS library to transmit data in the default mode of a DMA \u2018PUT\u2019 operation. Such a call, from the perspective of the calling application and the programmer who wrote the calling application, represents a request to the SLMPM library to transmit data according to the default mode, known to the programmer to be default mode associated with the express API call. The called function, in this example dacs_put( ), may be coded according to embodiments of the present invention, to make its own determination whether to transmit the data according to the requested data communications mode, that is, according to the default mode of the called function. In a further example, a dacs_send( ) instruction may represent a call through an API exposed by an SLMPM implemented as a DACS library to transmit data in the default mode of an SMT \u2018send\u2019 operation, where the called function dacs_send( ) is again coded according to embodiments of the present invention to make its own determination whether to transmit the data according to the requested mode.","An identification of a particular accelerator in a function call may effectively specify a fabric type. Such a function call may include as a call parameters an identification of a particular accelerator. An identification of a particular accelerator by use of a PCIe ID, for example, effectively specifies a PCI fabric type. In another, similar, example, an identification of a particular accelerator by use of a media access control (\u2018MAC\u2019) address of an Ethernet adapter effectively specifies the Ethernet fabric type. Instead of implementing the accelerator ID of the function call from an application executing on the host in such a way as to specify a fabric type, the function call may only include a globally unique identification of the particular accelerator as a parameter of the call, thereby specifying only a link from the host computer to the accelerator, not a fabric type. In this case, the function called may implement a default fabric type for use with a particular protocol. If the function called in the SLMPM is configured with PCIe as a default fabric type for use with the DMA protocol, for example, and the SLMPM receives a request to transmit data to the accelerator () according to the DMA protocol, a DMA PUT or DMA remote GET operation, the function called explicitly specifies the default fabric type for DMA, the PCIe fabric type.","In hybrid computing environments in which only one link of each fabric type adapts a single host computer to a single accelerator, the identification of a particular accelerator in a parameter of a function call, may also effectively specify a link. In hybrid computing environments where more than one link of each fabric type adapts a host computer and an accelerator, such as two PCIe links connecting the host computer () to the accelerator (), the SLMPM function called may implement a default link for the accelerator identified in the parameter of the function call for the fabric type specified by the identification of the accelerator.","The SLMPM () in the example of  also determines, in dependence upon the monitored performance (), whether to transmit the data () according to the requested data communications mode. Determining whether to transmit the data () according to the requested data communications mode may include determining whether to transmit data by a requested fabric type, whether to transmit data through a requested data communications link, or whether to transmit data according to a requested protocol.","In hybrid computing environments, where monitoring data communications performance across data communications modes includes monitoring a number of requests in a message transmit request queue (-) for a data communications link, determining whether to transmit the data () according to the requested data communications mode may be carried out by determining whether the number of requests in the message transmit request queue exceeds a predetermined threshold. In hybrid computing environments, where monitoring data communications performance for a plurality of data communications modes includes monitoring utilization of a shared memory space, determining whether to transmit the data () according to the requested data communications mode may be carried out by determining whether the utilization of the shared memory space exceeds a predetermined threshold.","If the data is not to be transmitted according to the requested data communications mode, the SLMPM () selects, in dependence upon the monitored performance, another data communications mode for transmitting the data and transmits the data () according to the selected data communications mode. Selecting another data communications mode for transmitting the data may include selecting, in dependence upon the monitored performance, another data communications fabric type by which to transmit the data, selecting a data communications link through which to transmit the data, and selecting another data communications protocol. Consider as an example, that the requested data communications mode is a DMA transmission using a PUT operation through link () of the PCIe fabric () to the accelerator (). If the monitored data performance () indicates that the number of requests in transmit message request queue () associated with the link () exceeds a predetermined threshold, the SLMPM may select another fabric type, the Ethernet fabric (), and link (, ) through which to transmit the data (). Also consider that the monitored performance () indicates that current utilization of the shared memory space () is less than a predetermined threshold while the number of outstanding DMA transmissions in the queue () exceeds a predetermined threshold. In such a case, the SLMPM () may also select another protocol, such as a shared memory transfer, by which to transmit the data ().","Selecting, by the SLMPM, another data communications mode for transmitting the data () may also include selecting a data communications protocol () in dependence upon data communications message size (). Selecting a data communications protocol () in dependence upon data communications message size () may be carried out by determining whether a size of a message exceeds a predetermined threshold. For larger messages (), the DMA protocol may be a preferred protocol as processor utilization in making a DMA transfer of a larger message () is typically less than the processor utilization in making a shared memory transfer of a message of the same size.","As mentioned above, the SLMPM may also transmit the data according to the selected data communications mode. Transmit the data according to the selected data communications mode may include transmitting the data by the selected data communications fabric type, transmitting the data through the selected data communications link, or transmitting the data according to the selected protocol. The SLMPM () may effect a transmission of the data according to the selected data communications mode by instructing, through a device driver, the communications adapter for the data communications fabric type of the selected data communications mode to transmit the message () according to a protocol of the selected data communications mode, where the message includes in a message header, an identification of the accelerator, and in the message payload, the data () to be transmitted.","The example hybrid computing environment () of  is configured for administering registered virtual addresses in accordance with embodiments of the present invention. The example SLMPM () in the hybrid computing environment () of  operates generally for administering registered virtual addresses in accordance with embodiments of the present invention by maintaining a cache () of ranges of currently registered virtual addresses and determining whether to register and deregister ranges of virtual addresses in dependence upon the cache () of ranges of currently registered virtual addresses. A cache of ranges of currently registered virtual addresses may be implemented as one or more data structures, such as a set of tables. In fact, a cache of ranges of currently registered virtual address may be implemented in a manner similar to a page table used by an operating system to administer virtual addresses. The example cache () of currently registered virtual addresses in the hybrid computing environment of  includes entries that associate a range () of currently registered virtual addresses, a handle () representing physical addresses that are mapped to the range of currently registered virtual addresses, and a counter.","The handle () in the example cache () of ranges of currently registered virtual addresses as the term is used in this specification is a representation of one or more physical addresses mapped to a range of registered physical addresses. Such a handle may be used by an SLMPM () executing on the host computer () or the accelerator () for DMA between the two, and other operations that use physical memory addresses as will occur to readers of skill in the art.","The counter () for each range of currently registered virtual memory addresses indicates usage of the range. Such a counter () may be used in a manner similar to usage bits in a typical RAM cache map that are used in \u2018least recently used\u2019 algorithms to identify cache lines for eviction from the RAM cache. In the example cache () of ranges of , the count () for a range of currently registered virtual addresses is incremented by the SLMPM () when an application attempts to register one or more particular virtual addresses falling within the range of currently registered virtual addresses and is decremented when an application attempts to deregister one or more particular virtual addresses falling within the range of currently registered virtual addresses.","The SLMPM () in the example hybrid computing environment () of  may be configured for administering registered virtual addresses in the hybrid computing environment () by intercepting application level calls () from an application () to the operating system () to register or deregister memory addresses. The SLMPM () may intercept application level calls to an operating system in many ways such as receiving, by the system level message passing module () from the application (), an alternative call executed by the application () in dependence upon a weak alias in the application code. Such a \u2018weak alias\u2019 is an indication in the application code associated with the application level call to a compiler of the application code that the alternative call is to be executed instead of the application level call. That is, although the application () may be originally coded to call an operating system function to register a virtual address, when compiled, the application actually calls a function of the SLMPM. The originally coded functional call is effectively redirected from the operating system () to the SLMPM (). An alternative way the SLMPM () may intercept application level calls to the operating system may be to monitor an instruction stack for a memory address of a the registering or deregistering function provided by the operating system and interrupt the application prior to execution of the instruction. As another alternative, the application may actually be coded to register and deregister virtual memory addresses through the SLMPM () instead of directly with the operating system (). In this alternative, intercepting application level calls to the operating system is carried out in contrast to application of the prior art that registered and deregistered virtual memory addresses directly with an operating system (), not through an SLMPM ().","When the SLMPM () intercepts an application level call to register a particular range of virtual addresses that falls within a range of currently registered virtual addresses maintained in the cache (), the SLMPM () maintains the cache () by incrementing the counter for the range of currently registered virtual addresses within which the particular range of virtual addresses falls. Also when the SLMPM () intercepts an application level call () to register a particular range of virtual addresses that falls within a range of currently registered virtual addresses maintained in the cache, the SLMPM () may determine whether to register ranges of virtual addresses in dependence upon the cache () of ranges of currently registered virtual addresses by determining not to register the particular range of virtual addresses and returning, to the application, the handle () associated with the range of currently registered virtual addresses within which the particular range of virtual addresses falls. That is, when the particular range falls within some range in the cache, the range is already pinned, and need not be pinned again. Instead, the SLMPM () returns to the application the handle associated with the previously pinned range, such that, from the perspective of the application (), the registering function was fully carried out by the operating system.","When the SLMPM () intercepts an application level call () to register a particular range of virtual addresses that does not fall within a range of currently registered virtual addresses maintained in the cache, determining whether to register ranges of virtual addresses in dependence upon the cache includes registering the particular range of virtual addresses. That is, when the particular range is not in the cache, the particular range is not currently registered and the SLMPM () executes a system call () to the operating system () to register the particular range and receives a handle as a return for the system call (). Also when the SLMPM () intercepts an application level call () to register a particular range of virtual addresses that does not fall within a range in the cache, the SLMPM () maintains the cache () of ranges of currently registered virtual addresses by adding the particular range of virtual addresses to the cache () of currently registered virtual addresses. Adding the particular range of virtual addresses to the cache () of currently registered virtual addresses may include associating in the cache () with the particular range () of addresses, a counter equal to one, and the handle () returned to the SLMPM () by the operating system ().","When the SLMPM () intercepts an application level call to deregister a particular range of virtual addresses that falls within a range of currently registered virtual addresses maintained in the cache, the SLMPM () may determine whether to deregister ranges of virtual addresses by determining not to deregister the particular range of virtual addresses. That is, if the particular range falls within a range that is in fact in the cache, currently registered, the SLMPM () does not deregister the particular range. Such a determination not to deregister the particular range of virtual addresses maintains the memory addresses as a pinned resource, such that upon a subsequent call from an application to register again that particular range of virtual addresses, the SLMPM need not execute a registering operation for the particular range, but instead, may return the handle associated with the range when previously registered. What would typically require a first registering operation, followed by a later deregistering operation, followed by a second registering operation of a particular range of virtual addresses, therefore, may be reduced to only a single, first registering operation when registered virtual addresses are administered by an SLMPM () in accordance with embodiments of the present invention. Also when the SLMPM () intercepts an application level call () to deregister a particular range of virtual addresses that falls within a range in the cache (), the SLMPM () maintains the cache () by decrementing the counter () for the range of currently registered virtual addresses within which the particular range of virtual addresses falls.","In some hybrid computing environments () configured to administer registered virtual addresses according to embodiments of the present invention, the cache () of ranges of currently registered virtual addresses is of limited size, that is, the cache may include only a predefined number of entries. The SLMPM () may use such a cache of limited size to control the maximum number of memory ranges which may be registered at any given time, thereby limiting the amount of physical memory resources allocated for pinning. That is, in a cache () of ranges of currently registered virtual addresses limited in size to 64 entries, only 64 memory ranges may be pinned at any given time. When the cache is full, at least one entry must be evicted in order to register a memory range not currently in the cache.","In such a hybrid computing environment () configured with a cache () of limited size, the system level message passing module () may administer registered virtual addresses according to embodiments of the present invention by intercepting an application level call to register a particular range of virtual addresses that does not fall within a range of currently registered virtual addresses maintained in the cache and determining that the cache is full. The SLMPM () may then register the particular range of virtual addresses and maintain the cache by evicting, from the cache, a least recently used and least recently added range of currently registered virtual addresses in dependence upon the counter for the least recently used and least recently added range of currently registered virtual addresses. In addition to evicting the least recently used and least recently added range from the cache, the SLMPM () may also deregister the least recently used and least recently added range. The SLMPM may deregister a range of addresses through a system call () to a deregistering function provided by the operating system (). After evicting the least recently used and least recently added range from the cache (), the SLMPM () may then add the particular range of virtual addresses to the cache of currently registered virtual addresses. The SLMPM () may identify the least recently used and least recently added range of currently registered virtual addresses in the cache by identifying least recently added range having the lowest count in the cache (). The SLMPM () may add ranges to the cache in order, such that, ranges higher in the cache were added more recently than those lower in the cache. As such, the SLMPM () may identify the least recently added range by identifying that range having the lowest count that is the lowest in the cache (). Readers of skill in the art will recognize that selecting the least recently used and least recently added range is but one way among many that SLMPM () may select a range for eviction from the cache () of ranges of currently registered virtual addresses. The SLMPM () may, for example, be configured to select a range for eviction which is the least recently used not necessarily least recently added range.","In some hybrid computing environments (), configured with or without a cache of limited size, the SLMPM () may maintain a cache () of ranges () of currently registered virtual addresses by receiving, from an operating system (), a notification () that the operating system () is unable to register a particular range of virtual addresses. The SLMPM () may then evict, from the cache, a least recently used and least recently added range of currently registered virtual addresses including deregistering the least recently used and least recently added range. The SLMPM () may then register the particular range of virtual addresses and add the particular range of virtual addresses to the cache of currently registered virtual addresses. The operating system () may notify the SLMPM () that the operating system () is unable is unable to register a particular range of virtual addresses when, for example, the quantity of available real memory, that is, memory not currently registered, is less than a predetermined threshold. That is, in some cases memory resources may be unavailable for registering. The SLMPM () may receive, from an operating system (), such a notification () that the operating system () is unable to register a particular range of virtual addresses by receiving the notification as a return from a system call () to the operating system to register the particular virtual address range.","For further explanation,  sets forth a block diagram of a further exemplary hybrid computing environment () useful for administering registered virtual addresses according to embodiments of the present invention. The hybrid computing environment of  is similar the hybrid computing environment of , including as it does, four compute nodes (, ), each of which includes a host computer () having a host computer architecture and an accelerator () having an accelerator architecture where the accelerator architecture is optimized, with respect to the host computer architecture, for speed of execution of a particular class of computing functions. The host computer () and the accelerator () are adapted to one another for data communications by a system level message passing module () and two or more data communications fabrics (, ) of at least two different fabric types. In the example of , the host computer () is adapted to accelerator () by an Ethernet fabric () and a PCIe fabric ().","The host computer () as illustrated in the expanded view of the compute node () includes an x86 processor. An x86 processor is a processor whose architecture is based upon the architectural register set of the Intel x86 series of microprocessors, the 386, the 486, the 586 or Pentium\u2122, and so on. Examples of x86 processors include the Advanced Micro Devices (\u2018AMD\u2019) Opteron\u2122, the AMD Phenom\u2122, the AMD Athlon XP\u2122, the AMD Athlon 64\u2122, Intel Nehalam\u2122, Intel Pentium 4, Intel Core 2 Duo, Intel Atom, and so on as will occur to those of skill in the art. The x86 processor () in the example of Figure illustrates a set of a typical architectural registers () found in many x86 processors including, for example, an accumulator register (\u2018AX\u2019), a base register (\u2018BX\u2019), a counter register (\u2018CX\u2019), a data register (\u2018DX\u2019), a source index register for string operations (\u2018SI\u2019), a destination index for string operations (\u2018DI\u2019), a stack pointer (\u2018SP\u2019), a stack base pointer for holding the address of the current stack frame (\u2018BP\u2019), and an instruction pointer that holds the current instruction address (\u2018IP\u2019).","The accelerator () in the example of  is illustrated as a Cell Broadband Engine (\u2018CBE\u2019) having a Cell Broadband Engine Architecture (\u2018CBEA\u2019). A CBEA is a microprocessor architecture jointly developed by Sony Computer Entertainment, Toshiba, and IBM, an alliance known as \u201cSTI.\u201d Microprocessors implemented according to the CBEA are sometimes referred to as \u2018Cell\u2019 processors or simply as CBEs. The CBEA combines a general-purpose POWER architecture core, a Power Processing Element (\u2018PPE\u2019) (), of modest performance with streamlined co-processing elements, called Synergistic Processing Elements (\u2018SPEs\u2019) () which greatly accelerate multimedia and vector processing applications, as well as many other forms of dedicated computation. The CBE architecture emphasizes efficiency\/watt, prioritizes bandwidth over latency, and favors peak computational throughput over simplicity of program code.","The accelerator () of , implemented as a CBE, includes a main processor () that in this example is a Power Processing Element (\u2018PPE\u2019), eight fully-functional co-processors called SPEs (), and a high-bandwidth circular data bus connecting the PPE and the SPEs, called the Element Interconnect Bus (\u2018EIB\u2019) (). The PPE () is a POWER architecture processor with a two-way multithreaded core acting as a controller for the eight SPEs (). The term \u201cPOWER architecture\u201d here refers to IBM's different generations of processor architectures, a broad term including all products based on POWER, PowerPC and Cell architectures. The architectural registers () of the PPE () of the CBE accelerator () therefore are different from those of the x86 processor () of the host computer (). The PPE () of  includes an example set of architectural registers () of the POWER architecture, including 32 general purpose registers (\u2018GPRs\u2019), 32 floating point registers (\u2018FPRs\u2019), a fixed-point exception register (\u2018XER\u2019), a count register (\u2018CTR\u2019), a Condition register (\u2018CR\u2019), an instruction address register (\u2018IAR\u2019), a link register (\u2018LR\u2019), and a processor version register (\u2018PVR\u2019).","The SPEs () handle most of the computational workload of the CBE (). While the SPEs are optimized for vectorized floating point code execution, the SPEs also may execute operating systems, such as, for example, a lightweight, modified version of Linux with the operating system stored in local memory () on the SPE. Each SPE () in the example of  includes a Synergistic Processing Unit (\u2018SPU\u2019) (), and a Memory Flow Controller (\u2018MFC\u2019) (). An SPU () is a Reduced Instruction Set Computing (\u2018RISC\u2019) processor with 128-bit single instruction, multiple data (\u2018SIMD\u2019) organization for single and double precision instructions. In some implementations, an SPU may contain a 256 KB embedded Static RAM () for instructions and data, called local storage which is visible to the PPE () and can be addressed directly by software. Each SPU () can support up to 4 Gigabyte (\u2018GB\u2019) of local store memory. The local store does not operate like a conventional CPU cache because the local store is neither transparent to software nor does it contain hardware structures that predict which data to load. The SPUs () also implement architectural registers () different from those of the PPE which include a 128-bit, 128-entry register file (). An SPU () can operate on 16 8-bit integers, 8 16-bit integers, 4 32-bit integers, or 4 single precision floating-point numbers in a single clock cycle, as well as execute a memory operation.","The MFC () integrates the SPUs () in the CBE (). The MFC () provides an SPU with data transfer and synchronization capabilities, and implements the SPU interface to the EIB () which serves as the transportation hub for the CBE (). The MFC () also implements the communication interface between the SPE () and PPE (), and serves as a data transfer engine that performs bulk data transfers between the local storage () of an SPU () and CBE system memory, RAM (), through DMA. By offloading data transfer from the SPUs () onto dedicated data transfer engines, data processing and data transfer proceeds in parallel, supporting advanced programming methods such as software pipelining and double buffering. Providing the ability to perform high performance data transfer asynchronously and in parallel with data processing on the PPE () and SPEs (), the MFC () eliminates the need to explicitly interleave data processing and transfer at the application level.","The SLMPM () in the example of  processes data in the hybrid computing environment () by monitoring data communications performance for a plurality of data communications modes between the host computer () and the accelerator (); receiving, from an application program () on the host computer (), a request to transmit data according to a data communications mode from the host computer () to the accelerator (); determining, in dependence upon the monitored performance, whether to transmit the data according to the requested data communications mode; and if the data is not to be transmitted according to the requested data communications mode: selecting, in dependence upon the monitored performance, another data communications mode for transmitting the data and transmitting the data according to the selected data communications mode.","The example hybrid computing environment () of  may be configured for administering registered virtual addresses according to embodiments of the present invention. The SLMPM () of the hybrid computing environment () of  may operate for administering registered virtual addresses according to embodiments of the present invention by maintaining a cache of ranges of currently registered virtual addresses and determining whether to register or deregister ranges of virtual addresses in dependence upon the cache of ranges of currently registered virtual addresses.","For further explanation,  sets forth a block diagram of a further exemplary hybrid computing environment () useful for administering registered virtual addresses according to embodiments of the present invention. The hybrid computing environment of  is similar the hybrid computing environment of , including as it does, four compute nodes (, ), each of which includes a host computer () having a host computer architecture and one or more accelerators () each having an accelerator architecture where the accelerator architecture is optimized, with respect to the host computer architecture, for speed of execution of a particular class of computing functions. The host computer () and the accelerator () in the example of  are adapted to one another for data communications by a system level message passing module () and two or more data communications fabrics (, ) of at least two different fabric types. In the example of , the host computer () is adapted to accelerator () by an Ethernet fabric () and a PCIe fabric ().",{"@attributes":{"id":"p-0074","num":"0078"},"figref":["FIG. 4","FIG. 4","FIG. 4"],"b":["110","103","155","152","110","154","152","142","166","146","145","146"]},"Each x86 processor core () in the example of  is adapted through an Ethernet () and PCIe () fabric to a separate accelerator () implemented as a CBE as described above with respect to . Each core () of each AMD Opteron processor () in the host computer () in this example is connected to at least one CBE. Although in this example the ratio of cores of the Opteron processors to CBEs () is one-to-one, readers of skill in the art will recognize that other example embodiments may implement different ratios of processor cores to accelerators such as, for example, one-to-two, one-to-three, and so on.","Each instance of the SLMPM () executing on each x86 processor core () in the example of  processes data in the hybrid computing environment () by monitoring data communications performance across data communications modes between the host computer () and the accelerator () connected to the processor core (); receiving, from the instance of the application program () executing on the processor core () of the host computer (), a request to transmit data according to a data communications mode from the host computer () to the accelerator () connected to the processor core (); determining, in dependence upon the monitored performance, whether to transmit the data according to the requested data communications mode; and if the data is not to be transmitted according to the requested data communications mode: selecting, in dependence upon the monitored performance, another data communications mode for transmitting the data and transmitting the data according to the selected data communications mode.","The example hybrid computing environment () of  may be configured for administering registered virtual addresses according to embodiments of the present invention. Any SLMPM () in the example of  may operate generally for such administering registered virtual addresses by maintaining a cache of ranges of currently registered virtual addresses and determining whether to register or deregister ranges of virtual addresses in dependence upon the cache of ranges of currently registered virtual addresses.","For further explanation,  sets forth a flow chart illustrating an exemplary method for administering registered virtual addresses in a hybrid computing environment according to embodiments of the present invention. The method of  is carried out in a hybrid computing environment similar to the hybrid computing environments described above in this specification. Such a hybrid computing environment ( in ) includes a host computer ( on ) having a host computer architecture and an accelerator ( on ) having an accelerator architecture, the accelerator architecture optimized, with respect to the host computer architecture, for speed of execution of a particular class of computing functions, the host computer ( on ) and the accelerator ( on ) adapted to one another for data communications by an SLMPM () and, optionally, by two or more data communications fabrics (,  on ) of at least two different fabric types. The method of  includes maintaining (), by the system level message passing module (), a cache () of ranges of currently registered virtual addresses. In the method of , the cache () includes entries associating a range () of currently registered virtual addresses, a handle () representing physical addresses mapped to the range of currently registered virtual addresses, and a counter (). The method of  also includes determining (), by the system level message passing module (), whether to register ranges () of virtual addresses in dependence upon the cache () of ranges of currently registered virtual addresses. Such ranges () of virtual addresses to register may be included as an argument of a system call () to register the ranges from an application () to an operating system which is intercepted by the SLMPM (). The method of  also includes determining, by the system level message passing module (), whether to deregister ranges () of virtual addresses in dependence upon the cache of ranges of currently registered virtual addresses. Such ranges () of virtual addresses to deregister may be included as an argument of a system call () to deregister the ranges from an application () to an operating system which is intercepted by the SLMPM (). Determining () whether to register and determining () whether to deregister may be carried out in various ways, described in detail above with respect to  and below with respect to .","For further explanation,  sets forth a flow chart illustrating a further exemplary method of administering registered virtual addresses in a hybrid computing environment according to embodiments of the present invention. The method of , like the method of  is carried out in a hybrid computing environment similar to the hybrid computing environments described above in this specification. Such a hybrid computing environment ( in ) includes a host computer ( on ) having a host computer architecture and an accelerator ( on ) having an accelerator architecture, the accelerator architecture optimized, with respect to the host computer architecture, for speed of execution of a particular class of computing functions, the host computer ( on ) and the accelerator ( on ) adapted to one another for data communications by an SLMPM () and, optionally, by two or more data communications fabrics (,  on ) of at least two different fabric types. The method of  is similar to the method of  including, as it does, maintaining (), by the system level message passing module (), a cache () of ranges of currently registered virtual addresses; determining (), by the system level message passing module (), whether to register ranges () of virtual addresses in dependence upon the cache () of ranges of currently registered virtual addresses; and determining, by the system level message passing module (), whether to deregister ranges () of virtual addresses in dependence upon the cache of ranges of currently registered virtual addresses. The method of  differs from the method of  in that the method of  includes intercepting (), by the system level message passing module (), an application level call () to register a particular range () of virtual addresses that falls within a range of currently registered virtual addresses maintained in the cache (). In the method of  maintaining () a cache of ranges of currently registered virtual addresses includes incrementing () the counter () for the range () of currently registered virtual addresses within which the particular range () of virtual addresses falls. In the method of  determining (), by the system level message passing module (), whether to register ranges of virtual addresses in dependence upon the cache of ranges of currently registered virtual addresses includes determining () not to register the particular range () of virtual addresses and returning (), to the application (), the handle () associated with the range of currently registered virtual addresses within which the particular range () of virtual addresses falls.","For further explanation,  sets forth a flow chart illustrating a further exemplary method of administering registered virtual addresses in a hybrid computing environment according to embodiments of the present invention. The method of , like the method of  is carried out in a hybrid computing environment similar to the hybrid computing environments described above in this specification. Such a hybrid computing environment ( in ) includes a host computer ( on ) having a host computer architecture and an accelerator ( on ) having an accelerator architecture, the accelerator architecture optimized, with respect to the host computer architecture, for speed of execution of a particular class of computing functions, the host computer ( on ) and the accelerator ( on ) adapted to one another for data communications by an SLMPM () and, optionally, by two or more data communications fabrics (,  on ) of at least two different fabric types. The method of  is similar to the method of  including, as it does, maintaining (), by the system level message passing module (), a cache () of ranges of currently registered virtual addresses; determining (), by the system level message passing module (), whether to register ranges () of virtual addresses in dependence upon the cache () of ranges of currently registered virtual addresses; and determining, by the system level message passing module (), whether to deregister ranges () of virtual addresses in dependence upon the cache of ranges of currently registered virtual addresses. The method of  differs from the method of  in that the method of  includes intercepting (), by the system level message passing module (), an application () level call () to register a particular range () of virtual addresses that does not fall within a range of currently registered virtual addresses maintained in the cache (). In the method of , determining (), by the system level message passing module (), whether to register ranges of virtual addresses in dependence upon the cache () of ranges of currently registered virtual addresses includes registering () the particular range () of virtual addresses. In the method of  maintaining () a cache () of ranges of currently registered virtual addresses includes adding () the particular range () of virtual addresses to the cache of currently registered virtual addresses.","For further explanation,  sets forth a flow chart illustrating a further exemplary method of administering registered virtual addresses in a hybrid computing environment according to embodiments of the present invention. The method of , like the method of  is carried out in a hybrid computing environment similar to the hybrid computing environments described above in this specification. Such a hybrid computing environment ( in ) includes a host computer ( on ) having a host computer architecture and an accelerator ( on ) having an accelerator architecture, the accelerator architecture optimized, with respect to the host computer architecture, for speed of execution of a particular class of computing functions, the host computer ( on ) and the accelerator ( on ) adapted to one another for data communications by an SLMPM () and, optionally, by two or more data communications fabrics (,  on ) of at least two different fabric types. The method of  is similar to the method of  including, as it does, maintaining (), by the system level message passing module (), a cache () of ranges of currently registered virtual addresses; determining (), by the system level message passing module (), whether to register ranges () of virtual addresses in dependence upon the cache () of ranges of currently registered virtual addresses; and determining, by the system level message passing module (), whether to deregister ranges () of virtual addresses in dependence upon the cache of ranges of currently registered virtual addresses. The method of  differs from the method of  in that the method of  includes intercepting (), by the system level message passing module (), an application level call () to deregister a particular range () of virtual addresses that falls within a range of currently registered virtual addresses maintained in the cache (). In the method of , determining (), by the system level message passing module (), whether to deregister ranges of virtual addresses in dependence upon the cache () of ranges of currently registered virtual addresses includes determining () not to deregister the particular range () of virtual addresses. In the method of , maintaining () a cache () of ranges of currently registered virtual addresses includes decrementing () the counter () for the range () of currently registered virtual addresses within which the particular range () of virtual addresses falls.","For further explanation,  sets forth a flow chart illustrating a further exemplary method of administering registered virtual addresses in a hybrid computing environment according to embodiments of the present invention. The method of , like the method of  is carried out in a hybrid computing environment similar to the hybrid computing environments described above in this specification. Such a hybrid computing environment ( in ) includes a host computer ( on ) having a host computer architecture and an accelerator ( on ) having an accelerator architecture, the accelerator architecture optimized, with respect to the host computer architecture, for speed of execution of a particular class of computing functions, the host computer ( on ) and the accelerator ( on ) adapted to one another for data communications by an SLMPM () and, optionally, by two or more data communications fabrics (,  on ) of at least two different fabric types. The method of  is similar to the method of  including, as it does, maintaining (), by the system level message passing module (), a cache () of ranges of currently registered virtual addresses; determining (), by the system level message passing module (), whether to register ranges () of virtual addresses in dependence upon the cache () of ranges of currently registered virtual addresses; and determining, by the system level message passing module (), whether to deregister ranges () of virtual addresses in dependence upon the cache of ranges of currently registered virtual addresses. The method of  differs from the method of  in that the method of  includes intercepting (), by the system level message passing module (), an application () level call to register a particular range () of virtual addresses that does not fall within a range of currently registered virtual addresses maintained in the cache (). The method of  also includes determining () that the cache () is full. In the method of , determining () whether to register ranges of virtual addresses includes registering () the particular range () of virtual addresses. In the method of , maintaining () a cache () of ranges of currently registered virtual addresses includes evicting (), from the cache (), a least recently used and least recently added range of currently registered virtual addresses in dependence upon the counter () for the least recently used and least recently added range of currently registered virtual addresses. Evicting (), from the cache (), a least recently used and least recently added range of currently registered virtual addresses in the method of  includes deregistering () the least recently used and least recently added range. Also in the method of , maintaining () a cache () includes adding () the particular range of virtual addresses to the cache of currently registered virtual addresses.","For further explanation,  sets forth a flow chart illustrating a further exemplary method of administering registered virtual addresses in a hybrid computing environment according to embodiments of the present invention. The method of , like the method of  is carried out in a hybrid computing environment similar to the hybrid computing environments described above in this specification. Such a hybrid computing environment ( in ) includes a host computer ( on ) having a host computer architecture and an accelerator ( on ) having an accelerator architecture, the accelerator architecture optimized, with respect to the host computer architecture, for speed of execution of a particular class of computing functions, the host computer ( on ) and the accelerator ( on ) adapted to one another for data communications by an SLMPM () and, optionally, by two or more data communications fabrics (,  on ) of at least two different fabric types. The method of  is similar to the method of  including, as it does, maintaining (), by the system level message passing module (), a cache () of ranges of currently registered virtual addresses; determining (), by the system level message passing module (), whether to register ranges () of virtual addresses in dependence upon the cache () of ranges of currently registered virtual addresses; and determining, by the system level message passing module (), whether to deregister ranges () of virtual addresses in dependence upon the cache of ranges of currently registered virtual addresses. The method of  differs from the method of  in that in the method of  maintaining () a cache () of ranges of currently registered virtual addresses includes receiving (), from an operating system (), a notification () that the operating system () is unable to register a particular range of virtual addresses. Also in the method of , maintaining () a cache () of ranges of currently registered virtual addresses includes evicting (), from the cache (), a least recently used and least recently added range of currently registered virtual addresses. Evicting a least recently used and least recently added range of currently registered virtual addresses in the method of  includes deregistering () the least recently used and least recently added range. Also in the method of , maintaining () a cache () of ranges of currently registered virtual addresses includes registering () the particular range of virtual addresses. Registering () the particular range of virtual addresses in the method of  includes adding () the particular range of virtual addresses to the cache () of currently registered virtual addresses.","Exemplary embodiments of the present invention are described largely in the context of administering registered virtual addresses in a fully functional hybrid computing environment. Readers of skill in the art will recognize, however, that method aspects of the present invention also may be embodied in a computer program product disposed on signal bearing media for use with any suitable data processing system. Such signal bearing media may be transmission media or recordable media for machine-readable information, including magnetic media, optical media, or other suitable media. Examples of recordable media include magnetic disks in hard drives or diskettes, compact disks for optical drives, magnetic tape, and others as will occur to those of skill in the art. Examples of transmission media include telephone networks for voice communications and digital data communications networks such as, for example, Ethernets\u2122 and networks that communicate with the Internet Protocol and the World Wide Web. Persons skilled in the art will immediately recognize that any computer system having suitable programming means will be capable of executing the steps of the method of the invention as embodied in a program product. Persons skilled in the art will recognize immediately that, although some of the exemplary embodiments described in this specification are oriented to software installed and executing on computer hardware, nevertheless, alternative embodiments implemented as firmware or as hardware are well within the scope of the present invention.","It will be understood from the foregoing description that modifications and changes may be made in various embodiments of the present invention without departing from its true spirit. The descriptions in this specification are for purposes of illustration only and are not to be construed in a limiting sense. The scope of the present invention is limited only by the language of the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
