---
title: Using kernel level simulation techniques to improve application program robustness
abstract: A method and system for simulating system conditions at a kernel-level is provided. In one aspect, process identifiers of processes for which simulation is to be performed are transmitted along with simulation pattern or rules from a user-space to a kernel space. Emulator in the kernel space intercepts system calls invoked by processes running in the user space. If the system calls originated from the one or more processes for which emulation was to be performed, return results according to the simulation pattern are generated and returned to the calling process.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07130786&OS=07130786&RS=07130786
owner: Computer Associates Think, Inc.
number: 07130786
owner_city: Islandia
owner_country: US
publication_date: 20040212
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application relates to computer systems, and more particularly, to using kernel-level techniques to simulate various abnormal conditions during development testing to improve application robustness.","During black-box software testing, a wide range of scenarios is not evaluated due to the difficulties of simulating the system conditions that provide those scenarios. For instance, creating abnormal or high-load system conditions such as the unreliable network, memory pressure, or lack of disk space conditions in a real working computer system may negatively impact all other projects that happen to use the same system. Creating such conditions on a real working computer system may also cause damages to the real system, entailing additional costs in the system management and administration. Accordingly, it would be desirable to be able to simulate abnormal system conditions so that software modules may be tested more thoroughly against a wide range of abnormal system conditions, yet other software or projects running on the same system may continue to be run under the normal system conditions.","A method of simulating testing conditions at a kernel-level is provided. The method in one aspect includes intercepting an operating system call from an application at a kernel-level. In the kernel-level, a determination is made as to whether the operating system call was invoked from a process that was identified for failure emulation. If the operating system call was invoked from a process that was identified for failure emulation, user loaded rules are consulted and results to the operating system call according to the user loaded rules are generated and returned to the calling application. If the operating system call was not invoked from a process that was identified for failure emulation, a native operating system service routine associated with the operating system call is called and normal processing takes place.","The system for simulating testing conditions at a kernel-level in one aspect includes a user-space module operable to transmit one or more process identifiers and one or more rules associated with the process identifiers for emulating failure conditions at a kernel-level and a kernel-level module operable to intercept system call, and further operable to determine whether the system call was invoked from one or more processes identified by the one or more process identifiers and if the system call was invoked from the one or more processes identified by the one or more process identifiers, the kernel-level module further operable to generate a return result according to the one or more rules, and if the system call was not invoked from the one or more processes identified by the one or more process identifiers, the kernel-level module further operable to call native operating system service routine associated with the system call.","In one embodiment, the intercepting of the system calls by the emulator module at the kernel level is transparent to the processes that invoke the system calls.","Further features as well as the structure and operation of various embodiments are described in detail below with reference to the accompanying drawings. In the drawings, like reference numbers indicate identical or functionally similar elements.","In one embodiment, a kernel-level module simulates test environments on a selective basis, for example, on a per process basis.  illustrates the logic of processing in the failure emulator kernel module in one embodiment. At , when a process is called, it is determined whether the process is subject to failure emulator processing. This may be done, for example, by checking the identity of the called process, and whether the process's identity was previously downloaded from the user-space and identified as being the process for failure emulation.","At , if a failure emulator is to be used, for example, the process is identified as a process for failure emulation as determined at , syscall-dependent pre-syscall processing is performed at . Pre-syscall processing may include maintaining any statistics that the failure emulator may choose to provide and any emulator-specific logic such as checking a counter for emulating intermittent failures, for example, a failure in 50 percent of calls can be approximated by condition (count % 2)==0. There are various design approaches which will depend on the particular system call, for example, a short read may be emulated by truncating the size of a read request before the call to the original syscall handler (that is, as part of pre-syscall processing) or by just returning part of the buffer of a full read. In some cases, it may not be necessary to call the original syscall handler at all.","At , the original syscall handler is called and the results from the call is saved. At , post-syscall processing is performed. Examples of post-syscall processing include generating syscall result as provided by failure rules, generating error codes as provided by failure rules, and updating system call statistics. Maintaining system call statistics may help setting up and conducting tests.","At , if failure emulator is not being used, at  the original syscall handler is called and the call results are saved. At , syscall returns to its caller with appropriate results and\/or error codes.","In one embodiment, the kernel module uses kernel-intercept technology where system calls are intercepted. The result of a particular system call executed by an application under testing depends on a set of rules downloaded to the kernel module using a user-level binary, for example, a user-space set up utility module.","The user-level binary provides control over what is simulated and how, for instance, intermittent short reads, occasional failure of memory allocations. Intermittent and occasional failures can be emulated by maintaining a set of counters for each system call and using a type of pseudo random number generator. The user level binary is used to communicate selected failure types and patterns to the kernel module that simulates them.","In one embodiment, failure characterization are system call-based, for example, \u201cmake 50 percent of read calls from a process with pid  fail pseudo-randomly with a short read error\u201d. Each failure can be described by the system call, percentage of times it should fail and exact type of failure possible for the system call in question. Process identifiers of the target processes (for example, process owner, group owner, pid) can be downloaded to the failure emulator kernel module by a separate API call. The failure patterns (rules) may be selected by the user based on his scope of interest and what is available or implemented in the failure emulator kernel module.","The simulation may be done without requiring any modifications of the applications being tested. Thus, it is possible to test the exact application binary before the application is released to customers.","In one embodiment, a testing person may activate failure simulation for a particular process or group of processes by issuing a command that provides process identification to the kernel module together with a chosen set of failures and their patterns.  is a flow diagram illustrating a method for activating failure simulation in one embodiment. At , the group attribute of the process, for which the failure condition is to be emulated, is set to one particular group. This way, one particular group may have the group ownership of the executable file that spawns the process. For example, for\n\n","At , the identities of the processes that are to fail are downloaded to the failure emulator module. For example, the command line: fem_control-i -g failtest will download the identities to the failure emulator module called fem_control. At , failure test patterns are downloaded as follows: fem_control-c  -t , where -c  requests call #  (read), -t  requests read failure of type . Failure type  may, for example, be short reads. At  failure emulation is started, for example, by the following command: fem_control -a . Here, the parameter \u201c-a \u201d sets active flag on, enabling the kernel-level emulation module.","At , the returned test failure patterns may be observed, for example, to check how the process responds to the failure. For example, once simulation is activated, a tester may observe program behavior correlating observations with requested type of failure. At , the failure emulation may be stopped, for example, by a command: fem_control -a .","In one embodiment, the kernel-level simulation system disclosed in the present application includes kernel-level components and user-space setup utility components.  is a block diagram illustrating the kernel-level components and user-space setup utility components in one embodiment. The kernel-level components may be a library statically linked into the kernel during the kernel build. The kernel-level components may also be dynamically loaded as a module.","In the following discussion, both types are referred to as a failure emulator kernel module. The arrows in  illustrate control\/data paths when failure emulator is active. In one embodiment, all service calls from user programs   go through the system call dispatch  to the failure emulator kernel module  which then calls the original system call handler . In one embodiment, the failure emulator module is completely transparent. The test pattern rules  are consulted for each process to be tested to see what kind of failure is requested.","The user-space setup utility components communicate setup data to the kernel-level components. User-space setup utility  in one embodiment is a program that is used to set up and control the kernel emulation module . It communicates with the kernel emulation module  via its own system call that is installed during the kernel module startup in a spare system call table slot . In one embodiment, the failure emulator API  is based around that system call. The user-space setup utility  parses the command line, sets up the parameters for and makes an API call . The API call  communicates with the kernel emulation module  using the system call .","In one aspect, operating service calls from the user-level ,  are intercepted at the system call table level , by replacing the addresses of original system call handlers with addresses of functions in the failure emulator kernel module , then modifies their behavior for the calling processes, consulting the rules  uploaded by the user-space control utility.","A typical system call wrapper in the failure emulator kernel module has code similar to the following for a read system call:",{"@attributes":{"id":"p-0027","num":"0030"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if (caller is a target_process) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if (rules[__NR_read].enabled) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"rc = (*orig_read_sycall) (arg1, arg2, arg3) ;"]},{"entry":[{},"switch (rules[[__NR_read].type) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case SHORT_READ:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"rc >>= 1 ;"]},{"entry":[{},"SET_ERRNO(0) ;"]},{"entry":[{},"break ;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case INTRD_READ:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"rc = \u22121 ;"]},{"entry":[{},"SET_ERRNO(EINTR) ;"]},{"entry":[{},"break ;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"default:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"rc = \u22121 ;"]},{"entry":[{},"SET_ERRNO(EINTR) ;"]},{"entry":[{},"break ;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"return rc ;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} else {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"return (*orig_read_sycall) (arg1, arg2, arg3) ;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} else {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"return (*orig_read_sycall) (arg1, arg2, arg3) ;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"For all other processes running on the same system, native operating system service routines are processed normally as shown in the above example.","The system and method of the present disclosure may be implemented and run on a general-purpose computer. The embodiments described above are illustrative examples and it should not be construed that the present invention is limited to these particular embodiments. Although the description was provided using the UNIX system call table as an example, it should be understood that the method and system disclosed in the present application may apply to other operating systems. Thus, various changes and modifications may be effected by one skilled in the art without departing from the spirit or scope of the invention as defined in the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"}]},"DETDESC":[{},{}]}
