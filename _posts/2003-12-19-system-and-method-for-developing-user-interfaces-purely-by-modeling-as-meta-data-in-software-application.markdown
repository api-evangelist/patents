---
title: System and method for developing user interfaces purely by modeling as meta data in software application
abstract: A system, method and computer program that enables an application designer to automate the process of development of user interfaces (UIs). The designer develops UIs by modeling. The process of development of UI applications by modeling does not require any coding. The modeling activity is accomplished by using the visual modeling environment, which among other tools comprises a set of pre-built reusable components. Each component represents a dimension of functionality that is commonly required in UI applications. The designer specifies application-specific context for the components. Components when provided with application specific context become tasks. The tasks are then connected together in a logical order to develop an application. The applications thus developed are then visually verified. These applications are then executed by an Engine.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07451403&OS=07451403&RS=07451403
owner: Rage Frameworks, Inc.
number: 07451403
owner_city: Westwood
owner_country: US
publication_date: 20031219
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","BACKGROUND","SUMMARY","DESCRIPTION OF PREFERRED EMBODIMENTS","1. Introduction","2. Example User Interfaces","3. Details of an Embodiment of the Present Invention"],"p":["This application claims priority to U.S. Provisional Patent Application No. 60\/435,559 entitled \u201cA System And Method For Developing User Interfaces Purely By Modeling As Meta-Data In Software Application\u201d by Dr. Venkatesan Srinivasan, Mahantesh Kothiwale, Rummana Alam and Srinivasan Bharadwaj, filed on Dec. 20, 2002, which is incorporated by reference as if set forth herein in its entirety.","The present invention relates to the field of development of graphical user interfaces (GUIs). More specifically, the present invention relates to the field of rapid development of GUIs.","The Evolution of GUIs","As semiconductor-processing power increases and computer architecture improves, the overall performance of computer hardware has improved exponentially. More sophisticated computer software evolved to take advantage of the higher performance of the hardware and to offer richer functionality. The task of developing an appropriate interface between the application and the user became more and more difficult, as software applications became more complex.","Before the advent of the user interface (UI), commands to a software application were provided by text menus. The output of the processing done by the application was also displayed in text format. As software applications became more complex, the number of inputs from the user and the display needs increased significantly. Taking input and displaying output in text formats was found to be an inadequate way of handling the interaction between the application and the user. Hence, GUIs were developed to provide a more user-friendly paradigm.","Early GUIs were developed for computer operating systems with Apple and Microsoft taking the lead. Application developers of big enterprise-wide applications followed the lead and started developing GUIs for their applications. Today, almost all applications come with a GUI in conjunction with a mouse, a keyboard or a touch screen to select various options. For example, all the enterprise resource planning applications like SAP\u2122, present data differently to different users depending on their requirements. Similarly, various desktop applications use GUIs extensively for providing a user-friendly interface to allow the user input data and to present output. For example, various applications for media manipulation and technical analysis like AnSyS\u2122, AutoCAD\u2122, MATLAB\u2122, etc. use GUIs extensively for user input and for displaying output. Therefore, development of the GUI has become integral to the development of any software application.","Historically, application logic was coded on the server in the mainframe computer. In this architecture, no GUIs were developed as the entire application logic was coded on the mainframes. Later on client server architecture was introduced. With the introduction of client-server architecture, application logic was coded and deployed on the client side as well. Thus, GUIs were developed accordingly and installed on the client side. In present day network architecture, GUI applications are coded to deal with the presentation layer only. As a result, the presentation layer is distinct from the data access layer and logic layer.","GUI Development Process and Challenges","GUI development is an integral part of any software development effort that requires user interaction. Despite significant advances in software development methodologies, architecture and tools, the pace and ease of GUI development and modifications is inadequate.","In a contemporary layered architecture, GUI development is largely limited to coding the presentation of information to the users, validating and capturing user actions and interfacing with the application's logic and data access layers. In older architectural paradigms, GUI development may also involve the development of application logic and\/or data access functionality.","The conventional way to develop GUIs is to go through a software development lifecycle (SDLC). As shown in , an SDLC consists of various stages as an idea gets converted into a software application. At each stage, output from the previous stage is translated to serve the purpose of the current stage. In such a cycle, unless one stage of the cycle is complete, next stage cannot be started. Also, with each translation, an effort is made to preserve full information and knowledge from the previous stage. Thus, a significant amount of overhead is created at each stage. As a result, traditional SDLC results in a time-consuming development of complex and cumbersome software applications for GUIs.","Methodological Improvements and their Impact on GUI Development","One of the major hurdles in GUI development is the amount of time it takes from conceptualization to completion. While Prototyping tools have eased the issue somewhat, the time to market is prohibitively long. There is a need to dramatically reduce the time to market in GUI development.","Another hurdle in GUI development has been the lack of inter-operability across operating platforms. Obviously, this increased the time and effort to develop GUIs for cross-platform applications. The advent of the Java\u2122 programming language has alleviated the challenge considerably. Java\u2122, originally developed by Sun Microsystems, is an object-oriented, multi-threaded, portable, platform-independent, secure programming environment used to develop, test and maintain software programs. A Java\u2122 virtual machine is used to run a single Java\u2122 source code on all the platforms, thereby substantially decreasing the efforts required in GUI generation.","While Java has enabled inter-operability, the emergence of network centric computing and the Internet have made browser based GUIs the presentation medium of choice. Designers face two broad challenges in this context. First, they have to choose amongst multiple programming options on which to develop the GUIs, e.g. Java Server Pages, Active Server Pages, etc. Second, there are considerable challenges if a designer wants to develop the same GUI on a browser and on the desktop. In most cases, the designer has to develop the GUIs twice, once for the browser and once for the desktop.","Another hurdle in GUI development is the rapid evolution of GUI development environments and frameworks and the need for people skilled in these environments. Today, a diverse range of options exists with different capabilities suited for different applications. Hence, there is a requirement for a GUI development tool that allows GUI generation without the knowledge of any programming languages.","To accelerate the process, various GUI development tools are available today. A GUI development tool is a software product used to facilitate rapid development of GUIs by automating some of the repetitive tasks. Currently available visual development tools automate the process of GUI development to a large extent. Developers can drag\/drop various GUI components into the main window and the corresponding code snippets are automatically added to the main code. Hence, a substantial decrease in development time is achieved. However, there are various hurdles in the rapid development of GUIs.","All GUI development tools today are code generators and some of them provide visual development tools like Microsoft Visual Studio, Visual Caf\u00e9, Jbuilder, etc. These tools generate code in the specified language, which is then compiled and deployed. Since the output of all these tools are in the form of code in a programming language, they require expert knowledge of the programming environment. These tools are complete application development environments and do not allow the generation of GUIs independent of the application. Development tools based on Extensible Markup Language [XML] and Extensible Style Sheets [XSLT] do allow the generation of GUIs but require specialized programming skills.","Related Patents and Products","Various systems have been proposed to overcome one or more of the above shortcomings. A WIPO Patent application No. 0072184, Entitled \u201cA Platform Independent System Of Specifying An Embedded User Interface\u201d of Matsushita Mobile Communication Development Corp. of USA, discloses a development tool for developing embedded user interfaces. The patent discloses a system of storing and generating a user interface in the form of elements and parameters. These elements and parameters describe various aspects of the user interface including the form of presentation to the user and response to the user feedback. A User Interface Engine residing within a target device (like mobile phones and various electronic gadgets) monitors user events and displays the user interface in accordance with the elements and parameters.","Another system as disclosed in U.S. Pat. No. 6,025,836, entitled \u201cMethod And Apparatus For Generating Object Oriented User Interfaces\u201d assigned to Novell, Inc., develops object oriented user interfaces. The User Interface Generator creates separate class files containing user interfaces suitable for use in different languages. The invention aims to achieve reusability and rapid generation of complex user interfaces to minimize costs associated with internationalization of software applications.","Yet another U.S. Pat. No. 6,342,907, entitled \u201cSpecification Language For Defining User Interface Panels That Are Platform-independent\u201d assigned to International Business Machines (IBM), specifies a specification language to allow a developer to define platform-independent user interface panels without a detailed knowledge of complex computer programming languages. A Panel Definition Markup Language (PDML) is defined in accordance with the Extensible Markup language (XML) standards. Java Swing is used to generate user interfaces. A graphical editor allows the creation and modification of platform-independent user interface panels without programming directly in the specification language. A run-time manager for different platforms process PDML panels to display the panels.","All the abovementioned patents and products require the GUI developer to do some coding for generating GUIs. Moreover, some of them primarily focus on GUIs for embedded systems. No generalized solution is available that does not require any coding for GUI generation. Also, these patents and products focus on one or more of narrow problems, like controlling the exact location of user interface objects using Java\u2122 swing. None of the patents and products addresses the abovementioned drawbacks of the GUI development process at a broader level. Hence, there is a need for a system that addresses all the abovementioned issues.","The present invention is directed to a system, method and computer program that provides an application development framework that automates the process of Graphical User Interface (GUI) development rather than automating the process of coding.","An object of the present invention is to provide a system, method and computer program that enables an application designer to develop GUIs for software applications by modeling without coding.","Another object of the present invention is to provide a system, method and computer program that enables an application designer to develop GUIs for software applications based on computational logic with reduced software development life cycles.","A further object of the present invention is to provide a system, method and computer program that reduces GUI development activity to a pure modeling exercise.","Another object of the present invention is to provide a system, method and computer program that allows changes to be made rapidly in GUIs by merely changing the GUI models without doing any coding or code-testing as in a conventional software development life cycle.","Another object of the present invention is to provide a system, a method and a computer program that is user friendly and reduces and\/or eliminates the need for an application designer to have expertise in at least one formal programming language.","To attain the above-mentioned objectives, the present invention provides a system, method and computer program that provides a complete application development environment for GUIs. The application development environment comprises a visual modeling environment that enables an application designer to design and model GUIs, a set of reusable pre-built components, an Engine capable of executing the GUIs and a database to store GUIs modeled by the application designer. The visual modeling environment allows the application designer to develop GUI models in a flowchart like manner using the pre-built reusable components. These reusable components are highly abstract objects that are built to perform a specific function in computation. The designer creates computational logic based applications by selecting appropriate components, specifying application specific meta-data to model tasks using selected components and then logically connecting them with each other. The components are reusable, i.e. once a component is selected, a copy of that component is created for use in an application. Thus, a component can be used in different applications by creating copies of the component and specifying meta-data as per the application's properties. After selecting the required components, the designer inputs application-specific data. The application specific data provided to a component is called meta-data.","For example, consider a Rule component that represents the functionality of computation of a condition. The application designer inputs the condition to be computed for the GUI in the form of meta-data. Also, the application designer specifies the tasks to be executed in the case of success and failure of the rule. A component instance when provided with application specific data becomes a task. The tasks thus generated are then connected together in a logical manner to create GUI applications. After modeling, these applications are verified. The application designer may verify the entire application at once, in parts or task by task. To verify the modeled application in parts, the application designer sets breakpoints in the application.","The GUI applications modeled and verified using the visual modeling environment are executed using the Engine. The application models generated can also be executed by third party systems. That is, the system according to the present invention has the capability of integrating with third party systems.","The present invention provides for a method, system and computer program to automate the process of developing Graphical User Interfaces (UIs). Hereinafter, Graphical User Interfaces (GUIs) will be referred to as User Interfaces (UIs). As opposed to the current set of application development technologies that focus on automating the process of coding user interfaces, the current invention provides a method, system and computer program to reduce the user interface development activity to a modeling exercise and relies on abstract components to eliminate coding altogether.","Referring primarily to , a software development lifecycle in accordance with an embodiment of the present invention is hereinafter described. In this lifecycle, the development starts with the conception of an idea  for an application. A First stage  involves the translation of idea  into Business requirements . Business requirements  are documented in terms of the business processes that need to be supported by the application. These business processes include the user interface needs of the application. A Second stage  involves visual modeling of Business requirements  in accordance with an embodiment of the present invention. The output of the second stage is Models  of Business requirements . In a Third stage , Models  are tested for their functional validity. The output of Third stage  is Functionally tested models . Functionally tested models  are ready to be released as UIs. At a Fourth stage , Functionally tested models  (User Interfaces) are rolled out as finished UIs . A Fifth stage  involves obtaining user feedback  on finished UIs  from the users. A Sixth stage  reflects that the feedback from the users typically results in generation of a new idea; after this stage, the software development lifecycle starts all over again. Seventh stage  and Eighth stage  are feedback stages where functional testing of Models  may result in revisions of Business requirements  and\/or Models .","The present invention is applicable whenever software development requires user interface development. The degree of separation between user interfaces, application logic and the application data is a function of the architectural approach adopted by the application development team. As shown in , a software application generally comprises three layers: User Interface , Application logic  and Application data . In addition to the three layers, we can view an Application Controller  as the coordinating mechanism that facilitates the required flow through the application. These are logical separations and the exact line of demarcation between the layers depends on the context and needs of the application. The generally recommended approach is to keep the user interface or presentation layer as thin as possible.","In accordance with an embodiment of the of the present invention, user interface development includes the development of screens, the interaction between the user interface and Application Controller  including the navigation between screens and validation of user input. This is without loss of generality. Application Controller  defines and controls the overall flow of the UI application logic. The present invention allows for narrower or broader definitions of the scope of user interface development. Further, the modeling semantics may vary slightly as a function of the target deployment environment (Java, Windows, Macintosh, etc.) and the type of user interface (browser-based, desktop-based).","In accordance with an embodiment of the present invention, application requirements are modeled as described in U.S. patent application Ser. No. 10\/336,965, entitled \u2018Business Process Technology For The Enterprise\u2019, by Rage Frameworks, Inc filed on Jan. 6, 2003, which is incorporated by reference as if set forth herein in its entirety. Here a business or a business problem is broken down into its constituent business processes. Referring now primarily to , such a multi-echelon systematic view of a business is hereinafter described in detail. A Business  comprises Business processes -. As shown, business process may initiate another Business process ; business process may be viewed as a sub-process of Business process . Each Business process -is a collection of business tasks. For example, Business process comprises a Set of tasks and another Set of tasks wherein Set of tasks further comprises Tasks Tto Tand Set of tasks further comprises Tasks Tto T. These tasks are arranged in a logical order to model the business process. The tasks, when carried out in the defined logical order, would execute the business process. Multiple arrows (coming from the top in the figure) into a Set of tasks, for example Set of tasks , illustrate that the same set of tasks is being executed in more than one Business process (and ). Finally, each task, (for example T), is an instance of one of abstract Components -. Components -are highly abstract objects that are built to perform a specific function in user interfaces. Instances of Components -, when provided with business process specific properties called \u201cmeta-data\u201d become business tasks. Different instances of the same component will result in different business tasks appropriate for the process they are being used in, even though they are instances of the same abstract business component. For example, two tasks that display User Interface screens are both instances of the user interface component and yet, each would display two different screens and would be used in two separate processes or the same process. The difference between the two tasks lies in the task-specific properties specified as meta-data to the instance of the components used in the respective tasks.","Once business requirements are identified in terms of the underlying business processes, they are modeled using an embodiment of the present invention, including their inter-relationships across processes. The modeling activity is accomplished by using the visual modeling environment in accordance with an embodiment of the present invention. The visual modeling environment comprises a set of abstract business components among other tools. Each business process is viewed as a collection of business tasks. Each business task is modeled as an instance of an abstract business component. The instance acquires process-specific context with process-specific parameters (meta-data) input by the application designer. Such tasks are then connected together as required for the business process. The entire set of business process models for an application, including their inter-relationships, is referred to as the application domain.","There are many different scenarios that an application designer could adopt when approaching application modeling. A few sample scenarios are described:","Scenario A\n\n","Scenario B\n\n","Scenario C\n\n","Scenario A is a top-down approach to modeling an application. In this approach, the application designer starts by modeling the application's domain and then proceeds to model the details. A data model is a structural representation of the data that would be collected in any application and stored permanently. On the other hand, Scenarios B and C, start with a specific aspect of the application (for example, the application's User Interface storyboard in scenario C) and proceed to other aspects later. A User Interface storyboard is a map of all the user interface screens and their relationship with each other.","The actual approach followed is a function of the application designer's prior experience and expertise. While the above scenarios have been described as being sequential, the process is likely to be iterative between the various steps. Further, the abovementioned scenarios are not mutually exclusive; an application designer may follow a combination of the abovementioned scenarios. The present invention should not be considered limited to these scenarios and their combinations only; it is also possible to conceive of many more scenarios.","In accordance with an embodiment of the present invention, user interface development substantially translates to the development of a process that encapsulates all the sub-tasks required for the user interface identified earlier in this section. The modeling environment of the present invention provides a business friendly point-and-click facility for the application designer to model all these sub-tasks by providing a set of abstract components that represent commonly required functionality in user interface development.","Once the models are developed, the next stage involves testing the logical accuracy and efficiency of the models. Upon having validated the models for logical accuracy and efficient performance, user interfaces are ready to be released.","In the software development lifecycle in accordance with an embodiment of the present invention, as described in , the number of stages in the cycle are significantly less with the less value added steps largely eliminated. Stages that do not add any significant value to the final application are largely eliminated. Stages that arise purely because of coding are also eliminated. The reduction in the number of stages also results in a reduction in the number of feedback stages, for example, Seventh stage , resulting in a significantly simplified cycle.","In this section, we illustrate the working of the UI component with several examples. User Interfaces can be broadly categorized into two types: browser-based and desktop-based. Browser-based applications have gained in popularity for the ease with which they can be deployed and maintained while desktop-based applications continue to be the choice in the case of applications that involve significant amounts of analytics and complex user-interaction.","While there is significant commonality in the process of different combinations of target environments (Windows, Macintosh, etc.), the application types may require different sets of meta-data.","2.1 Browser-based User Interface",{"@attributes":{"id":"p-0075","num":"0087"},"figref":"FIG. 5","b":["501","501","501","503","505"]},"The meta-data for UI  consists of attributes for the screen, 2 text fields (\u2018username\u2019 and \u2018password\u2019) with their look and feel attributes (length, font, font-style, label, etc), 2 buttons with their attributes (name, length, etc.) and 2 actions corresponding to the 2 buttons. The meta-data consists of 6 columns. These six columns together allow the application designer (UI modeler) to specify all the attributes for UI . The first column is the name of an object to be placed on UI . The second column specifies the section that the object is a part of, e.g. header, body, etc. The third column refers to the type of object. The type of the object includes but is not limited to\u2014Form, Variable, Link, Table, etc.","The type of objects specified in the meta-data represent the objects used in UI  and the present invention should not be considered as limited to these types of objects only. Numerous similar types of objects will be apparent to those skilled in the art. The fourth column refers to a sub object where one is required in some cases, e.g. a sub object of UI objects \u2018username\u2019 and \u2018password\u2019 is \u2018input\u2019. The fifth column is an attribute column, which specifies various attributes for the objects. For example, for the UI object \u2018username\u2019 the attributes listed in the meta-data are\u2014\u2018name\u2019, \u2018maxlength\u2019, \u2018size\u2019 and \u2018value\u2019. The sixth column defines the values of the attributes of an object listed in the fifth column. For example, for the UI object \u2018username\u2019, the values of the attributes \u2018name\u2019, \u2018maxlength\u2019, \u2018size\u2019 and \u2018value\u2019 are \u2018username\u2019, \u201820\u2019, \u201820\u2019 and \u2018 . . . \u2019 respectively.","Desktop-Based User Interface","Examples of desktop-based UIs generated using the present invention are presented in  and . These figures collectively illustrate the depth of functionality of the UI component by demonstrating the modeling of a GUI for the UI component itself.",{"@attributes":{"id":"p-0080","num":"0092"},"figref":"FIG. 6"},"The meta-data for the menu tree comprises a menu control with specifications for each menu (label, action, keyboard shortcut), menu items for each menu again with all the necessary attributes like label, action, etc.","The meta-data structure for the Swing environment has 8 attribute columns and has essentially the same structure as the structure for the Java Server Pages illustrated in the previous section. The first column is an object reference. The second column is a function or object type reference. The third column specifies the name of the attribute and the remaining columns are attribute value columns.  is an example of a model browser, which is useful as a navigation GUI for the UI component.","The purpose of the model browser is to list all the applications and UI models that the designer is working on and allow easy access to the models.  illustrates both the menu system and the model browser together.",{"@attributes":{"id":"p-0084","num":"0096"},"figref":["FIG. 9","FIG. 9","FIG. 6","FIG. 7","FIG. 9","FIG. 9","FIG. 6","FIG. 7"]},"3.1 Network Diagram","Referring now primarily to , a network diagram of the system in accordance with an embodiment of the present invention is hereinafter described in detail. The present invention can either be used in conjunction with a framework as described in patent application Ser. No. 10\/336,965, titled \u2018Business process technology for the enterprise\u2019, filed by Rage Frameworks, Inc. or on a loosely coupled basis. System  allows for development and deployment of user interfaces for one or more applications on a loosely coupled basis. The network architecture supports three layers\u2014a Presentation Layer , a Service Layer  and a Data Layer .","Presentation Layer  comprises a Designer  and an Administration Tool (AT) . Designer  is a Java application used to create, debug and validate the UI models. Designer  provides a visual modeling environment that allows the application designer to define, build and deploy UIs. An application designer creates UIs by modeling the UI requirements in a flowchart like manner. Modification of a UI is also done using Designer  by modifying the visual flow diagrams that constitute the relevant UI. AT  enables the administrator to perform administrative functions such as security management, log files maintenance, reporting and monitoring system activity.","Service Layer  comprises a Web Server  and Application Server .","Web Server  runs a Controller Servlet compliant with industry standard web servers. This Controller Servlet is a program that facilitates the connection of Designer  and AT  to Application Server . Designer  and AT  interact with Web Server  through HTTP(S) (Secure Hypertext Transfer Protocol). In an embodiment of the present invention, Web Server  can handle both HTML and XML requests from Designer  and AT .","Application Server  comprises three parts\u2014a Designer Server , an Engine  and a Data Access Layer . Designer Server  facilitates User Interfaces of Presentation Layer . Engine  is the runtime execution module of System . Engine  serves (i.e. executes two types of requests) the requests generated by an application designer while developing and maintaining user interface models and serves the requests generated at runtime by the application for which the UIs have been created. Engine  also houses the XML versions of the UI models created using Designer .","Data Access Layer  acts as a gateway to a Database . Data Access Layer  provides a set of standard interfaces, which are implemented by various Java beans. Data Access Layer  is used when either Engine  or Designer Server  needs to access Database . Data Access Layer  also captures statistics related to database access. Statistics related to database access could be the query time, elapsed time and execution time. These statistics assist in database performance optimization.","The application designer interacts with Designer  to create UI models and stores the validated models in Database . The administrator interacts with AT  to administer System  and UIs created using System . The user interacts with the applications modeled using Designer . All these interactions generate requests that are serviced by Engine .","Data Layer  comprises Database . Database  stores all the UI models, i.e., the layouts, the validation rules and the database mappings. Database  is a meta-database. Access to Database  through Data Access Layer  is provided through a connection pool using the Java Database Connectivity (JDBC) protocol.","3.2 Designer","Designer  comprises an integrated set of modeling tools and abstract components that together allow the application designer(s) to model and validate all aspects of the UI application visually. Referring now primarily to , a GUI for the main screen of Designer  is hereinafter described in detail. The illustration shows the GUI the way it would appear during a typical UI modeling session. The figure shows a Designer Menu System , an Object Browser  and a UI Tool Palette . Designer Menu System  provides a number of menu options to the application designer to create UIs and to validate them. Object Browser  is another way for the application designer to navigate through the UI models created in Designer  and\/or to engage in modeling. Designer  allows the application designer to create UIs for multiple applications, reuse whole or part of any application UI in another application, create UIs as templates, and designate certain UIs to be at the system level, forcing a higher level of security and access control.",{"@attributes":{"id":"p-0094","num":"0106"},"figref":"FIG. 11","b":["1107","1105","1103","1109","1111","1105","1113","1115","1117","1119","1121"]},"A UI process in accordance with an embodiment comprises multiple tasks that are connected with each other. Every task performs a step in the overall process. A task is an instance of a component with UI specific run-time properties, i.e. a task is a business object that provides services specific to a UI process or collection of UIs. A component is a highly abstract object, which represents a function that is typically required in UI and provides generic services that can be made UI-specific by providing UI-specific properties. The UI specific properties are called meta-data. On supplying meta-data to a component, the component becomes a task.","While creating a UI, the application designer selects these pre-built components according to the requirements of the UI. The application designer thereafter creates tasks using the components by specifying run-time properties specific to the business process. Using Designer , the application designer drags and drops these tasks and then interconnects them to model the entire UI. After connecting the tasks, the application designer specifies UI-level properties such as when to execute the UI process. These are called Process Triggers and they could be ad hoc, periodic or event based. An ad hoc scheduling is used, if the user needs to execute a UI at a specific time. The application designer may choose periodic scheduling, when, for instance, a user wants a UI to be executed every night, except on holidays. Event Triggers are attached to database activity. The user can have UIs triggered based on database activities such as insert, update and delete at table as well as column level. Thus, the application designer creates the entire UI in a flowchart-like manner by connecting pre-built components. Hence, neither coding nor programming needs to be done in order to create a UI. Therefore, anyone with none or very little coding and\/or programming knowledge may create UIs that model highly complex business requirements rapidly and efficiently.","At the Enterprise level, this has several significant benefits. First, it shifts the focus and control of implementation to the process owner and not necessarily a technical, non business person. Second, it reduces the time to market. Third, it results in significant cost reduction.","UI development can be decomposed into application level and screen level.","Application level development refers to the overall user interface structure of the application. Referring now to , a typical application layout structure for a browser-based application is shown. The application layout structure in  has been divided into 3 parts\u2014a Left frame , a Top frame  and a Bottom frame . This design envisions that each of the frames will contain a user interface screen. In accordance with an embodiment of the present invention, the logic relating to which screen to display in which frame is contained in Application Controller  (shown in ).","Screen level development refers to the placement of controls (described with reference to ) on the screen, the mapping of database fields to screen variables, validation of user action at the control level (e.g. validating values entered in a field) and at the layout level (e.g. validating values across fields) and the forwarding of screen information to Application Controller .",{"@attributes":{"id":"p-0101","num":"0113"},"figref":"FIG. 13","b":["1301","1301","1303","1305","1307","1309"]},"Creating a new UI from an existing UI is even simpler in accordance with an embodiment of the present invention. The application designer may use an existing UI and make a copy of its template by using the \u201csave as\u201d feature. The copy is named and the tasks are changed\/modified according to the requirements of the new UI. The properties related to the UIs are supplied in the tasks. The tasks are connected with each other to reflect the UI flow logic. After connecting the tasks in a logical flow, UI level properties are specified.","UI Tool Palette  contains a representation of all the available components in the form of icons. While creating a business task using a business component, the application designer may either re-use an existing task (modeled previously) or create a new task. In either of the cases, UI specific properties for the business task are provided in the task properties screen. Double-clicking on any of the tasks displays task properties screen to the application designer. Task screens for different components are shown with reference to .","System  provides a built-in Verifier for testing, troubleshooting and improving the UI and the task models modeled using Designer . The Verifier provides a powerful and friendly mechanism to test and verify a UI process. Verification is done at two levels. First, the Verifier applies the pre-defined verifications for each task on the UI process being tested. Second, the Verifier gives the application designer the ability to step through each task in the UI process and verify it.","Each task may be verified by invoking the Verify option within Designer . The Verify option runs a set of pre-defined verifications. The verifications are defined for each abstract component. Invoking the Verify option on a task prompts the application designer to input any startup parameters for the task, applies the verifications for the underlying component and presents the results with their severity levels in the Output window of Designer .","In addition, the application designer can setup Watch variables and Break points. Very often, the application designer may want to observe the value of some intermediate information variables as the UI is being executed. Setting up Watch variables refers to the practice of identifying the variables that the designer wants to observe, the values of which the application designer wants to observe as the UI model being executed. Similarly, the application designer may want the Verifier to stop at some pre-defined points in the process so that the information in the memory of the process may be analyzed. Such points are referred to as Break points.","After the modeling of a UI is complete, the application designer may decide to deploy the UI using Designer . Choosing the deployment option creates an XML version of the application UIs and stores them on Application Server . This is done for performance optimization and has the additional benefit of not requiring a database for the application models at deployment.","There are a number of settings that Designer  uses for modeling an application. These include the use of user locale providing date and time format, time zone and language appropriate to the user, resource location for strings and images, the location to store debug information, ability to enable or disable memory, and the enablement or disablement of memory caching.","3.3 Components","As stated before, UI Tool Palette  contains an iconic representation of the components available to the application designer. Components may be of two types: flow and functional. Flow components allow the application designer to model some aspect of the process flow. Functional components, on the other hand, allow the application designer to model a function using business logic.",{"@attributes":{"id":"p-0110","num":"0122"},"figref":["FIG. 14","FIGS. 19-24"],"b":["1105","1105","1105","1401","1403","1405","1407","1409","1411","1413","1415","1417","1419","1421","1423"]},"3.3.1 The Anatomy of UI Component","Each component represents a dimension of functionality that is commonly required in UI development. By way of an example, the UI layout component represents the need to specify layout properties for a UI. All components are designed such that the functionality embodied in the component is externalized in the form of meta-data.","Each component has a similar structure and comprises three sub-parts. The first sub-part is a meta-data structure. \u201cMeta-data\u201d is a collection of application specific parameters. A component when provided with a meta-data becomes a task. The second sub-part of a component is a set of Graphical User Interface (GUI) objects. These objects encapsulate the meta-data structure and provide a user-friendly environment for the application designer to specify the meta-data. The third sub-part is a code segment that understands the meta-data structure and the implied functionality of the component. The code segment uses the meta-data and the abstract function of the component to perform a business specific task.","3.3.2 Flow Components","UI Tool Palette  comprises a number of flow components including but not limited to, Selection , UI Start\/End , Line , Rule , Loop Object , End Loop component , and Text component .","3.3.2.1 Selection (Arrow)","Selection (arrow) component  allows the application designer to select existing tasks and create new tasks. The application designer can also select multiple tasks and perform operations such as cut, copy, move and paste.","3.3.2.2 UI Start\/End","UI Start\/End component  allows the application designer to denote where a UI Model starts and ends. There may be multiple instances of UI Start\/End component  in a UI Model. Multiple starts allow the application designer to design an execution strategy that serves more than one purpose. Multiple ends denote the natural end points in a UI Model.","UI Start\/End component  also allows the application designer to design startup parameters required for the current UI Model to execute. These parameters are provided by the application or user that invokes the current UI. Referring now primarily to , the UI Start\/End component's meta-data structure is hereinafter described in detail. The meta-data structure comprises an identifier for process start object , a Name  and a set of parameters . Each parameter object in turn comprises a Name , a Direction , a Data Type , a List , and a Default Value . The parameter ID is system generated and unique to the process. Name  identifies the parameter to the application designer. Direction  allows the application designer to declare whether the parameter is an incoming or an outgoing parameter. An incoming parameter of a task is defined as a parameter that is utilized by the task. An output parameter of a task is defined as a parameter that is generated by the task and is given as an output on executing the task. Data Type  declares the parameter's type that may be String, Numeric, Boolean, etc. List  allows the application designer to associate a list of values to the parameter. This implies that the parameter may have any one of the values in List . Finally, Default Value  allows the application designer to declare a default value for the parameter in case the parameter is not provided by the calling application.","3.3.2.3 Line","Line component  allows the application designer to connect two tasks. In certain cases, the line connecting the two tasks needs to denote an outcome. For example, in the case of Rule component , the process may branch into multiple tasks depending on the outcome of Rule component . The line component's meta-data structure contains a line outcome attribute that is specific to each instance of the line component. In the case of Rule component , the outcome is binary.","Referring now primarily to , the meta-data structure for the Line component  comprises a name attribute with multiple possible values . The name attribute refers to the outcome that the line is intended to represent.","3.3.2.4 Branching (Rule)","Rule component  allows the application designer to create separate branches of execution in the process as a function of some condition. Rule component  is both a Flow and a Functional component.","The meta-data structure for a rule reflects the following abstraction. The branching rule is a condition that may comprise single or multiple conditions. Each condition may be abstracted to contain a left-hand side (LHS) expression, a right-hand side (RHS) expression and a relational operator that relates the LHS and RHS. Relational operators are =, <, >, <=, >=, not equal to, contained in, contains, like, etc. When a rule has multiple conditions, the conditions may be connected using either conjunctively (AND) or disjunctively (OR) operators.","The expressions used in the rule component may include literals, system functions, process variables and input parameters. Consider a Business Rule component's example as shown below:","If (customer.risk>90","And m1>=100000)","Or (m2<=200000)","Then True","Else False\n\n","90, 100000 and 200000 are the RHS expressions","Referring now primarily to , the meta-data structure of Rule component  is hereinafter described in detail. The meta-data structure for a rule extends over two levels. At the top level are attributes that are unique to the Rule: an Identifier , a Name , a Created By , a Created Date , a Version No. , a Description  and a Rule group . Rule group  allows the application designer to group rules into convenient classifications that improve their organization in Object Browser .","The rule's condition represents the second level of the rule's meta-data structure.  displays the rule's conditions that can be one or many. The rule's conditions(s) are defined using table . In the Primary column of table , the application designer specifies the primary condition (for example \u2018if\u2019). In the LHS column, left hand side of the condition is defined. Similarly, in the RHS column, right hand side of the condition is defined. In the Operator column the operator is defined that compares LHS and RHS. Examples of the operator comprise \u2018greater than\u2019, \u2018smaller than\u2019, \u2018equal to\u2019, \u2018not equal to\u2019, etc. The condition meta-data structure defined in table  is further explained with reference to . Referring now primarily to , the condition meta-data structure is hereinafter described in detail. The meta-data structure allows the application designer to compose an LHS  and an RHS  of a condition using process memory information, information from the application database, and\/or various inbuilt functions. Where LHS  and RHS  involve date\/time information and a Unit  and a Unit  allow the application designer to define the time unit (business day, day, week, month, etc.).","Once the application designer provides the meta-data for Rule component , using screenshots shown in  and , the rule is verified. To verify the rule, the application clicks on verify option  provided in the screenshot provided in . The rule is verified and the output of the verification is presented to the designer. The rule verification includes verifying LHS  and RHS  and the condition as a whole. Verification of LHS  and RHS  include verification of associated expressions and the variables used in the expressions. In addition, the meta-data provided using Screenshot of  is also verified. For example, verification is performed to check if the name of the rule provided using Name  does not exceed the number of characters specified for the name.  shows the output message presented to the application designer in case the rule is verified.","3.3.2.5 Text","Text component  allows the application designer to address the documentation and look and feel aspects of the UI model. Using this component annotation and formatting is defined. Annotation allows the application designer to add explicit textual comments to make the process more readable. Formatting allows the application designer to control the appearance of the process including the ability to specify font, background and foreground color. Using this component, font, background and foreground color is specified as meta-data.","3.3.2.6 Loop Object","Loop Object  enables the application designer to model repetitive execution of tasks in within a process. The application designer specifies the meta-data for this component using the screenshot shown in . The application designer specifies a name for the instance of Loop Object  using a Name field . Using an Exit Condition box  the application designer specifies the termination condition for the loop. To define the termination of the loop, the designer has two options\u2014a Number of Iterations option  and a Rule\/DT option . Number of Iterations option  defines the termination when the number of iterations in the loop reaches the defined value. Rule\/DT option  defines the termination of the loop on the occurrence of a condition specified in a rule. This rule is selected using a Select Rule\/DT button . Using this button, the user selects an existing rule. This rule, an instance of Rule component , is defined by the application designer in the manner described with reference to  and .","3.3.2.8 Task Component","Task component  represents the functionality of calling Rule component . Task component  enables reusability of Rule component  by calling Rule component  across multiple UIs. In an embodiment of the present invention, it is assumed that business rules will generally need to be reusable across UIs and different applications. To facilitate such reusability, the designer is allowed to create the rules using parameters. In designing the UI process, the designer can then provide UI-specific data as parameters to the rule. Task component  facilitates such modeling.","3.3.3 Functional Components","3.3.3.1 UI State","UI State component  defines the state of the corresponding UI. State of a UI may be a \u2018user-defined\u2019 state or a \u2018system-defined\u2019 state. A user-defined state is externally monitored by the end user of the application. A user-defined state is defined at process level. A system-defined state is also associated with the process level. The system-defined state has three possible values\u2014\u201cStart\u201d, \u201cProcessing\u201d and \u201cComplete\u201d. \u201cStart\u201d indicates that the process has been selected for execution; \u201cProcessing\u201d indicates that the execution of the process is going on and \u201cComplete\u201d indicates that the processing is complete.","Referring now primarily to , the UI State component's meta-data structure is hereinafter described in detail. The meta-data structure comprises an Identifier  unique to the process, a Name  and a State  with multiple values. The multiple values for State  refer to the \u2018user-defined\u2019 states. The values in State  are provided by the application designer. For example, in the case of a loan application, the application may be in \u2018Data Entry\u2019, \u2018Investigation\u2019, \u2018In Process\u2019 or \u2018Processing Complete\u2019 states.","3.3.3.2 Assignment Object","Frequently, in a UI model, the application designer needs to retrieve information from a data source or create new information as a function of existing information. This is done through a transformation or formula and the new information is stored in the process memory for subsequent operations. Assignment Object  reflects an abstraction of such functionality so that the application designer can specify the information needed without any programming.","Referring now primarily to , Assignment Object's  meta-data structure is hereinafter described in detail. The meta-data structure for an instance of Assignment Object  comprises a unique Identifier  for the Assignment Object instance, a Name , a Data Type  and an Assigned Value  (expression). Assigned Value  is specified by Assigned Value box . Here, the application designer specifies an expression using repository, variables and functions. As in the case of business rule, the meta-data structure allows the application designer to use any process memory information, information from the application database and\/or built in functions to specify the assigned value. The expressions defined using Assigned Value box  are reflected in Assigned value .","Frequently, the application designer may need to create more than one variable. The meta-data structure allows the application designer to define multiple variable expressions in an assignment instance.","The corresponding assignment module in Engine  has the ability to execute the expressions defined in Assigned Value  fields at runtime without the need to translate the defined expressions into code.","3.3.3.3 Database Access","Database access component  allows modeling of application data access through meta-data. This component performs the function of accessing data from Database . For example, consider an UI that asks a user to login to authorize the user to access an application. Here, a Validate Login task is used while generating the UI. Validate login task is generated using Database Access component . To validate login, the system needs to match the password supplied by the user with the password stored in the database for the user name used by the user. The password stored in the database is accessed by Database Access component .","Referring now primarily to , the meta-data structure for Database Access component  is hereinafter described in detail. The meta data structure for Database Access component  comprises a unique identifier  for the Database Access component instance, a Task Name , a Type , a Rule , a Bulk Selection Flag , a Database , an Entities , an Execution Asynchronously Flag , and a set of Parameters , which in turn includes the following attributes: a Name , a Value  and a Unit .","Using the dropdown provided with Type , the application designer specifies the task to be of one of four types\u2014Insert, Update, Delete and Select. Depending on the type of database access task specified and the entity value chosen using Entities , the application designer then provides values for the parameters in the chosen entity in set of parameters . While specifying the values, the application designer may use any process memory information, information from the application database and\/or built-in functions. This is done using a Parameter Details box .","3.3.3.3 External Object","External Object  allows the designer to invoke program modules outside the present invention. In this component, the designer specifies the parameters that the external program module may need as meta-data and also capture the status of execution of the external program module via Return Codes.","Referring now primarily to , the meta-data structure for the External Object  is hereinafter described in detail. The meta-data structure for External Object  comprises a unique identifier  for the External Object component instance. Using a Name box , the application designer provides a name to the instance of External Object . The application designer provides the description of the instance of External Object  using a Description box . The parameters that the external program module may need are specified using a parameters box . As already stated, the status of execution of the external program module is also captured via Return Codes. The Return Codes are specified using a Return Codes box .","3.4 Administration Tool","AT  is a Java application, which facilitates the system administration of System  and applications created using System . It connects with one or more Web Servers  through the HTTPS protocol. The browsers supported by AT  include Microsoft\u00ae Internet Explorer and Netscape Navigator.","AT  provides various functions that enable an administrator to manage System . These functions include management of various systems level activities as well as application level activities within System . Examples of functions that facilitate systems level activities include starting or stopping Engine . Examples of functions that facilitate application level activities include providing activity reports and statistics to the administrator. Also, application level data such as UI and task related statistics could be analyzed using AT . For example, UI related information includes information such as Wait Time, Execution Time and UI State (for example START, PROCESSING, COMPLETE).","AT  is also used to perform various security management functions of System . For example, AT  may perform user management functions such as creating user profiles and privileges either at the user and or group level. AT  facilitates browsing and searching of system logs created by Application Server  based on Event ID, component name, user name\/id, request ID, date, etc. AT  also facilitates browsing and searching of the security audit log.","3.5 Engine","3.5.1 Overview of Engine","Engine  is the runtime execution module of System  that serves (i.e. executes, interprets or processes) the UIs requested by a user. All requests that Engine  serves effectively imply the execution or the continuation of some UI modeled using Designer . Engine  processes the requests by executing the tasks related to that UI. The tasks are executed using the Execution module inside Engine . The manner in which Engine  executes the requests generated by the user is explained by way of an example. When a user wants to use a web application designed using Designer , the user clicks on an application link. This action sends a request to Engine  for execution\/continuation of the process corresponding to the application link. Engine  receives and processes this request by loading the process (stored as meta-data) and executing the tasks specified in the process using the Execution module. Depending on the application, the process and user specific information such as User ID, permissions, etc., may be cached in the system memory for servicing ongoing requests from the user and\/or for the process.","Engine  has an ability to concurrently execute multiple process requests. This execution may require Engine  to concurrently execute multiple instances of a single component. This may also require Engine  to concurrently execute single or multiple instances of different components. An administrator can configure the number of maximum allowable instances per component while deploying System . During installation, a default number is set for each component, based on available resources such as CPU and memory of the Server. Engine  provides statistics to further fine-tune these settings depending on the desired response time and resource availability.","Engine  uses a Message Service architecture to interact with loosely coupled subsystems such as Designer Server  and Data Access Layer. In an embodiment, Engine  uses asynchronous queued JMS messages to communicate with Designer Server . The Java Message Service (JMS) is a common enterprise messaging Application Programming Interface (API) that is designed to support a wide range of enterprise messaging products. JMS make it easy to write business applications that asynchronously send and receive critical business data and events. Service requests are queued and handled using a combination of First In First Out (FIFO) and a priority criterion. Engine  maintains a Message Queue for request management. The Message Queue comprises a Request Queue and a Result Queue.","The Request Queue contains requests that are forwarded to Engine . These requests are prioritized on the basis of time and the priority level of the corresponding UI models. The Result Queue contains information resulting from execution of the requests. The Result Queue also comprises task summary information such as execution statistics. Both the queues are memory based. The Result Queue also performs the function of saving the information related to these queues in Database . Both the queues have configurable \u201ctimeout\u201d and \u201cmax size\u201d properties.","3.5.2 Caching","Caching is used for optimization purposes in Designer , Web Server , Application Server , and Database . Caching is provided both at the time of modeling of a UI as well as at the time of execution of a UI.","When an application designer starts using Designer  to create an application's UI, Designer  caches all the information related to the application designer including the meta-data created and object Browser . Web Server  caches the information that is most frequently requested. Engine  manages a central cache called Cache Manager on Application Server . All the UIs within Engine  share a common cache in the Cache Manager. During Startup of Engine , all the components that have been configured to be cached at startup are loaded into the Cache Manager. A UI is cached the first time it is invoked, if it is not already cached in the Cache Manager. All the subsequent invocations of the UI retrieve the UI meta-data from the Cache Manager.","3.5.3 Engine Startup Process","Referring now primarily to , Engine  startup process is hereinafter described in detail. At step , Engine  is initialized. In the startup process, Engine  reads a number of parameters specified in the App Server Configuration XML file. These parameters include\u2014Mail server settings, Logger settings, the number of rollover files, the email IDs for the administrator alerts and the severity level and the number of times Engine  will try to run a failed request. Engine  reads the User ID and the password and decrypts them. Further, Engine  initializes the Log Writer and configures alerts for messages of different severity levels. The Log Writer writes log messages to an ASCII text file.","Next, at step , Engine  accesses Database  through Data Access Layer . Data Access Layer  connects to Database  using a JDBC connection pool. At step , Engine  creates and loads the Cache Manager. To load the Cache Manager, Engine  loops through every component and identifies those that have their \u2018Load at Startup\u2019 property set to \u2018Yes\u2019; this is set by the application designer while modeling the application. Thereafter, Engine  locates the components' XML definition files from Application Server  and converts the XML files to Java objects. This conversion is achieved using a third party software Castor\u2122 that maps XML files to Java objects.","Next, at step , Engine  receives requests from the users\/applications and creates a Request Queue and a Result Queue (as described in section 3.5.1). At step , Engine  creates a number of threads as configured by the application designer or as set by default. At step , the threads are attached to the Request Queue and the Result Queue.","The Scheduler prioritizes the results in the Request Queue. The Scheduler looks for requests that were abnormally terminated during the most recent shutdown and assigns them the highest priority. After executing the priority requests, Engine  waits for new requests to arrive in the Request Queue at step . If a request arrives, System  goes to step . While performing any of the steps -, if a fatal error occurs, System  jumps to step . At step , an error notification is sent and Engine  shuts down. Engine  keeps processing as long as there are requests to process and is in a wait state when there are no requests, until it is shut down.","3.5.4 Engine's Process Execution Flow","Referring now primarily to , the sequence of tasks executed by Engine  in servicing a request is hereinafter described in detail. When a request is selected to be executed from the Request Queue, all the business tasks of the corresponding UI are identified. The selection of a request for execution depends on the execution time attribute of the request. The execution time attribute can have a future date and time value, if required. As described in the previous section, the order of selection depends on the priority of the associated UI. Engine  reads the earliest request from the sorted Request Queue based on the condition that the scheduled date-time is lesser than the current date-time. After selecting a request for execution, Engine  identifies the tasks that need to be executed to process the request. Engine  has an Execution Module, in which execution of these tasks takes place. The results of the execution are written to the Result Queue. After processing the request, Engine  goes back to wait state if there are no more requests to process.","At step , Engine  waits for a request in the Request Queue. At step , Engine  checks if there is a request in the Request Queue. If there is a request in the Request Queue, System  moves to step , otherwise it goes back to step  and waits for a request. At step , Engine  reads the request along with the Startup parameters. After reading the request, Engine  updates the Database Queue (used for temporarily storing a request and its status in Database  during its execution) and the UI State (explained in section 3.4) is set to \u201cProcessing\u201d at step . At step , Engine  checks whether the requested UI is already in the Cache Manager; if the process is not present, Engine  fetches the corresponding XML files and converts the XML files to Java objects and loads the process into the Cache Manager. At step , Engine  initializes an EJB instance and the Log Writer. At step , Engine  identifies the tasks that constitute the process. After identifying the tasks to be executed, Engine  executes the tasks at step . The tasks are executed either synchronously or asynchronously, as configured, until an End Task is reached. At step , UI state to \u2018COMPLETE\u2019 and the Request queue and Result queues are updated. At step , the Logger writes the status information and the results in Database .","While performing any of the steps -, if a fatal error occurs, System  jumps to step . At step , an error notification is sent and Engine  shuts down. At step , the UI State is set to \u2018COMPLETE\u2019 and the user is informed that an error has occurred. Engine  keeps processing as long as there are requests to process and is in a wait state when there are no requests, until it is shut down.","3.5.5 Exception Handling","Each process has a built-in Exception Object and Handler. System default actions are taken when an exception occurs. System default actions can be over-ridden by the application designer at the time of modeling. The application designer may provide custom alerts and exception messages at the UI level.","Any message generated through System  can be of the following severity level: Informational, Warning, Debug, Error and Fatal. As earlier described, at step , if an exception is generated with a severity level of type \u201cFatal\u201d or \u201cError\u201d, the execution of the process stops and the Process State of the process is set to \u201cError\u201d.","Referring now primarily to , the Exception Handling Framework is hereinafter described in detail. This framework is designed independent of client technologies. It could be used with multiple clients such as a Java application, an applet, a servlet and Personal Digital Assistants (PDAs). In accordance with an embodiment of the invention, implementation has been provided for a Java application and a servlet.","Exception Handling Framework  comprises a field called Error Types and Structure . Error Types and Structure  contains an Error Object  and an Exception Hierarchy . Error Object  encapsulates all the information about an error and its context. The application designer can create and use the error objects like other data.","Exception Handling Framework  comprises another field called Error Handling Strategies . Error Handling Strategies  contains an Error Handler , which is the error handling subsystem used by the client to process an error. Error Handler  uses an Error Dialog  to display the error message on the client's screen. Error Handling Strategies  also contains an Error Default Handler  to avoid any exceptions that are not handled by Error Handler . A Resource Preallocation  in Error Handling Strategies  performs two functions. First, it creates Error Dialog  at Startup and then shows or hides Error Dialog , as appropriate. It also implements an abstract factory for all the exception handling classes and performs memory management of the exceptions.","Exception Handling  also comprises an Error Integration , which further comprises an Exception Wrapper . Exception Wrapper  integrates a ready-to-use library into Exception Handling Framework .","Exception Handling Framework  also comprises an Exception Manager . Exception Manager  comprises a Centralized Error Logging . Exception Manager  uses Centralized Error Logging  to log the relevant exceptions. All the exceptions are filtered and the relevant exceptions are identified on the basis of their severity level. All the error messages are written to the log file based on the system wide severity level. The system state can have one of the following possible values\u2014Start, Processing, Complete, Error and Exception. Applications can proceed or abort depending on the severity of the error.","3.5.6 Logging","System  creates an application log file, which may be accessed by Designer  and AT . The application log file is stored on Application Server  and maintains a log of information related to functioning of various applications. The log would include a list of all the requests for a given application and a list of errors messages; the application log file is different from the log files produced by the J2EE Server, the Web Server, Oracle or UNIX.","The application log file supports filtering on the basis of Request Identifier or User Identifier. This filtering of information enables a user or an administrator to view the log file by requests or users.","All the application error messages are captured in a resources bundle located on Application Server  and are accessed by Web Server . Application error messages can be broadly divided into two categories\u2014System-defined messages and User-defined messages.","System-defined messages are pre-defined within System . A couple of examples of system-defined messages are: \u201cThe input file does not correspond to the definition specified in the connector\u201d, \u201cConnection to the remote system has been lost due to a communications failure\u201d. The first message implies that the file being read did not match the specifications about the file that were defined in the connector factory instance. Similarly, the second message implies that the connection with the remote system was lost most likely due to a communications failure.","User-defined error messages are defined by the application designer using Designer . For example, a validation in the User Interface component may need to generate an error message to the end user of the application. As with system messages, user defined messages may be assigned severity levels. Users have the capability to manipulate the messages at runtime.","All the system and user-defined messages in various languages are stored in a global resources bundle. All the messages are associated with an internal code. The resource bundle is cached whenever Web Server  accesses the resource bundle. All the components of Engine  and Data Access Layer  use the resource bundle. For example, a stored procedure has an exception and it returns a code to Data Access Layer . Data Access Layer  converts the code to a message in the language based on the system locale and the user locale.","3.6 Database","All the required information for the functioning of the system is stored in Database . Database  is a collection of resources such as databases, tables, columns and their extended attributes. Every component within Engine  is built on top of Database . Database  describes meta-data about meta-data. Designer  uses Database  to define and create objects from components.","Database  stores information related to Fields, Labels, Lists and Substitution Tables. Fields, Labels and Lists are used for creating GUIs. Labels are used for displaying some information to the users. Fields are used to hold information related to the display labels. Lists are used in GUI where the items within a list box are subject to frequent changes. Lists are also used to hold meta-data that may change and the user needs to have an easy access to manage the contents of the list.","If a new data model or a set of new database objects such as tables and indices are created using any commercial Data Modeler tool, they could be accessed by System  once the changes are updated in Database , using the Update procedure. Similarly if a new XML schema needs to be accessed by System , the schema is created using a separate tool and an Update procedure is executed, so that System  begins to recognize the schema. The Update procedure loops through all the database objects and stores their descriptions and attributes in Database . Once the objects are stored in Database , they are accessible to all the components.","3.7 Security","Application Server  provides security services including Authentication, Authorization, Administration and Auditing.","Authentication is the primary identity mechanism that is based on User ID and password. Authentication is used to manage account of a user in System . In an embodiment, Authentication is supported by an API based on XML. For third party applications, the API support for user management is provided through Web Server . The Authentication service is accessible as a task, which in turn is accessible through a process. In other words, the Authentication service is provided as a task within a process.","The Authorization service controls the access of system resources based on the role of a user. The role of the user is generally based on the hierarchy within an enterprise. The Authorization service applies constraints on the access of the resources by a user on the basis of the user's role. The Access control includes functionality level access control and component instance level access control.","The Auditing service is used to track security events in System . The Auditing service provided in System  is file based. The architecture used for Auditing is the same as that used for Logging. SMTP messages are used to provide alert information regarding Critical Audit Events.","The Administration service relates to delegating user administration. The Administration service provides bi-directional synchronization of System  with external systems. Audit message management also takes place through the Administration service.","Consider an example wherein all the security services get used. When a user signs-in for the first time, a user profile is created for the user. The user profile may be created by an administrator or a process through an API call to Application Server . The administrator also creates roles and associates the users with the roles. The user submits his or her credentials in an encrypted channel to Web Server , using a 128-bit Server Digital Certificate. For every subsequent login of the user, a token is generated and attached to the user's browser, after authentication is successful. The token and the session information is encrypted and attached to every request. This information is attached in the HTTP header or the XML element for both the templates or dynamically generated pages. If a token is not found attached to a request, the user is redirected to the login screen. Application Server  looks for a token in the request when the user tries to access a resource. The resources can include a toolbar, a button menu, a menu-item or an edit box in Designer . The Authentication service accesses the user database, caches the user credentials and allows the user to access the protected resources.","AT  provides a GUI to define access control, group and user management. Database  stores the security rights by storing the list of users that do not have access to a resource. A list of users that do not have access rights for an object is stored as this list is likely to be shorter as compared to users with access rights. Some examples of groups for resource access are\u2014Designer Group, AT Group and Applications Group. For example, an Application Group consists of a group of users that are provided with rights to use the application. The User Table keeps track of all the users of a particular application.","There may be a set of access rights associated with a resource. For example, a user may be provided with one or more of the following access rights\u2014Full Access, Create, Read, Modify, Delete and Execute. The rights for a resource are defined at the time of creation of a new object. Default rights for a new object provide Full Access to the creator and Read and Execute rights to every other user.","3.8 Additional Features","3.8.1 Internationalization","The system supports internationalization and thus may be used in any part of the world. All the software components of the overall system are completely internationalized and capable of localization to any language, including multi-byte character systems (MBCS). All the messages and the GUI labels such as menu and control labels are also internationalized. Based on the user's locale, the corresponding resource bundle is bound to the client. The applications generated using System  are also internationalized. All the date-times are stored in Universal Time format and appropriate conversions are made before showing it to the user.","The servers in the system operate on English Sun Solaris. The clients run on US English or the International version of Windows. The database and XML use UTF-8 (Unicode Transformation Format-8) encoding.","The language of the Oracle database may be set to the required language according to the user's preference. Language in the database is set by using NLS_LANG. The default value of NSL_LANG is AMERICAN_AMERICA.UTF8. The character set encoding is set to UTF-8 in INIT.ORA startup file for Oracle. The default LANG environmental variable for the operating system is en_US. The LC_ALL category is selected so that character handling, monetary formatting, date-time format and sorting rules depend on the selected locale.","Engine  stores messages in log or audit files in System  based on server locale. All the messages that are written to the log file are picked up from the resource bundle based on language ID. The system is made MBCS (Multibyte Character Set) aware. MBCS is used for character sets that contain large number of different characters, for example the Asian language character sets. The system supports the conversion of UCS-2 (Unicode Character Set-2) data to MBCS data and vice versa as per the requirement.","AT  uses Xerces that supports UTF-8 for providing internationalization. AT  uses HTML templates and JSPs that are stored in a root directory. AT  supports multiple languages by placing a different template for each language in a sub-directory. The name of the sub-directory is driven by the system locale.","3.8.7 Scaling Options","System  is scalable and may be deployed as a large enterprise, a workgroup or a departmental solution. The present invention is scalable at both the system as well as the application level. At the system level, the three layers\u2014Presentation Layer , Service Layer  and Data Layer \u2014may be deployed on a single server or may be spread over multiple servers. Every layer may further be deployed on one or more servers. If multiple servers are used, industry standard load balancing and fail-over solutions such as F5 and Cisco may be used. Engine  may also be deployed on multiple servers. Load balancing and fail-over solutions from J2EE are used while deploying Engine  on multiple servers. In the database server, high availability is achieved by using options such as Veritas Clustering and Oracle Parallel Server.","At the application level, various scaling solutions are available with System . Throughput and responsiveness of System  may be improved by increasing the number of concurrent process execution tasks. Engine  adapts to available resources such as CPU and memory. In other words, Engine  scales itself linearly with available resources. Thus, increasing resources on a single server or adding multiple servers improves the performance of System .","Advantages offered by the present invention are as following:","The present invention allows creation of GUIs for software applications without coding, purely by modeling the UIs using meta-data.","The present invention allows development of GUIs for software applications with reduced software development life cycles.","The present invention allows changes to be made rapidly to GUIs by merely changing the GUI models without doing any re-coding or code-testing as in a conventional software development life cycle.","The present invention eliminates the need for an application designer to have expertise in at least one formal programming language for creating GUIs for software application.","The present invention may also be embodied in computer program product for use with a computer. The computer program product includes a computer readable medium having a computer readable program code embodied therein.","While the embodiments of the invention have been illustrated and described, it will be clear that the invention is not limited to these embodiments only. Numerous modifications, changes, variations, substitutions and equivalents will be apparent to those skilled in the art without departing from the spirit and scope of the invention as described in the claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The preferred embodiments of the invention will hereinafter be described in conjunction with the appended drawings provided to illustrate and not to limit the invention, wherein like designations denote like elements, and in which:",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 27"}]},"DETDESC":[{},{}]}
