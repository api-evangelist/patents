---
title: Partitioned application environment
abstract: A partitioned application environment is disclosed. In various embodiments, a request associated with an application environment in which an application is running is received from the application. A determination is made to fulfill the request at least in part via a call to a node at which application code associated with the application is running in an application environment partition provided at the node. A call associated with the request is sent to the node, based at least in part on the determination.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09465677&OS=09465677&RS=09465677
owner: MOBILE IRON, INC.
number: 09465677
owner_city: Mountain View
owner_country: US
publication_date: 20160331
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO OTHER APPLICATIONS","BACKGROUND OF THE INVENTION","DETAILED DESCRIPTION"],"p":["This application is a continuation of co-pending U.S. patent application Ser. No. 13\/922,077, entitled PARTITIONED APPLICATION ENVIRONMENT, filed Jun. 19, 2013, which claims priority to U.S. Provisional Patent Application No. 61\/662,162, entitled LOAD BALANCING OF A VIRTUALIZED, PARTITIONED APPLICATION ENVIRONMENT AND ITS ADMINISTRATION VIA A MANAGEMENT CONSOLE, filed Jun. 20, 2012, both of which are incorporated herein by reference for all purposes.","The most common way in which an end-user interacts with a computing device is through applications. Applications are packaged into application binaries, which are serialized representations of the application's programming logic. Operating systems (OSs) provide an application environment (AE), or a set of AEs, one of which is used when the end-user instructs the OS to launch an application binary. The choice of which AE to use and how to deploy the application binary within it is usually the task of a specialized OS component called a loader.","The loader, on instruction from the OS, will attempt to retrieve the application binary from one of the OS services that manages serialized media. Typical serialized media can be physical storage devices (eg: floppy disks, hard drives, ROMs, CDROMs, etc.), networked components and services (eg: network storage, application stores, etc.) or local system non-persistent resources such as main memory (eg: RAM) and other form of caches. The loader then attempts to deserialize the application binary into a storage area designated for execution by the OS. This storage area is typically called a process and is budgeted a set of resources (eg: virtual address space, CPU time, etc.) by the OS. On a successful deserialization operation by the loader and execution of the process by the OS, the application binary becomes an application that is evident to the end-user.","Once an application has been started, it will attempt to consume resources provisioned to it by the OS. Certain resources are privileged and cannot be directly consumed by the application, as they fall under the authority of the OS or a delegated authority (DA) of the OS. An example of such resource ownership is the Graphical User Interface (GUI) subsystem, which typically is managed by an application, called the Window Manager (WM) in the Microsoft Windows\u2122 OS, and is appointed by the OS as the DA for GUIs. In order to use these types of resources, an application must interact with the owning DA, WM in the case of GUI resources, via an OS gateway known as the Application Programming Interface (API). This gateway provides a fundamental abstraction for the OS and DA to manage and arbitrate privileged resources.","The set of resources available to be used by an application, which typically includes both resources that can be consumed directly and those accessed via APIs, is termed as the Application Environment (AE). A compatible AE is fundamental to running any application on a given OS.","Application Environments (AE) have been virtualized in two ways. In one approach, of the host operating system (OS) that provides the specified AE is virtualized. This is typically done with a system hypervisor that uses a combination of hardware and software to replicate the physical machine specification for the OS into a virtual machine. Note that there are at least two OS instances running concurrently in this model. In a second approach, emulation is used to translate the specified AE into that of another which uses a different OS. Note that there are no virtual machines in this model and only one OS is running.","The invention can be implemented in numerous ways, including as a process; an apparatus; a system; a composition of matter; a computer program product embodied on a computer readable storage medium; and\/or a processor, such as a processor configured to execute instructions stored on and\/or provided by a memory coupled to the processor. In this specification, these implementations, or any other form that the invention may take, may be referred to as techniques. In general, the order of the steps of disclosed processes may be altered within the scope of the invention. Unless stated otherwise, a component such as a processor or a memory described as being configured to perform a task may be implemented as a general component that is temporarily configured to perform the task at a given time or a specific component that is manufactured to perform the task. As used herein, the term \u2018processor\u2019 refers to one or more devices, circuits, and\/or processing cores configured to process data, such as computer program instructions.","A detailed description of one or more embodiments of the invention is provided below along with accompanying figures that illustrate the principles of the invention. The invention is described in connection with such embodiments, but the invention is not limited to any embodiment. The scope of the invention is limited only by the claims and the invention encompasses numerous alternatives, modifications and equivalents. Numerous specific details are set forth in the following description in order to provide a thorough understanding of the invention. These details are provided for the purpose of example and the invention may be practiced according to the claims without some or all of these specific details. For the purpose of clarity, technical material that is known in the technical fields related to the invention has not been described in detail so that the invention is not unnecessarily obscured.","A partitioned application environment (AE) is disclosed. In various embodiments, an AE is split (partitioned), effectively, into two or more AEs, which are used in coordination to provide access to an application, and the functionality the application embodies, to an end user of the application.","In various embodiments, a logically partitioned AE that enables compute workloads of a contained application to be distributed across various logical and physical entities is disclosed. In various embodiments, the partitioned environment may span a plurality of networked computing nodes and a plurality of Operating Systems each deployed on a unique computing node.","For example, an AE may in some embodiments be split into two (sometimes herein designated as AE and AE, for example), one of which executes in the intended host OS (AE), e.g., an app written by an app developer for mobile devices having a particular OS, and the other which executes in, by way of example but not limited to, a server OS (AE). Each split AE may be run either within a virtual machine or on a physical machine. In yet another example, an AE can be split into two (AE and AE, for example), where a first application environment AE executes on the host OS but related application environments used to provide the application (AE) could be split into further AEs, such as AE() to AE(n), and cumulatively all these AE's still function to provide one application. The execution of the AEs, e.g. the split AEs, in a controlled and coordinated manner provide the environment, under which application binaries may be deployed.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 1A","b":["100","102","104","106","108","110","112","114","116","102","106","116","102","106","116","104","108","112","114","102","106","116"]},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 1B","b":["142","144","146","148","150"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 2A","b":["202","204","206"]},{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 2B","FIG. 2B"],"b":["222","224","226","228","230","230","228","230","222","224","230","224","230","224","222","228","224","230","222","230","230","224","230","230"]},"In the examples shown in , the AE has been split between two or more AEs, each of which is designated a specific role. In other embodiments, the division of work across AEs may be determined dynamically, for example based on dynamic determinations of resource availability, current workload, current capacity, etc. In either approach, to an Application deployed within this AE set, the AE set appears as a singular, homogeneous AE, no different from that for which the Application was originally designed for.","By way of example, consider an application designed for the Microsoft\u00ae Windows\u2122 OS. A typical application for this OS is written using the Win32\u2122 API and the C++ programming language. At its simplest form an application written for the Win32\u2122 API involves initializing its own internal state, services and data structures and then interfacing with the Win User function set provided by the Win32\u2122 API to construct Windowing objects. The sequence for creating a trivial window is by invoking the RegisterClassEx routine followed by a Create Window and ShowWindow routine. This allows the application to instruct the WM to allocate internal data structures to track the newly created window, create a visual object for the computer screen and display it.","This Application may be run in an AE that is split along the API interface boundary. The API interface boundary is an example of one possible split point that can be used to divide an AE. For the purposes of illustration the above example of a Win32\u2122 Application can be split along the Dynamic Link Library (DLL) boundary to produce the an AE that can run on the server (AE) using any OS and a corresponding AE that talks to the Microsoft\u00ae Windows\u2122 OS instance (AE). Communication between the two AEs can be facilitated by using standard Inter Process Communication (IPC\u2014see ), Remote Procedure Calls (RPC\u2014see FIG. A) or any other service, which provides a logical connection and preserves the illusion to the application of a homogeneous Win32\u2122 API AE.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 3A","FIG. 3A","FIG. 3A"],"b":["300","302","304","306","308","302","304","310","312","314","316","314","316","314","316","306","308","302","304","312","302","304"]},"In various embodiments, the remote AEs (AE) in the AE set can be intelligently placed across nodes in a network in order to address various use cases. For example, in order to preserve a native user experience, the set of function calls in an API that constitute GUI functionality can be bundled into an AE that can be placed in close proximity to the end-user. This is illustrated by  where the client provides (AE) and the server provides (AE). Depending on various policy decisions, such as but not limited to, security, network bandwidth consumption, etc., the Distributed Load Balancer (DLB)  may decide to position an AE at different points in a network topology. The decision to position an AE at any network location can be either a static decision (immutable after the user launches the application) or dynamic (based on a set of variables and circumstances that occur when the application is running).","In the example shown in , application data may be stored in data storage  associated with nodes represented by node . Data may be accessed, for example, by an application instance executing in AE , and results of the processing thereof may be caused to be displayed to an associated end user of a client device such as client device  or client device .","In various embodiments and examples described herein an application is partitioned to have a first application partition realized on a server side application environment and a second application partition realized on a corresponding client side application environment. For example, a user interface and other user experience related aspects of the application may be realized by application code running in a client side application environment while backend processing, data access from an external or other data storage system, etc. may be performed by application code running in a corresponding server side application environment. However, in various embodiments, using techniques disclosed herein an application may be partitioned across any two or more nodes, with various corresponding application partitions being realized on the respective nodes by application code running in an associated application environment on that node.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 3B","FIG. 3B"],"b":["1","340","342","344","346"]},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 3C","b":["360","362","364","366","368","370","364","370","360","362","366","368","366","370","360","364","362","364","360","362","364","362","362","368"]},"In some embodiments, techniques described herein may be used to facilitate simultaneous and\/or otherwise collaborative use of application data. The application data may reside at and be modified by application code running in a server side application environment, for example, and an application hypervisor at the server may facilitate collaborative access to and\/or modification of the application data, e.g., document or other content data, by multiple users, each interacting with the application via a user experience portion of the application executing in an application environment partition provided at a client system being used by that user. In various embodiments, an application hypervisor at the server may be configured to broker access to the content, including by resolving any conflicts between actions taken by the different users, e.g., by implementing conflict resolution logic, user-specified policies, etc.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 4","FIG. 4"],"sub":["\u03c1","\u03c6","\u03c6"],"b":["404","402","406","408","412","410","412","414"]},{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 5","FIG. 5","FIG. 5","FIG. 5"],"b":["502","504","506","508","510","512"],"sub":"\u03c6"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 6","FIG. 6"],"b":["602","604","606"],"sub":"\u03c6"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 7","FIG. 7","FIG. 7"],"b":["702","704","706","708","710","712"],"sub":"\u03c6"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":["FIG. 8","FIG. 8","FIG. 8","FIG. 8","FIG. 8"],"sub":["\u03c1","\u03c6"],"b":["802","804","804","806","804","808","808","810","804","808","812","814"]},{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 9","FIG. 9","FIG. 9"],"b":["902","904","906","908","910","912"]},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 10","b":["1002","1004","1018","1002","1006","1008","1010","1002","1010","1012","1014","1002","1002","1016"]},"Referring further to , the server  includes a LINUX (or other operating system) kernel , a POSIX compatibility layer , a user space (GNU) , runtimes , and user interface library . An application hypervisor  running on the aforementioned stack (, , , , ) in various embodiments emulates an application environment (AE) with which the application is associated. In various embodiments, the application hypervisor  includes software code that, when executed, makes remoting decisions with respect to the application. Server-side remoting services  enable remote calls to be communicated to the client device  and\/or enables remote calls sent to the server  to be received and processed. Application  comprises application binary executing in an emulated AE provided at the server . User experience elements  enable certain user experience related processing to be performed at server .",{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 11","FIG. 11"],"b":["1102","1104","1106"]},{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 12","FIG. 10","FIG. 12"],"b":["1202","1204","1206"]},"In various embodiments, applications may utilize some form of user identification tracking, for example iOS and Android have a Unique Device Identifier (UDID) for each physical device. This may raise security concerns about user tracking based on the physical device's identification. In various embodiments, application deployment as disclosed herein resolves this issue. Instead of providing a single fixed binary, a one-time application token is embedded in some embodiments into a small binary (under a megabyte) that is tied to the user installing the application. A token is uniquely generated for each thin application client that the user downloads to their device. Once the client is launched, it checks to see if a device token is found within the secure storage of the device. If it is not found, then the client provides its embedded application token to an authentication server, which generates a unique device token which is returned to the client, and stored in the secure storage on the device. This device token is used to securely identify and authenticate the device to all services going forward.","In some embodiments of this authentication model, the user initially sends a request to the Enterprise Application Store (EAS) to download the thin client application. The EAS then retrieves the template thin application binary from data storage. It then generates a unique \u201cApplication Token\u201d for the request and injects it, along with other useful data, into the binary. The thin application binary is digitally signed, then returned to the initial request for the application, and loaded onto the user's device. Once the application is launched, the application will check the secure storage for a \u201cSecure Token\u201d. If a \u201cSecure Token\u201d is not found, then the application will send the user's credentials plus the embedded \u201cApplication Token\u201d to the assigned server over a secure connection. The server then validates the user based on the user's credentials as well as validates the \u201cApplication Token\u201d. If the \u201cApplication Token\u201d is valid, the server then generates a \u201cSecure Token\u201d and stores this for future processing. The server then sends this \u201cSecure Token\u201d back to the application over secure connection. The application then stores this \u201cSecure Token\u201d in the device's secure storage for future processing requests. The application then interacts with the server as needed.","The benefit of this token authentication in some embodiments is that it securely identifies enrolled devices as belonging to a user without relying on system provided credentials, which are available to other applications on the device, preventing many potential spoofing attacks against the system.","A partitioned application environment and an infrastructure and techniques to provide same have been disclosed. In various embodiments, processing to realize an application and associated functionality may be performed across two or more AE partitions, which present themselves to the application, with the aid of an application hypervisor on a server side and\/or an application partition manager on a client device, as a single, homogeneous application environment. Use of such an architecture to provide access to and use of mobile or other applications as a service, and\/or to maintain synchronization between multiple instances of a stored application object, such as a file, have been described.","Although the foregoing embodiments have been described in some detail for purposes of clarity of understanding, the invention is not limited to the details provided. There are many alternative ways of implementing the invention. The disclosed embodiments are illustrative and not restrictive."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Various embodiments of the invention are disclosed in the following detailed description and the accompanying drawings.",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3C"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 12"}]},"DETDESC":[{},{}]}
