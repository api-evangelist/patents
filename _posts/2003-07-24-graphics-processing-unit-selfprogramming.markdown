---
title: Graphics processing unit self-programming
abstract: A method of self-programming a graphics processing unit (GPU) includes receiving a blit instruction defining a blit operation and storing a first control value in a control register, which determines the behavior of the GPU, using the blit operation. The blit instruction is read by the GPU from a command buffer asynchronously with the CPU. The blit operation is applied to a second control value to determine the first control value. The second control value can be stored in a memory, such as a second control register or a table of control values accessed by an index value. In one application, the second control value is a starting memory address for a display buffer, while in another application, second control value is a clip plane distance. The blit operation can include a copy operation, a colorkey operation, a logic operation, and/or a pattern copy operation on the first control value.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06952217&OS=06952217&RS=06952217
owner: NVIDIA Corporation
number: 06952217
owner_city: Santa Clara
owner_country: US
publication_date: 20030724
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["The present invention relates to the field of computer graphics. Many computer graphic images are created by mathematically modeling the interaction of light with a three dimensional scene from a given viewpoint. This process, called rendering, generates a two-dimensional image of the scene from the given viewpoint, and is analogous to taking a photograph of a real-world scene.","As the demand for computer graphics, and in particular for real-time computer graphics, has increased, computer systems with graphics processing subsystems adapted to accelerate the rendering process have become widespread. In these computer systems, the rendering process is divided between a computer's general purpose central processing unit (CPU) and the graphics processing subsystem. Typically, the CPU performs high level operations, such as determining the position, motion, and collision of objects in a given scene. From these high level operations, the CPU generates a set of rendering instructions and data defining the desired rendered image or images. For example, rendering instructions and data can define scene geometry, lighting, shading, texturing, motion, and\/or camera parameters for a scene. The graphics processing subsystem creates one or more rendered images from the set of rendering instructions and data.","To maximize rendering performance, it is generally desirable for the CPU and the graphics processing subsystem to operate asynchronously. This permits both the CPU and the graphics processing subsystem to operate independently of each other and without interruption. However, typical graphics processing subsystems require the direct assistance of the CPU to perform certain tasks, such as updating the graphics processing subsystem's control registers or evaluating conditional statements. During these tasks, the CPU and graphics processing subsystem must operate synchronously. Typically, this requires the graphics processing subsystem to be idle while waiting for the CPU, or vice-versa. This wasteful processing overhead decreases the performance of the computer system. Further, many rendering optimizations that are theoretically possible cannot be implemented because the processing overhead is greater than the performance improvements.","It is therefore desirable for a graphics processing subsystem to perform tasks such as updating its own control registers or evaluating conditional statements without the assistance of the CPU.","An embodiment of the invention leverages the blit engine of the graphics processing unit to load and\/or combine values in its control registers, enabling the GPU to program itself asynchronously and without assistance from the CPU. Embodiments of the invention can be used for simple programming tasks such as loading a new value into a control register, or for more complicated tasks such as conditional rendering.","One embodiment of the invention is a method of self-programming a graphics processing unit (GPU) including receiving from the CPU a blit instruction defining a blit operation and storing a first control value in a control register using the blit operation. The first control value in the control register determines the behavior of the GPU. In a further embodiment, the blit instruction is read by the GPU from a command buffer asynchronously with the CPU.","In another embodiment, the blit operation is applied to a second control value to determine the first control value. The second control value can be stored in a memory. In one embodiment, the memory is a second control register. In yet another embodiment, the memory includes a table of control values, including the second control value, accessed by an index value. In yet a further embodiment, the index value is changed to access a third control value in the table following the blit operation.","In still a further embodiment, the second control value is a starting memory address for a display buffer. In an alternate embodiment, the second control value is a clip plane distance. In one example of this alternate embodiment, the second control value is greater than the depth extent of an object.","In yet another embodiment of the invention, the blit operation includes a colorkey operation. In an additional embodiment, the blit operation includes a logic operation on the first control value. In still another embodiment, the blit operation includes a pattern copy operation. In a further embodiment, the first control value is a copy of the second control value.","The present invention is generally a method and system for programming the control registers of the graphics processing subsystem and evaluating conditional statements without the assistance of the CPU. This eliminates the wasteful processing overhead associated with the synchronous operations typically used to perform these tasks.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1","b":["100","100","105","110","105","115","120","100","125","100","100","105","110","115","120","125","160"]},"A graphics subsystem  is further connected with data bus  and the components of the computer system . The graphics subsystem  includes a graphics processing unit (GPU)  and graphics memory. Graphics memory includes a display memory  (e.g., a frame buffer) used for storing pixel data for each pixel of an output image. Pixel data can be provided to display memory  directly from the CPU . Alternatively, CPU  provides the GPU  with data and\/or instructions defining the desired output images, from which the GPU  generates the pixel data of one or more output images. The data and\/or instructions defining the desired output images is stored in additional memory . In an embodiment, the GPU  generates pixel data for output images from instructions and data defining the geometry, lighting, shading, texturing, motion, and\/or camera parameters for a scene.","In another embodiment, display memory  and\/or additional memory  are part of memory  and is shared with the CPU . Alternatively, display memory  and\/or additional memory  is one or more separate memories provided for the exclusive use of the graphics subsystem . The graphics subsystem  periodically outputs pixel data for an image from display memory  and displayed on display device . Display device  is any device capable of displaying visual information in response to a signal from the computer system , including CRT, LCD, plasma, and OLED displays. Computer system  can provide the display device  with an analog or digital signal.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIGS. 2A and 2B","FIG. 2A","FIG. 1"],"b":["200","205","210","205","210","215","215","205","210","215","110","215"]},"Command buffer  stores a set of rendering commands, such as command set , and rendering data, such as data set . In one embodiment, a command set is associated with a data set. The command set defines the set of rendering processes to be performed by the GPU on the data set. In a further embodiment, the associated data set is stored in the command buffer  immediately after its associated command set.","The CPU  writes command and data sets to the command buffer . The command buffer  can include a number of command and data sets. The CPU  writes command and data sets into the command buffer  at the location determined by \u201cput\u201d pointer . Following each CPU write into the command buffer , the CPU  increments the put pointer  to the next unused location in the command buffer . In an embodiment, a driver software program executed by the CPU  translates high-level rendering instructions from a rendering application into command and data sets, which are then written into the command buffer . In a further embodiment, the driver software program receives high-level rendering instructions via an application programming interface, for example DirectX\u2122 or OpenGL\u2122.","The GPU  reads command and data sets from the command buffer . The GPU  reads command and data sets from the command buffer  at the location determined by \u201cget\u201d pointer . Following each GPU read from the command buffer , the GPU  increments the get pointer  to the location of the next command or data set in the command buffer .","The CPU  and GPU  can access the command buffer independently. This enables the CPU  and GPU  to operate asynchronously. In an embodiment, the CPU  periodically adds new command and data sets to the command buffer. Simultaneously, the GPU  processes command and data sets previously stored by the CPU  continuously. Provided the CPU  stays sufficiently far ahead of the GPU , the GPU  is able to render images without any idle time waiting for the CPU . In an embodiment, the CPU  writes commands and data sets for frames several frames ahead of the frame being rendered by the GPU .","In an embodiment, the command buffer is limited in size. As an example, a typical command buffer is five megabytes in size. When either the get pointer  or put pointer  reaches the end of the command buffer , the pointer is reset to the location of the beginning of the command buffer . In this manner, the command buffer  \u201cwraps around,\u201d enabling the CPU and GPU to access the command buffer  in a continuous loop.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 2B","FIG. 2A","FIG. 2B"],"b":["230","247","255","235","238","260"]},"In , the command buffer  includes an update command . The update command is adapted to instruct the GPU  to change the values of its control registers . As discussed above, the GPU  typically needs the CPU  to assist with tasks such as updating the control registers  of the GPU .","Upon retrieving update command  via get pointer , the GPU initiates an processor interrupt . In response to the processor interrupt , the CPU  halts its current action, for example, writing rendering sets to the command buffer  via put pointer , and executes interrupt handler . In an embodiment, interrupt handler is part of a software driver program adapted to interface software applications with the GPU . Interrupt handler  writes the appropriate values to the control registers  of the GPU . In an embodiment, the CPU  accesses the control registers  via a memory-mapped I\/O interface.","Once the interrupt handler  has completed the update of the control registers , the GPU  reads and processes rendering set  and any successive rendering sets in the command buffer . Further, interrupt handler  allows the CPU  to return to its previously interrupted action.","During the execution of the update command , the GPU  sits idle and waits for the interrupt handler  to complete the update of the control registers . As discussed above, the idle period decreases the performance of the GPU  and makes certain optimizations impractical to implement.","To address the problems introduced by the use of synchronous communications to update, or program, the control registers of a GPU, an embodiment of the invention leverages existing GPU hardware to enable the GPU to program itself asynchronously and without assistance from the CPU.  is a block diagram  of a self-programming GPU  according to an embodiment of the invention. GPU  includes control registers . The values stored in the control registers  determine the behavior of the GPU .","GPU  also includes blit engine . The blit engine  is designed to move or copy large amounts of contiguous data from one region of memory to another region of memory. In many graphics processing subsystems, the data in display memory corresponds with the screen display. Generally, the blit engine  is used to move a set of data representing an object from one area of display memory to another area of display memory, thereby moving the object on the screen display. In a further embodiment, the blit engine  is able to perform logic operations, for example AND, OR, XOR, and NOT operations, and masking operations on the set of data as it is being moved or copied. These operations enable the moving object to be wholly or partially covered by the background image, or vice-versa. Typical example uses of the blit engine  include moving and\/or covering windows on the screen display and moving the mouse pointer on the screen display.","Similar to the examples discussed above, GPU  reads rendering sets, such as rendering set , from command buffer  via get pointer . Unlike the above example, GPU  updates its control registers using the blit engine . Upon retrieving a blit command  from the command buffer  via the get pointer , the GPU activates the blit engine . The blit engine  initiates a blit operation  transferring one or more control register values  previously stored in memory to one or more control registers. The blit engine  reads control register values  from memory, or alternately from one or more control registers. The blit engine  then writes  the control register values  into the control registers , overwriting the previous values of the control registers . In a further embodiment, the blit engine  can perform one or more logic or masking operations on the control register values  prior to writing into the control registers .","Following completion of the blit operation, the GPU  continues operation and retrieves the next command from the command buffer . The GPU  can use the blit engine  to update its control registers  quickly and without waiting for any assistance from the CPU . Similarly, the CPU operates uninterrupted during the blit operation. Typically, the CPU  writes rendering sets and blit commands into the command buffer  far ahead of the get pointer  of the GPU , so that the GPU  can operate continuously. In an embodiment, a driver software program executed by the CPU  creates the rendering sets and blit commands and stores them in the command buffer . In a further embodiment, the driver software program creates rendering sets and blit commands in response to high-level rendering instructions received from a rendering application via an application programming interface, for example DirectX\u2122 or OpenGL\u2122.","The block diagram  shows the operation of the self-programming GPU  generally. Each blit command includes numerous parameters defining the specific details of the desired blit operation, such as the source and destination locations and any optionally logic or masking operations. Depending upon the update requirements, the GPU  can update the values of one or more of its control registers at a time. As illustrated in the example below, the GPU  can also perform several consecutive blit operations to store the desired control register values in its control registers. The operation of the self-programming GPU  will be explained in more detail in the following examples.","Double-buffered rendering is typically used to ensure that animation is flicker-free. The graphics processing subsystem renders a new image into a first display buffer. As the new image is being rendered, the graphics processing subsystem displays a previously rendered image in a second buffer. Upon completion of rendering of the new image in the first buffer, the buffers are \u201cswapped,\u201d and the image in the first buffer is displayed and the next image is rendered into the second buffer, overwriting the previously rendered and displayed image. In a variation of this technique, a first buffer is used for rendering a new image, a second buffer is used to display a previously rendered image, and a third buffer holds a previously rendered image \u201con deck\u201d to be displayed at the next screen refresh interval.","For double buffering rendering techniques, the digital to analog converter (DAC) or other display circuitry of the graphics processing subsystem must be set up to display an image from a buffer at the appropriate time. Typically, the DAC is programmed with the starting memory address of the display buffer, the pixel depth, and the width and height of the display buffer. The value of these parameters are typically stored in control registers. During buffer swapping, the value of the starting memory address is changed from the memory address of the first buffer to that of the second buffer, or vice-versa.","Previously, changing the value of the display buffer starting memory address required the assistance of the CPU, for example using an interrupt handler as discussed above. In one application of the present invention, a self-programming GPU can perform a fast buffer swapping operation with CPU assistance.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 4","b":["400","405","405","410","410","415"]},"The GPU  retrieves commands from the command buffer  via the get pointer . One or more rendering sets  define the desired output image created in a first display buffer. A blit command  for performing a buffer swap operation follows the rendering sets . The goal of this buffer swap operation is to change the display buffer starting memory address used by the DAC  to the starting memory address of the first display buffer, thereby displaying the output image on the display device.","Upon completion of the output image in the first display buffer, the GPU  retrieves and executes the blit command . In response to blit command , blit engine  initiates a blit operation . Blit operation  retrieves a new DAC offset value from a table of DAC offset values  previously stored in memory. Each DAC offset value in table  is the starting memory address of a display buffer. In an embodiment using two display buffers, the table  includes at least one copy of a DAC offset value for each of the two display buffers.","Blit operation  retrieves the new DAC offset value from table  and stores this value in the appropriate one of the control registers , overwriting the previously stored value. The new DAC offset value retrieved from the table  corresponds to the starting memory address of the first display buffer. The DAC  or other display circuitry will use the new DAC offset value stored in the control registers  as the starting memory address of the display buffer, thereby displaying the output image in the first display buffer. Similarly, upon completion of the rendering of a second output in a second display buffer, a second blit operation  is used to load the starting address of the second display buffer into the control registers , thereby causing the DAC  to display the second output image on a display device.","In an embodiment, the buffer swap operation uses blit operations to load additional parameters beside the display buffer starting memory address into the control registers. In another embodiment, the CPU  writes commands into the command buffer via the put pointer  several frames ahead of the GPU  rendering operations. For example, the CPU  writes commands into the command buffer  approximately three frames ahead of the GPU . In this embodiment, the table  will include a total of three DAC offsets values. In an application with only two different display buffers, the first and third table values will be the same, for example the DAC offset value of the first display buffer. The second table value will be the DAC offset value of the second display buffer.","Unlike this example application of the present invention, previous buffer swapping operation required a processor interrupt for each buffer swap. In high frame rate applications, for example over 100 frames per second, the large number of interrupts creates a bottleneck on system performance. The above discussed example application of the present invention performs buffer swap operations without creating any processor interrupts. This typically improves overall rendering performance by 5 percent.","Conditional rendering is another application of the present invention. In conditional rendering, the rendering of objects or portions of a scene are skipped under certain circumstances, such as when it can be quickly determined that the object or portion of the scene is not visible. This improves rendering performance by decreasing the amount of rendering performed for a given output image.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 5","FIG. 5"],"b":["500","500","505","510","500","510","510","505","500","515","520","515","520","520"]},"To avoid the wasteful rendering of object , a visibility test is used to determine if object  is completely obscured by object  in scene . If object  is not visible, then rendering of object  can be skipped. One type of visibility test uses a bounding box . Bounding box  is typically a very simple object that completely encloses the more complicated object . The visibility of object  is tested by performing a \u201cmock\u201d rendering of bounding box , If no pixels are rendered during the rendering of the bounding box , then it follows that object  is not visible in the scene and does not need to be rendered. Because bounding box  is much simpler than object , it takes much less time to render. During the rendering of the bounding box  rendering, no updates are made to the display buffer. This ensures that the output image is unchanged by the rendering of the bounding box .",{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 6","b":["605","605","610","605","620","605","620","605","615","615","605","625"]},"GPU  receives rendering sets from command buffer . To perform conditional rendering of the example scene , GPU retrieves and executes rendering sets  associated with object . Following the completion of the rendering of object , GPU executes initialization command . Initialization command  resets the value of the RPC register  to 0, and also sets the value of the TMP memory buffer  to a large value, such as 10000. The value of the TMP memory buffer  should be set larger than the depth of the object being tested for visibility, such as object  in this example.","The GPU  then renders the bounding box  associated with the object  in response to bounding box command . As discussed above, no updates are made to the display buffer when rendering the bounding box . During the rendering of bounding box , the RPC register  will be incremented if any pixels of the bounding box  are visible from viewpoint . If, upon completion of the rendering of the bounding box , the RPC register  still has a value of 0, then the bounding box , and hence the object , are not visible from viewpoint , and object  does not need to be rendered. Conversely, a non-zero value in the RPC register  indicates that a portion of object  may be visible from viewpoint .","The self-programming GPU  can be used to evaluate the value of the RPC register  and to skip the rendering of object , if necessary. In an embodiment, this evaluation is accomplished by executing two blit commands,  and . Blit command specifies blit operation of a colorkey=0 on the source value and a bitwise NOT operation of the destination . As explained below, this blit operation modifies the TMP memory buffer  based on the value of the RPC register .","A colorkey operation is a blit engine masking operation. A colorkey value is used to determine whether data should be processed by the blit engine or not. In a colorkey on source operation, a colorkey value is compared with the source value, and the blit operation is aborted if the values match. If the source value does not match the colorkey value, then the blit operation proceeds as indicated. In blit command , if the colorkey value, 0, matches the source value, which the value of the RPC register , then the TMP memory buffer  is unchanged. Conversely, blit command  performs a bitwise NOT operation on the value of the TMP memory buffer  if the colorkey value does not equal the value of the RPC register .","Blit operation  specifies a second blit operation of colorkey=55535 and a copy from the TMP memory buffer  to the NCP register . In this example, the color key value is the bitwise NOT of the initial value of the TMP memory buffer set by the initialization command . This value will vary depending upon the choice of the initial TMP memory buffer value and the number of bits in the TMP memory buffer (unsigned 16 bits in this example).","In blit operation , if the value of the TMP memory buffer  is equal to 55535, then nothing is copied from the TMP memory buffer  to the NCP register . In this case, the value of the NCP register  remains 1. Conversely, if the value of TMP memory buffer  is not equal to 55535, for example 10000, then the value of the TMP memory buffer  is copied into the NCP register , overwriting the previously stored value.","Following the completion of blit commands  and , GPU  executes rendering sets  associated with object . Although rendering sets  specify the rendering of object , the resulting value of the NCP register  from the previous blit commands  and  can cause the GPU  to skip the rendering of object . If the value of the NCP register  is 1, which is less than the depth of the object , then object  is in front of the near clipping plane  and will be rendered. Conversely, if the NCP register  has a value greater than the depth of object , for example 10000, the object  will be behind the near clipping plane  (i.e. the object  is between the viewpoint  and the near clipping plane ) and object  will not be rendered.","It should be noted that GPU  reads and executes rendering sets  associated with object  regardless of the value of the NCP register . However, the GPU  will abort the processing of the rendering sets  and proceed to the next command in the command buffer  upon determining that the object is behind the near clipping plane. In an embodiment of GPU , the rendering pipeline is optimized to detect at an early processing stage that objects are behind the near clipping plane. This enables the GPU  to skip rendering object  without performing a large number of wasteful rendering steps.","To further explain this application of the present invention,  shows tables  and  illustrating example register values during a conditional rendering operation performed with a self-programming GPU according to an embodiment of the invention. Tables  and  illustrates the register values of registers RPC, TMP, and NCP during the evaluation of the RPC register as described above. The table  is an example of the RPC register having a non-zero value, for example 2, following the rendering of the bounding box . The \u201cBB\u201d column\u201d shows the values of the registers following the rendering of the bounding box. In this example, the RPC is 2, while the TMP value is 10000, and the NCP is still set to 1.","The first blit operation is a colorkey=0 with the RPC as the source and a bitwise NOT operation on the TMP as the destination. Because the value of the RPC register, 2, does not equal the colorkey value, the blit engine performs a bitwise NOT of the value of the TMP memory buffer. As a result, this operation sets the TMP memory buffer to 55535.","The second blit operation is a colorkey=55535 with the TMP memory buffer as the source and a copy operation to the NCP register as the destination. Because the value of the TMP memory buffer, 55535, is equal to the colorkey value, nothing is copied to the NCP register. The result is that the NCP register still has a value of 1. Therefore, the object  will be rendered.","The table  is an example of the RPC register having a zero value following the rendering of the bounding box , which indicates that the object  should not be rendered. The \u201cBB\u201d column\u201d shows the values of the registers following the rendering of the bounding box. In this example, the RPC is 0, while the TMP value is 10000, and the NCP is still set to 1.","The first blit operation is a colorkey=0 with the RPC as the source and a bitwise NOT operation on the TMP as the destination. Because the value of the RPC register, 0, equals the colorkey value, the blit engine does not perform the bitwise NOT operation and the value of the TMP memory buffer is unchanged.","The second blit operation is a colorkey=55535 with the TMP memory buffer as the source and a copy operation to the NCP register as the destination. Because the value of the TMP memory buffer, 10000, does not equal to the colorkey value, the blit engine copies the value of the TMP memory buffer to the NCP register. The result is that the NCP register has a value of 10000, and the object will not be rendered.","In another example, conditional rendering can be further optimized using a pattern copy command. With a pattern copy command, the blit engine copies a pattern to a destination when the colorkey value does not match the source value. In this example, the NCP register is initialized to a large value, such as 10000, that is greater than the depth of the object being evaluated. A pattern copy command from the RPC register to the NCP register with a colorkey value of 0 and a pattern value of 1 is then performed. In this example, the pattern value is selected to be the desired near clip plane value for rendering the object. If the RPC register equals 0, matching the colorkey value, nothing is copied to the NCP register. Thus, the NCP register remains set to 10000 and the object is not rendered. Conversely, if the RPC register does not equal 0, the colorkey value is not matched and the blit engine copies the pattern value, 1, to the NCP register. Because the NCP register now equals 1, the object is rendered.","This alternate example has the advantage of only requiring a single blit operation, as opposed to the two blit operations of the previous example application. However, the pattern value, which is used to set the NCP register, must be known at the time the CPU writes the commands into the command buffer. This requires that the CPU knows the desired near clip plane distance in advance. In some situations, this is not possible and the previous example application must be used instead.","This invention provides a very efficient way to reprogram the GPU without the help of the CPU. These self programming commands, correctly interleaved with rendering sets, increase the overall performance of the graphics rendering by enabling new rendering techniques and optimizations while consuming less system resources. Although the invention has been discussed with respect to specific examples and embodiments thereof, these are merely illustrative, and not restrictive, of the invention. For instance, though the invention is discussed with reference to three example applications of a self-programming GPU, the invention is applicable to any GPU operation requiring one or more changes in control register values. Thus, the scope of the invention is to be determined solely by the claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The invention will be described with reference to the drawings, in which:",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIGS. 2A and 2B"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
