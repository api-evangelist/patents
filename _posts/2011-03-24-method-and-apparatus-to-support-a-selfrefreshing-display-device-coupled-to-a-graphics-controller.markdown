---
title: Method and apparatus to support a self-refreshing display device coupled to a graphics controller
abstract: A method and apparatus for supporting a self-refreshing display device coupled to a graphics controller are disclosed. A self-refreshing display device has a capability to drive the display based on video signals generated from a local frame buffer. A graphics controller coupled to the display device may optimally be placed in one or more power saving states when the display device is operating in a panel self-refresh mode. Data objects stored in a memory associated with the graphics controller may be aliased in another memory subsystem accessible to the operating system, graphical user interface, or applications executing in the system while the graphics controller is in a deep sleep state. The disclosed technique utilizes a virtual memory pointer, that may be updated in one or more virtual memory page tables to point to either the memory associated with the graphics controller or an alternate memory alias.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08732496&OS=08732496&RS=08732496
owner: NVIDIA Corporation
number: 08732496
owner_city: Santa Clara
owner_country: US
publication_date: 20110324
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","System Overview","Accessing Data Objects in Panel Self-Refresh Mode"],"p":["1. Field of the Invention","The invention relates generally to display systems and, more specifically, to a method and apparatus to support a self-refreshing display device coupled to a graphics controller.","2. Description of the Related Art","Computer systems typically include some sort of display device, such as a liquid crystal display (LCD) device, coupled to a graphics controller. During normal operation, the graphics controller generates video signals that are transmitted to the display device by scanning-out pixel data from a frame buffer based on timing information generated within the graphics controller. Some recently designed display devices have a self-refresh capability, where the display device includes a local controller configured to generate video signals from a static, cached frame of digital video independently from the graphics controller. When in such a self-refresh mode, the video signals are driven by the local controller, thereby allowing portions of the graphics controller to be turned off to reduce the overall power consumption of the computer system. Once in self-refresh mode, when the image to be displayed needs to be updated, control may be transitioned back to the graphics controller to allow new video signals to be generated based on a new set of pixel data.","One drawback to shutting down portions of the graphics controller is that the operating system or applications running on the host computer system may be configured to access data objects stored in a memory associated with the graphics controller. If the graphics controller is switched off, such as when the display device is operating in a self-refresh mode, the operating system or applications may lose access to the objects stored in the graphics memory. This may cause the operating system or applications to crash.","As the foregoing illustrates, what is needed in the art is an improved technique for providing access to data object stored in a memory associated with a graphics controller.","One embodiment of the present invention sets forth a method for controlling a graphics processing unit coupled to a self-refreshing display device. The method includes the steps of detecting a trigger event that indicates that the display device is set to enter a self-refresh mode and, in response to detecting the trigger event, determining whether any mutual exclusion mechanisms in a set of mutual exclusion mechanisms is bound to a data object stored in a memory associated with the graphics processing unit. The method also includes the steps of, if at least one mutual exclusion mechanism is bound to a data object, then delaying transition into a deep sleep state or, if no mutual exclusion mechanisms are bound to a data object, then entering the deep sleep state.","One advantage of the disclosed technique is that the physical storage locations of the data objects are transparent to an operating system or applications executing on the host computer system. A pointer that identifies the physical storage location is the same for the applications whether the data object resides in the graphics memory or the system memory. Furthermore, the state of the data object may be tracked while the graphics controller is switched off to determine whether the graphics controller needs to update the data object in the graphics memory once the graphics controller is woken up and resumes processing graphics data to generate video signals for display on the display device. Consequently, the transition into and out of a self-refresh mode is transparent to an operating system and application that are configured to access the data objects.","In the following description, numerous specific details are set forth to provide a more thorough understanding of the invention. However, it will be apparent to one of skill in the art that the invention may be practiced without one or more of these specific details. In other instances, well-known features have not been described in order to avoid obscuring the invention.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 1","FIG. 1"],"b":["100","100","102","104","105","105","106","107","107","108","102","106","105","112","105","113","112","110","103","113","112","110","114","107","116","107","118","120","121","107"]},"In one embodiment, the parallel processing subsystem  incorporates circuitry optimized for graphics and video processing, including, for example, video output circuitry, and constitutes a graphics processing unit (GPU). In another embodiment, the parallel processing subsystem  incorporates circuitry optimized for general purpose processing, while preserving the underlying computational architecture, described in greater detail herein. In yet another embodiment, the parallel processing subsystem  may be integrated with one or more other system elements, such as the memory bridge , CPU , and I\/O bridge  to form a system on chip (SoC).","It will be appreciated that the system shown herein is illustrative and that variations and modifications are possible. The connection topology, including the number and arrangement of bridges, the number of CPUs , and the number of parallel processing subsystems , may be modified as desired. For instance, in some embodiments, system memory  is connected to CPU  directly rather than through a bridge, and other devices communicate with system memory  via memory bridge  and CPU . In other alternative topologies, parallel processing subsystem  is connected to I\/O bridge  or directly to CPU , rather than to memory bridge . In still other embodiments, I\/O bridge  and memory bridge  might be integrated into a single chip. Large embodiments may include two or more CPUs  and two or more parallel processing systems . The particular components shown herein are optional; for instance, any number of add-in cards or peripheral devices might be supported. In some embodiments, switch  is eliminated, and network adapter  and add-in cards ,  connect directly to I\/O bridge .",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 2A","b":["112","110","112","240","242","242","244","0","244","1","244","112","112","244","110","280","280"]},"GPU  may be configured to receive graphics primitives from CPU  via communications path , such as a PCIe bus. GPU  processes the graphics primitives to produce a frame of pixel data for display on display device  and stores the frame of pixel data in frame buffers . In normal operation, GPU  is configured to scan out pixel data from frame buffers  to generate video signals for display on display device . In one embodiment, GPU  is configured to generate a digital video signal and transmit the digital video signal to display device  via a digital video interface such as an LVDS, DVI, HDMI, or DisplayPort (DP) interface. In another embodiment, GPU  may be configured to generate an analog video signal and transmit the analog video signal to display device  via an analog video interface such as a VGA or DVI-A interface. In embodiments where communications path  implements an analog video interface, display device  may convert the received analog video signal into a digital video signal by sampling the analog video signal with one or more analog to digital converters.","As also shown in , display device  includes a timing controller (TCON) , self-refresh controller (SRC) , a liquid crystal display (LCD) device , one or more column drivers , one or more row drivers , and one or more local frame buffers (), () . . . (M\u22121), where M is the total number of local frame buffers implemented in display device . TCON  generates video timing signals for driving LCD device  via the column drivers  and row drivers . Column drivers , row drivers  and LCD device  may be any conventional column drivers, row drivers, and LCD device known in the art. As also shown, TCON  may transmit pixel data to column drivers  and row drivers  via a communication interface, such as a mini LVDS interface.","SRC  is configured to generate video signals for display on LCD device  based on pixel data stored in local frame buffers . In normal operation, display device  drives LCD device  based on the video signals received from parallel processing subsystem  over communications path . In contrast, when display device  is operating in a panel self-refresh mode, display device  drives LCD device  based on the video signals received from SRC .","GPU  may be configured to manage the transition of display device  into and out of a panel self-refresh mode. Ideally, the overall power consumption of computer system  may be reduced by operating display device  in a panel self-refresh mode during periods of graphical inactivity in the image displayed by display device . In one embodiment, to cause display device  to enter a panel self-refresh mode, GPU  may transmit a message to display device  using an in-band signaling method, such as by embedding a message in the digital video signals transmitted over communications path . In alternative embodiments, GPU  may transmit the message using a side-band signaling method, such as by transmitting the message using an auxiliary communications channel. Various signaling methods for signaling display device  to enter or exit a panel self-refresh mode are described below in conjunction with .","Returning now to , after receiving the message to enter the self-refresh mode, display device  caches the next frame of pixel data received over communications path  in local frame buffers . Display device  transitions control for driving LCD device  from the video signals generated by GPU  to video signals generated by SRC  based on the pixel data stored in local frame buffers . While the display device  is in the panel self-refresh mode, SRC  continuously generates repeating video signals representing the cached pixel data stored in local frame buffers  for one or more consecutive video frames.","In order to cause display device  to exit the panel self-refresh mode, GPU  may transmit a similar message to display device  using a similar method as that described above in connection with causing display device  to enter the panel self-refresh mode. After receiving the message to exit the panel self-refresh mode, display device  may be configured to ensure that the pixel locations associated with the video signals generated by GPU  are aligned with the pixel locations associated with the video signals generated by SRC  currently being used to drive LCD device  in the panel self-refresh mode. Once the pixel locations are aligned, display device may transition control for driving LCD device  from the video signals generated by SRC  to the video signals generated by GPU .","The amount of storage required to implement a self-refresh capability may be dependent on the size of the uncompressed frame of video used to continuously refresh the image on the display device . In one embodiment, display device  includes a single local frame buffer () that is sized to accommodate an uncompressed frame of pixel data for display on LCD device . The size of frame buffer () may be based on the minimum number of bytes required to store an uncompressed frame of pixel data for display on. LCD device , calculated as the result of multiplying the width by the height by the color depth of the native resolution of LCD device . For example, frame buffer () could be sized for an LCD device  configured with a WUXGA resolution (1920\u00d71200 pixels) and a color depth of 24 bits per pixel (bpp). In this case, the amount of storage in local frame buffer () available for self-refresh pixel data caching should be at least 6750 kB of addressable memory (1920*1200*24 bpp; where 1 kilobyte is equal to 1024 or 2bytes).","In another embodiment, local frame buffer () may be of a size that is less than the number of bytes required to store an uncompressed frame of pixel data for display on LCD device . In such a case, the uncompressed frame of pixel data may be compressed by SRC , such as by run length encoding the uncompressed pixel data, and stored in frame buffer () as compressed pixel data. In such embodiments, SRC  may be configured to decode the compressed pixel data before generating the video signals used to drive LCD device . In yet other embodiments, GPU  may compress the frame of pixel data prior to encoding the compressed pixel data in the digital video signals transmitted to display device . For example, GPU  may be configured to encode the pixel data using an MPEG-2 format. In such embodiments, SRC  may store the compressed pixel data in local frame buffer () in the compressed format and decode the compressed pixel data before generating the video signals used to drive LCD device .","Display device  may be capable of displaying 3D video data, such as stereoscopic video data. Stereoscopic video data includes a left view and a right view of uncompressed pixel data for each frame of 3D video. Each view corresponds to a different camera position of the same scene captured approximately simultaneously. Some display devices are capable of displaying three or more views simultaneously, such as in some types of auto-stereoscopic displays.","In one embodiment, display device  may include a self-refresh capability in connection with stereoscopic video data. Each frame of stereoscopic video data includes two uncompressed frames of pixel data for display on LCD device . Each of the uncompressed frames of pixel data may be comprised of pixel data at the full resolution and color depth of LCD device . In such embodiments, local frame buffer () may be sized to hold one frame of stereoscopic video data. For example, to store uncompressed stereoscopic video data at WUXGA resolution and 24 bpp color depth, the size of local frame buffer () should be at least 13500 kB of addressable memory (2*1920*1200*24 bpp). Alternatively, local frame buffers  may include two frame buffers () and (), each sized to store a single view of uncompressed pixel data for display on LCD device .","In yet other embodiments, SRC  may be configured to compress the stereoscopic video data and store the compressed stereoscopic video data in local frame buffers . For example, SRC  may compress the stereoscopic video data using Multiview Video Coding (MVC) as specified in the H.264\/MPEG-4 AVC video compression standard. Alternatively, GPU  may compress the stereoscopic video data prior to encoding the compressed video data in the digital video signals for transmission to display device .","In one embodiment, display device  may include a dithering capability. Dithering allows display device  to display more perceived colors than the hardware of LCD device  is capable of displaying. Temporal dithering alternates the color of a pixel rapidly between two approximate colors in the available color palette of LCD device  such that the pixel is perceived as a different color not included in the available color palette of LCD device . For example, by alternating a pixel rapidly between white and black, a viewer may perceive the color gray. In a normal operating state, GPU  may be configured to alternate pixel data in successive frames of video such that the perceived colors in the image displayed by display device  are outside of the available color palette of LCD device . In a self-refresh mode, display device  may be configured to cache two successive frames of pixel data in local frame buffers . Then, SRC  may be configured to scan out the two frames of pixel data from local frame buffers  in an alternating fashion to generate the video signals for display on LCD device .",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 2B","b":["280","280","240","110","240","244","240"]},"The panel enable signal VDD may be connected from GPU to the display device  to turn on power in display device . The backlight enable and backlight pwm signals control the intensity of the backlight in display device  during normal operation. However, when the display device  is operating in a panel self-refresh mode, control for these signals must be handled by TCON  and may be changed by SRC  via control signals received over the auxiliary communication channel (Aux). One of skill in the art will recognize that the intensity of the backlight may be controlled by pulse width modulating a signal via the backlight pwm signal (Backlight_PWM). In some embodiments, communications path  may also include a frame lock signal (FRAME_LOCK) that indicates a vertical sync in the video signals generated by SRC . The FRAME_LOCK signal may be used to resynchronize the video signals generated by GPU  with the video signals generated by SRC .","The hot-plug detect signal, HPD, may be a signal connected from the display device  to GPU  for detecting a hot-plug event or for communicating an interrupt request from display device  to GPU . To indicate a hot-plug event, display device drives HPD high to indicate that a display device has been connected to communications path . After display device is connected to communications path , display device  may signal an interrupt request by quickly pulsing the HPD signal low for between 0.5 and 1 millisecond.","The auxiliary channel, Aux, is a low bandwidth, bidirectional half-duplex data communication channel used for transmitting command and control signals from GPU  to display device  as well as from display device  to GPU . In one embodiment, messages indicating that display device  should enter or exit a panel self-refresh mode may be communicated over the auxiliary channel. On the auxiliary channel, GPU  is a master device and display device  is a slave device. In such a configuration, data or messages may be sent from display device  to GPU  using the following technique. First, display device  indicates to GPU  that display device  would like to send traffic over the auxiliary channel by initiating an interrupt request over the hot-plug detect signal, HPD. When GPU  detects an interrupt request, GPU  sends a transaction request message to display device . Once display device  receives the transaction request message, display device  then responds with an acknowledgement message. Once GPU  receives the acknowledgement message, GPU  may read one or more register values in display device  to retrieve the data or messages over the auxiliary channel.","It will be appreciated by those of skill in the art that communications path  may implement a different video interface for transmitting video signals between GPU  and display device . For example, communications path  may implement a high definition multimedia interface (HDMI) or a low voltage differential signal (LVDS) video interface such as open-LDI. The scope of the invention is not limited to an Embedded DisplayPort video interface.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 2C","b":["250","240","280","250","251","252","253","254","240","110","280","255"]},"The format of digital video signals  enables secondary data packets to be inserted directly into the digital video signals  transmitted to display device . In one embodiment, the secondary data packets may include messages sent from GPU  to display device  that request display device  to enter or exit a panel self-refresh mode. Such secondary data packets enable one or more aspects of the invention to be realized over the existing physical layer of the eDP interface. It will be appreciated that this form of in-line signaling may be implemented in other packet based video interfaces and is not limited to embodiments implementing an eDP interface.","Secondary data packets may be inserted into digital video signals  during the vertical or horizontal blanking periods of the video frame represented by digital video signals . As shown in , digital video signals  are packed one horizontal line of pixel data at a time. For each horizontal line of pixel data, the digital video signals  include a blanking start (BS) framing symbol during a first link clock cycle () and a corresponding blanking end (BE) framing symbol during a subsequent link clock cycle (). The portion of digital video signals  between the BS symbol at link symbol clock cycle () and the BE symbol at link symbol clock cycle () corresponds to the horizontal blanking period.","Control symbols and secondary data packets may be inserted into digital video signals  during the horizontal blanking period. For example, a VB-ID symbol is inserted in the first link symbol clock cycle () after the BS symbol. The VB-ID symbol provides display device  with information such as whether the main video stream is in the vertical blanking period or the vertical display period, whether the main video stream is interlaced or progressive scan, and whether the main video stream is in the even field or odd field for interlaced video. Immediately following the VB-ID symbol, a video time stamp (Mvid7:0) and an audio time stamp (Maud7:0) are inserted at link symbol clock cycles () and (), respectively. Dummy symbols may be inserted during the remainder of the link symbol clock cycles () during the horizontal blanking period. Dummy symbols may be a special reserved symbol indicating that the data in that lane during that link symbol clock cycle is dummy data. Link symbol clock cycles () may have a duration of a number of link symbol clock cycles such that the frame rate of digital video signals  over communications path  is equal to the refresh rate of display device .","A secondary data packet may be inserted into digital video signals  by replacing a plurality of dummy symbols during link symbol clock cycles () with the secondary data packet. A secondary data packet is framed by the special secondary start (SS) and secondary end (SE) framing symbols. Secondary data packets may include an audio data packet, link configuration information, or a message requesting display device  to enter or exit a panel self-refresh mode.","The BE framing symbol is inserted in digital video signals  to indicate the start of active pixel data for a horizontal line of the current video frame. As shown, pixel data P . . . PN has a RGB format with a per channel bit depth (bpc) of 8-bits. Pixel data P associated with the first pixel of the horizontal line of video is packed into the first lane  at link symbol clock cycles () through () immediately following the BE symbol. A first portion of pixel data P associated with the red color channel is inserted into the first lane  at link symbol clock cycle (), a second portion of pixel data P associated with the green color channel is inserted into the first lane  at link symbol clock cycle (), and a third portion of pixel data P associated with the blue color channel is inserted into the first lane  at link symbol clock cycle (). Pixel data P associated with the second pixel of the horizontal line of video is packed into the second lane  at link symbol clock cycles () through (), pixel data P associated with the third pixel of the horizontal line of video is packed into the third lane  at link symbol clock cycles () through (), and pixel data P associated with the fourth pixel of the horizontal line of video is packed into the fourth lane  at link symbol clock cycles () through (). Subsequent pixel data of the horizontal line of video are inserted into the lanes - in a similar fashion to pixel data P through P. In the last link symbol clock cycle to include valid pixel data, any unfilled lanes may be padded with zeros. As shown, the third lane  and the fourth lane  are padded with zeros at link symbol clock cycle ().","The sequence of data described above repeats for each horizontal line of pixel data in the frame of video, starting with the top most horizontal line of pixel data. A frame of video may include a number of horizontal lines at the top of the frame that do not include active pixel data for display on display device . These horizontal lines comprise the vertical blanking period and may be indicated in digital video signals  by setting a bit in the VB-ID control symbol.",{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 2D","FIG. 2C","FIG. 2D"],"b":["260","250","260","250","250","265","00","265","04","240","265","01","260","260","265","02","0","260","251","254","250","240","265","03"]},"In one embodiment, the secondary data packet  may include a header and data indicating that the display device  should enter or exit a self-refresh mode. For example, the secondary data packet  may include a reserved header code that indicates that the packet is a panel self-refresh packet. The secondary data packet may also include data that indicates whether display device  should enter or exit a panel self-refresh mode.","As described above, GPU  may send messages to display device  via an in-band signaling method, using the existing communications channel for transmitting digital video signals  to display device . In alternative embodiments, GPU  may send messages to display device  via a side-band method, such as by using the auxiliary communications channel in communications path . In yet other embodiments, a dedicated communications path, such as an additional cable, may be included to provide signaling to display device  to enter or exit the panel self-refresh mode.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 3","b":["112","100","100","310","320","330","340","310","102","100","310","102","240","340","240","102","310","240","310","340"]},"Computer system  may also include multiple display devices  such as an internal display panel () and one or more external display panels () , , , (N). Each of the one or more display devices  may be connected to GPU  via communication paths () . . . (N). In one embodiment, each of the HPD signals included in communication paths  are also connected to EC . When one or more display devices  are operating in a panel self-refresh mode, EC  may be responsible for monitoring HPD and waking-up GPU  if EC  detects a hot-plug event or an interrupt request from one of the display devices .","In one embodiment, a FRAME_LOCK signal is included between internal display device () and GPU . FRAME_LOCK passes a synchronization signal from the display device () to GPU . For example, GPU  may synchronize video signals generated from pixel data in frame buffers  with the FRAME_LOCK signal. FRAME_LOCK may indicate the start of the active frame such as by passing the vertical sync signal used by TCON  to drive LCD device  to GPU .","EC  transmits the GPU_PWR and FB_PWR signals to voltage regulators that provide a supply voltage to the GPU  and frame buffers , respectively. EC  also transmits the WARMBOOT, SELF_REF and RESET signals to GPU  and receives a GPUEVENT signal from GPU . Finally, EC  may communicate with GPU  via an I2C or SMBus data bus. The functionality of these signals is described below.","The GPU_PWR signal controls the voltage regulator that provides GPU  with a supply voltage. When display device  enters a self-refresh mode, an operating system executing on CPU  may instruct EC  to kill power to GPU  by making a call to driver . Driver  will then drive the GPU_PWR signal low to kill power to GPU  to reduce the overall power consumption of computer system . Similarly, the FB_PWR signal controls the voltage regulator that provides frame buffers  with a supply voltage. When display device  enters the self-refresh mode, computer system  may also kill power to frame buffers  in order to further reduce overall power consumption of computer system . The FB_PWR signal is controlled in a similar manner to the GPU_PWR signal. The RESET signal may be asserted during wake-up of the GPU  to hold GPU  in a reset state while the voltage regulators that provide power to GPU  and frame buffers  are allowed to stabilize.","The WARMBOOT signal is asserted by EC  to indicate that GPU  should restore an operating state from SPI flash device  instead of performing a full, cold-boot sequence. In one embodiment, when display device  enters a panel self-refresh mode, GPU  may be configured to save a current state in SPI flash device  before GPU  is powered down. GPU  may then restore an operating state by loading the saved state information from SPI flash device  upon waking-up. Loading the saved state information reduces the time required to wake-up GPU  relative to performing a full, cold-boot sequence. Reducing the time required to wake-up GPU  is advantageous during high frequency entry and exit into a panel self-refresh mode.","The SELF_REF signal is asserted by EC  when display device  is operating in a panel self-refresh mode. The SELF_REF signal indicates to GPU  that display device  is currently operating in a panel self-refresh mode and that communications path  should be isolated to prevent transients from disrupting the data stored in local frame buffers . In one embodiment, GPU  may connect communications path  to ground through weak, pull-down resistors when the SELF_REF signal is asserted.","The GPUEVENT signal allows the GPU  to indicate to CPU  that an event has occurred, even when the PCIe bus is off. GPU  may assert the GPUEVENT to alert system EC  to configure the I2C\/SMBUS to enable communication between the GPU  and the system EC . The I2C\/SMBUS is a bidirectional communication bus configured as an I2C, SMBUS, or other bidirectional communication bus to enable GPU  and system EC  to communicate. In one embodiment, the PCIe bus may be shut down when display device  is operating in a panel self-refresh mode. The operating system may notify GPU  of events, such as cursor updates or a screen refresh, through system EC  even when the PCIe bus is shut down.",{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 4","b":["400","110","110","410","410","240","210","216","240","110","280","240","110","110","420"]},"In the wake-up frame buffer state , display device  wakes-up the local frame buffers . If display device  cannot initialize the local frame buffers , then display device  may send an interrupt request to GPU  indicating that the display device  has failed to enter the panel self-refresh mode and display device  returns to normal state . In one embodiment, display device  may be required to initialize the local frame buffers  before the next frame of video is received over communications path  (i.e., before the next rising edge of the VSync signal generated by GPU ). Once display device  has completed initializing local frame buffers , display device  transitions to a cache frame state .","In the cache frame state , display device  waits for the next falling edge of the VSync signal generated by GPU  to begin caching one or more frames of video in local frame buffers . In one embodiment, GPU  may indicate how many consecutive frames of video to store in local frame buffers  by writing a value to a control register in display device . After display device has stored the one or more frames of video in local frame buffers , display device  transitions to a self-refresh state .","In the self-refresh state , the display device  enters a panel self-refresh mode where TCON  drives the LCD device  with video signals generated by SRC  based on pixel data stored in local frame buffers . Display device  stops driving the LCD device  based on the video signals generated by GPU . Consequently, GPU  and communications path  may be placed in a power saving mode to reduce the overall power consumption of computer system . While in the self-refresh state , display device  may monitor communications path  to detect a request from GPU  to exit the panel self-refresh mode. If display device  receives a panel self-refresh exit request, then display device  transitions to a re-sync state .","In the re-sync state , display device  attempts to re-synchronize the video signals generated by GPU  with the video signals generated by SRC . Various techniques for re-synchronizing the video signals are described below in conjunction with  and -. When display device  has completed re-synchronizing the video signals, then display device  transitions back to a normal state . In one embodiment, display device  will cause the local frame buffers  to transition into a local frame buffer sleep state , where power supplied to the local frame buffers  is turned off.","In one embodiment, display device  may be configured to quickly exit wake-up frame buffer state  and cache frame state  if display device  receives an exit panel self-refresh exit request. In both of these states, display device  is still synchronized with the video signals generated by GPU . Thus, display device  may transition quickly back to normal state  without entering re-sync state . Once display device  is in self-refresh state , display device  is required to enter re-sync state  before returning to normal state .",{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 5","b":["500","240","110","240","510","240","110","244","240","244","240","244","244","240","244","240","244","240","240","520"]},"In the deep-idle state , GPU  still generates video signals for display on display device . However, GPU  operates in a power saving mode, such as by clock-gating or power-gating certain processing portions of GPU  while keeping the portions of GPU  responsible for generating the video signals active. Additionally, GPU  may send a message to display device  requesting display device  to drive LCD device  at a lower refresh rate. For example, GPU  may request display device  to reduce the refresh rate from 75 Hz to 30 Hz, and GPU  may generate and transmit video signals based on the lower refresh rate. While operating in deep-idle state , GPU  may continue to monitor pixel data in frame buffers  for graphical activity. If GPU  detects graphical activity, GPU  transitions back to normal state . Returning to deep-idle state , GPU  may continue to increment the counter to determine the number of consecutive frames of video without any graphical activity. If the counter reaches a second threshold value, that is greater than the first threshold value, then GPU  transitions to a panel self-refresh state .","In some embodiments, the state diagram  does not include the deep-idle state . In such embodiments, GPU  may transition directly from the normal state  to the panel self-refresh state  when the counter reaches the second threshold value. In yet other embodiments, EC , graphics driver , or some other dedicated monitoring unit, may perform the monitoring of the pixel data in frame buffers  and send a message to GPU  over the I2C\/SMBUS indicating that one of the progressive levels of idleness has been detected.","In the panel self-refresh state , GPU  transmits the one or more video frames for display during the panel self-refresh mode to display device . GPU  may monitor communications path  to detect a failure by display device  in entering self-refresh mode. In one embodiment, GPU  monitors the HPD signal to detect an interrupt request issued by display device . If GPU  detects an interrupt request from display device , then GPU  may configure the Auxiliary channel of communications path  to receive communications from display device . If display device  indicates that entry into self-refresh mode did not succeed, then GPU  may transition back to normal state . Otherwise, GPU  transitions to a deeper-idle state . In another embodiment, GPU  may override the transition into the deeper idle state  and transition directly into GPU power off state . In such embodiments, the GPU  will be completely shut down whenever display device  enters a panel self-refresh mode.","In the deeper-idle state , GPU  may be placed in a sleep state and the transmitter side of communications path  may be shut down. Portions of GPU  may be clock-gated or power-gated in order to reduce the overall power consumption of computer system . Display device  is responsible for refreshing the image displayed by display device . In one embodiment, GPU  may continue to monitor the pixel data in frame buffers  to detect a third level of idleness. For example, GPU  may continue to increment a counter for each frame of video where GPU  fails to update the pixel data in frame buffers . If GPU  detects graphical activity, such as by receiving a signal from EC  over the I2C\/SMBUS or from graphics driver  over the PCIe bus, then GPU  transitions to the re-sync state . In contrast, if GPU  detects a third level of idleness in the pixel data, then GPU  transitions to a GPU power-off state .","In the GPU power-off state , EC  shuts down GPU  by turning off the voltage regulator supplying power to GPU . EC  may drive the GPU_PWR signal low to shut down the voltage regulator supplying GPU . In one embodiment, GPU  may save the current operating context in SPI flash device  in order to perform a warm-boot sequence on wake-up. In GPU power off state , a voltage regulator supplying power to graphics memory  may also be turned off. EC  may drive the FB_PWR signal low to shut down the voltage regulator supplying graphics memory .","When GPU  is in either the deeper-idle state  or the GPU power-off state , GPU  may be instructed to wake-up by EC  to update the image being displayed on display device . For example, a user of computer system  may begin typing into an application that requires GPU  to update the image displayed on the display device. In one embodiment, driver  may instruct EC  to assert the GPU_PWR and FB_PWR signals to turn on the voltage regulators supplying GPU  and frame buffers . When GPU  is turned on, GPU  will perform a boot sequence based on the status of the WARMBOOT signal and the RESET signal. If EC  asserts the WARM_BOOT signal, then GPU  may load a stored context from the SPI flash device . Otherwise GPU  may perform a cold-boot sequence. GPU  may also configure the transmitter side of communications path  based on information stored in SPI flash device . After GPU  has performed the boot sequence, GPU  may send a panel self-refresh exit request to display device . GPU  then transitions to a re-sync state .","In the re-sync state , GPU  begins generating video signals based on pixel data stored in frame buffers . The video signals are transmitted to display device  over communications path  and display device  attempts to re-synchronize the video signals generated by GPU  with the video signals generated by SRC . After re-synchronizing the video signals is complete, GPU  transitions back to the normal state .",{"@attributes":{"id":"p-0076","num":"0075"},"figref":["FIG. 6","FIG. 1"],"b":["100","104","103","612","614","624","616","618","612","100","612","614","102","614","240","240","614","103","103","240","240","240","240","110"]},"As also shown, frame buffers  includes data objects , which may include one or more data objects (i.e., data structures) generated by GPU  during execution of a shader program. Application  may include one or more shader program instructions that cause GPU  to generate a data object in frame buffers . The data object may be stored in data objects . In one embodiment, operating system  or application  may be configured to access data objects  to read values from the resulting data as calculated by GPU  during execution of the shader program. It will be appreciated that more than one application executing on CPU  (or multiple threads of the same application) may request access to data objects  simultaneously. In one embodiment, computer system  may be configured to ensure that two applications or threads do not access a data object simultaneously.","In order to guarantee data coherency for data objects , operating system  may implement a mutual exclusion algorithm that prevents multiple applications or threads from accessing the same data object in data objects  simultaneously. In one embodiment, locks  includes one or more locks that are associated with a corresponding data object in data objects . A lock may be a single bit that is tested to determine if the data object is free, and the lock may be set by an application during the same instruction cycle in order for the application to access the data object. For example, when GPU  allocates memory in data objects  for a new data object, GPU  may also allocate a corresponding lock object (such as a bit) in locks  that is associated with the new data object. When an application  attempts to access a data object in data objects , GPU  may test the lock bit in locks  associated with the data object. If the associated lock bit is set, then the application  must wait until the owner application or thread releases the lock by clearing the lock bit. Once the lock has been released (i.e., the bit is cleared by the owner application or thread), then the application  can acquire the lock and access the associated data object in data objects . In alternative embodiments, other mutual exclusion algorithms may be implemented by operating system  to ensure mutual exclusive access to a data object. For example, possible mutual exclusion mechanisms may include access control locks, binary semaphores, atomic operations, or monitors (modules or methods that may be accessed by only a single thread at any point in time).","In one embodiment, locks  may also ensure that the data objects in data objects  are in a pre-defined format suitable for use by operating system  or application . In one embodiment, GPU  may temporarily store the data object in frame buffers  in a format that is efficient for processing by GPU . However, that format may be unsuitable for use by operating system  or application . For example, GPU  may store data objects in a compressed format to minimize latency in memory interface operations between GPU  and memory . However, CPU  may not be able to decode the compressed format. Therefore, when an application  attempts to acquire a lock on a particular data object, GPU  may cause the data object to be reformatted in the predefined format. In this manner, GPU  ensures that operating system  or application  receives a properly formatted data object.","In one embodiment, operating system  generates one or more page tables  in system memory . Page tables  allow the operating system  to map an address space in virtual memory to an address space in the physical memory such as an actual DRAM module coupled to CPU . Operating system  may generate a single page table for every process executing on CPU  or, alternatively, a separate page table associated with each currently executing process. CPU  may include a memory management unit (not shown) that includes a translation lookaside buffer (TLB) that caches recently used page table entries. When an application  or thread attempts to read a memory address in the virtual memory address space, the virtual address is transmitted to the memory management unit of CPU . If the virtual address matches a cached entry in the TLB, then the memory management unit returns an address in the physical memory associated with the virtual address. If the virtual address has no corresponding entry in the TLB, then CPU  walks through the page table entries in one or more page tables of page tables . If the virtual address matches a page table entry in page tables , then CPU  returns the corresponding address in physical memory listed in the page table entry. However, if the virtual address does not match a page table entry in page tables , then CPU  generates a page fault, that indicates that data associated with the virtual address is not currently loaded into system memory , and operating system  may load the data from a backing store such as system disk . The operating system  conventionally implements a page fault exception handler or software configured to execute whenever a page fault occurs.","In one embodiment, GPU  generates data objects in frame buffers  and transmits a handle to the new data object to graphics driver . Operating system  then generates a pointer to an address in the virtual memory address space that is associated with the data object. An entry is also created in a page table in page tables  that matches the address in the virtual memory address space to the physical address of the data object in memory . Thus, the pointer indirectly points to the data object in memory .","In order to access the data object, application  may acquire a lock associated with the data object. Once the associated lock is acquired, application  may attempt to read the data at the virtual address included in the pointer. The memory management unit in CPU  resolves the virtual address into a physical address as set forth above. The resolved physical address will point to the location in memory  associated with the data object. Recognizing that the address is located in memory , operating system  causes graphics driver  to transmit an instruction to GPU  via memory bridge  to read the values stored in the location indicated by the resolved address. GPU  receives the microcode instruction generated by graphics driver  and resolves the instruction in memory management unit (MMU)  included in GPU . MMU  transmits a control signal via the memory interface connecting GPU  to memory  to retrieve the requested data and then transmits the data to application  via graphics driver .","In other embodiments, the memory address space for memory  may also be virtualized. In such embodiments, GPU  may maintain one or more additional page tables (not shown) in memory  for implementing a virtual address space in a similar manner to that described above in connection with CPU  and system memory . Such a virtualized address space may be more efficient when more than one RAM unit is connected to GPU .","When display device  is operating in a panel self-refresh mode, GPU  and memory  may frequently be switched off. Thus, any attempts by operating system  or application  to access data objects  will fail. Ideally, GPU  will be prevented from entering a deep sleep state when one or more locks are presently acquired on data objects in data objects . In one embodiment, GPU  is configured to check locks  to determine whether there are any currently pending accesses to data objects . If any locks are set, then GPU  may delay entering the deep sleep state until no locks corresponding to data objects  are presently acquired. One of ordinary skill in the art would readily recognize that a currently acquired lock may indicate that operating system  or application  may attempt to read data from memory  sometime in the near future. Thus, GPU  should not enter a deep sleep state until all pending requests are complete.","In another embodiment, GPU  may be configured to cache one or more data objects from data objects  in system memory . For example, for each lock in locks  that is currently acquired by operating system  or application , GPU  may be configured to cause a copy of the corresponding data object in data objects  to be cached in system memory . Data object cache  includes one or more cached data objects that correspond to currently acquired locks in locks . GPU  may then cause page table entries corresponding to the pointers associated with the cached data objects to be updated to point to the cached versions of the data objects in data object cache . Consequently, when the memory management unit of CPU  resolves a virtual address for a cached data object, the resolved address will point to system memory  and not memory . Once all data objects have been cached and page table entries updated, GPU  may then cause display device  to enter the panel self-refresh state and GPU  may enter a deep sleep state such as GPU power off state .","In yet another embodiment, GPU  may be configured to cache data objects in system memory  even when a lock is not currently acquired on the data object. For example, GPU  may cache any data objects which have a high probability of being accessed by operating system  or application  while the GPU is in a deep sleep state. GPU  may be configured to always cache a primary surface that includes the visible pixel data being displayed on display device . On common function in the Windows operating system is the print-screen function that reads the pixel data contained in the primary surface and creates a digital copy of the image being displayed on display device  in system memory . By automatically caching the primary surface to system memory , operating system  may execute a call to the print-screen function without requiring the GPU  to exit the deep sleep state.","In still other embodiments, GPU  may be configured to track whether the cached versions of the data objects in data object cache  have been modified. When GPU  causes a data object to be cached in system memory , GPU  may also generate a hash value associated with an unmodified version of the cached data object and cause the hash value to be stored in system memory . Once GPU  exits the deep sleep state, GPU  may compare the stored hash value to a calculated hash value generated from the cached data object during the present time. If the stored hash value matches the calculated hash value, then GPU  may determine that the cached data object was not modified while GPU  was in the deep sleep state. If the cached data object was not modified, GPU  may not be required to write the cached version of the data object back to memory .","Instead of updating the page table entries to map the virtual address to an address of the cached versions of the data objects, the pointers to the data objects may be replaced with a null pointer object. The null pointer object includes an invalid memory address, that when attempted to be resolved by the memory management unit in CPU , causes a page fault exception to be thrown to operating system . A page fault exception handler may then be configured to handle the page fault. In one embodiment, the page fault exception handler may be configured to cause GPU  to wake-up so that GPU  can process the request by operating system  or application  to access the data object in memory . In another embodiment, the page fault exception handler may be responsible for remapping the page table entries to point to pre-cached versions of the data objects in system memory . Because the GPU  may remain in the deep sleep state for a short amount of time, such as  ms or less, it may be inefficient to perform all of the caching and remapping of page table entries only after display device  is ready to enter a self-refresh mode. Thus, GPU  may maintain cached versions of the data objects in system memory  during normal operation. Thus, GPU  may skip transmitting the data objects to graphics driver  after display device is ready to enter the panel self-refresh mode. Instead, the pointers for the data objects may be replaced in a much faster operation, and only when the operating system  or application  attempts to access the data object will the page table entry be updated by the page fault exception handler.",{"@attributes":{"id":"p-0089","num":"0088"},"figref":"FIGS. 7A-7B","b":["100","612","710","614","612","710","102","612","710","614","240","244","240","103","614","720","240","720","722","724","726"]},"Upon receiving a pointer to a location in the graphics memory address space  at graphics driver , operating system  may update the pointer to point to an address in the virtual memory address space  instead of the graphics memory address space . Application  may access the data object using the virtual memory address space  by reading or writing to the address included in the updated pointer. As shown, operating system  updates the pointers to the three data objects to point to memory addresses , , and , respectively, in the virtual memory address space . While updating the pointers, operating system  also creates page table entries in page tables  to map memory address  in the virtual memory address space  to memory address  in the graphics memory address space , memory address  in the virtual memory address space  to memory address  in the graphics memory address space , and virtual memory address  in the virtual memory address space  to memory address  in the graphics memory address space .","Upon detecting a trigger event, such as detecting a first level of idleness in pixel data stored in frame buffers , GPU  may cause display device  to enter a panel self-refresh mode and transition into a deep sleep state. In one embodiment, GPU  determines whether operating system  or application  has acquired a lock on any data object in data objects . As shown in , application  may have acquired a lock on the second data object located at memory address  and the third data object located at memory address . Consequently, before entering the deep sleep state, GPU  is configured to cause the second and third data objects in data object cache  to be cached in system memory . GPU  transmits the second and third data objects to graphics driver , which requests operating system  to allocate memory in system memory address space  for the data objects. Operating system  may allocate a block of memory starting at memory address  to store the second data object and a block of memory starting at memory address  to store the third data object. GPU  then transmits a request to graphics driver  to update the page table entries in page tables  such that memory address  in the virtual memory address space  corresponds to memory address  in the system memory address space , and virtual memory address  in the virtual memory address space  corresponds to memory address  in the system memory address space . Application  continues to reference the second and third data objects using memory address  and , respectively. However, when the memory management unit of CPU  resolves the virtual address into a physical address, the resolved address points to the cached version of the data objects in system memory . Thus, even though the location of the cached data object is different from the location of the data object, application  uses the exact same pointer as originally provided to application  when the data object was created by GPU .",{"@attributes":{"id":"p-0092","num":"0091"},"figref":["FIG. 8","FIGS. 1"],"b":["800","614","240","240","2","2","3","6","7","7"]},"The method begins at step , where GPU  detects a trigger event that indicates that the display device is set to enter a self-refresh mode. In one embodiment, GPU  may monitor graphical activity in the pixel data stored in frame buffers . If the pixels remain static (i.e., do not change) for a threshold number of frames of digital video, then GPU  may detect a first level of idleness in the pixel data. In response to detecting the first level of idleness, the display device  may ideally be placed in a self-refresh mode and the GPU  and memory  may enter a deep sleep state in order to minimize total power consumption of computer system . At step , GPU  determines whether a mutual exclusion mechanism (i.e., a lock bit in locks ) is bound to a data object in memory . For example, GPU  determines whether operating system  or application  has acquired a lock on any data objects. If a mutual exclusion mechanism is bound to a data object, then method  proceeds to step  where GPU  causes the data objects bound to a mutual exclusion mechanism to be cached in system memory . At step , GPU  causes a page table entry in page tables  to be updated so that a pointer associated with the data object points to a virtual memory address in virtual memory address space  that corresponds to a memory address associated with the cached version of the data object. Then, method  proceeds to step .","Returning now to step , if no mutual exclusion mechanism is bound to a data object, then method  proceeds directly to step . At step , GPU  causes display device  to enter a panel self-refresh mode. In one embodiment, GPU  transmits a panel self-refresh entry request to display device  via communications path . Once display device has entered the panel self-refresh mode successfully, method  proceeds to step  where GPU  enters a deep sleep state. In one embodiment, GPU  enters GPU power off state  where the power supply for GPU  as well as memory  may be switched off. Once GPU  is in the deep sleep state, method  terminates.","In sum, the disclosed technique provides access to data objects associated with a graphics controller to one or more applications executing on the host computer system even when the graphics controller is in a deep sleep state. The graphics controller allocates memory for a data object in a memory associated with the graphics controller. A pointer to the object is passed to the host computer system, which is remapped by the host computer system into a virtual memory address space. Before a graphics controller enters a deep sleep state, the graphics controller causes a copy of the data object to be cached in system memory, and a page table entry is updated to map the virtual memory address in the pointer to an address of the cached data object in the system memory. When the graphics controller enters the deep sleep state, applications may continue to access the data objects using the virtual memory address included in the pointer.","One advantage of the disclosed technique is that the physical storage locations of the data objects are transparent to an operating system or applications executing on the host computer system. A pointer that identifies the physical storage location is the same for the applications whether the data object resides in the graphics memory or the system memory. Furthermore, the state of the data object may be tracked while the graphics controller is switched off to determine whether the graphics controller needs to update the data object in the graphics memory once the graphics controller is woken up and resumes processing graphics data to generate video signals for display on the display device. Consequently, the transition into and out of a self-refresh mode is transparent to an operating system and application that are configured to access the data objects.","While the foregoing is directed to embodiments of the invention, other and further embodiments of the invention may be devised without departing from the basic scope thereof. For example, aspects of the present invention may be implemented in hardware or software or in a combination of hardware and software. One embodiment of the invention may be implemented as a program product for use with a computer system. The program(s) of the program product define functions of the embodiments (including the methods described herein) and can be contained on a variety of computer-readable storage media. Illustrative computer-readable storage media include, but are not limited to: (i) non-writable storage media (e.g., read-only memory devices within a computer such as CD-ROM disks readable by a CD-ROM drive, flash memory, ROM chips or any type of solid-state non-volatile semiconductor memory) on which information is permanently stored; and (ii) writable storage media (e.g., floppy disks within a diskette drive or hard-disk drive or any type of solid-state random-access semiconductor memory) on which alterable information is stored. Such computer-readable storage media, when carrying computer-readable instructions that direct the functions of the present invention, are embodiments of the invention.","In view of the foregoing, the scope of the invention is determined by the claims that follow."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["So that the manner in which the above recited features of the invention can be understood in detail, a more particular description of the invention, briefly summarized above, may be had by reference to embodiments, some of which are illustrated in the appended drawings. It is to be noted, however, that the appended drawings illustrate only typical embodiments of this invention and are therefore not to be considered limiting of its scope, for the invention may admit to other equally effective embodiments.",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2C"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 2D","FIG. 2C"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6","b":"100"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIGS. 7A-7B"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
