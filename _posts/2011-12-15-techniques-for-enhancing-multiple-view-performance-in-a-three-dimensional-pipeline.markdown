---
title: Techniques for enhancing multiple view performance in a three dimensional pipeline
abstract: Techniques may be directed to enhancing multiple view performance in a three dimensional pipeline. A plurality of view transformations associated with an image may be received. The vertex data associated with the image may be received. Operation data may be determined by performing the view transformations on the compiled vertex data. A plurality of display lists may be determined through a single run of a vertex pipeline. A display list may be based on the operation data. Other embodiments are described and claimed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09196081&OS=09196081&RS=09196081
owner: INTEL CORPORATION
number: 09196081
owner_city: Santa Clara
owner_country: US
publication_date: 20111215
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","DETAILED DESCRIPTION"],"p":["Three dimensional technology plays a crucial role in the graphics development domain. Three dimensional technology is implemented in mobile devices such as smart phones, tablets and netbooks. The performance and power consumption of the three dimensional technology on the mobile devices is typically correlated to the user's visual experience and influences a product's competitive advantage.","Currently, each time an image is rendered from a different angle or view, information is sent over a three dimensional pipeline to the mobile device. Some of the information sent during each view is repetitive. For example, each time information is sent over the three dimensional pipeline, the same components are initialized and the same vertex data is sent. Reinitializing the components and resending the data negatively affects performance and power consumption. It is with respect to these and other considerations that the present improvements have been needed.","Various embodiments are directed to techniques for enhancing multiple view performance in a three dimensional pipeline. In an embodiment, a plurality of view transformations associated with an image may be received. Vertex data for the image may be received. The vertex data may be compiled. Operation data may be determined by performing the view transformations on the compiled vertex data. A plurality of display lists may be determined through a single run of a vertex pipeline. A display list may be based on the operation data.","In an embodiment, three dimensional images or objects may be rotated in a series of scenes. Different scenes may have a three dimensional image rotated with a different angle or view transformation. However, some data, such as vertex data, is the same in each view transformation. As a result, refining components within the three dimensional pipeline to generate multiple display lists with a plurality of view transformations with a single run through the vertex pipeline may enhance performance and save computing power. As a result, the embodiments can improve affordability, scalability, modularity, extendibility, or interoperability for an operator, device or network.","In particular, rendering rotating and multiple views of the three dimensional images for subsequent scenes in a single run of the vertex pipeline benefits three dimensional graphics performance. By generating multiple display lists in one vertex pipeline for rotating three dimensional graphics, duplicative efforts within the vertex pipeline may be unnecessary. Using the processes described below, the three dimensional pipeline does not have to initiate hardware states, load vertex data and allocate input and output spaces each time the same image is viewed at a different angle. In an embodiment, the number of redundant jobs for rendering multiple views of the three dimensional images between scenes may be reduced. In an embodiment, as a result of rendering multiple view transformations of the three dimensional image, duplicated direct memory access transfers may be eliminated as the vertex data is only loaded a single time from the application to the hardware device memory. The one time load of the vertex data may benefit three dimensional graphic performance and reduce computing effort. The benefit may be increased when a three dimensional image is complex and has a large number of vertexes. In an embodiment, by rendering multiple views of the three dimensional image in a single run of the vertex pipeline, the effort to initialize the vertex pipeline multiple times for the same vertex data may be eliminated. In an embodiment, by rendering multiple views of the three dimensional image in a single vertex pipeline, overall computing effort may be saved by reusing some common internal results on the computations for the multiple view transformations.","Reference is now made to the drawings, wherein like reference numerals are used to refer to like elements throughout. In the following description, for purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding thereof. It may be evident, however, that the novel embodiments can be practiced without these specific details. In other instances, well known structures and devices are shown in block diagram form in order to facilitate a description thereof. The intention is to cover all modifications, equivalents, and alternatives falling within the spirit and scope of the claimed subject matter.",{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 1","FIG. 1"],"b":["100","100","100","100","100"]},"In an embodiment, the input  may include data such as, but not limited to, vertex data. The system  may comprise a view transforming operation . In an embodiment, the view transforming operation  may occur within a graphics processing unit. The view transforming operation  may include a graphics application programming interface  and a three dimensional driver .","In an embodiment, a graphics application programming interface  may receive information from a user and send the information to the three dimensional driver . In an embodiment, a graphics application programming interface  may receive a plurality of view transformations to render an image over a plurality of scenes. In an embodiment, display lists may be determined for the view transformations. In an embodiment, the graphics application programming interface  may receive an interval period between presenting sequential display lists. The graphics application programming interface  may send the number of view transformations and the interval period to the three dimensional driver .","The three dimensional driver  may include a vertex component  and a pixel component . The vertex component  may receive, compile and process vertex data. Operation data may be determined by performing view transformations on the compiled vertex data. A plurality of display lists may be determined through a single run of the vertex pipeline. The pixel component  may use the operation data from the vertex component  to render a display list to be presented.","In an embodiment, a three dimensional driver  may include a vertex component . The vertex component  may receive a plurality of view transformations associated with an image. The vertex component  may receive vertex data for the image. The vertex component  may take the vertex data compiled from the three dimensional driver  and perform view transformations on the compiled vertex data to determine operation data. The compiled vertex data may be vertex shader information or program code. The vertex component  may determine a plurality of display lists. In an embodiment, a display list may be based on operation data.","In an embodiment, the vertex component  may include a memory controller component and a shader processor component. The memory controller component may allocate multiple output spaces within a shader processor component. In an embodiment, the vertex data may be compiled by the three dimensional driver so that it is recognized by the shader processor component. The shader processor component may use the compiled vertex data to perform transformation and lighting. The shader processor component may generate the operation data and place the operation data into previously allocated output spaces.","In an embodiment, the memory controller component may allocate multiple input spaces within a tiling processor component. The tiling processor component may be included within the vertex component . The tiling processor component may receive the operation data from the shader processor component and clip and tile the operation data. The tiling processor component may output the clipped and tiled data into a plurality of display lists.","In an embodiment, the pixel component  may render an image based on a view. As the transforming application includes the vertex component performing multiple view transforms within a single vertex pipeline, multiple views of each image may be listed on multiple display lists. In an embodiment, a different view may be stored in a different display list. The display lists may be stored in one or more output buffers. The pixel component may render each display list sequentially according to an interval period received from the application programming interface.","In an embodiment, the output  may include a three dimensional image. In an embodiment, the output may include various views of a three dimensional image with the view corresponding to the display list.","Included herein is a set of flow charts representative of exemplary methodologies for performing novel aspects of the disclosed architecture. While, for purposes of simplicity of explanation, the one or more methodologies shown herein, for example, in the form of a flow chart or flow diagram, are shown and described as a series of acts, it is to be understood and appreciated that the methodologies are not limited by the order of acts, as some acts may, in accordance therewith, occur in a different order and\/or concurrently with other acts from that shown and described herein. For example, those skilled in the art will understand and appreciate that a methodology could alternatively be represented as a series of interrelated states or events, such as in a state diagram. Moreover, not all acts illustrated in a methodology may be required for a novel implementation.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 2","b":["200","200"]},"In the illustrated embodiment shown in , the logic flow  may receive a plurality of view transformations associated with an image at block . For example, an image may be viewed at different angles in sequential three dimensional scenes. An image may be rendered in a variety of angles or views. A three dimensional image may often be rendered in a plurality of view transformations to depict the image as rotating. Instead of using the image pipeline separately for each view transformation of the image, a plurality of view transformations may be received at a single time. The view transformation data may be depicted as models and\/or view transform matrices. In an embodiment, view transformations may include views of an image with different scaling, rotation and\/or translation.","The logic flow  may receive vertex data for the image at block . In an embodiment, vertex data may include information about the object or image. In an embodiment, vertex data may be used to describe the image in a modeling system. For example, vertex data may include the color, position, lighting, etc for an image. For example, an image may be a table and the table may include four vertex data. Each vertex data may include information about a part of the image including, but not limited to, a particular position and\/or color associated with a particular angle or view transformation. The embodiments are not limited to this example.","The logic flow may compile the vertex data at block . In an embodiment, the vertex data may be compiled by the three dimensional driver. The vertex component may include a shader processor component. In an embodiment, compiled vertex data may be used by the shader processor as program code.","The logic flow  may determine operation data by performing the view transformations on the compiled vertex data at block . Information associated with a view of an image may be different for different view transformations. However, the vertex data may remain the same for the different view transformations. By having multiple views in the three dimensional pipeline at a single time, the vertex data only needs to be received and compiled a single time. For example, the shader processor component may determine multiple views using the view transformations which may include matrices and\/or models of various views. The shader processor component may process the compiled vertex data in order to transform the vertex data into the different views.","The compiled vertex data may be vertex shader information or program code for the shader processor component. In an embodiment, program code may enable the shader processor component to run and process the plurality of views. The compiled vertex data may be received a single time and can be used as program code to process the different view transformations. The shader processor component may receive multiple views at once and process the plurality of views on the compiled vertex data through a single run of the vertex pipeline. In an embodiment, multiple view transformations may be handled one by one by a graphical processing unit within a single vertex phase. In an embodiment, multiple views may be processed simultaneously.","Once the shader processor component receives a program that includes matrices and\/or models of various views, the shader processor component may simultaneously perform multiple view transformations for each vertex and generate operation data. In an embodiment, the operation data may be stored into previous allocated memory. In an embodiment, the operation data corresponding to each vertex may be stored individually into previously allocated memory. The embodiments are not limited to this example.","The logic flow  may determine a plurality of display lists through a single run of a vertex pipeline at block . In an embodiment, the vertex component may generate multiple display lists through a single run of the vertex pipeline in order to render sequential three dimensional scenes. In an embodiment, a display list may be based on the operation data. For example, if there were eight vertex data for an image and there were three angles or view transformations in which the image may be rendered, there would be twenty four (or eight times three) pieces of operation data. The embodiments are not limited to this example.","In an embodiment, the logic flow  may store the plurality of display lists at block . In an embodiment, the plurality of display lists may be stored in one or more output buffers.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 3","b":["300","300","100","320"]},"The computing device  may execute processing operations or logic for the system  using a processing component . The processing component  may comprise various hardware elements, software elements, or a combination of both. Examples of hardware elements may include devices, components, processors, microprocessors, circuits, circuit elements (e.g., transistors, resistors, capacitors, inductors, and so forth), integrated circuits, application specific integrated circuits (ASIC), programmable logic devices (PLD), digital signal processors (DSP), field programmable gate array (FPGA), memory units, logic gates, registers, semiconductor device, chips, microchips, chip sets, and so forth. Examples of software elements may include software components, programs, applications, computer programs, application programs, system programs, machine programs, operating system software, middleware, firmware, software modules, routines, subroutines, functions, methods, procedures, software interfaces, application program interfaces (API), instruction sets, computing code, computer code, code segments, computer code segments, words, values, symbols, or any combination thereof. Determining whether an embodiment is implemented using hardware elements and\/or software elements may vary in accordance with any number of factors, such as desired computational rate, power levels, heat tolerances, processing cycle budget, input data rates, output data rates, memory resources, data bus speeds and other design or performance constraints, as desired for a given implementation.","The computing device  may execute communications operations or logic for the system  using a communications component . The communications component  may implement any well-known communications techniques and protocols, such as techniques suitable for use with packet-switched networks (e.g., public networks such as the Internet, private networks such as an enterprise intranet, and so forth), circuit-switched networks (e.g., the public switched telephone network), or a combination of packet-switched networks and circuit-switched networks (with suitable gateways and translators). The communications component  may include various types of standard communication elements, such as one or more communications interfaces, network interfaces, network interface cards (NIC), radios, wireless transmitters\/receivers (transceivers), wired and\/or wireless communication media, physical connectors, and so forth. By way of example, and not limitation, communication media  includes wired communications media and wireless communications media. Examples of wired communications media may include a wire, cable, metal leads, printed circuit boards (PCB), backplanes, switch fabrics, semiconductor material, twisted-pair wire, co-axial cable, fiber optics, a propagated signal, and so forth. Examples of wireless communications media may include acoustic, radio-frequency (RF) spectrum, infrared and other wireless media .","The computing device  may communicate with other devices ,  over a communications media  using communications signals  via the communications component .","In an embodiment, a computing device  may comprise a display . In one embodiment, the display  may comprise a liquid crystal display (LCD). In one embodiment, the display  may comprise an organic light emitting diode (OLED) display. In one embodiment, an OLED display may be used as it provides better color saturation and viewing angles then a liquid crystal display (LCD). In one embodiment, the display  may comprise one or more OLED display screens.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 4","FIG. 4","FIG. 4"]},"In an embodiment, by creating display lists with multiple view transformations, duplicated direct memory access transfers may be eliminated as the vertex data is only loaded a single time to the hardware device memory. The one time load of the vertex data may benefit three dimensional graphic performance and reduce the computing effort.","In an embodiment, the data may be pre-processed . In an embodiment, a control stream direct memory access  may receive an input stream. In an embodiment, the control stream direct memory access  may send a command to the graphical processing unit to fetch a control stream. After the control stream is received, the primitive index direct memory access  may receive a vertex index list. In an embodiment, the vertex index list may be address information for the vertex data which may be received by the shader processor component . The vertex data master  may prepare the vertex index list from the programmable sequencer. In an embodiment, the vertex data master  may include a hardware component that helps to fetch vertex index lists from external memory. In an embodiment, the vertex data master  may help to configure the memory controller .","In an embodiment, the memory controller  may have the one or more direct memory accesses  load vertex data according to the configuration and the index list. The memory controller component  may receive vertex data from direct memory access . In an embodiment, the vertex data may be information about an image. In an embodiment, the vertex data may include modeling data. In an embodiment, vertex data may include data describing an image in a modeling system. In an embodiment, vertex data may include, but is not limited to, position and\/or color information about a particular vertex of an object or image. For example, the vertex data may include position information about the edge of an image.","In an embodiment, the memory controller  may create a series of direct memory accesses  to load compiled vertex data into the shader processor component. The vertex data may be compiled by the three dimensional driver. The shader processor component  may receive the compiled vertex data as program code and process each vertex of an image using the view transformations.","In an embodiment, the memory controller component  may allocate output spaces within a shader processor component . In an embodiment, the memory controller component  may allocate output spaces within the shader processor component  for vertex primary attribute data and vertex secondary attribute data. In an embodiment, vertex primary attribute data may refer to values which are unique to a vertex. For example, a position value may be vertex primary attribute data as each vertex may have a specific position. For example, a color value may be vertex primary attribute data as each vertex may have a different color. In an embodiment, vertex secondary attribute data may refer to values which are common among one or more of the vertices within a three dimensional scene. For example, a view transform matrix may be vertex secondary attribute data as the vertices in a scene may be observed from the same angle.","The shader processor component  may receive the compiled vertex data as program code or vertex shader information. In an embodiment, a matrix from the compiled vertex data may be loaded into the secondary attribute space of the vertex data. In an embodiment, the shader processor component  may combine vertex shader and pixel shader graphic, video and image processing features and capabilities into a single scalable processing unit.","In an embodiment, the memory controller component  may allocate multiple output spaces within the shader processor component  in order to handle multiple view transformations within a single run of the vertex pipeline. In an embodiment, the memory controller component  may allocate N output spaces for the shader processor component  to include the calculated results for N different view transform matrices or models. In an embodiment, the view transformations may be processed using view transform matrices.","For example, in , the shader processor component  may include multiple output spaces , ,  instead of a single output space. The output data may include operation data. The first output space  may be the operation data for the first view transformation or first angle. The second output space  may be operation data for the second view transformation or second angle. The Nth output space  may be operation data for the Nth view transformation or Nth angle.","After the multiple views are processed and placed in multiple output spaces within the shader processor component , the memory controller component  may allocate multiple input spaces within the tiling processor component . In an embodiment, signals may be received from the shader processor component  that the operation data is available. The tiling processor may read the operation data from the shader processor component  to its corresponding input spaces in the tiling processor component . In an embodiment, the memory controller component  may send the operation data to the tiling processor component  to perform clipping and tiling.","In an embodiment the tiling processor component  may perform a series of operations such as primitive construction and\/or view clipping on the operation data. In an embodiment, each operation may be applied to each output of the shader processor component  and a display list output  may be generated for later pixel processing in the pixel pipeline. In an embodiment, the tiling processor component  may clip and tile the operation data.","In , the tiling processor component  may include multiple input spaces , ,  instead of a single input space. The first input space  may be the operation data for the first view transformation or first angle. The second input space  may be the operation data for the second view transformation or second angle. The Nth input space  may be the operation data for the Nth view transformation or Nth angle.","In an embodiment, the tiling processor component  may be optional. For some graphical processing units that do not perform tiling and\/or clipping, the operation data from the shader processor component may be stored in individual output spaces. Each output space in the shader processor may correspond to a different view transform matrix and may be moved into a system buffer waiting for rendering in the pixel phase. At the end of the vertex pipeline, there may be N display lists generated and stored into N system buffers waiting for pixel rendering. In an embodiment, the three dimensional driver may ensure that each display list may be successfully located for the pixel pipeline.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 5","b":["540","541","542","543","541","542","543","540","540","541","542","543","541","542","542"]},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 6","b":["624","626"]},"In an embodiment, the graphics application programming interface  may perform one or more functions. The graphics application programming interface  may assign multiple view transform matrices. Multiple transform matrices may be assigned in order to render rotating three dimensional scenes. A view transform matrix may relate to an image rotating angle. Multiple view transform matrices may enable the image to appear to rotate as the image may be rendered from multiple angles. The graphics application programming interface  may be able to specify a time delay between two sequential scenes. The graphics application programming interface  may enable or disable the function of rendering multiple sequential views.","The three dimensional driver  may be enhanced in one or more aspects. In an embodiment, the three dimensional driver  may determine operation data by performing view transformations on compiled vertex data. In an embodiment, the view transformation matrices may be supplied by the graphics application programming interface . In an embodiment, the three dimensional driver  may allocate one or more system buffers to include display lists which are generated by the vertex pipeline. In an embodiment, each buffer address may be embedded into the memory controller component to ensure that the hardware component within the vertex pipeline and the first hardware component in the pixel pipeline can locate the display lists in the one or more output buffers.","In an embodiment, the three dimensional driver  may begin pixel rendering by reading the display list to the pixel pipeline. The three dimensional driver  may render a display list based on a view transformation. In an embodiment, the pixel pipeline in the three dimensional driver  may render the plurality of display lists sequentially according to an interval period.","In an embodiment, the graphics application programming interface  may determine and assign multiple view transform matrices in order to render rotating three dimensional scenes . The graphics application programming interface  may receive input as to the time interval between rendering sequential scenes. In an embodiment, the time interval  received by the graphics application programming interface  may be used by the three dimensional driver . An image may be presented in a view transformation for the length of the time interval before the render result may be BLIT to the frame buffer to present another angle of the image. In an embodiment, the graphics application programming interface  may be enabled  to process multiple angles during a single run through the vertex pipeline.","The three dimensional driver  may create a context . In an embodiment the three dimensional driver  may receive vertex data . In an embodiment, the three dimensional driver  may obtain the view transform matrices. In an embodiment, the three dimensional driver  may compile the vertex data . In an embodiment, the three dimensional driver  may determine operation data by performing the view transform matrices on the compiled vertex data in the shader processor component.","The three dimensional driver  may allocate system memory for the plurality of display lists to be generated at the end of the vertex pipeline using the operation data. The shader processor component may perform transformations and\/or lighting on each vertex of the image or object. The shader processor component may generate operation data according to the view transform matrices.","In an embodiment, the operation data may be tiled . In an embodiment, the operation data may be read to individual spaces within the tiling processor component for clipping and tiling.","At the end of the vertex pipeline, multiple display lists  may be generated and stored in system memory and\/or one or more buffers. In an embodiment, a display list may be stored in a system buffer. Once the display list has been generated, the vertex pipeline has been completed. The time interval for displaying the rendered images specified by the graphics application programming interface  may be communicated to the three dimensional pipeline.","In an embodiment, when the three dimensional vertex phase has multiple view transformations to perform, the vertex phase may generate individual display lists. The pixel phase  may render each display list in the pixel pipeline.","In an embodiment, the three dimensional driver may render each display list  sequentially according to the time interval  set by a user in the graphics application programming interface . In an embodiment, the three dimensional driver  may wait the time interval . After the time interval, the rendered result may be BLIT to the frame buffer to be presented .","In an embodiment, the three dimensional driver  may determine whether there is another display list waiting for rendering in the pixel phase . If there is another display list, the display list may be rendered in the pixel phase . The three dimensional driver  may wait the time interval  and then BLIT the rendered result to the frame buffer for display . When the last display list has been BLIT and presented and there are no more views , the context may end .",{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 7","b":["700","700"]},"In one embodiment, the computing architecture  may comprise or be implemented as part of an electronic device. Examples of an electronic device may include without limitation a mobile device, a personal digital assistant, a mobile computing device, a smart phone, a cellular telephone, a handset, a one-way pager, a two-way pager, a messaging device, a computer, a personal computer (PC), a desktop computer, a laptop computer, a notebook computer, a handheld computer, a tablet computer, a server, a server array or server farm, a web server, a network server, an Internet server, a work station, a mini-computer, a main frame computer, a supercomputer, a network appliance, a web appliance, a distributed computing system, multiprocessor systems, processor-based systems, consumer electronics, programmable consumer electronics, television, digital television, set top box, wireless access point, base station, subscriber station, mobile subscriber center, radio network controller, router, hub, gateway, bridge, switch, machine, or combination thereof. The embodiments are not limited in this context.","The computing architecture  includes various common computing elements, such as one or more processors, co-processors, memory units, chipsets, controllers, peripherals, interfaces, oscillators, timing devices, video cards, audio cards, multimedia input\/output (I\/O) components, and so forth. The embodiments, however, are not limited to implementation by the computing architecture .","As shown in , the computing architecture  comprises a processing unit , a system memory  and a system bus . The processing unit  can be any of various commercially available processors. Dual microprocessors and other multi-processor architectures may also be employed as the processing unit . The system bus  provides an interface for system components including, but not limited to, the system memory  to the processing unit . The system bus  can be any of several types of bus structure that may further interconnect to a memory bus (with or without a memory controller), a peripheral bus, and a local bus using any of a variety of commercially available bus architectures.","The computing architecture  may comprise or implement various articles of manufacture. An article of manufacture may comprise a computer-readable storage medium to store logic. Embodiments may also be at least partly implemented as instructions contained in or on a non-transitory computer-readable medium, which may be read and executed by one or more processors to enable performance of the operations described herein. Examples of a computer-readable storage medium may include any tangible media capable of storing electronic data, including volatile memory or non-volatile memory, removable or non-removable memory, erasable or non-erasable memory, writeable or re-writeable memory, and so forth. Examples of logic may include executable computer program instructions implemented using any suitable type of code, such as source code, compiled code, interpreted code, executable code, static code, dynamic code, object-oriented code, visual code, and the like.","The system memory  may include various types of computer-readable storage media in the form of one or more higher speed memory units, such as read-only memory (ROM), random-access memory (RAM), dynamic RAM (DRAM), Double-Data-Rate DRAM (DDRAM), synchronous DRAM (SDRAM), static RAM (SRAM), programmable ROM (PROM), erasable programmable ROM (EPROM), electrically erasable programmable ROM (EEPROM), flash memory, polymer memory such as ferroelectric polymer memory, ovonic memory, phase change or ferroelectric memory, silicon-oxide-nitride-oxide-silicon (SONOS) memory, magnetic or optical cards, or any other type of media suitable for storing information. In the illustrated embodiment shown in , the system memory  can include non-volatile memory  and\/or volatile memory . A basic input\/output system (BIOS) can be stored in the non-volatile memory .","The computer  may include various types of computer-readable storage media in the form of one or more lower speed memory units, including an internal hard disk drive (HDD) , a magnetic floppy disk drive (FDD)  to read from or write to a removable magnetic disk , and an optical disk drive  to read from or write to a removable optical disk  (e.g., a CD-ROM or DVD). The HDD , FDD  and optical disk drive  can be connected to the system bus  by a HDD interface , an FDD interface  and an optical drive interface , respectively. The HDD interface  for external drive implementations can include at least one or both of Universal Serial Bus (USB) and IEEE 1394 interface technologies.","The drives and associated computer-readable media provide volatile and\/or nonvolatile storage of data, data structures, computer-executable instructions, and so forth. For example, a number of program modules can be stored in the drives and memory units , , including an operating system , one or more application programs , other program modules , and program data .","The one or more application programs , other program modules , and program data  can include, for example, the graphics application interface  and the three dimensional driver  with the vertex component  and the pixel component .","A user can enter commands and information into the computer  through one or more wire\/wireless input devices, for example, a keyboard  and a pointing device, such as a mouse . Other input devices may include a microphone, an infra-red (IR) remote control, a joystick, a game pad, a stylus pen, touch screen, or the like. These and other input devices are often connected to the processing unit  through an input device interface  that is coupled to the system bus , but can be connected by other interfaces such as a parallel port, IEEE 1394 serial port, a game port, a USB port, an IR interface, and so forth.","A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video adaptor . In addition to the monitor , a computer typically includes other peripheral output devices, such as speakers, printers, and so forth.","The computer  may operate in a networked environment using logical connections via wire and\/or wireless communications to one or more remote computers, such as a remote computer . The remote computer  can be a workstation, a server computer, a router, a personal computer, portable computer, microprocessor-based entertainment appliance, a peer device or other common network node, and typically includes many or all of the elements described relative to the computer , although, for purposes of brevity, only a memory\/storage device  is illustrated. The logical connections depicted include wire\/wireless connectivity to a local area network (LAN)  and\/or larger networks, for example, a wide area network (WAN) . Such LAN and WAN networking environments are commonplace in offices and companies, and facilitate enterprise-wide computer networks, such as intranets, all of which may connect to a global communications network, for example, the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a wire and\/or wireless communication network interface or adaptor . The adaptor  can facilitate wire and\/or wireless communications to the LAN , which may also include a wireless access point disposed thereon for communicating with the wireless functionality of the adaptor .","When used in a WAN networking environment, the computer  can include a modem , or is connected to a communications server on the WAN , or has other means for establishing communications over the WAN , such as by way of the Internet. The modem , which can be internal or external and a wire and\/or wireless device, connects to the system bus  via the input device interface . In a networked environment, program modules depicted relative to the computer , or portions thereof, can be stored in the remote memory\/storage device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers can be used.","The computer  is operable to communicate with wire and wireless devices or entities using the IEEE 802 family of standards, such as wireless devices operatively disposed in wireless communication (e.g., IEEE 802.11 over-the-air modulation techniques) with, for example, a printer, scanner, desktop and\/or portable computer, personal digital assistant (PDA), communications satellite, any piece of equipment or location associated with a wirelessly detectable tag (e.g., a kiosk, news stand, restroom), and telephone. This includes at least Wi-Fi (or Wireless Fidelity), WiMax, and Bluetooth\u2122 wireless technologies. Thus, the communication can be a predefined structure as with a conventional network or simply an ad hoc communication between at least two devices. Wi-Fi networks use radio technologies called IEEE 802.11x (a, b, g, n, etc.) to provide secure, reliable, fast wireless connectivity. A Wi-Fi network can be used to connect computers to each other, to the Internet, and to wire networks (which use IEEE 802.3-related media and functions).",{"@attributes":{"id":"p-0081","num":"0080"},"figref":"FIG. 8","b":["800","800","800"]},"As shown in , the communications architecture  comprises includes one or more clients  and servers . The clients  may implement the client system . The clients  and the servers  are operatively connected to one or more respective client data stores  and server data stores  that can be employed to store information local to the respective clients  and servers , such as cookies and\/or associated contextual information.","The clients  and the servers  may communicate information between each other using a communication framework . The communications framework  may implement any well-known communications techniques and protocols, such as those described with reference to systems  and . The communications framework  may be implemented as a packet-switched network (e.g., public networks such as the Internet, private networks such as an enterprise intranet, and so forth), a circuit-switched network (e.g., the public switched telephone network), or a combination of a packet-switched network and a circuit-switched network (with suitable gateways and translators).","Some embodiments may be described using the expression \u201cone embodiment\u201d or \u201can embodiment\u201d along with their derivatives. These terms mean that a particular feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment. The appearances of the phrase \u201cin one embodiment\u201d in various places in the specification are not necessarily all referring to the same embodiment. Further, some embodiments may be described using the expression \u201ccoupled\u201d and \u201cconnected\u201d along with their derivatives. These terms are not necessarily intended as synonyms for each other. For example, some embodiments may be described using the terms \u201cconnected\u201d and\/or \u201ccoupled\u201d to indicate that two or more elements are in direct physical or electrical contact with each other. The term \u201ccoupled,\u201d however, may also mean that two or more elements are not in direct contact with each other, but yet still co-operate or interact with each other.","It is emphasized that the Abstract of the Disclosure is provided to allow a reader to quickly ascertain the nature of the technical disclosure. It is submitted with the understanding that it will not be used to interpret or limit the scope or meaning of the claims. In addition, in the foregoing Detailed Description, it can be seen that various features are grouped together in a single embodiment for the purpose of streamlining the disclosure. This method of disclosure is not to be interpreted as reflecting an intention that the claimed embodiments require more features than are expressly recited in each claim. Rather, as the following claims reflect, inventive subject matter lies in less than all features of a single disclosed embodiment. Thus the following claims are hereby incorporated into the Detailed Description, with each claim standing on its own as a separate embodiment. In the appended claims, the terms \u201cincluding\u201d and \u201cin which\u201d are used as the plain-English equivalents of the respective terms \u201ccomprising\u201d and \u201cwherein,\u201d respectively. Moreover, the terms \u201cfirst,\u201d \u201csecond,\u201d \u201cthird,\u201d and so forth, are used merely as labels, and are not intended to impose numerical requirements on their objects.","What has been described above includes examples of the disclosed architecture. It is, of course, not possible to describe every conceivable combination of components and\/or methodologies, but one of ordinary skill in the art may recognize that many further combinations and permutations are possible. Accordingly, the novel architecture is intended to embrace all such alterations, modifications and variations that fall within the spirit and scope of the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0004","num":"0003"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0005","num":"0004"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0006","num":"0005"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0007","num":"0006"},"figref":["FIG. 4","FIG. 1"]},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
