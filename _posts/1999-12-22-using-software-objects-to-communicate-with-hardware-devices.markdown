---
title: Using software objects to communicate with hardware devices
abstract: An interface to one or more hardware devices includes a configuration library and objects to model the hardware. Software programs using the interface need not understand how to communicate with the hardware. Instead, the software programs may communicate with the interface. In turn, the interface communicates with the hardware. The software may be written when the hardware implementation features are unknown.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07139693&OS=07139693&RS=07139693
owner: Intel Corporation
number: 07139693
owner_city: Santa Clara
owner_country: US
publication_date: 19991222
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This invention relates to software programs and, more particularly, to application programming interfaces.","Software development is a robust industry. Following the development of new hardware, software typically provides an interface to the hardware.","Before writing a software program, a developer may need to understand the functional requirements of the software, the hardware upon which the software may operate, and the operating environment. Particularly for complex software, a logical organization of the software may also be beneficial to reducing defects.","Some software programs are structured so that they work in a variety of operating environments. Additionally, software that is well-written anticipates new hardware to be supported by the software program. An application programming interface, or API, is a tool for structuring such software applications. As the name suggests, the API \u201cinterfaces\u201d the core application code with the rest of an operating environment.","APIs generally include specifications or protocols for their use. Programs written according to the protocol may have a similar interface to the end-user, for example. APIs also may include routines, libraries, or other tools which minimize duplicity of effort for various developers who may perform similar functions. Thus, APIs are tools that typically permit new development to support new operating systems, to support new hardware, or to add new software features to existing application programs.","Software which supports a number of hardware components may benefit from such interfaces. Further, software which supports hardware from more than a single vendor, each with a distinct hardware requirement, may interface to an API to simplify code development. For projects where the hardware is available only after the software is written, an API may also promote developing the software within the project time constraints.","Thus, there is a continuing need for an interface between a plurality of hardware devices and a software program to support the hardware devices such that the software program is simplified while continuing to support the hardware.","In general, in one embodiment of the invention, a method comprises defining a plurality of hardware devices as a plurality of objects, providing a plurality of tools to perform a plurality of operations on the plurality of objects, executing a software program to use the tools and responding to the plurality of operations by the plurality of hardware devices.","Other features and embodiments will become apparent from the following description, the drawings, and from the claims.","In the prior art, a software program may be written to support one or more hardware devices. For example, the software program may include a graphical user interface which permits a user of the software program to control or monitor the hardware devices. The software program may initialize the hardware devices, as another example.","In supporting the hardware device, the software program may directly interact with the hardware device, or instead interact with an interface to the hardware. The interface to the hardware device may itself be a second software program.","The software program may be written to support hardware devices from a particular vendor. In order to support hardware devices from a second vendor, the software program may be changed, the second vendor's hardware device or an interface to the second vendor's hardware device may be changed. For each distinct hardware type supported by the software program, the software program may grow proportionately.","An object model application programming interface (API)  may provide an alternative to the prior art. Turning to , the object model API , according to one embodiment of the invention, may include a configuration library  and a plurality of objects . The object model API  is coupled between a software program  and a hardware device , a hardware device , and a hardware device .","The hardware device  may, for example, be supplied by a different vendor than the hardware device , etc. The hardware device  may itself include software, such as a software interface (not shown). The hardware device  may operate using one protocol, the hardware device  may operate using a second protocol, and so on.","The object model API  may reside between the software program  and the hardware devices \u2013. In one embodiment of the invention, the object model API  provides the capability to abstract the hardware devices \u2013 so that the software program  need not be written with the distinct requirements of the hardware devices \u2013 in mind. Instead, the software program  communicates with the objects  which model the hardware devices \u2013. In turn, the hardware devices \u2013 communicate with the object model API , whether to take actions, provide information, or perform other operations on the hardware devices \u2013.","The object model API may be beneficial for some hardware\/software models. The software program  may be written with less than full knowledge of the particular hardware involved. Instead, using the object model API , the software program  may be written once a \u201cmodel\u201d of the hardware devices \u2013 has been defined. The objects  represent this model.","Each hardware device \u2013 to be supported by the software program  communicates with the object model API . Where the hardware devices \u2013 include a software interface, the interface may communicate with the object model API . For example, the interface to the hardware devices \u2013 may respond to commands from the object model API  such that the commands are executed upon the hardware devices \u2013.","As part of the object model API , the configuration library  includes a set of tools which enable the software program  to communicate with the objects . The objects  model the hardware devices \u2013. Once the software program  knows how to retrieve and manipulate the objects , using the tools from the configuration library , the software program  may perform operations on the objects .","The objects , in essence, define the hardware devices \u2013 by modeling the operations (or methods), the attributes (or properties), and the actions (or events) of each hardware device \u2013. An operation, known as a method, may be invoked upon an object. The method is appropriate for the real-world hardware modeled by the object. One or more attributes, described below as properties, may also be used to define an object. Actions, described below as events, may model real-world occurrences by the hardware devices \u2013.","In one embodiment of the invention, each object encapsulates the operations of, the attributes of, and the actions to be taken upon the real-world hardware modeled by the object. For example, the hardware device  may be divided into components, each of which is modeled as a separate object . The characteristics for each component are identified, and become properties and methods of the object . Likewise, hardware devices  and  may have objects  for modeling their components.","In , in one embodiment of the invention, the object  includes methods , properties  and events  for representing the characteristics of the hardware devices \u2013 modeled by the object . The methods  may include functions or actions which the hardware devices \u2013 modeled by the object  may perform.","For example, suppose the hardware device modeled is a staple gun. A staple gun may push staples into a piece of paper. Accordingly, an object modeling the staple gun may appropriately include a method, PushStaples.","The properties  may include attributes of the hardware device . For example, attributes of the staple gun may include the number and type of staples. An object modeling the staple gun may appropriately include two properties, NumberOfStaples and StapleType.","Further, the properties  may be defined as having different types. In the staple gun example, NumberOfStaples may be represented as an integer type, while StapleType may be a Boolean variable.","The events  may include those behaviors of the hardware devices \u2013 for which notification may be requested. For example, the staple gun may run out of staples. Accordingly, an object modeling the staple gun may appropriately include an event, OutOfStaples.","The methods , the properties , and the events  of the object  thus model the behavior of the hardware devices \u2013. Once the hardware devices \u2013 are defined in terms of these features, the software program  may communicate with the object  instead of the hardware devices \u2013. In turn, the hardware devices \u2013 communicate with the object model API .","In one embodiment of the invention, the configuration library  may be used to communicate with the objects . In , the tools of the configuration library  may include several functions. The functions may be used by the software program  to communicate with the objects .","The configuration library  includes an initialization function . The initialization function  initializes the configuration library . In one embodiment of the invention, the initialization function  is executed prior to any other function in the configuration library .","A second initialization function  allows the software program  to override any memory management functions of the environment. Some system management architectures provide unique memory management routines. Under such system management architectures, memory management routines may be replaced with other routines. The second initialization function  thus overrides the memory manager upon command.","The configuration library  further includes a set of functions for object creation and object discovery. An object locating function  provides the capability to locate an object of a specific type with a specific property value using a comparison operator as an input value. The object locating function  may be used to determine the components of the hardware device  by the software program , for example. Closely associated with the object locating function , a subsequent object locating function  provides the capability to locate the next object based upon the parameters provided in the object locating function .","In one embodiment of the invention, an object creation function  allows the software program  to create an object for the hardware devices \u2013 which may not be physically located, e.g., virtual hardware features. The object creation function  essentially creates an internal storage area for the object . The internal storage area may be used for the properties  of the object  used to represent the virtual hardware feature, for example.","Another tool in the configuration library , a method invocation function , allows the software program  to execute or invoke a method  within an object . The method  may include parameters which may be set prior to invoking the method  or may be returned upon executing the method . In one embodiment of the invention, the parameters may include properties  of the object  for which the method  is invoked.","In one embodiment of the invention, the configuration library  also provides functions for manipulating the properties  of the object . A get property function  enables the software program  to retrieve the property  of the object . Likewise, a set property function  allows the software program  to set the property  of the object .","The configuration library  also provides functions which enable the software program  to be notified when an event to one of the hardware devices \u2013 occurs. A monitor event function , when enabled, allows the software program  to be notified upon the occurrence of the particular event  of the object . Likewise, a monitor event off function  allows the software program  to turn off monitoring of the particular event  of the object .","Thus, in one embodiment of the invention, the configuration library  of the object model API  provides the capability to invoke the methods , set and retrieve the properties , and monitor the events  for a given object . The software program  may utilize the functions in the configuration library  to communicate with the objects  which model the hardware devices \u2013.","The object model API  may be used as a front end to a variety of types of hardware devices \u2013. By distilling the hardware devices \u2013 into distinct components, an object model  for each component may then be created. Like the staple gun, described above, a variety of hardware devices may then be defined in terms of operations (methods), attributes (properties) and actions (events). These methods , properties , and events  are then encapsulated as objects . To support the hardware devices \u2013, a developer may then use the functions of the configuration library , described above, to perform operations upon the objects .","Because the software program  does not communicate directly with the hardware devices \u2013, the requirements of the hardware devices \u2013 are unimportant to the software program . Instead, the software program  communicates with the objects  using the tools of the configuration library . In this way, the software program  may support the hardware devices \u2013, even when the hardware devices \u2013 change. Further, the software program  may support future hardware additions.","Software which supports a redundant array of independent disks, or RAID, system, may benefit from the object model API . A RAID system is essentially a collection of disks, connected by one or more buses, and employing one or more controllers. RAID systems may employ one or more disk drives, typically to provide fault tolerance and to enhance performance. In addition to the disk drives themselves, the RAID system may include a plurality of controllers and buses. Further, the RAID system may be organized into physical representations of disks, called arrays, or logical representations of disks, called volumes. The RAID hardware, as well as its supporting software, may therefore be complex.","Turning to , a particular implementation of the object model API , shown as a RAID object API , includes the configuration library  and RAID objects , in accordance with one embodiment of the invention. The RAID API interfaces with a RAID software program and a RAID hardware device , a RAID hardware device , and a RAID hardware device ","As in , the RAID hardware devices \u2013may include RAID hardware device , from one vendor, RAID hardware , possibly from a second vendor, and RAID hardware , possibly from a third vendor. Each RAID hardware device \u2013may include a software interface (not shown). The RAID hardware devices \u2013are responsive to directives from the RAID API . Likewise, the RAID software communicates with the objects modeling the RAID hardware devices \u2013using the configuration library .","As with the object model API , with the RAID API , RAID objects may be defined according to the RAID hardware devices \u2013. The RAID hardware devices \u2013may also be described in terms of physical groupings of disks into a unified storage medium, known as an array. Alternatively or additionally, the RAID hardware devices \u2013may be described in terms of logical groupings, or volumes.","The RAID hardware \u2013may be distilled into distinct components, which are then modeled as objects . In , a system  according to one embodiment of the invention may include a processor  and a memory  are coupled to a processor bus . A secondary bus  may be coupled to the processor bus  via a bridge .","The RAID hardware devices extend from the secondary bus , in one embodiment of the invention. Controllers A and B are coupled to the secondary bus . From the controllers , a small computer system interface, or SCSI, bus A and a SCSI bus B connect the controllers A and B to a plurality of disks . For example, disks A, B, C and D are coupled to the SCSI bus A.","As stated above, the RAID system may be organized into physical representations of disks, called arrays, or logical representations of disks, called volumes. In one embodiment of the invention, the volumes may be repositories for information about the volume, while the arrays store no information. So, for example, information about a volume may be written on the volume itself. The array has no such storage capability.","In , the RAID hardware devices include a plurality of arrays . For example, disks C and disks D are joined to form array B. In one embodiment of the invention, each array  has at least one volume  associated with the array . In , the array D includes two volumes E and F. However, array B includes only a single volume D.","The RAID hardware devices may be presented in a number of different ways. For example, in , the controllers A and B extend from the same secondary bus . Alternatively, these controllers  may extend from distinct buses.","From the physical RAID hardware devices of , a plurality of RAID objects may be derived. In , the RAID objects include controller objects , bus objects , disk objects , array objects , and volume objects .","Each of the RAID objects of  represents a component of the RAID hardware devices in . For example, the RAID hardware devices include eight disks A\u2013H. Thus, the RAID objects include eight disk objects \u2013. Likewise, the RAID hardware devices include two controllers A and B. Accordingly, in , controller object and are two of the RAID objects . The RAID objects thus represent, using objects, the entire configuration of the RAID hardware devices ","In one embodiment of the invention, each of the RAID objects includes methods , properties  and events , which are consistent with the particular hardware features these objects model. In , for example, the controller object  includes a method , used to reset the controller of the RAID hardware devices . Likewise, the controller object  includes properties , such as a bus counting method , used to report the number of buses on the controller, and a disk counting method , for reporting the number of disks on the controller, an array counting method  and a volume counting method  to report on the number of arrays and volumes on the controller, respectively. Each of the properties  is accessible to the RAID software for communicating with the controller of the RAID hardware devices .","In , the bus object  includes a scan bus method  and several properties , including a bus indexing property , a bus identification property , a bus protocol property , a bus device count property  and a Boolean property , which tells whether the bus is presently scanning. As with the controller object , the bus object  includes no events for the RAID software to monitor. However, the RAID software may set or retrieve any of the properties or may invoke the scan bus method , as desired.","In , the disk object  includes methods , properties , and events  which allow the RAID software to communicate with the plurality of disks, such as the eight disks A\u2013H of . For example, a method , a method , and a method  may be used to mark a disk as normal, offline, and online, respectively. A total block count property  may be used to retrieve the total block count of the disk.","In addition to several methods  and properties , the disk object  includes events  which may permit the RAID software to monitor the behavior of each disk modeled by the disk object . For example, a disk is normal event  may permit the RAID software to be notified when the disk has been marked as normal (following the invocation of the mark as normal method ). Recall that the configuration library  provides two functions, event monitor on  and event monitor off , which allow the RAID software to monitor one or more events  of the disk object .","In , the array object  and the volume object , like the disk object , include methods , properties  and events . In one embodiment of the invention, the array is defined as a physical grouping of one or more disks. Accordingly, the array object  includes a method  to create an array and a method  to expand an array. A disk count property  enables the RAID software to identify the number of disks  included in the array . A volume degraded event  permits the RAID software to receive notification when a volume  of the array  has degraded.","The volume object  () includes methods such as a method  and a method , for creating and deleting a volume , respectively, from the RAID hardware devices . Properties such as number of bytes per block  and total number of blocks  provide other indicia about the volume . The volume object  further includes event notification for failed, migrating, and initializing volumes, an event , an event , and an event , respectively.","Using the above objects in conjunction with the functions of the configuration library , the RAID software may perform a number of operations on the RAID hardware devices . Simply by controlling the properties  and methods  of the RAID objects , the RAID software can configure the RAID hardware devices ","As an example, the RAID software may perform an operation to determine the devices which are located on a bus. Looking back to , suppose the RAID software wants to determine which devices are connected to the SCSI bus A of the system . An operation to scan the SCSI bus A according to one embodiment of the invention includes invoking the method invocation function  of the configuration library  (see ). In , the method invocation function  is passed two parameters (block ). The object  for which a method  is invoked is provided as a parameter. In the RAID objects , the available objects are controller objects , bus objects , disk objects , array objects , and volume objects . To scan the SCSI bus A, the bus object is passed as a parameter. The method  to invoke from the passed object is also provided as a parameter.","Looking back to , the scan bus method  is the only method  available for the bus object , and is the desired method for performing a scan operation upon the SCSI bus A. Accordingly, the method invocation function  is invoked, and the bus object  and the scan bus method  are passed as parameters (block ).","The get property function  is next invoked (block ). The get property function  is passed three parameters: the object for which a property is to be retrieved, the property to be retrieved, and a location for storing the property value. As with the method invocation function , the bus object  is passed as a parameter. Also, the bus is presently scanning property , and a memory location for storing the result, are passed as parameters. The property  returns a Boolean result.","Once the get property function  is complete, the allocated memory location contains a zero (false) or one (true) result. The next operation (diamond ) tests the value of the property . If true, the property get function  is once again invoked (block ).","If the property  is false, however, the get property function  is invoked, this time with the bus device count property  passed as a parameter (block ). The bus device count property  indicates to the RAID software how many devices were found on the SCSI bus A as a result of the scanning operation. Accordingly, an integer value is stored in the bus device count memory location once the property is retrieved by the get property function . The scanning operation is thus complete (block ).","Thus, an interface to hardware includes a configuration library and objects to model the hardware. Software programs using the interface need not understand how to communicate with the hardware. Instead, the software programs may communicate with the interface. In turn, the interface communicates with the hardware. Such an organization allows the software to be written even before the hardware is implemented, prior to the addition of new or different hardware, or under other conditions in which the hardware requirements are unknown.","While the present invention has been described with respect to a limited number of embodiments, those skilled in the art will appreciate numerous modifications and variations therefrom. It is intended that the appended claims cover all such modifications and variations as fall within the true spirit and scope of this present invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 6","FIG. 5"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 12"}]},"DETDESC":[{},{}]}
