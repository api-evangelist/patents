---
title: Managing availability of a component having a closed address space
abstract: Systems, methods and articles of manufacture are disclosed for managing availability of a component executing in a distributed system. The component may have an address space closed to the distributed system. In one embodiment, the component may be initiated. A state of the component may be analyzed to determine the availability of the component. The determined availability may be transmitted to the distributed system. The component may also be restarted responsive to a request from the distributed system to restart the component.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08082464&OS=08082464&RS=08082464
owner: International Business Machines Corporation
number: 08082464
owner_city: Armonk
owner_country: US
publication_date: 20091013
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["1. Field of the Invention","Embodiments of the invention relate to distributed systems. More specifically, embodiments of the invention relate to techniques for managing availability of a component having a closed address space.","2. Description of the Related Art","Distributed systems include software components running on different computers and interacting with each other via a network, frequently as part of a larger distributed application. Examples of distributed applications include scalable information retrieval and\/or document processing applications that exploit machine-level parallelism. In some cases, a distributed application may include a component that may be unable to participate in an availability protocol of the distributed application. Such a component may be said to have a \u201cclosed address space\u201d (i.e., an address space that is closed to the distributed application). In other words, a component that has a closed address space refers to a component that, while deployed as a standalone process in the distributed system, may not be extended or modified to provide and\/or manage availability of the component using the availability protocol of the distributed application.","A typical example of a component having a closed address space is a third party component deployed as part of a larger distributed application. For instance, the component may provide a service for converting documents or extracting information from documents. However, the component may be closed to modification and\/or extension by a developer of the larger distributed application. For example, a vendor of the component may not provide any source code, software development kit, or integration hooks for the component that would allow the developer to modify or extend the component to provide and manage availability of (a runtime instance of) the component within the framework of the availability protocol of the larger distributed application. Put another way, the developer of the distributed application may be unable to modify or extend the component to participate in the availability protocol of the distributed application.","Often, the availability of the component executing in the closed address space affects availability of the larger distributed system. For example, an unresponsive component may cause the larger distributed system to behave less responsively and\/or less reliably. Further, because the component executes in the closed address space, the distributed system may be unable to determine whether the component is hung. Consequently, the distributed system may be unable to determine whether a performance issue is caused by a dead or hung component, a hardware failure, etc. Because the distributed system may not take into account or otherwise manage the availability of the component, reliability of the distributed system may suffer.","One embodiment of the invention includes a computer-implemented method. The method may generally include configuring one or more computer processors to perform an operation for managing availability of a component executing in a distributed system, the component having an address space closed to the distributed system. The operation may generally include monitoring one or more availability indications of the component within the distributed system; analyzing the one or more availability indications of the component; and assigning an availability state to the component within the distributed system based on the of the one or more availability indications of the component. The operation further includes assigning an availability state to the component selected from at least: (i) a first availability state indicating that the component is healthy; (ii) a second availability state indicating that the component is hung; and (iii) a third availability state indicating that the component is dead.","Other embodiments of the invention include a system and a computer-readable storage medium containing a program, which, when executed on a processor, performs the operation for managing availability of a component executing in a distributed system described above.","Embodiments of the invention provide techniques for managing availability of a component having a closed address space. One embodiment of the invention provides a proxy for the component in the distributed system. The proxy may initiate the component. Further, the proxy may analyze a state of the component to determine the availability of the component. The proxy may also transmit the determined availability to the rest of the distributed system. For example, the proxy may adhere to (and participate in) an availability protocol specified by the distributed system. Accordingly the distributed system may monitor, via the proxy, the health and availability of the component having the closed address space.","In the following, reference is made to embodiments of the invention. However, it should be understood that the invention is not limited to specific described embodiments. Instead, any combination of the following features and elements, whether related to different embodiments or not, is contemplated to implement and practice the invention. Furthermore, although embodiments of the invention may achieve advantages over other possible solutions and\/or over the prior art, whether or not a particular advantage is achieved by a given embodiment is not limiting of the invention. Thus, the following aspects, features, embodiments and advantages are merely illustrative and are not considered elements or limitations of the appended claims except where explicitly recited in a claim(s). Likewise, reference to \u201cthe invention\u201d shall not be construed as a generalization of any inventive subject matter disclosed herein and shall not be considered to be an element or limitation of the appended claims except where explicitly recited in a claim(s).","As will be appreciated by one skilled in the art, aspects of the present invention may be embodied as a system, method or computer program product. Accordingly, aspects of the present invention may take the form of an entirely hardware embodiment, an entirely software embodiment (including firmware, resident software, micro-code, etc.) or an embodiment combining software and hardware aspects that may all generally be referred to herein as a \u201ccircuit,\u201d \u201cmodule\u201d or \u201csystem.\u201d Furthermore, aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium(s) having computer readable program code embodied thereon.","Any combination of one or more computer readable medium(s) may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be, for example, but not limited to, an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system, apparatus, or device, or any suitable combination of the foregoing. More specific examples (a non-exhaustive list) of the computer readable storage medium would include the following: an electrical connection having one or more wires, a portable computer diskette, a hard disk, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM or Flash memory), an optical fiber, a portable compact disc read-only memory (CD-ROM), an optical storage device, a magnetic storage device, or any suitable combination of the foregoing. In the context of this document, a computer readable storage medium may be any tangible medium that can contain, or store a program for use by or in connection with an instruction execution system, apparatus, or device.","A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein, for example, in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms, including, but not limited to, electro-magnetic, optical, or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate, propagate, or transport a program for use by or in connection with an instruction execution system, apparatus, or device.","Program code embodied on a computer readable medium may be transmitted using any appropriate medium, including but not limited to wireless, wireline, optical fiber cable, RF, etc., or any suitable combination of the foregoing.","Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages, including an object oriented programming language such as Java, Smalltalk, C++ or the like and conventional procedural programming languages, such as the \u201cC\u201d programming language or similar programming languages. The program code may execute entirely on the user's computer, partly on the user's computer, as a stand-alone software package, partly on the user's computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario, the remote computer may be connected to the user's computer through any type of network, including a local area network (LAN) or a wide area network (WAN), or the connection may be made to an external computer (for example, through the Internet using an Internet Service Provider).","Aspects of the present invention are described below with reference to flowchart illustrations and\/or block diagrams of methods, apparatus (systems) and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and\/or block diagrams, and combinations of blocks in the flowchart illustrations and\/or block diagrams, can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer, special purpose computer, or other programmable data processing apparatus to produce a machine, such that the instructions, which execute via the processor of the computer or other programmable data processing apparatus, create means for implementing the functions\/acts specified in the flowchart and\/or block diagram block or blocks.","These computer program instructions may also be stored in a computer readable medium that can direct a computer, other programmable data processing apparatus, or other devices to function in a particular manner, such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function\/act specified in the flowchart and\/or block diagram block or blocks.","The computer program instructions may also be loaded onto a computer, other programmable data processing apparatus, or other devices to cause a series of operational steps to be performed on the computer, other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions\/acts specified in the flowchart and\/or block diagram block or blocks.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1","b":["100","100","102","102","130","102","130","130"]},"The computer  generally includes a processor  connected via a bus  to a memory , a network interface device , a storage , an input device , and an output device . The computer  is generally under the control of an operating system . Examples of operating systems  include UNIX, versions of the Microsoft Windows\u00ae operating system, and distributions of the Linux\u00ae operating system. (Note: Linux is at trademark of Linus Torvalds in the United States and other countries.) More generally, any operating system supporting the functions disclosed herein may be used. The processor  is included to be representative of a single CPU, multiple CPUs, a single CPU having multiple processing cores, and the like. Similarly, the memory  may be a random access memory. While the memory  is shown as a single entity, it should be understood that the memory  may comprise a plurality of modules, and that the memory  may exist at multiple levels, from high speed registers and caches to lower speed but larger DRAM chips. The network interface device  may be any type of network communications device allowing the computer  to communicate with other computers via the network .","The storage  may be a hard disk drive storage device. Although the storage  is shown as a single unit, the storage  may be a combination of fixed and\/or removable storage devices, such as fixed disc drives, floppy disc drives, tape drives, removable memory cards, or optical storage. The memory  and the storage  may be part of one virtual address space spanning multiple primary and secondary storage devices.","The input device  may be any device for providing input to the computer . For example, a keyboard, keypad, light pen, touch-screen, track-ball, or speech recognition unit, audio\/video player, and the like may be used. The output device  may be any device for providing output to a user of the computer . For example, the output device  may be any conventional display screen or set of speakers, along with their respective interface cards, i.e., video cards and sound cards. Although shown separately from the input device , the output device  and input device  may be combined. For example, a display screen with an integrated touch-screen, a display with an integrated keyboard, or a speech recognition unit combined with a text speech converter may be used.","As shown, the memory  of the computer  includes a component , a proxy , and the operating system . As used herein, the component  refers to a process, i.e., an instance of the component executing on the computer . In one embodiment, the component  may be a server component that executes in an address space that is closed to the distributed system. As used herein, a component refers to a software application that encapsulates a set of related functions (and\/or data). An example of a component is a software application that provides a service to one or more applications locally and\/or via the network  (i.e., a server component). The component  may also be closed to modification and\/or extension by a developer of the distributed application. In one embodiment, the proxy  may be a process that analyzes a state of the component  to determine availability of the component  (e.g., whether the component  is available to participate in the larger distributed application). The proxy  may also transmit the determined availability (or other information related to the state of the component ) to the rest of the distributed system (e.g., using an availability protocol of the distributed system). In other words, the proxy  shadows the component  executing in the distributed system and represents the component  in the availability protocol of the distributed system. Accordingly, the distributed system may manage the availability of the component  via the proxy . For example, upon receiving an indication that the component  is hung, the distributed system may request the proxy  to restart the component .",{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 2","FIG. 1"],"b":["200","150","200","148","150","152","210","150","148","204","148","150","206","148","208","210"]},"While embodiments are described herein with reference to the C++ programming language, those skilled in the art will recognize that other programming languages may be supported without departing from the scope of the invention.","As described above, the proxy  may use inter-process communication with the component  to analyze a state of the component , according to one embodiment. As is known, inter-process communication (IPC) refers to a set of techniques for exchanging data between multiple threads in one or more processes. The processes may execute on one or more computers connected via a network. One example of inter-process communication is redirecting a shared library. One example of a shared library is a dynamic-link library (DLL) in a Windows\u00ae environment. In UNIX-like environments, a shared library is also referred to as a shared object; consequently, a .so filename extension often identifies a shared library file in UNIX-like environments.","Suppose that the component  calls functions provided by the shared library. In one embodiment, the proxy  may intercept the function calls via a wrapper library for the shared library. As is known, a wrapper library for a shared library provides the same function signatures as the shared library. As is known, a function signature refers to the name of a function, the type and order of parameters of a function, and the type of return value of a function. For each function in the wrapper library, however, the wrapper library may provide additional functionality. The wrapper library may also call a corresponding function in the shared library. The proxy  may analyze the intercepted function calls (via the wrapper library) to determine progression of a process and\/or thread of the component , according to one embodiment. Consequently, the proxy  may determine the availability of the component  (e.g., whether the component is in a healthy, hung, or other state).","Another example of inter-process communication is commonly referred to as pipes. As is known, a pipe refers to a set of processes chained by standard streams of the processes, so that the output of each process feeds directly as input to the next process. A pipe typically exists anonymously and persists only for as long as the processes are executing. Thus, a pipe is sometimes referred to as an \u201cunnamed pipe.\u201d A named pipe, on the other hand, is system-persistent and exists beyond execution of the processes. Processes may generally attach to the named pipe to perform inter-process communication with other processes. Once the named pipe is no longer being used, a process may also delete the named pipe.","For example, in a UNIX like environment, the component  may create a named pipe via calling a mkfifo( ) function. As is known, the mkfifo( ) function creates a new named pipe based on a pathname and an access mode (which the component  may specify). For instance, if the specified access mode permits read and write access by all users, any process may use the named pipe to send and\/or receive data (i.e., with any other process that also uses the named pipe). For example, the proxy  may call an open( ) function to open the named pipe and use file I\/O functions (e.g., read( ), write( ), close( ), etc.) to access the named pipe. Once the component  no longer needs the named pipe, the component  may remove the named pipe via calling an unlink( ) function. As is known, the unlink( ) function deletes files.","In one embodiment, the proxy  may detect whether a named pipe exists. For example, the proxy  may determine if calling the open( ) function to open the named pipe returns an error; if so, the named pipe may not exist. If the named pipe exists, the proxy  may determine that the component  is healthy (i.e., executing normally; not dead or hung). Otherwise, the proxy  may determine that the component  is dead or hung. In other words, the proxy  may infer the availability of the component  from the named pipe. Consequently, the proxy  may more accurately determine the availability of the component  (e.g., by using both a shared library and a named pipe). Of course, those skilled in the art will recognize that the way of determining the availability of the component  via named pipes may be tailored to suit the needs of a particular case.","As described above, the proxy  may also use operating system primitives to analyze the state of the component , according to one embodiment. As used herein, an operating system primitive refers to a function or event that is supported by the operating system. One example of an operating system primitive is a kill function supported by many UNIX-like operating systems. As is known, the kill function sends a termination signal to a process or a group of processes. A signature for the kill function may be int kill (pid_t pid, int sig).","In one embodiment, the proxy  may call the kill function to analyze the availability of the component . Specifically, the proxy  may call kill (pid, 0). The first argument, pid, is the process identifier for the component . The second argument, 0, specifies that no termination signal is to be sent to the component  (and consequently, only validity of pid is checked). The kill function returns a value indicating whether the process identifier is valid. From the returned value, the proxy  may determine whether the component  has terminated (as of the time of validating the process identifier).","Another example of an operating system primitive is a function for opening a process in debug mode. The proxy  may obtain sufficient authority (granted by the operating system, e.g., superuser authority) to open the process (i.e., a runtime instance of the component ) in debug mode, thereby gaining control over the process. For instance, versions of the Windows\u00ae operating system include a Windows application programming interface (API) that supports a DebugActiveProcess function. As is known, the DebugActiveProcess function enables a debugger to attach to an active process and debug the active process. A signature for the DebugActiveProcess function is BOOL WINAPI DebugActiveProcess(_in DWORD dwProcessId).","In one embodiment, the proxy  may call the DebugActiveProcess function to analyze the availability of the component . The formal parameter, dwProcessId, is the process identifier for the component . The proxy  may attach to the component  and debug the attached component . That is, the proxy  may probe the closed address space of the attached component  using functions provided by the debugger. For example, the proxy  may determine whether the process (and\/or a thread) of the component  is progressing as opposed to hanging (e.g., in terms of executing instructions). The proxy  may also determine whether the process (and\/or a thread) of the component  is waiting on any outstanding request(s). Consequently, the proxy  may determine whether the component  is healthy or hung. Of course, those skilled in the art will recognize that the way of determining the availability of the component  via opening a process in debug mode may be tailored to suit the needs of a particular case.","UNIX-like operating systems may also support interrogating a process state. For instance, many UNIX-like operating systems support a process file system (or procfs for short). As is known, procfs refers to a pseudo file system (i.e., a file system generated at boot time) for accessing process level related information via the kernel of the operating system. The pseudo file system is often mounted at a \/proc directory in UNIX-like environments. The proxy  may be configured with authority to access the pseudo file system, according to one embodiment.","In one embodiment, the proxy  may construct profiles of the component  information stored by the operating system in the procfs file system. Each profile may correspond to a different state of the component  (e.g., healthy, hung, etc.). Each profile may also include information about the component  that is typically observed for a given state (healthy, hung, etc.). For example, the information may include state, progression in terms of executing instructions, hardware utilization, etc. The proxy  may then detect behavior of the component . For example, the proxy  may examine threads and extract samples of resources used by the component . Examples of typical resources include instantaneous stack traces, context switches, execution cycles etc. The proxy  then may compare the detected behavior with the constructed (historic) profiles to determine the availability of the component . Of course, those skilled in the art will recognize that the way of determining the availability of the component  via interrogating a state of the process may be tailored to suit the needs of a particular case.","Yet another example of an operating system primitive is an event supported by the operating system. For example, an event may indicate that a child process has terminated. As is known, SIGCHLD is a signal sent by the kernel of a UNIX like operating system to a parent process when a child process of the parent process terminates. A child process is created when one process (the parent) \u201cforks\u201d another process (the child). The operating system monitors the child process, and when the child process terminates, the kernel sends the SIGCHLD signal to the parent.","In one embodiment, the proxy  may be configured to initiate execution of the component . For example, the proxy  may fork the component  as a child process (and thus become a parent process of the component ). Upon receiving a SIGCHLD signal from the kernel, the proxy  may determine that the component  has terminated (whether gracefully, abnormally, etc.). Of course, other ways of determining the availability of the component  from system events are broadly contemplated without departing from the scope of the invention.","Further, the proxy  may combine multiple techniques to determine the availability of the component , according to one embodiment. For example, the proxy  may use inter-process communication in conjunction with operating system primitives. In doing so, the proxy  may more accurately determine availability of the component . Of course, the way of combining multiple techniques to determine a comprehensive availability state of the component  may be tailored to suit the needs of a particular case.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":["FIG. 3","FIG. 1"],"b":["300","150","300","302","304","306","302","304","306","148","150","148"]},"As shown, the proxy  may transition from a healthy state  to a suspect state  upon receiving a signal (e.g., SIGCHLD) from the operating system . The proxy  may also transition from a healthy state  to a suspect state  upon receiving a request (from the distributed system ) for the availability of the component . The proxy  may also transition from a healthy state  to a suspect state  upon determining that a \u201ctimeout\u201d period has elapsed. The timeout period refers to a predefined time period beyond which a previously determined availability of the component  (e.g., healthy) is no longer deemed to be accurate. In other words, once the predefined time period is exceeded, the proxy  may re-determine the availability of the component  and transition the state of component  to a \u201csuspect\u201d state until the determination is complete.","In one embodiment, the proxy  may probe and\/or analyze the state of the component  to determine the availability of the component . For example, the proxy  may use inter-process communication and\/or operating system primitives to probe and\/or analyze the state of the component . Further, the proxy  may transition from the suspect state  to the healthy state  upon determining that the component  is healthy. Similarly, the proxy  may transition from the suspect state  to the dead\/hung state  upon determining that the component  is dead\/hung. The proxy  may transition from the dead\/hung state  to the suspect state  upon restarting the component .","Other embodiments are broadly contemplated without departing from the scope of the invention. In one embodiment, the distributed system may also control availability of the component  via the proxy . For example, the distributed system may request to start, stop, or restart the component  via the proxy . Further, the proxy  may restart the component  in a manner transparent to the distributed system. For example, the proxy  may restart the component  upon determining that no the component  is not healthy and that no request is currently pending from the distributed system for the availability of the component .",{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 4","FIG. 1"],"b":["400","148","400","410","150","148","420","150","148","148","430","150","430","400"]},{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 5","FIG. 1","FIG. 4"],"b":["500","148","500","420","430","500","150"]},"As shown, the method  begins at step , where the proxy  transitions to a \u201csuspect\u201d state (which represents an availability of the component , as determined by the proxy ). The \u201csuspect\u201d state indicates that the proxy  has not yet determined the state of the component .","At step , the proxy  uses inter-process communication and\/or operating system primitives to extract and analyze the state of the component . More generally, the application  may use inter-process communication and\/or operating system primitives to extract and\/or analyze the state of the component  throughout the method  to determine the state of the component  (e.g., at steps , , , , , , , which are described below).","At step , the proxy  determines whether the component  is healthy based on the analysis of the step . If so, the proxy  transitions to a \u201chealthy\u201d state (step ) and resets counters (e.g., a first counter and a second counter, described below). The proxy may also transmit the \u201chealthy\u201d state to the distributed system via an availability protocol of the distributed system (step ).","On the other hand, if the proxy  determines that the component  is not healthy (step ), then at step , the proxy  determines whether the component is hung. In one embodiment, to reduce the effect of noise in the system on availability determination, the proxy  transitions to a \u201chung\u201d state only upon having made a threshold count of determinations that the component is hung. For example, if the proxy  determines that the component  is hung (step ), the proxy  increments a first counter (step ) and checks whether the first counter satisfies a first threshold (step ). If the first threshold is not satisfied, the method  returns to the step  to reevaluate the component . Of course, those skilled in the art will recognize that the threshold count may be tailored to suit the needs of a particular case. However, a threshold count of three or four hang determinations has proven useful in some cases.","Alternatively, if the first threshold is satisfied (step ), the proxy  transitions the component  to a to a \u201chung\u201d state (step ). At step , the proxy  may attempt to kill the hung component. If the hung component is not successfully killed (step ), the proxy  may transition to a \u201cfatal\u201d state (step ) and reset counters (e.g., the first counter and the second counter). As used herein, the \u201cfatal\u201d state refers to an error condition of the component  as determined by the proxy . In addition, the proxy  may transmit the \u201cfatal\u201d state to the distributed system via an availability protocol used by the distributed system (step ) to monitor the availability of each component that contributes to the distributes system. If the hung component is successfully killed (step ), the proxy  may transition to a \u201cdead\u201d state (step ) and attempt to restart the component  (step ).","In one embodiment, the proxy  transitions to the \u201cfatal\u201d state upon satisfying a threshold count of determinations that the component  has not been killed successfully (e.g., based on a third counter maintained by the proxy ). That is, the proxy  transitions to the \u201cfatal\u201d state after multiple, unsuccessful attempts at killing the component .","On the other hand, if the proxy  determines that the component  is not hung (step ), then at step , the proxy  determines whether the component  is dead. If so, the proxy  simply returns to the step  to transition to a \u201csuspect\u201d state.","Otherwise, to reduce the effect of noise in the system on availability determination, the proxy  transitions to a \u201cdead\u201d state only upon having a made a threshold count of determinations that the component is dead, according to one embodiment. For instance, if the proxy  determines that the component  is dead (step ), the proxy  increments a second counter (step ) and checks whether the second counter satisfies a second threshold (step ). If the second threshold is not satisfied, the method  returns to the step  to reevaluate the component . Of course, those skilled in the art will recognize that the threshold count may be tailored to suit the needs of a particular case. However, a threshold count of two death determinations has proven useful in some cases.","Alternatively, if the second threshold is satisfied (step ), the proxy  transitions to a \u201cdead\u201d state (step ). At step , the proxy  may attempt to restart the (dead) component . If the component  is not successfully restarted (step ), the proxy  may transition to the \u201cfatal\u201d state (step ) and reset counters (e.g., the first counter and the second counter). Further, the proxy  may transmit the \u201cfatal\u201d state to the distributed system via the availability protocol of the distributed system (step ). Of course, those skilled in the art will recognize that the way of transitioning to the \u201cfatal\u201d state may be tailored to suit the needs of a particular case. For example, in one embodiment, the proxy  may transition to the \u201cfatal\u201d state only upon satisfying a threshold count of determinations that the component  is not successfully restarted (e.g., based on a fourth counter maintained by the proxy ). That is, the proxy  transitions to the \u201cfatal\u201d state only upon multiple unsuccessful attempts at restarting the component .","On the other hand, if the restart is successful (step ), the proxy  transitions to a \u201chealthy\u201d state (step ) and resets counters (e.g., the first counter and the second counter). The proxy  may also transmit the \u201chealthy\u201d state to the distributed system via the availability protocol of the distributed system (step ). After the step , the method  may return to the step  for the proxy  to reevaluate the component .","The flowchart and block diagrams in the Figures illustrate the architecture, functionality, and operation of possible implementations of systems, methods and computer program products according to various embodiments of the present invention. In this regard, each block in the flowchart or block diagrams may represent a module, segment, or portion of code, which comprises one or more executable instructions for implementing the specified logical function(s). It should also be noted that, in some alternative implementations, the functions noted in the block may occur out of the order noted in the figures. For example, two blocks shown in succession may, in fact, be executed substantially concurrently, or the blocks may sometimes be executed in the reverse order, depending upon the functionality involved. It will also be noted that each block of the block diagrams and\/or flowchart illustration, and combinations of blocks in the block diagrams and\/or flowchart illustration, can be implemented by special purpose hardware-based systems that perform the specified functions or acts, or combinations of special purpose hardware and computer instructions.","Advantageously, embodiments of the invention provide techniques for managing the availability of a component executing in a distributed system. The component may have an address space closed to the distributed system. One embodiment of the invention provides a proxy. In one embodiment, the proxy initiates the component. The proxy may analyze a state of the component to determine the availability of the component. The proxy may transmit the determined availability to the distributed system via an availability protocol of the distributed system. Accordingly, the distributed system may monitor, via the proxy, the availability of the component having the closed address space. The distributed system may also control the availability of the component via the proxy.","While the foregoing is directed to embodiments of the present invention, other and further embodiments of the invention may be devised without departing from the basic scope thereof, and the scope thereof is determined by the claims that follow."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["So that the manner in which the above recited features, advantages and objects of the present invention are attained and can be understood in detail, a more particular description of the invention, briefly summarized above, may be had by reference to the embodiments thereof which are illustrated in the appended drawings.","It is to be noted, however, that the appended drawings illustrate only typical embodiments of this invention and are therefore not to be considered limiting of its scope, for the invention may admit to other equally effective embodiments.",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
