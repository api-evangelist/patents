---
title: Detection of lockstep behavior
abstract: Disclosed here are methods, systems, paradigms and structures for determining fraudulent content in a social network. The methods include identifying a plurality of users of the social network who perform a plurality of tasks within the social network in a lockstep manner. In the method, the plurality of users are determined to be performing a given task in the lockstep manner when the plurality of users each perform the given task within a predefined duration of time, where the predefined duration of time is associated with the given task. The method further includes identifying content data generated by the performance of the plurality of tasks by each of the plurality of users. The method further includes determining at least a portion of the content data generated by the performance of the plurality of tasks as fraudulent content.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09077744&OS=09077744&RS=09077744
owner: FACEBOOK, INC.
number: 09077744
owner_city: Menlo Park
owner_country: US
publication_date: 20130306
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This invention generally relates to detecting fraudulent behavior in online media. More specifically, the invention relates to detecting fraudulent content generated by spammers from legitimate content generated by users in online media.","In recent years, web services have increasingly relied on social data in providing information to their users, where social data generally refers to content created by users (e.g., a user review of a product), which they knowingly and voluntarily share with other users. For example, on Facebook users discover content based on what their friends and other users like, and on Amazon users evaluate potential purchases based on other users' reviews. Unfortunately, attackers attempt to skew content perception by offering misleading feedback (through a variety of means), with the goal of increased distribution for their content. The challenge becomes distinguishing such fraudulent feedback from legitimate user feedback. Such a challenge is faced by all services that depend on user behavior for their processes and recommendations, for e.g., from stories on Facebook to product reviews on Amazon to reviews of businesses on TripAdvisor.","For example, on Facebook, Pages are used by organizations to interact with their fans. Users can \u201cLike\u201d a Page to let their friends know about their interests and to receive content from that Page in their News Feed, one of the primary distribution channels on Facebook. Further, other users may interpret a high \u201cLike\u201d count as a Page being popular and will also see their friends' Page Likes in their News Feeds. Because of the News Feed's utility as a distribution channel, attackers frequently attempt to boost Page Like counts to get increased distribution for their content. For instance, attackers have attempted to inflate Like counts through a variety of deceitful methods, including malware, credential stealing, social engineering, and fake accounts. Such ill-gotten Likes that came from someone not truly interested in connecting with a Page could affect the trust of users on such social data.","Among teaching a variety of other things, certain aspects of the inventions herein have embodiments which may satisfy one or more of the above-described issues.","Introduced here are methods, systems, paradigms and structures for determining fraudulent content in a social network. In one embodiment, a computer-implemented method includes identifying a plurality of users of the social network who perform a plurality of tasks within the social network in a lockstep manner. In the method, the plurality of users are determined to be performing a given task in the lockstep manner when the plurality of users each perform the given task within a predefined duration of time, where the predefined duration of time is associated with the given task. The method further includes identifying content data generated by the performance of the plurality of tasks by each of the plurality of users. The method further includes determining at least a portion of the content data generated by the performance of the plurality of tasks as fraudulent content.","Some embodiments of the invention have other aspects, elements, features, and steps in addition to or in place of what is described above. These potential additions and replacements are described throughout the rest of the specification.","References in this description to \u201can embodiment\u201d, \u201cone embodiment\u201d, or the like, mean that the particular feature, function, or characteristic being described is included in at least one embodiment of the present invention. Occurrences of such phrases in this specification do not necessarily all refer to the same embodiment, nor are they necessarily mutually exclusive.","References in this description to \u201ca Like\u201d, \u201cLiking\u201d, \u201cLiked\u201d, \u201cendorse\u201d, or the like, refers to a user making a connection with a Facebook Page, an advertisement, or other content off of Facebook.","References in this description to \u201csocial network\u201d refer to an online service, platform, or site that facilitates the building of networks or social relations among people who, for example, share interests, activities, backgrounds, or real-life connections.","References in this description to \u201csocial data\u201d refer to content created by users (e.g., a user review of a product, an indication of an interest in a product by endorsing, say Liking, the product), which the users knowingly and voluntarily share with other users.","As discussed above, detecting fraudulent social data, such as ill-gotten Likes (i.e. user endorsements), are important to maintain the integrity and usefulness of the various social networks, such as yelp, Facebook, etc. Disclosed here are methods, systems, paradigms and structures for detecting fraudulent content generated by spammers from legitimate content generated by users in online media. The method includes detecting fraudulent content in a social network by identifying suspicious groups of users in the social network who display lockstep behavior, such as Liking (i.e. endorsing) similar groups of Pages within a given window of time. The method further includes deeming at least a portion of the content generated by such suspicious groups of users as fraudulent content.","One possible method for detecting lockstep behavior in a social network includes analyzing the social graph between users and Pages and the times at which the edges between the users and the Pages in the graph were created (e.g., the time a given user Liked a given Page).  provides an illustrative example of a social graph between users - and Pages - with the corresponding times at which the users Liked the Pages representing the respective edges - between the users and Pages. To detect lockstep behavior, the method includes analyzing the similarity of a suspicious group of users' - connections - (i.e. edges in the social graph) to similar groups of Pages -, where the similarity in connections - is determined based on various metadata, including the times at which the connection between the users - and Pages - were created. Additional details regarding the social graph is explained in later sections of the specification.","In some embodiments, the method further includes filtering the suspicious groups of users and only considering those groups of users which include a minimum number of users who performed a relevant task in association with a minimum number of Pages at around the same time as the other suspicious users. For example, the method can require that at least three users exhibit lockstep behavior by Liking at least five Pages at around the same time for the three users to be considered a suspicious group of users. Such a constraint will limit the instances where groups of innocent users, seemingly exhibiting lockstep behavior, are incorrectly identified as suspicious groups of users.","The method is effective in detecting fraudulent content as it exploits one of the critical weaknesses of spammers who generate fraudulent content. For spammers to be successful, it is important that they get as many users as possible to perform a relevant task, such as Like the spammers' Page in Facebook. However, in most social networks, each user is limited to performing the relevant task only once (with respect to a particular object), e.g., in Facebook each user can only Like each Page once, while in Amazon a user can endorse a spammer's product with a high product rating only once, etc. In addition, most of the social networks already have many anti-phishing and anti-malware mechanisms that make it difficult for real accounts to be compromised. Further, many fake accounts detection processes make it difficult to create and maintain fake accounts.","As a result, it is hard for spammers to control many accounts, and instead the spammers are forced to use the same few users to perform the relevant tasks, such as Like Pages on Facebook. So, by identifying suspicious groups of users in the social network who display lockstep behavior, where groups of users acting together, generally performing relevant tasks in association with the same Pages at around the same time as each other, the method can deem content generated by such suspicious groups of users as fraudulent content. Here, when exhibiting lockstep behavior, a suspicious group of users could have performed a relevant task in association with each Page from a subset of Pages at a different time. However, when exhibiting lockstep behavior, the suspicious group of users should have each performed a relevant task in associated with a given Page from the subset of Pages at around the same time as the other users. For example, if users #1, #2 and #3 each Like Page \u201cA\u201d around 6:30 pm PST on Dec. 15, 2012 and users #1, #2 and #3 each further Like Page \u201cB\u201d around 1:30 pm PST on Feb. 15, 2013, then users #1, #2 and #3 could be considered a suspicious group of users exhibiting lockstep behavior.","As discussed earlier, the disclosed method could be applied to a range of anomaly detection problems. In one example, the method could be used to identify ill-gotten Likes by identifying lockstep behavior of suspicious users who each Liked similar Pages around the same time. In another example, the method could be used to find bots on Twitter that systematically \u201cFollow\u201d people by searching for groups of users who start \u201cfollowing\u201d groups of other users within a given time period. In another instance, the method could be used to analyze the relationship between reviewers and products on ecommerce sites (e.g. Amazon.com) and detect suspicious groups of users who are connected to similar groups of products.","In instances where the users provide additional data when performing the relevant action, such as providing an IP address a product review is being posted from, the product review tone, linguistic cues in the product review, etc., the additional data can be used in analyzing the similarity of connections when performing anomaly detection. The similarity analysis for some of the additional data that are provided as data strings (such as parsed strings from posted user reviews) can be performed using any well known method that provides the degree of similarity between any two provided data strings as a quantifiable value. In one embodiment, the quantified similarity value for each of the additional data can be utilized by the method to analyze the similarity of connections between the users and Pages.","The above disclosed method to detect fraudulent content by identifying lockstep behavior can be implemented using many different processes. Two such processes, which are explained in detail below, are: (1) a provably-convergent iterative process (also referred to as the \u201cserial process\u201d); and (2) an approximate, scalable MapReduce process (also referred to as the \u201cparallel process\u201d). In the following sections, the two processes are explained using how they could be utilized to identify ill-gotten Likes in a social network. However, as explained above, the two processes can be applied to a range of other anomaly detection problems by changing the definition of the relevant user action and the context in which the relevant user action is performed by the user.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 1","FIG. 1"],"b":["100","105","100","110","105","115","100"]},"The social networking system  comprises one or more computing devices storing user profiles associated with users and\/or other objects as well as connections between users and other users and\/or objects. In use, users join the social networking system  and then add connections to other users or objects of the social networking system to which they desire to be connected. As further described below, users of the social networking system  may be individuals or entities such as businesses, organizations, universities, manufacturers. The social networking system  allows its users to interact with each other as well as with other objects maintained by the social networking system . In some embodiments, the social networking system  allows users to interact with third-party websites and financial account providers.","Based on stored data about users, objects and connections between users and\/or objects, the social networking system  generates and maintains a \u201csocial graph.\u201d comprising a plurality of nodes interconnected by a plurality of edges. Each node in the social graph represents an object or user that can act on another node and\/or that can be acted on by another node. An edge between two nodes in the social graph represents a particular kind of connection between the two nodes, which may result from an action that was performed by one of the nodes on the other node. For example, when a user identifies an additional user as a friend, an edge in the social graph is generated connecting a node representing the first user and an additional node representing the additional user. The generated edge has a connection type indicating that the users are friends. As various nodes interact with each other, the social networking system  modifies edges connecting the various nodes to reflect the interactions. In another example, when a user Likes a Page, an edge in the social graph is generated connecting a node representing the user and an additional node representing the Page. The generated edge represents the connection time between the user and the Page, indicating the time when the user Liked the Page.","A user device  is a computing device capable of receiving user input as well as transmitting and\/or receiving data via the network . In one embodiment, the user device  is a conventional computer system, such as a desktop or laptop computer. In another embodiment, the user device  may be a device having computer functionality, such as a personal digital assistant (PDA), mobile telephone, smart-phone or similar device. The user device  is configured to communicate with the social networking system , and\/or the financial account provider via the network . In one embodiment, the user device  executes an application allowing a user of the user device  to interact with the social networking system . For example, the user device  executes a browser application to enable interaction between the user device  and the social networking system  via the network . In another embodiment, a user device  interacts with the social networking system  through an application programming interface (API) that runs on the native operating system of the user device , such as IOS\u00ae or ANDROID\u2122.","The user device  are configured to communicate via the network , which may comprise any combination of local area and\/or wide area networks, using both wired and wireless communication systems. In one embodiment, the network  uses standard communications technologies and\/or protocols. Thus, the network  may include links using technologies such as Ethernet, 102.11, worldwide interoperability for microwave access (WiMAX), 3G, 4G, CDMA, digital subscriber line (DSL), etc. Similarly, the networking protocols used on the network  may include multiprotocol label switching (MPLS), transmission control protocol\/Internet protocol (TCP\/IP), User Datagram Protocol (UDP), hypertext transport protocol (HTTP), simple mail transfer protocol (SMTP) and file transfer protocol (FTP). Data exchanged over the network  may be represented using technologies and\/or formats including hypertext markup language (HTML) or extensible markup language (XML). In addition, all or some of links can be encrypted using conventional encryption technologies such as secure sockets layer (SSL), transport layer security (TLS), and Internet Protocol security (IPsec).","The social networking system  includes a web server , an action logger , an action log , a user profile store , a content store , an edge store , a financial account store , and a lockstep detection engine . In other embodiments, the social networking system  may include additional, fewer, or different modules for various applications. Conventional components such as network interfaces, security mechanisms, load balancers, failover servers, management and network operations consoles, and the like are not shown so as to not obscure the details of the system architecture.","Web server  links social networking system  via network  to one or more user devices ; the web server  serves web Pages, as well as other web-related content, such as Java, Flash, XML, and so forth.","Each user of the social networking system  is associated with a user profile, which is stored in the user profile store . A user profile includes declarative information about the user that was explicitly shared by the user, and may also include profile information inferred by the social networking system . In one embodiment, a user profile includes multiple data fields, each data field describing one or more attributes of the corresponding user of the social networking system . The user profile information stored in user profile store  describes the users of the social networking system , including biographic, demographic, and other types of descriptive information, such as work experience, educational history, gender, hobbies or preferences, location and the like. A user profile may also store other information provided by the user, for example, images or videos. In certain embodiments, images of users may be tagged with identification information of users of the social networking system  displayed in an image. A user profile in the user profile store  may also maintain references to actions by the corresponding user performed on content items in the content store  and stored in the edge store .","A user profile may be associated with one or more financial accounts, allowing the user profile to include data retrieved from or derived from a financial account. A user may specify one or more privacy settings, which are stored in the user profile, that limit information from a financial account that the social networking system  is permitted to access. For example, a privacy setting limits the social networking system  to accessing the transaction history of the financial account and not the current account balance. As another example, a privacy setting limits the social networking system  to a subset of the transaction history of the financial account, allowing the social networking system  to access transactions within a specified time range, transactions involving less than a threshold transaction amounts, transactions associated with specified vendor identifiers, transactions associated with vendor identifiers other than specified vendor identifiers or any suitable criteria limiting information from a financial account identified by a user that is accessible by the social networking system . In one embodiment, information from the financial account is stored in the user profile store . In other embodiments, it may be stored in the financial account store .","The content store  stores content items associated with a user profile, such as images, videos or audio files. Content items from the content store  may be displayed when a user profile is viewed or when other content associated with the user profile is viewed. For example, displayed content items may show images or video associated with a user profile or show text describing a user's status. Additionally, other content items may facilitate user engagement by encouraging a user to expand his connections to other users, to invite new users to the system or to increase interaction with the social network system by displaying content related to users, objects, activities, or functionalities of the social networking system . Examples of social networking content items include suggested connections or suggestions to perform other actions, media provided to, or maintained by, the social networking system  (e.g., pictures or videos), status messages or links posted by users to the social networking system, events, groups, Pages (e.g., representing an organization or commercial entity), and any other content provided by, or accessible via, the social networking system.","The content store  also includes one or more Pages associated with entities having user profiles in the user profile store . An entity is a non-individual user of the social networking system , such as a business, a vendor, an organization or a university. A Page includes content associated with an entity and instructions for presenting the content to a social networking system user. For example, a Page identifies content associated with the entity's user profile as well as information describing how to present the content to users viewing the brand Page. Vendors may be associated with Pages in the content store , allowing social networking system users to more easily interact with the vendor via the social networking system . A vendor identifier is associated with a vendor's Page, allowing the social networking system  to identify the vendor and\/or to retrieve additional information about the vendor from the user profile store , the action log  or from any other suitable source using the vendor identifier. In some embodiments, the content store  may also store one or more targeting criteria associated with stored objects and identifying one or more characteristics of a user to which the object is eligible to be presented.","The action logger  receives communications about user actions on and\/or off the social networking system , populating the action log  with information about user actions. Such actions may include, for example, a user \u201cLiking\u201d a Page, adding a connection to another user, sending a message to another user, uploading an image, reading a message from another user, viewing content associated with another user, attending an event posted by another user, among others. The information associated with some of the above described user actions could include the time stamp of when the user action was performed by the user, such as the time stamp of when the user \u201cLiked\u201d a Page.","In some embodiments, the action logger  receives, subject to one or more privacy settings, transaction information from a financial account associated with a user and identifies user actions from the transaction information. For example, the action logger  retrieves vendor identifiers from the financial account's transaction history and identifies an object, such as a Page, in the social networking system associated with the vendor identifier. This allows the action logger  to identify a user's purchases of products or services that are associated with a Page, or another object, in the content store . In addition, a number of actions described in connection with other objects are directed at particular users, so these actions are associated with those users as well. These actions are stored in the action log .","The action log  may be used by the social networking system  to track user actions on the social networking system , as well as external website that communicate information to the social networking system . Users may interact with various objects on the social networking system , including commenting on posts, sharing links, and checking-in to physical locations via a mobile device, accessing content items in a sequence or other interactions. Information describing these actions is stored in the action log . Additional examples of interactions with objects on the social networking system  included in the action log  include commenting on a photo album, communications between users, becoming a fan of a musician, adding an event to a calendar, joining a groups, becoming a fan of a brand Page, creating an event, authorizing an application, using an application and engaging in a transaction. Additionally, the action log  records a user's interactions with advertisements on the social networking system  as well as other applications operating on the social networking system . In some embodiments, data from the action log  is used to infer interests or preferences of the user, augmenting the interests included in the user profile and allowing a more complete understanding of user preferences.","The action log  may also store user actions taken on external websites and\/or determined from a financial account associated with the user. For example, an e-commerce website that primarily sells sporting equipment at bargain prices may recognize a user of a social networking system  through social plug-ins that enable the e-commerce website to identify the user of the social networking system . Because users of the social networking system  are uniquely identifiable, e-commerce websites, such as this sporting equipment retailer, may use the information about these users as they visit their websites. The action log  records data about these users, including webpage viewing histories, advertisements that were engaged, purchases made, and other patterns from shopping and buying. Actions identified by the action logger  from the transaction history of a financial account associated with the user allow the action log  to record further information about additional types of user actions.","In one embodiment, an edge store  stores the information describing connections between users and other objects on the social networking system  in edge objects. Some edges may be defined by users, allowing users to specify their relationships with other users. For example, users may generate edges with other users that parallel the users' real-life relationships, such as friends, co-workers, partners, and so forth. Other edges are generated when users interact with objects in the social networking system , such as expressing interest in a Page (e.g., \u201cLiking\u201d the Page) on the social networking system, sharing a link with other users of the social networking system, and commenting on posts made by other users of the social networking system.","The edge store  stores edge objects that include information about the edge, such as the time the edge was created, affinity scores for objects, interests, and other users. Affinity scores may be computed by the social networking system  over time to approximate a user's affinity for an object, interest, and other users in the social networking system  based on the actions performed by the user. Multiple interactions between a user and a specific object may be stored in one edge object in the edge store , in one embodiment. In some embodiments, connections between users may be stored in the user profile store , or the user profile store  may access the edge store  to determine connections between users.","The lockstep detection engine  detects fraudulent content in a social network. In some embodiments, the lockstep detection engine  detects fraudulent content in the social networking system  by utilizing the method  disclosed in . Performing method , in step , the lockstep detection engine  identifies suspicious groups of users in the social network who display lockstep behavior. In some embodiments, the lockstep detection engine  identifies suspicious groups of users in the social network by identifying those groups of users who Like similar groups of Pages within a given duration of time (also referred to as \u201cwindow of time\u201d).  provides a flowchart of one possible method  used by the lockstep detection engine  to identify the group of suspicious users exhibiting lockstep behavior in the social networking system .","In step , the lockstep detection engine  identifies all the content data generated by the suspicious group of users within the social networking system . In some embodiments, the lockstep detection engine  identifies the content data generated by the suspicious group of users by analyzing the actions performed by each of the suspicious group of users within the social networking system . By analyzing each user's action log , the lockstep detection engine  identifies all the data generated by each of the performed actions. For example, if a user in the suspicious group of users has Liked a particular Page, then the data regarding the user's Like of the Page is content data generated by the suspicious group of users.","In step , the lockstep detection engine  determines the fraudulent portion of the content data generated by the suspicious group of users. In some embodiments, based on step , the lockstep detection engine  identifies those actions of the suspicious group of users that were performed in lockstep with each other. In one embodiment, the lockstep detection engine  considers only the data generated by those actions that were performed in lockstep to be fraudulent. In some embodiments, the lockstep detection engine  considers all data generated by the suspicious group of users as fraudulent.","The following section provides a detailed description of the various methods used by the lockstep detection engine  to identify the group of suspicious users exhibiting lockstep behavior. As discussed earlier, in some embodiments, the lockstep detection engine  detects suspicious groups of users in the social network by performing data clustering on both the users and the Pages to sub-group the users and Pages into one or more groups where each sub-group of users have an associated sub-group of Pages that they each Liked at around the same time. Such identified groups of users who each Liked a corresponding group of Pages at around the same time are considered suspicious groups of users. In some embodiments, the lockstep detection engine  considers a sub-group of users suspicious when each of the sub-group of users Liked at least a certain minimum number of Pages included in an associated sub-group of Pages at around the same time as one or more other users of the sub-group of users who also Liked those same Pages. In one embodiment, the certain minimum number of Pages that a given user should have Liked can be defined as a percentage of Pages (or \u03c1, where \u03c1\u03b5[0,1]) of the associated sub-group of Pages. In some embodiments, the lockstep detection engine  performs data clustering on both the users and the Pages by utilizing the method  disclosed in .",{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 2B","b":["220","155","220"]},"In the method , to identify the subset of suspicious users, data clustering on both the users and the Pages are performed to sub-group the users and Pages into one or more groups where each sub-group of users have an associated sub-group of Pages that they each Liked at around the same time. Here, the Like time is used as a constraint to cluster users into sub-groups of users with similar Like times for a sub-group of Pages.  provide an illustrative example of users and Pages before performing data clustering  and after performing data clustering  respectively. In , the users  and the Pages  are randomly distributed with each data point  representing the time  a given user liked a given Page, where the data points  exists only for those Pages that have a corresponding user who liked the Pages at some point in time. Further, each row  corresponds to a specific user of the social networking system  and each column  corresponds to a specific Page in the social networking system .","In , the users were reordered  to group users #1, #2, #3 with similar behavior (i.e. users who behaved similarly when Liking Pages). Similarly, the Pages were reordered  to group Pages B, C and D which all have similar time of Like  from the users #1, #2, #3, where like in , each data point  represents the time  a given user liked a given Page.  provides a graphical view of the reordered users - and reordered Pages -, where each edge - between each user - and each Page - represents the time each user - Liked a corresponding Page -.","In the method , to identify the subset of suspicious users, data clustering on both the users and the Pages are performed by iteratively clustering either the users into subsets (i.e. sub-groups) of users or the Pages into subsets of Pages while keeping the other constant until neither the subset of clustered users nor the Pages changes in response to further clustering. In each iterative step, the clustering of either the users or the Pages is improved by choosing new users (for the subset of users) or new Pages (for the subset of Pages), respectively, which increase the number of Likes the subset of users have for at least \u03c1*m Pages from the subset of Pages within a given time frame.","As discussed above, in the method , data is clustered to identify sub-group of users who have an associated sub-group of Pages that were Liked by one or more users of the sub-group of users at around the same time frame. The time frame ensures that only those users whose Like time of a given Page which happens around that of Like time of other users already included in the subset of users are included, resulting in convergence of the sub-group of users to an associated sub-group of Pages that were Liked by one or more users of the sub-group of users at around the same time. In the method , the data clustering is stopped when no new users or new Pages could be added to the subset of users or subset of Pages, respectively, which would increase the number of Likes the subset of users have for at least \u03c1*m Pages from the subset of Pages within the given time frame. At this point, the subsets of users who have similar Like times for the subset of Pages have converged and the subset of users represent the suspicious group of users who exhibit lockstep behavior in the social networking system .","Further, as discussed earlier, in the method , only those groups of users which include a minimum number of users who Liked a minimum number of Pages at around the same time are considered as suspicious groups of user. Here, if the converged subset of users are lesser than the minimum number of users (as described above) or if the subset of Pages Liked by the subset of users are lesser than the minimum number of Pages, the identified group of users are not considered as suspicious group of users exhibiting lockstep behavior in the social networking system .","Performing the method , the lockstep detection engine , in step , selects a random subset of users and a random subset of Pages from the available users and Pages in the social networking system  as a starting point to start the data clustering of both the users and Pages. In step , while keeping the subset of Pages constant, the lockstep detection engine  searches the available users to identify new users who could be included in the subset of users while removing existing users (if necessary) from the subset of users.","The lockstep detection engine  identifies which users to include and which users to exclude from the subset based on which combination of subset of users have a greater number of Likes for at least \u03c1*m Pages from the subset of Pages within a given time frame, resulting in convergence of the subset of users who each Liked at least \u03c1*m Pages from the subset of Pages at around the same time. As discussed earlier, for lockstep behavior, the time frame within which one or more users from the subset of users should have Liked the Pages included in the subset of Pages varies from Page to Page. However, the Like times of any two users (in the subset of users) for a given Page from the subset of Pages cannot be separated by more than a predefined value (e.g., 24 hours) for the Likes of the two users to be considered to be in lockstep behavior with respect to the given Page Liked by both the users.","For example, let the initial random subset of Pages include Pages \u201cA\u201d, \u201cB\u201d and \u201cC\u201d and the initial random subset of users could include users #1, #3 and #5. Here, user #1 Liked Page \u201cA\u201d at 6:30 am PST on Nov. 10, 2012 and Liked Page \u201cC\u201d at 9:30 pm PST on Dec. 12, 2012, while user #3 Liked Page \u201cA\u201d at 9:30 pm PST on Nov. 10, 2012 and Liked Page \u201cB\u201d at 4:30 am PST on Dec. 11, 2012, and user #5 Liked Page \u201cB\u201d at 6:30 am PST on Dec. 10, 2012. For each Page in the subset of Pages, a time frame window can be set such that the Likes of any two users for the Page cannot vary by more than the time frame window.","For example, let Page \u201cA\u201d have a time frame window of 24 hours, Page \u201cB\u201d have a time frame window of 10 hours, and Page \u201cC\u201d have a time frame window of 36 hours. In this example, the Like times of user #1 and #3 of Page \u201cA\u201d are separated by less than 24 hours (i.e. the time frame window of Page \u201cA\u201d) while Like times of user #3 and #5 of Page \u201cB\u201d is separated by more than 10 hours (i.e. the time frame window of Page \u201cB\u201d). So, when the number of Likes for Pages \u201cA\u201d, \u201cB\u201d and \u201cC\u201d from users #1, #3 and #5 that fall within a given time frame are computed, there are a total of 4 (i.e. the two Likes for Page \u201cA\u201d, one Like for Page \u201cB\u201d and the one Like for Page \u201cC\u201d). Here, only one of the Likes for Page \u201cB\u201d is counted as the other would fall outside the allowed time frame window to Like Page \u201cB\u201d (for lockstep behavior).","Further, in the above example, the lockstep detection engine , could consider including user #2 into the existing subset of users #1, #3 and #5, where user #2 Liked Page \u201cA\u201d at 5:30 am PST on Nov. 10, 2012 and Liked Page \u201cB\u201d at 2:00 pm PST on Dec. 11, 2012. In this example, the Like times of both user #1 and #3 of Page \u201cA\u201d from the Like time of user #2 of Page \u201cA\u201d are each separated by less than 24 hours (i.e. the time frame window of Page \u201cA\u201d). Similarly, the Like times of user #2 and #3 of Page \u201cB\u201d is separated by less than 10 hours (i.e. the time frame window of Page \u201cB\u201d) but the Like times of user #2 and #5 of Page \u201cB\u201d is separated by more than 10 hours. Given that the subset of users could only include those users who have Liked at least \u03c1*m Pages from the subset of Pages within a given time frame, the lockstep detection engine  would have a greater Like count by including user #2 (i.e. a total of 6 including the additional Likes for Pages \u201cA\u201d and \u201cB\u201d) and excluding user #5 from the subset of users (as only either user #2 or #5 could be in the subset of users as their Like time of Page \u201cB\u201d are separated by more than 10 hours and user #5 has no Likes for the other Pages in the subset of Pages).","In some embodiments, the lockstep detection engine , in step , limits the search for new users to be included in the subset of users to speed up the data clustering process. In some embodiments, the lockstep detection engine  limits the search for new users to be included in the subset of users to only those users of the social networking system  who have Liked one or more Pages in the subset of Pages close to the Like time of the existing subset of users for one or more Pages in the subset of Pages. In one instance, the a Like time of a new user (not included in the existing subset of users) of a given Page is considered close to the Like time of the existing subset of users for the given Page if it falls within 2\u00d7\u201ctime frame window\u201d of the given Page (e.g., 2\u00d724 hrs=48 hrs for Page \u201cA\u201d).","In step , while keeping the updated subset of users (i.e. subset of users determined in step ) constant, the lockstep detection engine  searches the available Pages to identify new Pages which could be included in the subset of Pages. The lockstep detection engine  identifies which Pages to include and which Pages to exclude from the subset based on which subset of Pages received a greater number of Likes for the Pages included in the subset of Pages from the subset of users within a given time frame. This results in convergence of the subset of Pages which received Likes from the subset of users at around the same time. As discussed earlier, for lockstep behavior, the time frame within which Pages included in the subset of Pages should have a Like from one or more users from the subset of users varies from Page to Page. However, the Like times of any two users (in the subset of users) for a given Page from the subset of Pages cannot be separated by more than a predefined value (e.g., 24 hours) for the Likes of the two users to be considered to be in lockstep behavior with respect to the given Page Liked by both the users.","In some embodiments, the lockstep detection engine , in step , limits the search for new Pages to be included in the subset of Pages to speed up the data clustering process. In some embodiments, the lockstep detection engine  limits the search for new Pages to be included in the subset of Pages to only those Pages of the social networking system  that has received a Like from one or more users of the subset of users who have also all (i.e. the one or more users who Liked the new Page) Liked at least one of the Pages from the existing subset of Pages within a given time frame. In some embodiments, the lockstep detection engine  could replace one of the Pages from the existing subset of Pages with one of the new Pages that has not only Likes from the one or more users of the subset of users who Liked the Page being replaced from the existing subset of Pages but also received Likes from other users in the subset of users who did not have a Like for the Page being replaced (thus, implicitly, increasing the number of Likes received by the new subset of Pages from the subset of users within a given time).","For example, let the subset of Pages include Pages \u201cA\u201d, \u201cB\u201d and \u201cC\u201d and the updated subset of users include users #1, #2 and #3. Here, user #1 Liked Page \u201cA\u201d at 6:30 am PST on Nov. 10, 2012 and Liked Page \u201cC\u201d at 9:30 pm PST on Dec. 12, 2012, user #2 Liked Page \u201cA\u201d at 5:30 am PST on Nov. 10, 2012 and Liked Page \u201cB\u201d at 2:00 pm PST on Dec. 11, 2012, and user #3 Liked Page \u201cA\u201d at 9:30 pm PST on Nov. 10, 2012 and Liked Page \u201cB\u201d at 4:30 am PST on Dec. 11, 2012. For each Page in the subset of Pages, a time frame window can be set such that the Likes of any two users for the Page cannot vary by more than the time frame window. For example, let Page \u201cA\u201d have a time frame window of 24 hours, Page \u201cB\u201d have a time frame window of 10 hours, and Page \u201cC\u201d have a time frame window of 36 hours.","Further, in the above example, the lockstep detection engine , could consider including Page \u201cD\u201d into the existing subset of Pages \u201cA\u201d, \u201cB\u201d and \u201cC\u201d, where Page \u201cD\u201d was Liked by user #1 at 5:30 am PST on Sep. 10, 2012 and by user #3 at 4:00 pm PST on Sep. 10, 2012. Page \u201cD\u201d has a time frame window of 36 hours. In this example, the time at which Page \u201cD\u201d was Liked by user #1 and #3 are separated by less than the allowed 36 hour time frame window. Also, similar to Page \u201cC\u201d, Page \u201cD\u201d also received a Like from user #1 with the given time frame. Further, unlike Page \u201cC\u201d, Page \u201cD\u201d also received another Like from user #3 within the given time frame. Therefore, the lockstep detection engine  could replace Page \u201cC\u201d with Page \u201cD\u201d in the subset of Pages and increase the number of Like counts from the subset of users for the subset of Pages within the given time frame (i.e. total like count to 7, including the additional Like for Page \u201cD\u201d, from the current total count of 6 for the existing subset of Pages, see discussion above).","As discussed above, performing the steps  and  of the method , the lockstep detection engine  clusters the users and Pages to identify sub-group of users who have an associated sub-group of Pages that were Liked by one or more users of the sub-group of users at around the same time. The time frame ensures that only those users whose Like time of a given Page which happens around that of Like time of other users already included in the subset of users are included, resulting in convergence of the sub-group of users to an associated sub-group of Pages that were Liked by one or more users of the sub-group of users at around the same time.","In step , the lockstep detection engine  compares the subset of users determined in step  and subset of users determined in step  with the previously existing subset of users (before any update in step ) and the previously existing subset of Pages (before any update in step ), respectively, to determine convergence of the clustered data (i.e. subset of users and Pages). If both the subset of users and Pages remain unchanged compared to the previously existing subset of users and Pages, respectively, the lockstep detection engine  determines convergence of the subset of users and Pages. In other words, the lockstep detection engine  determines that there are no new users in the vicinity (as explained earlier) of the subset of users who could be included to improve the number of Likes within a given time frame or no new Pages that could replace an existing Page in the subset of Pages that could improve the number of Likes within a given time frame. If either the subset of users or the subset of Pages has changed, the lockstep detection engine  determines that the subset of users and Pages could be further clustered and proceeds to step  before returning to step  to repeat the data clustering process (if necessary).","As discussed earlier, in method , a subset of users which include a predefined minimum number of users who have Liked a predefined minimum number of Pages at around the same time can be considered a suspicious group of users engaging in lockstep behavior. In some embodiments, the predefined minimum number of Pages and the predefined minimum number of Pages can be experimentally determined at the point where it reduces the number of false identification of users as engaging in lockstep behavior. So, even when the subset of users and Pages haven't completely converged and identified additional users and Pages, the current subset of identified users have shown lockstep behavior with respect to the current subset of identified Pages to be deemed as a suspicious group of users.","In step , the lockstep detection engine  determines if the un-converged subset of users and Pages include at least a predefined minimum number of users (say, \u201cn\u201d users) who each Liked at least \u03c1*m Pages from the subset of Pages within a predefined time window (say, 2\u0394t, where the predefined time window can change from one Page to another). When the condition is met, the lockstep detection engine  proceeds to step  and reports the subset of users as a suspicious group of users engaging in lockstep behavior. If the condition is not met, the lockstep detection engine  determines that the subset of users and Pages could be further clustered and returns to step  to repeat the data clustering process.","In step , if the lockstep detection engine  determines convergence, the lockstep detection engine  proceeds to step  and determines if the converged subset of users and Pages include at least a predefined minimum number of users (say, \u201cn\u201d users) who each Liked at least \u03c1*m Pages from the subset of Pages within a predefined time window (say, 2\u0394t, where the predefined time window can change from one Page to another). By checking to ensure the subset of users and Pages include at least a predefined minimum number of users and a predefined minimum number of Pages, respectively, the lockstep detection engine  reduces the false identification of users (as discussed above). When the condition is met, the lockstep detection engine  proceeds to step  and reports the subset of users as a suspicious group of users engaging in lockstep behavior. If the condition is not met, the lockstep detection engine  proceeds to step  and reports that no suspicious group of users engaging in lockstep behavior were identified.","By performing the method , the lockstep detection engine , thus, identifies suspicious groups of users whose social data content, in whole or in part, can be considered to be fraudulent and removed to maintain the integrity of the social data content in the social networking system .  provide a flowchart diagram of an illustrative serial and parallel process, respectively, to implement the method .",{"@attributes":{"id":"p-0071","num":"0070"},"figref":["FIG. 4","FIG. 3C"],"b":["400","220","400","342","346","348","352","354","374","400","155"]},"In process 4, to re-define the data clustering as a optimization problem, the lockstep detection engine  represents the users and Pages and the respective Like times of users to corresponding Pages as a M dimensional space (where M represents the number of available Pages in the social networking system ), where each dimension of the space represents the range of Like times for a given Page. In this M dimensional space, each user is represented as a point within the M dimensional space corresponding to their Like times of the Pages of the M dimensions that they have Liked before. Here, given that users do not necessarily Like all available M Pages (and therefore have only Likes times for a subset of the M Pages), each user falls into a subspace within the M dimensional space where they have a corresponding Like time for each of the Pages that correspond to a dimension of the subspace.",{"@attributes":{"id":"p-0073","num":"0072"},"figref":"FIG. 3D","b":["326","336","338","328","332","326","326","328","332","155","334","326","334"]},"As discussed in the method , performing process , the lockstep engine  identifies the hypercube  (also, referred to as the cluster) by iteratively alternating between updating the center c of the cluster  (where center c is simply a time of Like that lies in the center of all the other time of Likes included in the cluster ) and updating the subset of Pages \u2032 (i.e. Pages \u201cB\u201d, \u201cC\u201d and \u201cD\u201d) that are associated with the dimensions of the subspace, while holding the other (i.e. c or \u2032) constant. Here, updating the center c of the cluster  results in the change in the subset of users whose Like times are included in the cluster  similar to the step  in method . Similarly, updating the subset of Pages \u2032 results in replacing, if necessary, the Pages \u201cB\u201d, \u201cC\u201d and \u201cD\u201d with a new Page \u201cE\u201d similar to the step  in method . Further, similar to steps  and  in method , in process , the updates of the center c of the cluster  and the subset of Pages \u2032 are based on which update results in increased number of Like times of users that fall within the cluster .","A pseudo code of process  is shown below in \u201cProcess 1 Serial COPYCATCH.\u201d In process , updating center c of the cluster  is performed using function \u201cUPDATECENTER\u201d and updating subset of Pages \u2032 is performed using function \u201cUPDATESUBSPACE\u201d. In process , the center c of the cluster  and the subset of Pages \u2032 are iteratively updated till neither center c of the cluster or the subset of Pages \u2032 change (i.e. similar to method , there is data convergence for the subset of users in cluster  for the subset of Pages \u2032).",{"@attributes":{"id":"p-0076","num":"0075"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Process 1 Serial COPYCATCH"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"function S-COPYCATCH(x, j)"]},{"entry":[{},"\u2003\u2003Require: Preset parameters \u0394t, n, m, and \u03c1"]},{"entry":[{},"\u2003\u2003Initialize c = x, P\u2032 = {j}"]},{"entry":[{},"\u2003\u2003repeat"]},{"entry":[{},"\u2003\u2003\u2003\u2003P\u2032 = P\u2032"]},{"entry":[{},"\u2003\u2003\u2003\u2003c= c"]},{"entry":[{},"\u2003\u2003\u2003\u2003c = UPDATECENTER(c, P\u2032)"]},{"entry":[{},"\u2003\u2003\u2003\u2003P\u2032 = UPDATESUBSPACE(c, P\u2032)"]},{"entry":[{},"\u2003\u2003until c = cand P\u2032 = P\u2032"]},{"entry":[{},"return [c, P]"]},{"entry":[{},"end function"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The below listed Table 1 describes the various symbols used in the pseudo code:",{"@attributes":{"id":"p-0078","num":"0077"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Symbols and Definitions"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Symbol","Definition and Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["N and M","Number of users and Pages on either side of the"]},{"entry":[{},"bipartite graph"]},{"entry":["L","N \u00d7 M data matrix of edge (i.e. Like time) data"]},{"entry":["I","N \u00d7 M adjacency matrix"]},{"entry":["U and P","Set of indices of indexed users and Pages"]},{"entry":["n and m","Number of users and Pages necessary to be considered"]},{"entry":[{},"anomalous for each side of the bipartite graph"]},{"entry":["P\u2032","Subset of Pages that are anomalous"]},{"entry":["c","Vector of times for each Page around which there are"]},{"entry":[{},"anomalous users"]},{"entry":["2\u0394t","Width of time window"]},{"entry":["\u03c1","Percent of P\u2032 for which an anomalous user must be"]},{"entry":[{},"within the time window"]},{"entry":["\u03c6","Thresholding function to compare two data points"]},{"entry":["s","Number of clusters being search for in parallel"]},{"entry":["P","Set of P\u2032 for multiple clusters"]},{"entry":["C","Set of c for multiple clusters"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"In process , the UPDATECENTER function works similar to step  in method . To identify the center c for the cluster , while holding the subset of Pages \u2032, the UPDATECENTER function works by updating each dimension's (i.e. for each Page in the subset of Pages \u2032) center (i.e. a time of Like that lies in the center of all the other time of Likes included in the cluster  for that dimension) one at a time, holding the others constant. For each update in each dimension, we take all the Like times that are within search window \u03b2\u0394t (where the search for new users is limited to the vicinity \u03b2\u0394t of cluster to speed up the clustering process) of the previous center and find the center that will most improve our objective of finding more Likes than before that fall within the cluster . Here, all Like times previously covered by the cluster  will be included as the width of search window for \u03b2\u0394t is set to \u03b2>1. Further, the UPDATECENTER function moves the center c of the cluster  only if the function find a location within the subspace  that covers more Likes than before (where time of Likes in the cluster  that have more than one user with the same time of Likes are weighted accordingly when determining the number of Likes within the cluster ).","A pseudo code of the function UPDATECENTER, used in process , is shown below. The function UPDATECENTER includes sub-functions FINDUSERS and FINDCENTER. Sub-function FINDUSERS, as discussed earlier, identifies Like times of users in the vicinity of the cluster  which could be included to increase the count of Like times in the cluster  for the given subset of Pages. Using the Like times of users identified in FINDUSERS, sub-function FINDCENTER, as discussed earlier, updates the center c of cluster  to a location (i.e. to a new time of Like within the subspace ) that increases the number of time of Likes that fall within the cluster . Therefore, with every update of the center c the subset of users who have Like times within the cluster  are converging for the subset of Pages \u2032.",{"@attributes":{"id":"p-0081","num":"0080"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Function UPDATECENTER"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"function UPDATECENTER(c, P\u2032)"]},{"entry":[{},"\u2003\u2003U\u2032 = FINDUSERS(U, c, P\u2032)"]},{"entry":[{},"\u2003\u2003Set c\u2032 to the average of L* for all i \u03b5 U\u2032"]},{"entry":[{},"\u2003\u2003for j \u03b5 P\u2032 do"]},{"entry":[{},"\u2003\u2003\u2003\u2003[U\u2032, w] = FINDUSERS(U, c; P\u2032, j, \u03b2\u0394t )"]},{"entry":[{},"\u2003\u2003\u2003\u2003[U\u2033, t] = FINDCENTER(U\u2032, w, j)"]},{"entry":[{},"\u2003\u2003\u2003\u2003c\u2032= t"]},{"entry":[{},"\u2003\u2003end for"]},{"entry":[{},"return c\u2032"]},{"entry":[{},"end function"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Further, the pseudo code of the sub-functions FINDUSERS and FINDCENTER, used in function UPDATECENTER, are shown below:",{"@attributes":{"id":"p-0083","num":"0082"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Function FINDCENTER"]},{"entry":[{},"\u2003\u2003function FINDCENTER(U, w, j)"]},{"entry":[{},"\u2003\u2003\u2003\u2003Sort U by ufor i \u03b5 U"]},{"entry":[{},"\u2003\u2003\u2003\u2003Scan sorted U linearly for subset U\u2032 such that"]},{"entry":[{},"\u2003\u2003\u03a3, wis maximized"]},{"entry":[{},"\u2003\u2003\u2003\u2003Set cto the center of this subset U\u2032"]},{"entry":[{},"\u2003\u2003return [U\u2032, c]"]},{"entry":[{},"\u2003\u2003end function"]},{"entry":[{},"Function FINDUSERS"]},{"entry":[{},"\u2003\u2003function FINDUSERS(U, c, P\u2032, j, \u0394t\u2032)"]},{"entry":[{},"\u2003\u2003\u2003\u2003U\u2032 = { }, w = 0"]},{"entry":[{},"\u2003\u2003\u2003\u2003for i \u03b5 U do"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003for j \u03b5 P\u2032 do"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003if I= 1\u2009 \u2009(|c,L|<\u0394t \u2009 "]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003(j = j\u2009 \u2009|c,L|<\u0394t\u2032)) then"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003w= w+ 1"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003end if"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003end for"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003if w\u2267 \u03c1 m then"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003U\u2032 = U\u2032\u222a{i}"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003end if"]},{"entry":[{},"\u2003\u2003\u2003\u2003end for"]},{"entry":[{},"\u2003\u2003return [U\u2032, w]"]},{"entry":[{},"\u2003\u2003end function"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In process , the UPDATESUBSPACE function works similar to step  in method . To update the subset of Pages \u2032 that form the dimensions of the cluster  (i.e. the hypercube ), while holding the updated center c of cluster , determined using UPDATECENTER, constant, the UPDATESUBSPACE function works by identifying new Pages that could be included in the subset of Pages \u2032 such that more Like times of users are included within the cluster  for the present set of users who have one or more Like times currently included within the cluster . In one instance, the UPDATESUBSPACE function replaces one of the existing Pages (i.e. Pages \u201cB\u201d, \u201cC\u201d and \u201cD\u201d) with a new Page (e.g., Page \u201cA\u201d) that has not only received a Like for each of the users who have a Like time included in the cluster  for the replaced Page (e.g., Page \u201cB\u201d) but also increases the Like count within the cluster  by having received Likes from other users (i.e. users with Like time for Page \u201cC\u201d or \u201cD\u201d but not \u201cB\u201d) whose Like time is included in the cluster . Therefore, with every update of the subset of Pages \u2032, the number of Like times of a subset of users that fall within the cluster  for the subset of \u2032 increases, resulting in convergence of the subset of Pages \u2032 for the subset of users.","A pseudo code of the function UPDATESPACE, used in process , is shown below:",{"@attributes":{"id":"p-0086","num":"0085"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Function FINDUSERS"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"function UPDATESUBSPACE (c, P\u2032)",{}]},{"entry":[{},"\u2003\u2003P\u2032 = P\u2032"]},{"entry":[{},"\u2003\u2003U\u2032 = FINDUSERS (U,c,P\u2032)"]},{"entry":[{},"\u2003\u2003for j\u2032 \u03b5 P\u2032 do"]},{"entry":[{},"\u2003\u2003\u2003\u2003j\u2033 = j\u2032"]},{"entry":[{},"\u2003\u2003\u2003\u2003U\u2032= FINDUSERS (U\u2032,c,{j\u2033})"]},{"entry":[{},"\u2003\u2003\u2003\u2003for j \u03b5 P \\ P\u2032 do"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003U\u2032= FINDUSERS (U\u2032,c,{j})"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003if U\u2032\u2282 U\u2032then"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003j\u2033 = j, U\u2032= U\u2032"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003end if"]},{"entry":[{},"\u2003\u2003\u2003\u2003end for"]},{"entry":[{},"\u2003\u2003\u2003\u2003P\u2032 = (P\u2032\\{j\u2032})\u222a{j\u2033}"]},{"entry":[{},"\u2003\u2003end for"]},{"entry":[{},"return P\u2032"]},{"entry":[{},"end function"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"Performing process , in step , the lockstep detection engine  chooses a random subset of edges - between users and Pages from the social networking system  and initializes a cluster  with the Like times of the users associated with the edges - and initializes a subset of Pages P\u2032 with the Pages associated with the edges -. The lockstep detection engine  utilizes the initial cluster  and subset of Pages P\u2032 to start clustering the users and Pages from the social networking system  who exhibit lockstep behavior.","In step , while keeping the subset of Pages P\u2032 constant, the lockstep detection engine  updates the center c of the cluster . In some embodiment, the lockstep detection engine  updates the center c of the cluster  using the UPDATECENTER function discussed earlier. In step , using the updated center c of the cluster  received from step  while keeping the center c constant (i.e. the users with Like times within the cluster  constant), the lockstep detection engine  updates the subset of Pages P\u2032. In some embodiment, the lockstep detection engine  updates the subset of Pages P\u2032 using the UPDATESUBSPACE function discussed earlier.","In step  and , the lockstep detection engine  compares the center c of the cluster  before and after step  and the subset of Pages P\u2032 before and after step , respectively. If either the center c or the subset of Pages P\u2032 has changed, then the lockstep detection engine  determines that further convergence is possible (as discussed earlier) and returns to step  to repeat the clustering process utilizing the center c determined in earlier run of step  and the subset of Pages P\u2032 determined in earlier run of step .","If neither the center c nor the subset of Pages P\u2032 have changed, then the lockstep detection engine  determines convergence (as discussed earlier in the method ) and proceeds to step  to determine if the subset of users who have Like times in the cluster  that can be considered a suspicious group of users exhibiting lockstep behavior. In some embodiments, the lockstep detection engine  determines if there are at least \u201cn\u201d users in the subset of users who each Liked at least \u03c1*m Pages from the subset of Pages within a 2\u0394t window (i.e. the max distance from the center c). If the condition is met, the lockstep detection engine  then reports at least the \u201cn\u201d users as suspicious group of users exhibiting lockstep behavior. If the condition is not met, the lockstep detection engine  then reports that no suspicious group of users exhibiting lockstep behavior was found.",{"@attributes":{"id":"p-0091","num":"0090"},"figref":["FIG. 5","FIG. 6"],"b":["500","220","500","500","220"]},"As discussed above, MapReduce is a framework for processing parallelizable problems across huge datasets using a large number of computers - (also referred to as nodes), collectively referred to as a cluster. In MapReduce framework , the locality of data is utilized to process the data on or near the storage node storing the data to decrease transmission of data. In the MapReduce framework , the parallelization of a problem is performed using two two steps: a \u201cMap\u201d step - and a \u201cReduce\u201d step -.","In the \u201cMap\u201d step, a master node  (one of the nodes designated to manage all the other nodes) receives the problem data , , , divides it into smaller sub-problems -, and distributes the sub-problems - to worker nodes -. A worker node - may do this again in turn, leading to a multi-level tree structure. The worker node - processes the sub-problem -, and passes the answer - back to its master node .","In the \u201cReduce\u201d step, the master node  then collects the answers - to all the sub-problems - and combines them in some way to form the output , , , which is the answer to the problem the master node  was originally trying to solve. In some embodiments, similar to the \u201cMap\u201d step, the master node  performs the \u201cReduce\u201d step by dividing the \u201cReduce\u201d step into smaller sub-problems, and distributing the sub-problems to the worker nodes -. The worker node - processes the sub-problem, and passes the answer back to the master node .","MapReduce framework  allows for distributed processing of the map and reduction operations. Provided each mapping operation is independent of the others, all maps can be performed in parallel. Similarly, a set of \u2018reducers\u2019 (i.e. nodes) can perform the reduction step, provided all outputs of the map operation that should be combined are presented to the same reducer at the same time.","Logical Overview of the MapReduce Framework :","The Map and Reduce functions of MapReduce are both defined with respect to data structured in (key, value) pairs. Map takes one pair of data with a type in one data domain, and returns a list of pairs in a different domain: Map(k1,v1)->list(k2,v2).","The Map function is applied in parallel to every pair in the input dataset. This produces a list of pairs for each call. After that, the MapReduce framework collects all pairs with the same key from all lists and groups them together, creating one group for each key.","The Reduce function is then applied in parallel to each group, which in turn produces a collection of values in the same domain: Reduce(k2, list (v2, v3))->list(v4). Each Reduce call typically produces either one value v4 or an empty return, though one call is allowed to return more than one value. The returns of all calls are collected as the desired result list. Thus the MapReduce framework transforms a list of (key, value) pairs into a list of values.","For example, the MapReduce framework  can be used to count the total number of appearance of each word in an essay. In this example, the master node  would identify all the unique words in the essay and utilize each unique word as a key for the map. In the Map step, for each unique key k1 (i.e. word), the master node  could issue multiple jobs corresponding to a paragraph in the essay, where each paragraph in the essay constitutes the value v1. Each worker node - that receives a job (k1,v1) counts the number of times key k1 (i.e. unique word) appears in value v1 (i.e. paragraph) and returns a list (k2,v2) to the master node , where key k2 is the unique word (same as key k1) and v2 is the count of the number of times key k2 appeared in value v1.","In the Reduce step, the master node  can combine all the returned list with the same key as k2 and generate a list of values that corresponded to key k2. For example, here, the master node  could have received the count of key k2 in each paragraph (say there are five paragraphs in the essay) and produce a list with key k2, where the list includes the five returned values from the worker nodes - that each correspond to a paragraph in the essay. Next, the master node  could assign the reduce job to a reducer as a key-value pair to Reduce(k2, list (v2, v3, v4, v5, v6))->(k2, list(v7)). Here, the reducer simply adds the values in provided list and returns a key-value pair with the key as k2 and value v7 as the sum of the values in the provided list. The returned value will provide the count of the unique work that corresponds to key k2.",{"@attributes":{"id":"p-0102","num":"0101"},"figref":"FIG. 6","b":["600","220","500","400","600","334","326","334","326","600","105"]},"In process , the MapReduce framework  is utilized to parallelize the implementation of the method . In process , one MapReduce job is run per iteration of updating the center c of the multiple clusters and their associated subset of Pages P\u2032. A pseudo code of process  is shown below in \u201cProcess 2 MapReduce COPYCATCH\u201d:",{"@attributes":{"id":"p-0104","num":"0103"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Process 2 MapReduce COPYCATCH"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"1: Require: Preset parameters \u0394t, m, and \u03c1"]},{"entry":[{},"2: C, P = INITIALIZE( )"]},{"entry":[{},"3: repeat"]},{"entry":[{},"4: \u2003\u2003C= C, P= P"]},{"entry":[{},"5: \u2003\u2003C, P = MAPREDUCEJOB (C, P)"]},{"entry":[{},"6: until C= C\u2009 \u2009P= P"]},{"entry":[{},"7: return [C, P]"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"As explained earlier, the MapReduce job is performed in two steps: the Map step; and the Reduce step. In the Map step, the input is split among many worker nodes -. Each worker node - gets a pair of data of the form K, V), where Kcould be left as null and the Vcould a given user's time of Like for a subset of Pages the given user previously Liked, and returns an output zero or a result of the form (K, V). As explained below, the Kcould be a number identifying one of the multiple clusters the given user's times of Like fall within and the Vreturned could simply be same as the Vprovided as input to the worker nodes - (i.e. the given user's time of Like for a subset of Pages the given user previously Liked).","In process , in the reducer step, for each unique K(i.e. a number identifying one of the multiple clusters), a reducer is formed which takes as an input (K, V), where Vis a set of the Voutputs (i.e. the time of Like for a corresponding set of Pages for each user identified in the Map step) from the Map step which correspond to that reducer's particular K. For a given cluster that corresponds to K, the reducer then updates the center c of the cluster and the subset of Pages P\u2032 associated with that cluster and returns the updated center c of the cluster and the subset of Pages P\u2032 to the master node . Similar to process , in process , the master node  compares the returned clusters and their subset of Pages P\u2032 against the prior version of the clusters and their subset of Pages P\u2032 to determine convergence (i.e. if unchanged, then converged). In process , if the master node  determines the data has not converged, the master node  initiates another iteration of MapReduce Job with the updated set of clusters and their associated subset of Pages P\u2032.","In our process , the worker node - utilizes a UMfunction to perform the Map step. A pseudo code of the function UM, used in process , is shown below. The function UM, as discussed earlier, takes as input a given user's time of Like for a subset of Pages the given user previously Liked. Based on the provided Like times of the given user, the UMchecks across each of the multiple clusters to see if the time of Likes of the given user falls within that cluster (as explained earlier in process ). If the time of Likes of the given user does fall within a given cluster, an ID of the given cluster (identifying the cluster) is outputted as a key \u201cK\u201d, and the time of Like for a subset of Pages the given user previously Liked is outputted as value \u201cV\u201d in the form (K, V).",{"@attributes":{"id":"p-0108","num":"0107"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Procedure 3 UserMapper(\u2009 \u2009NULL, (L,I)\u2009 \u2009)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"1: Globals: C, P"]},{"entry":[{},"2: for k = 1 . . . s do"]},{"entry":[{},"3: \u2003\u2003\u03c3 = \u03a3\u2032I\u00b7 \u03c6(c,L)"]},{"entry":[{},"4: \u2003\u2003if \u03c3 \u2267 \u03c1m then"]},{"entry":[{},"5: \u2003\u2003\u2003\u2003emit \u2009 \u2009k,(L,I)\u2009 "]},{"entry":[{},"6: \u2003\u2003end if"]},{"entry":[{},"7: end for"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"where, function \u03c6 is defined in expression (1), as shown below:",{"@attributes":{"id":"p-0110","num":"0109"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mi":"\u03d5","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":["t","c"]},{"mi":["t","u"]}],"mo":","}}},{"mo":"{","mtable":{"mtr":[{"mtd":[{"mn":"1"},{"mrow":{"mrow":[{"mi":"if","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mo":["\uf603","\uf604"],"mrow":{"msub":[{"mi":["t","c"]},{"mi":["t","u"]}],"mo":"-"}}},{"mi":["\u0394","t"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}],"mo":"\u2264"}}]},{"mtd":[{"mn":"0"},{"mi":"otherwise"}]}]}}],"mo":"="}},{"mrow":{"mo":["(",")"],"mn":"1"}}]}}}}},"In our process , the worker node - utilizes an AC-Rfunction to perform the Reduce step. A pseudo code of the function AC-R, used in process , is shown below:",{"@attributes":{"id":"p-0112","num":"0111"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Procedure 4 ADJUSTCLUSTER-REDUCER(k, U\u2032)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"1:","Globals: C, P"]},{"entry":[{},"2:","Initialize c = 0, p = 0, v = 0"]},{"entry":[{},"3:","for all map values (L,I)\u03b5 U\u2032 do"]},{"entry":[{},"4:","\u2003for j = 1 . . . M do"]},{"entry":[{},"5:","\u2003\u2003if I= 1\u2009 \u2009\u03c6(c,L) = 1 then"]},{"entry":[{},"6:","\u2003\u2003\u2003c= c+ L"]},{"entry":[{},"7:","\u2003\u2003\u2003p= p+ 1"]},{"entry":[{},"8:","\u2003\u2003\u2003v= v+ (c\u2212 L)"]},{"entry":[{},"9:","\u2003\u2003end if"]},{"entry":[{},"10:","\u2003end for"]},{"entry":[{},"11:","end for"]},{"entry":[{},"12:","c= c\/p"]},{"entry":[{},"13:","v = v\/p"]},{"entry":[{},"14:","Sort {j}by p (decreasing), then v (increasing)"]},{"entry":[{},"15:","Set P\u2032 to top m columns from previous sort"]},{"entry":[{},"16:","return Updated cand P\u2032"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"The function AC-R, as discussed earlier, receives an input (K, V), where Kis the ID of a given cluster and the Vis a set of the Voutputs (i.e. the time of Like for a corresponding set of Pages for each user identified in the Map step) from the Map step which correspond to the particular K. For the given cluster that corresponds to K, the AC-Rfunction then updates the center c of the given cluster and the subset of Pages P\u2032 associated with the given cluster and returns the updated center c of the cluster and the subset of Pages P\u2032 to the master node . In function AC-R, the center c of the cluster is updated in each dimension (i.e. each Page in the subset of Pages P\u2032 that correspond to a dimension) by taking an average of the time of Likes of all the users who fall within the cluster in that dimension.","Further, in function AC-R, the subset of Pages P\u2032 are updated by selecting the Pages (from the available Pages M in the social networking system ) that cover the most users (who have a time of Like) within the previous cluster (i.e. before the center c of the cluster is updated), and also have the least variance among the users who Liked the subset of Pages P\u2032. As discussed earlier, such a process can potentially drive the subset of users and Pages to converge.","Performing process , in step , the lockstep detection engine  chooses a random subsets of edges - between users and Pages from the social networking system  and initializes a set of clusters with the Like times of the users associated a corresponding subset of edges -. Further, the lockstep detection engine  initializes each subset of Pages P\u2032 associated with each of the set of clusters with the Pages associated with the corresponding subset of edges -. The lockstep detection engine  utilizes the initial set of clusters  and their associated subsets of Pages P\u2032 to start clustering the users and Pages from the social networking system  who exhibit lockstep behavior.","In step , the lockstep detection engine  performs the Map step of the MapReduce job on the set of clusters and their associated subsets of Pages P\u2032. As discussed earlier, in the Map step , using the UMfunction, for each of the set of clusters, the lockstep detection engine  determines all the users whose time of Likes for the subset of Pages P\u2032 (associated with the given cluster) falls within the cluster. Next, in Map step , the lockstep detection engine  receives, for each of the identified user who falls within any of the set of clusters, a key-value pair of the ID of the cluster the user falls into and the corresponding times of Like of the user.","In step , the lockstep detection engine  performs the Reduce step of the MapReduce job on the set of clusters and their associated subsets of Pages P\u2032. As discussed earlier, in the Reduce step , the lockstep detection engine  combines the users who fall within a cluster into a key-value pair and performs a reduction of the data using the AC-Rfunction. In step , using the received times of Like of each user who falls within a given cluster, the lockstep detection engine  updates the center c of the cluster. In step , the lockstep detection engine  updates the subset of Pages P\u2032 by selecting the Pages (from the available Pages M in the social networking system ) that cover the most users (who have a time of Like) within the previous cluster (i.e. before the center c of the cluster is updated), and also have the least variance among the users who Liked the subset of Pages P\u2032. In step , the lockstep detection engine  receives the updated center c of the cluster and the subset of Pages P\u2032.","In step , the lockstep detection engine  compares all the center c of the set of clusters before and after MapReduce and the subsets of Pages P\u2032 before and after MapReduce. If either any of the center c or the any of subsets of Pages P\u2032 have changed, then the lockstep detection engine  determines that further convergence is possible (as discussed earlier) and returns to step  to repeat the clustering process utilizing the MapReduce job.","If neither the centers c nor the subsets of Pages P\u2032 have changed, then the lockstep detection engine  determines convergence (as discussed earlier in the method ) and proceeds to step  to determine if any of the subsets of users who have Like times in the set of clusters can be considered a suspicious group of users exhibiting lockstep behavior. In some embodiments, the lockstep detection engine  determines if there are at least \u201cn\u201d users in the subset of users who each Liked at least \u03c1*m Pages from the subset of pages within a 2\u0394t window (i.e. the max distance from the center c). If the condition is met, the lockstep detection engine  then reports at least the \u201cn\u201d users in the subset of users as suspicious group of users exhibiting lockstep behavior. If the condition is not met, the lockstep detection engine  then reports that no suspicious group of users exhibiting lockstep behavior was found.",{"@attributes":{"id":"p-0120","num":"0119"},"figref":["FIG. 7","FIGS. 1-6","FIG. 7"],"b":["700","700","705","710","715","715","715"]},"The processor(s)  is\/are the central processing unit (CPU) of the processing system  and, thus, control the overall operation of the processing system . In certain embodiments, the processor(s)  accomplish this by executing software or firmware stored in memory . The processor(s)  may be, or may include, one or more programmable general-purpose or special-purpose microprocessors, digital signal processors (DSPs), programmable controllers, application specific integrated circuits (ASICs), programmable logic devices (PLDs), trusted platform modules (TPMs), or the like, or a combination of such devices.","The memory  is or includes the main memory of the processing system . The memory  represents any form of random access memory (RAM), read-only memory (ROM), flash memory, or the like, or a combination of such devices. In use, the memory  may contain a code. In one embodiment, the code includes a general programming module configured to recognize the general-purpose program received via the computer bus interface, and prepare the general-purpose program for execution at the processor. In another embodiment, the general programming module may be implemented using hardware circuitry such as ASICs, PLDs, or field-programmable gate arrays (FPGAs).","Also connected to the processor(s)  through the interconnect  are a network adapter , a storage device(s)  and I\/O device(s) . The network adapter  provides the processing system  with the ability to communicate with remote devices, over a network and may be, for example, an Ethernet adapter or Fibre Channel adapter. The network adapter  may also provide the processing system  with the ability to communicate with other computers within the cluster. In some embodiments, the processing system  may use more than one network adapter to deal with the communications within and outside of the cluster separately.","The I\/O device(s)  can include, for example, a keyboard, a mouse or other pointing device, disk drives, printers, a scanner, and other input and\/or output devices, including a display device. The display device can include, for example, a cathode ray tube (CRT), liquid crystal display (LCD), or some other applicable known or convenient display device.","The code stored in memory  can be implemented as software and\/or firmware to program the processor(s)  to carry out actions described above. In certain embodiments, such software or firmware may be initially provided to the processing system  by downloading it from a remote system through the processing system  (e.g., via network adapter ).","The techniques introduced herein can be implemented by, for example, programmable circuitry (e.g., one or more microprocessors) programmed with software and\/or firmware, or entirely in special-purpose hardwired (non-programmable) circuitry, or in a combination of such forms. Special-purpose hardwired circuitry may be in the form of, for example, one or more ASICs, PLDs, FPGAs, etc.","Software or firmware for use in implementing the techniques introduced here may be stored on a machine-readable storage medium and may be executed by one or more general-purpose or special-purpose programmable microprocessors. A \u201cmachine-readable storage medium\u201d, as the term is used herein, includes any mechanism that can store information in a form accessible by a machine.","A machine can also be a server computer, a client computer, a personal computer (PC), a tablet PC, a laptop computer, a set-top box (STB), a personal digital assistant (PDA), a cellular telephone, an iPhone, a Blackberry, a processor, a telephone, a web appliance, a network router, switch or bridge, or any machine capable of executing a set of instructions (sequential or otherwise) that specify actions to be taken by that machine.","A machine-accessible storage medium or a storage device(s)  includes, for example, recordable\/non-recordable media (e.g., ROM; RAM; magnetic disk storage media; optical storage media; flash memory devices; etc.), etc., or any combination thereof. The storage medium typically may be non-transitory or include a non-transitory device. In this context, a non-transitory storage medium may include a device that is tangible, meaning that the device has a concrete physical form, although the device may change its physical state. Thus, for example, non-transitory refers to a device remaining tangible despite this change in state.","The term \u201clogic\u201d, as used herein, can include, for example, programmable circuitry programmed with specific software and\/or firmware, special-purpose hardwired circuitry, or a combination thereof."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["These and other objects, features and characteristics of the present invention will become more apparent to those skilled in the art from a study of the following detailed description in conjunction with the appended claims and drawings, all of which form a part of this specification. In the drawings:",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":["FIG. 2","FIGS. 2(A) and 2(B)"]},{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 3","FIGS. 3(A)"],"b":["3","3","3"]},{"@attributes":{"id":"p-0012","num":"0011"},"figref":["FIG. 4","FIG. 2"]},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 6","FIG. 2"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
