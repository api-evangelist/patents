---
title: Method, apparatus and system for rendering an object on a page
abstract: A method of rendering a graphical object (e.g., ) on a page (), is disclosed. A region of the page containing the graphical object () is marked as output incompatible based on the graphical object () being output incompatible. A bounding box comprising the marked region is determined. A proportion of a number of the regions marked as output incompatible are determined to a total number of regions in the bounding box. A further region within the bounding box is marked as output incompatible to increase the determined proportion above a threshold. The graphical object in the marked region and the further marked region is converted into an output compatible graphical object if the determined proportion is above the threshold. The output compatible graphical object is rendered.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09361555&OS=09361555&RS=09361555
owner: Canon Kabushiki Kaisha
number: 09361555
owner_city: Tokyo
owner_country: JP
publication_date: 20150708
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DESCRIPTION OF THE EMBODIMENTS","INDUSTRIAL APPLICABILITY"],"p":["The present application is a Divisional of U.S. patent application Ser. No. 13\/533,695 filed Jun. 26, 2012, which claims the benefit of priority from Australian Patent Application No. 2011203173 filed Jun. 29, 2011, each of which is hereby incorporated by reference herein in their entirety.","1. Field of the Invention","The current invention relates to graphics processing and, in particular, to a method and apparatus for rendering an object on a page. The current invention also relates to a computer program product including a computer readable medium having recorded thereon a computer program for rendering an object on a page.","2. Description of the Related Art","The printing process in modern operating systems, typically involves steps of invoking drawing functions, converting the drawing functions into a standardized format (e.g. PDF or XPS), and spooling the standardized format drawing functions to a printer driver. The printer driver may contain an interpreter which parses the standardized format drawing functions, and converts the standardized format drawing functions into drawing instructions that are accepted by a printer driver rendering engine. The printer driver rendering engine typically renders the drawing instructions to pixels, and sends the pixels to a printer which prints the pixels onto paper.","Some printers have limited rendering functionality. A printer driver used by such printers may contain an interpreter that parse the standardized format into certain printer-recognizable graphical objects and drawing instructions that are accepted by the printer. The printer driver sends the generated graphical objects and drawing instructions to the printer. The printer then renders the graphical objects and drawing instructions into pixels.","Conventional methods for converting graphical objects and drawing instructions parsed from the standardized format into limited, printer-supported graphical objects, typically include processes for translating any printer-compatible graphical objects and drawing instructions directly into a printer-recognizable format. Such methods typically also include processes for rendering any printer-incompatible graphical objects and drawing instructions into pixels. The conventional methods for converting graphical objects and drawing instructions into limited, printer-supported graphical objects may result in a large amount of image data being sent to the printer, especially when there is lots of overlap between printer-compatible objects and printer-incompatible objects. The large amount of image data often results in a slow printing speed.","Thus, a need clearly exists for a better and more efficient printing method that will result in a faster printing speed. printing process in modern operating systems, typically involves steps of invoking drawing functions, converting the drawing functions into a standardized format","According to one aspect of the present disclosure there is provided a method of rendering a graphical object on a page, the method including:","marking a region of the page containing the graphical object as output incompatible based on the graphical object being output incompatible;","determining a bounding box including the marked region;","determining a proportion of a number of the regions marked as output incompatible to a total number of regions in the bounding box;","marking a further region within the bounding box as output incompatible to increase the determined proportion above a threshold;","converting the graphical object in the marked region and the further marked region into an output compatible graphical object if the determined proportion is above the threshold; and","rendering the output compatible graphical object.","According to another aspect of the present disclosure there is provided a method of rendering a graphical object on a page, the method including:","marking a first region of the page containing the graphical object as output incompatible based on the graphical object being output incompatible;","determining a distance of a second region from the first region;","marking the second region as output incompatible, if the determined distance satisfies a threshold;","converting graphical objects within the first and the second region as output compatible; and","rendering the output compatible objects.","According to still another aspect of the present disclosure there is provided a method of rendering a graphical object on a page, the method including:","determining a size of the graphical object to be rendered on the page;","marking a region of the page as output incompatible if (a) the graphical object is output incompatible, and (b) the determined size of the graphical object is larger than a threshold;","converting the graphical object into an output compatible graphical object; and","rendering the output compatible object to a renderer for rendering.","According to still another aspect of the present disclosure there is provided a system for rendering a graphical object on a page, the system including:","a memory for storing data and a computer program;","a processor coupled to the memory for executing the computer program, the computer program including instructions for:","marking a region of the page containing the graphical object as output incompatible based on the graphical object being output incompatible;","determining a bounding box including the marked region;","determining a proportion of a number of the regions marked as output incompatible to a total number of regions in the bounding box;","marking a further region within the bounding box as output incompatible to increase the determined proportion above a threshold;","converting the graphical objects in the marked region and the further marked region into an output compatible graphical object if the determined proportion is above the threshold; and","rendering the output compatible graphical object.","According to still another aspect of the present disclosure there is provided a system for rendering a graphical object on a page, the system including:","a memory for storing data and a computer program;","a processor coupled to the memory for executing the computer program, the computer program including instructions for:","marking a first region of the page containing the graphical object as output incompatible based on the graphical object being output incompatible;","determining a distance of a second region from the first region;","marking the second region as output incompatible, if the determined distance satisfies a threshold;","converting graphical objects within the first and the second region as output compatible; and","rendering the output compatible graphical objects.","According to still another aspect of the present disclosure there is provided an apparatus for rendering a graphical object on a page, the apparatus including:","means for marking a region of the page as output incompatible based on the mapped graphical object being output incompatible;","means for determining a bounding box including the marked region;","means for determining a proportion of a number of the regions marked as output incompatible to a total number of regions in the bounding box;","means for marking a further region within the bounding box as output incompatible to increase the determined proportion above a threshold;","means for converting the graphical object in the marked region and the further marked region into an output compatible graphical object if the determined proportion is above the threshold; and","means for rendering the output compatible graphical object.","According to still another aspect of the present disclosure there is provided an apparatus for rendering a graphical object on a page, the apparatus including:","means for marking a first region of the page containing the graphical object as output incompatible based on the graphical object being output incompatible;","means for determining a distance of a second region from the first region;","means for marking the second region as output incompatible, if the determined distance satisfies a threshold;","means for converting graphical objects within the first and the second region as output compatible; and","means for rendering the output compatible objects.","According to still another aspect of the present disclosure there is provided a computer readable medium having a computer program recorded thereon for rendering a graphical object on a page, the computer program including:","code for marking a region of the page containing the graphical object as output incompatible based on the graphical object being output incompatible;","code for determining a bounding box including the marked region;","code for determining a proportion of a number of the regions marked as output incompatible to a total number of regions in the bounding box;","code for marking a further region within the bounding box as output incompatible to increase the determined proportion above a threshold;","code for converting the graphical object in the marked region and the further marked region into an output compatible graphical object if the determined proportion is above the threshold; and","code for rendering the output compatible graphical object.","According to still another aspect of the present disclosure there is provided a computer readable medium having a computer program recorded thereon for rendering a graphical object on a page, the computer program including:","code for marking a first region of the page containing the graphical object as output incompatible based on the graphical object being output incompatible;","code for determining a distance of a second region from the first region;","code for marking the second region as output incompatible, if the determined distance satisfies a threshold;","code for converting graphical objects within the first and the second region as output compatible; and","code for rendering the output compatible objects.","Other aspects of the invention are also disclosed.","Where reference is made in any one or more of the accompanying drawings to steps and\/or features, which have the same reference numerals, those steps and\/or features have for the purposes of this description the same function(s) or operation(s), unless the contrary intention appears.","A method  (see ) of rendering a graphical object on a page, is described below with reference to . The method  takes into account a compatible\/incompatible property of the graphical object as well as other properties of the graphical object, such as object type and size as well as overlap.",{"@attributes":{"id":"p-0086","num":"0085"},"figref":"FIGS. 1A and 1B","b":["100","300"]},"As seen in , the computer system  includes: a computer module ; input devices such as a keyboard , a mouse pointer device , a scanner , a camera , and a microphone ; and output devices including a printer , a display device  and loudspeakers . An external Modulator-Demodulator (Modem) transceiver device  may be used by the computer module  for communicating to and from a communications network  via a connection . The communications network  may be a wide-area network (WAN), such as the Internet, a cellular telecommunications network, or a private WAN. Where the connection  is a telephone line, the modem  may be a traditional \u201cdial-up\u201d modem. Alternatively, where the connection  is a high capacity (e.g., cable) connection, the modem  may be a broadband modem. A wireless modem may also be used for wireless connection to the communications network .","The computer module  typically includes at least one processor unit , and a memory unit . For example, the memory unit  may have semiconductor random access memory (RAM) and semiconductor read only memory (ROM). The computer module  also includes a number of input\/output (I\/O) interfaces including: an audio-video interface  that couples to the video display , loudspeakers  and microphone ; an I\/O interface  that couples to the keyboard , mouse , scanner , camera  and optionally a joystick or other human interface device (not illustrated); and an interface  for the external modem  and printer . In some implementations, the modem  may be incorporated within the computer module , for example within the interface . The computer module  also has a local network interface , which permits coupling of the computer system  via a connection  to a local-area communications network , known as a Local Area Network (LAN). As illustrated in , the local communications network  may also couple to the wide network  via a connection , which would typically include a so-called \u201cfirewall\u201d device or device of similar functionality. The local network interface  may comprise an Ethernet\u2122 circuit card, a Bluetooth\u2122 wireless arrangement or an IEEE 802.11 wireless arrangement; however, numerous other types of interfaces may be practiced for the interface .","The I\/O interfaces  and  may afford either or both of serial and parallel connectivity, the former typically being implemented according to the Universal Serial Bus (USB) standards and having corresponding USB connectors (not illustrated). Storage devices  are provided and typically include a hard disk drive (HDD) . Other storage devices such as a floppy disk drive and a magnetic tape drive (not illustrated) may also be used. An optical disk drive  is typically provided to act as a non-volatile source of data. Portable memory devices, such optical disks (e.g., CD-ROM, DVD, Blu-ray Disc\u2122), USB-RAM, portable, external hard drives, and floppy disks, for example, may be used as appropriate sources of data to the system .","The components  to  of the computer module  typically communicate via an interconnected bus  and in a manner that results in a conventional mode of operation of the computer system  known to those in the relevant art. For example, the processor  is coupled to the system bus  using a connection . Likewise, the memory  and optical disk drive  are coupled to the system bus  by connections . Examples of computers on which the described arrangements can be practised include IBM-PC's and compatibles, Sun Sparcstations, Apple Mac\u2122 or a like computer systems.","The described methods, including the method , may be implemented using the computer system  wherein the processes of , to be described, may be implemented as one or more software application programs  executable within the computer system . In particular, the steps of the described method  are effected by instructions  (see ) in the software application program  that are carried out within the computer system . The software instructions  may be formed as one or more software code modules, each for performing one or more particular tasks. The software application program  may also be divided into two separate parts, in which a first part and the corresponding software code modules performs the described methods and a second part and the corresponding software code modules manage a user interface between the first part and the user.","The software application program  may be stored in a computer readable medium, including the storage devices described below, for example. The software application program  is loaded into the computer system  from the computer readable medium, and is then executed by the computer system . A computer readable medium having such software or computer program recorded on the computer readable medium is a computer program product. The use of the computer program product in the computer system  preferably effects an advantageous apparatus for implementing the described methods.","The software application program  is typically stored in the HDD  or the memory . The software application program  is loaded into the computer system  from a computer readable medium, and executed by the computer system . Thus, for example, the software application program  may be stored on an optically readable disk storage medium (e.g., CD-ROM)  that is read by the optical disk drive .","In some instances, the software application program  may be supplied to the user encoded on one or more CD-ROMs  and read via the corresponding drive , or alternatively may be read by the user from the networks  or . Still further, the software application program  can also be loaded into the computer system  from other computer readable media. Computer readable storage media refers to any non-transitory tangible storage medium that provides recorded instructions and\/or data to the computer system  for execution and\/or processing. Examples of such storage media include floppy disks, magnetic tape, CD-ROM, DVD, Blu-ray Disc, a hard disk drive, a ROM or integrated circuit, USB memory, a magneto-optical disk, or a computer readable card such as a PCMCIA card and the like, whether or not such devices are internal or external of the computer module . Examples of transitory or non-tangible computer readable transmission media that may also participate in the provision of software, application programs, instructions and\/or data to the computer module  include radio or infra-red transmission channels as well as a network connection to another computer or networked device, and the Internet or Intranets including e-mail transmissions and information recorded on Websites and the like.","The second part of the software application program  and the corresponding software code modules mentioned above may be executed to implement one or more graphical user interfaces (GUIs) to be rendered or otherwise represented upon the display . Through manipulation of typically the keyboard  and the mouse , a user of the computer system  and the application may manipulate the interface in a functionally adaptable manner to provide controlling commands and\/or input to the applications associated with the GUI(s). Other forms of functionally adaptable user interfaces may also be implemented, such as an audio interface utilizing speech prompts output via the loudspeakers  and user voice commands input via the microphone .",{"@attributes":{"id":"p-0096","num":"0095"},"figref":["FIG. 1B","FIG. 1A"],"b":["105","134","134","109","106","101"]},"When the computer module  is initially powered up, a power-on self-test (POST) program  executes. The POST program  is typically stored in a ROM  of the semiconductor memory  of . A hardware device such as the ROM  storing software is sometimes referred to as firmware. The POST program  examines hardware within the computer module  to ensure proper functioning and typically checks the processor , the memory  (, ), and a basic input-output systems software (BIOS) module , also typically stored in the ROM , for correct operation. Once the POST program  has run successfully, the BIOS  activates the hard disk drive  of . Activation of the hard disk drive  causes a bootstrap loader program  that is resident on the hard disk drive  to execute via the processor . This loads an operating system  into the RAM memory , upon which the operating system  commences operation. The operating system  is a system level application, executable by the processor , to fulfil various high level functions, including processor management, memory management, device management, storage management, software application interface, and generic user interface.","The operating system  manages the memory  (, ) to ensure that each process or application running on the computer module  has sufficient memory in which to execute without colliding with memory allocated to another process. Furthermore, the different types of memory available in the system  of  must be used properly so that each process can run effectively. Accordingly, the aggregated memory  is not intended to illustrate how particular segments of memory are allocated (unless otherwise stated), but rather to provide a general view of the memory accessible by the computer system  and how such is used.","As shown in , the processor  includes a number of functional modules including a control unit , an arithmetic logic unit (ALU) , and a local or internal memory , sometimes called a cache memory. The cache memory  typically includes a number of storage registers - in a register section. One or more internal busses  functionally interconnect these functional modules. The processor  typically also has one or more interfaces  for communicating with external devices via the system bus , using a connection . The memory  is coupled to the bus  using a connection .","The software application program  includes a sequence of instructions  that may include conditional branch and loop instructions. The software application program  may also include data  which is used in execution of the program . The instructions  and the data  are stored in memory locations , ,  and , , , respectively. Depending upon the relative size of the instructions  and the memory locations -, a particular instruction may be stored in a single memory location as depicted by the instruction shown in the memory location . Alternately, an instruction may be segmented into a number of parts each of which is stored in a separate memory location, as depicted by the instruction segments shown in the memory locations  and .","In general, the processor  is given a set of instructions which are executed therein. The processor  waits for a subsequent input, to which the processor  reacts to by executing another set of instructions. Each input may be provided from one or more of a number of sources, including data generated by one or more of the input devices , , data received from an external source across one of the networks , , data retrieved from one of the storage devices ,  or data retrieved from a storage medium  inserted into the corresponding reader , all depicted in . The execution of a set of the instructions may in some cases result in output of data. Execution may also involve storing data or variables to the memory .","The described methods use input variables , which are stored in the memory  in corresponding memory locations , , . The methods produce output variables , which are stored in the memory  in corresponding memory locations , , . Intermediate variables  may be stored in memory locations , ,  and .","I Referring to the processor  of , the registers , , , the arithmetic logic unit (ALU) , and the control unit  work together to perform sequences of micro-operations needed to perform \u201cfetch, decode, and execute\u201d cycles for every instruction in the instruction set making up the program . Each fetch, decode, and execute cycle comprises:","(a) a fetch operation, which fetches or reads an instruction  from a memory location , , ;","(b) a decode operation in which the control unit  determines which instruction has been fetched; and","(c) an execute operation in which the control unit  and\/or the ALU  execute the instruction.","Thereafter, a further fetch, decode, and execute cycle for the next instruction may be executed. Similarly, a store cycle may be performed by which the control unit  stores or writes a value to a memory location .","Each step or sub-process in the processes of  is associated with one or more segments of the software application program  and is performed by the register section , , , the ALU , and the control unit  in the processor  working together to perform the fetch, decode, and execute cycles for every instruction in the instruction set for the noted segments of the software application program .","The method  may alternatively be implemented in dedicated hardware such as one or more integrated circuits performing the functions or sub functions of the method . Such dedicated hardware may include graphic processors, digital signal processors, or one or more microprocessors and associated memories.","The method  of rendering a graphical object on a page will now be described with reference to . The method  may be implemented as one or more software code modules of the software application program  resident on the hard disk drive  and being controlled in its execution by the processor .","The method  begins at drawing command receiving step , where the processor  receives one or more drawing commands which may be stored in memory . The drawing commands may be issued by another software application program resident on the hard disk drive  and being controlled by the processor . Alternatively, the drawing commands may be issued by a software application program resident on a remote server connected to the network .","In one implementation, the drawing commands may be issued to an operating system spooler software module, using an operating system supplied graphics application programming interface. Such an operating system spooler software module may be resident on the hard disk drive  and be controlled in its execution by the processor . At converting step , the processor  (or the operating system spooler software module under execution of the processor ) converts the drawing commands to a standardized file format such as the XPS file format or the Portable Document Format (PDF).","Then, at interpreting step , the standardized file format is interpreted into an intermediate graphical object. The intermediate graphical object contains corresponding drawing instructions of how to draw the graphical object onto the page, including graphics properties of the graphical object, such as shape, compositing method, clipping information and possibly a bounding box. In one implementation, step  may be executed by a printer driver software module resident on the hard disk drive  and being controlled in its execution by the processor .","At storing step , the intermediate graphical object and corresponding drawing instructions are stored in a self-retained display list (SRDL) configured within the memory . The self-retained display list is an internal display list that is constructed and used for converting the intermediate graphical object into printer-recognizable format. In one implementation, step  and following steps  to  may be executed by an object converter software module resident in the hard disk drive  and being controlled in its execution by the processor . As described below, in steps  to  the intermediate graphical objects are converted into printer-compatible graphical objects in printer-recognizable format.","Then at mapping step , the processor  performs the step of mapping the intermediate graphical object onto one or more corresponding regions of the page. In performing the mapping at step , the processor  determines which regions of the page are touched by the graphical object. A method  of mapping the intermediate graphical object onto one or more corresponding regions of the page, as executed at step , will be described in detail below with reference to .","At marking step , the processor  performs the step of marking the corresponding regions of the page as output incompatible based on the mapped graphical object being output incompatible, and any surrounding regions being classified as output incompatible (i.e., associated with a corresponding output incompatible graphical object). In one implementation, the corresponding regions of the page are marked as output incompatible based on a determined size of the graphical object satisfying a threshold as described below.","Each region of the page has a bounding box and an associated \u201cdirty status\u201d flag. The dirty status flag is used for marking the corresponding region so as to indicate if the graphical object corresponding to the region is output incompatible (i.e., dirty) and needs to be converted to output compatible in following step . A method  of marking one or more regions of the page as output incompatible, as executed at step , will be described below with reference to .","Then at deciding step , if the processor  determines that there is a further intermediate graphical object to be processed (e.g., the printer driver software module has interpreted a further intermediate graphical object in the standardized file format), then the method  returns to step  to process the further intermediate graphical object. Otherwise, the method  proceeds to converting step . The further intermediate graphical object is stored in the self-retained display list (SRDL) configured within the memory .","At converting step , the processor  performs the step of converting the regions marked as output incompatible (i.e., as dirty) to output compatible regions. As described in detail below, at step , the processor  processes the dirty status flags of the regions and converts the dirty regions into printer-compatible graphical objects. A method  of converting regions marked as output incompatible to output compatible regions, as executed at step , will be described in detail below with reference to .","At rendering step , the processor  performs the step of rendering the graphical object on the page using any corresponding output compatible regions. In one implementation, the processor  may pass the printer-compatible graphical object, together with corresponding drawing instructions, to a rendering engine software module residing on the printer . Such a rendering engine renders the printer-recognizable graphical object into pixels, and prints the pixels onto the page.","The method  of mapping the intermediate graphical object onto one or more corresponding regions of the page, as executed at step , will now be described with reference to . In the method , an intermediate graphical object is mapped onto corresponding regions of the page. Each region has a bounding box and an associated dirty status flag as described above. The method  may be implemented as one or more software code modules of the software application program  resident on the hard disk drive  and being controlled in its execution by the processor . As described above, in one implementation, the method  may be executed by the object converter software module.","At step , the processor  receives a bounding box of the intermediate graphical object, if the bounding box is provided in graphics properties associated with the intermediate graphical object. If the bounding box is not provided with the graphical object, then the processor  determines a bounding box using shape and clipping information provided with graphics properties of the graphical object.","At step , the processor  uses the bounding box of the graphical object to determine which regions of the page are touched by the graphical object. In particular, the processor  determines intersections between the bounding box of the graphical object and bounding boxes of each of the regions. If intersections are determined, then the region is determined to be touched by the graphical object.","At step , the processor  stores details of the determined touched regions within the memory .","The method  of marking one or more regions of the page as output incompatible, as executed at step  of the method , will now be described below with reference to . In the method , the intermediate graphical objects parsed from standardised format and stored in the self-retained display list are converted to printer-compatible graphical objects. The page is divided into grids of a pre-determined size. Each grid is a region as described above.","The method  may be implemented as one or more software modules of the software application program  and being controlled in its execution by the processor .","The method  begins at dirty region determining step , where if the processor  determines that all the regions of the page that are touched by the intermediate graphical object have an associated \u201cdirty\u201d status flag, then the method  concludes. Otherwise, the method  proceeds to step .","A region that is marked as \u201cdirty\u201d means that the graphical object corresponding to the region is output incompatible (i.e., the graphical object is not in a format recognizable to the printer ) and needs to be converted into a printer-compatible graphical object. If all the touched regions already have the dirty flag on, then the method  skips further processing of the intermediate graphical object.","At printer-compatible determining step , the processor  checks all graphics properties of the received intermediate graphical object, including corresponding drawing instructions used to draw the graphical object onto the page, the compositing method and the clipping information. If the processor  determines at step  that there are any graphics properties of the graphical object that are not compatible with the printer-recognizable format used by the printer  (i.e., the graphical object is not printer compatible), then the current graphical object is considered as a printer-incompatible object and the method  proceeds to marking step . Otherwise, the method  proceeds to step .","At marking step , the processor  performs the step of marking the touched regions by setting the dirty flag associated with each of the touched regions to be TRUE; and the processor  skips further processing of the current intermediate graphical object.","If all graphics properties of the current intermediate graphical object are printer-compatible at step , then the current graphical object is classified as a printer-compatible object and the method  proceeds to image determining step .","At image determining step , if the processor  determines that the current intermediate graphical object is a larger than a pre-determined threshold, opaque image, that is not going to be scaled up too much on the page to be printed, then the method  proceeds to step . Otherwise, the method  proceeds to storing step .","A maximum threshold of scaling factor of the images, big_image_max_scaled_factor, and a minimum threshold of the image size, big_image_min_image_size, may be configured within the memory . Accordingly, if the current graphical object is an opaque image that is larger than the big_image_min_image_size threshold and has a scaling factor less than the big_image_max_scaled_factor threshold, then all regions touched by the current graphical object are marked as dirty at step .","At storing step , the intermediate graphical object is stored within the memory  for printing by the rendering engine, for example, in a printer-recognizable format.","At step , the processor  determines if there are any regions of the page that are fully covered by the current printer-compatible graphical object. Depending on the graphics properties of the graphical object, including the clipping information, if a region is fully covered by the graphical object then all previous contents in the region will not be shown on the printed page. The processor  marks such a region as output compatible at step  by setting the dirty status flag of such a region to FALSE. The method  concludes following step .","The method  of converting regions, marked as output incompatible, to output compatible regions, will be described in detail below with reference to . The method  processes the dirty status of all regions of the page, and converts the dirty regions into printer-compatible graphical objects.","The method  may be implemented as one or more software code modules of the software application program  resident on the hard disk drive  and being controlled in its execution by the processor . As described above, in one implementation, the method  may be executed by the object converter software module.","The method  begins at bounding box determining step , where the processor  performs the step of determining bounding boxes each comprising a plurality of regions marked as output incompatible (i.e., the dirty regions). In particular, the processor  processes the dirty regions, marked in accordance with the method , and merges the dirty regions into groups of \u201cregion_sets\u201d. The groups of region_sets are stored within the memory .","A method  of merging regions into groups of region_sets, as executed at step , will be described below with reference to . In the method , the processor  scans regions horizontally, starting at a first row of dirty tiles. In particular, starting at a left-most dirty tile of the first row, the processor  attempts to merge an adjacent tile to the right of the left-most dirty tile. Merging of the tiles succeeds if the adjacent tile on the right is dirty. However, if the adjacent tile is not dirty, then the merging of the tiles may fail, depending on an area threshold as described below. The method  determines a set of one or more dirty tile regions for the first row. After completing processing of the first row of dirty tiles, the processor  horizontally scans and merges a second row of dirty tiles in a similar manner.","After completing processing of the second row of dirty tiles, the processor  attempts to merge the set of dirty tiles from the first and second rows, again applying an area threshold to determine whether or not to carry out the merge. The result of merging the set of dirty tiles from the first and second rows is a set of one or more dirty tile regions. Processing then continues in a similar manner for each subsequent row of dirty tiles. At completion of processing of each row, a set of dirty tile regions (i.e., a region_set) in the processed row is merged with a previous combined set of dirty tile regions.","In one implementation, the processor  attempts to merge the set of dirty tiles from the first and the second rows, by determining a distance between the first and the second rows. If the distance satisfies a predetermined distance threshold, the result of merging the set of dirty tiles is a set of one or more dirty tile regions. Processing then continues in a similar manner for each subsequent row of dirty tiles. At completion of processing of each row, a set of dirty tile regions (i.e., a region_set) in the processed row is merged with a previously combined set of dirty tile regions.","Each region_set contains a group of regions of the page that forms a rectangle shape, and a bounding box of a region_set is determined by co-ordinates, (start_x, start_y), of a top left region of the page, and co-ordinates, (end_x, end_y), of a bottom right region of the page. Each region_set also contains information of how many regions of the page in total the region_set contains (i.e., \u201cnum_total_regions\u201d) and out of which how many regions are dirty regions (i.e., \u201cnum_dirty_regions\u201d). Accordingly, at step , the processor  also performs the step of determining a proportion of the number of output incompatible regions to total number of regions in the bounding box for a corresponding region_set.","At accessing step , the processor  accesses a region_set from the memory . Then at rendering step , the processor  renders an image representing an area indicated by the accessed region_set, using information stored in the self-retained display list configured within the memory . As described above, the self-retained display list contains the intermediate graphical objects and corresponding drawing instructions. The rendered image of the region_set may be stored within the memory  and contains all graphical objects in the corresponding area.","At converting step , the processor  converts the rendered image into the printer-recognizable format corresponding to the printer . In one implementation, the printer-recognizable formatted image is output to the rendering engine software module as described above. Then at decision step , if the processor  determines that there are more region_sets within memory  for processing, then the method  proceeds to step  to get a next region_set. Otherwise, the method  concludes.","The method  of merging regions into groups of region_sets, as executed at step , will be described below with reference to . The method  may be implemented as one or more software code modules of the software application program  resident on the hard disk drive  and being controlled in its execution by the processor . As described above, in one implementation, the method  may be executed by the object converter software module.","As described in detail below, in the method , the processor  marks at least one output compatible region in the particular bounding box for a region_set as output incompatible in order to increase the proportion of the number of the output incompatible regions to a total number of regions above a threshold (i.e, a predefined merge_threshold). Once the proportion of the number of regions marked as output incompatible reaches a threshold, the region in the bounding box is merged by processor .","In another implementation, if a region_set is within a predefined distance from another region_set, then both the region_sets are merged.","In the method , all dirty regions (ie., regions associated with a printer incompatible graphical object) marked in accordance with the method  are merged into a group of region_sets.","The method  begins at processing step , where the processor  processes each row of the regions to form a group of region_sets. A method  of processing each row of regions, as executed at step , will be described below with reference to . In the following steps  to , the dirty regions in each row are merged into a group of region_sets, where each region_set is also a shape of rectangle area. Each region_set also contains a group of regions including dirty and clean regions.","At first row accessing step , the processor  accesses a first row of the region_sets stored in memory . Then at decision step , if the processor  determines that there are no more rows of the region_sets to be processed, then the method  concludes. Otherwise, the method  proceeds to next row accessing step .","At further row accessing step , the processor  accesses a second row of the region_sets. At scanning step , after accessing a first_row and a second_row of the region_sets, the processor  scans from left to right, finding a candidate region_set from each row to form the first two candidate region_sets. As each region_set has a bounding box represented by the (start_x, start_y) co-ordinate and the (end_x, end_y) co-ordinate, the candidate region_set is determined based on the start_x co-ordinate of the region_set. The candidate region_set with the smallest start_x co-ordinate is selected for each row.","At merging step , the processor  merges the two candidate region_sets from the first_row and second_row to form a merged region_set by executing the comparison step . If the two region_sets are merged, the merged region_set is a new rectangle shape of regions. The new rectangle shape of regions has a bounding box determined by the (min_x, min_y) and (max_x, max_y) co-ordinates, where the min_x and min_y represents minimum X and minimum Y values, respectively, from the bounding boxes of the two candidate region_sets, and max_x and max_y represents maximum X and minimum Y values from the bounding boxes of the two candidate region_sets.","The merged region_set formed at step  contains all regions contained in the two candidate region_sets, as well as all the clean regions in between the two candidate region_sets to form a new rectangle shape of regions. The num_total_regions and num_dirty_regions, configured within the memory , for the new rectangle shape are also updated.","As part of the merging step , in comparing step , if the processor  determines that the ratio of the \u201cdirty region\u201d (region marked as output incompatible) to the total number of regions is greater than or equal to a predefined threshold that initiates merging merge_threshold, then the method  proceeds to step . Otherwise, the attempted merging is deemed to have failed and the method  proceeds to step .","At merging step , the merged region_set is stored within the memory  as one of two next candidate region_sets. At step , the candidate region_set with the larger start_x co-ordinate is stored in memory  as one of two next candidate region_sets.","At determining step , if the processor  finds the other next candidate region_set based on the start_x co-ordinate from the first_row and second_row of the region_sets stored in the memory , then the method  returns to step  to repeat the attempted merging steps, until all region_sets from both the first_row and the second row are processed. Otherwise, the method  proceeds to step . Again the region_set with the smallest start_x co-ordinate is selected at step .","At step , the processor  finishes processing all region_sets from the first_row and the second_row of region_sets. The result merged region_sets are stored within the memory  as a new row of region_sets, which will be the first_row of the next round of processing. Then the method  repeats the steps from step , where a second_row of region_sets is selected and merged with the first_row of region_sets.","The method  of processing each row of regions, as executed at step , will now be described with reference to . The method  may be implemented as one or more software code modules of the software application program  resident on the hard disk drive  and being controlled in its execution by the processor . As described above, in one implementation, the method  may be executed by the object converter software module.","The method  processes each row of regions of the page stored in the memory and merges the dirty regions in each row (i.e., as marked in accordance with the method ) into a group of region_sets.","The method  begins at determining step , where a new row of unprocessed regions stored in the memory  is selected by the processor  as a current row. Otherwise, if the processor  determines at step  that all rows of the regions stored in the memory  are processed, then the method  concludes.","At scanning step , the processor  scans the regions selected at step  for the current row from left to right. The processor  selects a first dirty region and all adjacent dirty regions following the first dirty region, and merges the first dirty region and all adjacent dirty regions into a merged region_set. The bounding box of the merged region_set is determined based on the (start_x, start_y) co-ordinate of the first dirty region and the (end_x, end_y) co-ordinate of the last adjacent dirty region. Both num_total_regions and num_dirty_regions are equal to the total number of the adjacent dirty regions merged together at step . The merged region_set is stored in memory  as the first_candidate region_set.","At decision step , if the processor  determines that all groups of adjacent dirty regions have been processed for the current row, then the method  proceeds to step . Otherwise, the method  returns to step .","At merging step , the processor  merges a next group of adjacent dirty regions into a new region_set. The new region_set is stored in the memory  as the second_candidate region_set. Then at step , the processor  tries to merge the first_candidate and second_candidate region_sets and all the clean regions in between the first_candidate and second_candidate region_sets. By merging the first_candidate and second_candidate region_sets, the merged region_set is a new rectangle shape of regions whose bounding box is determined by the (min_x, min_y), (max_x, max_y) co-ordinates, where the min_x and min_y are the minimum X and Y value from the bounding boxes of the two candidate region_sets, and max_x and max_y are the maximum X and Y value from the bounding boxes of the two candidate region_sets.","The merged region_set formed at step  contains all regions that were contained in the first and second candidate region_sets, as well as all the clean regions in between the first and second candidate region_sets to form a new rectangle shape of regions. The num_dirty_regions of the merged region_set equals the num_dirty_regions of the first_candidate region_set plus the num_dirty_regions of the second_candidate region_set. The num_total_regions of the merged region_set equals the num_total_regions of the first_candidate region_set plus the num_total_regions of the second_candidate region_set plus the number of the clean regions in between the first_candidate region_set and the second_candidate region_set.","At decision step , if the processor  determines that the ratio of number of \u201cdirty region\u201d (region marked as output incompatible) to the total number of regions in the merged region_set is greater than or equal to a predefined threshold that initiates merging merge_threshold then the method  proceeds to step . Otherwise, the method  proceeds to step .","In one implementation, at decision step , if the processor  determines that the distance between the clean region and a region marked as dirty (containing output incompatible graphical objects) satisfies a predefined threshold (e.g., fifty (50) pixels), the clean region is marked as dirty as well. The marking of the clean region as a dirty region initiates the merging process in merging step . Otherwise, the method  proceeds to step .","At step , the merged region_set is stored in the memory  as a new region_set in the current row as the first_candidate region_set. Otherwise, the second_candidate region_set is stored in the memory  as the first_candidate region_set of a next round at storing step .","Following steps  and , the method  returns to step  and processing steps are repeated from step , until there are no more dirty regions to be found in the current row. The next row of regions are then processed from step  as described above. When all rows of regions are processed, the method  concludes as described above.","The methods described above will now be described further by way of example with reference to . In accordance with the example, intermediate graphical objects , , , , , , , , , , , ,  of the page  are converted to printer-compatible graphical objects in accordance with the described methods.","In the example of , the objects , , , , , , , , , , , ,  are the graphical objects in the intermediate format sent from the printer driver software module and stored in the self-retained display list as described above. The objects , , , , , , , , , , , ,  are drawn on the page  in the same order as the objects , , , , , , , , , , , ,  are numbered. For example, an object with a smaller number (e.g., the object ) is rendered on the page  below an object with a higher number (e.g., the object ). The objects (e.g., , ) are rendered using a suitable compositing algorithm and the smaller numbered object (e.g., ) as compositing background. In the example of :","objects , , , , , , which are shaded in , are printer-incompatible graphical objects;","All other graphical objects of the page  (i.e. object , , , , , and ) are printer-compatible graphical objects which are also fully opaque;","object  is a non-scaled image object that is larger than the predefined big_image_max_scaled_size with zero (0) scaling factor, which is less than the pre-defined big_image_max_scaled_factor; and","all objects other than object  are not image objects.","In accordance with the described methods, the printer-compatible graphical objects are not necessarily fully opaque. However, the objects (i.e., object , , , , , and ) in the example of  are set as fully opaque for ease of explanation.","The page  has been assigned numbers and letters in both the X and Y co-ordinate direction for the purpose of naming the grided regions as presented in . Starting from the left top corner of the page , the names of the regions are: r(A), r(B) . . . r(N), r(A), r(B), . . . r(N). An example of a region_set combined by regions r(A), r(B), r(A), r(B) is referred to as \u201crs(A, B)\u201d, with (num_total_regions==4 & num_dirty_regions==0).","The pre-defined merge_threshold in the example of  is set to 80%. Regions of the page  touched by each graphical object, as determined at step  of the method  (i.e., in accordance with the method ), are as follows:","Object : r(B), r(C), r(D), r(E), r(F);","Object : r(C), r(D), r(E), r(C), r(D), r(E), r(C), r(D), r(E);","Object : r(K), r(L), r(M), r(J), r(K), r(L), r(M), r(J), r(K), r(L), r(M), r(K), r(L), r(M);","Object : r(K), r(J), r(K), r(L);","Object : r(L), r(M), r(N), r(M);","Object : r(E), r(F), r(E), r(F), r(E), r(F);","Object : r(F), r(G), r(H), r(E), r(F), r(G), r(H), r(I), r(F), r(G), r(H);","Object : r(G), r(H), r(I), r(G), r(H), r(I), r(G), r(H), r(I), r(G), r(H), r(I);","Object : r(B) to r(M), r(B) to r(M), r(B) to r(M), r(B) to r(M), r(B) to r(M), r(B) to r(M), r(B) to r(M), r(B) to r(M), r(B) to r(M);","Object : r(F) to r(J), r(F) to r(J), r(F) to r(J);","Object : r(E), r(D), r(E), r(D), r(E), r(F);","Object : r(I) to r(L), r(I) to r(L);","Object : r(H), r(I), r(H), r(I);","At the beginning of the method , the dirty status flag of each of the regions of the page  are set to FALSE. When the object  is received by the processor  at step  of the method , the touched regions determined at step  are r(B), r(C), r(D), r(E) and r(F). Since object  is a printer-incompatible object, at step  of the method  (i.e., at step  of the method ), the dirty flags of regions r(B), r(C), r(D), r(E) and r(F) are set to be TRUE.","Then at step  of the method , the method  returns to step  to get the next intermediate graphical object from the self-retained display list (i.e., as sent from the printer driver software module).","When object  is received by the processor , the touched regions determined at step  include region r(D), which was set to be dirty in the processing of object . At step  of the method , since object  is not an image object, the method  proceeds to step  where the processor  stores the object  in printer-recognizable format in the memory  for printing by the rendering engine software module, for example. At step  of the method , since object  is a fully opaque printer-compatible object, and region r(D) is fully covered by object , the processor  sets the dirty flag of region r(D) back to be FALSE. Then the method  returns to step  to get the next intermediate graphical object from the self-retained display list (i.e., as sent from the printer driver software module).","When the object  is received by the processor , since the object  is a non-image printer-compatible object, the processor  stores the object  in printer-recognizable format in the memory  (as at step ) for printing by the rendering engine software module. The method  then returns to step  to get a next intermediate graphical object from the self-retained display list (i.e., as sent from the printer driver).","When the object  and object  are received by the processor  at step  of the method , the touched regions determined at step  are r(K), r(J), r(K), r(L), r(L), r(M), r(N) and r(M). Since object  is a printer-incompatible object, at step  of the method  (i.e., at step  of the method ), the dirty flags of the regions r(K), r(J), r(K), r(L), r(L), r(M), r(N) and r(M) are set to be TRUE. Then at step  of the method , the method  returns to step  to get the next intermediate graphical object from the self-retained display list configured within the memory .","When object  is received by the processor  at step  of the method , since the object  is a non-image printer-compatible object, the processor  stores the object  at step  in printer-recognizable format in the memory  for printing by the rendering engine software module, for example. The dirty flags of the regions that are touched by object  are not changed. The method  then returns to step  to get the next intermediate graphical object from the self-retained display list configured in the memory .","When the object  is received by the processor  at step  of the method , the touched regions determined at step  are r(F), r(G), r(H), r(E), r(F), r(G), r(H), r(I), r(F), r(G) and r(H). Since object  is a printer-incompatible object, at step  of the method  (i.e., at step  of the method ), the dirty flags of the regions r(F), r(G), r(H), r(E), r(F), r(G), r(H), r(I), r(F), r(G) and r(H) are set to be TRUE. Then at step  of the method , the method  returns to step  to get the next intermediate graphical object from the self-retained display list configured within the memory .","When object  is received by the processor , the touched regions determined at step  includes region r(H), which was set to be dirty in the processing of object . At step  of the method , since object  is not an image object, the method  proceeds to step  where the processor  stores the object  in printer-recognizable format in the memory  for printing by the rendering engine software module, for example. At step  of the method , since object  is a fully opaque printer-compatible object, and region r(H) is fully covered by object , the processor  sets the dirty flag of region r(H) back to be FALSE. Then the method  returns to step  to get the next intermediate graphical object sent from the self-retained display list (i.e., as sent from the printer driver).","When object  is received by the processor  at step  of the method , the touched regions determined at step  are r(B) to r(M), r(B) to r(M), r(B) to r(M), r(B) to r(M), r(B) to r(M), r(B) to r(M), r(B) to r(M), r(B) to r(M), r(B) to r(M). Since object  is a non-scaled printer-compatible image object that is larger than a predefined big_image_max_scaled_size with zero (0) scaling factor, the result of step  is TRUE (i.e., the \u2018yes\u2019 arrow is followed at step ). The method  then proceeds to step  and sets dirty status flag of the regions touched by object  to be TRUE, without storing the object  in memory  for subsequent rendering by the rendering engine software module, even though the object  is printer-compatible. Then at step  of the method , the method  returns to step  to get the next intermediate graphical object from the self-retained display list configured within the memory .","When objects , ,  and  are received by the processor  at step , since the dirty status flags of the touched regions that are determined at step  are all already set to TRUE during processing object , the results of step  of the method  are always TRUE for the process of processing objects , ,  and . The method  skips any further processing and the method  returns to step  to get the next intermediate graphical object from the self-retained display list configured within the memory . Since there are no more objects on the page  to be processed at step , the method  proceeds to step  where any regions marked as output incompatible are converted to output compatible regions. At this stage of the example, the dirty status of the regions on the page  is as shown in . In accordance with the example of , below is a list of the dirty regions from each row of the page :","Row : r(B), r(C), r(E), r(F), r(K), r(L), r(M), r(N);","Row : r(J), r(K), r(L), r(M);","Row : r(F), r(G), r(H);","Row : r(E), r(F), r(G), r(H), r(I);","Row : r(F), r(G);","Row : r(B) to r(M);","Row : r(B) to r(M);","Row : r(B) to r(M);","Row : r(B) to r(M);","Row : r(B) to r(M);","Row : r(B) to r(M);","Row : r(B) to r(M);","Row : r(B) to r(M);","Row : r(B) to r(M);","At step  of the method , the processor  first executes the method  to merge the dirty regions of the page  shown in  to form region_sets.","At step  of the method , the processor  first executes the method  to process each row of the regions of the page .","At step , the processor  first gets Row  of the regions of the page . At step , the processor  merges regions r(B) and r(C) to region_set rs(B, C) with (num_total_regions==2; num_dirty_regions==2).","At step , the processor  merges regions r(E) and r(F) to region_set rs(E, F) with (num_total_regions==2; num_dirty_regions==2).","At steps  and , the processor  tries to merge the region_sets rs(B, C) and rs(E, F) to be rs(B, F) with (num_total_regions==5; num_dirty_regions==4). Since (num_dirty_regions\/num_total_regions)==0.8>=merge_threshold (80%), the processor  goes to step  and stores the rs(B, F) in the memory  to be the new region_set for the current row.","At step , the processor  merges regions r(K), r(L), r(M) and r(N) to region_set rs(K, N) with (num_total_regions==4; num_dirty_regions==4). At step  and , the processor  tries to merge the region_sets rs(B, F) and rs(K, N) to be rs(B, N) with (num_total_regions==13; num_dirty_regions==8). Since (num_dirty_regions\/num_total_regions)\u02dc=0.61<merge_threshold (80%), the method  proceeds to step , does not merge the two candidate region_sets, and uses the rs(K, N) as the next candidate region_set.","At step , since there are no more dirty regions on the current row, the method  proceeds to step  and accesses Row  of the regions. At this stage, the result region_sets for Row  are: rs(B, F), rs(K, N).","When Row  of the regions of page  are processed in accordance with the method , since there is only one group of adjacent dirty regions on the current row, the result region_sets for Row  are: rs(J, M).","Similar to Row , after the other rows of the regions of page  have been processed, the result region_sets for page  are as follows:","Row : rs(B, F), rs(K, N);","Row : rs(J, M);","Row : rs(F, H);","Row : rs(E, I);","Row : rs(F, G);","Row : rs(B, M);","Row : rs(B, M);","Row : rs(B, M);","Row : rs(B, M);","Row : rs(B, M);","Row : rs(B, M);","Row : rs(B, M);","Row : rs(B, M);","Row : rs(B, M);","After the last row Row  of the page  is processed in accordance with the method , the method  proceeds to step  to get the region_sets from Row , and then gets the region_sets from Row  at step . At step , the processor  gets region_sets rs(B, F) from Row  and rs(J, M) from Row  as two candidate region_sets to be merged.","At step  and  of the method , the processor  tries to merge the two candidate region_sets rs(B, F) and rs(J, M) to be rs(B, M) with (num_total_regions==24; num_dirty_regions==11). Since (num_dirty_regions\/num_total_regions)\u02dc=0.46<merge_threshold (80%), the method  proceeds to step , does not merge the two candidate region_sets, and scans from left to right, drops region_set rs(B, F), and gets the region_set rs(K, N) as the next candidate region_set.","At steps  and , the processor  tries to merge the two candidate region_sets rs(K, N) and rs(J, M) to be rs(J, N) with (num_total_regions==10; num_dirty_regions==8). Because (num_dirty_regions\/num_total_regions)\u02dc=0.8>=merge_threshold (80%), the method  proceeds to step , merges the two candidate region_sets to be the new candidate region_set, and proceeds to step  to find the next unprocessed region_set from Row  and Row  of the page . Since there are no more region_sets on rows Row  and Row , the method  goes to step  where the processor  merges the region_sets from Row  and Row  to one row as:","Row : rs(B, F), rs(J, N);","The method  then returns to step  to get region_sets on Row  as the next row to be merged with the new Row  described above. At step  and , the processor  tries to merge the two candidate region_sets rs(B, F) and rs(F, H) to be rs(B, H) with (num_total_regions==40; num_dirty_regions==7). Since (num_dirty_regions\/num_total_regions)\u02dc=0.18<merge_threshold (80%), the processor  does not merge the two candidate region_sets, goes to step  and gets the next candidate region_set rs(J, N). Similarly, since the (num_dirty_regions\/num_total_regions) is less than the merge_threshold 80%, the processor  does not merge the candidate region_sets rs(F, H) and rs(J, N). At step , since there are no more unprocessed region_sets left on Row  and Row , the method  proceeds to step . Since there are no merged region_sets, result of the merging is still as follows:","Row : rs(B, F), rs(J, N);","Row : rs(F, H);","The method  then returns to step  to get region_sets on Row  as the next row to be merged with the Row . At steps  and , the processor  tries to merge the two candidate region_sets rs(F, H) and rs(E, I) to be rs(E, I) with (num_total_regions==10; num_dirty_regions==8). Since (num_dirty_regions\/num_total_regions)=0.8>=merge_threshold (80%), the method  proceeds to step , then to step  with the result of the new Row  as:","Row : rs (E, I);","The method  then returns to step  to get region_sets on Row  as the next row to be merged with the new Row  as described above. At steps  and , the processor  tries to merge the two candidate region_sets rs(E, I) and rs(F, G) to be rs(E, I) with (num_total_regions==15; num_dirty_regions==10). Since (num_dirty_regions\/num_total_regions)\u02dc=0.67<merge_threshold (80%), the method  proceeds to step  and does not merge the two candidate region_sets. At step , since there are no merged region_sets, the result of the merging is still as follows:","Row : rs (E, I);","Row : rs (F, G);","The method  then returns to step  to get region_sets on Row  as the next row to be merged with the Row  described above. At step  and , the processor  tries to merge the two candidate region_sets rs(F, G) and rs(B, M) to be rs(B, M) with (num_total_regions==60; num_dirty_regions==14). Because (num_dirty_regions\/numtotal_regions)\u02dc=0.23<merge_threshold (80%), the method  proceeds to step , does not merge the two candidate region_sets. At step , since there are no merged region_sets, the result of the merging is still as follows:","Row : rs (F, G);","Row : rs (B, M);","The method  then returns to step  to get region_sets on Row  as the next row to be merged with the Row  described above. At step  and , the processor  tries to merge the two candidate region_sets rs(B, M) and rs(B, M) to be rs(B, M) with (num_total_regions==24; num_dirty_regions==24). Since (num_dirty_regions\/num_total_regions)=1>=merge_threshold (80%), the method  proceeds to step  then  with the result of the new Row  as follows:","Row : rs (B, M);","Similarly, after processing the last row Row  of region_sets, the processor  merges all region_sets from Row  to Row  to be a new Row  as follows:","Row : rs (B, M);","At step , since there are no new rows to be processed, the processor  proceeds to step . The final result from method  is as shown in . Below is a list of the merged region_sets to be output after the method .","Row : rs(B, F), rs(J, N);","Row : rs (E, I);","Row : rs(F, G);","Row : rs(B, M);","In another implementation, instead of checking the (num_dirty_regions\/num_total_regions) against a predefined threshold, the distance between a dirty region and a clean region is checked against a predetermined distance threshold. If the distance between the dirty candidate region_set and the clean candidate region_set is smaller than the predetermined threshold, then the dirty region and clean region are merged into one region_set.",{"@attributes":{"id":"p-0263","num":"0262"},"figref":["FIG. 9","FIGS. 8A and 8B"],"b":["500","510","105","3","3","106","910","520","910","530","500","510","3","4","106","920","7","8","106","930","9","9","940","13","21","950","200"]},"The arrangements described are applicable to the computer and data processing industries and particularly for the image processing.","The foregoing describes only some embodiments of the present invention, and modifications and\/or changes can be made thereto without departing from the scope and spirit of the invention, the embodiments being illustrative and not restrictive.","In the context of this specification, the word \u201ccomprising\u201d means \u201cincluding principally but not necessarily solely\u201d or \u201chaving\u201d or \u201cincluding\u201d, and not \u201cconsisting only of\u201d. Variations of the word \u201ccomprising\u201d, such as \u201ccomprise\u201d and \u201ccomprises\u201d have correspondingly varied meanings."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The accompanying drawings, which are incorporated in and constitute a part of the specification, illustrate exemplary embodiments, features, and aspects of the invention and, together with the description, serve to explain the principles of the invention.",{"@attributes":{"id":"p-0073","num":"0072"},"figref":"FIGS. 1A and 1B"},{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0075","num":"0074"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0076","num":"0075"},"figref":["FIG. 4","FIG. 2"]},{"@attributes":{"id":"p-0077","num":"0076"},"figref":["FIG. 5","FIG. 1"]},{"@attributes":{"id":"p-0078","num":"0077"},"figref":["FIG. 6","FIG. 5"]},{"@attributes":{"id":"p-0079","num":"0078"},"figref":["FIG. 7","FIG. 6"]},{"@attributes":{"id":"p-0080","num":"0079"},"figref":"FIG. 8A"},{"@attributes":{"id":"p-0081","num":"0080"},"figref":["FIG. 8B","FIG. 8A","FIG. 7","FIG. 8A"]},{"@attributes":{"id":"p-0082","num":"0081"},"figref":["FIG. 8C","FIG. 8B","FIG. 6","FIG. 8A"]},{"@attributes":{"id":"p-0083","num":"0082"},"figref":["FIG. 9","FIG. 8A","FIG. 5","FIG. 8A"]}]},"DETDESC":[{},{}]}
