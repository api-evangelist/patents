---
title: Specification of a software architecture for capability and quality-of-service negotiations and session establishment for distributed multimedia applications
abstract: A system offering an Application Programming Interface for multi-stream multimedia applications running on at least two registered end peers participating in a mobile telecommunication session and/or middleware being connected to a mobile network. The system providing guaranteed end-to-end quality and resource capabilities using the concept of concatenated E2ENP phases and providing a pre-negotiation of a multiplicity of alternative capabilities and QoS Contracts, management of leased pre-negotiated information, session establishment between said end peers with negotiation of a multiplicity of alternative capabilities and/or QoS Contracts, and a dynamic re-negotiation of the end-to-end quality and capabilities. The information to be negotiated is expressed in an interchangeable format allowing multi-stream multimedia applications to agree on a specific reference model of the negotiated information, which can then be used for dynamically configuring Finite State Machines to orchestrate local, peer, and network resources according to the preferences and profiles of the respective user.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08549143&OS=08549143&RS=08549143
owner: Nokia Siemens Networks GmbH & Co. KG
number: 08549143
owner_city: MÃ¼nchen
owner_country: DE
publication_date: 20031015
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"p":["The underlying invention generally relates to the field of distributed mobile computing in a mobile wireless networking environment with distributed multimedia applications and systems. More specifically, it is directed to the field of quality negotiation and session establishment for adaptive real-time streaming services running on fixed and mobile devices which support different access technologies in dynamic wireless Internet Protocol (IP) networks, thereby including research and development issues which are especially related to multimedia middleware and resource reservation mechanisms.","A problem that distributed systems will most likely face is how to cope with limited resources at the end systems and in the network, and unstable environment conditions. Mobile users are in fact expected to incur more frequently on the unfortunate case of having their QoS Contracts being no longer supported by the network infrastructure, due to various reasons like wireless link quality degradations, horizontal and\/or vertical handovers, limited amount of mobile terminal resources, etc., which shall be referred to as \u201cQoS violations\u201d. By assuming proper resource overprovision in the backbone, it can be expected that QoS violations will most likely originate due to handovers or within the access network, especially in the radio part thereof.","Furthermore, mobile multimedia applications dealing with multiple media streams of information being simultaneously exchanged with a multiplicity of peers require an effective and efficient way of negotiating capability and handling QoS requirements, especially in view of the aforementioned unstable environment conditions.","A possible way of coping with unstable environment conditions is to enable the mobile users' applications to efficiently and timely react to QoS violations. Peers can in fact negotiate off-line various alternative QoS Contracts at different levels of abstraction, so that at the time when a connection is established and whenever QoS violations occur, agreements on how to most effectively adapt to the mutated conditions can timely be accomplished among the peers.","In the European patent application EP 01 122 366.6, the End-to-End Negotiation Protocol (E2ENP) has already been introduced and described in detail. As the present invention develops further the ideas described in this European patent application, its disclosure is hereby incorporated by reference.","The following table gives a brief overview of recently published articles which describe the concept of QoS and capability negotiation protocols (in alphabetical order):",{"@attributes":{"id":"p-0008","num":"0007"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Abbr.","Publication"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["[Ber]","T. Berners-Lee et al.: \u201cUniform Resource Identifiers"]},{"entry":[{},"(URI): Generic Syntax\u201d, Networking Working"]},{"entry":[{},"Group, Standards Track RFC 2396."]},{"entry":["[Bos1]","L. Bos et al.: \u201cA Framework for End-to-End User"]},{"entry":[{},"Perceived Quality of Service Negotiation\u201d, IETF"]},{"entry":[{},"Internet Draft, work in progress, <draft-bos-"]},{"entry":[{},"mmusic-sdpqos-framework-00.txt>. It describes a"]},{"entry":[{},"process for negotiating QoS with SIP and SDP between"]},{"entry":[{},"two peers. However, it does not describe"]},{"entry":[{},"any architecture for the entity using this process."]},{"entry":["[Bos2]","L. Bos et al.: \u201cSDPng Extensions for Quality-of-"]},{"entry":[{},"Service Negotiation\u201d, IETF Internet Draft, work"]},{"entry":[{},"in progress, <draft-bos-mmusic-sdpng-qos-00.txt>."]},{"entry":[{},"It describes a process for negotiating"]},{"entry":[{},"QoS with SIP and SDP between two peers. However,"]},{"entry":[{},"it does not describe any software architecture"]},{"entry":[{},"for the entity using this process."]},{"entry":["[BRAIN]","\u201cConcepts for Service Adaptation, Scalability"]},{"entry":[{},"and QoS Handling on Mobility-Enabled Networks\u201d,"]},{"entry":[{},"IST-1999-10050 BRAN Deliverable 1.2"]},{"entry":[{},"(http:\/\/www.ist-brain.org\/)."]},{"entry":["[BRENTA]","A. Kassler et al.: \u201cBRENTA - Supporting Mobility"]},{"entry":[{},"and Quality of Service for Adaptable Multimedia"]},{"entry":[{},"Communication\u201d, in: Proceedings of the IST Mobile"]},{"entry":[{},"Communications Summit 2000, Galway, Ireland,"]},{"entry":[{},"October 2000, pp. 403-408."]},{"entry":["[Cam1]","G. Camarillo, W. Marshall, J. Rosenberg:"]},{"entry":[{},"\u201cIntegration of Resource Management and SIP\u201d,"]},{"entry":[{},"IETF Internet Draft, work in progress, <draft-"]},{"entry":[{},"ietf-sip-manyfolks-resource-07.txt>. It develops"]},{"entry":[{},"the requirements of an \u201cOffer\/Answer Model\u201d"]},{"entry":[{},"based on SDP, also in the sense of reservation."]},{"entry":[{},"However, it does not describe any software architecture"]},{"entry":[{},"for the entity performing such specific"]},{"entry":[{},"negotiations."]},{"entry":["[Cam2]","G. Camarillo et al.: \u201cGrouping of Media Lines in"]},{"entry":[{},"SDP\u201d (IETF Internet Draft, work in progress,"]},{"entry":[{},"<draft-ietf-mmusic-fid-04.txt>)."]},{"entry":["[Gam]","E. Gamma et al.: \u201cDesign Patterns - Elements of"]},{"entry":[{},"Reusable Object-Oriented Software\u201d, Addison-"]},{"entry":[{},"Wesley, Reading-Massachusetts (USA), 1994."]},{"entry":["[Gu]","X. Gu, K. Nahrstedt et al.,: \u201cAn XML-based Quality-"]},{"entry":[{},"of-Service-Enabling Language for the Web\u201d,"]},{"entry":[{},"Project Report of the National Science Foundation,"]},{"entry":[{},"2001."]},{"entry":["[Gue]","T. Guenkovy-Luy, A. Kassler, J. Eisl, D. Mandato:"]},{"entry":[{},"\u201cEfficient End-to-End Qos Signaling - Concepts"]},{"entry":[{},"and Features\u201d, IETF Internet Draft, work"]},{"entry":[{},"in progress, <draft-guenkova-mmusic-e2enp-sdpng-"]},{"entry":[{},"00.txt>."]},{"entry":["[Kly1]","G. Klyne: \u201cA Syntax for Describing Media Feature"]},{"entry":[{},"Sets\u201d, IETF RFC 2533."]},{"entry":["[Kly2]","G. Klyne: \u201cIdentifying Composite Media Features\u201d,"]},{"entry":[{},"IETF RFC 2938. It describes an optimization"]},{"entry":[{},"for the algorithm disclosed in [Kly1] by"]},{"entry":[{},"introducing data handles and hashing."]},{"entry":["[Kut1]","D. Kutscher et al.: \u201cRequirements for Session"]},{"entry":[{},"Description and Capability Negotiation\u201d (IETF"]},{"entry":[{},"Internet Draft, work in progress, <draft-"]},{"entry":[{},"kutscher-mmusic-sdpng-req-01.txt>)."]},{"entry":["[Kut2]","D. Kutscher et al.: \u201cSession Description and Capability"]},{"entry":[{},"Negotiation\u201d, IETF Internet Draft, work"]},{"entry":[{},"in progress, <draft-ietf-mmusic-sdpng-05.txt>."]},{"entry":["[Man1]","D. Mandato, A. Kassler, T. Robles, G. Neureiter:"]},{"entry":[{},"\u201cConcepts for Service Adaptation, Scalability"]},{"entry":[{},"and QoS Concepts on Mobility-Enabled Networks\u201d"]},{"entry":[{},"(IST Global Summit 2001, Barcelona, September"]},{"entry":[{},"2001, pp. 285-293). This article describes the"]},{"entry":[{},"core concepts of the End-to-End Negotiation Protocol"]},{"entry":[{},"(E2ENP). A similar paper has been presented"]},{"entry":[{},"at PIMRC 2001 in San Diego, October 2001."]},{"entry":["[Man2]","D. Mandato, A. Kassler, T. Robles and G. Neureiter:"]},{"entry":[{},"\u201cHandling End-to-End QoS in Mobile Heterogeneous"]},{"entry":[{},"Networking Environments\u201d (PIMRC 2001,"]},{"entry":[{},"San Diego, 30\/9\/2001 to 3\/10\/2001, pp. C-49 to"]},{"entry":[{},"C-54)"]},{"entry":["[ReqSpec]","\u201cEnd-to-End Negotiation Protocol\u201d, IST-2000-"]},{"entry":[{},"28584\/SO\/WP1\/PI\/I\/003\/a1, MIND Internal Contribution"]},{"entry":[{},"to WP1, Activity 1.3, Work Item 2."]},{"entry":["[Ros1]","J. Rosenberg, H. Schulzrinne et al.: \u201cSIP: Session"]},{"entry":[{},"Initiation Protocol\u201d, IETF Standards Track,"]},{"entry":[{},"Network Working Group, RFC 3261. This document"]},{"entry":[{},"describes the Session Initiation Protocol (SIP),"]},{"entry":[{},"which is an application-layer control (signaling)"]},{"entry":[{},"protocol for creating, modifying and terminating"]},{"entry":[{},"sessions with one or more participants."]},{"entry":["[Ros2]","J. Rosenberg, H. Schulzrinne: \u201cAn Offer\/Answer"]},{"entry":[{},"Model with SDP\u201d, IETF Internet Draft, work in"]},{"entry":[{},"progress, <draft-ieft-mmusic-sdp-offer-answer-"]},{"entry":[{},"02.txt>. This document defines a mechanism by"]},{"entry":[{},"which two entities can make use of SDP to provide"]},{"entry":[{},"a common view of a multimedia session between"]},{"entry":[{},"them."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"[Cam1] presents a multi-phase call-setup mechanism that makes network QoS and security establishment a precondition to sessions initiated by the Session Initiation Protocol (SIP) and described by the Session Description Protocol (SDP). Network resources are reserved before the session is started, thereby using existing network resource reservation mechanisms (e.g. RSVP).","[Kly1] presents a format to express media feature sets that represent media handling capabilities. In addition, an algorithm is provided that matches the feature sets. It might be used to determine if the capabilities of a sender and receiver are compatible. In addition, in [Kly2] an abbreviated format for composite media feature sets that use a hash of the feature representation to describe the composite is disclosed.","In [Ros2], a complete model for a one-to-one capabilities negotiation with SDP is described. However, this model suffers from problems caused by the definition of mutually referred information and information on grouping media streams due to the flat hierarchy structure of the SDP.","[Kut1] describes a set of requirements relevant for a framework for a session description and an end-point capability negotiation in multi-party multimedia conferencing scenarios. Depending on user preferences, system capabilities or other constraints, different configurations can be chosen for the conference. Thereby, the need for a negotiation process among the peers is identified, but not described in order to determine a common set of potential configurations and select one of the common configurations to be used for information exchange. This capability negotiation is used to get a valid session description, compatible with the end system capabilities and user preferences of the potential participants. Different negotiation policies may be used to reflect different conference types. They also identify the need for network resource reservation coupled with session setup. Finally, a proposal is drafted for describing capabilities and providing the negotiation language, but not a protocol. Thereby, the solution proposed in [Kut1] does neither consider the negotiation protocol for determining a common set of QoS configuration nor integrate local, peer and network resource reservation.","The most recent version of this IETF draft, in the following referred to as [Kut2], provides a detailed XML Schema specification and a prototype of the Audio Codec and Real-Time Protocol (RTP) Profiles.","In [Bos1], an end-to-end user-perceived QoS negotiation is described, with the presumption that some middleware and services may strongly be involved in the final decision about the negotiated QoS-information of the end peers. The decision as described may be taken over some standard \u201ccontract types\u201d. Although it is mentioned that the signaling and the data path may go different ways through the network, it is suggested that some middleware on the way of the negotiation path may influence the negotiation though in general having nothing to do with the data paths. In case this protocol model is deployed, the network is not transparent. The negotiation process according to [Bos1] is performed at one shot interleaving also with some non-QoS information (e.g. security, network admittance, etc.) without considering protocol modularity and information consistency with respect to QoS. With the model of [Bos1], it is only possible to use a push mode for the negotiation, which may be restrictive for some applications and services. The adaptation paths are only degrading and fixed.","In the articles [Man1], [Man2], and [Cam2], the possibility of grouping media streams is discussed. However, the authors do not consider criteria for the grouping, the possibility of recursive group building (a group of many groups), and the treatment of real, pseudo-real and non-real-time information media streams that also may be grouped. Besides, [Man1] and [Man2] define negotiation steps that may or may not run at one shot but not during independent negotiation phases. For this reason, they do not meet the requirements for the consistency of the negotiated QoS information during a negotiation phase and after it. Thereby, in [Man1] the core concepts of the E2ENP are disclosed. The treatment of colliding \u201cEconomy Principle\u201d applications is also not considered. Moreover, [Man1] and [Man2] describe the possibility of setting and managing adaptation paths for the QoS adaptation, which is controlled by a third party component\u2014the QoS Broker. However, the authors do not consider any possibility for the end parties to perform and control the negotiations on their own.","Nowadays, adaptive applications and\/or middleware (e.g. QoS Brokers) do not comprise any component which is capable of handling QoS pre-negotiation, QoS negotiation and\/or QoS re-negotiation, resource reservation and\/or release coordination offering a technology-independent Application Programming Interface (API), which masks the type of signaling protocols used for implementing those mechanisms. Instead, adaptive multi-stream multimedia applications and\/or middleware have directly to be coded against protocols like H.323, the Session Initiation Protocol (SIP) and\/or the Session Description Protocol (SDP, in future SDPng as described in [Kut2]). Furthermore, said SIP- and\/or SDP-based applications or middleware directly perform a parsing of the SDP data and have to infer the actions to be taken by examining changes on the SDP data from previously exchanged versions thereof.","Another problem is that adaptive applications and\/or middleware (e.g. QoS Brokers) are not able to express the information to be negotiated (e.g. capabilities, application-level QoS Contracts, network-level QoS Contracts, stream-level adaptation paths, and stream-group-level adaptation paths) in an interchangeable format. It is required that heterogeneous applications and\/or middleware can easily agree on a reference model, which said applications and\/or said middleware can then use for dynamically configuring themselves to orchestrate local, peer, and network resources according to the preferences and profiles of the respective user, policies of the respective systems and network providers in a coordinated manner among a multiplicity of heterogeneous applications and middleware used by various peers.","In the European patent application EP 01 122 366.6, the overall E2ENP concept, its requirements, and a possible implementation idea thereof is disclosed, however, without detailing any implementation. Any pre-negotiated information is not accomplished in time.","Although the current form of SDPng as described in [Kut2] is structured in a modular way, it does not consider E2ENP aspects and can not be used in a modular way across different SIP messages (or other protocol messages). Capability negotiations based on SDPng use the SDP Offerer\/Answerer model described in [Ros2], in which complex multi-phase negotiation processes such as the one proposed in the scope of E2ENP are not explicitly taken into account.","A process capable of considering user profile information as input for the overall QoS negotiation process is neither addressed in the European patent application EP 01 122 366.6 nor in SDPng.","In view of the explanations mentioned above, it is the primary object of the underlying invention to propose a negotiation method and a software architecture supporting capability and QoS negotiation and session establishment combined with resource reservation mechanisms for adaptive real-time services and multimedia applications.","This object is achieved by means of the features of the independent claims. Advantageous features are defined in the subordinate claims. Further objects and advantages of the invention are apparent in the following detailed description.","The underlying invention is basically dedicated to the concept and realization of a novel User Agent (UA) for an End-to-End Negotiation Protocol (E2ENP)\u2014a software module encapsulating the end-to-end signaling processes of the E2ENP as described in [ReqSpec]\u2014, which can advantageously be applied to define user profile and terminal capability information in such a way that hierarchical QoS Contract specifications (e.g. compelling correlations across different sets of QoS Contracts for related media streams) can be enforced and used for deriving negotiable information. As a reference implementation of this concept, this invention describes a novel usage of the Session Initiation Protocol (SIP) standardized by the Internet Engineering Task Force (IETF) in conjunction with extensions of the Session Description Protocol\u2014Next Generation (SDPng) specification based on the Extensible Markup Language (XML) in order to implement End-to-End QoS Negotiation Protocol (E2ENP) concepts. More specifically, the hereby proposed model extends the SDPng negotiation mechanisms by defining user profile and terminal capability information which allow to enforce and use hierarchical QoS Contract specifications.","Thereby, said End-to-End Negotiation Protocol (E2ENP) is applied to derive negotiable information, which enables a pre-negotiation, fast negotiation and a fast, dynamic re-negotiation of the end-to-end quality and capabilities for a telecommunication session, for multiple configurations of two or a multiplicity of end peers and\/or middleware in a consistent, reliable, and incremental way by enabling the mobile applications to efficiently and timely react to QoS violations. Furthermore, the invention pertains to the concept and realization of a novel E2ENP User Agent which encapsulates the signaling part of E2ENP. Said E2ENP User Agent expresses the information to be negotiated in an interchangeable format in such a way that heterogeneous applications can easily agree on a reference model, which can then be used for dynamically configuring Finite State Machines to orchestrate local, peer, and network resources according to the preferences and profiles of the respective user in a coordinated manner.","According to the underlying invention, the conversation of an interchangeable format between an internal (application-and\/or middleware-specific) and an external (SIP User Agent specific) representation is performed by a Parser and a Factory implementation. These software components are also configurable according to the specific needs of the underlying carrier protocol agent, the E2ENP User Agent, and the respective application and\/or middleware. In this connection, the specific E2ENP User Agent session identification and the respective application and\/or middleware session identification of the applied negotiation processes and sub-processes are uniquely mapped to each other and cached in order to be able to uniquely identify pre-negotiation, negotiation and\/or re-negotiation sessions. Thereby, the Parser, the Factory, and the Cache are coupled with the implementations of the respective E2ENP User Agent. It should be noted that the configuration of these four software components\u2014Parser, Factory, Cache, and E2ENP User Agent\u2014and the User Agent of the applied carrier protocol is an application-specific task, which depends on the needs of the respectively employed application and\/or middleware component.","According to one embodiment of the underlying invention, an E2ENP UA  supports the following platforms: Win32 and Linux. Quality, robustness, maintainability, extensibility, flexibility and efficiency are the challenges to the architecture and its solutions.\n\n","For the architecture, the following basic conceptual and technical requirements can be derived:\n\n","The E2ENP UA  depicted in  is designed as a software component which communicates with the environment through the following five APIs:\n\n","Internally, the E2ENP UA  is composed of different Finite State Machines  (FSMs) handling the coordination of the procedures associated with the aforementioned interfaces, and their interrelations. More specifically, the E2ENP UA  should feature a client FSM  and a server FSM  for independently and simultaneously handling, respectively, the initiation of an E2ENP (pre-)negotiation and\/or session establishment, and the response to such procedures. This means mapping primitives of the interface (IF2) to primitives of the interface (IF3), and vice versa. The mapping of the primitives concerns both object and object identifiers mapping. The mapped objects and the identifiers are stored in a respective Cache  at the E2ENP UA  and\/or at the application  above IF2.","During this mapping process, the E2ENP UA FSMs  should also be able to access the interfaces (IF4) and (IF5) for handling, respectively, E2ENP session description decoding and encoding.","The Parser and Factory implementations  and , respectively, though essential entities for implementing the E2ENP concept, are designed as separated software components, insofar as they can be implemented in various ways (based on SDP, SDPng, SDPng dialects, or any other session description languages of choice).","In the following subsection, the basic problem domains of the to system shall be described and how they are solved within the E2ENP UA . Each problem domain is discussed individually and across the system. It refers to other problem domains if there is any interference with them or if a part of the problem domain is discussed more detailed in an extra section.","The E2ENP UA  is designed according to the object-oriented paradigm, and a Java-based prototype based on such design is hereby described. It allows using various types of XML parsing tools (through IF4) and various session level protocols (through IF3) to transport E2ENP primitives. The hereby-described prototype based on the aforementioned E2ENP UA design uses SIP as described in [Ros1] as session-layer protocols. Various SIP implementations are supported by the E2ENP UA design, thanks to the abstract nature of IF3.","In the scope of the underlying invention, both the E2ENP UA FSM  and the SIP UA Generic API (IF3) are explicitly designed to support SIP. It is foreseen that in a future design review these dependencies will be removed by making IF3 even more abstract. The E2ENP UA  will also be able to simultaneously support multiple users of multiple applications  using multiple instances of the E2ENP UA services.","The E2ENP UA  supports three types of object categories: identifiers (IDs), description objects (object graphs or a formal description of an object graph, like XML) and event objects. These categories correspond to the objects passed to the agent through IF2, IF3, IF4, and IF5 in both directions.\n\n","The IDs, the E2ENP UA FSM object graphs and the event objects are Java objects. The external protocol representations can be SDP, SDPng, SDPng dialects, or any other session description language objects of choice. The implementation of the Java objects passed through interface IF2 depend on the interface definition of IF2. The objects passed through the interfaces IF4 and IF5 are either E2ENP UA FSM  object representations or external protocol representations. The objects passed through IF3 are external protocol representations. All the external representations of the session description objects passed through IF3, IF4 and IF5 should implement java.io.Serializable in order to be compatible with the SIP Surrogate RMI implementation.","The internal representations of the session description objects passed over the IF2, IF3, IF4 and IF5 shall be typed as java.lang.Object and should be cast into the expected type by the E2ENP UA , the Parser , and the Factory . This requirement is necessary to keep the SIP UA  and the implementations of the Parser  and the Factory  modular by leveraging generic APIs.","The following section contains a brief survey of the applied implementations of the Parser  and the Factory .","Since the negotiation process involves at least two entities interconnected by a network, it is necessary to provide mapping functionality from system-internal representation to a transport representation over the network and back. The mechanisms that provide this mapping are called Parser API (in the following referred to just as Parser ) and Factory API (referred to as Factory ), where the Parser  takes an object encoded in network representation as input and generates a system-internal representation of said object. In contrast, the Factory  generates a network representation for a given system-internal representation.","The need for said Parser API , said Factory API and the functionality defined by them arises from the facts that the system-internal representation may not be appropriate for a transport representation that can be sent over networks and the transport representation may not be adequate for a system-internal representation.","Additionally, introducing these components into the system decouples the higher application layer from the lower transport-oriented layers. As a consequence, the actually used transport protocol is of no concern to the upper application layers and should ideally be pluggable.","The use of the Extensible Markup Language (XML) as transport syntax is motivated by the widespread adoption of XML as an industry standard, and it also allows for the incorporation of external features (SDPng libraries and profiles) and provides compatibility to related work (SDPng schema). Another feature of XML is its simple extensibility.","As described above, the use of different carrier protocols requires that the Parser  and the Factory  are configurable by the same means as the protocol, which means that in case the protocol is configurable at runtime, said Parser  and said Factory  might also have to be changed while the system is running. This implies the specification of an abstract interface, since the actual implementations depend on the specific underlying carrier protocols.","Concrete Factory  implementations for different carrier protocols will produce different results. For example, an RMI factory may just be a dummy implementation. It is thus possible to transfer Java objects, e.g. the objects \u201cas is\u201d, directly over a network connection by simply using Java Remote Method Invocation (RMI).","If SIP is used as a carrier protocol, however, an external representation (more specifically a protocol data unit or PDU) to be sent over the network has to be generated.","Possibilities include but are not limited to some proprietary text format similar to SDP, for example, or a more structured approach using XML, as e.g. SDPng does.","The API definitions for the Parser API and the Factory API are un-typed in order to support loose coupling of the E2ENP UA  and the Parser  as well as the Factory . The transport representation as described above is implemented by just using the java.io.Serializable interface, which is inherently un-typed. The system-internal representation is chosen to be the represented as java.lang.Object. The matching between the actual implementations of the Parser  and the Factory  and the object representation used in the E2ENP UA  have to be established by configuration.","The mechanism is implemented by the following two software components:\n\n","Additionally, in order to achieve configurability, the use of a \u201cfactory design pattern\u201d for creating Parser  and Factory  instances is a possible solution. For this purpose, the factory method is parameterized with the transport protocol (the distinguishing feature of different Parser \/Factory  implementations). If dynamic support for different carrier protocols is needed, the factory classes have to provide a registration procedure for new protocols.","In the next section, the use of SIP surrogates shall briefly be described.","The applied SIP UA Generic API (IF3) requires the availability of a SIP UA implementation which supports such an API. Similarly, the Parser API (IF4) and the Factory API (F5) presume the availability of parser and factory implementations compatible with the UA implementation , respectively. In order to allow validating and rapidly prototyping the E2ENP model, IF3, IF4, and IF5 have been designed in such a way that surrogates of real SIP UA implementations and of compatible Parser  and Factory  implementations can be used as handy alternatives for experimental purposes.","By using a legacy implementation (already provided code\/API and\/or software, possibly from an external implementer) of the SIP UA  for testing and\/or updating the E2ENP UA , it might be sometimes difficult to establish the connection between the E2ENP UA  and the SIP UA , as the interface provided by the legacy SIP implementation may not match directly the interface required by the E2ENP UA. In general, using a SIP UA  to provide network connectivity for the E2ENP UA  is not recommended whenever testing new E2ENP UA  features, due to possible conceptual contradictions between the protocol agents (SIP and E2ENP). These contradictions may result in specification changes of the carrier protocol\u2014SIP, that is why for the tests of the E2ENP UA  the usage of a SIP emulator (which can easily adopt conceptual changes) is preferable.","In order to carry out a SIP emulation, SIP surrogates (e.g. Remote Procedure Call mechanisms, RPCs) can be employed. When E2ENP session description payloads have to be tested without necessarily using \u201cfull-blown\u201d Parser  and Factory  implementations, solutions coupled with the chosen SIP surrogate can also be applied.","As mentioned above, a prototype E2ENP UA  implementation based on the hereby-presented architectural model has been selected for demonstrating the E2ENP concept. Since this implementation is based on Java, an RPC-based, built-in Java RMI mechanism has been selected as SIP surrogate.","Since RMI takes care of marshalling or demarshalling the SIP UA Generic API (IF3) primitives payload directly, all the parameters passed to the API have to implement the java.io.Serializable interface.","In order to test E2ENP session description payloads without necessarily using \u201cfull-blown\u201d Parser  and Factory  implementations (for the same reasons set forth above for the use of SIP surrogates), passing such content through the IF3 as a string might be not necessary as RMI can process objects. Rather, a whole object structure representing a given E2ENP session description payload might be exchanged directly through the RMI marshalling or demarshalling mechanism. Therefore, the prototype E2ENP UA  implementation based on the hereby-presented architectural model has been designed in such a way that the IF3 primitives shall accept as parameters any object implementing the java.io.Serializable interface, and not just instances of the java.lang.String class.","Said mechanism is implemented by the following software components:\n\n",{"@attributes":{"id":"p-0116","num":"0139"},"figref":"FIG. 2","b":["110","114","112"]},{"@attributes":{"id":"p-0117","num":"0140"},"figref":"FIG. 3","b":["114","112"],"i":["b ","b "]},"The Dummy ParserFactory and the Dummy FactoryFactory respectively create the \u201cDummy Parser\u201d runtime instance and the \u201cDummy Factory\u201d runtime instance ","Though indicated as \u201cdummy\u201d, still, said Parser and said Factory could check and\/or enforce that the objects used in the object graph are typed as \u201cjava.io.Serializable\u201d.",{"@attributes":{"id":"p-0120","num":"0143"},"figref":"FIG. 4","b":["114","112","112","114","126"],"i":["c ","c ","a ","a ","c"]},"The Dummy FactoryFactory and Dummy ParserFactory create respectively the \u201cDummy Parser\u201d runtime instance and the \u201cDummy Factory\u201d runtime instance ","Though indicated as \u201cdummy\u201d, still, said Parser and said Factory could check and\/or enforce that the objects used in the object graph are typed as \u201cjava.io.Serializable\u201d.","In the following subsections, the software components applied within the scope of the E2ENP UA  according to the underlying invention shall briefly be described from the viewpoint of the component. For each software component, its requirements, offered services and constraints are described and also its relations to other software components. This description serves as the basis for the detailed design.",{"@attributes":{"id":"p-0124","num":"0147"},"figref":"FIG. 1"},"Accordingly, the entity using the services offered by a given API will be referred to as Service User, whereas the entity implementing the services of said API will be referred to as Service Provider.","The E2ENP UA API (the aforementioned IF2) exposes the E2ENP UA functionality to Service Users like QoS-aware applications  and\/or QoS Brokers , according to the BRENTA model as described in [BRENTA]. This component realizes the specification of a generic API by defining a set of interfaces and complex data types exchanged through said API.","Thereby, said E2ENP UA API allows multiple instances of Service Users to simultaneously access the E2ENP UA  functionality. More specifically, the E2ENP UA  offers the following services as described in [ReqSpec]:\n\n","In order to expose these services, the E2ENP UA API shall expose, respectively, the following primitives:\n\n","The E2ENP UA API has been designed based on the following design principles:\n\n","Thereby, said E2ENP UA API depends on the respective application  and\/or middleware  using the services of said E2ENP UA , the applied E2ENP UA FSM , concerning the implementation of the Request (Req) and Response (Rsp) primitives, and the applied Factory  and Parser : The chosen implementation of these components dictates the type of representation used for the information exchanged through this API.","The E2ENP UA API has been designed with the aid of the object-oriented paradigm, and is thus hereby described using the Unified Modeling Language (UML). The information to be exchanged via the E2ENP is described above. The component is composed of a basic package, the org::mind::e2enp as depicted in .","To this basic package belong the following interfaces:\n\n",{"@attributes":{"id":"p-0133","num":"0187"},"figref":"FIGS. 39A and 39B","b":"502"},"The E2ENPUserAgentListener interface  is specialized in the OffererListener interface  and the AnswererListener interface . The former is specially designed for the application- or middleware-initiating E2ENP procedures; the latter is specially designed for applications  or middleware  responding to said E2ENP procedures.",{"@attributes":{"id":"p-0135","num":"0189"},"figref":["FIG. 40","FIG. 41"],"b":["506","508"]},"The \u201cto\/from\u201d-parameters passed on by the pre-negotiation and negotiation primitives are addresses identifying E2ENP users (respectively, the Offerer and the Answerer). The E2ENP UA  maps these addresses to the specific syntax used by the given session-layer protocol that is used for piggybacking E2ENP information: in the case of this writing, SIP. The E2ENP addresses shall therefore be independent of the specific session-layer protocol, and possibly of the transport protocol used underneath by the E2ENP UA . To this extent, a new syntax, which has specially been designed for the E2ENP, shall herewith be proposed.",{"@attributes":{"id":"p-0137","num":"0191"},"figref":"FIG. 5B","b":["101","108","102","101","510","512","112","114","514","516"],"i":["a ","a "]},{"@attributes":{"id":"p-0138","num":"0192"},"figref":"FIG. 6"},"The full or partial usage of the E2ENP address components depends on the domain model (proxying) and the address resolution mechanisms, which are mainly part of the respectively applied session layer protocol (e.g. SIP). The E2ENP UA  should use at least the user (default user) name and the domain name to identify the communicating partners, if the session layer protocol is already offering some proxying and\/or redirection mechanisms to identify the network paths.","In the following subsections, the procedures executed by the E2ENP UA API shall be described by means of a set of UML Message Sequence Charts (MSCs).",{"@attributes":{"id":"p-0141","num":"0195"},"figref":["FIG. 7","FIG. 7"],"b":["704","706"]},{"@attributes":{"id":"p-0142","num":"0196"},"figref":"FIG. 8"},"The re-negotiation procedure is similar to the negotiation procedure, except that the names of the primitives have been changed as follows:",{"@attributes":{"id":"p-0144","num":"0198"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":[{},"Old Name","New name"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"bookNegotiation<type>","bookReNegotiation<type>"]},{"entry":[{},"negotiation<type>","reNegotiation<type>"]},{"entry":[{},"negotiationStatus<type>","reNegotiationStatus<type>"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The Cache  is a database for saving different object identifiers. In order to decouple the Service User identification scheme from the one specified for the E2ENP [ReqSpec], an E2ENP Cache  is used for:\n\n","The Cache  should be searchable for different identifiers and following different criteria set by the E2ENP UA . The E2ENP UA  is responsible for the Cache management.","The cached objects correspond to the identifier object category. The Cache  maintains two types of data:\n\n","The E2ENP Cache  is a database used for managing the negotiation object IDs. The E2ENP UA FSM  requests the Cache  services. In an embodiment of this invention, the Cache  is designed as a set of java.util.Hashtable objects referencing each other. An alternative implementation based upon tupel-space technology is left for further study.","In order to keep the E2ENP UA  implementation simple, the Cache API  between the Cache  and the E2ENP UA FSM  represents a synchronous interface.","In the implemented version of the underlying invention, a two-stage Cache  is used:\n\n","The two levels of the Cache  are implemented as two distinct singleton objects as described in [Gam], which are initiated and managed by the E2ENP UA . The Cache objects run within the instance of the E2ENP UA .  depicts a UML Class Diagram of the org::mind::e2enp::Cache sub-package that contains the Cache implementation.","The singletons LevelOneCache  and LevelTwoCache  respectively represent the Cache level L1 and the Cache level L2 and provide APIs for creating, searching, and releasing Cache entries (LevelOneEntry  and LevelTwoEntry , respectively).","The methods provided by the API of the first and second Cache level (L1 and L2) are depicted in  and , respectively.","In the following subsection, an XML-based serialized transport representation shall be defined by means of an XML schema definition. Rather than defining such a format from scratch, the transport representation is based upon and using the baseline SDPng format definition. Aside from providing compatibility, it is also possible to use and benefit from a third-party library and profile definitions designed for SDPng as described in [Kut2]. Examples include but are not limited to the Real-Time Protocol (RTP) as well as audio and video codec profiles.","In order to illustrate how the Factory API and the Parser API share common transport representation syntax, the following subsection provides one possible definition for such a format. The XML description of E2ENP extends and uses the baseline SDPng XML description format.","The XML representation for E2ENP (in the following, E2ENP will be used synonymously for this representation) has chosen to be an extension to the SDPng baseline XML definition. The main reason for this decision is that SDPng is expected to be standardized by the IETF, which results in some major benefits:\n\n","The E2ENP XML representation is formally specified by an XML Schema definition as defined by the W3C. The schema definition can roughly be separated into three parts, one containing type definitions such as enumerations for attribute values or the definition of common content models as complex types. The main part defines the top-level E2ENP sections (i.e. elements), which are also plugged into SDPng using the substitution group mechanism. Finally, the third part defines E2ENP-specific elements with no relation to SDPng, which are used to completely define the content model of the top-level elements.","As can be seen in , descType \u2014originally defined in SDPng\u2014is redefined in such a way that the E2ENP-specific header section \u201cpurpose\u201d  appears as a legal child of the \u201cdesc root\u201d element. E2ENP defines a \u201cqosdef\u201d section which can be used as a substitute for the \u201csdpng:d\u201d element, the only valid child for the \u201csdpng:def\u201d  section, similarly, \u201cqoscfg\u201d may be used instead of \u201csdpng:c\u201d, in turn the only valid child for the \u201csdpng:cfg\u201d  section. The E2ENP-specific element types will be described in the following.","The extensions and plug-ins to SDPng are illustrated in , which shows how elements in substitution groups can be used to replace the head element of this group.","Here, \u201csdpng:d\u201d  is the head element which may be substituted by any of the members of the substitution group, that is, \u201caudio:codec\u201d , \u201ce2enp:qosdef\u201d , \u201crtp:pt\u201d , \u201crtp:transport\u201d 01111 (which in turn again is the head element of a nested substitution group) and \u201cvideo:codec\u201d . Thus, by using the substitution group mechanism combined with the XML namespaces concept, it is possible to define modular extensions to any XML schema definition. Additionally, the substitution group member \u201crtp:udp\u201d  can further be enhanced in order to support the option sub-group described in [Bost], thereby incorporating an option similar to that suggested by [Bost] (not shown in ).","The aforementioned \u201cqoscfg\u201d element  is defined in the substitution group headed by \u201csdpng:c\u201d, which in turn is a valid child of the \u201csdpng:cfg\u201d section.","Using the \u201cpurpose\u201d  element depicted in , it is possible to convey additional information about the negotiation process in the external description. The general structure of how the purpose element is defined is shown in .","Thereby, the header defines to which session the current message belongs to. It can also establish references to previous sessions by means of the \u201cuse\u201d  element, making it possible to reference definitions from these sessions.","Depending on what the E2ENP message is intended for, either the \u201cdescription\u201d  or the \u201cmediation\u201d  element should be present. For example, with the aid of the \u201cdescription\u201d  element it is possible to state the kind of a message, i.e. Request (Req) or Response (Rsp) and what negotiation mode should be used (push, pull, push-pull).",{"@attributes":{"id":"p-0165","num":"0228"},"figref":"FIG. 13","b":["1300","1300","1300","128"],"ul":{"@attributes":{"id":"ul0031","list-style":"none"},"li":{"@attributes":{"id":"ul0031-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0032","list-style":"none"},"li":["Specifying Capabilities: In case the \u201cname\u201d attribute's value of the \u201cqosdef\u201d element  is \u201ccapabilities\u201d, the valid child elements are \u201caudio:codec\u201d , \u201cvideo:codec\u201d , and \u201crtp:pt\u201d . The respective codec elements represent system capabilities of the peer in terms of audio and video codecs and their configuration. By using the \u201crtp:pt\u201d  element, it is possible to specify a desired RTP payload format for the given capabilities.","Specifying Contracts: In this case, the attribute value of the \u201cname\u201d element of the qosdef element  has to be \u201ccontracts\u201d. Then, the valid child elements are \u201cpolicy\u201d , \u201caudio\u201d , and \u201cvideo\u201d . The \u201cpolicy\u201d element has to appear exactly once. It specifies the usage for negotiating the resource management policies to enforce. It is possible to use a policy to optimize one or several aspects of system behavior, such as optimization of memory usage, CPU load, network traffic or power consumption. In order to achieve more flexibility, these atomic aspects can be combined by using predicates. The elements following the \u201cpolicy\u201d  element can be one or many \u201caudio\u201d , \u201cvideo\u201d , \u201cdata\u201d , and \u201ccontrol\u201d  elements. These elements describe the QoS Contracts for the respective data-streams. By using the \u201crtp:map\u201d  element it is possible to define a mapping between an application level QoS Contract and a specific RTP payload format."]}}}},{"@attributes":{"id":"p-0166","num":"0231"},"figref":"FIG. 14","b":["1400","1401","1401"]},"In the following subsection, a brief overview of the Parser API shall be given.","The Parser API provides primitives, which can be used to parse a description in some transport representation and generate an object representation according to IF2. In order to be able to loosely couple the E2ENP UA  and the Parser , this object representation is abstracted in such a way that it is expressed as a java.lang.Object. As already pointed out, the only requirement for the transport representation is that it implements the java.io.Serializable interface. This can be interpreted in the sense that the transport representation is un-typed, thereby providing much flexibility regarding what this representation can actually look like.","The transport representation may contain references to external, previously defined entities. These references are left untouched and unresolved by the Parser . This issue is handled later in the E2ENP UA  or higher layer entities.","The Parser API provides one primitive for each message type to be passed. Like this, the message types are represented implicitly and do not need to be considered in the object model. For each message type, the Parser  offers one primitive to parse the offer and the answer of the respective message type. Therefore, the general pattern depicted in  for the Parser API primitives is\n\n","Thereby, \u201cXXX\u201d denotes a placeholder for the names of primitives like Negoffer or PreNegAnswer, etc. (see the API definition below for more details)","In addition to these general parsing methods, the Parser API provides some specialized primitives intended to navigate through the content wrapped in the serialized representation. These primitives can be used by clients to access specific information or data on an abstract level, independent from the actual representation. Thus, if the representation changes due to future protocol enhancements, the clients which use older versions of the representation are not affected by the new changes since the information access methods do not change.","As the actual carrier protocol should be exchangeable, there is a need for providing functionality to exchange the actual Parser  implementation as well. As described above, this mechanism has to be the same for the Parser  implementation and for the carrier protocol.","Therefore, a ParserFactory API is defined which provides primitives to create an actual Parser  implementation instance (factory  depicted in  shows an implementation of such a ParserFactory). Additionally, it is possible to register new actual Parser  implementations for any given carrier protocol.","The communication between the E2ENP UA  and the Parser  could be asynchronous, e.g. implemented by an active request interface and a passive confirmation interface. However, this option is not appropriate for the underlying design, because some gain in performance and flexibility is opposed by much more complicated state models for the FSMs  of the E2ENP. One consequence of this decision is that the E2ENP UA  and the Parser  (and also the Factory ) communicate synchronously and thus have to share a common address space, which in most circumstances is a reasonable assumption.","Another consequence of this decision is that the Parser  (and also the Factory ) have to be designed as threadsafe, re-entrant libraries.","The object representation, generated during the parsing and passed as a result back to the calling E2ENP VA , is described very abstractly by just using the java.lang.Object class, in order to provide loose coupling of the Parser  and the E2ENP VA . The actual classes implementing the Parser  for a given transport representation and a given object model, used in the E2ENP VA , have to be fitted together by configuration.","The actual Parser and Factory implementations  and , respectively, have to agree on a common format for the transport representation. The definition of these formats is implementation-specific and corresponds to the actual Parser  and Factory  components, even though the usage of existing standards is encouraged and envisioned. Therefore, a format has been defined, which is compatible to the baseline SDPng definition.","The registration functionality offered by the ParserFactory API can be handled in different ways. However, this is up to the actual ParserFactory  implementation. Some options what can be done with registration are:\n\n","Applications  may check if they have instantiated a matching pair of Parser  and Factory  by calling the respective getType( ) methods of these instances and comparing the returned values for equality. The usage of a non-matching pair of Parser  and Factory  by an application  may result in unpredictable results and undefined or even erroneous behavior.","In the following, the dependencies shall briefly be summarized.\n\n","The primitives to be implemented by the Parser API can be taken from . By contrast, the primitives to be implemented for generating a specific Parser  are listed in .","The ParserFactory API is realized by the class E2ENPContentHandlerFactory in the package org.mind.e2enp.content, also referred to as parser-factory implementation. It is designed as a singleton instance, so that all its clients can use registrations made earlier. Currently, the singleton instance created is a default implementation, but for future releases it is planned to provide a configurable approach (based on specific system properties) to determine the class to be used for the singleton instance. Methods provided by the E2ENPContentHandlerFactory class are depicted in .","In the following subsection, the implementation of the Parser  needed for an XML-based transport representation shall briefly be described. Thereby, a possible Parser  implementation for the XML-based transport representation is proposed.  describes the general structure of a Document Object Model (DOM) tree, modeled as a class DocumentTree , which aggregates one DocumentNode  and can be interpreted as the document root element. Each DocumentNode  in turn aggregates between 0 and N children, thus recursively describing the tree structure.","The Parser  for this representation can be implemented by using the \u201cvisitor design pattern\u201d as described in [Gam]. The structural overview is given in . Thereby, a generic Parser  visitor class pVisitor  is defined to use, or to be precise visit, 1 to N DOMNodes . In order to handle derived DOMNodes for each specially derived DOMNode subclass, a specialized visitor is defined. (Even if the \u201cvisitor pattern\u201d is intended for handling only subclasses, this concept can easily be extended in such a way that different element nodes are interpreted as categories of their own.)","In the following, the Application Programming Interface (API) applied to the Factory  shall briefly be described. The Factory API provides primitives which can be used to create a transport representation for a given object representation according to IF2. The loose coupling of the E2ENP UA  and the Factory  is realized via the abstraction of the object representation (passing through the Factory interface ) as a java.lang.Object. As already pointed out, the only requirement for the transport representation is that it implements the java.io.Serializable interface. Therefore, the primitives defined by this API all return \u201cjava.io.Serializable\u201d objects.","The object description may contain references to external, previously defined entities. These references are not handled or dereferenced by the Factory methods, they are just used.","Like the Parser , the Factory API provides one primitive for each message type to be passed. Like this, the message types are represented implicitly and do not need to be considered in the object model. The general pattern for the Factory API primitives as depicted in  is:\n\n","Thereby, \u201cXXX\u201d denotes a placeholder for the names of primitives like NegOffer or PreNegAnswer, etc. (see the API definition below for more details).","Since the actual carrier protocol should be exchangeable, there is a need to provide a functionality to make the actual Factory  implementation exchangeable as well. As described above, this mechanism has to be the same for the Factory  implementation and for the carrier protocol. Therefore, a FactoryFactory API is defined which provides primitives to create an actual Factory  implementation instance. (factory  in  shows an implementation of such a FactoryFactory.) Additionally, it is possible to register new actual Factory  implementations for any given carrier protocol in order to illustrate how the Factory API and the Parser API share a common transport representation syntax.","Communication between the E2ENP UA  and the Factory  could be asynchronous, e.g. implemented by an active request interface and a passive confirmation interface. This option is not used in the scope of the underlying invention because some gain in performance and flexibility is opposed by much more complicated state models for the FSMs  of the E2ENP. One consequence of this decision is that the E2ENP UA  and the Factory  (also the Parser ) communicate synchronously and thus have to share a common address space, which in most circumstances is a reasonable assumption.","Another consequence of this decision is that the Factory  (and also the Parser ) have to be designed as thread-safe, re-entrant libraries.","In order to provide loose coupling of the Factory  and the E2ENP UA , the transport representation, generated by the Factory  and passed back to the calling E2ENP UA  as a result, is abstractly described by using the java.io.Serializable class. Similarly, the java.lang.Object class abstractly describes the inputs of the Factory  primitives. Thus, the actual classes implementing a Factory  for a given transport representation and a given object model used in the E2ENP UA  have to be fitted together by configuration.","The actual Parser  and Factory  implementations have to agree on a common format for the transport representation. The definition of these formats is implementation-specific and corresponds to the actual Parser  and Factory  components, even though the usage of existing standards is encouraged and envisioned. Therefore, a format is proposed which is compatible to the baseline SDPng definition.","The registration functionality offered by the FactoryFactory  can be handled in different ways. Some options for registrations include but are not limited to:\n\n","Applications  may check if they have instantiated a matching pair of Parser  and Factory  by calling the respective getType( ) methods of these instances and comparing the returned values for equality. The usage of a non-matching pair of Parser  and Factory  by an application  may result in unpredictable results and undefined or even erroneous behavior.","In the following, the dependencies shall briefly be summarized:\n\n","The primitives specified by the Factory API can be taken from . Additionally, the primitives to be implemented for generating a specific Factory  are listed in .","The FactoryFactory API is realized by the class E2ENPContentHandlerFactory in the package org.mind.e2enp.content, also referred to as factory-factory implementation. It is designed as a singleton instance, so that all its clients can use registrations made earlier. Currently, the singleton instance created is a default implementation, but for future releases it is planned to provide a configurable approach (e.g. based on specific system properties) to determine the class to be used for the singleton instance. Methods provided by the E2ENPContentHandlerFactory class can be taken from .","In the following subsection, a possible Factory  implementation for the XML-based transport representation shall be presented.","Like the Parser , the Factory  implementation uses the \u201cvisitor design pattern\u201d described in [Gam]. The structure is illustrated by .","Again, a generic Factory  visitor class fVisitor  is defined which visits 1 to N instances of ObjectGraphNode  classes. For each concrete subclass of ObjectGraphNode, a corresponding concrete visitor class is defined.","In the following subsection, a brief overview of the SIP User Agent Generic API (IF3) shall be given.","Since the SIP User Agent Generic API exposes the functionality of a generic SIP UA  to the E2ENP UA , the main object of this API is to mask the actual implementation of the SIP UA  from the E2ENP UA FSM . The SIP User Agent Generic API realizes the specification of such generic API by defining a set of interfaces and complex data types exchanged through said API. Specific SIP UA  implementations will be able to expose their native (eventually standard) APIs by means of specific Adapters, which shall map the SIP API native interfaces into the SIP UA Generic API , and vice versa.","The SIP UA Generic API allows multiple users to simultaneously access a given SIP UA  implementation (via multimedia applications  or middleware ) for simultaneously establishing multiple SIP sessions.","The SIP UA Generic API also supports SIP Registrar implementations with the SIP signaling required by these entities. To this extent, it should be noted that the SIP UA Generic API is not designed to allow the simultaneous support of users' applications  and SIP Registrars on the same memory address space. With this design choice, SIP Registrar implementations are thus forced to run as standalone server side entities, distinct from pure application  or middleware  entities (in the present context, the E2ENP UA FSM ). Applications  and\/or middleware  (in the present context, the E2ENP UA FSM ), and SIP Registrar implementations are examples of Service Users. A SIP UA  implementation exposing the SIP UA Generic API represents the Service Provider.","The SIP UA Generic API has originally been designed to expose an API from a specific open source SIP UA  implementation, the Mitre's JSIP v.0.8 library (http:\/\/jsip.sourceforge.net\/), wherein API support is quite poor. The SIP UA Generic API has been designed based on the following design principles:\n\n","Further design choices are:\n\n","The SIP UA  associates an unused value of the connectionId to the SIP Call Identifier header field of an incoming INVITE, OPTIONS, MESSAGE, or REGISTER method. By applying the same design principle, Service Users requesting the transmission of any of those methods would obtain the connectionId value selected by the Service Provider in the Confirmation (Cfm) primitive associated with the original Request (Req) primitive.","Unfortunately, this solution is affected by to two problems:\n\n","To solve these problems, the Service User must be in charge of selecting an unused connectionId value and force the SIP UA  associating such value with a proper SIP Call Identifier header field value.","The set of connectionId values allocated by the Service Provider in case of incoming INVITE, OPTIONS, MESSAGE, or REGISTER methods and by the Service User in case of outgoing INVITE, OPTIONS, MESSAGE, or REGISTER methods should be distinct, so that the processing of incoming and outgoing INVITE, OPTIONS, MESSAGE, or REGISTER methods can simultaneously take place without interference.","However, for the sake of simplicity, the SIP UA Generic API has been designed with a centralized management of connectionId values allocation, embedded into the Service Provider itself. Service users are yet in charge of allocating connectionId values for outgoing INVITE, OPTIONS, MESSAGE, or REGISTER methods, but the actual allocation is delegated to the Service Provider by invoking the getConnectionId( ) method exposed by Service Provider. This method can in no way be considered a primitive itself, since it directly returns a value (the selected connectionId value): For instance, this would prevent implementing a loosely coupled interface, where primitives are exchanged between Service User and Service Provider via a (not RPC-like) message-based protocol. In any case, Service Users and Service Providers can be designed without the centralized connectionId value allocation management, and yet being compliant with the SIP UA Generic API , by simply not using respectively implementing the getConnectionId( ) method. As a special case, a connectionId can be reused in case of SIP re-INVITEs: in this case, a proper Boolean parameter indicating whether this is a re-INVITE, shall be passed to the connectionReq primitive (see below).\n\n","These primitives will eventually be mapped to more generic ones in a future E2ENP UA  design review in order to transform the SIP UA Generic API into a E2ENP Session Level Protocol API, which will be totally independent of the session-layer protocol actually used.\n\n","Thereby, said E2ENP UA API depends on the applied E2ENP UA FSM , concerning the implementation of the Indication (Ind) and Confirmation (Cfm) primitives and the Management component , which is used for configuring, controlling, and resetting the underlying SIP UA .","The SIP UA Generic API has been designed using the object-oriented paradigm, and is thus hereby described by using the Unified Modeling Language (UML). It is composed of a basic package, the so-called org::mind::sip::sipApi as depicted in . To this basic package belong the classes SipEndUser  and SipExpiresHandling . The SipEndUser class  represents a user accessing the SIP services offered by the SIP UA Generic API . The SipExpiresHandling class generalizes the functionality for manipulating the SIP Expires header field. The SipListener  generalizes all the interfaces that Service Users shall implement for intercepting Indication (Ind) and\/or Confirmation (Cfm) primitives generated by the SIP UA . The SipProvider  generalizes all the interfaces that the Service Provider shall support for implementing Request (Req) and Response (Rsp) primitives.","Four sub-packages complete the SIP UA Generic API specification: one, the org::mind::sip::sipApi::time, deals with the SIP Expires header field abstraction, whereas the other three characterize different roles of the Service User:\n\n","The org::mind::sip::sipApi::userAgent sub-package (cf. ) contains interfaces and classes specifying the part of the SIP UA Generic API that the Service User of the IF3 (in the present context, the E2ENP UA FSM ) use for accessing the Service Provider. It consists of three major parts:\n\n","Finally, this sub-package contains a class named SipNegotiationModel , which represents the E2ENP negotiation model.","The org::mind::sip::sipApi::registrar sub-package (cf. ) contains interfaces and classes specifying the part of the SIP UA Generic API that SIP Registrar implementations used for accessing the Service Provider. It consists of three major parts:\n\n","The org::mind::sip::sipApi::management sub-package (cf. ) contains interfaces and classes specifying the part of the SIP UA Generic API applied to the management entity  for configuring and controlling the Service Provider. It consists of three major parts:\n\n","The org::mind::sip::sipApi::time sub-package (cf. ) contains interfaces and classes specifying the part of the SIP UA Generic API that allow Service Users manipulating the SIP Expires header field. It consists of two major parts:\n\n","In the following subsection, the procedures enabled by the SIP UA Generic API shall be described by using a set of UML Message Sequence Charts (MSCs).",{"@attributes":{"id":"p-0224","num":"0345"},"figref":["FIG. 25","FIGS. 26A and 26B"],"b":["110","101","110","101"],"i":["c ","c "]},"This procedure starts with a connectionReq primitive invoked by a peer acting as calling party (or initiator), triggers a message exchange, which terminates only when the peer acting as called party (or responder) after having initially received a connectionInd primitive notifying the initiator's invitation to establish a SIP session, eventually accepts such invitation (after a number of negotiation and signaling steps), and replies with a connectionRsp primitive.","The responder generates SIP-provisional responses through the connectionStatusReq primitive invocations, which map at initiator's side to connectionStatusInd primitive invocations. The initiator acknowledges provisional responses with the PRACK method, by using the ProvisionalAckReq\/Cfm primitive, which corresponds at responder's side to ProvisionalAcklnd\/Rsp primitive, respectively.","This procedure ends with the initiator receiving a connectionCfm primitive and the responder receiving a connection-Statuslnd primitive. The latter is due to the SIP three-way acknowledgment scheme described in [Ros1].","Two procedures in this MSC are assumed to be executed automatically by the Service Provider: The generation of the \u201c100 Trying\u201d provisional response at responder's side, and the generation of the final ACK signal at initiator's side. The latter can, however, be forced by the Service User itself via the connectionStatusRsp primitive, but this means that the Service User must accordingly be configured not to generate the ACK signal automatically.","Final SIP responses indicating other reasons than success are generated either automatically by the Service Provider or explicitly by the responder's Service User via the connectionStatusReq primitive. These SIP responses are notified to the initiator's Service User via the connectionStatusInd primitive.",{"@attributes":{"id":"p-0230","num":"0351"},"figref":["FIG. 27","FIG. 28"]},"In the following subsection, the Finite State Machine  (FSM) applied to the E2ENP UA  shall briefly be described.","The core of the E2ENP UA  is composed of a Finite State Machine  (FSM), which coordinates the overall functionality and implements a part of the aforementioned interfaces. More specifically, the FSM  implements the Service User part of the IF3, IF4 and IF5, and the Service Provider part of the IF1 and IF2. Furthermore, the E2ENP UA FSM  makes use of the Cache  described above.","The FSM  is designed hierarchically as a StateChart. In the Root State (cf. ), the FSM  handles session-terminating events, either associated with local or remote users' decisions. Furthermore, the Root State handles pre-negotiation, lease renewal, negotiation as Offerer\/Answerer, re-negotiation, and session release processes. It should be noted that the term \u201cnegotiation\u201d process is used for indicating a multimedia session establishment, intertwined with resource reservation coordination and QoS negotiation, as described in [ReqSpec].","The role of the Offerer is taken by the peer who is initiating a session establishment with QoS negotiation and resource reservation, but also by the peer who decides to initiate a re-negotiation. The role of the Answerer is always taken by the peer who is responding to an invitation to carry out a session establishment process with QoS negotiation and resource reservation, but also by the peer who decides to respond to an invitation to carry out a re-negotiation. This means that a peer initially acting the Offerer role can later take either the Offerer or the Answerer role during a re-negotiation. And vice versa, a peer initially acting the Answerer role can later take either the Offerer or the Answerer role during a re-negotiation.","For the sake of simplicity,  does not detail the handling of primitives associated with IF1 (Management API); neither the internal interfaces with the FSM factory  nor the Cache  are taken into account.","The following subsections provide a detailed description of the mutex-related procedures shown in .","Lower-level details of the negotiation process as Offerer\/Answerer are encapsulated in nested FSMs , respectively the NegOfferer sub-state (cf. ) and the NegAnswerer sub-state (cf. ).","The NegOfferer sub-state contains a nested FSM  capturing the logic handling the negotiation process, as seen from the Offerer perspective. The NegAnswerer sub-state contains a nested FSM  capturing the logic handling the negotiation process, as seen from the Answerer perspective.","In order to guarantee consistency and avoid deadlocks during the combined reservation of local, peer, and network resources as described in [ReqSpec], the FSMs  nested in the NegOfferer sub-state and in the NegAnswerer sub-state use the system-wide \u201c_ResvMtx\u201d FSM  for accessing the reservation phase on a mutually exclusive basis, with respect to other instances of the E2ENP UA FSM . The \u201c_ResvMtx\u201d FSM  interacts with various instances of the E2ENP UA FSMs  via atomic local methods invocation (e.g. via any specific system call provided by the underlying Operating System).","The following subsections provide a detailed description of the mutex-related procedures shown in .","Lower-level details of the re-negotiation process as Offerer\/Answerer are encapsulated in nested FSMs , respectively the ReNegOfferer sub-state (cf. ) and the ReNegAnswerer sub-state (cf. ).\n\n","In order to guarantee consistency and avoid deadlocks during the combined reservation of local, peer, and network resources as described in [ReqSpec], the FSMs  nested in the ReNegOfferer sub-state and in the ReNegAnswerer sub-state use the system-wide \u201c_ResvMtx\u201d FSM  for accessing the reservation phase on a mutually exclusive basis, with respect to other instances of the E2ENP UA FSM . The \u201c_ResvMtx\u201d FSM  interacts with various instances of the E2ENP UA FSMs  via atomic local methods invocation (e.g. via any specific system call provided by the underlying Operating System).","The following subsections provide a detailed description of the mutex-related procedures shown in .","This mechanism enforces a transaction-like processing of the resource reservation phase by enforcing various concurrent instances of the E2ENP UA Service Users to mutually exclusively access such a phase, as described in [ReqSpec].","In other words, the resource reservation mutex allows defining the phase between local admission control and final network resource reservation as a critical section. Combined with the contention resolution policy, this mechanism also guarantees that no deadlock situation as described in [ReqSpec] might affect the E2ENP whatsoever.","Concurrent E2ENP UA Service User instances try to seize the mutex via suspensive method calls. The Service User instance owning the mutex releases it via the signal call event.","The \u201c_ResvMtx\u201d is associated with a priority queue for allowing multiple requests to seize the mutex in a coordinated manner, based on their priority (cf. ).","Any request is served immediately if the mutex is unlocked; otherwise, the request is queued. Requests with high priority are queued in front of requests with low priority. Requests with the same priority are queued in a \u201cFirst-In-First-Out\u201d (FIFO) order.","All requests to acquire the mutex are limited in time. Upon expiration of such a (configurable) time, the given E2ENP UA Service User instance pending on the mutex is resumed with a return value indicating failure.","This design choice allows detecting (and thus preventing) starvation of concurrent E2ENP UA Service User instances suspended on the mutex, which occurs when the Service User instance owning the mutex is misbehaving (or maybe blocked). This is of most importance, especially in case the ill-behaved Service User instance are suspended on some other application-specific mutex, semaphore or lock, eventually seized by one of the Service User instances queued on the \u201c_ResvMtx\u201d: In such an unfortunate situation, a dead lock would in fact inevitably occur.","When the timer associated with each blocked request expires, the priority of that request (specified in the parameter list of respectively the bookNegotiationReq or bookRenegotiationReq primitives, cf. ) should be higher than the priority of the one for which the mutex was granted, the mutex would throw a signal event, congestionInd, to the instance of the FSM  UA associated with the Service User instance owning the mutex. This event is caught by the E2ENP UA FSM  Root state and mapped to a failureInd primitive sent to the Service User instance owning the mutex.","According to application-specific policies, such Service User instance might react on such event by rolling-back the current status of its activities and starting a release operation, which in turn would force the release of the mutex, as indicated in . Should however such Service User instance act differently (either based on application-specific policies or because being blocked or just misbehaving), the other instances would nevertheless be able to detect the prolonged delay on acquiring the mutex (after a configured number of failed attempts to invoke the get method successfully), thanks to the bookNegotiationCfm (or bookRenegotiationCfm in the re-negotiation case) primitives indicating a failure case (see , respectively). In such cases, the notified E2ENP UA Service User instances might invoke the mediation of an application-specific arbitration unit. To manage all these exceptional cases\/dead locks, the resetReq primitive can be issued at any time to cancel the current given session and release the mutex, if necessary.","A key issue typically encountered when using mutex entities is the so-called priority inversion problem, which occurs whenever a task Towning the mutex has a lower priority than other tasks Tblocked on the mutex, and more precisely when the Tgets pre-empted by a task Twith a priority greater than Tbut less than T.","Given the design choice of enforcing loosely coupled interfaces to both the E2ENP UA Service Users and to the SIP UA , the E2ENP UA  containing the \u201c_ResvMtx\u201d implementation cannot directly enforce well-known protocols, e.g. the Priority Inheritance Protocol or the Priority Ceiling Protocol. This is after all a consequence of designing the E2ENP UA  as a software component.","However, if the E2ENP UA FSM  is designed to handle a thread-pool for processing concurrently multiple instances of the FSM , the priority inversion problem might be tackled at least on this level. In this connection, the enforcement of the Priority Inheritance Protocol allows to achieve a good performance in handling the aforementioned problem. To this extent, the priority specified in the parameter list of the bookNegotiationReq primitive (or bookRenegotiationReq in the re-negotiation case, cf. ) issued by each E2ENP UA Service User instance is assigned as priority of the thread serving that FSM  instance. The \u201c_ResvMtx\u201d shall therefore temporarily raise the priority of the thread associated with the FSM  instance owning the mutex to the priority of any blocked thread if the priority of the latter is greater than the one of the former.","The E2ENP UA  thus provides the tools for solving deadlock and priority inversion problems: However, this is up to the applications  or QoS Brokers  using such tools to guarantee that those problems will never occur.","In the following subsection, the resource reservation coordination process shall be described.","The NegAnswerer (cf. ) and ReNegAnswerer (cf. ) sub-states each contain an instance of the same composite state, the WaitForCoordDone sub-state (cf. ), whose nested FSM  captures the logic handling the coordination of resource reservation signaling required before the Answerer is actually alerted and the Offerer informed correspondingly thereupon.","The resource reservation coordination process is based on the mechanisms described in [Cam1], with the following differences:\n\n","Impact on SIP implementation (e.g. the introduction of the status response and the new value \u201cpreconditions\u201d for the \u201cSupported\u201d header field of the OPTIONS method) are left for further study.","An important aspect is that the E2ENP described in [ReqSpec] explicitly claims that the Economy Principle is always required, including the concept described in [Cam1] of allowing both end-to-end and segmented reservations. In the latter case, enforcing the Economy Principle might not always be desirable. There might in fact be situations where reservation can be well done locally on beforehand with no cost and\/or major impact on session establishment. For instance, some users might be attached to an intranet or wireless LAN, where network resource reservation might be free and starving other users might flexibly be handled. Therefore, the original E2ENP shall accommodate this case and rely on the applicability of the Economy Principle to allow the aforementioned case.","It should be noted that the E2ENP does not imply that a direct interface to reservation entities is available: It is up to the applications  or QoS Broker  to access those entities. If the latter wishes to execute a \u201cpre-reservation\u201d of network resources, it might do that, but the E2ENP signaling would still give the right timing to the applications  or QoS Broker , thereby informing it when the reservations at all sides have been accomplished according to the Economy Principle, e.g. which signal has reached the level of the desired QoS (even though best effort communications might well have been started on beforehand, if specified by the applications  or QoS Broker , respectively).","For the sake of simplicity, the model depicted in  only partially details the handling of unexpected events and error cases.  complete the description of said model by indicating the behavior expected in case any of such events or errors occur.","A set of timers is defined to avoid that the E2ENP UA FSM  gets stuck in a state waiting for an event from the Service User and\/or the SIP UA . The treatment of timers for handling primitives across the E2ENP UA API (T1-T22) does not prescribe the E2ENP UA FSM  taking autonomously corrective actions, except for a few cases (missing negotiationReq in Root.NegOfferer.WaitNegReq and renegotiationReq in Root.ReNegOfferer.WaitReNegReq). The E2ENP UA FSM  simply notifies the misbehaving Service User about the detected problem via the failureInd primitive upon which the Service User is supposed to clean up and send a releaseReq primitive to the E2ENP UA FSM . However, if this counteraction does not succeed, e.g. owing to massive problems at the Service User side, the E2ENP UA FSM  would detect this situation upon expiration of yet another timer: in this case, the E2ENP UA FSM  finally takes the decision to release the SIP connection and the overall E2ENP session. To manage all these exceptional cases\/dead locks, the resetReq primitive can be issued at any time to cancel the current given session and release the mutex, if necessary.","However, the composite states Root.ReNegOfferer, Root.NegAnswerer, Root.ReNegOfferer, Root.ReNegAnswerer may detect a later arrival of the missed primitive (eventually triggered by the invocation of the failureInd primitive) by using each an History state (cf. , , , and ). With this solution, the late primitive arrival would be caught in the right original state and processed correctly. This means that whenever the aforementioned timers expire, the aforementioned composite states shall each take care of updating the history to point to the state where the timer expired.","Should a SIP primitive fail, specific timers (T101-T106) would detect the failure at the Root.ReNegOfferer, Root.NegAnswerer, Root.ReNegOfferer, Root.ReNegAnswerer composite states: In these cases, the same procedure as described above (based on the failureInd primitive) shall be enforced.","For the interface, similar approaches to the potential problem of primitive failure have to be pursued by means of the management entity , which is however not detailed in this section.","For properly implementing the E2ENP concept, the dual seizure event (peers simultaneously initiating a negotiation session with each other) shall be properly detected and handled in order to allow that consistency is guaranteed and that any correlation between outgoing and incoming invitations is enforced.","The former issue can be addressed by using a mutex for regulating the access to the Economy Principle phase on a system-wide basis (the \u201c_ResvMtx\u201d described in the sections above).","For enforcing any correlation, some additional support is required instead. Two possible approaches are envisioned:\n\n","A reasonable solution to this issue is to enforce the push-pull model (first approach) as much as possible and to include in the re-negotiation phase the possibility to allow the Answerer to send an offer to the Offerer at a later time (i.e. after the first negotiation has been entirely completed).","This means that the E2ENP shall allow the Offerer and\/or any Answerer to negotiate with the other Answerers and\/or the Offerer upgraded or new information for establishing QOS-aware multimedia sessions. This means that re-negotiations can be subdivided in two classes:\n\n","An explicit Boolean parameter in the pre-negotiation primitive indicates which of the two classes the given primitive should be used for. Of course, the semantics could be inferred from the information passed, which would be different in the two cases, but the Boolean parameter is a good trade-off between having this distinction, which has explicitly been made for improving performance, and the need to keep the E2ENP UA API and FSM  simple by avoiding additional primitives.","However, applying the aforementioned solution might not suffice in the general case since a non-E2ENP compliant SIP UA  might interfere with E2ENP compliant peers, or one of the participants might try to invite some of the other participants to a parallel multimedia session and use the E2ENP to accomplish this.","SIP loosely tackles the dual seizure problem by suggesting a contention resolution policy (indicated as a \u201cMAY\u201d requirement in [Ros1]), whereby peers abort the invitation by replying with an Internal Server Error response, carrying a Retry-After SIP header field set-to the time after which the remote peer should retry.","The dual seizure detection is accomplished by matching all messages between each given couple of users, via the To- and From-SIP header fields. This means if a first user is using UA A and sends an INVITE to a second user on UA B, and vice versa, both users can detect the dual seizure by using the couple (To, From) as a unique identifier for correlating the two INVITEs.","But this is not exactly the way E2ENP identifies sessions. If users are engaged in two independent videoconferences, the E2ENP can actually distinguish such cases by using the session ID described in [ReqSpec]. In any case, the biggest issue is what would the SIP UA  do in such a case, given that the aforementioned SIP requirement is a MAY requirement and thus not necessarily supported by all SIP implementations.","One has to assume that the aforementioned policy may be implemented: Thereby, the E2ENP UA  would not notice the dual seizure, except for an indication of an unsuccessful ne-gotiation or re-negotiation phase. But one could also get into dual seizure troubles if the contention resolution policy is not supported by the underlying SIP UA  implementation.","To tackle the latter case, the Cache  should store for each of its entries also the (E2ENPFromnAddress, E2ENPTo-Address) couple associated with the outgoing INVITE and use this information for correlating an incoming INVITE with a pending outgoing INVITE registered in the Cache , thus detecting the double seizure case: This would then trigger a contention resolution policy. This means that every incoming INVITE received after sending an INVITE should be checked by searching the Cache  with the aid of a secondary key, using the (From, To) couple. Although this is an extra effort, it is only limited to the specific case of receiving an INVITE after having sent one.","As an alternative to the contention resolution policy suggested by [Ros1], which is eventually implemented by the underlying SIP UA , the E2ENP UA  shall support a more general policy, which is also applicable to complex scenarios like one-to-many or many-to-many described in [ReqSpec].","Whenever initiating a negotiation or pre-negotiation phase, the E2ENP UA  should not only include the session ID described in [ReqSpec] in the offer sent within the INVITE but also a hash thereof which takes the IP address of the computing unit where the E2ENP UA  is active into account and a time stamp. This hash might also be signed digitally in order to improve security aspects [ReqSpec]. The hash will be used as a substitute for the session ID in any subsequent SIP message. Should a dual seizure occur, the E2ENP would detect it by using the aforementioned (From, To) couple. Thereby, said contention resolution policy would be applied as follows:\n\n",{"@attributes":{"id":"p-0282","num":"0413"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Application (130) \u2003\u2003\u2003\u2003E2ENP UA (128)"]},{"entry":[{},"\u2003\u2003negotiationReq --->"]},{"entry":[{},"\u2003\u2003<--- abortInd"]},{"entry":[{},"\u2003\u2003<--- negotiationInd"]},{"entry":[{},"\u2003\u2003negotiationRsp --->"]},{"entry":[{},"\u2003\u2003\u2003\u2003..."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"ul":{"@attributes":{"id":"ul0081","list-style":"none"},"li":{"@attributes":{"id":"ul0081-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0082","list-style":"none"},"li":["If the two peers are already involved in multimedia sessions (which means an entry in the Cache  for the given (From, To) couple), the \u201cbully\u201d process described in the previous point could be applied as well. The peer whose request is rejected could apply an unplanned re-negotiation after the winner of the \u201cbully\u201d process has completed its negotiation. An example for this case is the simultaneous detection and re-negotiation reaction of the involved peers to a QoS violation.","Since the generated session ID contains also a randomly generated number (together with the IP, port, etc. information) for the identification, it is not to be expected that some of the peers would always be \u201cwinners\u201d and some always \u201closers\u201d."]}}}},"Finally, the aforementioned contention resolution process also applies to the case of a negotiation procedure colliding with a pre-negotiation procedure or even a lease-renewed procedure as well as for the collision of a pre-negotiation procedure with a lease-renewed procedure.","The model described in the previous subsections represents the static definition of the E2ENP UA FSM . At runtime, the E2ENP UA  shall associate a specific E2ENP session with an object representing it. This object\u2014the Session\u2014shall contain any information related with the given E2ENP instance: most notably, a pointer to the current state and the instance of all the condition variables defined in the model above.","A thread of execution shall dynamically be associated with each of these Session objects: either created on demand, or\u2014better\u2014picked up from a thread-pool (potentially with lazy initialization).\n\n","The E2ENP UA FSM  depends on the following components:\n\n","The E2ENP UA FSM model is described in , , , , and  in terms of UML State Charts and can be implemented by using various well-known design patterns. In any case, as indicated in , the FSMs  are associated at runtime with instances of the applied framework or design pattern to implement the model. Each instance is associated with a specific SIP phase [ReqSpec], i.e. pre-negotiation, lease renewal, or negotiation. Re-negotiations run on the same instance as the underlying session established with the corresponding negotiation.","In order to handle the life cycle of an FSM  instance (creation, activation, deactivation, and destruction), an FSM instance factory  (see ) is envisioned. This should be a singleton object creating instances of the FSM  either upon invocation of specific E2ENP UA API primitives (negotiationReq, prenegotiationReq, renewLeaseReq) or upon invocation of specific SIP UA Generic API primitives (connectionInd, optionsInd, messageInd).",{"@attributes":{"id":"p-0289","num":"0434"},"figref":"FIG. 36","b":["101","101","106"],"i":["b ","c "]},{"@attributes":{"id":"p-0290","num":"0435"},"figref":"FIGS. 37A and 37B","b":["101","101","106"],"i":["b ","c "]},"In the following subsection, the E2ENP UA factory  shall briefly be described.","The E2ENP UA factory  is a management functionality modeled according to the \u201cabstract factory\u201d design pattern described in [Gam] for instantiating a specific E2ENP UA  implementation using an implementation-independent interface.","This entity handles the instantiation of all the classes described in the previous sections required to create an instance of the E2ENP UA . More specifically, the E2ENP UA factory  creates the following entities:\n\n","Thereby, said E2ENP UA factory  depends on the following components:\n\n","The E2ENP UA factory  has been designed by using the object-oriented paradigm. Thus, it is hereby described by using the Unified Modeling Language (UML).","In the following, the E2ENP object configuration parameters shall briefly be summarized.","The E2ENP UA  and its sub-components (FSM , Parser , Factory , Cache ) are configurable elements. The initial configuration should consider the specific features of the peer using the E2ENP UA .","The E2ENP UA  should be initialized with the following parameters:\n\n","The configuration of the E2ENP UA  and its respective components can be performed either manually with the aid of a Graphical User Interface (GUI) or can be preset with configuration parameters read from a configuration file.","Concerning the E2ENP UA FSM , the following parameters are configurable:\n\n","The SIP UA implementation  shall allow configuring at least the following parameters:\n\n","The following subsection provides information about the decision to make communication between the E2ENP UA  and the Parser  respectively the Factory  synchronous. In this connection, the E2ENP UA  shall support multiple concurrent instances of the E2ENP UA FSM . In order to avoid an unbounded usage of OS resources, the E2ENP UA  shall enforce a thread pool.","Communication between the E2ENP UA  and the Parser  respectively Factory  could also be asynchronous, e.g. implemented by an active request interface and a passive confirmation interface. This option is not used within the scope of the underlying invention because some gain in performance and flexibility is opposed by much more complicated state models for the FSMs  of the E2ENP UA .","One consequence of this decision is that the E2ENP UA  and the Parser  (also the Factory ) communicate synchronously, thus having to share a common address space, which in most circumstances is a reasonable assumption. Another consequence of this decision is that both the ParserFactory and the FactoryFactory have to be designed as threadsafe, re-entrant libraries.","Due to the discussion above, it is decided that communication between the E2ENP UA  and the Parser  as well as the Factory  is synchronous.","In conclusion, the main advantageous differences between the underlying invention and the state of the art shall be emphasized. Briefly summarized, the main benefits of the proposed approach consists in\n\n","Moreover, the information to be negotiated (capabilities, application-level QoS Contracts, network-level QoS Contracts, stream-level adaptation paths, and stream-group-level adaptation paths) can be expressed in an interchangeable format in such a way that heterogeneous applications  and\/or middleware  can easily agree on a reference model, which said applications  and\/or said middleware  can then use for dynamically configuring Finite State Machines  (FSMs) in order to orchestrate local, peer, and network resources according to the preferences and profiles of the respective user, policies of the respective systems and network providers in a coordinated manner among a plurality of heterogeneous applications  and middleware  used by various peers.","Finally, said E2ENP UA  can be used for any session-layer protocol and session description language, a plurality of applications  and different types of middleware .",{"@attributes":{"id":"p-0309","num":"0478"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE A"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Used Abbreviations"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Abbr.","Brief Explanation"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":[{},"ABNF","Augmented Backus-Naur Form"]},{"entry":[{},"API","Application Programming Interface"]},{"entry":[{},"ASCII","American Standard Code for Information Interchange"]},{"entry":[{},"E2ENP","End-to-End Negotiation Protocol"]},{"entry":[{},"FSM","Finite State Machine"]},{"entry":[{},"IF<X>","Interface <X>"]},{"entry":[{},"IP","Internet Protocol"]},{"entry":[{},"IPv6","IP version 6"]},{"entry":[{},"LAN","Local Area Network"]},{"entry":[{},"MIME","Multi-Purpose Internet Mail Extensions"]},{"entry":[{},"MSC","Message Sequence Chart (UML)"]},{"entry":[{},"OSI","Open Systems Interconnection"]},{"entry":[{},"QoS","Quality of Service"]},{"entry":[{},"RMI","Remote Method Invocation"]},{"entry":[{},"RPC","Remote Procedure Call"]},{"entry":[{},"SAP","Service Access Point"]},{"entry":[{},"SDP","Session Description Protocol"]},{"entry":[{},"SDPng","Session Description Protocol (next generation)"]},{"entry":[{},"SIP","Session Initiation Protocol"]},{"entry":[{},"UML","Unified Modeling Language"]},{"entry":[{},"XML","Extensible Markup Language"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0310","num":"0479"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"center"}},"thead":{"row":{"entry":"TABLE B"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Depicted Features and their Corresponding Reference Signs"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"238pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["No.","Technical Feature"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["\u2002100","block diagram showing the applied architecture for the"]},{"entry":[{},"User Agent (UA) of the End-to-End Negotiation Protocol"]},{"entry":[{},"(E2ENP) according to the underlying invention"]},{"entry":["\u2002101a","E2ENP Management API (=interface IF1) between the E2ENP"]},{"entry":[{},"UA Factory 108 and the Management Entities 102"]},{"entry":["\u2002101b","E2ENP UA API (=interface IF2) between the E2ENP UA 128"]},{"entry":[{},"and any application 130 or middleware 130 using the"]},{"entry":[{},"services offered by said E2ENP UA 128"]},{"entry":["\u2002101c","SIP UA Generic API (=interface IF3) between the E2ENP"]},{"entry":[{},"UA FSM 106 and the carrier protocol UA 110 (SIP, RMI, etc.)"]},{"entry":["\u2002101d","Parser API (=interface IF4) between the E2ENP UA FSM"]},{"entry":[{},"106 and the implemented Parser 112"]},{"entry":["\u2002101e","Factory API (=interface IF5) between the E2ENP UA FSM"]},{"entry":[{},"106 and the implemented Factory 114"]},{"entry":["\u2002102","E2ENP Management Entities of the E2ENP architecture 100"]},{"entry":["\u2002103","Cache API between the Cache 104 and the E2ENP UA FSM 106"]},{"entry":["\u2002104","two-stage Cache of the E2ENP architecture 100, connected"]},{"entry":[{},"to the Finite State Machine (FSM) 106 of the E2ENP User"]},{"entry":[{},"Agent (UA) 128"]},{"entry":["\u2002106","Finite State Machine (FSM) applied to the E2ENP User"]},{"entry":[{},"Agent (UA) 128 of the E2ENP architecture 100"]},{"entry":["\u2002108","E2ENP UA generation factory of the E2ENP architecture 100"]},{"entry":["\u2002108a","SIP-based E2ENP UA generation factory of the E2ENP architecture 100"]},{"entry":["\u2002110","placeholder for the implementation of the carrier protocol"]},{"entry":[{},"(SIP, RMI, etc.) User Agent (UA), also referred to as Service Provider"]},{"entry":["\u2002110a","SIP User Agent (UA) used for the UA implementation 110"]},{"entry":[{},"of the carrier protocol within the applied E2ENP architecture"]},{"entry":[{},"100 according to the first implementation example 200"]},{"entry":["\u2002110b","Java Remote Method Invocation (RMI)-based User Agent"]},{"entry":[{},"(UA) used for the UA implementation 110 of the carrier"]},{"entry":[{},"protocol within the applied E2ENP architecture 100 according"]},{"entry":[{},"to the second implementation example 300"]},{"entry":["\u2002110c","socket-based User Agent (UA) used for the UA implementation"]},{"entry":[{},"110 of the carrier protocol within the applied"]},{"entry":[{},"E2ENP architecture 100 according to the third implementation example 400"]},{"entry":["\u2002112","placeholder for the implementation of the applied Parser"]},{"entry":["\u2002112a","SDPng Parser used for the Parser implementation 112 of"]},{"entry":[{},"the applied E2ENP architecture 100 according to the"]},{"entry":[{},"first implementation example 200"]},{"entry":["\u2002112b","Dummy Parser used for the Parser implementation 112 of"]},{"entry":[{},"the applied E2ENP architecture 100 according to the second"]},{"entry":[{},"implementation example 300. The Dummy Parser is used"]},{"entry":[{},"together with the Java RMI based UA 110b."]},{"entry":["\u2002112c","Dummy Parser used for the Parser implementation 112 of"]},{"entry":[{},"the applied E2ENP architecture 100 according to the"]},{"entry":[{},"third implementation example 400. The Dummy Parser is"]},{"entry":[{},"used together with the socket based UA 110c."]},{"entry":["\u2002114","placeholder for the implementation of the applied Factory"]},{"entry":["\u2002114a","SDPng Factory used for the Factory implementation 114 of"]},{"entry":[{},"the applied E2ENP architecture 100 according to the"]},{"entry":[{},"first implementation example 200"]},{"entry":["\u2002114b","Dummy Factory used for the Factory implementation 114 of"]},{"entry":[{},"the applied E2ENP architecture 100 according to the second"]},{"entry":[{},"implementation example 300. The Dummy Factory is"]},{"entry":[{},"used together with the Java RMI based UA 110b."]},{"entry":["\u2002114c","Dummy Factory used for the Factory implementation 114 of"]},{"entry":[{},"the applied E2ENP architecture 100 according to the"]},{"entry":[{},"third implementation example 400. The Dummy Factory is"]},{"entry":[{},"used together with the socket based UA 110c."]},{"entry":["\u2002116","Generation factory of the carrier protocol User Agent (UA) implementation"]},{"entry":["\u2002116a","Java-based SIP agent 110a generation factory for the"]},{"entry":[{},"carrier protocol User Agent 110 for SIP according to the"]},{"entry":[{},"first implementation example 200"]},{"entry":["\u2002116b","RMI agent 110b generation factory for the carrier protocol"]},{"entry":[{},"User Agent 110 for Java RMI according to the second"]},{"entry":[{},"implementation example 300"]},{"entry":["\u2002116c","Socket-based agent 110c generation factory for the carrier"]},{"entry":[{},"protocol User Agent 110 for socket-based connections"]},{"entry":[{},"according to the third implementation example 400"]},{"entry":["\u2002118","Generation factory of the applied Parser implementation 112"]},{"entry":["\u2002118a","SDPng Parser 112a generation factory (ParserFactory) of"]},{"entry":[{},"the applied Parser 112 according to the first implementation example 200"]},{"entry":["\u2002118b","Dummy Parser 112b generation factory (ParserFactory) of"]},{"entry":[{},"the applied Parser 112 according to the second implementation"]},{"entry":[{},"example 300"]},{"entry":["\u2002118c","Dummy Parser 112c generation factory (ParserFactory) of"]},{"entry":[{},"the applied Parser 112 according to the third implementation example 400"]},{"entry":["\u2002120","Generation factory of the applied Factory implementation 114"]},{"entry":["\u2002120a","SDPng Factory 114a generation factory (FactoryFactory)"]},{"entry":[{},"of the applied Factory 114 according to the first implementation"]},{"entry":[{},"example 200"]},{"entry":["\u2002120b","Dummy Factory 114b generation factory (FactoryFactory)"]},{"entry":[{},"of the applied Factory 114 according to the second implementation example 300"]},{"entry":["\u2002120c","Dummy Factory 114c generation factory (FactoryFactory)"]},{"entry":[{},"of the applied Factory 114 according to the third implementation example 400"]},{"entry":["\u2002122","Java-based SIP stack (JSIP) applied as a component of"]},{"entry":[{},"the said SIP User Agent (UA) 110a"]},{"entry":["\u2002124a","Remote Method Invocation (RMI) skeleton of the Java RMI-"]},{"entry":[{},"based User Agent (UA) 110b according to the second implementation"]},{"entry":[{},"example 300"]},{"entry":["\u2002124b","Remote Method Invocation (RMI) stub of the Java RMI-"]},{"entry":[{},"based User Agent (UA) 110b according to the second implementation"]},{"entry":[{},"example 300"]},{"entry":["\u2002126a","TX socket of the socket-based User Agent (UA) 110c according"]},{"entry":[{},"to the third implementation example 400 used for"]},{"entry":[{},"transmitting strings or objects"]},{"entry":["\u2002126b","RX socket of the socket-based User Agent (UA) 110c according"]},{"entry":[{},"to the third implementation example 400 used for"]},{"entry":[{},"receiving strings or objects"]},{"entry":["\u2002126c","Adapter of the socket-based User Agent (UA) 110c according"]},{"entry":[{},"to the third implementation example 400 used for receiving"]},{"entry":[{},"and\/or transmitting strings or objects using the"]},{"entry":[{},"said sockets 126a + b"]},{"entry":["\u2002128","combined unit comprising said Cache 104, said E2ENP UA"]},{"entry":[{},"FSM 106, and said E2ENP UA Factory 108, in the following"]},{"entry":[{},"referred to as E2ENP-based User Agent (E2ENP UA)"]},{"entry":["\u2002130","multi-session multimedia application or QoS Broker"]},{"entry":[{},"(middleware) using the E2ENP UA API 101b to connect with"]},{"entry":[{},"the E2ENP UA 128"]},{"entry":["\u2002200","first implementation example of the applied architecture"]},{"entry":[{},"for the User Agent (UA) of the End-to-End Negotiation"]},{"entry":[{},"Protocol (E2ENP) according to one embodiment of the underlying"]},{"entry":[{},"invention using a Java-based SIP Stack (JSIP)"]},{"entry":[{},"and SDPng Parser and Factory"]},{"entry":["\u2002300","second implementation example of the applied architecture"]},{"entry":[{},"for the User Agent (UA) of the End-to-End Negotiation"]},{"entry":[{},"Protocol (E2ENP) according to one embodiment of the"]},{"entry":[{},"underlying invention using Sun's Java Remote Method Invocation (RMI)"]},{"entry":["\u2002400","third implementation example of the applied architecture"]},{"entry":[{},"for the User Agent (UA) of the End-to-End Negotiation"]},{"entry":[{},"Protocol (E2ENP) according to one embodiment of the underlying"]},{"entry":[{},"invention using the socked-based User Datagram"]},{"entry":[{},"Protocol (UDP) or Transmission Control Protocol (TCP)"]},{"entry":["\u2002500","UML class diagram showing the org::mind::e2enp package"]},{"entry":["\u2002502","E2ENPUSerAgentListener interface within the"]},{"entry":[{},"org::mind::e2enp package"]},{"entry":["\u2002504","Provider interface within the org::mind::e2enp package"]},{"entry":["\u2002506","OffererListener interface, generalized to said interface"]},{"entry":[{},"Listener 502 within the org::mind::e2enp package"]},{"entry":["\u2002508","AnswererListener interface, generalized to said interface"]},{"entry":[{},"Listener 502 within the org::mind::e2enp package"]},{"entry":["\u2002510","ManagerProvider interface"]},{"entry":["\u2002512","ManagerListener interface"]},{"entry":["\u2002514","class ConfigurationRequest"]},{"entry":["\u2002516","class ParserFactoryConfiguration"]},{"entry":["\u2002600","Augmented Backus-Naur Form (ABNF) of the E2ENP address"]},{"entry":[{},"as a Universal Resource Identifier (URI)"]},{"entry":["\u2002700","first message sequence chart (MSC) showing the pre-negotiation"]},{"entry":[{},"procedure enabled by the User Agent (UA) 128 of"]},{"entry":[{},"the End-to-End Negotiation Protocol (E2ENP)"]},{"entry":["\u2002702","class OffererServiceUser, derived from the class"]},{"entry":[{},"E2ENPUserAgentListener, implementing the Listener interface"]},{"entry":[{},"502"]},{"entry":["\u2002704","class OffererServiceProvider, derived from the class"]},{"entry":[{},"Provider, which implements the Provider interface 504"]},{"entry":["\u2002706","class AnswererServiceProvider, derived from the class"]},{"entry":[{},"Provider, which implements the Provider interface 504"]},{"entry":["\u2002708","class AnswererServiceUser, derived from the class"]},{"entry":[{},"E2ENPUserAgentListener, implementing the Listener interface 502"]},{"entry":["\u2002800","second message sequence chart (MSC) showing the session"]},{"entry":[{},"establishment with a QoS negotiation and resource reservation"]},{"entry":[{},"coordination enabled by the User Agent (UA) of"]},{"entry":[{},"the End-to-End Negotiation Protocol (E2ENP)"]},{"entry":["\u2002900","UML class diagram showing the org::mind::e2enp::Cache sub-package"]},{"entry":["\u2002902","class LevelOneCache representing the first level (L1) of"]},{"entry":[{},"the two-stage Cache 104"]},{"entry":["\u2002904","class LevelTwoCache representing the second level (L2)"]},{"entry":[{},"of the two-stage Cache 104"]},{"entry":["\u2002906","class LevelOneEntry encompassing methods for storing and"]},{"entry":[{},"loading information to\/from the first level (L1) of said"]},{"entry":[{},"two-stage Cache 104"]},{"entry":["\u2002908","class LevelTwoEntry encompassing methods for storing and"]},{"entry":[{},"loading information to\/from the second level (L2) of"]},{"entry":[{},"said two-stage Cache 104"]},{"entry":["1000","diagram showing the top-level view of an Extensible"]},{"entry":[{},"Markup Language (XML) description used for the End-to-"]},{"entry":[{},"End Negotiation Protocol (E2ENP)"]},{"entry":["1001","Complex Type definition descType of the SDPng desc element."]},{"entry":[{},"The illustration also incorporates the E2ENP specific"]},{"entry":[{},"changes made by the redefine mechanism."]},{"entry":["1002","\u201ce2enp:purpose\u201d child element of the \u201cdesc\u201d element."]},{"entry":["1003","\u201csdpng:def\u201d child element of the \u201cdesc\u201d element."]},{"entry":["1004","\u201csdpng:cfg\u201d child element of the \u201cdesc\u201d element."]},{"entry":["1005","\u201csdpng:constraints\u201d child element of the \u201cdesc\u201d element."]},{"entry":["1006","\u201csdpng:conf\u201d child element of the \u201cdesc\u201d element."]},{"entry":["1100","diagram showing the XML substitution groups used for the"]},{"entry":[{},"End-to-End Negotiation Protocol (E2ENP)"]},{"entry":["1101","Complex Type definition descType of the SDPng desc element."]},{"entry":[{},"The illustration also incorporates the E2ENP specific"]},{"entry":[{},"changes made by the redefine mechanism."]},{"entry":["1102","\u201ce2enp:purpose\u201d child element of the \u201cdesc\u201d element."]},{"entry":["1103","\u201csdpng:def\u201d child element of the \u201cdesc\u201d element."]},{"entry":["1104","\u201csdpng:cfg\u201d child element of the \u201cdesc\u201d element."]},{"entry":["1105","\u201csdpng:constraints\u201d child element of the \u201cdesc\u201d element."]},{"entry":["1106","\u201csdpng:conf\u201d child element of the \u201cdesc\u201d element."]},{"entry":["1107","\u201csdpng:d\u201d element, head of the substitution group which"]},{"entry":[{},"defines the valid child elements of the \u201csdpng:def\u201d section."]},{"entry":["1108","\u201caudio:codec\u201d element, member of the \u201csdpng:d\u201d substitution group."]},{"entry":["1109","\u201ce2enp:closdef\u201d element, member of the \u201csdpng:d\u201d substitution group."]},{"entry":["1110","\u201crtp:pt\u201d element, member of the \u201csdpng:d\u201d substitution group."]},{"entry":["1111","\u201crtp:transport\u201d element, member of the \u201csdpng:d\u201d substitution"]},{"entry":[{},"group. This element in turn is head of the"]},{"entry":[{},"\u201crtp:transport\u201d substitution group."]},{"entry":["1112","\u201crtp:udp\u201d element, member of the \u201crtp:transport\u201d substitution group."]},{"entry":["1113","\u201cvideo:codec\u201d element, member of the \u201csdpng:d\u201d substitution group."]},{"entry":["1200","diagram showing the XML purpose element used for the"]},{"entry":[{},"End-to-End Negotiation Protocol (E2ENP)"]},{"entry":["1201","\u201cpurpose\u201d element. Can be used to convey additional information"]},{"entry":[{},"about the description following in the protocol data unit (PDU)."]},{"entry":["1202","\u201ce2enp:use\u201d element. Child of the purpose\u201d section, can"]},{"entry":[{},"be used to indicate referenced sessions."]},{"entry":["1203","\u201cdescription\u201d element. Can be used to indicate a description PDU."]},{"entry":["1204","\u201cmediation\u201d element. Can be used to indicate a mediation PDU."]},{"entry":["1205","\u201ce2enp:session\u201d element"]},{"entry":["1206","\u201cexpires\u201d element"]},{"entry":["1300","diagram showing the XML qosdef element used for the End-"]},{"entry":[{},"to-End Negotiation Protocol (E2ENP)"]},{"entry":["1300\u2032","XML qosdef element"]},{"entry":["1301","\u201caudio:codec\u201d element. Describes an audio capability of"]},{"entry":[{},"the system."]},{"entry":["1302","\u201cvideo:codec\u201d element. Describes an video capability of"]},{"entry":[{},"the system."]},{"entry":["1303","\u201crtp:pt\u201d element. Can be used to specify a desired payload"]},{"entry":[{},"format for a given capability."]},{"entry":["1304","\u201ce2enp:policy\u201d element. Can be used to specify the resource"]},{"entry":[{},"management policy to enforce."]},{"entry":["1305","\u201ce2enp:audio\u201d element. Can be used to describe the QoS"]},{"entry":[{},"contracts for audio streams."]},{"entry":["1306","\u201ce2enp:video\u201d element. Can be used to describe the QoS"]},{"entry":[{},"contracts for video streams."]},{"entry":["1307","\u201ce2enp:control\u201d element. Can be used to describe the QoS"]},{"entry":[{},"contracts for control streams."]},{"entry":["1308","\u201ce2enp:data\u201d element. Can be used to describe the QoS"]},{"entry":[{},"contracts for data streams."]},{"entry":["1309","\u201crtp:map\u201d element. Can be used to define a mapping between"]},{"entry":[{},"an application level QoS Contract and a specific"]},{"entry":[{},"RTP payload format."]},{"entry":["1310","\u201ce2enp:contract\u201d element"]},{"entry":["1311","\u201cpredicate\u201d element"]},{"entry":["1312","\u201ccriterion\u201d element"]},{"entry":["1400\u2032","XML qoscfg element"]},{"entry":["1400","diagram showing the XML qoscfg element used for the End-"]},{"entry":[{},"to-End Negotiation Protocol (E2ENP)"]},{"entry":["1401","\u201ce2enp:context\u201d element. Can be used to define associations"]},{"entry":[{},"between data streams and thus to express time synchronization"]},{"entry":[{},"and\/or QoS correlation. Briefly, this element"]},{"entry":[{},"defines high level QoS Contracts."]},{"entry":["1402","\u201ce2enp:adapath\u201d element"]},{"entry":["1403","\u201cdefault\u201d element"]},{"entry":["1404","\u201calt\u201d element"]},{"entry":["1405","\u201cevent\u201d element"]},{"entry":["1406","\u201cpath\u201d element"]},{"entry":["1407","\u201ccomp\u201d element"]},{"entry":["1408","\u201cconstraints\u201d element"]},{"entry":["1409","\u201cpar\u201d element"]},{"entry":["1500","UML message sequence chart (MSC) showing the interaction"]},{"entry":[{},"between the E2ENP User Agent (UA) 128 according to the"]},{"entry":[{},"underlying invention and the applied Parser 112 and"]},{"entry":[{},"Cache 104"]},{"entry":["1700","UML class diagram showing the general structure of a"]},{"entry":[{},"Document Object Model (DOM) tree"]},{"entry":["1702","class DocumentTree, which models the general structure"]},{"entry":[{},"of said DOM tree and can therefore be interpreted as the"]},{"entry":[{},"document root element"]},{"entry":["1704","class DocumentNode aggregated to said class DocumentTree"]},{"entry":[{},"1702, which in turn aggregates between 0 and n children,"]},{"entry":[{},"thus recursively describing the tree structure"]},{"entry":["1800","UML class diagram showing a structural overview of the"]},{"entry":[{},"Parser implementation 112 using a \u201cvisitor design pattern\u201d"]},{"entry":[{},"for traversing the DOMTree 1804 and generating a"]},{"entry":[{},"XMLObject 1802"]},{"entry":["1802","class XML Object used within the Parser implementation"]},{"entry":[{},"112"]},{"entry":["1804","class DOMTree, which models the general structure of"]},{"entry":[{},"said DOM tree and can therefore be interpreted as the"]},{"entry":[{},"document root element"]},{"entry":["1806","class DOMNode aggregated to said class DOMTree 1804"]},{"entry":["1808","generic Parser visitor class pVisitor, which visits between"]},{"entry":[{},"1 and N DOMNodes"]},{"entry":["1810a","first specialized DOMNode of said class DOMNode 1806"]},{"entry":["1810n","N-th specialized DOMNode of said class DOMNode 1806"]},{"entry":["1812a","first specialized Parser visitor class pVisitor 1, which"]},{"entry":[{},"is applied to handle the first derived DOMNode"]},{"entry":["1812n","N-th specialized Parser visitor class pVisitor N, which"]},{"entry":[{},"is applied to handle the N-th derived DOMNode"]},{"entry":["1900","UML message sequence chart (MSC) showing the interaction"]},{"entry":[{},"between the E2ENP User Agent (UA) 128 according to the"]},{"entry":[{},"underlying invention and the applied Factory 114 and Cache 104"]},{"entry":["2000","UML class diagram showing a structural overview of the"]},{"entry":[{},"Factory implementation 114"]},{"entry":["2002","generic Factory visitor class fVisitor, which visits between"]},{"entry":[{},"1 and N instances of ObjectGraphNode classes"]},{"entry":["2004","class ObjectGraphNode used within the Factory implementation 114"]},{"entry":["2006a","first specialized Factory visitor class fVisitor 1,"]},{"entry":[{},"which is applied to handle the first derived Node 2008a"]},{"entry":[{},"of the class ObjectGraphNode 2004"]},{"entry":["2006n","N-th specialized Factory visitor class fVisitor N, which"]},{"entry":[{},"is applied to handle the N-th derived Node 2008n of the"]},{"entry":[{},"class ObjectGraphNode 2004"]},{"entry":["2008a","first specialized Node (subclass) of the class ObjectGraphNode"]},{"entry":[{},"2004"]},{"entry":["2008n","N-th specialized Node (subclass) of the class ObjectGraphNode"]},{"entry":[{},"2004"]},{"entry":["2100","UML class diagram showing the org::mind::sip::sipApi package"]},{"entry":["2102","class management of the org::mind::sip::sipApi package"]},{"entry":["2104","class userAgent of the org::mind::sip::sipApi package"]},{"entry":["2106","class registrar of the org::mind::sip::sipApi package"]},{"entry":["2107","class time of the org::mind::sip::sipApi package"]},{"entry":["2108","interface SipListener of the org::mind::sip::sipApi package"]},{"entry":["2110","interface SipProvider of the org::mind::sip::sipApi package"]},{"entry":["2112","class SipExpiresHandling of the org::mind::sip::sipApi package"]},{"entry":["2114","class SipEndUser of the org::mind::sip::sipApi package"]},{"entry":["2200","UML class diagram showing the"]},{"entry":[{},"org::mind::sip::sipApi::userAgent package"]},{"entry":["2202","interface SipUserAgentListener of the"]},{"entry":[{},"org::mind::sip::sipApi::userAgent package"]},{"entry":["2204","interface SipUserAgentServerListener of the"]},{"entry":[{},"org::mind::sip::sipApi::userAgent package, derived from"]},{"entry":[{},"the class SipUserAgentListener 2202"]},{"entry":["2206","interface SipUserAgentClientListener of the"]},{"entry":[{},"org::mind::sip::sipApi::userAgent package, derived from"]},{"entry":[{},"the class SipUserAgentListener 2202"]},{"entry":["2208","Class SipConnectionReq of the"]},{"entry":[{},"org::mind::sip::sipApi::userAgent package"]},{"entry":["2210","interface SipUserAgentType of the"]},{"entry":[{},"org::mind::sip::sipApi::userAgent package"]},{"entry":["2212","interface SipUserAgentFactory of the"]},{"entry":[{},"org::mind::sip::sipApi::userAgent package"]},{"entry":["2214","class SipUserAgent of the"]},{"entry":[{},"org::mind::sip::sipApi::userAgent package, derived from"]},{"entry":[{},"the class SipUserAgentType 2210"]},{"entry":["2214a","class UAClient of the"]},{"entry":[{},"org::mind::sip::sipApi::userAgent package, derived from"]},{"entry":[{},"the class SipUserAgent 2214"]},{"entry":["2214b","class UAServer of the"]},{"entry":[{},"org::mind::sip::sipApi::userAgent package, derived from"]},{"entry":[{},"the class SipUserAgent 2214"]},{"entry":["2216","class SipNegotiationModel of the"]},{"entry":[{},"org::mind::sip::sipApi::userAgent package"]},{"entry":["2218","class SipRegistrationReq of the"]},{"entry":[{},"org::mind::sip::sipApi::userAgent package"]},{"entry":["2220","class SipRegistrationCfm of the"]},{"entry":[{},"org::mind::sip::sipApi::userAgent package"]},{"entry":["2300","UML class diagram showing the"]},{"entry":[{},"org::mind::sip::sipApi::registrar package"]},{"entry":["2302","interface SipRegistrarListener of the"]},{"entry":[{},"org::mind::sip::sipApi::registrar package"]},{"entry":["2304","interface SipRegistrarType of the"]},{"entry":[{},"org::mind::sip::sipApi::registrar package"]},{"entry":["2306","class SipRegistrar of the"]},{"entry":[{},"org::mind::sip::sipApi::registrar package, derived from"]},{"entry":[{},"said class Sip-RegistrarType 2304"]},{"entry":["2308","class SipRegistrationlnd of the"]},{"entry":[{},"org::mind::sip::sipApi::registrar package"]},{"entry":["2310","class SipRegistrationRsp of the"]},{"entry":[{},"org::mind::sip::sipApi::registrar package"]},{"entry":["2312","interface SipRegistrarFactory of the"]},{"entry":[{},"org::mind::sip::sipApi::registrar package"]},{"entry":["2400","UML class diagram showing the"]},{"entry":[{},"org::mind::sip::sipApi::management package"]},{"entry":["2402","interface SipManagementListener of the"]},{"entry":[{},"org::mind::sip::sipApi::management package"]},{"entry":["2404","interface SipManager of the"]},{"entry":[{},"org::mind::sip::sipApi::management package"]},{"entry":["2406","class SipConfigurationReq of the"]},{"entry":[{},"org::mind::sip::sipApi::management package"]},{"entry":["2500","UML class diagram showing the"]},{"entry":[{},"org::mind::sip::sipApi::time package"]},{"entry":["2502","interface SipExpiresType of the"]},{"entry":[{},"org::mind::sip::sipApi::time package"]},{"entry":["2504","class SipParseException of the"]},{"entry":[{},"org::mind::sip::sipApi::time package"]},{"entry":["2506","class SipExpires of the"]},{"entry":[{},"org::mind::sip::sipApi::time package"]},{"entry":["2508","interface SipExpiresFactory of the"]},{"entry":[{},"org::mind::sip::sipApi::time package"]},{"entry":["2600","UML message sequence chart (MSC) showing the configuration"]},{"entry":[{},"of the Service Provider and the binding of the"]},{"entry":[{},"Service User with said Service Provider"]},{"entry":["2700","UML message sequence chart (MSC) showing the connection"]},{"entry":[{},"establishment between the User Agents of a client and a server"]},{"entry":["2800","UML message sequence chart (MSC) showing the OPTIONS"]},{"entry":[{},"method used for the End-to-End Negotiation Protocol (E2ENP)"]},{"entry":["2900","UML message sequence chart (MSC) showing the connection"]},{"entry":[{},"release between the User Agents of a client and a server"]},{"entry":["3000","first state transition diagram for a nested Finite State"]},{"entry":[{},"Machine (FSM) showing the mutex-related procedures executed"]},{"entry":[{},"in the root state"]},{"entry":["3100","second state transition diagram for a nested Finite"]},{"entry":[{},"State Machine (FSM) showing the mutex-related procedures"]},{"entry":[{},"executed in the NegOfferer sub-state"]},{"entry":["3200","third state transition diagram for a nested Finite State"]},{"entry":[{},"Machine (FSM) showing the mutex-related procedures executed"]},{"entry":[{},"in the NegAnswerer sub-state"]},{"entry":["3300","fourth state transition diagram for a nested Finite"]},{"entry":[{},"State Machine (FSM) showing the mutex-related procedures"]},{"entry":[{},"executed in the ReNegOfferer sub-state"]},{"entry":["3400","fifth state transition diagram for a nested Finite State"]},{"entry":[{},"Machine (FSM) showing the mutex-related procedures executed"]},{"entry":[{},"in the ReNegAnswerer sub-state"]},{"entry":["3500","sixth state transition diagram for the ResvMtx Finite"]},{"entry":[{},"State Machine (FSM) for allowing multiple requests to"]},{"entry":[{},"seize the mutex in a coordinated manner, based on their priority"]},{"entry":["3600","seventh state transition diagram for a nested Finite"]},{"entry":[{},"State Machine (FSM) showing the mutex-related procedures"]},{"entry":[{},"executed in the WaitForCoordDone sub-state"]},{"entry":["3700","UML message sequence chart (MSC) showing the pre-negotiation"]},{"entry":[{},"procedure needed for the correlation of the Application"]},{"entry":[{},"Programming Interface (API) of the E2ENP User"]},{"entry":[{},"Agent (UA) and the generic Application Programming Interface"]},{"entry":[{},"(API) of the SIP User Agent (UA), thereby using"]},{"entry":[{},"the above-mentioned Finite State Machine (FSM) of the"]},{"entry":[{},"E2ENP User Agent (UA)"]},{"entry":["3702","class OffererSIPServiceUser, implementing the interface"]},{"entry":[{},"SipUserAgentClientListener 2206"]},{"entry":["3704","class OffererSIPServiceProvider, derived from the class"]},{"entry":[{},"SipUserAgent 2214"]},{"entry":["3706","class AnswererSIPServiceProvider, derived from the class"]},{"entry":[{},"SipUserAgent 2214"]},{"entry":["3708","class AnswererSIPServiceUser, implementing the interface"]},{"entry":[{},"SipUserAgentServerListener 2204"]},{"entry":["3800","UML message sequence chart (MSC) showing the session establishment"]},{"entry":[{},"with the QoS negotiation procedure and the"]},{"entry":[{},"resource reservation coordination needed for the correlation"]},{"entry":[{},"of the Application Programming Interface (API) of"]},{"entry":[{},"the E2ENP User Agent (UA) and the generic Application"]},{"entry":[{},"Programming Interface (API) of the SIP User Agent (UA),"]},{"entry":[{},"thereby using the above-mentioned Finite State Machine"]},{"entry":[{},"(FSM) of the E2ENP User Agent (UA)"]},{"entry":["3900","FIG. 38: table showing a list of primitives implemented"]},{"entry":[{},"by the Service Provider, based on a Java implementation"]},{"entry":[{},"of the Application Programming Interface (API) applied"]},{"entry":[{},"to the User Agent (UA) of the End-to-End Negotiation"]},{"entry":[{},"Protocol (E2ENP)"]},{"entry":["4000","FIGS. 39A and 39B: table showing a list of primitives to be implemented"]},{"entry":[{},"by the Service User, based on a Java implementation"]},{"entry":[{},"of the Application Programming Interface (API) applied"]},{"entry":[{},"to the User Agent (UA) of the End-to-End Negotiation"]},{"entry":[{},"Protocol (E2ENP)"]},{"entry":["4100","FIG. 40: table showing a list of primitives to be implemented"]},{"entry":[{},"by the Service User acting as an Offerer, based"]},{"entry":[{},"on a Java implementation of the Application Programming"]},{"entry":[{},"Interface (API) applied to the User Agent (UA) of the"]},{"entry":[{},"End-to-End Negotiation Protocol (E2ENP)"]},{"entry":["\u2002200","FIG. 41: table showing a list of primitives to be implemented"]},{"entry":[{},"by the Service User acting as an Answerer, based"]},{"entry":[{},"on a Java implementation of the Application Programming"]},{"entry":[{},"Interface (API) applied to the User Agent (UA) of the"]},{"entry":[{},"End-to-End Negotiation Protocol (E2ENP)"]},{"entry":["4300","FIG. 42: table showing the methods provided by the Application"]},{"entry":[{},"Programming Interface (API) of the first Cache level"]},{"entry":["4400","FIG. 43: table showing the methods provided by the Application"]},{"entry":[{},"Programming Interface (API) of the second Cache level"]},{"entry":["4500","FIGS. 44A and 44B: table showing a list of primitives which have to"]},{"entry":[{},"be implemented by the Application Programming Interface"]},{"entry":[{},"(API) of the Parser"]},{"entry":["4600","FIG. 45: table showing a list of primitives which have to"]},{"entry":[{},"be implemented for generating a specific parser instance"]},{"entry":["4700","FIG. 46: table showing a list of primitives which have to"]},{"entry":[{},"be implemented by the Application Programming Interface"]},{"entry":[{},"(API) of the Factory"]},{"entry":["4800","FIG. 47: table showing a list of primitives which have"]},{"entry":[{},"to be implemented for generating a specific factory instance"]},{"entry":["4900","FIG. 48: table showing the methods provided by the well-"]},{"entry":[{},"known factory-factory class E2ENPContentHandlerFactory"]},{"entry":["5000","FIG. 49: table showing a list of primitives implemented"]},{"entry":[{},"by the Service Provider, based on a Java implementation"]},{"entry":[{},"of the generic Application Programming Interface (API)"]},{"entry":[{},"applied to the User Agent (UA) of the End-to-End Negotiation"]},{"entry":[{},"Protocol (E2ENP)"]},{"entry":["5100","FIG. 50: table showing a list of client-side-specific"]},{"entry":[{},"primitives implemented by the Service User, based on a"]},{"entry":[{},"Java implementation of the generic Application Programming"]},{"entry":[{},"Interface (API) applied to the User Agent (UA) of"]},{"entry":[{},"the End-to-End Negotiation Protocol (E2ENP)"]},{"entry":["5200","FIG. 51: table showing a list of server-side-specific"]},{"entry":[{},"primitives implemented by the Service User, based on a"]},{"entry":[{},"Java implementation of the generic Application Programming"]},{"entry":[{},"Interface (API) applied to the User Agent (UA) of"]},{"entry":[{},"the End-to-End Negotiation Protocol (E2ENP)"]},{"entry":["5300","FIG. 52: table showing a list of both client-side- and"]},{"entry":[{},"server-side-specific primitives implemented by the Service"]},{"entry":[{},"User, based on a Java implementation of the generic"]},{"entry":[{},"Application Programming Interface (API) applied to the"]},{"entry":[{},"User Agent (UA) of the End-to-End Negotiation Protocol"]},{"entry":[{},"(E2ENP)"]},{"entry":["5400","FIG. 53: table showing a list of primitives implemented"]},{"entry":[{},"by the Service Provider, based on a Java implementation"]},{"entry":[{},"of the generic Application Programming Interface (API)"]},{"entry":[{},"applied to the User Agent (UA) of the End-to-End Negotiation"]},{"entry":[{},"Protocol (E2ENP)"]},{"entry":["5500","FIG. 54: table showing a list of primitives implemented"]},{"entry":[{},"by the Service User, based on a Java implementation of"]},{"entry":[{},"the generic Application Programming Interface (API) applied"]},{"entry":[{},"to the User Agent (UA) of the End-to-End Negotiation Protocol (E2ENP)"]},{"entry":["5600","FIGS. 55A-D: state transition table showing a survey of the"]},{"entry":[{},"applied exception events"]},{"entry":["5700","FIGS. 56A and 56B: table showing the applied timers applied to the"]},{"entry":[{},"End-to-End Negotiation Protocol (E2ENP) according to the"]},{"entry":[{},"underlying invention"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}}],"heading":["BRIEF DESCRIPTION OF THE PRESENT STATE OF THE ART","PROBLEMS TO BE SOLVED BY THE INVENTION","OBJECT OF THE UNDERLYING INVENTION","SUMMARY OF THE UNDERLYING INVENTION","DETAILED DESCRIPTION OF THE UNDERLYING INVENTION"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Further advantages and possible applications of the underlying invention result from the subordinate claims as well as from the following description of the preferred embodiment of the invention, illustrated by the following figures and tables:",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 5A"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 5B"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIGS. 26A and 26B"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 32"},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 33"},{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 34"},{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 35"},{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 36"},{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIGS. 37A and 37B"},{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 38"},{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIGS. 39A and 39B"},{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 40"},{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 41"},{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 42"},{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 43"},{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIGS. 44A and 44B"},{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 45"},{"@attributes":{"id":"p-0073","num":"0072"},"figref":"FIG. 46"},{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 47"},{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIG. 48"},{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 49"},{"@attributes":{"id":"p-0077","num":"0076"},"figref":"FIG. 50"},{"@attributes":{"id":"p-0078","num":"0077"},"figref":"FIG. 51"},{"@attributes":{"id":"p-0079","num":"0078"},"figref":"FIG. 52"},{"@attributes":{"id":"p-0080","num":"0079"},"figref":"FIG. 53"},{"@attributes":{"id":"p-0081","num":"0080"},"figref":"FIG. 54"},{"@attributes":{"id":"p-0082","num":"0081"},"figref":"FIGS. 55A","b":["55","55","55"]},{"@attributes":{"id":"p-0083","num":"0082"},"figref":"FIGS. 56A and 56B"}]},"DETDESC":[{},{}]}
