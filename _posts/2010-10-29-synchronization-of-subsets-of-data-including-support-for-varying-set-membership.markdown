---
title: Synchronization of subsets of data including support for varying set membership
abstract: An efficient way and general mechanism is provided to represent and exchange knowledge and/or partial knowledge across nodes when synchronizing between any two nodes including custom or move filters where set membership can change over time at a device as data items come in and out of filter scope. A first node sends a second node its knowledge and/or partial knowledge, including objects and versions of those objects. The second node compares its knowledge and/or partial knowledge with the knowledge and/or partial knowledge of the first node, and then sends the first node any latest versions of objects of which the first node is unaware. In addition, the second node sends its knowledge and/or partial knowledge to the first node. The first node then performs a similar object-by-object version comparison to determine any conflicts due to independent evolution of objects and any changes that can be sent to the second node in order to bring the objects of the second node up to date with the knowledge and/or partial knowledge of the first node. Replicas can track filters to efficiently support synchronizing with filtered replicas. Filter forgotten knowledge is also used to represent how recently a replica can guarantee to know which items have been in the filter. Ghosts can be used to represent items that have been in the filter recently but have currently moved out. Filter forgotten knowledge concept allows both new filters to be tracked when they are introduced into the community, as well as periodically cleaning up of tombstones and ghosts.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08805783&OS=08805783&RS=08805783
owner: Microsoft Corporation
number: 08805783
owner_city: Redmond
owner_country: US
publication_date: 20101029
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application claims priority to U.S. Provisional Application Ser. No. 61\/349,076, filed on May 27, 2010, entitled \u201cSYNCHRONIZATION OF SUBSETS OF DATA INCLUDING SUPPORT FOR VARYING SET MEMBERSHIP\u201d, the entirety of which is incorporated herein by reference.","The subject disclosure relates to efficient multi-master synchronization of subsets of data between endpoints such as devices and computers, and where set membership can vary over time.","There are a variety of distributed data systems that have nodes (e.g., computers or devices) that share data with one another. For instance, music sharing systems may synchronize music between a PC, a Cell phone, a gaming console and an MP3 player. For another example, email data may be synchronized between an e-mail server and e-mail clients on PCs or other devices. Conventionally, to the extent such devices synchronize according to common information, the synchronization takes place according to a static setup among the devices.","Because of limited storage availability on different devices or computers, as well as limited network bandwidth availability between them, synchronizing a subset of the data is essential in many scenarios. Correct functionality in such scenarios requires every node maintain the most recent copy of all the desired data. At the same time synchronization of such subsets needs to be performed efficiently. A common problem with existing solutions is synchronization metadata grows proportional to the number of items in the subset, rather than proportional to the number of nodes involved in synchronization.","Another problem is how to synchronize and represent only a subset of information known by other device(s). For instance, this might happen where a device or application is not storing the same data that a second device stores or uses, e.g., different endpoints can store different subsets. For instance, a first device might be a personal computer (PC) with lots of storage and stores all music items on behalf of a user, whereas a handheld device that synchronizes with the PC may have limited storage in which case only music items rated with 5 stars by the user are stored. In such case, the handheld device may only receive a subset of the files from the PC, e.g., only those files on the PC that are rated with 5 stars. How to represent on the handheld device in a loosely coupled multi-master synchronization environment that the handheld device received a subset of data from the PC is a challenge. Compounding the challenge is when multiple devices are synchronizing. For instance, in addition to the handheld device and the PC, a user's laptop may store all music items with 3 stars or greater.","Conventional synchronization systems suffer from either or both of 1) non-convergence due to not handling items that move out of the filter, which leads to unacceptable results or 2) metadata growth is proportional to the number of items in the subset due to sending and storing metadata for all items including those items that have never been in the subset, which leads to unscalable systems and\/or difficulties for devices with limited storage or processing capabilities as well as leading to incorrect data, incorrect behavior, or higher storage requirements. Thus, conventionally, for loosely coupled devices in a multi-master system, there is no efficient and flexible way to represent synchronization metadata for the subset of the data that is of interest. In essence, tracking how items move in and out of the subset, and how such subsets of data are exchanged among the devices in such a system is a difficult and challenging problem thus far unaddressed by those in the synchronization field.","Still further, other conventional systems in essence ignore the problem by allowing the full set of synchronization metadata (e.g., knowledge) on each device to synchronize to each of the other devices. Where a device does not recognize the data that was synchronized to its data store, the device marks the data as unrecognizable. While this allows a third device to synchronize with the unrecognizable data on the second device, potentially giving the third device an opportunity to recognize some or all of the unrecognizable data, the proliferation of unrecognizable data on devices with limited storage is unworkable as a practical matter. More generally, storing all of the data in this fashion achieves nothing more than a backup system where each device backs up its data to all other devices of a network, an inefficient scheme to say the least.","In general, synchronization or replication refers to the act of keeping multiple copies of data at different replicas the same, as well as detecting and reporting conflicts for concurrent changes to same data on different replicas. Replicas can reside on different locations such as a computer, device, or cloud. Synchronization systems have to deal with changes happening on different replicas, efficiently replicating them while detecting conflicts to ensure there is no data loss.","Filtering refers to synchronizing a subset of the data. There are different types of filtering related to synchronization, and arbitrary filters where data can move in and out of the filters currently has no known efficient solutions, with examples of such difficult synchronization scenarios as follows.","As mentioned, a first example is synchronizing music albums, and tracks between a PC and device where device only keeps music that user rates as \u201c5 stars\u201d and where another device keeps music that a user rates as 3 or more stars. Since the user can change ratings of music, this causes data to move in and out of the filter. This relatively straightforward example involving just three devices is illustrated in . PC  stores all music . Handheld device  stores music rated with 5 stars  and laptop  stores music rated with 3 or more stars . Since the set membership of music  and  can change a lot as a user adds or deletes music, or re-rates existing music, the synchronization problem is not straightforward to handle.","Another example is synchronizing customer data between a relational database that keeps all customer records including those applicable to a given sales person. On the sales person's laptop client, the sales person only wants to keep data for customers with which that sales person works, e.g., those customers with state=\u2018WA\u2019. Since customer addresses can change to states other than \u2018WA\u2019, data can move in and out of the filter applicable to the laptop or other client. This example illustrates the sheer complexity of the number of devices that can be involved since a sales force of sales people may include hundreds of people and thousands of devices possessed by such people, and thus a general and scalable mechanism for resolving how to keep track of what information each device knows, track and can therefore receive as part of synchronization processes is desirable.","In this regard, existing filtering solutions have the drawback of either move filters that take the step of exchanging filter membership (e.g., all items are in the filter) or sending updates to all items (e.g., including those not in the filter). For instance, based on the example above with a database filter of customers in state=\u2018WA\u2019, synchronizing changes to all data (e.g., customers in all other states) is extremely inefficient and undesirable.","Accordingly, flexible and efficient ways to represent synchronization metadata transfers of data from one device to another device are desired for a variety of loosely coupled devices, where the device transfers a subset of its knowledge to the other device and where set membership can vary. Additional detail about these and other deficiencies in the current state of synchronization among loosely coupled devices, and with respect to synchronizing subsets of data among the devices, may become apparent from the description of the various embodiments of the detailed description that follows.","In consideration of the need for exchanging synchronization metadata between nodes of a synchronization network, which may independently evolve common information to be synchronized across the nodes, an efficient way is provided to represent and exchange the synchronization metadata when is performed to one or more subsets of data without the downsides of conventional approaches.","In various embodiments, replicas can efficiently support synchronization of subsets by tracking the filter that defines the subset replica tracking filters. A replica is said to track a filter if the replica knows which items have recently been in the filter. Filter forgotten knowledge is used to represent how recently a replica can guarantee to know which items have been in the filter. Ghosts can be used to represent items that have been in the filter recently but have currently moved out. Another aspect is that the filters used in the community of synchronizing devices need not be known in advance, that is, a new replica with new filter(s) can be added to and supported by the synchronization community at any time as if the new replica was added before, or from the beginning of synchronization among other devices.","A simplified summary is provided herein to help enable a basic or general understanding of various aspects of exemplary, non-limiting embodiments that follow in the more detailed description and the accompanying drawings. This summary is not intended, however, as an extensive or exhaustive overview. Instead, the sole purpose of this summary is to present some concepts related to some exemplary non-limiting embodiments in a simplified form as a prelude to the more detailed description of the various embodiments that follows.","Overview","As generally discussed in the background, particularly where synchronization metadata exchanges can occur among the multiple nodes according to different filters with data set membership changing, the complete picture can become cumbersome and difficult to describe in hard-coded metadata, even where devices can be presume to remain connected. Specifically, efficient and correct synchronization of scenarios like this where data moves in and out of the filter is complex and difficult, and currently unsolved by conventional solutions in a widely applicable manner without significant drawbacks.","Accordingly, in various embodiments, replicas can track filters via replica tracking filters. A replica is said to track a filter if the replica knows which items have recently been in the filter. In this regard, synchronization metadata, termed knowledge, is generally described in U.S. patent application Ser. No. 11\/673,129, filed Feb. 9, 2007, which is incorporated herein by reference in its entirety. As detailed therein, knowledge can be employed as concise synchronization metadata for multi-master synchronization. Using the same knowledge concept at times of metadata or tombstone cleanup can guarantee correct synchronization, as described generally in U.S. Patent Publication No. 2007\/0299887, filed Jun. 23, 2006, also incorporated herein by reference in its entirety. In addition, forgotten knowledge can be utilized, which generally relates to metadata information associated with a set of data objects that has been removed, deleted or otherwise purged, typically because of a cleanup operation or the like. Forgotten knowledge can employ the same format and semantics as knowledge, with metadata or tombstone cleanup to guarantee correctness of synchronization. Ghosts can be used to represent items that have been in the filter recently, but have currently moved out. Ghosting is described in U.S. Pat. No. 7,720,890, issued May 18, 2010, which is incorporated herein by reference in its entirety.","In consideration of such need to efficiently describe filtered synchronization in a multi-master synchronization system where set membership as defined by the filter can vary, various embodiments provide an efficient and flexible way to track and describe the evolution of knowledge, and succinctly represent present knowledge of the devices in the system as a function of partial knowledge, or subsets of knowledge, learned from other devices. In one embodiment, a knowledge vector with versioning information is used to represent knowledge, and subsets of data being synchronized include additional metadata that efficiently describes the partial knowledge exchange as such. In this regard, replicas can track filters via replica tracking filters. A replica is said to track a filter if the replica knows which items have recently been in the filter. Filter forgotten knowledge is used to represent how recently a replica can guarantee to know which items have been in the filter. Ghosts can be used to represent items that have been in the filter recently but have currently moved out.","Another aspect of the various embodiments disclosed herein is that the filters used in the community of synchronizing devices need not be known in advance. For example, in the customer data example set forth in the background, when a new replica is added to the sync community with \u201call customers with age>65\u201d, the existing replicas can start tracking from that point in time onwards and support the new replica efficiently as if the replica was supported from the beginning along with the other synchronizing devices. In other words, the systems disclosed herein can support a new replica with new filter(s) including scenarios where set membership (as defined by the filter) can vary over time and\/or at any time the replica is added to the synchronization community.","As a general roadmap for what follows herein, first, a general mechanism is described that ensures whenever a device has access to other device(s) in a loosely coupled network, the device will exchange knowledge with the other device(s) in order to determine which changes can be retrieved by the device and conveyed to the other device(s). Then, it is shown how the general mechanism for knowledge exchange can be extended to include representations of filtered synchronization where filter membership varies over time.","In this fashion, while a first device and a third device may never communicate directly, if each is able to connect to a second device, a collective share of knowledge can be achieved across all three devices, determining what changes each of the devices can receive from each of the other devices. With various embodiments, partial knowledge learned at the second device from the first device and partial knowledge learned from the third device can be combined into a single representation of all the knowledge understood by the second device, which in turn can be synchronized to the other devices.","Considering the proliferation of devices that share data, such as music, email, pictures, videos, advantageously, the knowledge exchange techniques of the various embodiments are scalable to any number of devices, and any number of independent filtered knowledge bases where set membership can vary, e.g., different sets of common information, simultaneously, e.g., anywhere any evolving set of devices wish to share whole or partial data. Various embodiments of representing such knowledge or partial knowledge in a distributed system are described in more detail below.","Efficient Knowledge Representation and Exchange","As a prelude to describing the synchronization of subsets of data in an embodiment, in this section, an overview is presented of a general mechanism for efficiently representing knowledge in data synchronization systems. The term knowledge as used in this section refers to synchronization metadata that is exchanged during synchronization, which can be a concise description of all item IDs and versions, e.g., the item IDs and version numbers known by the device, which allow the devices to deduce what other knowledge can be acquired from other devices to which they connect. The general mechanism includes (1) an efficient exchange of knowledge between connected devices by utilizing only the minimum data needed by a first node from a second node to be sent, (2) the ability to efficiently and correctly recognize disagreements over the state of data, i.e., conflicts, between a first node and a second node, (3) the ability to synchronize an arbitrary number of nodes and (4) the ability to synchronize any node via any other node, e.g., the ability to work in a peer to peer, multi-master synchronization environment.","With the general mechanism, any number of changes might be made to the local copy of the data that is available on a device. At any time they become connected, however, by exchanging their knowledge with one another, they become aware of at least the minimum amount of information needed to reconstruct what each other knows and doesn't know to facilitate of changes between the devices. In other words, nodes can pick up changes available from other nodes by sending their knowledge which represents the set of changes they have available locally. For example, knowledge of a device or node represents what set of changes it knows about. Such can include both local changes made by the node, as well as changes made at other nodes that have been applied from previous synchronization operations.","Advantageously, one or more embodiments operate to perform synchronization for a set of devices all interested in maintaining the latest versions of a set of objects, but also allow such devices to come into connection and out of connection with the other objects of the set. Whenever a device comes back into connection with other device(s) via one or more networks, the device performs synchronization to get changes made at other devices or nodes. In this fashion, even loosely connected devices may come into and out of contact with a set of devices, and then relearn all the knowledge missed by coming into contact with any set of devices that possess the latest set of collective knowledge.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 2","b":["200","210","220","230"],"sub":["200","210","220 ","230 "]},"Advantageously, as shown by , even where connections in the network become disconnected, a complete set of knowledge can nonetheless be gained by all of the devices , , , and , as long as at least one connection directly or indirectly exists to the other devices. For instance, as shown, knowledge Kof device  still reaches device  via the knowledge exchange with device , then via the knowledge exchange between device  and , and finally via the knowledge exchange between device  and .","With more devices sharing knowledge about common information to be shared, all of the devices benefit because the knowledge exchange is agnostic about from which device collective knowledge comes. The devices each independently operate to try to gain as much knowledge about information to be shared among the devices from any of the other devices to which it is connected.","In exemplary non-limiting detail, a method is described in further detail for two nodes to engage in a conversation and at the end of the conversation to have equivalent knowledge for the concerned data set. The method is scalable beyond two nodes by creating a knowledge exchange capability for each new device entering the peer-to-peer network.","Thus, as shown in , node  of a peer-to-peer network having any number of nodes wants to exchange data with Node . Node A begins by requesting changes from Node  and in order to do so Node  sends its knowledge (represented as K) to Node  as shown.","Knowledge of a device or node is represented by labeling each object to be shared among devices with a letter identifier, and then the trailing number represents the latest version for this object. For instance, Kas shown in  includes objects A, B, C and D each to be synchronized between nodes  and , and the number following each of the objects represents the latest version of the object known on the device. For instance, knowledge Kat a time t=1 includes the 5version of A, the 4version of B, the 7version of C, and the 1version of D, notated as A, B, C, D in . In contrast, knowledge Kof node  at a time t=1 may include the 4version of A, the 7version of B, the 7version of C, and the 3version of D, notated as A, B, C, D in .","As shown in , at time T=2, node  compares knowledge Kreceived from node  against its own knowledge Kand determines what needs to be sent to node . In this example, as a result, node  will send node  the changes made by B with tickcount greater than 3, and changes made by D with tickcount greater than 0 are not covered by B or D and hence will be sent. Along with the changes, the node will send its own knowledge of K. When node  sends node  the changes between B and B, and the changes between D and D, it also sends along the latest version of knowledge Kit has (reflecting whenever the last change on node  was made).","As shown in , representing time t=3, sending knowledge Kto node  allows node  to detect conflicts (e.g., store them for later resolution) if it later finds out that both node  and node  made a change to an object independently. For example, a conflict is not based on two objects not being same, but rather based on destination version not contained by source knowledge, and source change not contained by destination knowledge. Accordingly, such allows for autonomous updating, efficient enumeration, but also correct conflict detection when the nodes meet and exchange changes. For instance, in the example, if C is not the same object in both knowledge Kand K, e.g., if both independently evolved from C to C, then which C is the correct C can be set aside for conflict resolution, e.g., according to pre-set policy resolution that befits the synchronization scenario and devices involved.","An exemplary knowledge exchange process between any two nodes of a distributed multi-master synchronization environment using the above described general mechanism is shown in the flow diagram of . At , node A requests synchronization with node B, thereby asking node B for changes node A does not know about. In order to equip node B, at , node A sends its knowledge to node B. At , node B compares the knowledge received from node A with the versions of the local copy of the data to determine what changes node B knows about that can be sent to node A. At , node B sends such changes to node A, and in addition, node B sends its knowledge to node A so that node A can perform correct conflict detection, and also calculate its new knowledge after applying the changes it received from B at .","At , node A detects any potential conflicts between latest versions reflected in the knowledge of node B and latest versions reflected in the knowledge of node A, in the event that independent evolution of versions has occurred on node A and node B. In an embodiment, any conflict resolution policy may be applied to determine which node trumps the other node in the event of a conflict. At , the latest changes from node A that are not possessed by node B are sent to node B. The conflict resolution policy will additionally dictate whether any changes are sent from node B to node A, or node A to node B, to maintain common information between the nodes. If independent versioning is OK, or desirable, no conflict resolution is another option.","Efficient Knowledge Subset Representation and Exchange","As discussed above in connection with the generalized mechanism for representing knowledge in a multi-master synchronization environment, knowledge of a device or node can be efficiently represented by labeling each object to be shared among devices with a letter identifier including a trailing number that represents the latest version for this object. It should be understood that such labeling is simply a convention used to refer to multiple knowledge objects corresponding to different replicas in documents. The knowledge contents, and representation can be very different. In this regard, knowledge defines the summary of the state based synchronization of a replica. However, as mentioned in the background and overview, in many cases it is useful to synchronize a subset of the data that is contained within a given endpoint, which is complex where data set membership can change over time at the devices. When this happens, the representation of knowledge still works for synchronization purpose even when filtered replicas, or replicas with subset(s), are introduced into the synchronization community. In various embodiments, this is achieved via a filter mechanism and represents subsets as a form of filtered knowledge.","Accordingly, the uses for the subsetting representation as filtered knowledge, as described herein, are virtually limitless. Subsetting of every kind is very popular in synchronization scenarios. Being able to efficiently represent and combine information about filters advantageously allows replicas to only keep data and metadata about the subset they care about and still synchronize according to efficient knowledge exchanges in a multi-master synchronization environment.","In more detail, various embodiments are provided for filters with knowledge based synchronization, as described in the previous section. As mentioned, normally, knowledge is represented as a version vector, representing the maximum tick count a given endpoint has ever seen from any other endpoint in the community with which it synchronizes for a given set of data. Another way of thinking of this vector is as a scope vector since it defines the scope of knowledge of the objects possessed by a device.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 8"},"Filter forgotten knowledge has the same representation as knowledge, but provides a different role than does knowledge with respect to synchronization. As shown, each replica A and B has provider PA and provider PB, respectively. According to one or more embodiments, each replica A and B tracks a filter and thus in addition to maintaining knowledge Kand K, respectively, and forgotten knowledge FKand FK, respectively, replica A and B also maintain filter forgotten knowledge FFKand FFK, respectively. Similar to the case with no subsetting or filters (in which case knowledge and forgotten knowledge can be exchanged in connection with syncing), any of the replicas can request changes  of another replica and receive changes  in response to the other replica conveying changes, including an exchange of knowledge and filter forgotten knowledge.","In either case, knowledge exchange can be handled according to a common scheme, whereby the replica initiating the knowledge exchange (e.g., replica A or the source replica) transmits the change request along all current knowledge, K, and filter forgotten knowledge, FFK. Upon receipt of the change request, the destination replica (e.g., replica B) can update its own knowledge, K, and compare Kto FFKin order to determine whether Kis contained or a subset of FFK. If so, such is considered to be a nominal or normal sync operation, and at some time later (possibly with intervening sync operations between replica B and other replicas in the community) replica B can transmit all or a portion of Kthat is unknown to replica A as well as FFKto replica A as part of a change conveyance operation. In the event that Kis not contained or a subset of FFK, then a normal sync will not typically be used, but rather another type of synchronization, such as a partial sync with line item exceptions or a full enumeration sync, both of which are further detailed herein.",{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 9","b":["900","900","900","920","930","920","922"],"i":["b ","b ","b "]},"Sync module  may also include a sync initiation module which may initiate synchronization with a second device if authorized, e.g., via authorization module , and connect to the second device. Sync module  may also include an I\/O module responsive to the initiation of synchronization by sending full and\/or partial knowledge and filter forgotten knowledge about the set of data objects  to the second device (not shown), and for receiving back full and\/or partial knowledge and, if any, filter forgotten knowledge of the second device and changes to be made to the set of data objects  originating from the second device. In turn, a sync analysis module  operates to apply the changes to be made to the set of data objects  and to compare full and\/or partial knowledge and filter forgotten knowledge from the second device with the full and\/or partial knowledge and filter forgotten knowledge of the first device in order to determine changes to send to the second device to complete synchronization between the devices.","In accordance therewith, in one or more embodiment, device can include sync module  that can be communicatively coupled to a local replica  that can store a local version of a set of data objects  and associated metadata such as knowledge , filter forgotten knowledge , or forgotten knowledge . As will be described in more detail below, knowledge typically relates to what local replica  (and by proxy sync module  or device ) knows about the various states or versions associated with a set of data objects as maintained by other devices in the community, such as the second device discussed above. For example, if device very recently synced with the second device, then knowledge about the second device's set of objects can be quite up-to-date and\/or substantially similar to set of data objects  maintained by local replica . On the other hand, if device has not synchronized with the second device in some time, then it is more likely that knowledge relating to second device's replica state will be stale or outdated. Additionally, forgotten knowledge typically relates to metadata information associated with set of data objects  that has been deleted or purged, typically because of a cleanup operation or the like. Likewise, filter forgotten knowledge is similar to forgotten knowledge , but can apply expressly to a filtered subset of set of data objects , or when local replica  only stores a subset of the objects maintained by the community (e.g., is a filtered replica such as including only 5 star music or including only customers residing in the State of Washington).","Further, as introduced above, sync module  can include a communications module  (e.g., sync comm. Module ) that can be configured to communicate with at least one other sync module (e.g., associated with the second device) included in a multi-master community of sync modules. Advantageously, the community can be multi-master in the sense that any node or device included in the community can engage in a full or partial sync with any other node or device and\/or receive complete knowledge exchanges necessary to maintain set of data objects  in a community-wide current state without the necessity of sync with a predefined master node or device.","In addition, as briefly discussed above, sync module  can also include an analysis module  (e.g., sync analysis module ) that can be stored in a computer readable storage medium and can be configured to manage information associated with set of data objects . As such, the information will typically be metadata associated with set of data objects , including, e.g., (1) knowledge pertaining to at least one version of set of data objects  received from the at least one other sync module, (2) forgotten knowledge pertaining to deleted data objects or versions thereof of set of data objects , or (3) filter forgotten knowledge pertaining to deleted data objects, or versions thereof, that belong to a filtered subset of the set of data objects  in which membership is dynamic. Thus, advantageously, synchronization mechanisms or procedures described herein can remain scalable, even without a need to fix set membership. Such is quite practical for both of the scenarios introduced above. For example, it is likely that over time, e.g., music rated 5 stars will change, either by the introduction of new 5 star music or deleting or rerating a previous 5 star rating. As another example, in the ERP situation, it is likely that, over time, some customers residing in the State of Washington will move to other states, thereby dropping out of the filter that is interested in the item of State of residence=WA.","Regardless, sync module  can be configured to synchronize, either partially or fully, local replica  based upon information received from the at least one other sync module, as substantially described herein. Such can be accomplished whether sync module  is the source or destination of the sync operation. For example, in one or more embodiment where sync module  is a source node, sync module  can be configured to initiate a synchronization procedure with the at least one other sync module by way of a change request (e.g., request changes  of ), which can transmit to the information (e.g., knowledge , filter forgotten knowledge , and\/or forgotten knowledge ) to the at least one other sync module. As a result, sync module  can receive from the at least one other sync module a conveyance of any changes (e.g., change convey  of ), which can include all or a subset of knowledge, filter forgotten knowledge, or forgotten knowledge associated with the at least one other sync module.","In the case where sync module  is a destination node, in one or more embodiment thereof, sync module  can be configured to respond to a synchronization procedure requested by the at least one other sync module based upon receipt of a change request that includes, e.g., knowledge, forgotten knowledge, or filter forgotten knowledge associated with the at least one other sync module. In addition, sync module  can also be configured to perform a comparison between data included in the change request and data included in the local replica . Further still, sync module  can be configured to transmit data determined to be unknown to the at least one other sync module based upon the comparison by way of a change conveyance.","Advantageously, when making the aforementioned comparison, in one or more embodiment, sync module  can be configured to compare received knowledge from the at least one other sync module to one or both of forgotten knowledge or filter forgotten knowledge included in local replica . In the case where the received knowledge is contained in the forgotten knowledge (or filter forgotten knowledge), then a normal sync can be performed as noted above, in which data determined to be unknown to the at least one other sync module can be transmitted. Additionally or alternatively, in the case where the received knowledge is not contained in the forgotten knowledge or filter forgotten knowledge of the at least one other sync module, then sync module  can proceed with one of a partial sync with line item exceptions or a full enumeration sync.","In one or more embodiment, sync module  can further include tracking module . Tracking module  can be configured to monitor or track at least one filter applied to the set of data objects . In other words, tracking module  can monitor various objects included in the set of data objects  that belong to a particular filter. That is, for example, music with a 5 star rating or customers who reside in WA can be monitored, e.g., to determine if and\/or when such objects move out of the filter. Accordingly, music with a 5 star rating that is later set to 4 stars (or a customer who moves from WA to, say NY) will move out of the filter, but, at least for a certain period of time (e.g., to ensure other nodes can be apprised of the change), can still be tracked by tracking module . On the other hand, music that has never been rated with 5 stars or at least not within a recent time frame (e.g., since a most recent cleanup operation and\/or a typical period in which other nodes are likely to be informed of the out move), will not be tracked by the \u201c5 star\u201d filter, but can be monitored by tracking module  in accordance with one or more different filter, such as, for instance, music under a certain price or music for relaxation, and so forth.","In one or more embodiment, tracking module  can be further configured to maintain a data table related to filtered data objects included in set of data objects , such as Table I, provided below. Table I, which follows, is an example of how a replica can advantageously track a filter for an item without change units.",{"@attributes":{"id":"p-0070","num":"0069"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE I"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":[{},"Creation","Last Update",{},"Move out"]},{"entry":["Item Id","Version","Version","Has been in the filter","version"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Id1","A10","B15","TRUE",{}]},{"entry":["Id2","A5","B9","FALSE","null"]},{"entry":["Id3","A9","A9","TRUE","A9"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}}}},"Thus, for example, the data table maintained by tracking module  can include at least one of (1) an item ID that uniquely describes a filtered data object; (2) a creation version that denotes a sync module ID and an indication of time associated with creation of the filtered data object; (3) a last update version that relates to a sync module ID and an indication of time associated with update to or versioning of the filtered data object; (4) an indication of presence or recent presence (e.g., \u201cHas been in the filter\u201d) of the filtered data object in the at least one filter; or (5) a move out version that relates to either a sync module ID and an indication of time associated with a change to the filtered data object that removes the filtered data object from the at least one filter or a null value or another value that indicates the filtered data object has not ever, or not recently, been in the at least one filter.","In accordance therewith, in one or more embodiment, tracking module  can be further configured to bootstrap the at least one filter in order to track preexisting filters. Thus, filters created by other nodes that are newly learned after the filter has previously existed, or in the case of a particular node that newly begins tracking a filter that previously existed need not lead to synchronization issues. Rather, the filter can be bootstrapped by setting filter forgotten knowledge associated with the data objects included in the filter to knowledge associated with the data objects included in the filter.","In addition, in one or more embodiment, tracking module  can be further configured to set filter forgotten knowledge of a moved data object to the move out version of the moved data object in order to treat the moved data object as though the moved data object never existed in the at least one filter. Such can be advantageous in that additional data such as ghosts or tombstones need no longer be stored in or associated with the filter forgotten knowledge, as further detailed herein. Therefore, tracking module  can be configured to set filter forgotten knowledge to the move out version during or substantially concurrently with a cleanup operation, in which case, filter forgotten knowledge and forgotten knowledge can be substantially identical.","It should be understood that with respect to all or a portion of the features detailed herein, sync module  can be associated with local replica  that is either one of a full replica (e.g., intended to store a copy of all data for the community) or a filtered replica (e.g., intended to store a subset of all data for the community, as determined by one or more filter), which can be syncing with either another full or filtered replica. However, it should be apparent that more interesting cases and\/or more interesting uses associated with filter forgotten knowledge arise during synch operations involving a full replica and a filtered replica, or with two filtered replicas that track the same or overlapping filters.","Therefore, in one or more embodiments, local replica  is a full replica configured to maintain all data managed by the multi-master community and a remote replica associated with the at least one other sync module is a filtered replica configured to maintain a subset of the data managed by the multi-master community based upon at least one filter applied to the set of data objects . In one or more embodiments, local replica  is a filtered replica configured to maintain a subset of data managed by the multi-master community based upon at least one filter applied to the set of data objects  and a remote replica associated with the at least one other sync module is a full replica configured to maintain all data managed by the multi-master community","The various embodiments for efficiently representing knowledge may also be applied to the context of resolving in memory data on the same provider. In such context, the in memory data may not be backed by a physical store, e.g., it might be used in a graph solver on the CPU to synchronize nodes. The various embodiments may also be applied in the context of scene graphs, especially as they become more distributed on multi-core architectures and calculations are written directly to an in memory data structure such as a volumetric texture.","Efficient Synchronization with Filters","As mentioned, filtering is applicable to many synchronization scenarios. In various embodiments, a comprehensive filtering functionality is built into a synchronization framework. As described for one or more of the embodiments, the synchronization framework can support list based filters. With a list based filter, the filter is defined in terms of the list of items, e.g., their global ids or GUIDs, which are in the filter. With list based filters, the metadata, which is exchanged during synchronization and saved as knowledge, grows linearly with the number of items which can become cumbersome for a large number of items or limited bandwidth for exchange.","The synchronization framework can also support column filtering. Column filters are expressed in terms of change units, e.g., properties of items, which are part of the filter. Column filters can also be called vertical filters.","In various other embodiments described herein, the filtering support of a synchronization framework can be extended to include other types of filters. This includes custom filters and move filters. A custom filter is one where the filter is defined by a third party and not understood by the synchronization framework. A move filter is one where the filter membership, e.g., a set of items that belong to the filter, changes over time.","In this regard, such filtering includes support for custom filters, e.g., filter(s) defined and implemented by third party code. The filtering is efficient since metadata growth is not proportional to the number of items in the filter. Further, filter usage is not a burden on the synchronization community since filter(s) used in one replica do not have to be understood, and maintained by all other replicas in the synchronization community. In addition, the synchronization protocol supports various common filtered replica synchronization scenarios for ease of use. Other scenarios by the synchronization framework are supported as well with single item exceptions in knowledge.","Media devices can use filters in terms of media type and attributes. Here are some examples: (a) Include a specific album, e.g., include all tracks that are part of the album, (b) Filter of specific tracks, (c) Filter of specific artist(s), (d) Include a folder of photos, (e) Include a play list, e.g., include all tracks on the play list, (f) Include a podcast series, e.g., depending on setting includes a number of episodes, (g) Genre Rock filter, e.g., includes all tracks of Genre Rock and (h) Filter of music that I do not hate, e.g., an exclude based list.","The following terms are used herein, and are defined as follows: Ghosting, Forgetting, Knowing filter F, Tracking filter F, Filtered Replica, Filtered Change Batch and Filter Forgotten Knowledge.","Ghosting is a technique by which a replica removes the data of an item or change unit, and keeps the metadata, namely the ID and change version. Ghosting is a way for a replica to manage its storage requirements by removing data that is of no interest to the replica.","Forgetting is a technique where a replica removes both data, and metadata for an item. Forgetting may be desired when, due to the storage limitations on a replica, keeping ghosts for many items is not desirable.","With respect to Knowing filter F, a replica with knowledge K knows filter F since Kiff (e.g., if and only if) the replica has versions for all items that had been in F since K.","With respect to Tracking filter F, a replica with knowledge K tracks filter F since Kiff the replica has versions for all items that have been in F since K, and the replica knows which items had been in F.","A filtered replica is a replica that stores data that belongs to a filter (e.g., only stores data that belongs to the filter). Filtered replicas keep ghosts for items that had been in the filter recently, and have moved out.","A filtered replica for filter F and forgotten knowledge (FK) is by definition tracking F since FK iff the replica maintains ghosts for all items that had been in F since FK.","A filtered change batch for filter F, pre-requisite knowledge (PK), and made with knowledge (MWK) has all changes (I, v) such that PK does not contain (I, V) and I had been in F.","A filtered change batch has data for all items in the filter and has versions for all items that had been in F.","A filtered change batch can have versions for more items, including items that may not have been in the filter. This allows replicas that know F, and do not track F, to produce filtered change batch.","Filter forgotten knowledge for a filter represents what is the base knowledge, e.g., most recent point, from which a replica has tracking information for a filter.","Filter forgotten knowledge helps a replica with tracking a filter in the following ways: (1) A replica can start to track a filter after the replica has existed for awhile without tracking the filter. The replica does so by setting its current knowledge at the time of starting to track the filter as the filter forgotten knowledge and (2) When an item that has been outside a filter F for a long time, a replica can treat the item as if the item has not been in the filter. The replica does so by advancing its filter forgotten knowledge to contain the move out version of the item.","With respect to tracking and ghosts, having all full replicas track a filter is one model. In this regard, full replicas track filters for filters with which they do filtered change enumeration. Filtered replicas maintain ghosts for items that have been in the filter. This is good from the standpoint of storage requirements since the replicas do not have to maintain ghosts for items that had not been in the filter.","In another model, not all full replicas track the filter. When a replica that does not track filter F sends changes to a replica that tracks F, the destination replica does not know which of the changed items have been in F. Items that are known to destination to have been in F are understood, but for other items, if changes are received, the destination advances its filter forgotten knowledge to current knowledge.","Later, when the filter tracking replica does a filtered change enumeration, the filter forgotten knowledge violation causes replica to send versions for those items for which filter forgotten knowledge has been advanced. This leads to correct synchronization in terms of convergence, and correct knowledge.","Both full replicas and filtered replicas can maintain full (or \u201cunfiltered\u201d) knowledge.","Knowledge of a filtered replica with filter F remains free of single item exceptions as far as the replica is synchronizing with replicas that track F.","Knowledge of a full replica has single item exceptions when the replica receives changes made at a full replica from the filtered replica. Such exceptions go away when the full replica synchronizes with other full replicas directly.","When a full replica does an occasional filtered synchronization with another full replica, the replica ends up with single item exceptions.","With respect to forgotten knowledge and filter forgotten knowledge, full replicas maintain a separate filter forgotten knowledge if they do not track the filter from the beginning. A filter forgotten knowledge that is different than forgotten knowledge is maintained from the time the replica started to track the filter until the next tombstone cleanup.","Filtered replicas maintain the filter forgotten knowledge. Filtered replicas also maintain a separate forgotten knowledge since they store ghosts for items that have been in the filter.","In one aspect of an embodiment of a synchronization protocol, tracked filters that are common between source and destination are identified. During synchronization filter tracking, information is synchronized for any filters that are tracked both at the source and destination. In order to determine the common filters, the destination sends the list of filters the destination is tracking to the source. This can be done using filter negotiation or a similar mechanism.","In one non-limiting implementation, filter tracking providers implement IFilterTrackingProvider. The synchronization session calls IFilterTrackingProvider.SpecifyTrackedFilters on the destination provider, and for each filter specified by the destination provider IFilterTrackingProvider. AddTrackedFilter is called on the source provider.","For a change batch, the source provider adds the filter forgotten knowledge for the subset of filters that are tracked both at the source and destination.","Destination unions source filter forgotten knowledge to its filter forgotten knowledge for any changes for which it is learning knowledge.","In one embodiment, for a synchronization change, the following filter change information is added to synchronization change: (1) If the item has been in the filter, e.g., a boolean value, and (2) the move out version, e.g., if an item has been in the filter, but has moved out, then the change version that moved the item out of the filter is the move out version.","When request (e.g., destination) knowledge does not contain the filter forgotten knowledge for an item, the source can assume the item to be one that has been in the filter and send any versions that are not contained by the request knowledge.","In one embodiment, when change units are involved, the source provider can use ContainsChangeUnit against all change unit(s) changes that can cause the item to move out. When it is not clear which change unit changes can cause an item to move item, a provider can use the change units that are relevant during synchronization, e.g., all of them, or if column filtering is involved, all of them that are part of the filter.","The destination provider can save the move out version when the destination provider is saving a change that causes an item to move out. It is ok for it to save a move out change even, e.g., in the presence of conflicts or recoverable errors.","In various embodiments and for various synchronization scenarios, the following knowledge operations enabled by the synchronization framework are provided for applications: complement, intersects, AddAllChangeUnitsRequiredMarker, AddAllChangeUnitsPresentMarker, ContainsAllChangeUnitsRequiredMarker and RemoveMarkers, as follows.","For Complement, in one embodiment, K.Complement(K) returns a knowledge that contains the changes that are contained by K, but not contained by K. For Intersects, in one embodiment, Intersects returns S_OK or S_FALSE based on whether the two knowledges have any clock vectors with common replica id.","For AddAllChangeUnitsRequiredMarker, in one embodiment, the destination provider uses this application programming interface (API) to add a marker that requests the source provider to include the change units, e.g., all change units, when enumerating items. The source provider can still apply any filters that the source provider has been asked to apply.","For AddAllChangeUnitsPresentMarker, in one embodiment, change batch uses this API to add a marker in learned knowledge that would indicate a change with the change units, e.g., all change units, was included in the change batch.","For ContainsAllChangeUnitsRequiredMarker, in one embodiment, when doing change enumeration, if a change unit that is not obsolete is found, the source provider can use this API to decide if the source provider will include the change units, e.g., all change units, that are applicable or not.","For RemoveMarkers, in one embodiment, a change batch builder uses this API to remove any \u201call change units required\u201d or \u201call change units present\u201d markers from the made with knowledge or pre-requisite knowledge.","It is noted that an implementation of ContainsChange or ContainsKnowledge can ignore the markers. Union can remove matching \u201call change units required\u201d and \u201call change units present\u201d markers.","For full replicas doing filtered change enumeration, with known filters, full replicas keep data and metadata for the items, e.g., all items. Hence, by definition the full replicas \u201cknow\u201d the filters, e.g., all filters. For example, the full replicas can ignore the requested filter and produce an unfiltered change batch.","For full replicas doing filtered change enumeration, with tracked filters, a full replica can track filters with which the full replica is frequently asked to enumerate changes. In one embodiment, tracking a filter uses a replica to keep the following per item metadata: (1) HasBeenInTheFilter (BOOL)\u2014indicates that item had been in the filter recently, (2) MoveOutVersion (SyncVersion)\u2014the move out version of the item. In this regard, null indicates an item had never been in the filter.","As provided above, with respect to Table I, a replica can track a filter for an item without employing change units.","With respect to bootstrapping a filter, a full replica can start to track a filter after the full replica has existed for awhile without having tracked the filter. The full replica does this by setting its current knowledge at the time of tracking the filter as the filter forgotten knowledge.","With respect to items that have been outside the filter for a long period, a replica can treat an item that has been outside the filter for a long time as one that has not been in the filter, but when doing so, the replica advances its filter forgotten knowledge to include the move out version of such items. One time for the provider to do this is at the same time the provider is performing tombstone cleanup. In one non-limiting implementation, the provider can do the following: (1) Set the filter forgotten knowledge to forgotten knowledge and (2) Set \u201cHas been in the filter\u201d to FALSE for all items whose move out version is contained by the forgotten knowledge.","With respect to a filtered change batch, in one embodiment, a filtered change batch includes the following: (1) Made with knowledge\u2014source knowledge, (2) Pre-requisite knowledge\u2014request knowledge, (3) Forgotten knowledge\u2014filter forgotten knowledge and (4) Changes including (a) Data\u2014for the items in the filter at the source (e.g., all items) and (b) Metadata\u2014for the items that have been in the filter, e.g., has been in the filter=TRUE.","With respect to a filtered replica doing filtered change enumeration, for known filters, a filtered replica stores data for all items that belong to a filter. It maintains metadata (versions) for all items that had been in the filter recently. Hence by definition a filtered replica knows the filter that is part of its replica definition.","For tracked filters, a filtered replica maintains ghosts for all items that have been in the filter. Such a filtered replica tracks the filter by definition.","When cleaning up ghosts, a filtered replica can clean up ghosts just like a full replica cleans up tombstones. It does so by removing ghosts and advancing its forgotten knowledge to include the move out version for all the ghosts that were removed.","For a filtered change batch, the following is included: (1) Made with knowledge\u2014source knowledge, (2) Pre-requisite knowledge\u2014request knowledge, (3) Forgotten knowledge\u2014filter forgotten knowledge and (4) Changes including (a) Data\u2014for the items, e.g., all items, in the filter at the source and (b) Metadata\u2014the ghosts, e.g., all the ghosts.","With respect to a filtered replica doing change enumeration without a filter, in one embodiment, a filtered change batch includes the following: (1) Made with knowledge\u2014source knowledge, (2) Pre-requisite knowledge\u2014request knowledge, (3) Forgotten knowledge\u2014forgotten knowledge and (4) Changes including (a) Data\u2014for the items, e.g., all items, in the filter at the source and (b) Metadata\u2014the ghosts, e.g., all the ghosts.","With respect to a filtered replica doing change application of filtered change batch, the following notations can be used for descriptive simplicity: DFK\u2014destination forgotten knowledge, DFFK\u2014destination filter forgotten knowledge, SFK\u2014source forgotten knowledge, DK\u2014destination knowledge, Complement\u2014Knowledge subtraction and Intersection\u2014Knowledge intersection.","For conflict detection, the following non-limiting implementation details are provided as an example. In addition to regular knowledge conflict checks, the following can be performed:",{"@attributes":{"id":"p-0131","num":"0130"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public DetectConflicts( )"},{"entry":"{"},{"entry":"\u2003if (destinationVersion != null)"},{"entry":"\u2003{"},{"entry":"\u2003\u2003\/\/"},{"entry":"\u2003\u2003\/\/ Destination has item and not ghost"},{"entry":"\u2003\u2003\/\/"},{"entry":"\u2003\u2003if (destinationHasItem)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\/\/ Can do regular conflict detection"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003destinationKnowledge += change.LearnKnowledge( );"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003\/\/"},{"entry":"\u2003\u2003\/\/ Can unghost. Whole item present?"},{"entry":"\u2003\u2003\/\/"},{"entry":"\u2003\u2003else if (fullItemEnumerated)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\/\/ A new change made with the versions of the destination"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003if (MWK.Contains(destinationVersion))"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003\/\/ Unghost item and learn knowledge"},{"entry":"\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003destinationKnowledge += change.LearnKnowledge( );"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003\/\/ Raise conflict and accept with new version"},{"entry":"\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003\/\/"},{"entry":"\u2003\u2003\/\/ Unghost, but only a partial change enumerated"},{"entry":"\u2003\u2003\/\/"},{"entry":"\u2003\u2003else"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\/\/ Add a marker to destination knowledge which"},{"entry":"\u2003\u2003\u2003\/\/ requests next time changes are enumerated to this"},{"entry":"\u2003\u2003\u2003\/\/ provider, the relevant change units are included"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2002destKnowledge.AddAllChangeUnitsRequiredMarker(change.itemId);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"\u2003\/\/"},{"entry":"\u2003\/\/ Destination knows the creation version, but item or ghost does not"},{"entry":"\u2003\/\/ exist."},{"entry":"\u2003\/\/"},{"entry":"\u2003\/\/"},{"entry":"\u2003else if (destinationKnowledge.Contains(change.CreationVersion))"},{"entry":"\u2003{"},{"entry":"\u2003\u2003if (fullItemEnumerated)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\/\/ Item has moved into the filter"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003if (MWK.Contains(destinationKnowledge.ProjectToChange( )))"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003\/\/ Create item and accept knowledge"},{"entry":"\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003destinationKnowledge += change.LearnKnowledge( );"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\/\/ Item has moved into the filter, but destination knowledge"},{"entry":"\u2003\u2003\u2003\/\/ is higher. Possibly get some changes that were discarded"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003else if ( MWK.Contains("},{"entry":"destFilterForgottenKnowledge.ProjectToChange( )))"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003\/\/ Lower knowledge and accept change"},{"entry":"\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003\/\/ calculation"},{"entry":"\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\/\/ The ability to correctly detect conflicts"},{"entry":"\u2003\u2003\u2003\/\/ for this change may have been lost"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003\/\/ Raise new type of conflict (e.g., possibly overwrite some"},{"entry":"\u2003\u2003\u2003\u2003\/\/ change) accept with new version"},{"entry":"\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003else"},{"entry":"\u2003\u2003{"},{"entry":"\u2002destKnowledge.AddAllChangeUnitsRequiredMarker(change.itemId);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"\u2003\/\/"},{"entry":"\u2003\/\/ Can apply this change. It is a new create"},{"entry":"\u2003\/\/"},{"entry":"\u2003else"},{"entry":"\u2003{"},{"entry":"\u2003\u2002destinationKnowledge += change.LearnKnowledge( );"},{"entry":"\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Knowledge can be calculated as follows:\n\nDK=DK+MWK.ProjectWithPrerequisite( ).Exclude(all items that have a filter move in version not contained by MWK)\n","With respect to forgotten knowledge, a filtered replica's forgotten knowledge is advanced to cover items and ranges for which the filtered replica's learned knowledge is advanced. With respect to filter forgotten knowledge, filter forgotten knowledge is advanced to cover any items and ranges for which the learned knowledge is advanced. This is true both for filtered replicas, as well as for full replicas that track a filter.","For a full replica doing change application on receiving changes from a filtered replica, when a destination is a full replica, the change batch is unfiltered. In such case, the change batch will have the following: (1) Made with knowledge\u2014source knowledge, (2) Pre-requisite knowledge\u2014request knowledge, (3) Forgotten knowledge\u2014forgotten knowledge and (4) Changes including (a) Data\u2014for items, e.g., all items, in the filter at the source and (b) Metadata\u2014the ghosts, e.g., all the ghosts.","It is noted that if the source is keeping ghosts only for items that had been in the filter, the source forgotten knowledge will be high.","The following topology is used for the examples that follow below.","A\u2014Full replica","B\u2014Full replica","C\u2014Filtered replica with F","D\u2014Filtered replica with F","E\u2014Filtered replica with F, where neither F or F contains the other, but they overlap","The following notations are also used:","K=A's knowledge","FK=A's forgotten knowledge","FK(F)=A's filter forgotten knowledge for F","With respect to bootstrapping tracking of a filter, the following example is illustrative.","1. Initial state:","a. K=AB, FK=null","b. K=C, FK=null, FK(F)=null","2. A starts to track F. FK(F)=AB.","3. A\u2192C synchronization change batch has","a. MWK=AB","b. PK=C","c. FK=null","d. Although K.Contains(FK(F))==FALSE, it is also K.Intersects(FK(F))==FALSE. Hence, A includes items that have been in the filter since AB.","4. A\u2192C synchronization change application @ C","a. Advance forgotten knowledge since C is a filtered replica: FK=AB","b. Advance filter forgotten knowledge FK(F)=AB","c. Advance knowledge: K=ABC","With respect to bootstrapping tracking of a filter with some common changes, the following is a continuation of the above example.","1. Initial state:","a. K=AB, FK=null","b. K=ABC, FK=AB, FK(F)=AB","2. B starts to track F. FK(F)=AB.","3. B\u2192C synchronization change batch has","a. MWK=AB","b. PK=ABC","c. FK=null","d. B includes ghosts for all changes since K.Contains(FK(F))==FALSE && K.Intersects(FK(F))==TRUE","4. B\u2192C synchronization change application @ C","a. Advance knowledge to K=ABC","b. Advance forgotten knowledge FK=AB","c. Advance filter forgotten knowledge FK(F)=AB","With respect to synchronization from a full replica to a filtered replica, in this example, synchronization occurs where the full replica has been tracking the filter for awhile, as follows.","1. Initial state","a. K=ABCD, FK=FK(F)=ABCD","b. K=ABCD, FK=AB, FK(F)=AB","2. A\u2192C synchronization, change batch has","a. MWK=ABCD","b. PK=ABCD","c. FK=ABCD","3. A\u2192C synchronization change application @ C","a. Forgotten knowledge check succeeds: K.Contains(FK)==TRUE.","b. Advance forgotten knowledge since C is a filtered replica. FK=FK+MWK.Complement(K)=ABD","c. Advance knowledge: K=ABCD","d. Filter forgotten knowledge does not change. FK(F)=FK(F).Union(FK(F).Complement(K)","With respect to synchronization from a filtered replica to another with the same filter, the following example is illustrative:","1. Initial state","a. K=ABCD, FK=AB, FK(F)=AB","b. K=ABCD, FK=AB, FK(F)=AB","2. C\u2192D synchronization; Change batch has","a. MWK=ABCD","b. PK=ABCD","c. FK=AB","3. C\u2192D synchronization; Change application @ D","a. Forgotten knowledge check passes.","b. Advance forgotten knowledge since D is a filtered replica","FK=ABD","c. Advance knowledge: K=ABCD","With respect to synchronization from a filtered replica to a full replica the following example is illustrative:","1. Initial state:","a. K=ABCD, FK=FK(F)=AB","b. K=ABCD, FK=AB, FK(F)=AB","2. C\u2192B synchronization; Change batch has","a. MWK=ABCD","b. PK=ABCD","c. FK=AB","3. C\u2192B synchronization; Change application @ B","a. Forgotten knowledge check fails: K.Contains(FK)==FALSE","b. Partial synchronization happens (recovery synchronization not possible)","K=K+MWK.UnionWithPrerequisite(PK.Union(FK),K)+MWK.Project(changesAppplied)=ABCD+single item exceptions for all changes with A","With respect to synchronization from a filtered replica to another with a different filter, the following example is illustrative:","1. Initial state","a. K=AC, FK=A, FK(F)=null, FK(F)=AC","b. K=AE","2. C\u2192E synchronization; Change batch has","a. MWK=AC","b. PK=AE","c. FK=AC","3. C\u2192E; Change application @ E","a. Forgotten knowledge check fails","b. Do partial synchronization. Advance knowledge with single item exceptions. K=AE+{for all applied changes}AC","To support filtered synchronization for a synchronization application, the synchronization application can pass the filter to the destination provider, unless the destination is a filtered replica that does not know it is filtered. In such case, a variety of interfaces defined by synchronization framework can be used for the synchronization application to pass the desired filter to the destination provider.","With respect to filter tracking providers, a provider is said to be tracking a filter if, for every item and tombstone, the provider knows\/tracks: (1) Which items have recently been in the filter, (2) When did the last move (in or out) happen for items that have recently been in the filter and (3) A filter forgotten knowledge which represents knowledge that is an over estimation (guaranteed to be no smaller) on from what point provider can correctly enumerate filter changes.","A filter tracking provider implements IFilterTrackingProvider and ISupportFilteredSync. Filter tracking providers that uses change applier also implement IFilterTrackingNotifyingChangeApplierTarget.","One way to filter forgotten knowledge is to calculate the forgotten knowledge by taking a snapshot of the replica knowledge when a filter was tracked initially, and then updating the snapshot during the following cases: 1) When synchronizing changes from other replicas. When using change applier this happens automatically, 2) When tombstones are cleaned up and 3) When filter change information is cleaned up. A replica can treat items that have been outside of the filter for a long time to have never been in the filter, but when it does that, it can update its filter forgotten knowledge. ForgetToVersion can also be used to update the forgotten knowledge instead of using the snapshot mechanism.","Providers are recommended to clean up filter change information at the same time as tombstone cleanup. In which case, once a cleanup has happened, forgotten knowledge and filter forgotten knowledge are the same and storing them separately is unnecessary.","With respect to filter tracking negotiation, a filter tracking provider participates in filter tracking negotiation using methods on IFilterTrackingProvider. When two full replicas that track filters synchronize, the filter tracking information is synchronized. Filter tracking happens after BeginSession and prior to any other methods (e.g., GetSyncBatchParameters, GetChangeBatch, or ProcessChangeBatch) called on the provider.","When a filter tracking provider is the destination of a synchronization operation, the provider specifies the filters using IFilterTrackingProvider.SpecifyTrackedFilters. If one or more filters are not tracked by the source (e.g., the return value is S_FALSE or SYNC_E_FILTER_NOT_SUPPORTED), it is ok and synchronization can continue.","When a filter tracking provider is the source of the synchronization operation, in one non-limiting implementation, IFilterTrackingProvider.AddTrackedFilter is called for each filter tracked by the destination. If the destination does not track a filter, the destination indicates the filter is not tracked by returning S_FALSE. HRESULTs other than S_FALSE and SYNC_E_FILTER_NOT_SUPPORTED will abort the synchronization session.","With respect to change enumeration, GetChangeBatch is called on the provider to get changes. The provider determines whether the destination is tracking any filters based on the filter negotiation that happened.","In one non-limiting implementation, if ISupportFilteredSync.AddFilter is called, then destination has requested a filter. If filtering type is FT_CURRENT_ITEMS_AND_VERSIONS_FOR_MOVED_OUT_ITEMS, then destination is a filtered replica. If IFilterTrackingProvider.AddTrackedFilter is called, then the destination is tracking some filters. The destination may or may not be a filtered replica.","If a filter is requested, then a filtered change batch is produced. Otherwise, a regular change batch is produced. If the destination has requested a custom filter, or requested filter tracking information for a custom filter, then a filter key map can be specified using\u2014ISyncChangeBatchWithFilterKeyMap.SetFilterKeyMap. This can be performed before any groups (ordered or unordered) are added, and before any changes or logged conflicts are added to the change batch.","In one non-limiting embodiment, for every filter that is common between source and destination, filter forgotten knowledge is specified and filter changes are added to the synchronization change if the destination does not know the filter. When creating a change batch with custom or a combined filter, the filter forgotten knowledge is specified as the forgotten knowledge.","Filter forgotten knowledge can be added to the change batch using ISyncChangeBatchWithFilterKeyMap.SetFilterForgottenKnowledge. This can be done once per group, after the group has been started. This is since different groups can have different filter forgotten knowledges.","When change units are involved and source knowledge contains the \u201call change units required\u201d marker, e.g., IKnowledgeWithMarkers\u2192ContainsAllChangeUnitsRequiredMarker(itemId), and at least one non-obsolete change unit is found, the source can include the change units that are relevant, e.g., if no column filtering involved then all change units at source, else all change units in the column filter. When the source includes the change units, then in one embodiment, the source can set the \u201call change units present\u201d marker on the synchronization change using IFilterTrackingSyncChangeBuilder. SetAllChangeUnitsPresentFlag( ).","When there are common custom filters between the source and destination filter, in one embodiment, changes that are not obsolete can be added to the synchronization change using IFilterTrackingSyncChangeBuilder. AddFilterChange.Filter changes are conceptually present in a special change unit and hence ContainsChange (instead of ConstainsChangeUnit) can be used to determine if the change is obsolete or not.","A source provider can decide whether to enumerate filter changes based on checks of the move version of filter changes against destination knowledge. There can be the following cases for the custom filters and filter changes: (1) There are no change units associated with a filter. Filter membership is done based on evaluating a whole item. In this case, the filter change is enumerated if destination knowledge does not contain a move version for the current item. (2) A single change unit is associated with a filter. In this case, the filter change is enumerated if destination knowledge does not contain a move version for the change unit used in the filter for the current item. (3) More than one change unit is associated with a filter. In this case, the filter change is enumerated if destination knowledge does not contain a move version for all change units used in the filter for the current item.","For a change application, in one embodiment, ProcessChangeBatch is called on the provider to apply changes. In one implementation, providers that use change application calls ApplyChanges with an ISynchronousNotifyingChangeApplier that is also an IFilterTrackingNotifyingChangeApplierTarget.","When destination versions are given to the change applier, destination filter changes can be included. In one embodiment, destination filter changes are added using IFilterTrackingSyncChangeBuilder.AddFilterChange. When saving changes, filter changes can be updated using IFilterTrackingSaveChangeContext.GetFilterChange.","In one non-limiting implementation, the IFilterTrackingSaveChangeContext.GetFilterChange method can return: 1) S_OK if filter change is enumerated from the source and filter change is available, 2) S_FALSE if source replica is tracking but there is no filter change or 3) SYNC_E_FILTER_CHANGE_NOT_AVAILABLE if source replica is not tracking.","The responsibility of the destination provider is to carry out that a filter change returned by IFilterTrackingSaveChangeContext.GetFilterChange is not obsolete by using the following logic for the following cases: 1) If there are no change units associated with a filter, a filter change is obsolete if its move version is contained by the destination knowledge for the current item. 2) If there is a single change unit associated with a filter, a filter change is obsolete if its move version is contained by the destination knowledge for the change unit used in the filter for the current item. 3) If there are several change units associated with a filter, a filter change is obsolete if its move version is contained by the destination knowledge for all change units used in the filter for the current item.","Once a filter change is considered to be not obsolete, the destination provider typically helps to ensure there are no conflicts with the current filter change at the destination. In one non-limiting implementation, the destination provider uses the following logic: 1) If IFilterTrackingSaveChangeContext.GetFilterChange returns SYNC_E_FILTER_CHANGE_NOT_AVAILABLE, the destination can assign a new move version to the filter change. 2) If IFilterTrackingSaveChangeContext.GetFilterChange returns S_FALSE, the destination can reevaluate the filter and assign a new move version to the filter change if it changes. 3) If IFilterTrackingSaveChangeContext.GetFilterChange returns S_OK, the destination can perform a conflict detection: a) If there are no change units associated with a filter, the local filter change is conflicting if its move version is not contained in the made-with knowledge for the current change for the current item. b) If there is a single change unit associated with a filter, the local filter change is conflict if its move version is not contained in the made-with knowledge for the current change for the change unit used in the filter for the current item. c) If there are several change units associated with a filter, the local filter change is conflict if its move version is not contained in the made-with knowledge for the current change for all change units used in the filter for the current item.","Once a conflict is detected, the destination can resolve it in whatever way it deems right, e.g., by merging with the filter change enumerated from the source, and assign the new move version to the filter change. Else If move version conflict is not detected, but an inconsistency on move-in flag between source and destination filter changes is present, the destination provider re-evaluates a filter, picks a move-in flag value and assigns a new version. Else, the source's filter change and its move-in flag\/move version are saved.","If a provider updates knowledge per change using GetKnowledgeForScope, the provider can update filter forgotten knowledge using IFilterTrackingSaveChangeContext.GetUpdatedFilterForgottenKnowledge.","For filter tracking, providers change applier calls (e.g., IFilterTrackingNotifyingChangeApplierTarget. SaveKnowledgeWithFilterForgottenKnowledges instead of ISynchronousNotifyingChangeApplierTarget.SaveKnowledge).","Providers that do not use a change applier can otherwise ensure filter forgotten knowledge is advanced correctly. If a source does not track a filter, source knowledge for the changes can be added to destination filter forgotten knowledge. If a source does track a filter, then source knowledge for the changes can be added if the destination filter forgotten knowledge does not contain the filter already.","In regards to filtered replica providers, filtered replicas store data for items that belong to a custom or combined filter. Filtered replicas store ghosts for items that have recently been in the filter. By definition, a filtered replica is tracking the filter that is part of its definition.","In one embodiment, a filter tracking provider implements IFilterTrackingProvider, ISupportFilteredSync, and IRequestFilteredSync. Filtered replica providers that use a change applier also implement IFilteredReplicaNotifyingChangeApplierTarget.","In regards to filter forgotten knowledge, filtered replicas add the filter that is part of their replica definition as the first filter in their filter key map. If there are other filters they track, they can be added afterwards.","With respect to change enumeration, when no filters have been negotiated, a filtered replica is enumerating changes to a full replica. If the filter that is part of the replica definition has been negotiated, then the filtered replica is enumerating changes to another filtered replica with the same filter.","When enumerating changes to another filtered replica with the same filter, filter forgotten knowledge is specified as the forgotten knowledge for change batch creation. In other cases, replicas specify their forgotten knowledge.","If the destination replica is a full replica, then ghosts can be skipped.","With respect to change application, ProcessChangeBatch is called on the provider to apply changes. Providers that use change application calls ApplyChanges with a ISynchronousNotifyingChangeApplier that is also (e.g., can be QIed to) a IFilteredReplicaChangeApplierTarget.","Guidelines that are applicable to filter tracking replicas can also be applicable here.",{"@attributes":{"id":"p-0256","num":"0255"},"figref":"FIGS. 10-12"},{"@attributes":{"id":"p-0257","num":"0256"},"figref":"FIG. 10"},"At , the application specifies a filter to the destination. At , the application starts a sync session. At , the sync session issues to the destination a pRequestFilteredSync\u2192SpecifyFilter. At , the destination returns to the sync session a pFilterRequestCallback2\u2192RequestFilter. At , the sync session sends to the source provider a pISupportFilteredSync2\u2192AddFilter command. At , the source returns a filtered change batch to the destination in response.",{"@attributes":{"id":"p-0259","num":"0258"},"figref":"FIG. 11"},"At , the application specifies a filter to the destination. At , the application starts a sync session. At , the sync session issues to the destination a pRequestFilteredSync\u2192RequestFilter. At , the destination returns to the sync session a pFilterRequestCallback2\u2192SpecifyFilter. At , the sync session sends to the source provider a pISupportFilteredSync2\u2192AddFilter command, but it fails with a SYNC_E_FILTER_NOT_SUPPORTED. At , the source returns an unfiltered change batch to the destination in response at which point at , the destination filters the change batch before applying changes.","Where the destination is a full replica, and the source tracks the filter, the component interaction of  can apply.","Where the destination is a full replica, and the source does not track the filter, but evaluates the filter, this is useful in certain scenarios, for example, where music files with ratings are being synchronized. Although the destination keeps the music files, some synchronizations obtain the subset of files with rating \u201c5*\u201d.  illustrates such a component interaction.","At , the application specifies a filter to the destination. At , the application starts a sync session. At , the sync session issues to the destination a pRequestFilteredSync\u2192RequestFilter. At , the destination returns to the sync session a pFilterRequestCallback2\u2192SpecifyFilter. At , the sync session sends to the source provider a pISupportFilteredSync2\u2192AddFilter command, but it fails with a SYNC_E_FILTER_NOT_SUPPORTED. At , the destination can deliver a pFilteredRequestCallback\u2192SpecifyFilter, to, e.g., attempt to negotiate a different filter since the previous filter suggested by the destination provider at  was not supported. At , the source provider can add the suggested filter by way of a pISupportedFilteredSync\u2192AddFilter. As such, at , the source returns a filtered change batch to the sync session.",{"@attributes":{"id":"p-0264","num":"0263"},"figref":"FIG. 13","b":["1300","1310","1320","1330","1300","1310","1302","1312","1320","1330","1322","1332","1300","1310","1320","1330"]},"As shown, PCs  and  each store all music for a synchronization community, and thus when they synchronize with one another, in addition to synchronizing via a generic knowledge exchange, they also exchange forgotten knowledges FKand FK, respectively. Similarly, when PC  and laptop  synchronize or when PC  and laptop  synchronize, they exchange forgotten knowledges FKand FK, and FKand FK, for their respective exchanges. However, advantageously, when laptop  and laptop  synchronize, in addition to the general knowledge exchange, as described above, they can exchange filtered forgotten knowledges FFKand FFK, respectively, a more compact representation not representing forgotten knowledge outside of the scope of the filter being tracked by laptop  and .",{"@attributes":{"id":"p-0266","num":"0265"},"figref":"FIG. 14","b":["1400","1410"]},"At , the first replica can communicate with a second replica of a multi-master community of replicas, the second replica storing a second version of data objects and associated metadata. Accordingly, changes to data objects performed at either the first replica or the second replica can be shared, and appropriate updates can be applied to the first version of data objects stored in the first replica or vice versa based upon what is known about the data objects by the first replica and second replica, respectively. In particular, at , the first replica can include (1) knowledge relating to known version of data objects maintained by the multi-master community (e.g., the second replica, et al.), and (2) filter forgotten knowledge relating to purged or deleted data objects, or versions thereof, belonging to a filtered subset of the first version of data objects in which membership is variable. In addition, in one or more embodiment, the first replica can also include forgotten knowledge relating to purged or deleted objects or versions thereof. Advantageously, by maintaining knowledge, forgotten knowledge, and\/or filter forgotten knowledge, the synchronizing the first replica based upon data received from the second replica can be effectuated, and vice versa.","For example, at least one of knowledge, forgotten knowledge, or the filter forgotten knowledge can be transmitted by the first replica in order to initiate a synchronization process with the second replica. Generally, the second replica can examine such data, identify potential updates to its own version of data objects, and also identify information not known to the first replica, which can be transmitted to and\/or received by the first replica.","On the other hand, e.g., in cases where the second replica is the initiator of the sync, the first replica can receive at least one of the knowledge, forgotten knowledge, or the filter forgotten knowledge from the second replica during a synchronization process, perform suitable comparisons, and respond with information determined to be unknown by the second replica. In either case, the destination replica will respond to the source replica based upon a comparison of current knowledge versus either forgotten knowledge or filter forgotten knowledge. When the comparison is nominal, then a normal synchronization operation can be completed by transmitting to the source replica what is determined to be unknown to the source replica.","However, in other cases, a partial synchronization with line items exceptions can be invoked, while in still other cases, a full enumeration synchronization can be performed. For example, assuming the first replica is the destination replica (e.g., the second replica initiated the synchronization operation), then a partial synchronization with line item exceptions can be performed when knowledge received from the second replica is not contained in either forgotten knowledge or filter forgotten knowledge of the first replica. Similarly, a full enumeration synchronization can be performed when knowledge received from the second replica is not contained in either forgotten knowledge or filter forgotten knowledge of the first replica.","Regardless, it is apparent that filter forgotten knowledge can be advantageously leveraged to facilitate not only suitable filtering, but also tracking of filters to enable syncing with respect to variable set membership. For example, filter forgotten knowledge can be employed for tracking one or more filter applied to the first version of the data objects. Thus, in connection with filter forgotten knowledge, a first indication of whether a tracked data object has been in the one or more filter since a last cleanup operation for tracking the one or more filter can be maintained. In addition, a second indication of whether the tracked data object has moved out of the one or more filter for tracking the one or more filter can be maintained.","Moreover, filter forgotten knowledge can also be employed in connection with bootstrapping, such as when a replica begins to track a previously existing filter, even though, previously, the replica was not tracking the filter, and therefore can bootstrap. For example, the one or more filter can be bootstrapped by tracking an existing filter and setting knowledge relating to data objects included in the existing filter to filter forgotten knowledge relating to data object included in the existing filter. Furthermore, stale moved objects can be vacated from the one or more filter when a moved out version of the moved object that has left the one or more filter predates a last cleanup process by setting filter forgotten knowledge for the moved object to forgotten knowledge for the moved object. Advantageously, the vacating of stale moved objects can be performed concurrently with a cleanup process, which has the advantageous of converging the sets of forgotten knowledge and filter forgotten knowledge.",{"@attributes":{"id":"p-0273","num":"0272"},"figref":"FIG. 15","b":["1500","1510"]},"Thus, at , knowledge relating to known versions of data objects maintained by the multi-master community, forgotten knowledge relating to purged data object or versions thereof, and filter forgotten knowledge relating to purged data objects, or versions thereof, that are included in a filtered subset, with variable membership, of the local version of data objects can be maintained by the local replica.","Hence, in one or more embodiment, synchronizing the local replica and the other replica according to a normal sync operation can be effectuated, such as when knowledge of a source replica is contained in either forgotten knowledge or filter forgotten knowledge of the destination replica. In other case, such as when knowledge of a source replica is not contained in either forgotten knowledge or filter forgotten knowledge of the destination replica, then various other types of synchronization procedures can be applied. For example, synchronizing the local replica and the other replica according to a partial sync operation with line item exceptions, synchronizing the local replica and the other replica according to a full enumeration operation, or the like.","Moreover, as introduced above, filter forgotten knowledge can be leveraged in various ways. For example, for tracking at least one filter applied to the data objects. Such tracking can take the form of maintaining a first indication of whether a tracked data object has been in the one or more filter since a last cleanup operation and\/or maintaining a second indication of whether the tracked data object has moved out of the one or more filter for tracking the one or more filter. Regardless, set membership can be monitored to, e.g., determined whether a member of the data objects either is currently, was recently, or has never been a member of a filtered subset, all or any of which can be useful for various synchronization procedures as detailed herein.","The following presents some exemplary non-limiting APIs for the efficient synchronization of replicas with filters.","For instance, the following enums and flags can apply.","Filtering_Type",{"@attributes":{"id":"p-0280","num":"0279"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/"},{"entry":"\/\/ This enum is used with filter negotiation of custom filters to indicate"},{"entry":"\/\/ what type of filtered synchronization is requested"},{"entry":"\/\/"},{"entry":"\u2003\u2003\u2003typedef enum"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/ Data and metadata for changes to items in the filter at the source are"},{"entry":"included."},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003FT_ONLY_CURRENT_ITEMS,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/ Data and metadata for changes to items in the filter at the source are"},{"entry":"included."},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/ In addition metadata (i.e. versions) are included for items that had"},{"entry":"been in the filter"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003FT_CURRENT_ITEMS_AND_VERSIONS_FOR_MOVED_OUT_ITEMS"},{"entry":"\u2003\u2003\u2003} FILTERING_TYPE;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Synchronization Change Flags","The following flags can be used with IsyncChange to indicate a version (e.g., only version) is included in change batch:",{"@attributes":{"id":"p-0283","num":"0282"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"#define SYNC_CHANGE_FLAG_VERSION_ONLY \u2003\u20030x00000004"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"For instance, the following are SYNC_SAVE_ACTION Values",{"@attributes":{"id":"p-0285","num":"0284"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/"]},{"entry":[{},"\/\/ Create a ghost item."]},{"entry":[{},"\/\/"]},{"entry":[{},"SSA_CREATE_GHOST,"]},{"entry":[{},"\/\/"]},{"entry":[{},"\/\/ Change live item to a ghost."]},{"entry":[{},"\/\/"]},{"entry":[{},"SSA_GHOST_ITEM,"]},{"entry":[{},"\/\/"]},{"entry":[{},"\/\/ Change a ghost to a live item."]},{"entry":[{},"\/\/"]},{"entry":[{},"SSA_UNGHOST_ITEM,"]},{"entry":[{},"\/\/"]},{"entry":[{},"\/\/ Update version for ghost"]},{"entry":[{},"\/\/"]},{"entry":[{},"SSA_UPDATE_GHOST,"]},{"entry":[{},"\/\/"]},{"entry":[{},"\/\/ Change a ghost to a tombstone"]},{"entry":[{},"\/\/"]},{"entry":[{},"SSA_DELETE_GHOST"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Sync_Filter_Change_Info",{"@attributes":{"id":"p-0287","num":"0286"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/"]},{"entry":[{},"\/\/ Filter change info is used to specify filter changes"]},{"entry":[{},"\/\/ (e.g., change type and change version) with IsyncChange"]},{"entry":[{},"\/\/"]},{"entry":[{},"typedef struct _SYNC_FILTER_CHANGE_INFO"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003\/\/ True indicates item has been in the filter"]},{"entry":[{},"\u2003\u2003\/\/ For replicas that cleanup filter history"]},{"entry":[{},"\u2003\u2003\/\/ this means item has recently been in the filter"]},{"entry":[{},"\u2003\u2003\/\/ (e.g. more recent than forgotten knowledge)"]},{"entry":[{},"\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003BOOL \u2003\u2003\u2003\u2003fHasBeenInTheFilter;"]},{"entry":[{},"\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003\/\/ Synchronization version for the last move out."]},{"entry":[{},"\u2003\u2003\/\/ For items that are currently in the filter or has never"]},{"entry":[{},"\u2003\u2003\/\/ been in the filter this can be (0,0)"]},{"entry":[{},"\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003SYNC_VERSION \u2003lastMoveOutVersion;"]},{"entry":[{},"} SYNC_FILTER_CHANGE_INFO;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Filter_Group_Type","Filter grouping is used to aggregate filters. In one embodiment, intersection of a custom filter with a column filter are supported.",{"@attributes":{"id":"p-0290","num":"0289"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/"]},{"entry":[{},"\/\/ This enum is used to create aggregated filters"]},{"entry":[{},"\/\/"]},{"entry":[{},"typedef enum"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\/\/"]},{"entry":[{},"\u2003\/\/ Compose a filter that is an intersection for two filters"]},{"entry":[{},"\u2003\/\/"]},{"entry":[{},"\u2003FGT_INTERSECTION"]},{"entry":[{},"} FILTER_GROUPING_TYPE;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The following describes exemplary SYNC_FILTER_INFO flags.","Two filter info flags can be included. The first flag is used with custom filters, the second one with grouped filters.",{"@attributes":{"id":"p-0293","num":"0292"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003Cpp_quote(\u201c#define SYNC_FILTER_INFO_FLAG_CUSTOM"},{"entry":"0x00000004\u201d)"},{"entry":"\u2003\u2003cpp_quote(\u201c#define SYNC_FILTER_INFO_COMBINED"},{"entry":"0x00000008\u201d)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Interfaces implemented by 3rd parties include the following, e.g., provider writers.","IrequestFilteredSync","This interface already exists in MSF V2 CTP1. It is listed for completeness.",{"@attributes":{"id":"p-0297","num":"0296"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/"]},{"entry":[{},"\/\/ Implemented by synchronization providers"]},{"entry":[{},"\/\/ It is called by synchronization framework on the destination"]},{"entry":[{},"\/\/ provider to do filter negotiation"]},{"entry":[{},"\/\/"]},{"entry":[{},"\/\/"]},{"entry":[{},"interface IrequestFilteredSync : Iunknown"]},{"entry":[{},"{"]},{"entry":[{},"\u2003HRESULT SpecifyFilter("]},{"entry":[{},"\u2003\u2003[in] IfilterRequestCallback * pCallback);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"IsupportFilteredSync2",{"@attributes":{"id":"p-0299","num":"0298"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/"},{"entry":"\/\/ IsupportFilteredSync2 is implemented by providers"},{"entry":"\/\/ It is called by the synchronization framework on the source provider"},{"entry":"\/\/ during filter negotiation to see if source can produce"},{"entry":"\/\/ a filtered change batch with the specified filter"},{"entry":"\/\/"},{"entry":"interface IsupportFilteredSync2 : Iunknown"},{"entry":"{"},{"entry":"\u2003HRESULT AddFilter("},{"entry":"\u2003\u2003[in] Iunknown * pFilter,"},{"entry":"\u2003\u2003\u2003\u2002[in] FILTERING_TYPE requestedFilteringType);"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"IsyncFilter",{"@attributes":{"id":"p-0301","num":"0300"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003\u2003\u2002\/\/"]},{"entry":[{},"\u2003\u2003\u2003\u2002\/\/ IsyncFilter is implemented by 3rd parties"]},{"entry":[{},"\u2003\u2003\u2003\u2002\/\/ Typically providers and filters are written together"]},{"entry":[{},"\u2003\u2003\u2003\u2002\/\/"]},{"entry":[{},"\u2003\u2003\u2003\u2002interface IsyncFilter : Iunknown"]},{"entry":[{},"\u2003\u2003\u2003\u2002{"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2002\/\/"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2002\/\/ Checks whether two synchronization filters evaluate"]},{"entry":[{},"membership identically"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2002\/\/"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2002HRESULT IsIdentical("]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2002[in] IsyncFilter *pISyncFilter);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2002HRESULT Serialize("]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2002[in, out, unique, size_is(*pcbSyncFilter)] BYTE *"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2002pbSyncFilter, [in, out] DWORD * pcbSyncFilter);"]},{"entry":[{},"\u2003\u2003\u2003\u2002}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"IsyncFilterDeserializer",{"@attributes":{"id":"p-0303","num":"0302"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/"]},{"entry":[{},"\/\/ IsyncFilterDeseriazlier is implemented by 3rd parties."]},{"entry":[{},"\/\/ It is implemented together with IsyncFilter"]},{"entry":[{},"\/\/ Only when the filtering scenario involves serialization and"]},{"entry":[{},"\/\/ deserialization of synchronization filter this interface needs"]},{"entry":[{},"\/\/ to be implemented"]},{"entry":[{},"interface IsyncFilterDeserializer : Iunknown"]},{"entry":[{},"{"]},{"entry":[{},"\u2003HRESULT DeserializeSyncFilter("]},{"entry":[{},"\u2003\u2003[in, size_is(dwCbSyncFilter)] const BYTE * pbSyncFilter,"]},{"entry":[{},"\u2003\u2003[in] DWORD dwCbSyncFilter,"]},{"entry":[{},"\u2003\u2003[out] IsyncFilter ** ppISyncFilter);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"IFilterTrackingProvider",{"@attributes":{"id":"p-0305","num":"0304"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/"]},{"entry":[{},"\/\/ IFilterTrackingProvider is implemented by 3rd parties."]},{"entry":[{},"\/\/ All providers that track filters implement it"]},{"entry":[{},"\/\/"]},{"entry":[{},"interface IFilterTrackingProvider : Iunknown"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\/\/"]},{"entry":[{},"\u2003\/\/ Called by synchronization framework at the beginning of"]},{"entry":[{},"\u2003\/\/ synchronization session on the destination provider"]},{"entry":[{},"\u2003\/\/"]},{"entry":[{},"\u2003HRESULT SpecifyTrackedFilters("]},{"entry":[{},"\u2003\u2003[in] IfilterTrackingRequestCallback * pCallback);"]},{"entry":[{},"\u2003\/\/"]},{"entry":[{},"\u2003\/\/ Called by synchronization framework on the source provider to"]},{"entry":[{},"\u2003\/\/ add destinations tracked filters"]},{"entry":[{},"\u2003\/\/"]},{"entry":[{},"\u2003HRESULT AddTrackedFilter("]},{"entry":[{},"\u2003\u2003[in] IsyncFilter * pSyncFilter);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"IfilterTrackingSynchronousNotifyingChangeApplierTarget Providers that track filters can implement this interface.",{"@attributes":{"id":"p-0307","num":"0306"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\/\/ IfilterTrackingSynchronousNotifyingChangeApplierTarget is"},{"entry":"\u2003\u2003\u2003\/\/ implemented by providers that track filters. This will be"},{"entry":"\u2003\u2003\u2003\/\/ called both during full and filtered synchronization"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003interface"},{"entry":"IfilterTrackingSynchronousNotifyingChangeApplierTarget : Iunknown"},{"entry":"{"},{"entry":"\u2003\/\/"},{"entry":"\u2003\/\/ Get the filter key map of the provider"},{"entry":"\u2003\/\/"},{"entry":"\u2003HRESULT GetFilterKeyMap("},{"entry":"\u2003\u2003[out] IfilterKeyMap * pIFilterKayMap);"},{"entry":"\u2003\/\/"},{"entry":"\u2003\/\/ Get filter forgotten knowledge. Return null to indicate filter forgotten"},{"entry":"\u2003\/\/ knowledge is same as forgotten knowledge"},{"entry":"\u2003\/\/"},{"entry":"\u2003HRESULT GetFilterForgottenKnowledge("}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2003\u2003[in] DWORD","dwFilterIndex,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003[out] IforgottenKnowledge * pIForgottenKnowledge);"},{"entry":"\u2003\/\/"},{"entry":"\u2003\/\/ Save knowledge, forgotten knowledge, and filter forgotten"},{"entry":"\u2003\/\/ knowledges"},{"entry":"\u2003HRESULT SaveKnowledgeWithFilterForgottenKnowledges("}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003[in] IsyncKnowledge","* pSyncKnowledge,"]},{"entry":["\u2003\u2003[in] DWORD","dwFilterCount,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003[in] IforgottenKnowledge ** ppFilterForgottenKnowledges);"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"IfilteredReplicaSynchronousNotifyingChangeApplierTarget",{"@attributes":{"id":"p-0309","num":"0308"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/"]},{"entry":[{},"\/\/ IfilteredReplicaNotifyingChangeApplierTarget is implemented by"]},{"entry":[{},"\/\/ filtered replica synchronization providers. Change applier"]},{"entry":[{},"\/\/ Qies for it from IsynchronousNotifyingChangeApplierTarget"]},{"entry":[{},"\/\/ during ApplyChanges when applying changes."]},{"entry":[{},"\/\/"]},{"entry":[{},"\/\/ Change applier uses it for two purposes:"]},{"entry":[{},"\/\/ \u20031) Calculate correct learned knowledge by"]},{"entry":[{},"\/\/ \u2003excluding any items that have newly moved in"]},{"entry":[{},"\/\/ \u2003that source does not know about"]},{"entry":[{},"\/\/ 2) If change batch is not filtered to determine"]},{"entry":[{},"\/\/ \u2003which changes are in the filter"]},{"entry":[{},"\u2003\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003\u2003interface IfilteredReplicaNotifyingChangeApplierTarget :"]},{"entry":[{},"IfilterTrackingSynchronousNotifyingChangeApplierTarget"]},{"entry":[{},"\u2003\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003HRESULT GetNewMoveins("]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003[in] IsyncKnowledge\u2003\u2009* pBaseKnowledge,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003[out] IenumSyncChanges\u2002** pEnumSyncChanges);"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The following are exemplary interfaces implemented by the synchronization framework.","IfilterRequestCallback",{"@attributes":{"id":"p-0312","num":"0311"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/"},{"entry":"\/\/ IfilterRequestCallback2 is implemented by synchronization framework"},{"entry":"\/\/ It is given to the destination provider to request a filter"},{"entry":"\/\/ during filter nogotiation"},{"entry":"\/\/"},{"entry":"interface IfilterRequestCallback : Iunknown"},{"entry":"{"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\/\/ Used by destination provider to do filter negotiation"},{"entry":"\u2003\u2002\/\/"},{"entry":"\u2003\u2002HRESULT RequestFilter("},{"entry":"\u2003\u2003\u2002[in] Iunknown\u2003\u2003\u2003\u2003\u2002\u2009* pFilter,"},{"entry":"\u2003\u2003\u2003\u2003[in] FILTERING_TYPE\u2003\u2002requestedFilteringType);"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"IcustomFilterInfo",{"@attributes":{"id":"p-0314","num":"0313"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/"]},{"entry":[{},"\/\/ IcustomFilterInfo is implemented by synchronization framework"]},{"entry":[{},"\/\/"]},{"entry":[{},"interface IcustomFilterInfo : IsyncFilterInfo"]},{"entry":[{},"{"]},{"entry":[{},"\u2003HRESULT GetSyncFilter("]},{"entry":[{},"\u2003\u2003[out] IsyncFilter ** pISyncFilter);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"IcombinedFilterInfo",{"@attributes":{"id":"p-0316","num":"0315"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/"},{"entry":"\/\/ IcombinedFilterInfo is implemented by synchronization framework"},{"entry":"\/\/"},{"entry":"interface IcombinedFilterInfo : IsyncFilterInfo"},{"entry":"{"},{"entry":"\u2003HRESULT GetFilterCount("},{"entry":"\u2003\u2003[out] DWORD \u2003*pdwFilterCount);"},{"entry":"\u2003HRESULT GetFilterInfo("},{"entry":"\u2003\u2003[in] DWORD \u2003\u2003\u2003\u2003\u2003dwFilterIndex,"},{"entry":"\u2003\u2003[out] IsyncFilterInfo \u2002** ppIFilterInfo);"},{"entry":"\u2003HRESULT GetFilterCombinationType("},{"entry":"\u2003\u2003[out] FILTER_COMBINATION_TYPE \u2003*"},{"entry":"\u2003\u2003pFilterCombinationType);"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"IproviderCustomFilteredSyncServices",{"@attributes":{"id":"p-0318","num":"0317"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/"},{"entry":"\/\/ IproviderCustomFilteredSyncServices is implemented by sync"},{"entry":"framework"},{"entry":"\/\/"},{"entry":"interface IproviderCustomFilteredSyncServices : Iunknown"},{"entry":"{"},{"entry":"\u2003\/\/"},{"entry":"\u2003\/\/ Create a custom filter info"},{"entry":"\u2003\/\/"},{"entry":"\u2003HRESULT CreateCustomFilterInfo("},{"entry":"\u2003\u2003[in] IsyncFilter \u2003\u2003* pSyncFilter,"},{"entry":"\u2003\u2003[out] IcustomFilterInfo ** ppCustomFilterInfo);"},{"entry":"\u2003\/\/"},{"entry":"\u2003\/\/ Creates a filter combination"},{"entry":"\u2003\/\/ For V2, following combinations can be utilized:"},{"entry":"\u2003\/\/ \u2003\u2003Custom filter intersected with a column filter"},{"entry":"\u2003\/\/"},{"entry":"\u2003HRESULT CreateCombinedFilterInfo("},{"entry":"\u2003\u2003[in] IsyncFilterInfo2 \u2003\u2003* pFilterInfo1,"},{"entry":"\u2003\u2003[in] IsyncFilterInfo2 \u2003\u2003* pFilterInfo2,"},{"entry":"\u2003\u2003[in] FILTER_COMBINATION_TYPE \u2002filterCombinationType,"},{"entry":"\u2003\u2003[out] IcombinedFilterInfo \u2003** ppCombinedFilterInfo);"},{"entry":"\u2003\/\/"},{"entry":"\u2003\/\/ Creates a filter map. A filter map is an index (DWORD) to"},{"entry":"\u2003\/\/ filter info (i.e. IsyncFilterInfo) map. A replica that"},{"entry":"\u2003\/\/ tracks filters will have a filter map"},{"entry":"\u2003\/\/"},{"entry":"\u2003HRESULT CreateFilterKeyMap("},{"entry":"\u2003\u2003[out] IfilterKeyMap ** ppIFilterKeyMap);"},{"entry":"\u2003\/\/"},{"entry":"\u2003\/\/ Deserialize a filter key map"},{"entry":"\u2003\/\/"},{"entry":"\u2003HRESULT DeserializeFilterKeyMap("},{"entry":"\u2003\u2003[in] IsyncFilterDeserializer * pISyncFilterDeserializer,"},{"entry":"\u2003\u2003[in, size_is(dwCbFilterKeyMap)] const BYTE * pbFilterKeyMap,"},{"entry":"\u2003\u2003[in] DWORD dwCbFilterKeyMap,"},{"entry":"\u2003\u2003[out] IfilterKeyMap ** ppFilterKeyMap);"},{"entry":"\u2003\/\/"},{"entry":"\u2003\/\/ Deserialize a change batch with filter key map"},{"entry":"\u2003\/\/"},{"entry":"\u2003HRESULT DeserializeChangeBatchWithFilterKeyMap("},{"entry":"\u2003\u2003[in] IsyncFilterDeserializer * pISyncFilterDeserializer,"},{"entry":"\u2003\u2003[in, size_is(cbChangeBatch)] const BYTE * pbChangeBatch,"},{"entry":"\u2003\u2003[in] DWORD cbChangeBatch,"},{"entry":"\u2003\u2003[out] IsyncChangeBatch ** ppChangeBatch);"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"IfilterKeyMap","Filter key map is a map of DWORD filter index to the filter (e.g. IsyncFilterInfo).",{"@attributes":{"id":"p-0321","num":"0320"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/"]},{"entry":[{},"\/\/ IfilterKeyMap is implemented by synchronization framework"]},{"entry":[{},"\/\/ A filter map is a set of filter indexes and filter information"]},{"entry":[{},"\/\/"]},{"entry":[{},"interface IfilterKeyMap : Iunknown"]},{"entry":[{},"{"]},{"entry":[{},"\u2003HRESULT GetCount("]},{"entry":[{},"\u2003\u2003[out] DWORD * pdwCount);"]},{"entry":[{},"\u2003\/\/"]},{"entry":[{},"\u2003\/\/ Adds a filter info to the filter key map"]},{"entry":[{},"\u2003\/\/"]},{"entry":[{},"\u2003HRESULT AddFilter("]},{"entry":[{},"\u2003\u2003[in] IsyncFilter \u2002* pISyncFilter,"]},{"entry":[{},"\u2003\u2003[out] DWORD \u2003\u2003* pdwFilterKey);"]},{"entry":[{},"\u2003\/\/"]},{"entry":[{},"\u2003\/\/ Gets the filter info at the specified key"]},{"entry":[{},"\u2003\/\/"]},{"entry":[{},"\u2003HRESULT GetFilter("]},{"entry":[{},"\u2003\u2003[in] DWORD \u2003\u2003\u2003\u2003dwFilterKey,"]},{"entry":[{},"\u2003\u2003[out] IsyncFilter ** ppISyncFilter);"]},{"entry":[{},"\u2003\/\/"]},{"entry":[{},"\u2003\/\/ Serializing a filter map does not serialize the rules"]},{"entry":[{},"\u2003\/\/"]},{"entry":[{},"\u2003HRESULT Serialize("]},{"entry":[{},"\u2003\u2003[in, out, unique, size_is(*pcbFilterKeyMap)] BYTE *"]},{"entry":[{},"\u2003\u2003pbFilterKeyMap,"]},{"entry":[{},"\u2003\u2003[in, out] DWORD * pcbFilterKeyMap);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"IsyncChangeBatchWithFilterKeyMap","IsyncChangeBatchWithFilterKeyMap can be Qied from all sync change batch interface (i.e. IsyncChangeBatchBase, IsyncChangeBatc, IfilteredChangeBatch, IfullEnumerationChangeBatch).",{"@attributes":{"id":"p-0324","num":"0323"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\/\/"},{"entry":"\u2003\u2003\/\/ IsyncChangeBatchWithFilterKeyMap is implemented by"},{"entry":"synchronization framework"},{"entry":"\u2003\u2003\/\/ It is used to set or get a filter key map from a change batch"},{"entry":"\u2003\u2003\/\/"},{"entry":"\u2003\u2003interface IsyncChangeBatchWithFilterKeyMap : Iunknown"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003HRESULT GetFilterKeyMap("},{"entry":"\u2003\u2003\u2003\u2003[out] IfilterKeyMap ** ppIFilterKeyMap);"},{"entry":"\u2003\u2003\u2003HRESULT SetFilterKeyMap("},{"entry":"\u2003\u2003\u2003\u2003[in] IfilterKeyMap * pIFilterKeyMap);"},{"entry":"\u2003\u2003\u2003HRESULT SetFilterForgottenKnowledge("},{"entry":"\u2003\u2003\u2003\u2003[in] DWORD \u2003\u2003\u2003\u2003\u2003dwFilterKey,"},{"entry":"\u2003\u2003\u2003\u2003[in] IforgottenKnowledge * pIFilterForgottenKnowledge);"},{"entry":"\u2003\u2003\u2003HRESULT GetFilterForgottenKnowledge("},{"entry":"\u2003\u2003\u2003\u2003[in] DWORD \u2003\u2003\u2003\u2003\u2003dwFilterKey,"},{"entry":"\u2003\u2003\u2003\u2003[out] IforgottenKnowledge ** ppIFilterForgottenKnowledge);"},{"entry":"\u2003\u2003\u2003HRESULT GetLearnedFilterForgottenKnowledge("},{"entry":"\u2003\u2003\u2003\u2003[in] DWORD \u2003\u2003\u2003\u2003\u2003dwFilterKey,"},{"entry":"\u2003\u2003\u2003\u2003[out] IforgottenKnowledge ** ppIFilterForgottenKnowledge);"},{"entry":"\u2003\u2003\u2003HRESULT GetLearnedFilterForgottenKnowledgeWithPrerequisite("},{"entry":"\u2003\u2003\u2003\u2003[in] DWORD \u2003\u2003\u2003\u2003\u2003dwFilterKey,"},{"entry":"\u2003\u2003\u2003\u2003[in] IsyncKnowledge * pDestinationKnowledge,"},{"entry":"\u2003\u2003\u2003\u2003[out] IforgottenKnowledge ** ppIFilterForgottenKnowledge);"},{"entry":"\u2003\u2003}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"IfilterTrackingSyncChangeBuilder",{"@attributes":{"id":"p-0326","num":"0325"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003\/\/ IfilterTrackingSyncChangeBuilder is implemented by"]},{"entry":[{},"synchronization framework"]},{"entry":[{},"\u2003\u2003\/\/ It can be Qied from IsyncChangeBuilder. It is used by the"]},{"entry":[{},"\u2003\u2003\/\/ source and destination providers to add filter change info"]},{"entry":[{},"\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003interface IfilterTrackingSyncChangeBuilder : Iunknown"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003HRESULT AddFilterChangeInfo("]},{"entry":[{},"\u2003\u2003\u2003\u2003[in] const DWORD \u2003\u2003\u2003\u2003\u2003\u2003\u2003dwFilterChangeIndex,"]},{"entry":[{},"\u2003\u2003\u2003\u2003[in] const SYNC_FILTER_CHANGE_INFO *"]},{"entry":[{},"\u2003\u2003\u2003\u2003pFilterChangeInfo);"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"IfilterTrackingSaveChangeContext",{"@attributes":{"id":"p-0328","num":"0327"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\/\/"},{"entry":"\u2003\u2003\/\/ IfilterTrackingSaveChangeContext is implemented by the"},{"entry":"synchronization framework"},{"entry":"\u2003\u2003\/\/ It can Qied from IsyncChangeContext or"},{"entry":"IsyncChangeContextWithChangeUnits"},{"entry":"\u2003\u2003\/\/ Filter tracking destinations can call this to update filter tracking"},{"entry":"\u2003\u2003information"},{"entry":"\u2003\u2003\/\/"},{"entry":"\u2003\u2003interface IfilterTrackingSaveChangeContext : Iunknown"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003\/\/ Destination provider uses this method to update"},{"entry":"\u2003\u2003\u2003\u2003\/\/ the filter changes for its tracked filters"},{"entry":"\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003\/\/ Return values:"},{"entry":"\u2003\u2003\u2003\u2003\/\/ S_OK - updated filter change is returned"},{"entry":"\u2003\u2003\u2003\u2003\/\/ S_FALSE - no update is required for filter change"},{"entry":"\u2003\u2003\u2003\u2003\/\/ Other - errors"},{"entry":"\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003HRESULT GetFilterChange("},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003[in] DWORD \u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003dwFilterIndex,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003[out] SYNC_FILTER_CHANGE_INFO"},{"entry":"*pSyncFilterChangeInfos);"},{"entry":"\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003\/\/ Returns the updated filter forgotten knowledge for a filter"},{"entry":"\u2003\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003HRESULT GetUpdatedFilterForgottenKnowledge("},{"entry":"\u2003\u2003\u2003\u2003\u2003[in] DWORD \u2003\u2003\u2003\u2003\u2003\u2003\u2003dwFilterIndex,"},{"entry":"\u2003\u2003\u2003\u2002[out] IforgottenKnowledge ** ppFilterForgottenKnowledge);"},{"entry":"\u2003\u2003}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"IsyncKnowledge2",{"@attributes":{"id":"p-0330","num":"0329"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"interface IsyncKnowledge3 : IsyncKnowledge"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003\/\/ Returns a knowledge which is a complement of the other"]},{"entry":[{},"\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003\/\/ \u2003\u2003A10B15.Complement(A5B18) \u2192 A10"]},{"entry":[{},"\u2003\u2003\/\/ A10B15C12D18.Complement(A5B18C5D20) \u2192 A10C12"]},{"entry":[{},"\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003HRESULT Complement("]},{"entry":[{},"\u2003\u2003\u2003\u2003[in] IsyncKnowledge * pISyncKnowledge,"]},{"entry":[{},"\u2003\u2003\u2003\u2003[out] IsyncKnowledge * pIComplementedKnowledge);"]},{"entry":[{},"\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003\/\/ Returns S_OK if the two knowledges intersect"]},{"entry":[{},"\u2003\u2003\/\/ \u2003\u2003\u2003\u2003\u2003\u2003S_FALSE otherwise"]},{"entry":[{},"\u2003\u2003\/\/ Other HRESULTs indicate error"]},{"entry":[{},"\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003\/\/ For example:"]},{"entry":[{},"\u2003\u2003\/\/ A10B15.Intersects(B5C10) TRUE"]},{"entry":[{},"\u2003\u2003\/\/ A10B15.Intersects(C10) FALSE"]},{"entry":[{},"\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003HRESULT Intersects("]},{"entry":[{},"\u2003\u2003\u2003\u2003[in] IsyncKnowledge * pISyncKnowledge);"]},{"entry":[{},"\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003\/\/ Add an \u201call change units required\u201d marker to"]},{"entry":[{},"\u2003\u2003\/\/ knowledge"]},{"entry":[{},"\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003HRESULT AddAllChangeUnitsRequiredMarker("]},{"entry":[{},"\u2003[in] BYTE* pItemId);"]},{"entry":[{},"\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003\/\/ Add an \u201call change units present\u201d marker."]},{"entry":[{},"\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003HRESULT AddAllChangeUnitsPresentMarker("]},{"entry":[{},"\u2003[in] BYTE* pItemId);"]},{"entry":[{},"\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003\/\/ Returns"]},{"entry":[{},"\u2003\u2003\/\/ \u2003\u2003S_OK - if \u201call change units required\u201d marker"]},{"entry":[{},"\u2003\u2003\/\/ \u2003\u2003\u2003\u2003is present in knowledge."]},{"entry":[{},"\u2003\u2003\/\/ S_FALSE - if \u201call change units required\u201d marker is"]},{"entry":[{},"\u2003\u2003\/\/ \u2003\u2003\u2003\u2003\u2003not present for item"]},{"entry":[{},"\u2003\u2003\/\/ Other - on errors"]},{"entry":[{},"\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003HRESULT ContainsAllChangeUnitsRequiredMarker("]},{"entry":[{},"\u2003[in] BYTE* pItemId);"]},{"entry":[{},"\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003\/\/ Removes all markers from knowledge"]},{"entry":[{},"\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003HRESULT RemoveMarkers( );"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"IsynchronousNotifyingChangeApplier2","Change applier can QI the pChangeApplierTarget for IfilteredReplicaNotifyingChangeApplierTarget and IfilterTrackingSynchronousNotifyingChangeApplierTarget to take the correct action.",{"@attributes":{"id":"p-0333","num":"0332"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003\u2003\u2003HRESULT ApplyChanges("]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003[in] CONFLICT_RESOLUTION_POLICY"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003resolutionPolicy,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003[in] IsyncChangeBatch * pSourceChanges,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003[in] Iunknown * pUnkDataRetriever,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003[in] IenumSyncChanges * pDestinationVersions,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003[in] IsyncKnowledge * pDestinationKnowledge,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003[in] IforgottenKnowledge *"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003pDestinationForgottenKnowledge,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003[in] IsynchronousNotifyingChangeApplierTarget *"]},{"entry":[{},"pChangeApplierTarget,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003[in] IsyncSessionState * pSessionState,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003[in] IsyncCallback * pCallback,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003[in] IfilterEvaluationCallback"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003*pIFilterEvaluationCallback);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"IfilteredREplicaChangeApplicationHelper",{"@attributes":{"id":"p-0335","num":"0334"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\/\/"},{"entry":"\u2003\u2003\/\/ Implemented by synchronization framework."},{"entry":"\u2003\u2003\/\/ Only providers that do not use change applier need to use this"},{"entry":"\u2003\u2003interface"},{"entry":"\u2003\u2003\/\/"},{"entry":"\u2003\u2003interface IfilteredReplicaChangeApplicationHelper : Iunknown"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003HRESULT GetLearnedKnowledge("},{"entry":"\u2003\u2003\u2003\u2003[out] IsyncKnowledge ** ppLearnedKnowledge);"},{"entry":"\u2003\u2003\u2003HRESULT GetLearnedKnowledgeWithPrerequisite("},{"entry":"\u2003\u2003\u2003\u2003[in] IsyncKnowledge * pDestinationKnowledge,"},{"entry":"\u2003\u2003\u2003\u2003[out] IsyncKnowledge **"},{"entry":"\u2003\u2003\u2003\u2003ppLearnedWithPrerequisiteKnowledge);"},{"entry":"\u2003\u2003\u2003HRESULT GetLearnedForgottenKnowledge("},{"entry":"\u2003\u2003\u2003\u2003[out] IforgottenKnowledge ** ppLearnedForgottenKnowledge);"},{"entry":"\u2003\u2003\u2003HRESULT GetLearnedForgottenKnowledgeWithPrerequisite("},{"entry":"\u2003\u2003\u2003\u2003[in] IsyncKnowledge * pDestinationKnowledge,"},{"entry":"\u2003\u2003\u2003\u2003[out] IforgottenKnowledge **"},{"entry":"ppLearnedForgottenKnowledgeWithPrerequisite);"},{"entry":"\u2003\u2003}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Conflict types, and conflict resolution types can also be provided.","Some enums and flags for managed APIs can include the following","ChangeKind","A ChangeKind value Ghost can be implemented, e.g., used when enumerating a ghost (such as a version only change).",{"@attributes":{"id":"p-0340","num":"0339"},"tables":{"@attributes":{"id":"TABLE-US-00027","num":"00027"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Public enum ChangeKind"]},{"entry":[{},"{"]},{"entry":[{},"\u2003Update = 0,"]},{"entry":[{},"\u2003Deleted = 1,"]},{"entry":[{},"\u2003UnknownItem = 2,"]},{"entry":[{},"\u2003Ghost = 3"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"FilteringType",{"@attributes":{"id":"p-0342","num":"0341"},"tables":{"@attributes":{"id":"TABLE-US-00028","num":"00028"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public enum FilteringType"},{"entry":"\u2003{"},{"entry":"\u2003\u2003\/\/"},{"entry":"\u2003\u2003\/\/ Only send data and metadata for items that are"},{"entry":"\u2003\u2003\/\/ currently in the filter at the source"},{"entry":"\u2003\u2003\/\/"},{"entry":"\u2003\u2003CurrentItemsOnly,"},{"entry":"\u2003\u2003\/\/"},{"entry":"\u2003\u2003\/\/ Only send data for items that are in the filter at the source"},{"entry":"\u2003\u2003\/\/ Send metadata (i.e. versions) for all items that had been in the filter"},{"entry":"\u2003\u2003\/\/"},{"entry":"\u2003\u2003CurrentItemsAndVersionsForMovedOutItems"},{"entry":"\u2003}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"SaveChangeAction",{"@attributes":{"id":"p-0344","num":"0343"},"tables":{"@attributes":{"id":"TABLE-US-00029","num":"00029"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003public enum SaveChangeAction"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003Create = CoreInterop.SYNC_SAVE_ACTION."]},{"entry":[{},"\u2003\u2003\u2003\u2003SSA_CREATE,"]},{"entry":[{},"\u2003\u2003\u2003\u2003UpdateVersionOnly ="]},{"entry":[{},"CoreInterop.SYNC_SAVE_ACTION."]},{"entry":[{},"SSA_UPDATE_VERSION_ONLY,"]},{"entry":[{},"\u2003\u2003\u2003\u2003UpdateVersionAndData ="]},{"entry":[{},"CoreInterop.SYNC_SAVE_ACTION."]},{"entry":[{},"SSA_UPDATE_VERSION_AND_DATA,"]},{"entry":[{},"\u2003\u2003\u2003\u2003UpdateVersionAndMergeData ="]},{"entry":[{},"CoreInterop.SYNC_SAVE_ACTION."]},{"entry":[{},"SSA_UPDATE_VERSION_AND_MERGE_DATA,"]},{"entry":[{},"\u2003\u2003\u2003\u2003DeleteAndStoreTombstone ="]},{"entry":[{},"CoreInterop.SYNC_SAVE_ACTION."]},{"entry":[{},"SSA_DELETE_AND_STORE_TOMBSTONE,"]},{"entry":[{},"\u2003\u2003\u2003\u2003DeleteAndRemoveTombstone ="]},{"entry":[{},"CoreInterop.SYNC_SAVE_ACTION."]},{"entry":[{},"SSA_DELETE_AND_REMOVE_TOMBSTONE,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003\u2003\u2003\/\/ Create a ghost item."]},{"entry":[{},"\u2003\u2003\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003\u2003\u2003CreateGhost ="]},{"entry":[{},"CoreInterop.SYNC_SAVE_ACTION.SSA_CREATE_GHOST,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003\u2003\u2003\/\/ Change live item to a ghost."]},{"entry":[{},"\u2003\u2003\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003\u2003\u2003GhostItem = CoreInterop.SYNC_SAVE_ACTION."]},{"entry":[{},"\u2003\u2003\u2003\u2003SSA_GHOST_ITEM,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003\u2003\u2003\/\/ Change a ghost to a live item."]},{"entry":[{},"\u2003\u2003\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003\u2003\u2003UnghostItem ="]},{"entry":[{},"CoreInterop.SYNC_SAVE_ACTION.SSA_UNGHOST_ITEM,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003\u2003\u2003\/\/ Update version for ghost"]},{"entry":[{},"\u2003\u2003\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003\u2003\u2003UpdateGhost ="]},{"entry":[{},"CoreInterop.SYNC_SAVE_ACTION.SSA_UPDATE_GHOST,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003\u2003\u2003\/\/ Change a ghost to a tombstone"]},{"entry":[{},"\u2003\u2003\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003\u2003\u2003DeleteGhost ="]},{"entry":[{},"CoreInterop.SYNC_SAVE_ACTION.SSA_DELETE_GHOST"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"FilterCombinationType","Filter combination type can be used to combine two filters. When custom filters and column filters are used in the same scenario, one creates a filter combination.",{"@attributes":{"id":"p-0347","num":"0346"},"tables":{"@attributes":{"id":"TABLE-US-00030","num":"00030"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Public enum FilterCombinationType"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003\/\/ Compose a filter that is an intersection of two filters"]},{"entry":[{},"\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003Intersection"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The following are some interfaces that can be implemented by providers.","IrequestFilteredSync","Providers that request filtered synchronization can implement this interface.",{"@attributes":{"id":"p-0351","num":"0350"},"tables":{"@attributes":{"id":"TABLE-US-00031","num":"00031"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Public interface IrequestFilteredSync"]},{"entry":[{},"{"]},{"entry":[{},"\u2003void SpecifyFilter(FilterRequestCallback filterRequest);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"IsupportFilteredSync","Providers that support do filtered synchronization (e.g., can do filtered change enumeration) can implement this interface.",{"@attributes":{"id":"p-0354","num":"0353"},"tables":{"@attributes":{"id":"TABLE-US-00032","num":"00032"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Public interface IrequestFilteredSync"]},{"entry":[{},"{"]},{"entry":[{},"\u2003void SpecifyFilter(FilterRequestCallback filterRequest);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"IFilterTrackingProvider","Providers that track filters (including filtered replica providers) can implement this interface.",{"@attributes":{"id":"p-0357","num":"0356"},"tables":{"@attributes":{"id":"TABLE-US-00033","num":"00033"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Public interface IFilterTrackingProvider"},{"entry":"{"},{"entry":"\u2003\/\/"},{"entry":"\u2003\/\/ Called on the destination provider for it to specify the"},{"entry":"\u2003\/\/ filters it tracks"},{"entry":"\u2003\/\/"},{"entry":"\u2003void SpecifyTrackedFilters("},{"entry":"\u2003\u2003\u2003FilterTrackingRequestCallback filterTrackingRequestCallback);"},{"entry":"\u2003\/\/"},{"entry":"\u2003\/\/ Called on the source provider to add tracked filter"},{"entry":"\u2003\/\/"},{"entry":"\u2003bool AddTrackedFilter("},{"entry":"\u2003\u2003\u2003object filter);"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"IsyncFilter","Custom filter writers can implement the IsyncFilter interface.",{"@attributes":{"id":"p-0360","num":"0359"},"tables":{"@attributes":{"id":"TABLE-US-00034","num":"00034"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Public interface IsyncFilter"]},{"entry":[{},"{"]},{"entry":[{},"\u2003bool IsIdentical(IsyncFilter otherFilter);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"IfilterTrackingNotifyingChangeApplierTarget","Providers that track filters can implement this interface and pass it to the change applier in the ApplyChanges call.",{"@attributes":{"id":"p-0363","num":"0362"},"tables":{"@attributes":{"id":"TABLE-US-00035","num":"00035"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Public interface IfilterTrackingNotifyingChangeApplierTarget"},{"entry":"{"},{"entry":"\u2003FilterKeyMap FilterKeyMap"},{"entry":"\u2003{"},{"entry":"\u2003\u2003get;"},{"entry":"\u2003}"},{"entry":"\u2003ForgottenKnowledge GetFilterForgottenKnowledge(uint filterIndex);"},{"entry":"\u2003void SaveKnowledgeWithFilterForgottenKnowledges("},{"entry":"\u2003\u2003SyncKnowledge \u2003syncKnowledge,"},{"entry":"\u2003\u2003ForgottenKnowledge forgottenKnowledge,"},{"entry":"\u2003\u2003ForgottenKnowledge[ ] filterForgottenKnowledge);"},{"entry":"\u2003bool IsInFilter("},{"entry":"\u2003\u2003uint filterIndex,"},{"entry":"\u2003\u2003ItemChange itemChange,"},{"entry":"\u2003\u2003object changeData);"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"IfilteredReplicaNotifyingChangeApplierTarget","Filtered replica providers can implement this interface and pass it to the change applier in the ApplyChanges call.",{"@attributes":{"id":"p-0366","num":"0365"},"tables":{"@attributes":{"id":"TABLE-US-00036","num":"00036"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003Public interface IfilteredReplicaNotifyingChangeApplierTarget :"]},{"entry":[{},"IfilterTrackingNotifyingChangeApplierTarget"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003Ienumerator<SyncId> GetNewMoveins(SyncKnowledge"]},{"entry":[{},"\u2003\u2003\u2003baseKnowledge);"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The following are exemplary classes that can be implemented by the synchronization framework.","CustomFilterInfo",{"@attributes":{"id":"p-0369","num":"0368"},"tables":{"@attributes":{"id":"TABLE-US-00037","num":"00037"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public class CustomFilterInfo : FilterInfo, Iserializable"]},{"entry":[{},"{"]},{"entry":[{},"\u2003public CustomFilterInfo("]},{"entry":[{},"\u2003\u2003SyncIdFormatGroup idFormats,"]},{"entry":[{},"\u2003\u2003IsyncFilter syncFilter);"]},{"entry":[{},"\u2003protected CustomFilterInfo("]},{"entry":[{},"\u2003\u2003SerializationInfo info, StreamingContext context);"]},{"entry":[{},"\u2003public virtual void GetObjectData("]},{"entry":[{},"\u2003\u2003SerializationInfo info, StreamingContext context);"]},{"entry":[{},"\u2003public IsyncFilter Filter"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003Get;"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003public static CustomFilterInfo Deserialize(byte[ ] data);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"CombinedFilterInfo",{"@attributes":{"id":"p-0371","num":"0370"},"tables":{"@attributes":{"id":"TABLE-US-00038","num":"00038"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public class CombinedFilterInfo : FilterInfo, Iserializable"]},{"entry":[{},"{"]},{"entry":[{},"\u2003public CombinedFilterInfo("]},{"entry":[{},"\u2003\u2003FilterInfo firstFilterInfo,"]},{"entry":[{},"\u2003\u2003FilterInfo secondFilterInfo,"]},{"entry":[{},"\u2003\u2003FilterCombinationType combinationType);"]},{"entry":[{},"\u2003protected CombinedFilterInfo("]},{"entry":[{},"\u2003\u2003SerializationInfo info, StreamingContext context);"]},{"entry":[{},"\u2003public virtual void GetObjectData("]},{"entry":[{},"\u2003\u2003SerializationInfo info, StreamingContext context);"]},{"entry":[{},"\u2003public FilterCombinationType CombinationType"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003Get;"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003public FilterInfo GetFilterInfo(uint filterIndex);"]},{"entry":[{},"\u2003public static CombinedFilterInfo Deserialize(byte[ ] data);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"FilterKeyMap",{"@attributes":{"id":"p-0373","num":"0372"},"tables":{"@attributes":{"id":"TABLE-US-00039","num":"00039"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public class FilterKeyMap"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\/\/"]},{"entry":[{},"\u2003\/\/ Construct a filter key map"]},{"entry":[{},"\u2003\/\/"]},{"entry":[{},"\u2003public FilterKeyMap(SyncIdFormatGroup idFormats);"]},{"entry":[{},"\u2003\/\/"]},{"entry":[{},"\u2003\/\/ Gets the number of entries in the filter key map"]},{"entry":[{},"\u2003public int Count"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003get;"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003\/\/"]},{"entry":[{},"\u2003\/\/ Retrieve a filter at a specific index"]},{"entry":[{},"\u2003\/\/"]},{"entry":[{},"\u2003public IsyncFilter this[int filterIndex]"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003get;"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003\/\/"]},{"entry":[{},"\u2003\/\/ Adds a filter to the filter info."]},{"entry":[{},"\u2003\/\/ Return value is the index of the added filter info"]},{"entry":[{},"\u2003\/\/"]},{"entry":[{},"\u2003public int AddFilter(IsyncFilter syncFilter);"]},{"entry":[{},"\u2003public byte[ ] Serialize( );"]},{"entry":[{},"\u2003public static FilterKeyMap Deserialize(byte[ ] data);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"FilterChange","Filter change is added to ItemChange objects to include filter tracking information that is synchronized.",{"@attributes":{"id":"p-0376","num":"0375"},"tables":{"@attributes":{"id":"TABLE-US-00040","num":"00040"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003Public class FilterChange"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003\u2003\/\/ Construct a filter key map"]},{"entry":[{},"\u2003\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003\u2003public FilterChange(bool hasBeenInTheFilter, SyncVersion"]},{"entry":[{},"moveOutVersion);"]},{"entry":[{},"\u2003\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003\u2003\/\/ Returns whether the item has been in the filter recently"]},{"entry":[{},"\u2003\u2003\u2003\/\/"]},{"entry":[{},"\u2003\u2003\u2003public bool HasBeenInTheFilter"]},{"entry":[{},"\u2003\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003get;"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003public SyncVersion MoveOutVersion"]},{"entry":[{},"\u2003\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003get;"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"ItemChange","The following are the changes to the ItemChange class.",{"@attributes":{"id":"p-0379","num":"0378"},"tables":{"@attributes":{"id":"TABLE-US-00041","num":"00041"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/\/ <summary>"]},{"entry":[{},"\/\/\/ Add a filter change for filter corresponding to the filter with"]},{"entry":[{},"\/\/\/ the specified index to an ItemChange"]},{"entry":[{},"\/\/\/ <\/summary>"]},{"entry":[{},"\/\/\/ <param name=\u201dindex\u201d><\/param>"]},{"entry":[{},"\/\/\/ <param name=\u201dfilterchange\u201d><\/param>"]},{"entry":[{},"public void AddFilterChange(uint index, FilterChange filterchange);"]},{"entry":[{},"\/\/\/ <summary>"]},{"entry":[{},"\/\/\/ Get a filter change for the filter with the specified index"]},{"entry":[{},"\/\/\/ <\/summary>"]},{"entry":[{},"\/\/\/ <param name=\u201dindex\u201d><\/param>"]},{"entry":[{},"\/\/\/ <returns><\/returns>"]},{"entry":[{},"public FilterChange GetFilterChange(uint index);"]},{"entry":[{},"public bool AllChangeUnitsPresent"]},{"entry":[{},"{"]},{"entry":[{},"\u2003get;"]},{"entry":[{},"\u2003set;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"ChangeBatch","For instance, with ChangeBatch, only changes are listed.",{"@attributes":{"id":"p-0382","num":"0381"},"tables":{"@attributes":{"id":"TABLE-US-00042","num":"00042"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public class ChangeBatch"]},{"entry":[{},"{"]},{"entry":[{},"\u2003public FilterKeyMap FilterKeyMap"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003get;"]},{"entry":[{},"\u2003\u2003set;"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003public ForgottenKnowledge[ ] SourceFilterForgottenKnowledges"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003get;"]},{"entry":[{},"\u2003\u2003set;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"ChangeApplier","The following methods can be added to the NotifyingChangeApplier class.",{"@attributes":{"id":"p-0385","num":"0384"},"tables":{"@attributes":{"id":"TABLE-US-00043","num":"00043"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003Public void ApplyChanges("]},{"entry":[{},"\u2003\u2003\u2003ConflictResolutionPolicy resolutionPolicy,"]},{"entry":[{},"\u2003\u2003\u2003ChangeBatch sourceChanges,"]},{"entry":[{},"\u2003\u2003\u2003IchangeDataRetriever changeDataRetriever,"]},{"entry":[{},"\u2003\u2003\u2003Ienumerable<ItemChange> destinationVersions,"]},{"entry":[{},"\u2003\u2003\u2003SyncKnowledge destinationKnowledge,"]},{"entry":[{},"\u2003\u2003\u2003ForgottenKnowledge destinationForgottenKnowledge,"]},{"entry":[{},"\u2003\u2003\u2003InotifyingChangeApplierTarget changeApplierTarget,"]},{"entry":[{},"\u2003\u2003\u2003IfilterTrackingNotifyingChangeApplierTarget"]},{"entry":[{},"filterTrackingChangeApplierTarget,"]},{"entry":[{},"\u2003\u2003\u2003SyncSessionContext syncSessionState,"]},{"entry":[{},"\u2003\u2003\u2003SyncCallbacks syncCallback);"]},{"entry":[{},"\u2003\u2003public void ApplyChanges("]},{"entry":[{},"\u2003\u2003\u2003ConflictResolutionPolicy resolutionPolicy,"]},{"entry":[{},"\u2003\u2003\u2003ChangeBatch sourceChanges,"]},{"entry":[{},"\u2003\u2003\u2003IchangeDataRetriever changeDataRetriever,"]},{"entry":[{},"\u2003\u2003\u2003Ienumerable<ItemChange> destinationVersions,"]},{"entry":[{},"\u2003\u2003\u2003SyncKnowledge destinationKnowledge,"]},{"entry":[{},"\u2003\u2003\u2003ForgottenKnowledge destinationForgottenKnowledge,"]},{"entry":[{},"\u2003\u2003\u2003InotifyingChangeApplierTarget changeApplierTarget,"]},{"entry":[{},"\u2003\u2003\u2003IfilteredReplicaNotifyingChangeApplierTarget"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003filteredReplicaChangeApplierTarget,"]},{"entry":[{},"\u2003\u2003\u2003SyncSessionContext syncSessionState,"]},{"entry":[{},"\u2003\u2003\u2003SyncCallbacks syncCallback);"]},{"entry":[{},"\u2003\u2003public void ApplyFullEnumerationChanges("]},{"entry":[{},"\u2003\u2003\u2003ConflictResolutionPolicy resolutionPolicy,"]},{"entry":[{},"\u2003\u2003\u2003FullEnumerationChangeBatch sourceChanges,"]},{"entry":[{},"\u2003\u2003\u2003IchangeDataRetriever changeDataRetriever,"]},{"entry":[{},"\u2003\u2003\u2003Ienumerable<ItemChange> destinationVersions,"]},{"entry":[{},"\u2003\u2003\u2003SyncKnowledge destinationKnowledge,"]},{"entry":[{},"\u2003\u2003\u2003ForgottenKnowledge destinationForgottenKnowledge,"]},{"entry":[{},"\u2003\u2003\u2003InotifyingChangeApplierTarget changeApplierTarget,"]},{"entry":[{},"\u2003\u2003\u2003IfilterTrackingNotifyingChangeApplierTarget"]},{"entry":[{},"\u2003\u2003\u2003\u2003filterTrackingChangeApplierTarget,"]},{"entry":[{},"\u2003\u2003\u2003SyncSessionContext syncSessionState,"]},{"entry":[{},"\u2003\u2003\u2003SyncCallbacks syncCallback);"]},{"entry":[{},"\u2003\u2003public void ApplyFullEnumerationChanges("]},{"entry":[{},"\u2003\u2003\u2003ConflictResolutionPolicy resolutionPolicy,"]},{"entry":[{},"\u2003\u2003\u2003FullEnumerationChangeBatch sourceChanges,"]},{"entry":[{},"\u2003\u2003\u2003IchangeDataRetriever changeDataRetriever,"]},{"entry":[{},"\u2003\u2003\u2003Ienumerable<ItemChange> destinationVersions,"]},{"entry":[{},"\u2003\u2003\u2003SyncKnowledge destinationKnowledge,"]},{"entry":[{},"\u2003\u2003\u2003ForgottenKnowledge destinationForgottenKnowledge,"]},{"entry":[{},"\u2003\u2003\u2003InotifyingChangeApplierTarget changeApplierTarget,"]},{"entry":[{},"\u2003\u2003\u2003IfilteredReplicaNotifyingChangeApplierTarget"]},{"entry":[{},"\u2003\u2003\u2003\u2003filteredReplicaChangeApplierTarget,"]},{"entry":[{},"\u2003\u2003\u2003SyncSessionContext syncSessionState,"]},{"entry":[{},"\u2003\u2003\u2003SyncCallbacks syncCallback);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The following include some exemplary methods that can be added to the SyncKnowledge class.",{"@attributes":{"id":"p-0387","num":"0386"},"tables":{"@attributes":{"id":"TABLE-US-00044","num":"00044"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Public SyncKnowledge Complement(SyncKnowledge otherKnowledge);"},{"entry":"public bool Intersects(SyncKnowledge otherKnowledge);"},{"entry":"public void AddAllchangeUnitsRequiredMarker(SyncId itemId);"},{"entry":"public void AddAllChangeUnitsPresentMarker(SyncId itemId);"},{"entry":"public bool ContainsAllChangeUnitsRequiredMarker(SyncId itemId);"},{"entry":"public void RemoveMarkers( );"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"One of ordinary skill in the art can appreciate that the synchronization knowledge representation and exchange of the various embodiments can be implemented in connection with any computer or other client or server device, which can be deployed as part of a computer network, or in a distributed computing environment, connected to any kind of data store. In this regard, the various embodiments of the subject disclosure pertains to any computer system or environment having any number of memory or storage units, and any number of applications and processes occurring across any number of storage units or volumes, which may be used in connection with synchronization techniques in accordance with various embodiments. The embodiments may apply to an environment with server computers and client computers deployed in a network environment or a distributed computing environment, having remote or local storage. The various embodiments may also be applied to standalone computing devices, having programming language functionality, interpretation and execution capabilities for generating, receiving and transmitting information in connection with remote or local services and processes.","Distributed computing provides sharing of computer resources and services by exchange between computing devices and systems. These resources and services include the exchange of information, cache storage and disk storage for objects, such as files. Distributed computing takes advantage of network connectivity, allowing clients to leverage their collective power to benefit the entire enterprise. In this regard, a variety of devices may have applications, objects or resources that may implicate the systems and methods for synchronizing in an embodiment.",{"@attributes":{"id":"p-0390","num":"0389"},"figref":["FIG. 16","FIG. 16"],"b":["1610","1610","1620","1620","1620","1620","1620","1640","1610","1610","1620","1620","1620","1620","1620"],"i":["a","b","a","b","c","d","e","a","b","a","b","c","d","e"]},"It can also be appreciated that an object, such as , may be hosted on another computing device , , etc. or , , , , , etc. Thus, although the physical environment depicted may show the connected devices as computers, such illustration is merely exemplary and the physical environment may alternatively be depicted or described comprising various digital devices such as PDAs, televisions, MP3 players, etc., any of which may employ a variety of wired and wireless services, software objects such as interfaces, COM objects, and the like.","There are a variety of systems, components, and network configurations that support distributed computing environments. For example, computing systems may be connected together by wired or wireless systems, by local networks or widely distributed networks. Currently, many of the networks are coupled to the Internet, which provides an infrastructure for widely distributed computing and encompasses many different networks. Any of the infrastructures may be used for exemplary communications made incident to synchronizing according to the various embodiments.","In home networking environments, there are at least four disparate network transport media that may each support one or more protocols, such as Power line, data (both wireless and wired), voice (e.g., telephone) and entertainment media. Most home control devices such as light switches and appliances may use power lines for connectivity. Data Services may enter the home as broadband (e.g., either DSL or Cable modem) and are accessible within the home using either wireless (e.g., HomeRF or 802.14B) or wired (e.g., Home PNA, Cat 5, Ethernet, even power line) connectivity. Voice traffic may enter the home either as wired (e.g., Cat 3) or wireless (e.g., cell phones) and may be distributed within the home using Cat 3 wiring. Entertainment media, or other graphical data, may enter the home either through satellite or cable and is typically distributed in the home using coaxial cable. IEEE 1694 and DVI are also digital interconnects for clusters of media devices. All of these network environments and others that may emerge, or already have emerged, as protocol standards may be interconnected to form a network, such as an intranet, that may be connected to the outside world by way of a wide area network, such as the Internet. In short, a variety of disparate sources exist for the storage and transmission of data, and consequently, any of the computing devices may share and communicate data in any existing manner, and no one way described in the embodiments herein is intended to be limiting.","The Internet commonly refers to the collection of networks and gateways that utilize the Transmission Control Protocol\/Internet Protocol (TCP\/IP) suite of protocols, which are well-known in the art of computer networking. The Internet can be described as a system of geographically distributed remote computer networks interconnected by computers executing networking protocols that allow users to interact and share information over network(s). Because of such wide-spread information sharing, remote networks such as the Internet have thus far generally evolved into an open system with which developers can design software applications for performing specialized operations or services, essentially without restriction.","Thus, the network infrastructure enables a host of network topologies such as client\/server, peer-to-peer, or hybrid architectures. The \u201cclient\u201d is a member of a class or group that uses the services of another class or group to which it is not related. Thus, in computing, a client is a process, i.e., roughly a set of instructions or tasks, that requests a service provided by another program. The client process utilizes the requested service without having to \u201cknow\u201d any working details about the other program or the service itself. In a client\/server architecture, particularly a networked system, a client is usually a computer that accesses shared network resources provided by another computer, e.g., a server. In the illustration of , as an example, computers , , , , , etc. can be thought of as clients and computers , , etc. can be thought of as servers where servers , , etc. maintain the data that is then replicated to client computers , , , , , etc., although any computer can be considered a client, a server, or both, depending on the circumstances. Any of these computing devices may be processing data or requesting services or tasks that may implicate the synchronization techniques with knowledge in an embodiment.","A server is typically a remote computer system accessible over a remote or local network, such as the Internet or wireless network infrastructures. The client process may be active in a first computer system, and the server process may be active in a second computer system, communicating with one another over a communications medium, thus providing distributed functionality and allowing multiple clients to take advantage of the information-gathering capabilities of the server. Any software objects utilized pursuant to the techniques for synchronizing based on knowledge in an embodiment may be distributed across multiple computing devices or objects.","Client(s) and server(s) communicate with one another utilizing the functionality provided by protocol layer(s). For example, HyperText Transfer Protocol (HTTP) is a common protocol that is used in conjunction with the World Wide Web (WWW), or \u201cthe Web.\u201d Typically, a computer network address such as an Internet Protocol (IP) address or other reference such as a Universal Resource Locator (URL) can be used to identify the server or client computers to each other. The network address can be referred to as a URL address. Communication can be provided over a communications medium, e.g., client(s) and server(s) may be coupled to one another via TCP\/IP connection(s) for high-capacity communication.","Thus,  illustrates an exemplary networked or distributed environment, with server(s) in communication with client computer (s) via a network\/bus, in which the various embodiments may be employed. In more detail, a number of servers , , etc. are interconnected via a communications network\/bus , which may be a LAN, WAN, intranet, GSM network, the Internet, etc., with a number of client or remote computing devices , , , , , etc., such as a portable computer, handheld computer, thin client, networked appliance, or other device, such as a VCR, TV, oven, light, heater and the like in accordance with the various embodiments. It is thus contemplated that the various embodiments may apply to any computing device in connection with which it is desirable to synchronize any kind of data.","In a network environment in which the communications network\/bus  is the Internet, for example, the servers , , etc. can be Web servers with which the clients , , , , , etc. communicate via any of a number of known protocols such as HTTP. Servers , , etc. may also serve as clients , , , , , etc., as may be characteristic of a distributed computing environment.","As mentioned, communications may be wired or wireless, or a combination, where appropriate. Client devices , , , , , etc. may or may not communicate via communications network\/bus , and may have independent communications associated therewith. For example, in the case of a TV or VCR, there may or may not be a networked aspect to the control thereof. Each client computer , , , , , etc. and server computer , , etc. may be equipped with various application program modules or objects , , , etc. and with connections or access to various types of storage elements or objects, across which files or data streams may be stored or to which portion(s) of files or data streams may be downloaded, transmitted or migrated. Any one or more of computers , , , , , , , etc. may be responsible for the maintenance and updating of a database  or other storage element, such as a database or memory  for storing data processed or saved according to one or more embodiments. Thus, various embodiments can be utilized in a computer network environment having client computers , , , , , etc. that can access and interact with a computer network\/bus  and server computers , , etc. that may interact with client computers , , , , , etc. and other like devices, and databases .","Exemplary Computing Device","As mentioned, embodiments described herein apply to any device wherein it may be desirable to synchronize any kind of data across a set of devices. It should be understood, therefore, that handheld, portable and other computing devices and computing objects of all kinds are contemplated for use in connection with the various embodiments, i.e., anywhere that a device may benefit from sharing of data across devices or otherwise receive, process or store data. Accordingly, the below general purpose remote computer described below in  is but one example, and various embodiments may be implemented with any client having network\/bus interoperability and interaction. Thus, one or more embodiments may be implemented in an environment of networked hosted services in which very little or minimal client resources are implicated, e.g., a networked environment in which the client device serves merely as an interface to the network\/bus, such as an object placed in an appliance.","Although not required, the embodiments can partly be implemented via an operating system, for use by a developer of services for a device or object, and\/or included within application software that operates in connection with the component(s) of the various embodiments. Software may be described in the general context of computer-executable instructions, such as program modules, being executed by one or more computers, such as client workstations, servers or other devices. Those skilled in the art will appreciate that the various embodiments may be practiced with other computer system configurations and protocols.",{"@attributes":{"id":"p-0403","num":"0402"},"figref":"FIG. 17","b":["1700","1700","1700","1700"]},"With reference to , an exemplary remote device for implementing one or more embodiments includes a general purpose computing device in the form of a computer . Components of computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures.","Computer  typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer . By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CDROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media.","The system memory  may include computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM) and\/or random access memory (RAM). A basic input\/output system (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, may be stored in memory . Memory  typically also contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation, memory  may also include an operating system, application programs, other program modules, and program data.","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. For example, computer  could include a hard disk drive that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive that reads from or writes to a removable, nonvolatile magnetic disk, and\/or an optical disk drive that reads from or writes to a removable, nonvolatile optical disk, such as a CD-ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM and the like. A hard disk drive is typically connected to the system bus  through a non-removable memory interface such as an interface, and a magnetic disk drive or optical disk drive is typically connected to the system bus  by a removable memory interface, such as an interface.","A user may enter commands and information into the computer  through input devices such as a keyboard and pointing device, commonly referred to as a mouse, trackball or touch pad. Other input devices may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through user input  and associated interface(s) that are coupled to the system bus , but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A graphics subsystem may also be connected to the system bus . A monitor or other type of display device is also connected to the system bus  via an interface, such as output interface , which may in turn communicate with video memory. In addition to a monitor, computers may also include other peripheral output devices such as speakers and a printer, which may be connected through output interface .","The computer  may operate in a networked or distributed environment using logical connections to one or more other remote computers, such as remote computer , which may in turn have media capabilities different from computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, or any other remote media consumption or transmission device, and may include any or all of the elements described above relative to the computer . The logical connections depicted in  include a network , such local area network (LAN) or a wide area network (WAN), but may also include other networks\/buses. Such networking environments are commonplace in homes, offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter. When used in a WAN networking environment, the computer  typically includes a communications component, such as a modem, or other means for establishing communications over the WAN, such as the Internet. A communications component, such as a modem, which may be internal or external, may be connected to the system bus  via the user input interface of input , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in a remote memory storage device. It will be appreciated that the network connections shown and described are exemplary and other means of establishing a communications link between the computers may be used.","There are multiple ways of implementing the various embodiments, e.g., an appropriate API, tool kit, driver code, operating system, control, standalone or downloadable software object, etc. which enables applications and services to use the systems and methods for representing and exchanging knowledge in an embodiment. The various embodiments contemplate use from the standpoint of an API (or other software object), as well as from a software or hardware object that performs the knowledge exchange in an embodiment. Thus, various implementations described herein may have aspects that are wholly in hardware, partly in hardware and partly in software, as well as in software.","The word \u201cexemplary\u201d is used herein to mean serving as an example, instance, or illustration. For the avoidance of doubt, the subject matter disclosed herein is not limited by such examples. In addition, any aspect or design described herein as \u201cexemplary\u201d is not necessarily to be construed as preferred or advantageous over other aspects or designs, nor is it meant to preclude equivalent exemplary structures and techniques known to those of ordinary skill in the art. Furthermore, to the extent that the terms \u201cincludes,\u201d \u201chas,\u201d \u201ccontains,\u201d and other similar words are used in either the detailed description or the claims, for the avoidance of doubt, such terms are intended to be inclusive in a manner similar to the term \u201ccomprising\u201d as an open transition word without precluding any additional or other elements.","As mentioned above, while exemplary embodiments have been described in connection with various computing devices and network architectures, the underlying concepts may be applied to any computing device or system in which it is desirable to synchronize data with another computing device or system. For instance, the synchronization processes may be applied to the operating system of a computing device, provided as a separate object on the device, as part of another object, as a reusable control, as a downloadable object from a server, as a \u201cmiddle man\u201d between a device or object and the network, as a distributed object, as hardware, in memory, a combination of any of the foregoing, etc.","As mentioned, the various techniques described herein may be implemented in connection with hardware or software or, where appropriate, with a combination of both. As used herein, the terms \u201ccomponent,\u201d \u201csystem\u201d and the like are likewise intended to refer to a computer-related entity, either hardware, a combination of hardware and software, software, or software in execution. For example, a component may be, but is not limited to being, a process running on a processor, a processor, an object, an executable, a thread of execution, a program, and\/or a computer. By way of illustration, both an application running on computer and the computer can be a component. One or more components may reside within a process and\/or thread of execution and a component may be localized on one computer and\/or distributed between two or more computers.","Thus, the methods and apparatus of the various embodiments, or certain aspects or portions thereof, may take the form of program code (i.e., instructions) embodied in tangible media, such as floppy diskettes, CD-ROMs, hard drives, or any other machine-readable storage medium, wherein, when the program code is loaded into and executed by a machine, such as a computer, the machine becomes an apparatus for practicing one or more embodiments described herein. In the case of program code execution on programmable computers, the computing device generally includes a processor, a storage medium readable by the processor (including volatile and non-volatile memory and\/or storage elements), at least one input device, and at least one output device. One or more programs that may implement or utilize the synchronization services and\/or processes of the various embodiments, e.g., through the use of a data processing API, reusable controls, or the like, are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However, the program(s) can be implemented in assembly or machine language, if desired. In any case, the language may be a compiled or interpreted language, and combined with hardware implementations.","The methods and apparatus of the various embodiments may also be practiced via communications embodied in the form of program code that is transmitted over some transmission medium, such as over electrical wiring or cabling, through fiber optics, or via any other form of transmission, wherein, when the program code is received and loaded into and executed by a machine, such as an EPROM, a gate array, a programmable logic device (PLD), a client computer, etc., the machine becomes an apparatus for practicing one or more embodiments. When implemented on a general-purpose processor, the program code combines with the processor to provide a unique apparatus that operates to invoke the functionality of one or more embodiments. Additionally, any storage techniques used in connection with the various embodiments may invariably be a combination of hardware and software.","Furthermore, the disclosed subject matter may be implemented as a system, method, apparatus, or article of manufacture using standard programming and\/or engineering techniques to produce software, firmware, hardware, or any combination thereof to control a computer or processor based device to implement aspects detailed herein. The term \u201carticle of manufacture\u201d (or alternatively, \u201ccomputer program product\u201d) where used herein is intended to encompass a computer program accessible from any computer-readable device, carrier, or media. For example, computer readable media can include but are not limited to magnetic storage devices (e.g., hard disk, floppy disk, magnetic strips . . . ), optical disks (e.g., compact disk (CD), digital versatile disk (DVD) . . . ), smart cards, and flash memory devices (e.g., card, stick). Additionally, it is known that a carrier wave can be employed to carry computer-readable electronic data such as those used in transmitting and receiving electronic mail or in accessing a network such as the Internet or a local area network (LAN).","The aforementioned systems have been described with respect to interaction between several components. It can be appreciated that such systems and components can include those components or specified sub-components, some of the specified components or sub-components, and\/or additional components, and according to various permutations and combinations of the foregoing. Sub-components can also be implemented as components communicatively coupled to other components rather than included within parent components (hierarchical). Additionally, it can be noted that one or more components may be combined into a single component providing aggregate functionality or divided into several separate sub-components, and any one or more middle layers, such as a management layer, may be provided to communicatively couple to such sub-components in order to provide integrated functionality. Any components described herein may also interact with one or more other components not specifically described herein but generally known by those of skill in the art.","In view of the exemplary systems described supra, methodologies that may be implemented in accordance with the disclosed subject matter will be better appreciated with reference to the flowcharts of ,  and . While for purposes of simplicity of explanation, the methodologies are shown and described as a series of blocks, it is to be understood and appreciated that the claimed subject matter is not limited by the order of the blocks, as some blocks may occur in different orders and\/or concurrently with other blocks from what is depicted and described herein. Where non-sequential, or branched, flow is illustrated via flowchart, it can be appreciated that various other branches, flow paths, and orders of the blocks, may be implemented which achieve the same or a similar result. Moreover, not all illustrated blocks may be required to implement the methodologies described hereinafter.","Furthermore, as will be appreciated various portions of the disclosed systems above and methods below may include or consist of artificial intelligence or knowledge or rule based components, sub-components, processes, means, methodologies, or mechanisms (e.g., support vector machines, neural networks, expert systems, Bayesian belief networks, fuzzy logic, data fusion engines, classifiers . . . ). Such components, inter alia, can automate certain mechanisms or processes performed thereby to make portions of the systems and methods more adaptive as well as efficient and intelligent.","While the various embodiments have been described in connection with the preferred embodiments of the various figures, it is to be understood that other similar embodiments may be used or modifications and additions may be made to the described embodiment for performing the same function without deviating therefrom. For example, while exemplary network environments are described in the context of a networked environment, such as a peer to peer networked environment, one skilled in the art will recognize that the various embodiments are not limited thereto, and that the methods, as described in the present application may apply to any computing device or environment, such as a gaming console, handheld computer, portable computer, etc., whether wired or wireless, and may be applied to any number of such computing devices connected via a communications network, and interacting across the network. Furthermore, it should be emphasized that a variety of computer platforms, including handheld device operating systems and other application specific operating systems are contemplated, especially as the number of wireless networked devices continues to proliferate.","While exemplary embodiments refer to the context of particular programming language constructs, the various embodiments are not so limited, but rather may be implemented in any language to provide methods for representing and exchanging knowledge for a set of nodes in an embodiment. Still further, the various embodiments may be implemented in or across a plurality of processing chips or devices, and storage may similarly be effected across a plurality of devices. Therefore, the subject disclosure and detailed description should not be limited to any single embodiment."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The system and methods for representing synchronization knowledge for multiple nodes sharing subsets of a set of information are further described with reference to the accompanying drawings in which:",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIGS. 4","b":["5","6"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 17"}]},"DETDESC":[{},{}]}
