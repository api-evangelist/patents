---
title: System and method for supporting a remote isochronous device
abstract: A system and method are provided for supporting remote isochronous devices effectively. In one embodiment, first and second computer hosts include first and second virtual interposer logic, first and second send/receive logic and first and second at least partial device driver stacks therein. The first and second send/receive logics are configured to communicate packets between one another, representing commands and data passing between a user-level application at the first host and a peripheral device at the second host. The first and second virtual interposer logics are configured to interface the first and second send/receive logics to the first and second at least partial device driver-stacks within their respective hosts. To achieve low-latency transactions, the system includes speculative write completion functionality and/or speculative read functionality.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08578397&OS=08578397&RS=08578397
owner: Hewlett-Packard Development Company, L.P.
number: 08578397
owner_city: Houston
owner_country: US
publication_date: 20090227
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["This invention relates generally to techniques for causing peripheral devices that are attached to a first computer host to be accessible to resources that are running on a second computer host remote from the first.","Protocols exist, that enable a user at a local computer to access and share the desktop of a remote computer (e.g. a central server) over a computer network. One such protocol is the Remote Desktop Protocol (\u201cRDP\u201d), as provided by Microsoft Corporation, which provides remote display and input capabilities over network connections. Another protocol that can be used in this context is the Remote Graphics Software (\u201cRGS\u201d) protocol from the Hewlett Packard Co. RGS is designed to take advantage of the computer and graphics resources of a remote computer to deliver interactive remote access at the local computer. The desktop video data of the remote computer is transmitted over a network to the local computer, which displays the desktop video data locally in a window at the local computer. RGS captures user keyboard and mouse inputs at the local computer, and sends the keyboard and mouse inputs to the remote computer for processing by the operating system of the remote computer, and by applications running on the remote computer. RGS also allows data of some peripheral devices such as storage devices to be communicated from the local computer to the remote computer.","One general class of peripheral devices is the class of devices that can generate or receive isochronous data (an \u201cisochronous device\u201d). Isochronous data, by its nature, is intended to be continuous and real-time in its creation, delivery and consumption. Because timing-related information is implied by the steady rate at which isochronous data is received and transferred, isochronous data must be delivered at least as fast as it is generated in order for it to be used as intended. For example, when voice data is being transmitted from an isochronous device, any delays or discontinuities in the transmitted data stream can cause drop-outs or other irregularities to be noticed audibly at the receiver.",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1","b":["100","100","102","104","102","104","106","108","110","112","114","116","110","112","118","120","102","122","104","106","110","114","102","104","108","112","116","106","124","108","126","124","126","102","128","110","102","104","118","102","104","130","132","104","122","134"]},"In some embodiments, a buffer.  may be located in host . In yet other embodiments, a buffer  may be located in a host  that is distinct from hosts ,  but connected to hosts ,  in some way, such as via network .","The operating environment within hosts , ,  need not be the same. For example, either host may use a Microsoft Windows operating system or a Linux operating system or some other type of operating system. Depending on the host environment, application  may communicate with at least partial device driver stack  by means of an application programming interface (\u201cAPI\u201d) , which in turn utilizes functionality exported by kernel subsystems and input\/output (\u201cIO\u201d) manager . Optionally, host  may also include a lower device driver stack  and a means\u2014such as USB host controller \u2014for connecting to its own optional peripheral devices. Also optionally, host  may include an upper device driver stack  that is in communication with an optional application  via ah optional API  and optional kernel subsystems and IO manager . Network  may be any kind of network such as a wired or wireless local area network, an intranetwork, the Internet or any combination of these or other kinds of networks. For example, network  may be a TGP\/IP or UDP\/IP network. And at least partial device driver stacks ,  may be any kind of device driver stacks. In one embodiment, they may be upper and lower USB device driver stacks, respectively. In the vocabulary of the Microsoft Windows Driver Foundation, an example of an upper USB device driver stack would be a function driver object (\u201cFDO\u201d), and an example of a lower USB device driver stack would be a physical device object (\u201cPDO\u201d).","In order to understand how system  can be used to produce low-latency isochronous data transactions, it will be useful first to understand the time components of a high-latency  transaction.  illustrates such a high-latency  transaction . At step , application  generates an IO request (e.g. a read or a write request). At step , this IO request is processed within the upper device stack of host . For example, kernel subsystems\/IO manager  may create an IO request packet (\u201cIRP\u201d) corresponding to the request and may send the IRP to upper device stack  for processing. Virtual interposer  would then intercept the IRP and send commands and\/or data representing the IO request to host  via send\/receive logic , NIC  and network . The latter step corresponds to network send time . At me receiving end, at step , the commands and\/or data representing the IO request are further processed by the lower device stack of host . For example, virtual interposer  may access the received commands and\/or data from send\/receive logic  and may create an appropriate IO request for submission to lower device stack . If the IO request is a read request, then resulting data will need to be sent back to host  in step . Even if the IO request is a write request, typically some form of handshake or acknowledgment will be sent from host  back to host  indicating the completion of the write request. In step , this resulting data or this completion handshaking must be processed by the device stack in host . Ultimately, upper device stack  can complete the IO request by delivering resulting data up to application  or by otherwise indicating to kernel subsystems\/IO manager  that the IO request has been completed.","For isochronous data devices such as an isochronous USB device , this kind of latency can be problematic: The USB standard dictates that every transaction is to be initiated by a host controller, typically in response to an IO request generated by an application. Moreover, according to the USB standard, each segment of data that is transferred in an isochronous context must be transferred in a separate distinct transaction (e.g. an isochronous IN or OUT transaction). Consequently, an isochronous context appears as a long series of distinct USB transactions. But in the case of remote USB implementations, the initiating application in these transactions is separated from the initiating host controller by a network like network . Thus, every distinct transaction in the series would ordinarily resemble high-latency transaction .","The inventors hereof have determined, however, that it is possible to achieve low-latency IO transactions  even in a remote context. In a low-latency transaction , application  generates an IO request at step . At step , the IO request is processed by the device stack in host  as it was in step  of high-latency transaction . But immediately thereafter, in step  of the low-latency transaction, application  is notified that the IO request is complete. For a read IO transaction, this means that data, is delivered to application  in response to the read request in step . For a write IO transaction, this means that application  is told in step  that the write has been executed so that application  may then immediately begin preparing subsequent IO request.","More discussion regarding ways to achieve low-latency transactions  in a remote context will now be provided in relation to .  illustrates a low-latency write transaction  according to one preferred embodiment of the invention in which peripheral device  is a USB device. In other embodiments, device  may be a non-USB device. In step , application  may issue an isochronous write request. (Typically but not necessarily, the isochronous write request will be a non-blocking system call from the point of view of application .) In step , kernel subsystems\/IO manager  may create an IRP corresponding to the write request and may send the IRP to upper USB device stack . In step , virtual interposer  may intercept the IRP and transfer the corresponding write data to send\/receive logic . In step , immediately after the write data has been transferred safely to send\/receive logic , virtual interposer  may then indicate to upper USB device stack  that the IO request is complete, and device stack  may relay the completion status to kernel subsystems\/IO manager . Meanwhile, the activity of step  may be taking place simultaneously. That is, send\/receive logic  may begin sending the write data for the requested transaction to host  via network . But the request complete indication given in step  may occur before the data are actually transmitted to host  in step . The latter functionality may be implemented by speculative write completion logic  in virtual interposer . In this manner, kernel subsystems\/IO manager  need not hold resources (e.g. pending IRP resources) during components - of the transaction. Instead, according to embodiments of the invention, those resources may be freed much earlier in time. As a consequence, from the point of view of device , delays and discontinuities between individual write transactions in a series of isochronous write transactions may be reduced with beneficial effect.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIGS. 6-7","FIG. 5"],"b":["102","104","500","120","502","504","138","114","506","106","110","508","110","104","510","108","104","116","116","512","108","102","112","514","106","102","114","120","138"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 6","FIG. 7","FIG. 6"],"b":["600","102","104","700","602","604","126","108","116","108","102","112","602","104","102","104","606","110","102","104","128","128","128","128","120"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 7","FIG. 6"],"b":["700","702","120","704","138","114","706","106","110","708","110","128","104","710","106","114","120","138","300"]},"In another class of embodiments, a buffer  may be provided in host  either in addition to or in lieu of buffer  in host . In such embodiments, activities  may be modified as follows. In step , virtual interposer  may store the speculative read data in buffer , and only later send the data to host . In these embodiments, the sending of the data to host \u2033 may occur in response to a request from host  for data. (Step  may be modified accordingly such that the request is satisfied from the buffer  in host .) In this manner, latency associated with step  in the overall transaction may be eliminated.","In yet another class of embodiments, a buffer  may be provided in a third host . In such embodiments, activities  and  may be modified as follows. In step , virtual interposer  may send the speculative read data to buffer  in host , and host  therefore does the buffering in step . Then, in step , send\/receive logic  satisfies the actual isochronous read request from buffer  on host  by transmitting a read request to host . In these embodiments, host  need not send the actual read request to host . It is believed that this class of embodiments may be most useful in circumstances where the network connection between hosts  and  is faster than the network connection between hosts  and . Under those conditions, latency associated with step  may be eliminated as in the previous example, but also latency associated with steps  and  may be reduced from the point of view of the IO transaction being requested by host .",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 8","b":["800","100","802","100","804","104","806","100","804","102","122","808","100","804","102","122","810","808","810","102","122","122","806","810"]},"It should be noted that the logic described above need not be implemented in discrete components as illustrated. For example, any of all of virtual interposer , speculative write completion logic , send\/receive logic  and buffer  may be implemented integrally with equivalent effect. And any or all of virtual interposer , speculative read logic , send\/receive logic  and buffer  may be implemented integrally with equivalent effect. In such embodiments, the activities of and connections between any discrete components that are described in the claims, written description, and drawings hereof should instead be attributed to the integrally formed and equivalent logic component.","Except for the inventive logic described; above; the remainder of hosts , ,  may be conventional and may take any form, and hosts , ,  need not be the same. For example, either host may be a server computer, a desktop computer, a laptop computer, an embedded computer, a mobile computer or any other kind of computing\/device suitably configured in general accordance with the above description. All of the logic described, above may be implemented in hardware, software, firmware or any combination thereof. For example, any or all of the logic may take the form of instructions stored on a computer-readable storage medium which, when executed by a computer, cause the computer to perform the logic. Such a computer-readable storage medium may take any conventional form now known or yet to be developed including, for example, optical or magnetic disks, magnetic tapes, solid state static or dynamic random access memory, solid state read-only memory, flash memory or the like.","While the invention has been described in detail with reference to preferred embodiments thereof, the described embodiments have been presented by way of example and not by way of limitation. It will be understood by those skilled in the art and having reference to this specification that various changes may be made in the form and details of the described embodiments without deviating from the spirit and scope of the invention, as defined by the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
