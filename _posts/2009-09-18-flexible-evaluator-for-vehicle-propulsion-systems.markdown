---
title: Flexible evaluator for vehicle propulsion systems
abstract: A method for automatically generating a multi-component multilevel model for simulation of an automotive propulsion system and/or subsystem. The method comprises a capture component and a build component. The capture component operates to automatically parse all relevant information of an existing model and to generate one or more files indicative of the systems and subsystems of the model. The files are created such that they may be efficiently searched, manipulated, and applied for subsequent use in various user defined models created through the build component. The build component obtains the information in the one or more files and additional user defined files based on user selections to automatically create an executable model ready for analysis.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08510088&OS=08510088&RS=08510088
owner: UChicago Argonne LLC
number: 08510088
owner_city: Chicago
owner_country: US
publication_date: 20090918
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED PATENT APPLICATIONS","STATEMENT OF GOVERNMENT INTEREST","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF VARIOUS EMBODIMENTS"],"p":["The present application claims priority to U.S. Provisional Patent Application No. 61\/0101,511, filed Sep. 30, 2008, and incorporated herein by reference in its entirety.","The United States Government claims certain rights in this invention pursuant to Contract No. W-31-109-ENG-38 between the United States Government and the University of Chicago and\/or pursuant to DE-AC02-06CH11357 between the United States Government and UChicago Argonne, LLC representing Argonne National Laboratory.","The present invention relates generally to the field of systems and methods for vehicle modeling. More particularly, the present invention relates to automatic generation of computational models to evaluate automotive propulsion systems and subsystems.","This section is intended to provide a background or context to the invention that is, inter alia, recited in the claims. The description herein may include concepts that could be pursued, but are not necessarily ones that have been previously conceived or pursued. Therefore, unless otherwise indicated herein, what is described in this section is not prior art to the description and claims in this application and is not admitted to be prior art by inclusion in this section.","The present invention relates generally to the field of systems and methods for automatically building a model to evaluate an automotive propulsion system and\/or subsystems. More specifically the present invention relates to methods and systems for automating the design, analysis, and development of an automotive propulsion system and\/or subsystem.","With the introduction of advanced propulsion technologies, including hybrid electric vehicles, fuel cells, etc, designers often must evaluate hundreds of vehicle propulsion system configurations for potential selection for a new or modified vehicle. Various configurations for evaluation may comprise, for example, a variety of powertrain types (conventional, electric, series, parallel, power split, etc), a multitude of component technologies (various types of transmission, engine, electric machines, battery, etc.), model complexity (steady-state, transients, etc.), and system controllers. Additionally, vehicles can be two or four wheel drive and have a variety of differentials, all of which may affect the performance of the vehicle. Still further, a model may consider various driving variables (steady-state conditions, transient effects such as acceleration and braking, grades, city\/highway driving, etc.). These variables, plus others known in the art, but not mentioned here, can make up hundreds of configurations that must be taken into consideration when evaluating a vehicle propulsion system to arrive at an optimized system and\/or system subcomponents for a particular vehicle design.","It is impracticable to build and evaluate a physical embodiment of every potential configuration and inefficient to do so for even a reasonable number of configurations. Accordingly, simulation may be used to develop and evaluate a large number of configurations relatively quickly and inexpensively. The benefits of modeling and simulation in allowing companies to accelerate the introduction of technology into the market have grown rapidly. With time, however, the size and complexity of simulation models have also increased, detracting from their efficiency.","In the transportation field, two principal techniques for simulating various powertrain configurations have been developed: (1) build all the simulation configurations by hand, and (2) modify a preexisting configuration. The first technique is used by conventional simulation applications such as AVL CRUISE and GT-DRIVE. Here, every model must be manually created by moving individual component models, for example, an engine, a clutch, and a fuel cell, from a library of component models into the simulation environment and then linking every component. The second is used in some other conventional simulation applications such as ADVISOR from AVL. However, in light of the vast number of potential combinations and complexity of such models, this technique is inefficient from both a modeling and data management perspective. Further, the number of permissible combinations that can be saved may be limited to an insufficient number. In either case, conventional simulation processes may take too long and have limited effectiveness and\/or efficiency. In particular, development of a powertrain model for a vehicle may take several days to build and modifying such models requires additional time, all of which may more effectively be applied to running simulations on various configurations and analyzing the results of those simulations.","An embodiment of the present invention relates to a process for modeling an entire vehicle propulsion system and\/or subsystems in a computer simulation environment. The process automatically builds a configuration of a propulsion system and\/or subsystem in a matter of seconds, as opposed to the days required using conventional methods. The various component and system configuration options of the propulsion system are based on a user's selections. The process allows users to build any vehicle propulsion system and\/or subsystem quickly by selecting various component and\/or system models from a plurality of system libraries (i.e., engine plant, controller, actuator, sensor, etc.) that comprise a propulsion system and\/or subsystem. Each library contains a complete characterization of that particular component. By selecting a plurality of models from the various libraries, a complete propulsion system and\/or subsystem can efficiently be assembled and evaluated.","The process comprises a capture component and a build component. The capture component is capable of operating on an existing model to parse all relevant model information to generate one or more files (which may, for example, be XML files), thereby completely characterizing the systems and subsystems at each level of the model. The one or more generated files are created such that they may be efficiently searched, manipulated, and applied for subsequent use in various user defined models created through the build component. The build component obtains the information in the one or more files and additional user defined files based on user selections to create a new model that is complete and ready for analysis.","The process may further be configured to permit any set of models to be assembled and connected based on the contents of the files that may be automatically generated, offering users the ability to develop and evaluate a virtually unlimited number of configurations. By automatically generating the files, substantial time and effort to manually develop a model or file describing the system is avoided and model versioning issues are minimized. In one embodiment the files may comprise an extensible markup language (\u201cXML\u201d) file. The XML format further facilitates manipulation, storage, and searching of model related information and characteristics. By describing each model and system in an XML format, the models may be stored in a relational database. To build a new model, the recursive model building process automatically builds any system and\/or subsystem according to user choices using the automatically generated files. Thus, an entire model may be built starting from an empty window based on minimal user inputs from a Graphical User Interface (\u201cGUI\u201d). The process may be integrated into existing mathematical and simulation software applications. In particular, the modeling environment may be integrated into or configured to work with the Powertrain System Analysis Toolkit (\u201cPSAT) developed by Argonne National Laboratory.","The data resulting from the executed simulation may be generated relating to characteristics of the performance and other parameters of the configured system and\/or the subsystems under various conditions to evaluate subsystem interactions, performance, and overall suitability of the configuration. In one preferred embodiment, the resulting data are automatically saved for subsequent retrieval for analysis and comparison against other modeled configurations. The resulting data may further be associated with the various systems and subsystems making up the model.","The design and evaluation process is applicable to a variety of transportation systems including hybrid automobiles, light trucks, semi-trailers, and railroad locomotives. The approach is further applicable beyond the field of transportation, to virtually any field where complex models having a large number of components are combined to achieve an optimal solution for a particular system, including energy, infrastructure, and network systems.","These and other advantages and features of the invention, together with the organization and manner of operation thereof, will become apparent from the following detailed description when taken in conjunction with the accompanying drawings, wherein like elements have like numerals throughout the several drawings described below.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 1","b":["10","10","110","120","130","140","150","160","170","180","190"]},"To facilitate explanation of the flexible simulation building process , the following terminology is introduced. In an embodiment, the flexible simulation building process  may work in conjunction with various software applications, and in a particular embodiment these may include the MATHWORKS SIMULINK\/STATEFLOW software applications. A SIMULINK\/STATEFLOW model may comprise multiple levels and sublevels. Any level of a model in SIMULINK\/STATEFLOW may be decomposed into (a) subsystems\/subcharts and (b) elements not in subsystems. Elements not in the subsystems may include blocks and lines. All elements not contained in the subsystems\/subchart are referred to in this document as peripherals. Examples of peripherals include, but are not limited to, sum, goto, from, gain, and integrator blocks. That, is, any block in the SIMULINK library that is not a subsystem block. An example of a peripheral in STATEFLOW would be a STATEFLOW flow chart with equations.","The SIMULINK\/STATEFLOW model with subsystems\/subcharts and peripherals may be converted to an XML format. The XML format provides a number of benefits, including: efficient storage in a searchable database; automatic transformation of a model into other languages other than SIMULINK\/STATEFLOW; automatic composition of multiple models stored in the database into one SIMULINK\/STATEFLOW model; rapid substitution of one subsystem\/subchart for other subsystem(s)\/subchart(s). Characteristics of the XML format further allow the automated building of a SIMULINK\/STATEFLOW model based on user selections in a graphical software interface. Because a subsystem can, itself, contain subsystems and peripherals, the model building component recursively converts every level of the SIMULINK\/STATEFLOW model into an XML format.","The flexible simulation building process  uses information characterizing the entirety of a vehicle model stored in the configuration file  and the layout file . In an embodiment, one or more of the configuration files  and one or more of the layout files  comprise XML files, and in a particular embodiment comprise files comprising the Argonne Model Descriptor Specification (\u201cXAMDS\u201d), provided as Appendix A attached hereto. The configuration file  and the layout file  may be created manually by a user through the manual entry capability , including a standard text editor. Alternatively, the configuration file  and the layout file  may be created automatically by reading an existing model through the model capture component . The flexible simulation building process  may further rely on user or otherwise defined subsystem\/subcharts stored in the user library .","A model may be built based on information contained in the above as specified by a user of the flexible simulation building process . In an embodiment, the flexible simulation building process  is adapted to receive input from a GUI  from which a user specifies the subsystem\/subcharts from the user library  to add to the model. The recursive building component  selects one or more configuration files  and one or more layout files , and applies choices made by the user in the GUI  to build the model using library blocks from the user library  and library blocks from additional source, which may include standard blocks from a SIMULINK\/STATEFLOW library. The result is an executable model . In an embodiment, the executable model  may be a SIMULINK\/STATEFLOW file. Results obtained from the executable model  may be stored and associated as necessary with information contained in the one or more configuration files , the one ore more layout files , and the user library .","With reference to , the model capture component  captures a model . The model  may be a preexisting model. The model capture component  is configured to generate the configuration file  and the layout file  representing the model . The model capture component  may comprise a computer program in an embodiment, and in particular embodiments the model capture component  may be adapted to operate in the MATLAB environment. The model  captured by the model capture component  comprises a plurality of components and sub-components representing the simulated system, for example, a vehicle powertrain. The model  may be created and or reside in one or more simulation environments, including SIMULINK MODEL and\/or STATEFLOW CHART.","With reference to , the model capture component  capturing the model  comprises three subroutines, including a subsystem parser , a peripheral parser , and a connection parser . As previously described, the model capture component  generates from the model  the configuration file  and the layout file , which in an embodiment, comprises XML files. The model  may include a plurality of components, and each component may comprise one or more sub-systems, each of the one or more sub-systems may further comprise one or more sub-systems, and so forth defining a plurality of levels in the model . The configuration file  and the layout file  may be generated for each of the plurality of levels of the model .","As depicted in , the subsystem parser  comprises a reading component , a creation component , an attribute type setting component , an attribute position setting component , and a subsystem detection capability . The subsystem parser  recursively moves through the tree hierarchy of the plurality of levels of the model , replacing subsystem model names with system references. In an embodiment, the system references are in XML format, and more particularly may comprise standardized names in XML format.","The subsystem parser  accomplishes this by reading the plurality of subsystems from the model  at the reading component . The reading component  further obtains subsystem count j. The subsystem reference of the subsystem j is created in the creation component . The attribute type of the subsystem is established at the attribute type setting component , using the \u201cBlocktype\u201d attribute to hold the subsystem reference to a library block type. The subsystem parser  further captures information indicative of a position of each subsystem at the attribute position setting component . The subsystem detection capability  determines whether the subsystem j contains a subsystem. If a subsystem is detected by the subsystem detection capability , the subsystem count j is incremented and is returned to the reading component . If a subsystem is not detected by the subsystem detection capability , for each of the plurality of subsystems where the subsystem count is equal to zero, the subsystem count j is decreased by one and is returned to the reading component . On the other hand, where the subsystem count is not equal to zero, the subsystem count is unaltered and is returned to the reading component .","With reference to , the peripheral parser  comprises a reading component , an element obtaining component , a creation component , an attribute type setting component , an attribute position setting component , a parameter capture component , and a subsystem detection capability . The peripheral parser  captures an object parameter and a dialog parameter for each of the plurality of subsystems of the model . In an embodiment, the object parameter and the dialog parameter are obtained using the MATLAB \u201cget_param\u201d function. The peripheral parser  stores the object parameter and the dialog parameter in the layout file .","The peripheral parser  recursively moves through the tree hierarchy of the plurality of levels of the model . At the reading component , the subsystem j from the model  is read. The reading component  further obtains subsystem count j. The peripheral elements are obtained at the element obtaining component . A layout block and or a connection is created for the subsystem j at the creation component . The attribute type is established at the attribute type setting component . The attribute position is set at the attribute position setting component : The object parameter and the dialog parameter are obtained at the parameter capture component  and set as parameter elements. In an embodiment, the parameter elements are set as XML parameter elements. The subsystem detection capability  determines whether the subsystem j contains a subsystem. If a subsystem is detected by the subsystem detection capability , the subsystem count j is incremented and is returned to the reading component . If a subsystem is not detected by the subsystem detection capability , for each of the plurality of subsystems where the subsystem count is equal to zero, the subsystem count j is decreased by one and is returned to the reading component . On the other hand, where the subsystem count is not equal to zero, the subsystem count is unaltered and is returned to the reading component .","Turning to , the connection parser  comprises a reading component , a connection creation component , an storage component , and a subsystem detection capability . The connection parser  recursively moves through the tree hierarchy of the plurality of levels of the model  and captures any connections that may exist between each subsystem block. The connection parser  stores the connection information in the configuration file .","At the reading component , the subsystem j from the model  is read, capturing any connection for the subsystem j. The reading component  further obtains subsystem count j. A connection is created for the subsystem j at the connection creation component . A connection format for each captured connection is stored by the storage component . In an embodiment, the connection format is set as an XML connection type element. The subsystem detection capability  determines whether the subsystem j contains a subsystem. If a subsystem is detected by the subsystem detection capability , the subsystem count j is incremented and is returned to the reading component . If a subsystem is not detected by the subsystem detection capability , for each of the plurality of subsystems where the subsystem count is equal to zero, the subsystem count j is decreased by one and is returned to the reading component . On the other hand, where the subsystem count is not equal to zero, the subsystem count is unaltered and is returned to the reading component .","As described above, the model capture component  detects and captures the model , storing data indicative of the model in configuration file . The configuration file  comprises a plurality of entries characterizing components and sub-components of the model . One or more elements may be associated with at least one of each of the entries. The elements are indicative of the model components and permit storage, searching, indexing, and manipulation of the configuration file  and the entries therein. Storage of the elements may further be accomplished using a relational database. In an embodiment, the elements are XML markups, and in particular, may be defined by the XML Argonne Model Descriptor Specification\u2014XAMDS.","As depicted in , the configuration file  comprises a plurality of elements, which are defined as a system . The system. , includes a first attribute and a second attribute. The first attribute may be a name attribute . The second attribute may be a layout attribute . The name attribute  references a subsystem model contained in the user library . The reference to the subsystem model may be configured to point to a particular model parameter. In an embodiment, the subsystem model points to a SIMULINK\/STATEFLOW model parameter. This is accomplished by setting the XAMDS model attribute of the system  to the name of the model . This value can be hard coded in the file or left for the user interface to set.","The system  further comprises a position element  that may include attributes of a X position , a Y position , a width , and a height . The values of these attributes define the absolute positions of the system  in the model . In an embodiment, in place of the position element , a relative position attribute  may be used. The relative position attribute  may include the attributes of a grid , a column , and a row . The relative position attribute  is part of the implementation of an alternate method of placing a subsystem in a model  by using coordinates relative to a grid element defined in the corresponding layout file . The configuration file  may further include a connection (type) element  and a connection element . Each of these are addressed below.","The model capture component  may be used to automatically create the configuration file  and the layout file . The configuration file  and the layout file  may also be created by hand using the manual entry capability . The manual creation capability permits users to add further elements that may not be automatically inferred from the model structure, but facilitate the reusability of the file across multiple subsystems. In an embodiment, the additional elements comprise XAMDS elements. With reference to , one such XAMDS element, for example, is a grid element . The grid element  defines a region in the model  of regularly spaced locations of substantially equal size.","For instance, in a SIMULINK model a subsystem can be placed at any one of these predefined regularly spaced locations. The grid element  further includes a XAMDS child element of a prototype block. Any characteristics of the prototype block are applied to every block that is added to the grid element . For example, a common bus connection between every block in the grid element  and a main bus may be assigned to the prototype block. This common connection applied to any block is subsequently added to the grid element . In generally, all properties of the prototype block are applied to all blocks in the grid element . However, exceptions can be made by using a filter element of the prototype block. The filter element looks for a specific property value or a set of property values of any block that is added to the grid element . If the block has the corresponding property values, the prototype block is not applied. The grid element  can have one or more prototype blocks and a prototype block can have one or more filters. The grid element  is coded in the layout file  and the layout file  can include one or more grid elements  all referenced by a respective name element. A block added to a grid element can have relative coordinates based on the row and the column positions in the grid element  or can have absolute coordinates. If the block is given in absolute coordinates, the parent grid element is determined automatically by the model capture component .","As shown in , the layout file  further includes a block element  and a connection_type element . Again, in an embodiment the block element  and the connection_type element  may be defined as XAMDS elements. The block element  may either fully define each of the blocks with a fixed position in the model  or can partially define the characteristics of system elements included in the configuration file  that have a relative position element . The system  does not have a defined position until the user associates the system  with a specific grid element. The association may be accomplished through a graphical interface. A link between the system  in the configuration file  and the grid element  in the layout file  may be made by using the relative position element .","The block element  may further include a plurality of sub-elements. The sub-elements may comprise a position element , one or more parameter elements, and one or more block connection type  and block element connections . The position element  and the connection elements \/ may be substantially identical to those defined for the system  in the configuration file . The parameter element (not shown) allows the properties of the block to be encoded in the block element . The parameter element may include attributes of name and a value. In an embodiment, any SIMULINK\/STATEFLOW object parameter or dialog parameter may be set using the set_param MATLAB function, as defined by the script \u201cget_param(\u2018name\u2019, value)\u201d where name and value are the attributes defined for the respective parameter elements name and value.","The block element  may further include attributes of a blocktype , a name , a source , a SIMULINK_STATEFLOW_only attribute , an always_in_model attribute , and a description attribute . The blocktype  maps to the blocktype in the model , for example, in SIMULINK, or to a component type in, for example, PSAT. The name  may be the SIMULINK\/STATEFLOW block\/chart taken from the library and added to the model . The source  may be a library source for the block\/chart. In an embodiment, the source  may be either the SIMULINK library or the user's library . The SIMULINK_STATEFLOW_only attribute  defines whether the block\/chart should be displayed only in SIMULINK\/STATEFLOW and not appear in the graphical interface of the modeling environment. The always_in_model attribute  may separate one or more layout blocks that are always present in the model  and those that appear under specific conditions as determined by the model capture component .","The connection_type element  may contain formatting information for each connection element . Each connection element  has a type attribute  that can reference a connection type element . The connection_type element  may include one or more point elements . The point elements  may specify a shape of the connection. Any number of point elements  may be defined in the connection_type element .","One or more keywords may further be defined to reference characteristics of the model  that are undetermined until time of building the executable model . Keywords may include, for instance: [system_name], [model_name], [end_port_x], [end_port_y], [begin_port_x], [begin_port_y], and [system_number]. By way of example, the one or more of the point elements  may reference the keyword [end_port_x] to determine the starting point of the connection_type element  with respect to the port of the block element . The actual position of the port is not known until the block element  is instantiated in the executable model .","To automatically generate the new model for analysis, the executable model , the information contained in the configuration file  and the layout file  is combined. By merging contents of the configuration file  and the layout file  the executable model  is completely specified and automatically, generated based on user inputs. The process of building a new model from a collection of one or more layout files  and one or more configuration files  uses a recursive model building process. The recursive model building process comprises: an expander component , a builder component , and a router component . Each of these components is described in detail below.","With reference to , the expander component  comprises a reading component , a conversion component , a grid determining component , a sum block addition component , a static block layout component , and a subsystem detection capability . The expander component  obtains the configuration file  and a layout file at the top level of the model that is to be automatically generated.","The expander component  reads the model level j at the reading component . The common information contained in the configuration file  at the model level j and the layout file at the model level j are merged in the succeeding components of the expander component . The conversion component  converts system information to block information from the configuration file  and the layout file . The grid determining component  looks up the positions of the subsystem and the peripherals in the layout file , or they are determined by using the properties of the grid elements . At build time, one or more of, for example, a sum block is added automatically to the merged file in the sum block addition component . The static block layout component  obtains the information in the configuration file  and the layout file , including block formatting information, and adds it to the merged file.","The subsystem detection capability  determines whether the level j contains a subsystem. If a subsystem is detected by the subsystem detection capability , the subsystem level count j is incremented and is returned to the reading component . If a subsystem is not detected by the subsystem detection capability , for each of the plurality of subsystems where the subsystem count is equal to zero, the subsystem count j is decreased by one and is returned to the reading component . On the other hand, where the subsystem count is not equal to zero, the subsystem count is unaltered and is returned to the reading component . Accordingly, the expander component  moves to the next level of the configuration file  and merges a layout file for that level with its corresponding information. This operation continues recursively, moving from one layer of the tree to the next, through layer n containing a layout file . As this process progresses, the expander component  flattens each of the trees and determines the path of each block in preparation of the builder component  and adds a path element to each block definition in the flattened tree.","The builder component  instantiates the block elements  in the flattened tree. The builder component , as depicted in , comprises an array building component , a path sorting component , a placing component , a block count detection capability , and a keyword resolution component . In an embodiment, the builder component  uses the \u201cadd_block\u201d function in MATLAB or the STATELOW API Block\/Charts that may be added to the subsystem\/subchart. The path variables are sorted in the path sorting component , determining path length. The placing component  adds the block elements  in order from a shortest path to a longest path length. The block count detection capability  determines whether any blocks remain to be placed. If the block count is not equal to zero the block count is reduced by 1 and the process is returned to the placing. component . If the block count is equal to zero the builder component  makes an additional pass through the model resolving any of the keywords in the keyword resolution component .","The partially built model is passed to the routing component . The routing component  instantiates each of the one or more connection elements \/, linking the block elements  together in the model. In an embodiment, the linking is accomplished using the \u201cadd_line function\u201d in MATLAB. With reference to , the routing component  comprises an array building component , a path sorting component , a connection type determining component , a keyword resolving component , a format connection component , a connection adding component , a connection count detection capability , and a block count detection capability . The path variables are sorted in the a path sorting component , therein determining path length. One or more bus sizes are calculated and one or more bus creator blocks are instantiated in the executable model  by the routing component . Any of the keywords are resolved in the keyword resolution component . The connection count detection capability  determines whether any connections remain to be added. If the connection count is not equal to zero the connection count is reduced by 1 and the process is returned to the connection type determining component . If the block count is equal to zero, the routing component  moves to the block count detection capability . The block count detection capability  determines whether any blocks remain for connections to be added. If the block count is not equal to zero, the block count is reduced by 1 and the process is returned to the connection type determining component . If the block count is equal to zero, the routing component  is stopped, signifying the executable model  is complete.","Various embodiments described herein are described in the general context of method steps or processes, which may be implemented in an embodiment by a computer program product, embodied in a computer-readable medium, including computer-executable instructions, such as program code, executed by computers in networked environments. A computer-readable medium may include removable and non-removable storage devices including, but not limited to, Read Only Memory (ROM), Random Access Memory (RAM), compact discs (CDs), digital versatile discs (DVD), etc.","Embodiments of the present invention may be implemented in software, hardware, application logic or a combination of software, hardware and application logic. The software, application logic and\/or hardware may reside, for example, on a chipset, a memory device or a processor.","The foregoing description of embodiments of the present invention have been presented for purposes of illustration and description. It is not intended to be exhaustive or to limit the present invention to the precise form disclosed, and modifications and variations are possible in light of the above teachings or may be acquired from practice of the present invention. The embodiments were chosen and described to explain the principles of the present invention and its practical application to enable one skilled in the art to utilize the present invention in various embodiments and with various modifications as are suited to the particular use contemplated. The features of the embodiments described herein may be combined in all possible combinations of methods, apparatus, modules and systems."],"GOVINT":[{},{}],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 4","FIG. 1"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 5","FIGS. 2-4"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 6","FIGS. 2-4"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 7","FIG. 1"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 8","FIG. 1"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 9","FIG. 1"]}]},"DETDESC":[{},{}]}
