---
title: Run-time optimized shader program
abstract: Systems, methods, and computer readable media for generating optimized shader programs (e.g., vertex and fragment) at run-time are described. In general, techniques are disclosed for determining when an executing graphics program (a “client”) issues a command that, to be carried out, would require a significant change in the currently executing shader program (a “shader”). When this is detected, the client's specified change may be used to identify a minimal set of shader instructions that can provide the client's designated effect. The instructions so identified, may be used to generate a shader optimized for that effect.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09412193&OS=09412193&RS=09412193
owner: Apple Inc.
number: 09412193
owner_city: Cupertino
owner_country: US
publication_date: 20110601
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This disclosure relates generally to the field of graphics processing. More particularly, this disclosure relates to techniques for identifying and generating optimized shader programs for executing applications.","In computer graphics, it is common to represent objects as triangulated polygons (i.e., triangles). The vertices of triangles may be associated not only with position (i.e., where in\/on an object the vertex resides), but also with other attributes that may be used to properly render the triangle to which the vertex is a part. Such attributes may include color at the vertex point, reflectance of the surface at the vertex, textures of the surface at the vertex, and the normal of an approximated curved surface at the location of the vertex. In practice, a vertex may be thought of as a data structure that describes a point in two-dimensional (2D) or three-dimensional (3D) space. A collection of vertices (representing triangles), and information about their interconnectivity, may be used to model objects.","Modern graphics processing units (GPUs) have generalized architectures that permit customized programming through the use of \u201cshader\u201d programs. A shader program is a set of instructions that may be used to calculate rendering effects. In general, there are two principal types of shader programs: vertex shader programs and fragment shader programs. Vertex shader programs are run once for each vertex in a model and are responsible for how the vertex will be displayed. Fragment shader programs are run once for every pixel in every triangle in a model\/object and are responsible for how individual pixels will be displayed. Vertex shader programs can manipulate properties such as the position, color, texture coordinates, and lighting characteristics of a vertex. Fragment shader programs can manipulate various attributes of individual pixels such as color and translucency characteristics. Fragment shaders may also be used to apply lighting values, shadows and specular highlights to a displayed object.","For model data to faithfully represent an object, often many thousands of vertices are required. To produce animation it may be desirable to have rendering rates of 60 frames per second (FPS). Consider then a model that has 100,000 vertices. If the desired drawing rate for the object represented by the model is 60 FPS, a vertex shader program would need to be executed six million (6,000,000) times per second.","Modern framebuffers (to which GPUs write their output), are composed of millions of elements (each element representing a pixel). Often each final frame of GPU rendering will be the result of compositing multiple fragments (i.e., pixels) with a blending operation between them. Consider then a framebuffer that is 2,000-by-1,000 elements in size. If each pixel is drawn twice (once to render the pixel and another to perform a blending operation), a fragment shader program would need to be executed four million (4,000,000) times per second for each frame. At a rendering rate of 60 FPS, the fragment shader program would need to be executed two hundred forty million (240,000,000) times per second.","Because of the extremely high number of executions for both vertex and fragment shaders during object rendering operations, it is important to be able to use optimized shader programs. Unlike programs written for general purpose central processing units (CPUs), generalized logic that employs conditional instructions for potentially unused instructions is not acceptable (such instructions take to much time to evaluate at the rates presented above). Thus, it would be beneficial to provide a technique to generate optimized shaders for an executing application at run-time.","In one embodiment the invention provides a method to generate optimized shader programs. The method includes receiving a designated graphics effect from a client application at run-time, automatically identifying one or more shader program source instructions based on the designated graphics effect and automatically compiling the identified instructions to generate a shader program optimized for the designated graphics effect. Once compiled, the optimized shader program may be linked on behalf of the client application and executed by a programmable graphics processing unit.","In another embodiment the designated graphics effect may be used to generate a unique identifier. The unique identifier, in turn, may be used to isolate and select only those shader program source instructions needed to satisfy the designated graphics operation. The unique identifier may also be used to store the optimized shader program for reuse at a later time. In yet another embodiment, the unique identifier may be used (once generated and before being used to isolate and select shader program instructions) to determine if a shader optimized for the designated graphics operation has already been generated. For example, by using the unique identifier as a hash or key into a memory cache.","In still another embodiment an optimized shader may be retrieved from memory, or generated as described herein, only if the designated graphics operation would require a substantial change in a shader program already executing. In another embodiment, the unique identifier may be used as a mask to selectively identify only those instructions from a plurality of shader program source instructions, needed to implement the designated shader operation. The plurality of shader program source instructions may be instructions making up a monolithic shader program (e.g., a vertex or fragment shader). In one embodiment, the monolithic shader program may be tagged such that groups of one or more shader program instructions correspond to various values of the unique identifier. Other embodiments of the described methodologies may be embodied as program code stored on a non-transitory storage device. Such program code may even be made part of a computer system.","This disclosure pertains to systems, methods, and computer readable media for generating optimized shader programs (e.g., vertex and fragment) at run-time. In general, techniques are disclosed herein for determining when an executing graphics program (hereinafter, client) issues a command that, to be carried out, would require a significant change in the currently executing shader program (hereinafter, shader). When this is detected, the client's specified change may be used to identify a minimal set of shader instructions that can provide the client's designated effect. The instructions so identified, may be used to generate a shader optimized for that effect.","In the following description, for purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the inventive concept. As part of the this description, some structures and devices may be shown in block diagram form in order to avoid obscuring the invention. Moreover, the language used in this disclosure has been principally selected for readability and instructional purposes, and may not have been selected to delineate or circumscribe the inventive subject matter, resort to the claims being necessary to determine such inventive subject matter. Reference in the specification to \u201cone embodiment\u201d or to \u201can embodiment\u201d means that a particular feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment of the invention, and multiple references to \u201cone embodiment\u201d or \u201can embodiment\u201d should not be understood as necessarily all referring to the same embodiment.","It will be appreciated that in the development of any actual implementation (as in any development project), numerous decisions must be made to achieve the developers' specific goals (e.g., compliance with system- and business-related constraints), and that these goals may vary from one implementation to another. It will also be appreciated that such development efforts might be complex and time-consuming, but would nevertheless be a routine undertaking for those of ordinary skill in the Graphics Processing Unit (GPU) program development field having the benefit of this disclosure.","Referring to , system  in accordance with one embodiment allows client  to designate specific graphics effects by issuing calls to middleware  (e.g., a library) through application programming interface (API) . At run-time, middleware  generates shader  optimized to perform the designated effect and passes it to graphics hardware  via drivers . By way of example only, middleware  and API  may support the OpenGL ES 1.1 and\/or 2.0 standards.","When executing an individual shader four million (4,000,000) to two hundred forty million (240,000,000) times per second, each and every instruction within the shader becomes significant. For this reason, it has been determined that any shader that needs to operate at speeds such as these should be optimized. This means a shader should employ only those instructions needed to accomplish its specific task and include no looping or conditional statements.","When a fairly small number of specific tasks need to be implemented, they are typically hand-optimized. In the case of libraries or middleware implementations, the number of tasks can be so large that the development of hand-tailored shaders becomes impractical, if not impossible. Thus, in the past the only meaningful way to construct shaders (e.g., vertex and fragment) for these types of implementations has been to create monolithic shader programs. Monolithic shaders contain all of the instructions needed to implement all of the graphic operations that that type of shader is to provide. As a consequence, monolithic shaders make heavy use of conditional statements. To overcome the problem of conditional statements, shader programs as disclosed herein tag each functional block of one or more instructions within the source code of a monolithic shader. The tags may be used to relate or tie the instruction(s) within a block to a particular graphics state. At run-time, the tags may be used to identify only those instructions needed to provide the client's specified effect (i.e., without the use of conditional statements). The identified instructions, when compiled, constitute a shader optimized for the specified effect.","Referring to , operation  in accordance with one embodiment begins when client  calls into middleware  through API  designating a specific graphics effect (block ). The specified effect may be used to generate a unique identifier or key (block ). Each key so generated identifies, or corresponds to, a unique set of shader operations (a shader). Once generated, the key may be used to determine if the specified effect would require a significant change to the currently instantiated shader (block ). As used herein, an operation will cause a \u201csignificant change\u201d to a shader if the operation requires a change in the number or sequence of instructions the shader would need to execute to perform the operation. In a lighting effect, for example, changing the color of a light from blue to green would not constitute a significant change as both effects may be achieved by the same number and sequence of instructions (albeit with different input values). If, on the other hand, the number of lights provided by a lighting effect where to change from 1 to 3, to avoid the use of conditional statements in the shader, the number and sequence of instructions needed to supply  lights would be different from the number and sequence of instructions needed to supply  light. Such a change would be significant.","If the specified effect does not require a significant change to the currently instantiated shader (the \u201cNO\u201d prong of block ), input in accordance with the specified effect may be supplied to the currently instantiated shader (block ). As noted in the example above, one such change could be to change a lighting effect's color from blue to green. If the specified effect would require a significant change to the currently instantiated shader (the \u201cYES\u201d prong of block ), a check may be made to determine if a shader corresponding to the key generated during block  is already available (block ). If an optimized shader corresponding to the key is already available (the \u201cYES\u201d prong of block ), that shader may be retrieved (block ) and processed as discussed below (block ). If a shader corresponding to the key does not already exist or is otherwise unavailable (the \u201cNO\u201d prong of block ), the key may be used to identify one or more instructions from a collection of shader instructions such as, for example, a tagged monolithic shader (block ) in accordance with this disclosure. The instructions so identified may be compiled (block ), stored for later use (block ), linked on behalf of client application  and sent for execution by graphics hardware  via drivers  (block ). In one embodiment, compiled shader programs stored in accordance with block  may use the associated key as a hash value in a memory cache. In this way, acts in accordance with block  need only apply the key generated in accordance with block  to a memory cache to determine if a prior generated shader is available (e.g., during block ). If a prior generated shader is available, the memory cache could, for example, return the compiled shader itself or a location in memory where the shader may be stored.","Referring to , system  illustrates a functional architecture for generating optimized shader programs at run-time in accordance with one embodiment. As shown, middleware  includes initialization module , key generator module , lookup module , generator module , and linker module . Initialization module  retrieves tagged monolithic shader file  from storage , parses it into structure  suitable for use by generator module  and stores that structure in memory . Key generator module  uses client supplied effect information to generate a key that uniquely corresponds to the specific effect designated by client . Lookup module  uses the key to determine if an optimized shader corresponding to the key has already been generated and stored in memory  (e.g., in memory region ). Generator module  uses the key and structure  stored in memory  to generate and compile a shader optimized for the effect designated by client . Generator module  may also store compiled shader programs in region  of memory  for later use (e.g., retrieval by lookup module ). Linker module  links the compiled optimized shader on behalf of client application  and passes optimized shader  to graphics hardware  via drivers .","For embodiments in which middleware  and API  support a standard such as the OpenGL or OpenGL ES standards, extended mark-up language (XML) tags may be assigned to each functional block of one or more instructions within the source code of a monolithic shader. The tags may be used to relate or tie the instruction(s) within a block to a particular OpenGL state and the class object (in an object-oriented implementation) that handles the particular effect provided by the instruction(s). Referring to , structure  represents a tagged functional block of instructions within a monolithic shader program in accordance with one embodiment. As shown, structure  includes one or more instructions , label  and attributes . It will be recognized, that block  may include other (nested) blocks of instructions. To see how label  and attributes  may be used to tie or associate instructions  to a particular OpenGL ES state as may be implemented in an object-oriented environment effect, consider . As shown there, label  identifies instruction block  as being related to the texturing property for the class EFFECT (used, for example, to implement the OpenGL ES effect). Attributes  indicate the texturing property is conditional and handled by the class EFFECT. If the same instructions are used in the same sequence in multiple locations within file , a common tag may be applied to each such block.","Referring again to , at system start-up initialization module  retrieves monolithic shader program file  that has been tagged as described herein, parses it in accordance with those tags and stores the (hierarchical) structure  in memory . During this process, initialization module may also assign a unique value to each unique tag within file . As such, each assigned value relates to a single effect. In some embodiments, the \u201cvalue\u201d of each unique state (as represented my a unique label in file ) may be \u201crecorded\u201d in a state vector, where each element in the state vector represents the state (i.e., on or off, enabled or disabled) corresponding to a tag in file \/structure . Referring to , state vector  may include an element or bit value for each unique tag in file \/structure . As shown here, element (e.g., bit)  in state vector  may represent the status of the \u201ctexturing enabled\u201d tag  which, in turn, represents the status of the \u201ctexturing enabled\u201d effect within system  and\/or .","Key generation in accordance with blocks  () and module  () for one embodiment is illustrated in . When client  calls into middleware  through API , it can result in one or more values being set within middleware . For example, within effect structure . Values within effect structure  may be mapped into input state vector . For those effects in structure  that have a corresponding tag in file \/structure , input state vector  may have a corresponding element (e.g., bit). In one embodiment, input state vector  has the same number of elements as state vector  and the ith element in state vector  represents the same effect as does the ith element in input state vector . Because input state vector  uniquely represents the combination of effect values that client  may designate, it may also be thought of as a \u201ckey\u201d (e.g., an input key).","In addition to generating input key , operations in accordance with block  may determine if the effect specified by client  (as expressed by input state vector ) would significantly affect the currently executing shader program. In one embodiment, substantial changes to a shadier may be determined by modifier methods in the classes of the middleware (i.e., those classes used to implement an adopted graphics standard such as OpenGL). State vector  may then be thought of as a ledger to record these changes. If the specified effect would not necessitate a substantial change to the currently instantiated shader, operations continue as discussed above regarding block . If the client specified input state vector or key  indicates the currently executing shader would need to be significantly changed, key generator module  passes key  to lookup module .","Lookup module  may use input state vector  as a key into memory  to determine if a shader optimized for the specific effect represented by key  has already been generated. In one embodiment, key  may be used as input (e.g., a hash value) to a memory cache. If key  is \u201cin\u201d the memory cache, what can be returned is the optimized shader or the address in memory  where the optimized shader is stored (e.g., within region ), whereafter operations continue as discussed above with respect to block . If no such shader is found to exist (or is otherwise unavailable), lookup module  may pass key  to generator module .","Generator module  may use key  as a mask against structure . In this operation, key  may be seen to mask out (or remove from further consideration) those functional blocks in file  that do not correspond to the effect represented by the unique pattern of bits in key . It may be recognized that these acts have the effect of removing unnecessary instructions from structure  (the monolithic shader). The approach of removing unnecessary instructions from a monolithic shader to generate an optimized shader, as opposed to building up an optimized shader by joining together different blocks of instructions, yields unexpected benefits. One such benefit is that of substantially reducing the problem caused by inter-related blocks of instructions. Another benefit of this approach is that the tagging process makes it such that the complex process of iteratively parceling chunks of shading text (e.g., shader source code) into logical blocks, tagging them, and associating them with logic that determines if the block should be included or not into a tractable problem. It thereby subdivides a very complex system interaction problem into a set of logical actions that are manageable.","Once the instructions (and only the instructions) needed to provide the client's designated effect have been identified, generator module  may compile them, store a copy thereof in memory  for later use (in accordance with key ), and pass the compiled shader (which is now optimized for the specific effect designated by client ) to linker module . Linker module  may, in turn, link the optimized shader to client  and send the compiled and linked optimized shader program to graphics hardware  through drivers  (in accordance with block ). In an illustrative embodiment, the source code for a monolithic shader (e.g., a vertex or fragment shader) may include 200 to 400 lines. The same monolithic shader tagged in accordance with this disclosure may include 300 to 500 lines. Optimized shaders (e.g., shader ) may include 1 to 5 instructions, none of which are conditional.","Referring now to , a simplified functional block diagram of electronic device  incorporating graphics processing capabilities as disclosed herein is shown according to one embodiment. Electronic device  may include processor , display , device sensors  (e.g., proximity sensor\/ambient light sensor), microphone , audio\/video codecs , speaker , communications circuitry , image sensor with associated camera hardware , user interface , memory , storage device , graphics hardware , and communications bus .","Processor  may be any suitable programmable control device(s) and may control the operation of many functions, such as the generation and\/or processing of graphics data, as well as other functions performed by electronic device . Processor  may represent one or more processing units and include special purpose computational hardware. Processor  may also drive display  and receive user inputs from user interface . Processors such as the Intel Core\u00ae i5 and Intel Core\u00ae i7 processors or a Cortex\u00ae A8 with the ARM\u00ae v7-A architecture may provide a versatile and robust programmable control device that may be utilized for carrying out the disclosed techniques. (INTEL CORE is a registered trademark of the Intel Corporation. CORTEX and ARM are registered trademarks of the ARM Limited Company of the United Kingdom.) In one embodiment, electronic device  may be a workstation or desktop computer system. In another embodiment, electronic device may be portable such as a laptop computer, mobile phone, personal data assistant (PDA), portable digital camera or tablet computer.","Memory  may include one or more different types of storage media used by processor  to perform device functions. For example, memory  may include memory cache, read-only memory (ROM), and\/or random access memory (RAM). Graphics hardware  may includes special purpose graphics hardware such as a programmable GPU. Communications bus  may provide a data transfer path for transferring data to, from, or between at least storage device , memory , processor , and graphics hardware . User interface  may allow a user to interact with electronic device . For example, user interface  can take a variety of forms, such as a button, keypad, dial, a click wheel, keyboard, display screen and\/or a touch screen.","Storage device  may store media (e.g., image and video files), computer program instructions or software, preference information, device profile information, and any other suitable data. Storage device  may include one more non-transitory storage mediums including, for example, magnetic disks (fixed, floppy, and removable) and tape, optical media such as CD-ROMs and digital video disks (DVDs), and semiconductor memory devices such as Electrically Programmable Read-Only Memory (EPROM), and Electrically Erasable Programmable Read-Only Memory (EEPROM).","Memory  and storage  may be used to tangibly retain computer program instructions or code organized into one or more modules and written in any computer program language desired. When executed by, for example, processor  such computer program code may implement one or more of the methods described herein.","Various changes in the materials, components, circuit elements, as well as in the details of the illustrated operational methods are possible without departing from the scope of the following claims. For instance, processor  may be implemented using two or more program control devices communicatively coupled. Each program control device may include the above-cited processors, special purpose processors such as graphics processing units and custom designed state machines that may be embodied in a hardware device such as an application specific integrated circuits (ASICs) and field programmable gate array (FPGAs).","Finally, it is to be understood that the above description is intended to be illustrative, and not restrictive. For example, the above-described embodiments may be used in combination with each other. Many other embodiments will be apparent to those of skill in the art upon reviewing the above description. The scope of the invention therefore should be determined with reference to the appended claims, along with the full scope of equivalents to which such claims are entitled. In the appended claims, the terms \u201cincluding\u201d and \u201cin which\u201d are used as the plain-English equivalents of the respective terms \u201ccomprising\u201d and \u201cwherein.\u201d"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIGS. 4A and 4B"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
