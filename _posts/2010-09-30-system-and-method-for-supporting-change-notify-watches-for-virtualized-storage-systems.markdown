---
title: System and method for supporting change notify watches for virtualized storage systems
abstract: A technique supports Change Notify watches in virtualized storage systems. In particular, techniques of the present invention advantageously emulate Change Notify features (e.g., as documented by the CIFS protocol) on virtualized storage systems by leveraging virtualization mapping information (e.g., an inode-to-path or “I2P” mapping) to walk a file system tree backwards from the data blocks to their ancestors to determine whether there are applicable watches on ancestor directories, and to obtain a pathname (e.g., relative) of the watched (changed) data. In particular, changes to data received from different protocols (e.g., CIFS, NFS, HTTP, etc.) can trigger watches to clients on the virtualized storage system. Also, performance may be enhanced using various caching techniques, and watch state may be retained while moving watched data across volumes of the virtualized storage system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07958169&OS=07958169&RS=07958169
owner: NetApp, Inc.
number: 07958169
owner_city: Sunnyvale
owner_country: US
publication_date: 20100930
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF AN ILLUSTRATIVE EMBODIMENT"],"p":["The present application is a continuation of commonly assigned copending U.S. patent application Ser. No. 11\/948,608, which was filed on Nov. 30, 2007 now U.S. Pat. No. 7,809,776, by Wesley R. Witte for a SYSTEM AND METHOD FOR SUPPORTING CHANGE NOTIFY WATCHES FOR VIRTUALIZED STORAGE SYSTEMS and is hereby incorporated by reference.","The present invention relates to storage systems and, in particular, to supporting Change Notify watches in virtualized storage systems.","A storage system typically comprises one or more storage devices into which information may be entered, and from which information may be obtained, as desired. The storage system includes a storage operating system that functionally organizes the system by, inter alia, invoking storage operations in support of a storage service implemented by the system. The storage system may be implemented in accordance with a variety of storage architectures including, but not limited to, a network-attached storage (NAS) environment, a storage area network (SAN), and a disk assembly directly attached to a client or host computer. The storage devices are typically disk drives organized as a disk array, wherein the term \u201cdisk\u201d commonly describes a self-contained rotating magnetic media storage device. The term disk in this context is synonymous with hard disk drive (HDD) or direct access storage device (DASD).","The storage operating system of the storage system may implement a high-level module, such as a file system, to logically organize the information stored on volumes as a hierarchical structure of data containers, such as files and logical units. For example, each \u201con-disk\u201d file may be implemented as set of data structures, i.e., disk blocks, configured to store information, such as the actual data for the file. These data blocks are organized within a volume block number (vbn) space that is maintained by the file system. The file system may also assign each data block in the file a corresponding \u201cfile offset\u201d or file block number (fbn). The file system typically assigns sequences of fbns on a per-file basis, whereas vbns are assigned over a larger volume address space. The file system organizes the data blocks within the vbn space as a \u201clogical volume\u201d; each logical volume may be, although is not necessarily, associated with its own file system.","A known type of file system is a write-anywhere file system that does not over-write data on disks. If a data block is retrieved (read) from disk into a memory of the storage system and \u201cdirtied\u201d (i.e., updated or modified) with new data, the data block is thereafter stored (written) to a new location on disk to optimize write performance. A write-anywhere file system may initially assume an optimal layout such that the data is substantially contiguously arranged on disks. The optimal disk layout results in efficient access operations, particularly for sequential read operations, directed to the disks. An example of a write-anywhere file system that is configured to operate on a storage system is the Write Anywhere File Layout (WAFL\u00ae) file system available from Network Appliance, Inc., Sunnyvale, Calif.","The storage system may be further configured to operate according to a client\/server model of information delivery to thereby allow many clients to access data containers stored on the system. In this model, the client may comprise an application, such as a database application, executing on a computer that \u201cconnects\u201d to the storage system over a computer network, such as a point-to-point link, shared local area network (LAN), wide area network (WAN), or virtual private network (VPN) implemented over a public network such as the Internet. Each client may request the services of the storage system by issuing file-based and block-based protocol messages (in the form of packets) to the system over the network. By supporting a plurality of file system protocols, such as the conventional Common Internet File System (CIFS) and the Network File System (NFS) protocols, the utility of the storage system is enhanced.","Often, it is desirable for a client (or administrator) to be aware of changes to the data containers served by the storage system. Typically, changes to data containers are maintained through the client's operating system, which locally manages storage and is thus aware of file and directory locations in that local storage. Two problems arise, however, with virtualized network storage systems, such as the logical volumes served by the storage system described above. First, the client's local operating system is generally unaware of the actual physical storage locations of the files and directories on the logical volumes of the storage system, and as such, is generally unable to monitor for changes, particularly those made by clients sharing the logical volumes. Second, the logical volumes, generally, are minimally \u201caware\u201d of the files and directories at the data block level. In other words, the portions of the logical volumes that control the underlying physical storage (e.g., in a clustered storage system, as described herein) are only aware that data has changed, not to which particular files or directories that data belongs (e.g., handled by another portion of a clustered storage system).","The present invention overcomes the disadvantages of the prior art by providing a system and method for supporting Change Notify watches in virtualized storage systems. In particular, techniques of the present invention advantageously emulate Change Notify features (e.g., as documented by the CIFS protocol) on virtualized storage systems by leveraging virtualization mapping information (e.g., an inode-to-path or \u201cI2P\u201d mapping) to \u201cwalk\u201d a file system tree backwards from the data blocks to their higher-level file and directory inodes (\u201cancestors\u201d) to determine whether there are applicable watches on ancestor directories, and to obtain a pathname (e.g., relative) of the watched (changed) data. In particular, changes to data received from different protocols (e.g., CIFS, NFS, HTTP, etc.) can trigger watches to clients on the virtualized storage system. Also, performance may be enhanced using various caching techniques, and watch state may be retained while moving watched data across volumes of the virtualized storage system.","According to one or more embodiments of the present invention, data is stored on data containers of a storage system that may be arranged as one or more logical volumes (e.g., a clustered storage system), and a mapping is maintained from the data containers to corresponding parent directories of a file system of the storage system (e.g., I2P mapping). Watches may be set (e.g., by clients) on one or more of the directories to request that changes made to data stored within the directories be reported in accordance with Change Notify features. In the event a change is detected to data stored within a directory upon which a watch is set, the mapping is traversed to determine a relative pathname of the changed data based on the corresponding parent directories, and the pathname is reported (e.g., to the client). If the watches define an action to be taken in response to changes, then the system also takes that action, such as performing a \u201cdelete-pending\u201d procedure, etc.","Also, according to an aspect of the present invention, triggered watch events may be cached. Such caching may increase performance and reduce storage requirements. For instance, caching may be used to prevent duplicate reports, and to prevent traversal of the mapping based on previously stored pathnames.","Further, according to another aspect of the present invention, the logical volumes may be moved from a first storage device to a second storage device (e.g., of a clustered storage system). As such, the present invention defines techniques that may be used to retain the watches during the move to the second storage device.","As noted, it is often desirable for a client (or administrator) to be aware of changes to the data containers served by the storage system. \u201cChange Notify\u201d is a facility in CIFS network file systems that notifies clients of any changes made to directories or files of the storage system, e.g., at a single directory level or an entire subtree level. The client identifies the directories and actions it wants reported by setting \u201cwatches\u201d on these directories. When changes are made to a file or directory having an associated watch (as requested by the client), the watch is triggered, and a response is sent to notify the client of the change. (For example, these changes may be conveyed to the client through an NT_TRANSACT_NOTIFY_CHANGE command of a conventional Server Message Block (SMB) NT Trans Request, as may be appreciated by those skilled in the art.) For the reasons described above, however, it has been difficult to support Change Notify watches on virtualized storage systems","Accordingly, the present invention provides a system and method for supporting Change Notify watches in virtualized storage systems. In particular, techniques of the present invention advantageously emulate Change Notify features (e.g., as documented by the CIFS protocol, Common Internet File System (CIFS) Version: CIFS-Spec 0.9, Storage Networking Industry Association (SNIA), Draft SNIA CIFS Documentation Work Group Work-in-Progress, Revision Date: Mar. 26, 2001) on virtualized storage systems by leveraging virtualization mapping information (e.g., an inode-to-path or \u201cI2P\u201d mapping) to walk a file system tree backwards from the data blocks to their ancestors to determine whether there are applicable watches on ancestor directories, and to obtain a pathname of the watched (changed) data. In particular, changes to data received from different protocols (e.g., CIFS, NFS, HTTP, etc.) can trigger watches to clients on the virtualized storage system. Also, performance may be enhanced using various caching techniques, and watch state may be retained while moving watched data across volumes of the virtualized storage system.","A. Cluster Environment",{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 1","b":["200","100","200","100","200","310","350","310","200","180","140","350","130","120","200","150","100","100","200"]},"The clients  may be general-purpose computers configured to interact with the node  in accordance with a client\/server model of information delivery. That is, each client may request the services of the node, and the node may return the results of the services requested by the client, by exchanging packets over the network . The client may issue packets including file-based access protocols, such as the Common Internet File System (CIFS) protocol or Network File System (NFS) protocol, over the Transmission Control Protocol\/Internet Protocol (TCP\/IP) when accessing information in the form of files and directories. Alternatively, the client may issue packets including block-based access protocols, such as the Small Computer Systems Interface (SCSI) protocol encapsulated over TCP (iSCSI) and SCSI encapsulated over Fibre Channel (FCP), when accessing information in the form of blocks. Notably, the clients may request that one or more watches be set on data stored by the storage system, such as in accordance with a Change Notify feature, as described herein.","B. Storage System Node",{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 2","FIG. 11"],"b":["200","222","224","225","226","228","230","223","230","235","1100","226","200","100","226","100"],"i":"a,b"},"Each node  is illustratively embodied as a dual processor storage system executing a storage operating system  that preferably implements a high-level module, such as a file system, to logically organize the information as a hierarchical structure of named data containers, such as directories, files, and special types of files called virtual disks (hereinafter generally \u201cblocks\u201d) on the disks. However, it will be apparent to those of ordinary skill in the art that the node  may alternatively comprise a single or more than two processor system. Illustratively, one processor executes the functions of the N-module  on the node, while the other processor executes the functions of the D-module .","The memory  illustratively comprises storage locations that are addressable by the processors and adapters for storing software program code and data structures associated with the present invention. The processor and adapters may, in turn, comprise processing elements and\/or logic circuitry configured to execute the software code and manipulate the data structures. The storage operating system , portions of which is typically resident in memory and executed by the processing elements, functionally organizes the node  by, inter alia, invoking storage operations in support of the storage service implemented by the node. It will be apparent to those skilled in the art that other processing and memory means, including various computer readable media, may be used for storing and executing program instructions pertaining to the invention described herein.","The network adapter  comprises a plurality of ports adapted to couple the node  to one or more clients  over point-to-point links, wide area networks, virtual private networks implemented over a public network (Internet), or a shared local area network. The network adapter  thus may comprise the mechanical, electrical, and signaling circuitry needed to connect the node to the network. Illustratively, the computer network  may be embodied as an Ethernet network or a Fibre Channel (FC) network. Each client  may communicate with the node over network  by exchanging discrete frames or packets of data according to pre-defined protocols, such as TCP\/IP.","The storage adapter  cooperates with the storage operating system  executing on the node  to access information requested by the clients. The information may be stored on any type of attached array of writable storage device media such as video tape, optical, DVD, magnetic tape, bubble memory, electronic random access memory, micro-electro mechanical and any other similar media adapted to store information, including data and parity information. However, as illustratively described herein, the information is preferably stored on the disks  of array . The storage adapter comprises a plurality of ports having input\/output (I\/O) interface circuitry that couples to the disks over an I\/O interconnect arrangement, such as a conventional high-performance, FC link topology.","Storage of information on each array  is preferably implemented as one or more storage \u201cvolumes\u201d that comprise a collection of physical storage disks  cooperating to define an overall logical arrangement of volume block number (vbn) space on the volume(s). Each logical volume is generally, although not necessarily, associated with its own file system. The disks within a logical volume\/file system are typically organized as one or more groups, wherein each group may be operated as a Redundant Array of Independent (or Inexpensive) Disks (RAID). Most RAID implementations, such as a RAID-4 level implementation, enhance the reliability\/integrity of data storage through the redundant writing of data \u201cstripes\u201d across a given number of physical disks in the RAID group, and the appropriate storing of parity information with respect to the striped data. An illustrative example of a RAID implementation is a RAID-4 level implementation, although it should be understood that other types and levels of RAID implementations may be used in accordance with the inventive principles described herein.","C. Storage Operating System","To facilitate access to the disks , the storage operating system  illustratively implements a write-anywhere file system that cooperates with one or more virtualization modules to \u201cvirtualize\u201d the storage space provided by disks . The file system logically organizes the information as a hierarchical structure of named directories and files on the disks. Each \u201con-disk\u201d file may be implemented as set of disk blocks configured to store information, such as data, whereas the directory may be implemented as a specially formatted file in which names and links to other files and directories are stored. The virtualization module(s) allow the file system to further logically organize information as a hierarchical structure of blocks on the disks that are exported as named logical unit numbers (luns).","In the illustrative embodiment, the storage operating system is preferably the NetApp\u00ae Data ONTAP\u00ae operating system available from Network Appliance, Inc., Sunnyvale, Calif. that implements a Write Anywhere File Layout (WAFL\u00ae) file system. However, it is expressly contemplated that any appropriate storage operating system may be enhanced for use in accordance with the inventive principles described herein. As such, where the term \u201cONTAP\u201d is employed, it should be taken broadly to refer to any storage operating system that is otherwise adaptable to the teachings of this invention.",{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 3","b":["300","300","325","312","314","316","315","318","320","322","323","324","326","318","328","330","200"]},"In addition, the storage operating system  includes a series of software layers organized to form a storage server  that provides data paths for accessing information stored on the disks  of the node . To that end, the storage server  includes a file system module  in cooperating relation with a RAID system module  and a disk driver system module . The RAID system  manages the storage and retrieval of information to and from the volumes\/disks in accordance with I\/O operations, while the disk driver system  implements a disk access protocol such as, e.g., the SCSI protocol. In particular, the VSM  implements a Locate( ) function  to compute the location of data container content among the volumes served by the cluster to thereby ensure consistency of such content.","The file system  implements a virtualization system of the storage operating system  through the interaction with one or more virtualization modules illustratively embodied as, e.g., a virtual disk (vdisk) module (not shown) and a SCSI target module . The vdisk module enables access by administrative interfaces, such as a user interface of a management framework  (see ), in response to a user (system administrator) issuing commands to the node . The SCSI target module  is generally disposed between the FC and iSCSI drivers ,  and the file system  to provide a translation layer of the virtualization system between the block (lun) space and the file system space, where luns are represented as blocks.","The file system  is illustratively a message-based system that provides logical volume management capabilities for use in access to the information stored on the storage devices, such as disks. That is, in addition to providing file system semantics, the file system  provides functions normally associated with a volume manager. These functions include (i) aggregation of the disks, (ii) aggregation of storage bandwidth of the disks, and (iii) reliability guarantees, such as minoring and\/or parity (RAID). The file system  illustratively implements the WAFL file system (hereinafter generally the \u201cwrite-anywhere file system\u201d) having an on-disk format representation that is block-based using, e.g., 4 kilobyte (KB) blocks and using index nodes (\u201cinodes\u201d) to identify files and file attributes (such as creation time, access permissions, size and block location). The file system uses files to store meta-data describing the layout of its file system; these meta-data files include, among others, an inode file. A file handle, i.e., an identifier that includes an inode number, is used to retrieve an inode from disk.","Broadly stated, all inodes of the write-anywhere file system are organized into the inode file. A file system (fs) info block specifies the layout of information in the file system and includes an inode of a file that includes all other inodes of the file system. Each logical volume (file system) has an fsinfo block that is preferably stored at a fixed location within, e.g., a RAID group. The inode of the inode file may directly reference (point to) data blocks of the inode file or may reference indirect blocks of the inode file that, in turn, reference data blocks of the inode file. Within each data block of the inode file are embedded inodes, each of which may reference indirect blocks that, in turn, reference data blocks of a file.","Operationally, a request from the client  is forwarded as a packet over the computer network  and onto the node  where it is received at the network adapter . A network driver (of layer  or layer ) processes the packet and, if appropriate, passes it on to a network protocol and file access layer for additional processing prior to forwarding to the write-anywhere file system . Here, the file system generates operations to load (retrieve) the requested data from disk  if it is not resident \u201cin core\u201d, i.e., in memory . If the information is not in memory, the file system  indexes into the inode file using the inode number to access an appropriate entry and retrieve a logical vbn. The file system then passes a message structure including the logical vbn to the RAID system ; the logical vbn is mapped to a disk identifier and disk block number (disk, dbn) and sent to an appropriate driver (e.g., SCSI) of the disk driver system . The disk driver accesses the dbn from the specified disk  and loads the requested data block(s) in memory for processing by the node. Upon completion of the request, the node (and operating system) returns a reply to the client  over the network .","Included in the storage operating system  is a set of inode to pathname (I2P) functions . The I2P functions , in conjunction with the file system , illustratively implement I2P mapping functionality in accordance with the present invention. One exemplary technique for I2P mappings is described in the commonly-owned, copending U.S. Patent Application Publication No. US 2006\/0288026, entitled SYSTEM AND METHOD FOR GENERATING AND MAINTAINING INODE TO PATHNAME MAPPING INFORMATION, by Ed Zayas, et al. published on Dec. 21, 2006, the contents of which are hereby incorporated by reference in their entirety. The I2P functions  may include various scanners, described further below, that operate to install\/remove I2P mappings in accordance with embodiments of the present invention. Additionally, the I2P functions  may include an application program interface (API) that is exposed to enable other processes executing within the storage operating system to perform I2P mappings. The API may also be accessible via remote procedure calls (RPCs) to enable programs executing on other computers in network environment  to perform I2P mapping functions. Also included within the file system  is a lock manager  and a watch process , which implements the novel Change Notify support procedures of the present invention (e.g., in conjunction with watch process  of N-module ).","It should be noted that the software \u201cpath\u201d through the storage operating system layers described above needed to perform data storage access for the client request received at the node may alternatively be implemented in hardware. That is, in an alternate embodiment of the invention, a storage access request data path may be implemented as logic circuitry embodied within a field programmable gate array (FPGA) or an application specific integrated circuit (ASIC). This type of hardware implementation increases the performance of the storage service provided by node  in response to a request issued by client . Moreover, in another alternate embodiment of the invention, the processing elements of adapters ,  may be configured to offload some or all of the packet processing and storage access operations, respectively, from processor , to thereby increase the performance of the storage service provided by the node. It is expressly contemplated that the various processes, architectures, and procedures described herein can be implemented in hardware, firmware or software.","As used herein, the term \u201cstorage operating system\u201d generally refers to the computer-executable code operable on a computer to perform a storage function that manages data access and may, in the case of a node , implement data access semantics of a general purpose operating system. The storage operating system can also be implemented as a microkernel, an application program operating over a general-purpose operating system, such as UNIX\u00ae or Windows XP\u00ae, or as a general-purpose operating system with configurable functionality, which is configured for storage applications as described herein.","In addition, it will be understood to those skilled in the art that the invention described herein may apply to any type of special-purpose (e.g., file server, filer, or storage serving appliance) or general-purpose computer, including a standalone computer or portion thereof, embodied as or including a storage system. Moreover, the teachings of this invention can be adapted to a variety of storage system architectures including, but not limited to, a network-attached storage environment, a storage area network and disk assembly directly-attached to a client or host computer. The term \u201cstorage system\u201d should therefore be taken broadly to include such arrangements in addition to any subsystems configured to perform a storage function and associated with other equipment or systems. It should be noted that while this description is written in terms of a write any where file system, the teachings of the present invention may be utilized with any suitable file system, including a write in place file system.","D. CF Protocol","In the illustrative embodiment, the storage server  is embodied as D-module  of the storage operating system  to service one or more volumes of array . In addition, the multi-protocol engine  is embodied as N-module  to (i) perform protocol termination with respect to a client issuing incoming data access request packets over the network , as well as (ii) redirect those data access requests to any storage server  of the cluster . Moreover, the N-module  and D-module  cooperate to provide a highly-scalable, distributed storage system architecture of the cluster . To that end, each module includes a cluster fabric (CF) interface module adapted to implement intra-cluster communication among the modules, including D-module-to-D-module communication.","The protocol layers, e.g., the NFS\/CIFS layers and the iSCSI\/FC layers, of the N-module  function as protocol servers that translate file-based and block based data access requests from clients into CF protocol messages used for communication with the D-module . That is, the N-module servers convert the incoming data access requests into file system primitive operations (commands) that are embedded within CF messages by the CF interface module  for transmission to the D-modules  of the cluster . Notably, the CF interface modules  cooperate to provide a single file system image across all D-modules  in the cluster . Thus, any network port of an N-module that receives a client request can access any data container within the single file system image located on any D-module  of the cluster.","Further to the illustrative embodiment, the N-module  and D-module  are implemented as separately-scheduled processes of storage operating system ; however, in an alternate embodiment, the modules may be implemented as pieces of code within a single operating system process. Communication between an N-module and D-module is thus illustratively effected through the use of message passing between the modules although, in the case of remote communication between an N-module and D-module of different nodes, such message passing occurs over the cluster switching fabric . A known message-passing mechanism provided by the storage operating system to transfer information between modules (processes) is the Inter Process Communication (IPC) mechanism. The protocol used with the IPC mechanism is illustratively a generic file and\/or block-based \u201cagnostic\u201d CF protocol that comprises a collection of methods\/functions constituting a CF application programming interface (API). Examples of such an agnostic protocol are the SpinFS and SpinNP protocols available from Network Appliance, Inc. The SpinFS protocol is described in the above-referenced U.S. Patent Application Publication No. US 2002\/0116593.","The CF interface module  implements the CF protocol for communicating file system commands among the modules of cluster . Communication is illustratively effected by the D-module exposing the CF API to which an N-module (or another D-module) issues calls. To that end, the CF interface module  is organized as a CF encoder and CF decoder. The CF encoder of, e.g., CF interface on N-module  encapsulates a CF message as (i) a local procedure call (LPC) when communicating a file system command to a D-module  residing on the same node  or (ii) a remote procedure call (RPC) when communicating the command to a D-module residing on a remote node of the cluster . In either case, the CF decoder of CF interface on D-module  de-encapsulates the CF message and processes the file system command.",{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 4","b":["400","400","150","100","400","402","404","406","408","410","100","410","400","310","350","408","406"]},"A data container, e.g., a file, is accessed in the file system using a data container handle.  is a schematic block diagram illustrating the format of a data container handle  including a volume ID field , an inode number field  and a unique-ifier field . The volume ID field  contains a global identifier (within the cluster ) of the volume within which the data container resides. The inode number field  contains an inode number of an inode (within an inode file) pertaining to the data container. The unique-ifier field  contains a monotonically increasing number that uniquely identifies the data container handle . The unique-ifier is particularly useful in the case where an inode number has been deleted, reused, and reassigned to a new data container. The unique-ifier distinguishes that reused inode number in a particular data container from a potentially previous use of those fields.","E. File System Organization","In the illustrative embodiment, a data container is represented in the write-anywhere file system as an inode data structure adapted for storage on the disks .  is a schematic block diagram of an inode , which illustratively includes a meta-data section  and a data section . The information stored in the meta-data section  of each inode  describes the data container (e.g., a file) and, as such, includes the type (e.g., regular, directory, vdisk)  of file, its size , time stamps (e.g., access and\/or modification time) , an ownership, i.e., user identifier (UID ) and group ID (GID ), of the file, a link count field , and a primary name data structure . The meta-data section  also includes a generation number , and a meta-data invalidation flag field . The meta-data invalidation flag field  is used to indicate whether meta-data in the inode is usable. The link count field  tracks the number of names (and, implicitly, the number of hard links) associated with the inode. For example, a link count of one signifies that there are no hard links to the data container and that the only name associated with the inode is the primary name.","The primary name (pathname) data structure  illustratively includes a parent directory inode field , a parent directory cookie field  and, in alternative embodiments, additional fields . The parent directory inode field  contains an inode value that is associated with the parent directory of the data container. Thus, if the data container is a file bar located in the foo directory (i.e., \/foo\/bar) then the parent directory inode field contains the inode number of the foo directory. The parent directory cookie field  illustratively contains a multi-bit value that identifies a directory block and entry within the directory block of the directory identified by the parent directory inode field .","The contents of the data section  of each inode may be interpreted differently depending upon the type of file (inode) defined within the type field . For example, the data section  of a directory inode contains meta-data controlled by the file system, whereas the data section of a regular inode contains file system data. In this latter case, the data section  includes a representation of the data associated with the file.","Specifically, the data section  of a regular on-disk inode may include file system data or pointers, the latter referencing 4 KB data blocks on disk used to store the file system data. Each pointer is preferably a logical vbn to facilitate efficiency among the file system and the RAID system  when accessing the data on disks. Given the restricted size (e.g., 128 bytes) of the inode, file system data having a size that is less than or equal to 64 bytes is represented, in its entirety, within the data section of that inode. However, if the length of the contents of the data container exceeds 64 bytes but less than or equal to 64 KB, then the data section of the inode (e.g., a first level inode) comprises up to 16 pointers, each of which references a 4 KB block of data on the disk.","Moreover, if the size of the data is greater than 64 KB but less than or equal to 64 megabytes (MB), then each pointer in the data section  of the inode (e.g., a second level inode) references an indirect block (e.g., a first level L1 block) that contains 1024 pointers, each of which references a 4 KB data block on disk. For file system data having a size greater than 64 MB, each pointer in the data section  of the inode (e.g., a third level L3 inode) references a double-indirect block (e.g., a second level L2 block) that contains 1024 pointers, each referencing an indirect (e.g., a first level L1) block. The indirect block, in turn, contains 1024 pointers, each of which references a 4 KB data block on disk. When accessing a file, each block of the file may be loaded from disk  into the memory .","When an on-disk inode (or block) is loaded from disk  into memory , its corresponding in-core structure embeds the on-disk structure. For example, the dotted line surrounding the inode  indicates the in-core representation of the on-disk inode structure. The in-core structure is a block of memory that stores the on-disk structure plus additional information needed to manage data in the memory (but not on disk). The additional information may include, e.g., a \u201cdirty\u201d bit . After data in the inode (or block) is updated\/modified as instructed by, e.g., a write operation, the modified data is marked \u201cdirty\u201d using the dirty bit  so that the inode (block) can be subsequently \u201cflushed\u201d (stored) to disk. The in-core and on-disk format structures of the WAFL file system, including the inodes and inode file, are disclosed and described in commonly-owned U.S. Pat. No. 5,819,292 titled METHOD FOR MAINTAINING CONSISTENT STATES OF A FILE SYSTEM AND FOR CREATING USER-ACCESSIBLE READ-ONLY COPIES OF A FILE SYSTEM by David Hitz et al., issued on Oct. 6, 1998, the contents of which are hereby incorporated by reference in its entirety.",{"@attributes":{"id":"p-0085","num":"0084"},"figref":"FIG. 7","b":["700","224","360","702","704","705","706","700","704","130"]},"Also, in accordance with an embodiment of the present invention, each data block  comprises one or more directory entries  A-N. Illustratively, the parent directory cookie value  uniquely identifies a particular directory entry within the directory identified by the parent directory inode field . That is, the inode identified by the parent directory inode field  identifies a directory inode . The parent directory cookie value  identifies a particular level 0 data block  of the directory and a particular directory entry  within that level 0 data block .","A file system layout is provided that apportions an underlying physical volume into one or more virtual volumes (or flexible volume) of a storage system, such as node . An example of such a file system layout is described in U.S. Patent Application Publication No. US 2005\/0246401 titled EXTENSION OF WRITE ANYWHERE FILE SYSTEM LAYOUT, by John K. Edwards et al. published Nov. 3, 2005, and assigned to Network Appliance, Inc. The underlying physical volume is an aggregate comprising one or more groups of disks, such as RAID groups, of the node. The aggregate has its own physical volume block number (pvbn) space and maintains meta-data, such as block allocation structures, within that pvbn space. Each flexible volume has its own virtual volume block number (vvbn) space and maintains meta-data, such as block allocation structures, within that vvbn space. Each flexible volume is a file system that is associated with a container file; the container file is a file in the aggregate that contains all blocks used by the flexible volume. Moreover, each flexible volume comprises data blocks and indirect blocks that contain block pointers that point at either other indirect blocks or data blocks.","In one embodiment, pvbns are used as block pointers within buffer trees of types of files (such as directory ) stored in a flexible volume. This \u201chybrid\u201d flexible volume embodiment involves the insertion of only the pvbn in the parent indirect block (e.g., Mode or indirect block). On a read path of a logical volume, a \u201clogical\u201d volume (vol) info block has one or more pointers that reference one or more fsinfo blocks, each of which, in turn, points to an Mode file and its corresponding Mode buffer tree. The read path on a flexible volume is generally the same, following pvbns (instead of vvbns) to find appropriate locations of blocks; in this context, the read path (and corresponding read performance) of a flexible volume is substantially similar to that of a physical volume. Translation from pvbn-to-disk, dbn occurs at the file system\/RAID system boundary of the storage operating system .","In an illustrative dual vbn hybrid flexible volume embodiment, both a pvbn and its corresponding vvbn are inserted in the parent indirect blocks in the buffer tree of a type of file (e.g., a directory). That is, the pvbn and vvbn are stored as a pair for each block pointer in most buffer tree structures that have pointers to other blocks, e.g., level 1 (L1) indirect blocks, inode file level 0 (L0) blocks.  is a schematic block diagram of an illustrative embodiment of a buffer tree of a directory  that may be advantageously used with the present invention. A root (top-level) inode , such as an embedded inode, references indirect (e.g., level 1) blocks . Note that there may be additional levels of indirect blocks (e.g., level 2, level 3) depending upon the size of the directory. The indirect blocks (and inode) contain pvbn\/vvbn pointer pair structures  that ultimately reference data blocks  used to store the actual data of the directory. As noted above in , data blocks  of directory  contain directory entries A-N.","The pvbns reference locations on disks of the aggregate, whereas the vvbns reference locations within files of the flexible volume. The use of pvbns as block pointers  in the indirect blocks  provides efficiencies in the read paths, while the use of vvbn block pointers provides efficient access to required meta-data. That is, when freeing a block of a file, the parent indirect block in the file contains readily available vvbn block pointers, which avoids the latency associated with accessing an owner map to perform pvbn-to-vvbn translations; yet, on the read path, the pvbn is available.",{"@attributes":{"id":"p-0091","num":"0090"},"figref":"FIG. 9","b":["900","902","904","906","908","910","900","900","950","950","960","930"]},"Whereas the aggregate  is analogous to a physical volume of a conventional storage system, a flexible volume is analogous to a file within that physical volume. That is, the aggregate  may include one or more files, wherein each file contains a flexible volume  and wherein the sum of the storage space consumed by the flexible volumes is physically smaller than (or equal to) the size of the overall physical volume. The aggregate utilizes a physical pvbn space that defines a storage space of blocks provided by the disks of the physical volume, while each embedded flexible volume (within a file) utilizes a logical vvbn space to organize those blocks, e.g., as files. Each vvbn space is an independent set of numbers that corresponds to locations within the file, which locations are then translated to dbns on disks. Since the flexible volume  is also a logical volume, it has its own block allocation structures (e.g., active, space and summary maps) in its vvbn space.","A container file is a file in the aggregate that contains all blocks used by a flexible volume. The container file is an internal (to the aggregate) feature that supports a flexible volume; illustratively, there is one container file per flexible volume. Similar to a pure logical volume in a file approach, the container file is a hidden file (not accessible to a user) in the aggregate that holds every block in use by the flexible volume. The aggregate includes an illustrative hidden meta-data root directory that contains subdirectories of flexible volumes:\n\n","Specifically, a physical file system (WAFL) directory includes a subdirectory for each flexible volume in the aggregate, with the name of subdirectory being a file system identifier (fsid) of the flexible volume. Each fsid subdirectory (flexible volume) contains at least two files, a file system file and a storage label file. The storage label file is illustratively a 4 KB file that contains meta-data similar to that stored in a conventional raid label. In other words, the storage label file is the analog of a raid label and, as such, contains information about the state of the flexible volume such as, e.g., the name of the flexible volume, a universal unique identifier (uuid) and fsid of the flexible volume, whether it is online, being created or being destroyed, etc.",{"@attributes":{"id":"p-0095","num":"0095"},"figref":"FIG. 10","b":["1000","300","380","1000","1","2","1002","1002","1004","1004","1000"]},"Each fsinfo block  also includes a block pointer to an inode file  that contains inodes of a plurality of files, including an owner map , an active map , a summary map , and a space map , as well as other special meta-data files. The inode file  further includes a root directory  and a \u201chidden\u201d meta-data root directory , the latter of which includes a namespace having files related to a flexible volume in which users cannot \u201csee\u201d the files. The hidden meta-data root directory includes the WAFL\/fsid\/ directory structure that contains file system file  and storage label file . Note that root directory  in the aggregate is empty; all files related to the aggregate are organized within the hidden meta-data root directory .","In addition to being embodied as a container file having level 1 blocks organized as a container map, the file system file  includes block pointers that reference various file systems embodied as flexible volumes . The aggregate  maintains these flexible volumes  at special reserved inode numbers. Each flexible volume  also has special reserved inode numbers within its flexible volume space that are used for, among other things, the block allocation bitmap structures. As noted, the block allocation bitmap structures, e.g., active map , summary map  and space map , are located in each flexible volume.","Specifically, each flexible volume  has the same inode file structure\/content as the aggregate, with the exception that there is no owner map and no WAFL\/fsid\/filesystem file, storage label file directory structure in a hidden meta-data root directory . To that end, each flexible volume  has a volinfo block  that points to one or more fsinfo blocks , each of which may represent a snapshot, along with the active file system of the flexible volume. Each fsinfo block, in turn, points to an inode file  that, as noted, has the same inode structure\/content as the aggregate with the exceptions noted above. Each flexible volume  has its own inode file  and distinct inode space with corresponding inode numbers, as well as its own root (fsid) directory  and subdirectories of files that can be exported separately from other flexible volumes.","The storage label file  contained within the hidden meta-data root directory  of the aggregate is a small file that functions as an analog to a conventional raid label. A raid label includes physical information about the storage system, such as the volume name; that information is loaded into the storage label file . Illustratively, the storage label file  includes the name  of the associated flexible volume , the online\/offline status  of the flexible volume, and other identity and state information  of the associated flexible volume (whether it is in the process of being created or destroyed). Illustratively, an alternate name file  is located in the hidden meta-data directory . The alternate name file  is utilized to store I2P mapping information associated with alternate names of an inode and is illustratively implemented as a balanced (e.g., B+) tree structure to enable fast searches. Further, lock file  and watch file  may also be included within the hidden meta-data directory , as described herein.","F. Management Processes",{"@attributes":{"id":"p-0101","num":"0101"},"figref":"FIG. 11","b":["1100","300","1110","1130","1150","1110","1170","200","100"]},"The VLDB  is a database process that tracks the locations of various storage components (e.g., flexible volumes, aggregates, etc.) within the cluster  to thereby facilitate routing of requests throughout the cluster. In the illustrative embodiment, the N-module  of each node accesses a configuration table  that maps the volume ID  of a data container handle  to a D-module  that \u201cowns\u201d (services) the data container within the cluster. The VLDB includes a plurality of entries which, in turn, provide the contents of entries in the configuration table ; among other things, these VLDB entries keep track of the locations of the flexible volumes (hereinafter generally \u201cvolumes \u201d) and aggregates  within the cluster.","G. Lock State Information","Most file-level protocols include locking functionality that enables a client to transmit an operation to a software module that acts in conjunction with a file system to implement a lock on either an entire file or a defined subset of a file. A lock is a mechanism that represents the right of an owner, such as a client or system administrator, to access a shared resource. An entity later attempting to access this shared resource will be notified of the lock, which may (in the case of an exclusive lock) prevent others from accessing the resource. The types of locks can vary, for example, in some instances, there may be a write lock placed on a resource by the owner, yet other entities may be able to obtain read access to the resource. The type of lock, and\/or the absence of a lock over a particular data container, such as a file, or portion thereof are referred to herein as a \u201clock state.\u201d In particular, once the lock (e.g., a write lock) is granted, only the client owning the lock may perform certain operations (e.g., write operations) directed to the file or subset thereof. Other clients attempting such operations will have these operations denied by the file system. Typically, the file system maintains the current lock state in the memory of the storage system, i.e., in core. That is, if a client acquires a lock, information concerning the lock is typically retained in an in-memory data construct that may be quickly accessed by the file system when determining whether to permit\/deny subsequently later requested operations.","Commonly-owned, co-pending U.S. Pat. No. 7,587,558, entitled SYSTEM AND METHOD FOR MANAGING HARD LOCK STATE INFORMATION IN A DISTRIBUTED STORAGE SYSTEM ENVIRONMENT, filed on Nov. 1, 2005 by Toby Smith, et al., describes providing a technique for managing lock state information in a distributed storage system architecture comprising two or more volumes distributed across a plurality of nodes interconnected as a cluster. In particular, as described therein, a lock manager  is configured to efficiently manage the lock state information (lock file ), including granting, revoking, and releasing of various types of locks on data containers or ranges of data containers stored on the storage system.","Briefly,  is a schematic block diagram of an exemplary lock file  in accordance with an embodiment of the present invention. The lock file  illustratively comprises a plurality of entries . Each entry  contains an owner field  and one or more lock fields , i.e., each entry is associated with a single owner of one or more locks in the file system. Each lock field  illustratively comprises a data container handle field , a lock state field  and in alternate embodiments, additional fields . The data container handle field  contains a data container (e.g., a file) handle identifying the file with which the lock is associated. The lock state field  identifies the current state of the lock including, e.g., type, range, etc. Also, in accordance with one or more embodiments of the present invention, each entry  may also contain a watch pointer field , to point to associated watches corresponding to the data container identified in file handle field .","H. I2P Mapping Operations","Certain events occurring within the storage system and\/or a storage operating system executing thereon may result in a message being displayed to an administrator. For example, the storage system may detect that one or more data containers have become corrupted. A pathname provides a way for the administrator to refer to a data container served by the storage system. To that end, each pathname typically represents one data container within the hierarchical structure of the file system. However, the storage system typically reports the identity of the data container to the administrator by using its associated inode number. The inode number is used internally within the file system to identify the inode associated with the data container and, unfortunately, is not easily understood by humans. It is therefore desirous for the administrator to know the pathname of the data container to which the message relates so that appropriate action may be taken. One technique for generating inode to pathname information (I2P) is described in the above incorporated U.S. Patent Application Publication No. US 2006\/0288026, entitled SYSTEM AND METHOD FOR GENERATING AND MAINTAINING INODE TO PATHNAME MAPPING INFORMATION, by Ed Zayas, et al. published on Dec. 21, 2006. In such an environment, a primary name data structure is included within each inode. The primary name data structure contains information identifying a specific directory entry associated with a primary name of the data container. Illustratively, additional names for a data container, e.g., hard links, may be stored in an alternate name file in a metadata directory within the file system.","As described in the above-incorporated U.S. patent application Ser. No. 11\/156,679, filed on Jun. 20, 2005 by Edward R. Zayas et al., the I2P functions  of the storage operating system  operate in conjunction with the file system  to permit processes to read and\/or write I2P information from either a primary name data structure  within an inode  or from an alternate name file . Such reading\/writing operations, described further below, may be utilized by the various watch processes  of the present invention. In accordance with the illustrative embodiment of the present invention, any reading\/writing techniques for obtaining\/setting the I2P information may be utilized. As such, these procedures should be taken as exemplary only.",{"@attributes":{"id":"p-0110","num":"0110"},"figref":"FIG. 13","b":["1300","1300","1300","1305","1310","1315","1320","364","1325","650","1340","1320","1330","1095","1340"]},{"@attributes":{"id":"p-0111","num":"0111"},"figref":"FIG. 14","b":"1400","ul":{"@attributes":{"id":"ul0003","list-style":"none"},"li":{"@attributes":{"id":"ul0003-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0004","list-style":"none"},"li":"inodepath \u2212v<volume>[\u2212a][\u2212s<PCPIname>]<inodenumber>\n\nwhere the \u2212v option identifies the volume name identified in the <volume> field in which the inode number identified in the <inodenumber> field is located. Illustratively, the \u2212a option causes the command to print all of the names associated with the inode (identified by the inode number), i.e., the primary name and all alternate names associated with the inode. In an exemplary embodiment the program defaults to only displaying the primary name. The \u2212s option causes the program to display the name(s) associated with the inode <inodenumber> located within the PCPI having the name <PCPIname>. Thus, the program may display\/return names associated with previous point-in-time images of the file system. In the illustrative embodiment, the I2P functions  of the storage operating system  may be used by watch processes  to retrieve I2P information, accordingly.\n"}}}},"The procedure  begins in step  and continues to step  where the file system and I2P functions retrieve (read) the primary name data structure  from the inode. In step , the file system and I2P functions determine whether the primary name data structure contains a zero value. Illustratively, a zero value within the primary name data structure signifies that the file system has not yet identified the appropriate I2P mapping information for this inode. This may be because an initial scan, described further below, has not yet reached this particular inode or may be due to corruption of the information which has resulted in the file system clearing the I2P information to prevent incorrect results being returned. If the primary name data structure within the inode contains a zero value, the procedure branches to step  signifying that the I2P mapping information is not set before completing in step . Illustratively, a caller or program invoking procedure  will return information signifying that the I2P mapping information is not available. In alternate embodiments, if the primary name data structure is zero, then the file system invokes the scanner, described further below, to generate the appropriate information. In such alternative embodiments the scanner, which is illustratively part of the I2P functions , generates the appropriate primary name data structure contents before re-initiating procedure .","If, in step , the value is not zero then the procedure continues to step  where a determination is made whether the option, e.g., \u2212a, has been selected to display\/return alternate names. If the alternate names option has not been set, the procedure branches to step  and returns the primary name before completing in step .","However, if in step  it is determined that the alternate names are desired, the procedure continues to step  where a determination is made as to whether the alternate name file contains entries associated with this inode. If the alternate names file does not contain any associated entries, then the data container only has a primary name, which is returned in step  before the procedure completes in step . The primary name is determined by examining the directory entry  in the appropriate directory that is identified by the cookie value  within the primary name data structure . However, if in step  there are alternate names identified, then the file system returns the primary name and the alternate name(s) in step  before completing in step . The alternate name(s) are identified in a similar manner to the primary name, i.e., the directory is identified by the parent directory inode and a specific entry within the directory is identified by the cookie value.",{"@attributes":{"id":"p-0115","num":"0116"},"figref":"FIG. 15","b":["1500","1500","1505","1510","364","1500","1515","650","600","1520","715","815","640"]},"Once the directory entry has been removed and the link count updated, the procedure proceeds to step , where a determination is made as to whether the link count is greater than zero for the inode. If the link count is not greater than zero, then the procedure branches to step  and completes. An inode will have a link count of zero when the one and only name associated with it is removed, thereby indicating that the data container associated with the inode may be removed from the file system.","In step , an alternate name of the data container is \u201cpromoted\u201d to the primary name. Illustratively, the first alternate name stored in the alternate name file  is selected and stored within the primary name data structure  of the inode  as the new primary name. Once the newly promoted primary name has been stored, the file system and I2P functions remove the promoted alternate name from the alternate name file in step  before the procedure completes in step . However, if in step , it is determined that the name to be deleted is not the primary name, the procedure branches to step  where the name is removed from the alternate name file. This may be accomplished using conventional B+tree removal operations. In alternate embodiments, where the alternate name file is not implemented as a B+tree, appropriate conventional entry removal operations are utilized. In step , the appropriate directory entry is removed and the link count of the inode is updated before the procedure completes in step .","I. Supporting Change Notify Watches in Virtualized Storage Systems","The present invention overcomes the disadvantages of the prior art by providing a system and method for supporting Change Notify watches in virtualized storage systems. In particular, techniques of the present invention advantageously emulate Change Notify features (e.g., as documented by the CIFS protocol) on virtualized storage systems by leveraging virtualization mapping information (e.g., an inode-to-path or \u201cI2P\u201d mapping) to \u201cwalk\u201d a file system tree backwards from the data blocks to their higher-level file and directory inodes (\u201cancestors\u201d) to determine whether there are applicable watches on ancestor directories, and to obtain a pathname of the watched (changed) data. In particular, changes to data received from different protocols (e.g., CIFS, NFS, HTTP, etc.) can trigger watches to clients on the virtualized storage system. Also, performance may be enhanced using various caching techniques, and watch state may be retained while moving watched data across volumes of the virtualized storage system.","As noted above, it is often desirable for a client system (or administrator) to be aware of changes to data on a storage system. \u201cChange Notify\u201d is a facility in CIFS network filesystems that notifies clients of any changes made to data containers, such as directories and\/or files of the storage system, e.g., at a single directory level or an entire subtree level. The client identifies the directories and actions it wants reported by setting \u201cwatches\u201d on these directories. When changes are made to a file or directory having an associated watch (as requested by the client), the watch is triggered, and a response is sent to notify the client of the change. (To be understood by those skilled in the art, changes may be conveyed to the client through NT_TRANSACT_NOTIFY_CHANGE commands of a conventional Server Message Block (SMB) NT Trans Request.) Notably, while one or more embodiments described herein reference the CIFS protocol and associated Change Notify features, changes made by other protocols, such as NFS, HTTP, FTP, etc., as will be understood by those skilled in the art, may also be watched and reported in accordance with one or more techniques described herein. In particular, by nature of a virtualized storage system, illustratively a networked virtualized storage system, arbitrary protocols may be allowed access to the stored data, and any resultant changes should be detected and reported accordingly.","As a simple example of watches and Change Notify features, assume that two user interface windows are open displaying a same directory. If a change is made within a first window, e.g., adding a file \u201ctext.txt\u201d, it may be desirable to have the change be reflected in a second window, e.g., showing the added file \u201ctext.txt\u201d. Conventional CIFS Change Notify features (without underlying virtualized storage systems) may have placed a watch on the directory, such that detecting the change within the open directory results in a change notification that updates the second window to include the added file. Also, inheritable watches may be set on directories so that events within a subtree hierarchically below the watched directory may result in notifications (e.g., directories within the watched directories). Thus, a client may set \u201cinherited watches\u201d on data hierarchically below a directory upon which an inheritable watch is set (e.g., other directories and\/or files beneath the watched directory).","This simplified example, however, demonstrates conventional Change Notify features that are made available through the client's operating system, which locally manages storage and is thus aware of file and directory locations in storage. With virtualized network storage systems, however, such as the logical volumes served by the storage system described herein, problems may arise with supporting Change Notify watches. In particular, the client's local operating system is generally unaware of the actual physical storage locations of the files and directories on the logical volumes of the storage system, and as such, is generally unable to monitor for changes, particularly those made by clients sharing the logical volumes. Also, in a clustered storage system described herein, D-modules  that control the underlying physical storage are only aware that data has changed, not to which particular files or directories that data belongs (e.g., handled by N-modules  of the clustered storage system). This problem is particularly prevalent where an N-module  of one node  is communicating with a client that desires a directory be watched, while the directory is under the control of a D-module of another, separate, node . As such, prior to the inventive techniques described herein, it has been difficult to support Change Notify watches on virtualized storage systems.","Operationally, according to one or more embodiments of the present invention, data is stored on data containers of a storage system that may be arranged as one or more logical volumes (e.g., a clustered storage system), and a mapping is maintained from the data containers to corresponding parent directories of a file system of the storage system (e.g., I2P mapping). Watches may be set (e.g., by clients) on one or more of the directories to request that changes made to data stored within the directories be reported in accordance with Change Notify features. Illustratively, in the event a change is detected to data, the mapping may be traversed to determine whether there are applicable watches on ancestor directories (i.e., whether the changed data is part of (hierarchically below) a watched directory). In the event a change is detected to data stored within a directory upon which a watch is set, the mapping is (also) traversed to determine a pathname (e.g., a relative pathname) of the changed data based on the corresponding parent directories, and the pathname is reported (e.g., to the client). Notably, in accordance with expected SMB change notification mechanisms, the relative pathname from the watch to the object that was changed is what is illustratively reported.","If the watches define an action (or a plurality of actions) to be taken in response to changes, then the system also takes that action (or those actions), such as performing a \u201cdelete-pending\u201d procedure, etc. Also, if multiple watches are set on a single directory, then the system may take the action defined by each of the plurality of watches in response to changes made to the data. In this manner, the novel techniques described herein conform to the standard CIFS protocol such that all notification events and expected Change Notify features are supported on the virtualized storage system, accordingly.","Also, according to an aspect of the present invention, triggered watch events may be cached. Such caching may increase performance and reduce storage requirements. For instance, caching may be used to prevent duplicate reports, and to prevent traversal of the mapping based on previously stored pathnames. In particular, generation numbers may be used to keep track of changes in directories being watched, inheritance of watches, the inode (events) for watches, the post (trigger or client notification) of watches, etc. Specifically, with generation numbers, the novel techniques can cache the paths and event information until further changes are made to the events or directories to be notified, as described herein.","Notably, as used herein, the term \u201cmode\u201d is used as a filter that a client specifies in a watch to limit what types of file system actions are watched (e.g., create, modify, delete, etc.). Also, the term \u201cpost\u201d is the act of returning a watch notification from the D-module  to the N-module  via a notification callback mechanism. Further, \u201cpost action\u201d represents the type of post that is occurring. In addition, as described herein, watch state may be associated with inode-based lock structures (locks ) that are assigned to the data, and watch volume states may be maintained by the lock manager .","Data Structures for Watch Support","Illustratively, there are four main classes of (in-core) data structures that may be used to implement watches in accordance with one or more embodiments of the present invention. Namely, those data structures comprise \u201cWatch State\u201d data structures, \u201cWatch Cache\u201d data structures, \u201cWatch Trigger\u201d data structures, and \u201cGlobal\u201d data structures, each as described in detail below.",{"@attributes":{"id":"p-0129","num":"0130"},"figref":["FIG. 16A","FIG. 16B"],"b":["1600","1600","1600","1700","1800","1900","1600","1700","1800","1900","1600"],"i":["a ","a ","a ","b ","a. "]},{"@attributes":{"id":"p-0130","num":"0131"},"figref":"FIG. 17","b":["1700","1700","1200","1700","1700"]},"In particular, Watch_Directory Structure  comprises one or more fields used to carry\/store associated information. Mode_summary field  contains a superset of modes on all the watches. Inherit_mode_summary field  contains a mode summary for only inherited watches. Watch_open_count field  contains a total number of watches for this directory. Watch_open_list field  contains a list of all watches on the directory. Volume_pointer field  contains a pointer to the volume containing this directory. Finally, Lmgr_pointer field  contains a pointer to a lock manager file object (lock file ) of this directory.",{"@attributes":{"id":"p-0132","num":"0133"},"figref":["FIG. 18","FIG. 16B"],"b":["1800","1800","1800","1215","1240","1800","1900","1800","1215","1800","1900","1800"]},"In particular, Watch_Open Structure  comprises one or more fields used to capture watch information that is static for the life of the watch. Flags  may indicate various states of the watch, such as, e.g., a \u201ctoo_many\u201d flag that is set when there is a need to indicate that there have been too many changes to keep track of, or a \u201cposted\u201d flag that is true when the open is on the associated post_list (of Global Data Structure ). Lock_ID field  identifies a lock  granted to the client on file open\/create. Directory_backpointer field  contains a backpointer to the associated directory. Watch_mode field  contains a mode that is set the first time the watch is created. Number_posts field  contains a number of posts, illustratively having a buffered limit set to a maximum number of concurrent posts (e.g., 8). Posts field  contains an array of posts that is pending on this open (that is, a small set of posts that are pending for Notification callback processing, described below). Total_post_bytes field  contains a total number of bytes to post (e.g., used to detect a \u201ctoo_many\u201d condition). Notify_time field  contains a timing value used to indicate when to trigger the next callback (e.g., set on the first post, and reset after a callback). Next_watch field  links all watches (Watch_Opens ) for the same directory\/file. Buffered_post_watches field  contains a list of all watches which have some posts buffered, and are linked to the post_list  of the volume. This field () may be scanned by a notify callback message (described below) to fire (generate\/send) the callbacks. Lastly, Instance_pointer field  contains a list of zero or more instances of this watch that have been created by the client, i.e., pointers to Watch_Instance Structures .",{"@attributes":{"id":"p-0134","num":"0135"},"figref":"FIG. 19","b":["1900","1800","1900","1900","310","1900"]},"In particular, Watch_Instance Structure  comprises one or more fields used to carry\/store associated information. Next_instance field  contains a pointer to the next instance () in a linked list of instances associated with an open (Watch_Open ), e.g., as in . Watch_cookie field  contains an opaque cookie passed when the Watch_Instance Structure  is created, and is used as described herein. Request_preallocation_placeholder field  contains a placeholder for request preallocation that may be used when deleting a directory being watched. In particular, in that case all instances have to notify clients of the pending delete before freeing the instances (described below). Also, Watch_max_buffer_size field  may be passed in the watch request, and contains the maximum number of bytes that can be sent back to the client for this watch (e.g., which if exceeded may return a \u201ctoo_many\u201d condition).","As noted, another type of data structure that may be used with the present invention is a Watch Cache Data Structure.  is an illustrative block diagram of an example Watch Cache Data Structure  in accordance with the present invention. Watch Cache Data Structure  may be used to cache watch information for individual file system objects to minimize processing when watches are checked or watch notifications are posted, as described herein. In particular, the Watch Cache Data Structure  may have sub-structures comprising a Watch_Volume Structure  and a Watch_Inode_Cache Structure .",{"@attributes":{"id":"p-0137","num":"0138"},"figref":"FIG. 21","b":["2100","2100","2200","2100"]},"In particular, Watch_Volume Structure  comprises one or more fields used to carry\/store associated information. Directory_generation field  contains a directory generation number which tracks additions of non-inherited watches to a volume (generation numbers are described in more detail below). Inherited_generation field  contains an inherited generation number which tracks additions of inheritable watches to a volume. Mode_generation field  contains a mode generation number, which tracks additions to the modes being watched for individual watches. Mode_mask field  contains a lists supported modes of the volume. Number_directory_watches field  contains a count of the number of inheritable and non-inheritable watches on the volume. Number_inherited_watches field  contains a count of the number of inheritable watches and directories on the volume. Statistics field  contains a set of per-volume statistics. Watch_list field  contains a list of all the Watch_Directory Structures  associated with the volume. Lastly, Prune_list field  (optional) contains a list of stale opens\/watches; that is, for use with recycling Watch_Opens  which have no Watch_Instances  for a configured length of time (e.g., such as when a client doesn't renew a watch).",{"@attributes":{"id":"p-0139","num":"0140"},"figref":"FIG. 22","b":["2200","2200","2100","2200","2200","2200"]},"If the Watch_Inode_Cache Structure  is present, it can be used to determine if the cache  is valid, if a post is necessary, and if an I2P parent walk is necessary to locate possible watches. The Structure  generally contains a watch mode summary that is the superset of all watches that is filtering for this object, a path to the most ancestral watch for the object, present only when a post has occurred for the object, and a matching set of generation numbers for those in the Watch_Volume Structure , each of which is compared to determine the validity of various aspects of the Watch_Inode_Cache Structure information. Also, an additional post generation number is compared with a global post generation number kept in the Watch_Global structure  to allow for the efficient suppression of rapid, duplicate posts.","In particular, Watch_Inode_Cache Structure  comprises one or more fields used to carry\/store associated information. Directory_generation field  corresponds to Directory_generation field  of Watch_Volume Structure . Inherited_generation field  corresponds to Inherited_generation field  of Watch_Volume Structure . Mode_generation field  corresponds to Mode_generation field  of Watch_Volume Structure . Post_generation field  corresponds to Post_generation field  of Watch_Global Structure  (below), and contains a post generation number, which is changed after every notification callback set is sent. Post_action_mask field  contains a mask of all of the actions that have triggered for this inode during the current Post_generation period. (Notably, Post_action_mask  may be used in conjunction with Post_generation field  to suppress rapid, duplicate triggers.) Mode_summary field  contains a summary of all of the applicable modes accumulated through the parent chain of this inode. Lastly, Path_pointer field  contains a pointer to a path that is the complete path from this inode to the top most watch in the associated I2P chain (which may be empty).","Generation numbers, as mentioned above and as used to fill certain various fields described above, are a type of timing\/count number that may be updated\/changed (e.g., increased\/incremented) upon certain defined actions. Generally, generation numbers may change in response to creating watches, handling watches, and handling notification callback messages. The four types of generation numbers mentioned above and used in accordance with one or more embodiments of the present invention are directory_generation, inherit_generation, mode_generation, and post_generation.","Directory_generation fields contain values (generation numbers) that are incremented (\u201cbumped\u201d) whenever a new Watch_Directory  is added to the volume. These signify that a new directory is being watched for the first time. The generation number is not incremented when a new watch (Watch_Open ) is added to a directory that already has watches present, or when a Watch_Directory Structure  is removed. A change to this value informs the file operation watch handling code that its summary mode may be incorrect, and should be recomputed. If only Directory_generation has changed, and Inherit_generation has not, existing caches with modes that were not inherited only need to check for parent node changes; that is, a complete I2P parent walk is not necessary.","Inherit_generation fields contain values that are incremented whenever a directory is watched, and the watch is inheritable, or when the first inheritable watch is added to an existing watched directory. The value is also incremented when a directory is renamed, since an associated inheritance has changed. The value is not incremented when a non-directory (file) is renamed, nor when an inheritable watch is removed. If inode caches have Inherit_generation mismatches, then the inheritance structure has changed, and cached paths must be released, and I2P walks are necessary to find interested watchers.","Mode_generation fields contain values that are incremented whenever a new watch is added to an existing watched directory, and the new watch adds new trigger mode bits to the mode summary for the directory. This signifies that the inheritance structure has not changed, but that summary trigger mode values are no longer valid and should be recomputed. When an inode indicates that it has no watchers, mode_generation changes can be safely ignored.","Post_generation fields contain values that are incremented during notify callback processing. Along with the watch action value stored in the inode cache (Post_action_mask ), this value allows rapid, duplicate posts to be avoided, since each inode only needs to post the first instance of an action during a single notify callback cycle.","Still another type of data structure that may be used with the present invention is a Watch Trigger Data Structure.  is an illustrative block diagram of an example Watch Trigger Data Structure  in accordance with the present invention. Watch Trigger Data Structure  may be created and populated when watch events are triggered (i.e., changes are made to watched data), thus triggering post operations, as described herein. In particular, the Watch Trigger Data Structure  may have substructures comprising a Watch_Post_Item Structure  and a Watch_Post_Set Structure .","Illustratively, as described herein, notification callbacks (aka \u201cposts\u201d) may be computed during the LOAD phase and committed during the MODIFY phase of appropriate file operation handlers. The watch process\/mechanism  uses one or more Watch_Post_Item structures , each of which represents a post, and a Watch_Post_Set structure , which is a container for all of the posts generated for a single file operation. For example, the Watch Trigger Data Structure  illustratively contains a list of actions to post (in Item Structures ), each post containing a watch-relative pathname and an action to be performed, and a summary mask for all of the post actions contained in the post set (in Set Structure ). During the MODIFY phase of file operations (described herein), Watch_Post_Set is walked, and paths are committed (allocated) and transferred from the Watch_Post_Item structures to slots in the appropriate Watch_Open Structures .",{"@attributes":{"id":"p-0149","num":"0150"},"figref":"FIG. 24","b":["2400","2400","1800","2400","2400"]},"In particular, Watch_Post_Item Structure  comprises one or more fields used to carry\/store associated information noted above. For instance, Next_pointer field  contains a pointer to a next post item () in a chain (e.g., empty if no further items exist). Open_pointer field  contains a pointer to the Watch_Open Structure  with which this post is associated. Watch_action field  contains the action associated for this post item. Primary_name field  contains information that corresponds to path_pointer  (below), and may be used, along with Watch_action , to uniquely identify post sources so that multiple posts may be collapsed, removed, etc. Path_pointer field  contains a relative path from the watched directory that the open (Watch_Open ) is associated with to the object that posted the watch (e.g., which, if null, signifies an error).","Also,  is an illustrative block diagram of an example Watch_Post_Set Structure  in accordance with the present invention. Illustratively, each Watch_Post_Set Structure  is used to contain all of the Watch_Post_Item Structures  that are processed by a file operation during its modify phase. In addition, Structure  contains a \u201croll-up\u201d of the post actions being signaled by the enclosed Post_Items , which is used to update the Post_generation field  of the associated Watch_Inode_Cache Structure  during the modify phase. According to an illustrative embodiment, the Watch_Post_Set Structure  may be allocated on a file operations stack, as may be appreciated by those skilled in the art.","Watch_Post_Set Structure  comprises one or more fields used to carry\/store associated information noted above. For instance, Action_mask field  contains a rollup of all of the individual actions contained in the individual post items . Post_count field  contains a number of elements in Item_pointer field , which contains a list of Watch_Post_Item Structures  (e.g., terminated by \u201cnull\u201d). Further, Watch_volume_pointer field  contains a pointer to the volume to which this post set relates (which may be null), and that may be used for the case when renaming a directory and the Inheritance_generation needs to be incremented during the MODIFY phase.","The last noted type of (in-core) data structure that may be used with the present invention is a Watch Global Data Structure.  is an illustrative block diagram of an example Watch Global Data Structure  in accordance with the present invention. Generally, there is one Watch Global Data Structure  per D-module . In particular, Watch Global Data Structure  comprises one or more fields used to carry\/store associated information noted above. For instance, Structure  may contain a global list of triggered watches in Post_list field , which carries a list of Watch_Open Structures  that have pending posts (notification callbacks) that remain in this list until processed. That is, Post_list  contains a list of watches which have posts after their last callback. It is this post_list  that is scanned in order to send notifies (callbacks). Further, as noted above, Post_generation field  may contain values that are incremented after each notification callback processing cycle, used to eliminate rapidly repeated duplicate posts. Lastly, various freelists  and other related data may be used for memory management, and summary statistics field  may contain other global variables\/statistics for the node (D-module) for watch operation processing (e.g., ASUP data as described below).","Watch Trigger Processing","In accordance with one or more embodiments of the present invention, the file system (e.g., watch process ) may check for watch triggers during particular file operations. For instance, there are three situations when triggers are checked: when an object is created or linked, when an object is modified, and when an object is deleted or unlinked. For example, the following file operations have the associated watch processing:","CLOSE: watch for delete;","CREATE: watch for create and watch for modify;","LINK: watch for create;","OPEN: watch for create and watch for modify;","RENAME: watch for create and watch for delete;","SET_ATTRIBUTES: watch for modify;","WRITE: watch for modify;","REMOVE; watch for delete; and","UNLINK: watch for delete.","Each of the forms of watch checking (create\/modify\/delete) may follow the same basic algorithm, although each may have its own customization. For example, while checking watches for deletes, actions need not be kept in an inode cache (), since the object is being removed or its link count is being reduced. Illustratively, watches are triggered during a LOAD phase of file operations, which is where the operating system  reserves necessary resources for the operation to ensure success of the operation. Specifically, if a watch triggers, the appropriate post(s) are computed in the LOAD phase. These posts may then be committed in a MODIFY phase of the file operations, which is where those reserved resources from the LOAD phase are committed. In this manner, the posts are not committed unless the entire file operation is successful.",{"@attributes":{"id":"p-0166","num":"0167"},"figref":["FIGS. 27 and 28","FIG. 27"],"b":["2700","2700","2705","2710","363","2700","2755","2200","2715","2715","2200","2720"]},"It step , a determination is made as to whether the Watch_Inode_Cache  shows that no watches are interested in this action. If there are no interested watches, an early out causes the procedure  to end in step . If, however, there is at least one interested watch in step , the system may then determine in step  whether this action has been posted for this object during this post generation cycle, as described herein. If so, an early out condition causes the procedure to end in step , but if not, the action needs to be posted. As such, if there is no cached path in Watch_Inode_Cache  in step , then the path may be computed to the farthest ancestor watch in step , e.g., using I2P walk with directory loads. Once the path is cached, Watch_Post_Set  is computed for the object (e.g., through an I2P walk), and the procedure  for the LOAD phase of a file operation ends in step .",{"@attributes":{"id":"p-0168","num":"0169"},"figref":"FIG. 28","b":["2800","2800","2805","2810","2200","2200","2745","2700","2820","2500","2822","2400","1800","1850","2824","2826","2610","2800","2830","2700","2800"]},"Note again that I2P\/ancestor walking (traversing I2P mappings), as described in detail above, may be used by watch process  to obtain the relative pathname of a file or directory by walking (e.g., bottom-up) through the file's or directory's ancestor chain. In other words, with the information stored in the inodes, walking backwards up the file-system tree from the filename to its ancestors is allowed, thus enable watch lookup and notification callback pathname construction, as described herein. In particular, the I2P walking is necessary to create or update an object's Watch_Inode_Cache Structure , compute an object's path (pathname) for posting, and compute the Watch_Post_Set  for an object, as described herein.","As an example, assume that a path exists from a root of the file system to an object \u201cx\u201d, and the full path (pathname) is \u201c\/a\/b\/c\/x\u201d, as will be appreciated by those skilled in the art. In the event that an inherited watch is set on directory \u201cb\u201d, when object \u201cx\u201d is modified (changed), an I2P walk is performed from \u201cx\u201d to \u201ca\u201d to discover that there is a watch at \u201cb\u201d that is interested in the change. Once the interested watch is located, another I2P walk may be performed to construct a relative pathname from \u201cb\u201d to \u201cx\u201d (e.g., after an intermediate I2P walk to determine the distance from the changed object to the watched directory, accordingly), thus resulting in relative pathname \u201cc\/x\u201d that may be sent to the clients accordingly. These multiple I2P walks are necessary due to the fact that there may be multiple watches set up and down the path, so the watches (and distances) can be determined prior to constructing the pathname. As such, the caching techniques described herein may be advantageously utilized to reduce the number of I2P walks necessary during watch trigger processing. In accordance with one or more embodiments described herein, a notification callback (e.g., \u201cNOTIFY_CB\u201d) operation may be sent to inform N-modules  of watch posts (e.g., the pathnames) generated at D-modules  (e.g., within a CF Message ). The N-module (i.e., the device setting the watch, watch process ), in turn, may send notifications of these events (e.g., the pathnames) to the proper CIFS (e.g., Windows) client identified by the Watch_cookie  (of Watch_Instance ) given to the client as part of the callback. Illustratively, a file system backdoor message (or other dedicated thread and\/or timeout mechanism) may be used to trigger periodic generation of notification callback messages, such as at a timeout interval, e.g., one second. Clients may respond to the callback messages with requests to renew or cancel the associated watch (where renewing a watch maintains a current Watch_Open  intact, not adding another Watch_Instance ).","Notably, watches for volumes that are \u201cofflined\u201d or \u201cunmounted\u201d may illustratively maintain their state (as with the locks), such that upon returning (\u201conlined\u201d or \u201cremounted\u201d), the watches remain active. In this manner, watches may only be closed in response to a specific request from the client or if the corresponding file (or, illustratively, the corresponding lock) is deleted. Further, in the event of a \u201csendhome\u201d, as will be appreciated by those skilled in the art, locks and watches may be destroyed on the source node. When a watch is destroyed, any pending notification callbacks are consequently aborted\/ceased. Further, if a directory being watched by one client is deleted by another client, all existing watches on that directory are posted by D-module  with a watch action \u201cDELETE_PENDING\u201d, which indicates that the directory (or file within the directory) is about to be deleted by another client. This indication prompts the corresponding N-module  to respond to the appropriate CIFS (Windows) clients with DELETE_PENDING, as expected by the CIFS Change Notify features, as will be understood by those skilled in the art. Notably, as an added optimization, if a directory is marked as deleted by the system , but is still waiting on the last client to close the directory (e.g., DELETE_ON_CLOSE semantics of the CIFS protocol for DELETE_PENDING), any attempt made by clients to set watches on this deleted directory may be replied to with a DELETE_PENDING notification, without setting the watch on the deleted directory.","In addition, in accordance with one or more embodiments of the present invention, various support or \u201cauto support\u201d (ASUP) measurements (e.g., on per volume and per-node basis) may be kept with regard to the watch support. For instance, the following statistics, inter alia, may be kept (e.g., in global statistics field  and\/or volume statistics field ): the number of times an inode watch cache was valid and reused (\u201ccache hits\u201d), the number of times an inode watch cache was updated, but not allocated (\u201ccache updates\u201d), the number of times an inode watch cache was created (\u201ccache creates\u201d), the number of times watch I2P walks to the root of the volume were performed (\u201cI2P root walks\u201d), the number of times single level watch I2P walks were performed (not to root of volume) (\u201cI2P single level walks\u201d), the number of I2P walks to compute watch paths that cause the directories to be loaded (\u201cI2P path walks\u201d), the number of times cached paths were good (\u201cI2P path cache hits\u201d), the average path lengths of watch paths (e.g., in elements not bytes) (\u201cI2P path length average\u201d), the number of times watch post processing was averted because of cache hits (\u201cpost cache hits\u201d), the number of I2P walks to compute watch posts (\u201cpost walks\u201d), the number of watch posts (\u201cwatch posts\u201d), the number of directories that are being watched (\u201cwatched directories\u201d), etc.","Watch Support for Volume Moves","Volumes are often moved between nodes of a cluster, and the expectation is that the move is completely transparent to clients, i.e., no outage to file access or loss of state. Because watches represent a Change Notify state, the watches (and associated information) also need to be moved. As such, according to another aspect of the present invention, if the logical volumes are moved from a first storage device (e.g., serviced by a first D-module  of a clustered storage system) to a second storage device (e.g., serviced by a second D-module ), the watches are retained during the move to the second storage device.","In particular, as noted herein, watches are closely paired with locks. As such, a new operation may be defined in accordance with the present invention to identify the presence of watch information along with the lock information to reproduce watch state on the destination of volume move. For example, a new flag may be set within a lock transfer command to indicate that the lock has associated watches. (Note that this may allow for backward compatibility with systems not supporting watches.)",{"@attributes":{"id":"p-0176","num":"0177"},"figref":"FIG. 29","b":["2900","2900","2905","2910","2915","1800","1900","2910","2915","2900"]},{"@attributes":{"id":"p-0177","num":"0178"},"figref":"FIG. 30","b":["3000","3000","3005","3010","350","350","3010","2610","3015","3020","3025","2900","2900","300","3030","3000","3035"]},"Note that for local volume moves (i.e., volume moves within control of a same D-module ), watches need not be recreated. Instead, the watches may remain attached to their Watch_Directory  (and associated locks), and the volume_pointer  in the Watch_Directory  is reassigned, and watch counters (generation numbers) from the old volume are copied to the new volume. Since there are no outstanding posts at this point (i.e., have been flushed), the Global Post_list  is empty on the source volume. The new volume watch information, including the generation numbers and counters are reinitialized, so that all inode caches are invalidated and will trigger a \u201cslow-path\u201d approach during posting (that is, does not have the benefits of the caching, as described above).","In summary, the present invention advantageously overcomes the disadvantages of the prior art by providing a system and method for supporting Change Notify watches in virtualized storage systems. In particular, techniques of the present invention emulate Change Notify features (e.g., as documented by the CIFS protocol) on virtualized storage systems by leveraging virtualization mapping information (e.g., an inode-to-path or \u201cI2P\u201d mapping) to walk a file system tree backwards from the data blocks to their ancestors to obtain a pathname of the watched data. Also, performance may be enhanced using various caching techniques, and watch state may be retained while moving watched data across volumes of the virtualized storage system.",{"@attributes":{"id":"p-0180","num":"0181"},"figref":"FIG. 31","b":["3100","3100","3105","3110","3115","3120","3125","3130","3135","350","310","3125"]},"If the watch defines an action, that action may be taken in step . Also, if there are a plurality of set watches on the changed data in step , then each action defined by each of the plurality of watches may be taken in step  (e.g., as described above, multiple posts\/callbacks). In step , however, triggered watch events may be cached to prevent duplicate reports, and to prevent traversal of the mapping based on previously stored pathnames. The procedure  ends in step .","While there have been shown and described illustrative embodiments that supporting Change Notify watches in virtualized storage systems, it is to be understood that various other adaptations and modifications may be made within the spirit and scope of the present invention. For example, the embodiments have been shown and described herein in conformance with CIFS and associated Change Notify features\/functionality. However, the embodiments of the invention in its broader sense are not so limited, and may, in fact, be used with the Network File System (NFS) protocol. Further, while volumes are illustratively organized using inodes, the techniques described herein may be equally applicable to any type of volume organization, and the volume need not comprise an inode tree structure.","In addition, certain storage system vendors have implemented various forms of I2P mapping functionality. For example, the Novell NetWare system stores character strings of all of the names associated with an inode within the inode itself. However, inodes are typically fixed sized data structures and if a sufficient number of names are associated with an inode, additional \u201cspill over\u201d inodes must be allocated for the data container. Such a solution increases the complexity of managing data and utilizes extra and valuable inode numbers, which may be limited within the file system. Alternately, the Solaris operating system, available from Sun Microsystems, Inc., stores a pathname in the in-memory vnode data structure. However, modifications to the names of any directories in the pathname are not updated in the cached path within the vnode. Should a directory be renamed, the cached pathname data within the vnode data structure is not updated, which can result in incorrect pathnames being presented to an administrator. Another noted disadvantage is that no pathname information is stored persistently. Accordingly, while the inode tree structure and I2P mapping techniques described above are merely one representative example of mapping that may be used with the present invention, it may be appreciated by those skilled in the art that other, albeit possibly less efficient, mapping techniques may also be used in conjunction with the present invention.","The foregoing description has been directed to particular embodiments of this invention. It will be apparent, however, that other variations and modifications may be made to the described embodiments, with the attainment of some or all of their advantages. Specifically, it should be noted that the principles of the present invention may be implemented in non-distributed file systems. Furthermore, while this description has been written in terms of N and D-modules, the teachings of the present invention are equally suitable to systems where the functionality of the N and D-modules are implemented in a single system. Alternately, the functions of the N and D-modules may be distributed among any number of separate systems, wherein each system performs one or more of the functions. Additionally, the procedures, processes and\/or modules described herein may be implemented in hardware, software, embodied as a computer-readable medium having program instructions, firmware, or a combination thereof. Therefore, it is the object of the appended claims to cover all such variations and modifications as come within the true spirit and scope of the invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The above and further advantages of invention may be better understood by referring to the following description in conjunction with the accompanying drawings in which like reference numerals indicate identical or functionally similar elements:",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 16A"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 16B","FIG. 16A"]},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 31"}]},"DETDESC":[{},{}]}
