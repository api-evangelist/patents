---
title: Language neutral text verification
abstract: A resource string associated with output text is identified. A regular expression pattern is generated from the resource string. The regular expression pattern is matched to the output text. A verification result based on the matching of the regular expression pattern to the output text is provided.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07949670&OS=07949670&RS=07949670
owner: Microsoft Corporation
number: 07949670
owner_city: Redmond
owner_country: US
publication_date: 20070316
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["In many situations, textual data needs to be verified and elements of interest within the text need to be extracted. Some common examples include verifying the output generated by an application and picking out variables that need to be validated in areas like software testing, analyzing a log file generated by an application, extracting diagnostic information for identifying reasons for failures in Product Support Services, and extracting information from the output of an application while developing scripts for administrative Information Technology (IT) tasks.","Existing mechanisms for text verification are inadequate. First, text is localized into many languages. Any verification code that depends on the specific text needs to be changed\/re-implemented for each language, making it costly. Such verification code also scales poorly as the number of languages text is localized to increases. Second, the stability of such verification code is low because there can be ambiguity in where the elements of interest start and end in the text. In such situations, the verification code will fail.","The following presents a simplified summary of the disclosure in order to provide a basic understanding to the reader. This summary is not an extensive overview of the disclosure and it does not identify key\/critical elements of the invention or delineate the scope of the invention. Its sole purpose is to present some concepts disclosed herein in a simplified form as a prelude to the more detailed description that is presented later.","Embodiments of the invention provide language neutral text verification. A regular expression pattern is dynamically created from the resource string corresponding to the text to be verified. The text to be verified is matched with the generated regular expression. The pattern match accomplishes text verification and information extraction together. In one example, embodiments of the invention may be used in software testing.","Many of the attendant features will be more readily appreciated as the same become better understood by reference to the following detailed description considered in connection with the accompanying drawings.","The detailed description provided below in connection with the appended drawings is intended as a description of the present examples and is not intended to represent the only forms in which the present examples may be constructed or utilized. The description sets forth the functions of the examples and the sequence of steps for constructing and operating the examples. However, the same or equivalent functions and sequences may be accomplished by different examples.","Embodiments of the invention utilize resource strings and regular expression based pattern matching for text verification and information extraction. In short, the problem of text verification and information extraction is reduced to one of pattern matching. From a resource string, a regular expression pattern is dynamically generated. The text to be verified is matched with this regular expression pattern. The pattern match accomplishes text verification and information extraction together.","The term \u201ctext\u201d refers to characters (e.g., letter, number, punctuation mark, etc.) and\/or symbols that represent human speech. \u201cText\u201d is often manipulated by computing devices using strings. A string includes a data structure composed of a sequence of characters usually representing human-readable text.","Embodiments of language neutral text verification as described herein provide numerous advantages. First, is language neutrality; an implementation based on this approach will work irrespective of what language the text is localized into. Deriving the pattern from resource strings makes the solution language neutral. As text changes with localization, the resource string also changes, but the verification code itself remains unchanged.","Embodiments herein scale well when text is localized into more and more languages. Since the generation of the regular expression pattern is dynamic, no changes to verification code are required. It automatically works on new languages. Also, language neutral text verification is robust; pattern matching with regular expressions handles ambiguous situations well.","Further, embodiments herein are efficient; regular expression pattern matching tools are highly optimized for text processing. Embodiments herein are also simple to implement. Text verification code based on techniques described herein is simpler to implement because it uses pattern matching tools to perform complex text comparisons and searches. The text verification code itself is very light-weight.","Embodiments of the invention are described below in the context of software testing. The software testing examples presented below involve verifying output text generated by a command line application and extraction of information from the output text. However, one skilled in the art having the benefit of this description will appreciate that embodiments of the invention may be used in other situations involving text verification.","Consider the command line application and its output text shown in . In , the Command Line Interface (CLI) for backup application \u201cwbadmin\u201d is shown at . The output text is shown at .","The output text  includes two parts: static text and variables. As used herein, static text includes text that comes straight from the resource string and is constant for a human language. It does not vary with application state or environmental factors for a given language. The non-italicized text (e.g., \u201cVersion identifier:\u201d shown at ) represents static text. This text may be verified for equivalence character by character.","As used herein, a variable includes data generated at runtime by the application and varies from installation to installation, time to time, depending on state information and environment. In , all the italicized text (e.g., \u201c4\/30\/2006 7:17 AM\u201d shown at ) are variables. A verification test may extract and use the variables for other further verifications. For example, follow-on tests may include restoring data from the backup taken at the variable \u201c4\/30\/2006 7:17 AM\u201d shown at .","The following discusses existing approaches for text verification and their shortcomings in different circumstances. Approaches for verifying static text and extracting variable information from text are examined.","Verifying static text involves ensuring that static text is correct. For example, verifying that the command's output should read \u201cwbadmin 1.0\u2014Backup command-line tool\u201d (shown at ) instead of something else like \u201caslkdfaldskf\u201d. Some of the existing techniques accomplish this by looking for some expected string in the text. For example, static text like \u201cBackup Identifier\u201d may be tied to the verification code, and the code would search for this string in the output. The problem with this approach is that it will not work across all languages that the application might be localized to. Referring to , the output text  is outputted in the German language from German CLI . Clearly, a static text verification of looking for \u201cBackup Identifier\u201d it will definitely not work for German output text . There is no \u201cBackup Identifier\u201d string in German output text .","Extracting variable information in text involves extracting variables, such as the Backup time , from the output of the application. Existing techniques may accomplish this in several ways: pick characters based on position within the text (e.g., pick n characters starting at position m), tokenize the output based on some separator (e.g., a space) and pick out the ntoken, or pick characters based on relative position (e.g., pick all characters after \u201cthe\u201d and before \u201c\\n\u201d).","There are several problems associated with these approaches. For example, if text is localized to a different language, the position of the variable changes. In the backup application output in , Backup time starts at the 13character in English (shown at ), while Backup time starts at 20character in German (shown at ). Verification relying on position of variables will not work correctly in this case.","Where information extraction involves tokenizing text based on separators, the variable itself might have the separator character. In such cases, the variable will span many tokens. For example, in , Backup target comprises 4 tokens in English (shown at ), while the backup target in German comprises 6 tokens (shown at ). Verification relying on tokenizing text will fail in such a case.","In another case, the order in which variables appear in the output may vary from language to language.  shows a resource string having variables \u201c% 1\u201d and \u201c% 2\u201d. The output text is displayed when some operation (variable \u201c% 1\u201d) could not be performed on a file (variable \u201c% 2\u201d). In the English version of the resource string (shown at ), the operation comes first, followed by the file. In the Finnish version (shown at ), the file comes first, followed by the operation.","In another case, there is a possibility of ambiguity where the variable ends and static text begins. In , resource string  shows the static text with the placeholder {} for the variable. In output  (shown at ), \u201cworld\u201d following \u201cdear\u201d is part of the variable. In output  (shown at ), \u201cworld\u201d following \u201cdear\u201d is part of static text. Thus, there is ambiguity here. Approaches that extract variables based on their relative position, such as extracting text between \u201cHello\u201d and \u201cworld\u201d, will fail in such cases.","Turning to , a flowchart  shows the logic and operations of language neutral text verification in accordance with an embodiment of the invention. In one embodiment, at least a portion of the logic of flowchart  may be implemented as computer readable instructions. Embodiments of a computing device to execute such computer readable instructions are discussed below in conjunction with .","Starting in block , the resource string(s) that comprise the text to be verified are identified. In most modern applications, output text is generated from resource strings. Examples of textual output include textual output printed at a console, text visible on a Graphical User Interface, text written in log files for diagnosis, and the like. For a given application, it is possible to find which resource strings are being used to generate the text. For example, in an application developed using Microsoft Visual Studio\u00ae, resource strings may be found in the application's resource file. Resource strings may also be found in a compiled resource file, also called a Resource Dynamic-Link Library (DLL) or a resource assembly, installed with the application that can be examined using a binary resource editor. Referring to , a resource string  is shown for generating output text . In an embodiment discussed below in , the output text and the corresponding resource string are passed as an input to a language neutral text verification application.","Proceeding to block , a regular expression pattern is generated from the resource string(s). In one embodiment, the regular expression pattern is generated from the resource string by replacing format specifiers in the resource string with named captures. Format specifiers are placeholders in resource strings that would be replaced by variables at run time by the application. When the actual pattern matching happens in block , the variables will get captured in the named captures of the regular expression.","Referring to , for resource string , the regular expression pattern  generated after replacing format specifiers with regular expressions is shown. Resource string  includes static text \u201cBackup time:\u201d followed by a variable (shown by placeholder {}), static text \u201cBackup target:\u201d followed by a variable (shown by placeholder {}), and static text \u201cVersion identifier:\u201d followed by a variable (shown by placeholder {}). In generated regular expression pattern , the symbol \u201c.+\u201d causes one or more characters to be captured at the named capture (such as \u201ccapture\u201d). The symbol \u201c\\n\u201d caused the regular expression to refer to a new line.","It will be appreciated that the regular expression pattern is generated dynamically from the resource string. This enables the regular expression pattern to take into account variations from different languages after an application has been localized to a particular country or region. Also, ambiguities between static text and variables are easily resolved when the regular expression pattern is built from the application's localized resource strings.","Generating the language neutral verification pattern from the resource string may involve various complexities. Cases where the resource string contains some special characters that can affect the pattern match and cases where the variables span multiple lines are some of the issues that need to be considered when generating the regular expression pattern. Consider the case where the resource string contains some special characters. In most regular expression parsers, certain characters have special significance. For example, in the Microsoft\u00ae .NET Framework regular expression parser, the character $ (dollar) is considered as an end-of-line marker. Now consider a resource string \u201cPay me $% 1\u201d. Consider the output text \u201cPay me $100\u201d. This output text is generated from the resource string, and the language neutral text verification algorithm must succeed in matching the output, and extracting the variable . However, the .NET Framework regular expression parser considers the $ character as an end-of-line marker. Because of this, the pattern matching fails because \u201cPay me\u201d is not at the end of line. To avoid this, the algorithm makes use of the escape character \\ (back-slash) to remove the special meaning of $ (dollar). In the example resource string, the dollar is preceded by a back-slash, like \u201cPay me \\$% 1\u201d. Now the regular expression parser performs the match correctly. In the case where a variable can span multiple lines, a symbol \u201c(.|\\n)+\u201d can be used instead of \u201c.+\u201d because the .NET Framework regular expression parser does not allow a \u201c.\u201d (dot) character to match a newline.","Continuing to block , the regular expression pattern is matched with the output text. The pattern matching algorithm uses a regular expression based pattern matching tool and matches the text with the generated regular expression pattern. Also, if the regular expression pattern includes any named captures, values for variables are captured in the named captures. For example, in , output text  which needs to be verified is matched against generated regular expression pattern . Example pattern matching tools that may be used include, but are not limited to, the Microsoft\u00ae .NET Regular Expression class library or the Perl interpreter.","Next, in block , the verification results are provided. The verification results may be stored, such as on a local or network storage, or the results may be sent to an output device, such as a printer or a display monitor.","In one embodiment, if the match succeeds (i.e., passes), it means: output is a valid instance of the resource string (i.e., the logic of flowchart  has verified that output has been generated from the resource string by the application), the static text in the output matches the resource string verbatim, and the variables have been extracted from the output. In short, if the match succeeds, the verification has passed, output is validated and variable information has been extracted. For example, in , pattern matching will evaluate to true and the captures (as shown at ) have been completed. In , captured variable data is shown for \u201ccapture\u201d, \u201ccapture\u201d, and \u201ccapture\u201d. If the pattern match fails, it means the output text is not as expected. The pattern match may fail when the text to be verified is not a valid instance of the resource string or static text in the text to be verified does not match the resource string. Thus, the text verification fails.","Turning to , an embodiment of a language neutral text verification application  is shown. Components of application  may implemented as one or more computer readable modules executable by a computing device.","Language neutral text verification application  includes a resource string finder , a regular expression pattern generator , and a pattern matching tool . Resource string finder  finds the resource string(s) that are used to generate text . Text  is the text to be verified. In the embodiment of , resource string finder  access the application resource file  of the application that produced text . Application resource file  may include a compiled resource file. Resource string finder  extracts the relevant resource string(s) and passes them to regular expression pattern generator .","In one embodiment, resource string finder  receives user input  to use in finding the resource string(s). In one example, user input  may include a resource string identification (ID) for the resource string of interest. Resource string finder  may then use the resource string ID to read the resource string from application resource file . In another embodiment, user input  includes at least a portion of the text from the text to be verified . Resource string finder  uses the provided text to iterate through the resource strings in application resource file  to find the matching resource string(s).","Regular expression pattern generator  takes the resource string(s) and outputs the regular expression pattern to be used for verification. Pattern matching tool  compares text  and the generated pattern received from regular expression pattern generator . Pattern matching tool  outputs the verification result .","Embodiments herein provide language neutral text verification using resource strings and regular expressions. Generating a language neutral text verification pattern dynamically from the resource string provides language neutrality. As text changes with localization, the resource string changes, but the verification code itself remains unchanged. The use of pattern matching provides robustness, efficiency and simplicity to the verification process. All the text processing, such as comparisons, extracting information, dealing with ambiguous situations, is handled by a pattern matching tool. The verification code implementation becomes simple but is still efficient and robust by virtue of using pattern matching.",{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 13","FIG. 13"]},"Although not required, embodiments of the invention are described in the general context of \u201ccomputer readable instructions\u201d being executed by one or more computing devices. Computer readable instructions may be distributed via computer readable media (discussed below). Computer readable instructions may be implemented as program modules, such as functions, objects, Application Programming Interfaces (APIs), data structures, and the like, that perform particular tasks or implement particular abstract data types. Typically, the functionality of the computer readable instructions may be combined or distributed as desired in various environments.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 13","FIG. 13"],"b":["1300","1300","1302","1304","1304","1306"]},"In other embodiments, device  may include additional features and\/or functionality. For example, device  may also include additional storage (e.g., removable and\/or non-removable) including, but not limited to, magnetic storage, optical storage, and the like. Such additional storage is illustrated in  by storage . In one embodiment, computer readable instructions to implement embodiments of the invention may be in storage . Storage  may also store other computer readable instructions to implement an operating system, an application program, and the like.","The term \u201ccomputer readable media\u201d as used herein includes computer storage media. Computer storage media includes volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions or other data. Memory  and storage  are examples of computer storage media. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, Digital Versatile Disks (DVDs) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by device . Any such computer storage media may be part of device .","Device  may also include communication connection(s)  that allow device  to communicate with other devices. Communication connection(s)  may include, but is not limited to, a modem, a Network Interface Card (NIC), an integrated network interface, a radio frequency transmitter\/receiver, an infrared port, a USB connection, or other interfaces for connecting computing device  to other computing devices. Communication connection(s)  may include a wired connection or a wireless connection. Communication connection(s)  may transmit and\/or receive communication media.","The term \u201ccomputer readable media\u201d may include communication media. Communication media typically embodies computer readable instructions or other data in a \u201cmodulated data signal\u201d such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, radio frequency, infrared, Near Field Communication (NFC), and other wireless media.","Device  may include input device(s)  such as keyboard, mouse, pen, voice input device, touch input device, infrared cameras, video input devices, and\/or any other input device. Output device(s)  such as one or more displays, speakers, printers, and\/or any other output device may also be included in device . Input device(s)  and output device(s)  may be connected to device  via a wired connection, wireless connection, or any combination thereof. In one embodiment, an input device or an output device from another computing device may be used as input device(s)  or output device(s)  for computing device .","Components of computing device  may be connected by various interconnects, such as a bus. Such interconnects may include a Peripheral Component Interconnect (PCI), such as PCI Express, a Universal Serial Bus (USB), firewire (IEEE 1394), an optical bus structure, and the like. In another embodiment, components of computing device  may be interconnected by a network. For example, memory  may be comprised of multiple physical memory units located in different physical locations interconnected by a network.","In the description and claims, the term \u201ccoupled\u201d and its derivatives may be used. \u201cCoupled\u201d may mean that two or more elements are in contact (physically, electrically, magnetically, optically, etc.). \u201cCoupled\u201d may also mean two or more elements are not in contact with each other, but still cooperate or interact with each other (for example, communicatively coupled).","Those skilled in the art will realize that storage devices utilized to store computer readable instructions may be distributed across a network. For example, a computing device  accessible via network  may store computer readable instructions to implement one or more embodiments of the invention. Computing device  may access computing device  and download a part or all of the computer readable instructions for execution. Alternatively, computing device  may download pieces of the computer readable instructions, as needed, or some instructions may be executed at computing device  and some at computing device . Those skilled in the art will also realize that all or a portion of the computer readable instructions may be carried out by a dedicated circuit, such as a Digital Signal Processor (DSP), programmable logic array, and the like.","Various operations of embodiments of the present invention are described herein. In one embodiment, one or more of the operations described may constitute computer readable instructions stored on one or more computer readable media, which if executed by a computing device, will cause the computing device to perform the operations described. The order in which some or all of the operations are described should not be construed as to imply that these operations are necessarily order dependent. Alternative ordering will be appreciated by one skilled in the art having the benefit of this description. Further, it will be understood that not all operations are necessarily present in each embodiment of the invention.","The above description of embodiments of the invention, including what is described in the Abstract, is not intended to be exhaustive or to limit the embodiments to the precise forms disclosed. While specific embodiments and examples of the invention are described herein for illustrative purposes, various equivalent modifications are possible, as those skilled in the relevant art will recognize in light of the above detailed description. The terms used in the following claims should not be construed to limit the invention to the specific embodiments disclosed in the specification. Rather, the following claims are to be construed in accordance with established doctrines of claim interpretation."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Like reference numerals are used to designate like parts in the accompanying drawings.",{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 13"}]},"DETDESC":[{},{}]}
