---
title: Method and system for communicating between two independent software components of a device
abstract: A method and system for communicating between two independent software components of the WINDOWS® SIDESHOW™ device are disclosed. Specifically, one embodiment of the present invention sets forth a method, which includes the steps of independently queuing an incoming packet from a second software component via an emulated serial transport in a first software component before parsing and responding to the incoming packet and independently queuing an outgoing packet in the first software component before transmitting the outgoing packet to the second software component also via the emulated serial transport.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08032354&OS=08032354&RS=08032354
owner: NVIDIA Corporation
number: 08032354
owner_city: Santa Clara
owner_country: US
publication_date: 20071227
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["1. Field of the Invention","The present invention relates to WINDOWS\u00ae SIDESHOW\u2122 technology, and more particularly, to a method and system for communicating between two independent software components of a SIDESHOW\u2122 device.","2. Description of the Related Art","Unless otherwise indicated herein, the approaches described in this section are not prior art to the claims in this application and are not admitted to be prior art by inclusion in this section.","Windows\u00ae Vista\u00ae is a commercially available operating system from Microsoft Corporation of Redmond, Wash., hereinafter referred to as WINDOWS VISTA. Windows\u00ae SideShow\u2122 is a commercially available application program from Microsoft Corporation of Redmond, Wash., hereinafter referred to as WINDOWS SIDESHOW. With WINDOWS VISTA operating systems becoming the dominant operating systems for personal computers, a variety of software or hardware applications compatible with Vista-based computer systems are also becoming more and more popular. One of the Vista-based software\/hardware applications WINDOWS SIDESHOW, which is a technology that supports an auxiliary screen to the Vista-based computer system.","To illustrate,  is a simplified block diagram showing a software stack  for a WINDOWS SIDESHOW device. The software stack  includes a built-in gadget , a SIDESHOW Application Programming Interface (API) , a tiny media API , a tiny Common Language Runtime (CLR) , and an embedded operating system (OS) . Here, two distinct software components, such as the built-in gadget  and the embedded OS , communicate with each other via emulated serial transports such as virtual Universal Asynchronous Receiver Transmitter (UART) ports. Unlike their physical counterparts that directly access the hardware of the WINDOWS SIDESHOW device, these virtual UART ports are created to emulate the characteristics of the physical UART ports and to facilitate the communication between two software components. Specifically, for the built-in gadget  to access the hardware of the WINDOWS SIDESHOW device, the built-in gadget  may invoke function calls supported by the tiny media API , wherein the function calls further depend on routines that are supported by the tiny CLR . To abstract some of the operation details of the software stack  from the built-in gadget , some of the data or commands from the built-in gadget  are encapsulated and sent through virtual UART ports , so that the data or commands can be further operated on by the embedded OS .","However, there currently lacks a method or system to ensure the robustness of the communication between the aforementioned two independent software components through the emulated serial transports. More particularly, conventional methods or systems neither guarantee the success of the transfer of packets from one software component to another nor enable the software component that sends the packets to efficiently acquire the status of such transfer.","What is needed in the art is thus a method and system that enable two independent software components of the WINDOWS SIDESHOW device to communicate robustly and efficiently and address at least the problems set forth above.","A method and system for communicating between two independent software components of the WINDOWS SIDESHOW device are disclosed. Specifically, one embodiment of the present invention sets forth a method, which includes the steps of independently queuing an incoming packet from a second software component via an emulated serial transport in a first software component before parsing and responding to the incoming packet and independently queuing an outgoing packet in the first software component before transmitting the outgoing packet to the second software component also via the emulated serial transport.","At least one advantage of the present invention disclosed herein is to further improve the robustness of the communications between two independent software components in a WINDOWS SIDESHOW device.","Throughout this description, a computer system may include a main system and an auxiliary system. The main system typically is configured with a feature-rich operating system, such as WINDOWS VISTA, and much computing resources, such as central processing units (CPUs) and memory systems. The auxiliary system, on the other hand, is typically configured with embedded software programs and limited hardware resources. A \u201cprimary display\u201d broadly refers to the display mainly driven by the main system, and an \u201cauxiliary display\u201d broadly refers to the display that can be driven by either the main system or the auxiliary system. Here, an example of the main system is a laptop computer, and an example of the auxiliary system is a WINDOWS SIDESHOW device coupled to the laptop computer.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2","b":["200","202","204","206","202","208","210","212","204","214","216","218"]},"Outgoing packets of the first software component , whether containing commands, results of executions, or status information, are transferred by the first packet transmitter  to the second packet receiver  through the emulated serial transport . Once received by the second packet receiver , such outgoing packets are viewed as incoming packets from the perspective of the second software component . If the packets are successfully received, the second packet receiver  returns an acknowledgment signal indicative of the success to the first software component  through the emulated serial transport . If the packets are not successfully received, the second packet receiver  returns a non-acknowledgment signal indicative of the failure also back to the first software component . After successfully receiving the packets, the second packet receiver  sends the received packets to a receive queue (not shown), from which the second packet parser  retrieves the packets and looks into the content of the packets. If the packets received are command packets, the parsed commands will be executed, and the results of the executions are sent to the second packet transmitter . In one implementation, the second packet parser  generates the packets that contain the results and are sent. If the received packets are not command packets, such as packets containing responses or status information, no commands are executed. Instead, some application programs (not shown) may be notified of the responses or status information.","Similarly, the second packet transmitter  also transmits packets to the first packet receiver  through the emulated serial transport . After having successfully received the packets, the first packet receiver  returns an acknowledgement signal to the second software component . On the other hand, if the packets are not received successfully, the first packet receiver  returns a non-acknowledgment signal back to the second software component . The first packet receiver  then sends the packets to the receive queue, from which the first packet parser  retrieves the packets and looks into the content of the packets to decide whether to execute commands or to notify the first software component  of some execution results.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 3","FIG. 2","FIG. 1"],"b":["300","302","304","302","202","204","306","308","310","302","312","314","306","312","306","310","312","312","306","312","310","312","308","314","304","308"]},"In one implementation, the packet parser  generally recognizes two types of packets, a command packet and a response packet. A command packet contains a particular command intended to be executed, and a response packet contains results of executing a command. In one implementation, the response packet may also include error information associated with a failed operation. To illustrate, suppose an incoming packet is a command packet. After the packet parser  parses the packet, an application program corresponding to the command executes the command and places the execution results in a response packet to be sent back to the software component from which the command packet comes. This response packet to be transferred is first placed in the transmitter queue , which the packet transmitter  subsequently accesses. It should be noted that not all command packets require the recipient to respond with a response packet.","On the other hand, suppose the command is not executed properly. An error response packet is generated containing information associated with the failed execution and is placed in the transmitted queue  to be sent out. In another situation, suppose the packet transmitter  sends out an outgoing packet and receives a predetermined number of non-acknowledgement notifications over a predetermined amount of time. Here, the packet transmitter  also generates an error response packet with information indicative of this detected error condition and actually places this error response packet in the receiver queue  of the same software component . Subsequent paragraphs further detail the interactions among the various sub-components within the software component .",{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 4","FIG. 3","FIG. 3"],"b":["400","306","402","306","304","404","306","406","304","306","408","304","410","306","312","412","310","304"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 5","FIG. 3"],"b":["500","310","502","310","312","504","310","310","506","310","508"]},"On the other hand, if the packet in the receiver queue  is the command packet, then the packet parser  invokes the application program corresponding to the command to execute it in step . The application program, in one implementation, is external to the software component  and even the software component communicating with the software component . It should also be noted that the packet parser  continues to check if there is another packet in the receiver queue  during the execution of the command. After such execution is done, the packet parser  generates a response packet including the results of the execution and puts the response packet in the transmitter queue  in step . It is worth noting the steps of generating the response packets and the command packets are of higher priory than any other steps of the illustrated process . In other words, generating the response packets and the command packets is attended to by the packet parser  first, even if the packet parser  is still in the process of invoking an application program to execute the command, determining the packet type, or checking if there is any packet in the receiver queue .",{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 6","FIG. 3"],"b":["600","308","602","308","314","604","308","314","308","304","606","308","308","608","304","308","604","314","304","308","610","314","612","614","308","306","302","616"]},"The above description illustrates various embodiments of the present invention along with examples of how aspects of the present invention may be implemented. One embodiment of the present invention may be implemented as a program product for use with a computer system. The program(s) of the program product define functions of the embodiments (including the methods described herein) and can be contained on a variety of computer-readable storage media. Illustrative computer-readable storage media include, but are not limited to: (i) non-writable storage media (e.g., read-only memory devices within a computer such as CD-ROM disks readable by a CD-ROM drive, ROM chips, or any type of solid-state non-volatile semiconductor memory) on which information is permanently stored; and (ii) writable storage media (e.g., floppy disks within a diskette drive or hard-disk drive or any type of solid-state random-access semiconductor memory) on which alterable information is stored. The above examples, embodiments, instruction semantics, and drawings should not be deemed to be the only embodiments, and are presented to illustrate the flexibility and advantages of the present invention as defined by the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["So that the manner in which the above recited features of the present invention can be understood in detail, a more particular description of the invention, briefly summarized above, may be had by reference to embodiments, some of which are illustrated in the drawings. It is to be noted, however, that the drawings illustrate only typical embodiments of this invention and are therefore not to be considered limiting of its scope, for the invention may admit to other equally effective embodiments.",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 5","FIG. 3"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 6","b":"3"}]},"DETDESC":[{},{}]}
