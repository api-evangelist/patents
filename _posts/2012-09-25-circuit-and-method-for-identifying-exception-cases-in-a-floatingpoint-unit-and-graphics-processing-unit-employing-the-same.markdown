---
title: Circuit and method for identifying exception cases in a floating-point unit and graphics processing unit employing the same
abstract: A floating-point unit and a method of identifying exception cases in a floating-point unit. In one embodiment, the floating-point unit includes: (1) a floating-point computation circuit having a normal path and an exception path and operable to execute an operation on an operand and (2) a decision circuit associated with the normal path and the exception path and configured to employ a flush-to-zero mode of the floating-point unit to determine which one of the normal path and the exception path is appropriate for carrying out the operation on the operand.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09448806&OS=09448806&RS=09448806
owner: Nvidia Corporation
number: 09448806
owner_city: Santa Clara
owner_country: US
publication_date: 20120925
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application is directed, in general, to a floating-point unit (FPU) in a processor and, more specifically, to a circuit and method for identifying exception cases in an FPU and a graphics processing unit (GPU) employing the circuit or the method.","Most modern processors are capable of performing arithmetic operations on values represented in floating-point notation. Floating-point arithmetic operations, including addition, subtraction, multiplication, division, and square root, are executed by an FPU within the processor. Floating-point arithmetic is often the foundation of graphics processing performed by both central processing units (CPU) and GPUs. IEEE Standard 754, developed by the Institute of Electrical and Electronic Engineers, sets forth the standard for binary floating-point arithmetic operation. IEEE 754 compliance and the efficiency of floating-point computations have received increasing attention as the demand for accelerated graphics processing has increased.","In the context of binary computers, a floating-point number is represented as a sign (a digit or string of digits representing a plus or minus), a mantissa or significant (a string of digits representing a number that is multiplied by a base of two raised by an exponent), and an exponent (a string of digits representing a number that is to raise a base of two). IEEE defines several floating-point formats varying in terms of the precision they represent. The total space allocated for representing a floating-point number can be, for example 32 bits, for single precision, or 64 bits, for double precision.","A correct implementation of IEEE 754 functionality requires algorithms designed to handle both normal and exception cases arising in floating-point arithmetic. Accordingly, modern FPUs typically employ distinct normal and exception computation paths, thus making path selection a critical stage in arithmetic execution. To satisfy the IEEE 754 standard, compliant FPUs are designed to recognize exception cases and then execute the exception path to produce the appropriate result, because an exception case processed via the normal path may produce an invalid result, a result that cannot be represented in floating-point notation, or possibly no result at all.","One aspect provides a FPU. In one embodiment, the FPU includes: (1) a floating-point computation circuit having a normal path and an exception path and operable to execute an operation on an operand and (2) a decision circuit associated with the normal path and the exception path and configured to employ a flush-to-zero mode of the FPU to determine which one of the normal path and the exception path is appropriate for carrying out the operation on the operand.","Another aspect provides a GPU. In one embodiment, the GPU includes: (1) a control unit, (2) a plurality of processing cores coupled to the control unit, each of the plurality of processing cores having a memory and a FPU, the FPU including: (2a) a floating-point computation circuit having a normal path and an exception path and operable to execute an operation on an operand retrieved from the memory and (2b) a decision circuit associated with the normal path and the exception path and configured to employ a flush-to-zero mode of said FPU to determine which one of the normal and the exception path is appropriate for carrying out the operation on the operand.","Another aspect provides a method of identifying exception cases for a floating-point operation. In one embodiment, the method includes: (1) receiving an operand for processing according to the particular floating-point operation, (2) configuring a FPU in which the floating-point operation is to be executed to employ a flush-to-zero mode, and (3) initiating the floating-point operation, the flush-to-zero mode employing the operand in performing the identification.","Floating-point arithmetic operations may be executed faster by increasing processor clock speed. However, it is not a simple matter to increase clock speed, and cost, complexity and yield issues abound such that designers find themselves realizing diminishing returns. Consequently, designers have focused their attention on specialized hardware to execute the operations in fewer clock cycles. However, it is realized herein that some possibilities exist to increase execution speed by changing the way in which the floating-point arithmetic algorithms are executed.","From a conventional perspective, IEEE 754 floating-point algorithms are widely implemented, finely tuned, and leave little room for optimization. However, it is realized herein that conventional tests for identifying exception cases require extra bit manipulation to extract and compare exponents and are costly with respect to processing resources. Consequently, it is realized herein that were the identification and path selection process made more efficient, overall execution speed can increase. It is realized herein that, contrary to conventional practice, a flush-to-zero mode of a FPU may be employed in an IEEE 754 compliant floating-point arithmetic algorithm.","A normal floating-point value has no leading zeros in its mantissa. Leading zeros are instead represented in the exponent. For example, the value 0.01234 is represented as 1.234 \u00d710. The limited range of the exponent creates a gap around zero where very small values cannot be represented to full floating-point precision. This gap is known as the underflow gap. Floating-point values with a magnitude in the underflow gap are considered denormal, or more specifically sub-normal, and require leading zeros (i.e., precision loss) in the mantissa to represent a value closer to zero than the smallest normal number. To maintain IEEE 754 compliance, floating-point algorithms are designed to handle denormal numbers by trapping them in software or by the addition of specialized hardware. For this reason, computations involving denormal numbers are generally low performance, computationally expensive, or both.","However, as stated above, compliant FPUs provide a flush-to-zero mode that, when enabled, replaces denormal numbers with zeros. Absent additional action, this mode renders the floating-point operation non-compliant with respect to IEEE 754. For this reason, use of the flush-to-zero mode is widely discouraged. Realized herein is a use of the flush-to-zero mode that strays from the traditional purpose of prohibiting denormal numbers and does not frustrate IEEE 754 compliance.","It is realized herein that employing the flush-to-zero mode in certain floating-point operations within a floating-point arithmetic algorithm supplants the traditional costly tests for exception cases by yielding readily identifiable results, in exception cases, that serve as markers that propagate down the computation stream where they can be captured in an efficient manner. Once the markers are captured, the algorithm selects the exception computation path, thus completing IEEE 754 compliance. Otherwise, in normal cases, the floating-point computation assumes the normal computation path.","Before describing various embodiments of the novel circuit and method for identifying exception cases in a FPU, a computing system within which the circuit may be embodied or the method carried out will be described.",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1","b":["100","100","132","102","108","104","106","110","102","106","132","106"]},"As shown, the system data bus  connects the CPU , the input devices , the system memory , and the graphics processing subsystem . In alternate embodiments, the system memory  may connect directly to the CPU . The CPU  receives user input from the input devices , executes programming instructions stored in the system memory , operates on data stored in the system memory , and configures the graphics processing subsystem  to perform specific tasks in the graphics pipeline. The system memory  typically includes dynamic random access memory (DRAM) used to store programming instructions and data for processing by the CPU  and the graphics processing subsystem . The graphics processing subsystem  receives instructions transmitted by the CPU  and processes the instructions in order to render and display graphics images on the display devices .","As also shown, the system memory  includes an application program , an application programming interface (API) , and a graphics processing unit (GPU) driver . The application program  generates calls to the API  in order to produce a desired set of results, typically in the form of a sequence of graphics images.","The graphics processing subsystem  includes a GPU , an on-chip GPU memory , an on-chip GPU data bus , a GPU local memory , and a GPU data bus . The GPU  is configured to communicate with the on-chip GPU memory  via the on-chip GPU data bus  and with the GPU local memory  via the GPU data bus . The GPU  may receive instructions transmitted by the CPU , process the instructions in order to render graphics data and images, and store these images in the GPU local memory . Subsequently, the GPU  may display certain graphics images stored in the GPU local memory  on the display devices .","The GPU  includes one or more streaming multiprocessors . Each of the streaming multiprocessors  is capable of executing a relatively large number of threads concurrently. Advantageously, each of the streaming multiprocessors  can be programmed to execute processing tasks relating to a wide variety of applications, including but not limited to linear and nonlinear data transforms, filtering of video and\/or audio data, modeling operations (e.g., applying of physics to determine position, velocity, and other attributes of objects), and so on. Of the processing tasks, floating-point processing is allocated to a FPU and integer processing is allocated to an arithmetic logic unit (ALU). The GPU  may be provided with any amount of on-chip GPU memory  and GPU local memory , including none, and may use on-chip GPU memory , GPU local memory , and system memory  in any combination for memory operations.","The on-chip GPU memory  is configured to include GPU programming code  and on-chip buffers . The GPU programming  may be transmitted from the GPU driver  to the on-chip GPU memory  via the system data bus .","The GPU local memory  typically includes less expensive off-chip dynamic random access memory (DRAM) and is also used to store data and programming used by the GPU . As shown, the GPU local memory  includes a frame buffer . The frame buffer  stores data for at least one two-dimensional surface that may be used to drive the display devices . Furthermore, the frame buffer  may include more than one two-dimensional surface so that the GPU  can render to one two-dimensional surface while a second two-dimensional surface is used to drive the display devices .","The display devices  are one or more output devices capable of emitting a visual image corresponding to an input data signal. For example, a display device may be built using a cathode ray tube (CRT) monitor, a liquid crystal display, or any other suitable display system. The input data signals to the display devices  are typically generated by scanning out the contents of one or more frames of image data that is stored in the frame buffer .","Having described a computing system within which the circuit and method for identifying exception cases in a FPU may be embodied or carried out, various embodiments of the circuit and method will be described.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 2","FIG. 1"],"b":["200","124","200","202","208","200"]},{"@attributes":{"id":"p-0029","num":"0028"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Sample of an floating-point division algorithm Implementation"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2002(1)",{"sub":["\u2014\u2014","\u2014\u2014"]}]},{"entry":["\u2002(2)","unsigned int a_exp = float_as_int(a) & 0xff800000u;"]},{"entry":[{},"\/* adjust the exponent of a *\/"]},{"entry":["\u2002(3)","float a_man = int_as_float((float_as_int(a) &"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"0x007fffffu) | 0x3f800000u);"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/* Newton-Raphson. *\/"]},{"entry":[{},"float y; \/\/ approx of 1\/b"]},{"entry":[{},"float q; \/\/ quotient"]},{"entry":[{},"float r; \/\/ remainder"]},{"entry":["\u2002(4)","asm(\u201crcp.ftz.approx.f32 %0,%1;\u201d : \u201c=f\u201d(y) : \u201cf\u201d(b));"]},{"entry":[{},"\/* FOLLOWING FMA'S MUST BE COMPILED WITH FTZ!!! *\/"]},{"entry":["\u2002(5)","r = fmaf_rn(\u2212b, y, 1.0);"]},{"entry":["\u2002(6)","y = fmaf_rn(y, r, y);"]},{"entry":["\u2002(7)","q = fmaf_rn(a_man, y, 0.0f);"]},{"entry":["\u2002(8)","r = fmaf_rn(\u2212b, q, a_man);"]},{"entry":["\u2002(9)","q = fmaf_rn(r, y, q);"]},{"entry":["(10)","r = fmaf_rn(\u2212b, q, a_man);"]},{"entry":["(11)","q = fmaf_rn(r, y, q);"]},{"entry":["(12)","q = fmaf_rn(q, int_as_float(a_exp), 0.0f); \/* readjust"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"the exponent of a *\/"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/* check for under\/over-flow *\/"]},{"entry":["(13)","unsigned int q_abs = float_as_int(q) & 0x7fffffffu;"]},{"entry":["(14)","if(q_abs > 0x0080000fu && q_abs < 0x7f800000u;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["(15)","return q;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["(16)","else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["(17)","return div_ieee_rn_noftz_slowpath(a, b);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In the embodiment of , the computation circuit  is divided into a normal path  and an exception path . The normal path , the exception path , and the decision circuit  are coupled by a local data bus . The local data bus  also couples the FPU  to a local memory . In other embodiments, the decision circuit  may be embedded in the computation circuit  data paths, and need not be separated by the local data bus  or any other data bus.","The local memory  is operable to retrieve, over the local data bus , an operand from an addressed memory location and to store an intermediate result and ultimately a final result from the computation circuit , also over the local data bus . In certain embodiments, multiple operands are stored and are retrievable from the local memory .","The FPU  is configured to perform floating-point operations in flush-to-zero mode. The computation circuit  is configured to perform a floating-point arithmetic computation by routing an arithmetic computation stream through the normal path  or the exception path . The decision circuit  is configured to select either the normal path  or the exception path .","The decision circuit  is operable to retrieve the operand from local memory  over the local data bus . The decision circuit  identifies an exception case by recognizing a marker in the operand. In certain embodiments, the marker may be any one or more of zero, infinity, and not-a-number (NaN). Also in other embodiments, where the normal path  is initiated before the decision circuit  determines whether the normal path  or the exception path  is appropriate, the decision circuit  is further operable to retrieve the intermediate results of floating-point operations performed in the computation circuit , and is operable to recognize the marker in the intermediate result. An occurrence of the marker in the operand, or alternatively in the intermediate result, indicates an occurrence of the exception case. For example, the code sample in Table 1, above, shows the normal path  is nearly entirely executed before a determination, in lines  through , is made as to whether the exception case has been encountered.","In the embodiment illustrated in , the decision circuit  is operable to select the exception path  of the computation circuit  at the occurrence of the exception case. Otherwise, the normal path  is employed for the computation, which, in certain embodiments, is operable at a faster speed than the exception path .",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 3","FIG. 3"],"b":["310","320","330","340","350"]},"Those skilled in the art to which this application relates will appreciate that other and further additions, deletions, substitutions and modifications may be made to the described embodiments."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION","p":["Reference is now made to the following descriptions taken in conjunction with the accompanying drawings, in which:",{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"}]},"DETDESC":[{},{}]}
