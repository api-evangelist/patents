---
title: System and method for processing and forwarding transmitted information
abstract: A system and method for handling a digital electronic flow between a first and second entity in which a flow policy is determined that is to be applied to the flow and the flow is then directed along a path in accordance with the policy. An ID is supplied for each flow and a tag associated with each flow which indicates the policy to be applied to its associated flow. Flows are also associated with one another, with associated flows having associated policies. In particular the flow may be processed or forwarded. The path may include a graph structure and virtual applications.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08929374&OS=08929374&RS=08929374
owner: Netronome Systems, Incorporated
number: 08929374
owner_city: Santa Clara
owner_country: US
publication_date: 20111226
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application is a continuation of, and claims priority under 35 U.S.C. \u00a7120 from, nonprovisional U.S. patent application Ser. No. 12\/064,585 entitled \u201cSystem and Method for Processing and Forwarding Transmitted Information,\u201d filed on Aug. 18, 2008, published as U.S. Pat. Pub. No. 2009\/0204723. Application Ser. No. 12\/064,585 in turn is a continuation of, and claims priority under 35 U.S.C. \u00a7120 and \u00a7365(c) from International Application No. PCT\/IB2006\/052933, filed on Aug. 23, 2006, and published as WO 2007\/023467 A3 on Mar. 1, 2007, which in turn claims priority from Great Britain Application No. 0517304.2, filed on Aug. 23, 2005, in the United Kingdom. The disclosure of each of the foregoing documents is incorporated herein by reference.","This invention relates to a system and method for handling transmitted information. More particularly it relates to a system and method of forwarding and processing a digital electronic flow between a first entity and a second entity.","According to the invention there is provided a system for handling a digital electronic flow between a first entity and a second entity, which includes a flow policy determining means for determining the policy to be applied to the flow; and a directing means for directing the flow along a determined path in accordance with the relevant flow policy.","The system may include a flow ID supplying and identifying means for initially supplying an ID for each new flow from the first entity and for subsequently identifying the ID of an existing flow.","The flow policy determining means may provide a policy tag for each flow, the tag being associated with the ID of that flow, and the tag indicating the policy to be applied to that flow.","The flow policy determining means may determine the flow policy to be applied to a flow when the flow is first received and it may vary the policy applied to a flow during its lifetime.","The system may also include an association determining means for determining if a first flow is to be associated with a second flow and for applying associated flow policies to associated flows.","At least one processing means may be included in the path. Similarly, at least one forwarding means may be included in the path.","The processing means may include a graph structure, a processor, a memory, a virtual machine, and\/or an application. The application may be an application running in kernel mode in a virtual machine or an application running in user mode in a virtual machine.","The forwarding means may include a graph structure, a network interface, a communication interface, a virtual switch, a virtual network interface and\/or a virtual stream interface.","In particular, the directing means may direct the flow along a path that includes a flexible graph structure. The graph structure may have sub-graph or nested graph structures. The graph structure may also have processing and\/or forwarding components","The system may include a processor having an operating system with at least one real time processing function, and an application hosted within a kernel of the operating system or a user space of the operating system, and in which the directing means directs at least a part of the flow along a path that includes the application.","The entities forming the path may be connected in parallel, in series, or any combination thereof. The path may include internal and\/or external components.","The flow policy determining means may be responsive to an application.","Further, the flow policy determining means may determine different flow policies for forward and return portions of a flow.","The flow policy determining means may determine the flow policy for a flow in accordance with any suitable criteria. In particular, these criteria may be memory usage, network bandwidth use, power dissipation, feedback from guest operating systems in virtual machines, feedback from applications, feedback from a processing means, and feedback from a forwarding means. They may also be fields in packet headers, data in packet payloads, and protocols and sets of protocols.","Similarly, the association determining means may associate flows in accordance with suitable criteria such as flows from a specific type of application, flows which use a specified protocol, flows which use a sub-protocol at a specified layer of the relevant protocol hierarchy, specified patterns in a specified part of traffic, flows associated with a specified set of communicating entities, flows from a contained path, and flows from specified links, networks and network interfaces.","Further according to the invention there is provided a method of handling a digital electronic flow between a first entity and a second entity, which includes determining a policy to be applied to a flow; and directing the flow along a determined path in accordance with the relevant flow policy.","Initially an ID may be supplied for each new flow from the first entity with the ID of an existing flow being subsequently identified.","The method may include providing a policy tag for each flow and associating the tag with the ID of that flow, the tag indicating the policy to be applied to that flow.","As indicated above at least one processing means and\/or one forwarding means may be included in the path.","The flow policy to be applied to a flow may be determined when the flow is first received and may be varied during its lifetime.","The method may further include determining if a first flow is to be associated with a second flow and applying associated flow policies to associated flows.","The flow may be directed along a path that includes a flexible graph structure, that includes an application hosted within a kernel or a user space of an operating system having at least one real time processing function, that includes a plurality of entities connected in parallel and\/or in series, or includes internal and\/or external components.","The flow policy may be determined in response to an application and the flow policy may be different for forward and return portions of a flow.","The first and second entities may be network or communication devices, networking equipment (e.g. bridges\/routers\/switches), network nodes, computers, applications, tasks, processes, services, users, or other software or hardware systems.","The system may be connected to a network or other communication system in such a way that network traffic or other transmitted information is forced to traverse the system. Transmitted information may also originate at, terminate at, or traverse the system by virtue of the transmitted information having been appropriately constructed or formulated, e.g. by the information being addressed to the system using an appropriate address (e.g. a layer two networking address). Thus the system may be a router, a switch, a \u201cbump in the wire\u201d bridge, a \u201cself learning\u201d multi-port bridge, a relay, a proxy, or a gateway.","Furthermore, the system may comprise one or more processors or co-processors. If it has a plurality of processors\/coprocessors, they may be interconnected using one or more of: physically shared memory; virtually shared memory implemented using a remote direct memory access (RDMA) mechanism; a bus like HyperTransport, PCI or PCI Express; any other network or other communications link like Gigabit Ethernet, Advanced Switching Interconnect, or Infiniband (whether datagram or stream oriented).","The system may be attached to communication networks or other telecommunication systems using network or communication interfaces. The attached network may be a telecommunication system or communication network for which the aggregate to which transmitted information belongs is explicitly identified as a part of the transmitted information, or where the aggregate can be inferred from parameters associated with the transmitted information or the transmission medium. The associating means may utilize equality or relatedness of this aggregate identifying information to associate transmitted information with other transmitted information. This aggregate identifying information may identify the flow, channel, circuit, pipe, session, stream, timeslot, frequency, spread spectrum code, label switched path, or wavelength of transmitted information.","The communication network may segment transmitted data into discrete datagrams. The datagrams may be IP packets, ATM cells, Ethernet frames, or may use any other protocol carried over any medium. The associating means may utilize information contained within the datagrams (both header information and payload information) as well as information retained over time by inspecting network\/communication traffic to associate transmitted information with other transmitted information.","The format or interpretation of the transmitted information may be defined by a hierarchy of protocol layers. The associating means may inspect protocols at one or more of these layers to determine to which (if any) transmitted information other transmitted information is related.","The transmitted information may for example be network traffic which uses the Internet Protocol (IP) and\/or Ethernet Protocol (IEEE 802.x). The associating means may examine IP and\/or Ethernet headers as well as the payload of network packets, as well as headers or payloads of any protocols nested within these protocols, to determine to which (if any) transmitted information other transmitted information is related.","The transmitted information may contain identifying information which identifies the source (i.e. originator or initiator) and destination (i.e. addressee or target) of the transmitted information. This identifying information may contain network node identifiers in Internet Protocol address, MAC layer address, numerical, text, binary, or other formats. This identifying information may also contain identifiers that specify the user, application, component, process, task, subsystem or other entity within the network node which is the source or destination of the transmitted information. The identifying information may denote groups or other aggregates of the aforementioned sources or destinations. The identifying information may also specify the protocols or subprotocols used by the transmitted information\u2014these may define the format, range, and\/or namespace of the other identifying information. The associating means may utilize any of the aforementioned identifying information, and a combination of the aforementioned identifying information, to associate transmitted information with other transmitted information.","The transmitted information may itself directly or indirectly refer to associated transmitted information. The associating means may detect, extract, decode, interpret, and utilize these references to associate transmitted information with the referred to other transmitted information.","The transmitted information may for example be a signaling or control protocol, for example SIP\/H.323\/FTP\/RSVP\/CR-LDP etc, which may refer to associated data transmission information sessions\/streams\/paths\/traffic.","The association means may also associate transmitted information according to a defined bundling policy. The bundling policy may group: transmitted information sent by a specific type of application or which uses a specified protocol or sub-protocol at a specified layer of the relevant protocol hierarchy; transmitted information which contains specified arbitrary patterns\u2014where each pattern is sought in specified parts of the traffic, e.g. datagram headers, datagram payloads, within higher level (connection\/session\/application layer) data streams, etc; transmitted information associated with a specific set of communicating entities (e.g. user, server, device, network, application instance, service, or combinations thereof); transmitted information contained within a containing flow\u2014e.g. within a tunnel, virtual circuit, virtual path, label switched path, virtual private network, trunk, etc; information transmitted over specified links or networks, or which entered the apparatus at specified network interfaces; any combination of the above, nested to a arbitrary depth.","The flow policy determining means classifies transmitted information in order to group transmitted information into categories. It may classify transmitted information according to a variety of criteria:","Classification is performed based on fields in packet headers, packet payloads (content), and state maintained for the flow being classified as well as state for the apparatus overall.","The classification means can decode protocols that span packet boundaries, or protocols that are layered on other protocols, using its built in knowledge of protocols, or additional installed protocol support modules. Whether or not a specific protocol or set of protocols was detected can be used as a classification criterion.","The classification means can extract data from the supported protocol layers and match that data against arbitrary patterns (including regular expressions, ranges, longest prefix matching of addresses, substring, and string\/numerical equality and greater than\/less than matching).","The classification means supports using Boolean and arithmetic expressions to combine classification sub-results into an overall result.","The system may also decide how a transmission is to be processed. This may be done using the result of the association means and the result of the flow policy determining means to determine the processing policy to be applied to the transmitted information. This policy specifies the set of components (in series, in parallel, or interconnected in an arbitrary graph) which need to further process\/examine the traffic, together with additional processing parameters for each of these components (e.g. quality of service parameters to be applied by a traffic scheduler, or details of the tunnel into which a virtual private network module should en-tunnel traffic, etc.).","The processing means may generate, originate, terminate, store, examine, modify, duplicate, filter, encapsulate, un-encapsulate, and\/or otherwise process transmitted information. The processing that is performed for a particular item or bundle or category of transmitted information is determined by the configured processing policy or, should no configured policy apply, by a default built-in policy.","The processing means may be modularized, i.e. it may be implemented as a set of interconnected modules or components. The components in the modularized processing means may be: Network and communication interfaces, which link the apparatus to external communication networks or transmission media; Association identification components and classification components, which detect the association between transmitted information and other transmitted information, and which determine the policy to be applied to transmitted information; Action graphs, which contain one or more traffic processing modules interconnected in an arbitrary graph, where the traffic processing modules are either instances of any of these components or are elementary processing modules; Virtual switches, which link any number (typically more than two) of these components, while performing the processing a real switch would perform, e.g. self learning of Ethernet addresses and multicasting\/broadcasting of information; Virtual wires, which link two of these components; Virtual machines, which emulate uniprocessor or multiprocessor computer systems, and which run (possibly modified) standard operating systems (e.g. Linux, Microsoft Windows, Unix-like operating systems, real time operating systems, etc.); Virtual Network Interface Cards, which appear to be network interface cards to the operating systems\/applications running in the Virtual Machines (e.g. to the networking stacks in the Virtual Machines) but which connect to these components instead of connecting to real hardware; Virtual stream interfaces, which enable applications to receive data as streams rather than packets\u2014e.g. as virtual character devices\/virtual file systems\/devices which emulate stream oriented protocols like Sockets Direct Protocol etc.; Virtual shared memory mechanisms, which emulate shared memory based communication like remote direct memory access systems; Standard (unmodified) applications running in kernel mode or user mode in the Virtual Machines; Applications running in kernel mode or user mode in the Virtual Machines that have been developed to interact with an application programming interface (API) provided by the system.","These components are interconnected to form the highest level (most abstract level) dataflow graph within the system. Nesting of dataflow graphs (lower level graphs) is supported via the action graph mechanism.","Components may be arbitrarily mapped to (i.e. deployed or hosted on) a set of processors or coprocessors (specialized fixed function hardware) that have been interconnected in a cluster. Example: the network interfaces and some bundling (i.e. information association)\/classification\/action graph modules might be hosted on one processor (possibly a specialized processor like a network processor) whereas the other components might be hosted on other processors (possibly general purpose computing processors). The processors that host the components may be interconnected using shared memory (uniform or non-uniform), a bus\/backplane, or any form of communication link which supports a message\/packet\/datagram\/information stream passing paradigm.","The hosting means enables components to coexist on the processors that comprise the system. It also provides communication mechanisms which enable the components to interact with each other and with the rest of the system.","The hosting means incorporates an operating system which allocates resources (memory, dedicated CPUs or CPU time slices, coprocessors, disk space, network bandwidth etc.) to the components. This underlying operating system may be a real-time or non-real-time operating system, optionally with the ability to support virtual machines running on the underlying operating system.","The hosting means is able to link the components it hosts using a variety of internal and external communication mechanisms and media, including a shared memory communication mechanism, a message passing communication mechanism, and hybrid mechanisms.","The shared memory communication mechanism operates by the sender placing information which is to be communicated into a shared memory area which is accessible to the receiver. This area may be in a set of physical memory devices which are always physically accessible to both of the communicating parties, e.g. this may apply where the parties are applications running on the same processor or on different processors in a Symmetric Multiprocessing (SMP) system. In this case, virtual memory (if applicable) may need to be configured to explicitly permit sharing of memory segments\/pages. Alternatively, the area may be implemented using dedicated shared memory hardware, possibly dual-port or multi-port. In either case, as an optional optimization, a sending processor may instruct the cache of a receiving processor to \u201cpre-load\u201d its cache with the communicated information or a subset thereof (e.g. headers of a datagram but not the payload of the datagram). This may not be required in cases where the processors share a cache or where the communicating parties run on a single processor. The system may support multiple disjoint shared memory pools. The intention is that applications in the same security class are configured to use a single memory pool, e.g. the applications that operate on traffic belonging to a specific set of protocols may be segregated from applications which process other protocols, or applications that act on traffic associated with a specific user\/customer may be segregated from applications which act on behalf of another user\/customer. Segregating shared memory pools will require one of the other communication mechanisms to be used to transfer information between pools, i.e. data will need to be copied between pools. The onus is on the administrator of the apparatus to define memory sharing policies which reach the appropriate compromise between the desired security policy and the desired performance levels.","As an alternative to fully shared memory, a virtual memory system may be used to remap pages to transfer ownership or accessibility between parties. In this case, additional memory may be consumed versus the shared memory option as pages may be larger than the data items which are to be communicated, and remapping pages will incur processing overhead, however security will be improved as the party\/parties which are able to access (read or write) a specific data item can be specifically managed.","Remote direct memory access mechanisms can be used to implement virtually shared memory without requiring a physical shared memory. In this case, a mechanism for a receiving party to inform the sending party into which memory locations messages may be transferred (in essence to synchronies free list information) may be used.","The hosting means may also support linking components using a message passing system. The message passing system is able to utilize a variety of physical media, e.g. packet oriented network media, bus\/backplane, stream\/circuit channel oriented media, etc. It establishes one or more message passing queues across each link. If needed, messages are converted between transmission media by components who have access to multiple types of transmission media. The queues may be arranged in priority levels, where one or more queues are associated with each priority level. In this case, where a message needs to be transmitted\/received before other messages, the system can place the message in a queue with priority higher than the priority of the queues into which the other messages are enqueued.","The system is able to operate across reliable transports or across unreliable transports (where the probability of transmissions being lost is non-zero). In cases where the underlying transport is unreliable, the system uses positive and\/or negative acknowledgements as well as retries to ensure that messages that have to be delivered are delivered. Certain messages need not be delivered\u2014these are discarded by the message passing system if needed (e.g. if resources do not suffice to transmit\/deliver\/receive\/process the messages).","The hosting means can also use a combination of the following mechanisms:\u2014The system may for example place one or more information structure in shared memory, then notify the recipient via a passed message\/an interrupt\/an inter-task or inter-thread signal etc. that information is ready in shared memory to be read. The system may include optimizations to suppress these messages when the system knows that the recipient will \u201cpoll\u201d the shared memory area, and to send messages to wake up the recipient where the recipient may be dormant (e.g. if messages have not been sent to the recipient for a while).","The directing means may forward information to a set of components, applications, subsystems, communication\/networking interfaces, and\/or external systems. The set of entities to which information must be forwarded and in which order they need to receive the information (i.e. which entity receives the information first, to which entity the information is then fed, etc.) are governed by the flow policy. This policy can be defined per bundle and per classification category, with the option to specify a set of policies that apply to all traffic not otherwise bundled\/classified. A set of default flow policies may be built into the system.","The information may be forwarded to applications via APIs. This method is available to applications that have been designed to interact with these APIs, whether they are running in the underlying operating system (e.g. the real time OS\/hypervisor) or are running in virtual machines. The information can also be forwarded to virtual machines via Virtual Network Interface Cards or Virtual Stream Interfaces. In this case, standard commercial off the shelf applications can receive the information provided they are able to be hosted within the virtual machines. External servers or other external nodes will receive the information as real network traffic\/other communications transmissions.","The flow policy may also specify that only a subset of a bundle (i.e. typically a flow) should be directed to specific components. Components will often need to receive a segment of the flow from the start of the flow to somewhere in the middle of the flow\u2014however some components may support receiving arbitrary sections of a flow (\u201cjoining\u201d a flow in mid-stream).","The flow policy may depend on state variables within the system which are not specifically associated with the bundle\/flow which is being processed (or in some cases which are not associated with any bundles\/flows). Thus, the system may elect to direct a bundle\/flow to one of an equivalent set of virtual machines which run on different processors within the system based on the current load of those processors\u2014in effect load balance traffic amongst processors; the system may elect to modify the path taken through the system, e.g. omit certain components at certain times of day\/days of the week, or omit operations that have been labeled optional (e.g. filtering unsolicited commercial email a.k.a. \u201cspam\u201d) if system load exceeds a certain threshold (while continuing to perform operations that have been labeled critical e.g. traffic firewalling\/virus filtering); the system may select the component which processes data from a set of equivalent components based on proximity to other components in the dataflow graph specified by the policy. Thus, if traffic enters the system at a network interface attached to processor , the software components hosted on or the hardware components directly attached to processor  may be preferred to other equivalent components located elsewhere in the system, however if the cost to transfer information to processor  in the system is outweighed by processor  being more suited to hosting a specific component (because processor  has greater processing capacity\/more memory\/specialized hardware at its disposal etc.) the system may elect to use processor  to host a specific component even if an equivalent instance of the component may be available on processor . A mode where the system is configured to not automatically make substitutions, i.e. where the type and instance of each component is specifically configured, is also available. Whether automatically determined or manually configured, the system can therefore \u201ccut-through\u201d traffic or \u201coff-load\u201d traffic from some processors by using other processors\/forwarding and processing hardware.","The flow policy may also depend on the state of external devices\/components\/systems, or of interfaces to these entities. Example: the system could load balance amongst various external servers based on their load, or select the appropriate destination for traffic based on the geographical location associated with the network address of the originator of the traffic, or determine the network link to use based on the used capacity of a set of network links.","The system behavior may change over time as follows.","The classification means may successively refine the category in which it places transmitted information as more transmitted information is received (e.g. traffic may be categorized as TCP traffic, then HTTP over TCP traffic, then web conferencing in HTTP over TCP traffic).","The association means may modify the association information, i.e. the bundle with which transmitted information is associated.","The fact that the classification category and bundling information changed might cause different flow policies to be implemented as other flow policies may be linked to the newly determined categories\/bundles.","External systems or internal components may change association (i.e. bundling), classification and flow policies, and may also change how components are interconnected into dataflow graphs as well as how components are configured.","Other embodiments and advantages are described in the detailed description below. This summary does not purport to define the invention. The invention is defined by the claims.","Reference will now be made in detail to some embodiments of the invention, examples of which are illustrated in the accompanying drawings.","Referring now to , a system for handling a digital electronic flow in accordance with the invention is designated generally by reference numeral the system  comprises an apparatus  which is connected between client  and servers . and .. In this example the apparatus  is connected to a network or other telecommunication systems in such a way that network traffic or other communication is instructed (by virtue of addressing at a specific layer e.g. Layer 2) or forced (by virtue of the topology of physical connectivity) to traverse the apparatus , i.e. the apparatus is a gateway, a router, a switch, a \u201cbump in the wire\u201d bridge, or a similarly attached device.","The hardware of the apparatus  comprises a special purpose processor subsystem . and a general purpose processor subsystem .. The processor subsystems . and . are interconnected using a communication mechanism (not shown) which is able to support interchange of messages between the subsystems or provide a memory area shared by both processor subsystems which enables them to communicate.","The special purpose processor system . comprises network interface hardware . and . as well as a set of processors and coprocessors which are dedicated to identifying, classifying and processing network traffic. Flow identification and classification subsystems . and ., an action graph subsystem  and a virtual switch (VX) subsystem  are hosted on this set of processors and coprocessors.","The client  is connected to network interface .. This network interface is connected to the flow ID and classification subsystem . which is connected to the virtual switch . Network interface . is also connected to action graph  which is again connected to the virtual switch .","The servers . and . are connected to network interface .. This network interface is connected to the flow ID and classification subsystem . which is connected to the virtual switch .","The general purpose processor system . consists of one or more processor cores within one or more processor devices. These cores and devices are interconnected to form a multiprocessor system. The multiprocessor hosts a general purpose operating system with its kernel mode software environment  and its user mode software environment . Within the kernel mode software environment are located Virtual Network Interface Cards (VNICs) . and .. Within the user mode software environment is hosted application . Application  is connected to VNICs . and ., either directly or indirectly via the kernel . VNICs . and . are connected to the virtual switch .","In use, client  establishes a communication session with server . and (at nearly the same time or at different times) with server .\u2014for example it might establish TCP sessions (however any network protocol\/communication session over any media could be supported).","Information sent by client  (in this example encapsulated in datagrams\/packets) enters the apparatus via network interface ..","The flow identification and classification component . determines that flows are being established and identifies the flows associated with each datagram it receives. In this way the datagrams in the flow are bundled together (associated with each other).","The flow identification and classification component . furthermore inspects and analyses packet headers, packet content, and flow content; detects and decodes protocols (including nested protocols); and extracts information from flows. The classification process is governed by policy specification information which is supplied by the system and\/or by applications running on the system. The policy specification information may take the form of a set of rules or a set of matching expressions, both of which specify criteria and the policy which is to be applied if the criteria are fulfilled.","The flow identification and classification component . is composed of multiple submodules interconnected in an arbitrary graph structure. The submodules implement specific aspects of the classification process, e.g. one submodule may be able to detect and decode a specific protocol while another may be able to perform a specific matching operation. Submodules use coprocessors where appropriate to perform processing tasks, e.g. an encryption coprocessor may be used to decrypt information in order to obtain the content of a flow, or a regular expression parsing coprocessor may be used to assist in the matching process.","The result of flow classification is the policy that needs to be applied to the flow (or other non-flow transmitted information). In this example, the policy has specified that flows that match specified criteria from client  to server . should be routed to the application  via Virtual Network Interface Card (VNIC) ..","To the application  and the operating system kernel , VNIC . and VNIC . appear to be standard network interfaces (i.e. device drivers). The application is configured to obtain network traffic from VNICs . and ., either as raw network packets or via protocol stacks embedded in the kernel . The application is unaware that the network interface is a virtual and not a real network interface, and is similarly unaware that traffic has been processed prior to arriving at the network interface. The application  analyses the traffic in the flow and determines that the flow should proceed. After processing the traffic, e.g. modifying packet headers or flow content, the application  sends the traffic out via VNIC .. As data has been passed through a VNIC which is compatible with a standard network interface, metadata determined by the flow identification and classification system, for example tags that are linked to policy to be applied to the flow as well as information representing the result of flow classification, have been lost. The traffic therefore needs to be forwarded to the second flow identification and classification subsystem . in order for the flow identifier and flow policy to be determined. In this example, the policy specifies that no further actions need to be applied to the traffic and that the traffic merely needs to be transmitted via network interface .. The server . then receives the traffic.","Server . processes the information it has received and returns modified information or other information (e.g. information requested by the client). The information transmitted by the server is termed the return traffic or the return portion of the flow. In this example the return traffic is received via network interface . whereupon the flow identification and classification subsystem . again identifies the flow to which the received traffic belongs and determines the policy to be applied to the flow. In this case the policy indicates that the traffic is to be forwarded to VNIC ., whereupon the application  performs any required processing and forwards (possibly modified) traffic to VNIC ., from where traffic is received by virtual switch  and transmitted to action graph .","Note that in this example all traffic transmitted via VNIC . is destined for client  and is processed in the same way by action graph . The policy applied to this traffic is neither dependent on the flow to which the traffic belongs nor dependent on traffic or flow content. As this traffic therefore does not need to be processed by a flow identification and classification subsystem, it is routed directly to the action graph . This example illustrates that the system is able to determine that functions are not required in some circumstances and accordingly optimize the routing of flows within the system.","The action graph  consists of action modules connected in an arbitrary graph. In this example, the action graph could consist of a traffic monitoring module which keeps statistics with respect to bytes and packets passing through the system, a firewalling module which filters out a subset of the traffic, and a traffic management module which limits the bandwidth of traffic.","Note that the different directions of traffic within a flow, i.e. the forward and return traffic, need not follow the same path through the system and may be treated differently by subsystems and modules along the path. In this example, the return traffic passes through an action graph, whereas the forward traffic did not. Note also that the flow handling policy may be adjusted over the lifetime of the flow, either by the system continuing to classify traffic and correspondingly refining the policy, or by the policy being modified by administrators or applications over the lifetime of the flow. This may result in the path being modified or parameters used by subsystems in the path being modified.","A second flow is shown in  between client  and server .. The flow is initiated by client  and analyzed and classified by flow identification and classification block .. In this instance the system determines that there is no need for application  to receive the traffic contained in the flow, perhaps because the application is performing a security function and the client and server are trusted. The system routes the flow via action graph  to network interface .. The system \u201ccuts through\u201d this flow, meaning that all processing of this flow is done within system . and that the flow is never routed through processor ., therefore neither processed by the operating system  nor by the application .",{"@attributes":{"id":"p-0093","num":"0092"},"figref":"FIG. 2","b":["12","18","1","18","2","18","2","30","40","44","34","14","16","1","20","1","22","1","20","2","24","32","34","34","16","1","22","1","44","44","42","44","42","44","44","16","1","34"]},"After a period of time application  may determine that the flow no longer poses a threat and that it does not need to see the remaining traffic in the flow. At this point application  can indicate to the system that it no longer wishes to continue receiving this flow. The system will stop sending the flow to application  while still forwarding the flow to server . with a copy being sent to application . The ability to \u201chand back\u201d a flow frees up resources in application  and increases performance.",{"@attributes":{"id":"p-0095","num":"0094"},"figref":"FIG. 2","b":["14","16","2","22","1","16","2","16","2","14","22","2"]},{"@attributes":{"id":"p-0096","num":"0095"},"figref":"FIG. 3"},"In this example, a flow occurs between client  and server .. Flow identification and classification system . determines that the traffic within the flow needs to be processed by application . The flow policy specifies that application  has been developed to make use of the API provided by the system, and that traffic destined for application  needs to be routed to the application via component , which constitutes a library implementing the system API. The flow policy also specifies that after processing by application  this flow should be routed to application  for further processing, and that application  is attached to VNIC .. As application  is using the system APIs, the flow policy for this flow can be retained as metadata which is kept with the flow contents, therefore there is no need to perform flow identification and classification on the traffic which has been processed by application . Once the traffic has been processed by application , however, the data output by application  needs to be passed through flow identification and classification subsystem .. This is required because the traffic passes through a VNIC, which does not make provision for retaining metadata like flow policy. Once the flow identification and classification subsystem . has identified the flow and determined the flow policy, the system transmits the flow's traffic to server . via network interface . in accordance with the flow policy.","In this example, a second flow exists between client  and server .. The flow policy for this second flow specifies that the flow needs to traverse application , which is attached to VNIC .. Note that application  is processing the second flow which is routed directly to it as well as the first flow which is routed to it via application . Application  is unaware of any processing of the flow that occurs prior to it receiving the flow, for example in the case of the first flow application  does not know that it has already been processed by application \u2014it merely receives potentially altered or filtered flow content.","The third flow in this example occurs between client  and server .. It is classified by flow identification and classification subsystem . and is determined to require routing to application  using a different internal virtual network to that being used for the first and the second flow. The third flow is routed via virtual switch ., whereas the other flows are routed via virtual switch .. The third flow is routed to application  using VNIC .. This use of a separate VNIC and virtual switch within the system provides a greater degree of isolation between the third flow and the other flows than exists between the first and the second flow. It also offers opportunities for the system to optimize performance.",{"@attributes":{"id":"p-0100","num":"0099"},"figref":"FIG. 4","b":["12","60","1","60","2","60","3","30","1","30","2","30","3","40","1","40","2","40","3"]},"In this example, a flow occurs between client  and server .. The flow is received by network interface ., whereupon it is classified by flow identification and classification subsystem . and determined to require processing by application  running in virtual machine (VM) .. Application  is able to receive content via system API implementation library . Note that the system can deliver the flow content directly to an application running in user space . within the guest OS running in VM . without needing forwarding or handling by the guest OS kernel ..","In this example, the configured flow handling policy specifies that all traffic processed by application  also needs to be processed by application  in virtual machine ., and that the traffic needs to be passed to application  via VNIC .. Once processed by application , the flow exits virtual machine . via VNIC . and is forwarded by virtual switch . to flow identification and classification subsystem ., which determines the flow policy to be subsequently applied. The flow policy specifies that the flow should be sent to action graph . for processing before being sent to server . or server ., both via network interface .. Action graph . in this example performs a load balancing function to select the server which should receive the flow.","A second flow exists between client . and server .. The traffic in the second flow enters the system via network interface ., whereupon it is handled by flow identification and classification subsystem .. The configured flow policy specifies that this flow requires processing by application , which runs in VM . and which is attached to VNIC .. On exiting VNIC ., virtual switch . forwards the traffic to flow identification and classification subsystem .. This subsystem reclassifies the traffic and determines that it should be sent to server . via network interface .. Note that the first flow and the second flow both exit VNIC . but are processed differently depending on the result returned by flow identification and classification subsystem ..","A third flow exists between client . and server .. The traffic in this flow is received by network interface . and handled by flow identification and classification subsystem .. The configured flow policy specifies that this flow needs to be processed by application  which is attached to VNIC .. Application  is running in the guest operating system kernel . within virtual machine .. The traffic belonging to this flow is therefore routed to VNIC .. Application  passes the flow content to application , which is running in user space inside virtual machine .. Traffic returned by application  is received by application , which sends the traffic onwards via VNIC ., whereupon it is processed by flow identification and classification subsystem .. This determines that the flow policy mandates routing traffic through action graph . before the traffic is delivered to server . via network interface .. Note that arbitrarily complex paths through the system are possible, which may involve multiple VNICs per virtual machine as well as kernel mode and user mode applications. Note also that traffic belonging to a flow often enters a virtual machine via one VNIC and exits the virtual machine via another VNIC. Furthermore, note that the flow identification and classification subsystems cooperate where appropriate to ensure that the flow policy is correctly and consistently applied to the flow as it makes its way through the system. Flow identification and classification subsystem . may for example communicate the policy to be applied to the third flow to flow identification and classification subsystem . via a control channel (not shown on the diagram).","Referring now to  which depicts the subcomponents of a flow identification and classification subsystem  and an example usage scenario of the subsystem. In this example, traffic is fed to the subsystem  from a network interface , and exits the subsystem to virtual switch .","Within the subsystem, traffic is first received by the flow identification component . This component serves to identify the flow to which the traffic belongs by performing one or more lookups in the flow state table . This table correlates flow identifying information present in traffic, like information contained in packet headers as well as information present in the content of packets, with flow identifiers. The component is for example able to determine that traffic with the same IP addresses and TCP ports belongs to the same flow. In some cases, packet content also needs to be consulted, for example an application layer (i.e. layer seven) information may serve to distinguish flows which share the same basic IP header information. The component has enough intelligence and keeps enough state of the application layer protocol to enable it to extract the flow identifying information.","Where the first traffic element is received for a flow, the flow is termed a new flow, and a new flow identifier is assigned by component . For subsequently received traffic elements, component  will retrieve the previously assigned flow identifier.","Furthermore the component  is able to identify and distinguish between multiple flows that are nested within a single outer flows, as may occur in the case of tunnelled traffic. Where flows are nested, the nested flow is identified by the combination of the identifier of the containing flow and the identifier of the contained flow.","Furthermore, the component  is able to identify the flows that are associated with a specific flow. In this example, a flow is linked to associated flows via the combination of the flow state table  and the separate associated flow table , however, tables  and  may be combined.","In the case of flows containing other flows, the contained flows will be associated using a sibling relationship with all the flows in the same containing flows. The containing and contained flows will be associated using a parent-child relationship.","Other types of associated flows are also understood by the system, for example all the flows which have been initiated by a specific user may be associated, or signalling traffic may be associated with media streams controlled by this signalling traffic, or traffic between specific hosts or subnets may be associated. Multiple levels of association and multiple association relationships between flows are simultaneously supported.","After component  has assigned a flow identifier or retrieved the flow identifier, it forwards the received traffic and the flow identifier to the flow classification and policy determination component . This component first retrieves the tag which indicates the policy to be applied to the flow from the flow state table . Component  alternatively forwards the tag along with the flow identifier to component .","Should the tag indicate that the policy has been completely determined for the flow, the flow policy determining component  then forwards the flow together with information specifying the policy to be applied to the flow onward to the appropriate subsystem as defined by the policy. In this example, the flow is forwarded to virtual switch .","Initially however the tag may indicate that policy has not been completely determined yet. The flow policy determining component  therefore proceeds to classify the traffic in order to determine the policy. This classification process involves extracting, decoding, and interpreting flow content in a stateless or stateful manner, continually matching the flow content or information extracted from\/determined from the flow content to rules and expressions that are specified in the policy database . Should rules match or expressions return policy updates, the policy associated with the flow is updated, with the updates being reflected in changes to the tag associated with the flow or changes to the policy associated with the tag. In this way the policy is successively refined over the lifetime of a flow.","The policy database  may also refer to information which is present in or derived from flows associated with the flow which is being classified. The flow policy determining component  is therefore able to consult the associated flow table  and entries in the flow state table  pertaining to the associated flow in order to obtain the information to which the rules refer. The policy database may for example specify that media streams for which the associated signalling flow refer to username \u201cJSmith\u201d need to be forwarded using a quality of service class three, whereas other media streams receive quality of service class four.","The information present in the policy database , the flow state table  and the associated flow table  can also be dynamically altered by other components in the system. Different instances of the flow identification and classification subsystem may communicate amongst each other to ensure that flow policy is appropriately and consistently applied throughout the system. It is also possible for applications to invoke APIs which pre-populate the flow state table  or the associated flow table  with information enabling flow policy to be pre-configured for flows that are expected to occur in future. Applications can dynamically change the policy to be applied to flows by invoking APIs. These changes will result in the flow state table  and\/or the associated flow table  being updated. The content of the policy database  can also be modified at any time by applications or the system administrator.","It will be appreciated that the flow policy determining component  needs to be able to detect and decode a variety of protocols in order to be able to determine whether policies need to be applied which refer to the presence of these protocols, or policies which refer to elements contained within traffic transmitted using these protocols. The component  therefore contains subcomponents, each of which is responsible for detecting or decoding a specific protocol or set of protocols. As protocols are often layered on other protocols, the subcomponents need to interact. Subcomponents are also employed to assist with specific matching operations. These subcomponents enlist coprocessors where such coprocessors are available to speed up operations, for example the subcomponent dealing with a compressed protocol may use a decompression coprocessor, whereas the subcomponent performing pattern matching may use regular expression matching hardware.","It is contemplated that the invention could be used in the following list of illustrative examples of potential applications. This list is not intended to be exhaustive.","Consolidation of application software which was running on multiple real machines (computers) into a single virtual machine.","Consolidation of appliances to enable multiple appliances to be replaced with a smaller number of devices equipped with virtualisation technology. In this context, an appliance is a computing device, possibly with specialized peripherals\/interfaces like network interfaces, possibly with other specialized hardware like coprocessors, combined with software supplied by the device vendor or a vendor associated with the device vendor, where the appliance has been designed to perform one of a small number of functions. Examples of appliances include firewalls, intrusion detection\/prevention devices, anti-virus and anti-spam devices, etc.","Enabling existing virtual machine systems to process and direct (i.e. control the processing\/forwarding of) network traffic.","Hosting a new class of network infrastructure applications which combine traditional server like processing with traffic and flow directing\/manipulating etc.","Although certain specific exemplary embodiments are described above in order to illustrate the invention, the invention is not limited to the specific embodiments. Accordingly, various modifications, adaptations, and combinations of various features of the described embodiments can be practiced without departing from the scope of the invention as set forth in the claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The invention is now described, by way of examples, with reference to the accompanying diagrammatic drawings which show schematically a system in accordance with the invention connected to clients, servers, and applications.",{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0073","num":"0072"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
