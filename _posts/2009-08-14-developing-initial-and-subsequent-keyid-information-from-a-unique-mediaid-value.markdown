---
title: Developing initial and subsequent keyID information from a unique mediaID value
abstract: A technique for using a key repository to store data encryption keys provides a way to access key records in the key repository using a key identifier constructed from a media identifier associated with a data storage medium on which encrypted data is or will be stored. The media identifier is hashed and added to a counter value to produce the key identifier. In some embodiments, the technique is implemented in an encryption switch that provides data-at-rest encryption for a storage access network, but in other embodiments, the technique may be implemented in other devices, including data storage devices and hosts.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08189790&OS=08189790&RS=08189790
owner: Brocade Communications Systems, Inc.
number: 08189790
owner_city: San Jose
owner_country: US
publication_date: 20090814
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND ART","SUMMARY OF INVENTION","DESCRIPTION OF EMBODIMENTS"],"p":["The present invention relates to the field of storage area networks, and in particular to data-at-rest encryption in storage area networks.","Managing operational risk by protecting valuable digital assets has become increasingly critical in modern enterprise information technology (IT) environments. In addition to achieving compliance with regulatory mandates and meeting industry standards for data confidentiality, IT organizations must also protect against potential litigation and liability following a reported breach.","In the context of data center fabric security, operators of Storage Area Networks (SANs) have desired fabric-based encryption services to secure data assets either selectively or on a comprehensive basis.","Most sensitive corporate data is stored in the data center, and the vast majority of data from critical applications resides in a SAN, enabling organizations to employ the intelligence of the storage fabric as a centralized framework in which to deploy, manage, and scale fabric-based data security solutions.","The storage fabric enables centralized management to support various aspects of the data center, from server environments and workstations to edge computing and backup environments, providing a place to standardize and consolidate a holistic data-at-rest security strategy. Organizations can also implement data-at-rest encryption in other parts of the data center, helping to protect data throughout the enterprise.","Most current industry solutions include either host-based software encryption, device-embedded encryption, or edge encryption, all of which provide isolated services to specific applications but typically cannot scale across extended enterprise storage environments.","Some solutions have provided centralized encryption services that employ key repositories such as provided by several vendors. These key repositories can be considered specialized secure databases of the encryption keys used by the SAN for encrypting data at rest on the media controlled by the SAN. Each key stored by the key repository is associated with a key identifier that can be used to obtain the key from the key repository. The key identifier is typically randomly chosen by software external to the key repository. But performance and manageability of systems that employ key repositories has been less than desired, in part because of a need to maintain tables that associate encryption key identifiers with the media that is to be encrypted or decrypted.","In addition to performance impact of the lookup times required to first lookup the key identifier in the lookup tables, additional management costs are associated with this technique. In SANs with multiple clusters of equipment, these lookup tables are typically stored in each cluster of the SAN, and require careful management to maintain consistency of the information stored therein. Furthermore, data at rest encryption often employs rekeying techniques to avoid stale keys. In such systems, there may be a need to be able to determine previous key generations, but because the key identifiers are randomly selected, determining previous generation key identifiers is typically not straightforward.","According to one embodiment, a method comprises hashing a media identifier associated with a data storage medium to produce a base key identifier; adding a counter value to the base key identifier to produce a key identifier; and accessing a key record associated with the key identifier in a key repository.","According to another embodiment, a machine-readable storage medium stores instructions for a programmable device wherein the instructions cause a processor of the programmable device to perform the method described above.","According to yet another embodiment, a programmable device comprises a processor and a storage medium, operatively coupled to the processor, on which is stored software which when executed by the processor causes the processor to perform actions that comprise hashing a media identifier associated with a data storage medium to produce a base key identifier; adding a counter value to the base key identifier to produce a key identifier; and accessing a key record associated with the key identifier in a key repository.","According to yet another embodiment, a system comprises a key repository, configured to store data encryption keys and an encryption device that comprises a processor and a storage medium, operatively coupled to the processor, on which is stored software which when executed by the processor causes the processor to perform actions that comprise hashing a media identifier associated with a data storage medium to produce a base key identifier; adding a counter value to the base key identifier to produce a key identifier; and accessing a key record associated with the key identifier in the key repository.","Although the following disclosure is written in the context of a SAN, the scope of the present invention is not limited to a SAN, but includes any type of system in which a key repository is accessed by a key identifier for a key that is associated with media that has been or will be encrypted or decrypted using that key. Furthermore, although the embodiments describe below employ disclosed techniques for generating keyIDs in an encryption switch, the scope of the present invention is not so limited, and includes the use of such techniques in other types of devices, such as hosts or storage devices.",{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 1","FIG. 1","FIG. 1"],"b":["100","110","150","110","100","120","130","140","150","160","150","110","110","110","110"]},"Other servers or hosts, switches, and storage devices can be used in the SAN  illustrated in . The elements shown in  are illustrative and by way of example only, and other elements and other numbers and arrangements of elements, including other numbers of fabrics can be included as desired. In particular, the switch  can be a standalone switch, or a blade in a larger backbone switch.","As shown in , the encryption switch  provides for data-at-rest encryption of data stored on the RAID array , the tape library , and the JBOD , allowing access to the encrypted data that is stored in the SAN . Thus, information about encryption keys must be available to the encryption switch . In some embodiments, single elements shown in  may be implemented as redundant components, with two or more redundant elements provisioned into the network for reliability and performance reasons. For example, in a preferred embodiment, the encryption switch  can be provisioned as two or more redundant encryption switches .","In addition to the elements listed above, a key management system  provides for operator control over the encryption services, typically as part of a configuration management system for the SAN , which is not described further herein. Furthermore, a key repository  provides key management services to encryption switch .","In order to provide enterprise-wide consistent and secure encryption keys, the encryption switches  uses key services provided by the key repository . There are multiple vendors of key repositories , each of which may store keys differently and have a different interface for requesting keys from the key repository  and storing keys in the key repository . Example key repositories  include, without limitation, the NetApp Lifetime Key Management Appliance (LKM) from NetApp, the RSA Key Manager (RKM) from RSA, the HP StorageWorks Secure Key Manager from Hewlett-Packard Development Company, L.P., the IBM Tivoli Key Lifecycle Manager (TKLM) from IBM Corporation, and Thales Encryption Manager for Storage (TEMS) from Thales e-Security Inc. The specific protocol used for communicating with a specific vendor's key repository, as well as the techniques used for storing keys internal to the key repository and other internal structure of the key repository is outside the scope of the present invention.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 2","FIG. 1","FIG. 2","FIG. 2"],"b":["180","150","180","150","200","150","180","170","160","120"]},"The initiator  initiates a read or write request to the target . Data-at-rest encryption has been used to encrypt the data stored in the RAID array . The switch fabric  carries the request from the initiator  to the encryption switch . The SAN fabric  is typically a Fibre Channel fabric and uses Fibre Channel protocols to pass requests and responses between the initiator  and the target . The encryption switch  encrypts and decrypts the data read from or written to a logical unit (LUN) of the target .","At no time does the initiator  have access to the key, referred to herein as a Data Encryption Key (DEK), that is used to encrypt or decrypt data stored on the LUN of the target . Instead, encrypted data received from the target  is decrypted by the encryption switch  before transmitting the decrypted data to the initiator . In one embodiment, the encryption switch  limits access to DEKs to a cryptographic module of the switch  in compliance with the standards of Federal Information Processing Standard Publication - (FIPS -) \u201cSecurity Requirements for Cryptographic Modules,\u201d a copy of which is incorporated by reference herein.","The key repository  manages the DEKs, providing the DEKs to the encryption switch . The encryption switch  does not store the DEKs but obtains them from the key repository  as needed.","In addition, a management Local Area Network (LAN) , typically an Ethernet LAN, is used to link the management system  and the SAN fabric  devices, including the encryption switch .","Any desired protocol can be used to communicate between the key repository  and encryption switch . One example of such a protocol is the NetApp OpenKey Application Programming Interface (OpenKey API). Using the OpenKey API, keys that are communicated between the encryption device  and the key repository  are wrapped (encrypted) in another key before sending them within a Transport Layer Security (TLS) session. The key repository  manages the DEKs and performs other tasks related to managing keys for a network.","In a redundant embodiment, DEKs are synchronized between the encryption device  through the SAN fabric  and interconnected fabrics as necessary. The redundant key repositories  also synchronize with each other to ensure access to keys if one key repository  fails. These redundant key exchanges attempt to ensure that the data can be encrypted or decrypted without a single point of failure. In such a redundant embodiment, a separate cluster LAN, typically comprised of Gigabit Ethernet (GbE) links between the encryption devices and key repositories, is typically used for exchanging DEKs between the redundant key repositories  and encryption switches  in a cluster.","As described above, key repositories may be considered as a secure database for storing keys, among other things, using a keyID as the database key for accessing a key record associated with the keyID with information about a given DEK. Thus, in order to obtain a key from the key repository , the encryption switch  must determine the keyID value that corresponds to the desired key.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 3","b":["300","120","310","320","180","120","120"]},"Turning to , a more detailed description of the above technique is provided for three different scenarios. In the first scenario, illustrated in , the encryption switch  obtains the current key for a given MediaID from the key repository . The MediaID is a value that uniquely identifies the associated media. For storage devices other than tape volumes, the MediaID in one embodiment is the Logical Unit Name (LUN) serial number (LUNSN) of the target . For tape volumes, the MediaID in one embodiment is the tape volume label or the tape pool ID\/label. The MediaID can be extracted from the media using standard based interactions between the media  and the encryption switch . In one embodiment, the standards used are SCSI-3 standard of Technical Committee T10 of the InterNational Committee on Information Technology Standards (INCITS) and the Fibre Channel Protocol (FCP) of Technical Committee T11 of INCITS.","In block , the MediaID value is hashed, producing a base keyID value. All key records in the key repository  for this MediaID will be associated with keyIDs based on the base keyID value. In addition to a key record for each DEK stored in the key repository , a base key record is stored in the key repository  with attributes that are used for obtaining the other key records and for other purposes that unrelated to the present invention.","According to one embodiment, the hash function used by block  is the Secure Hash Algorithm-256 (SHA-256) described in the FIPS publication -, which is incorporated by reference herein in its entirety. In other embodiments, such as where the processing requirements of SHA-256 create negative performance impacts, Secure Hash Algorithm-1 (SHA-1) may be used. SHA-256 and SHA-1 are illustrative and by way of example only, and other hashing functions can be used.","In block , the base keyID is truncated to the appropriate size for the key repository  as discussed above. Then, in block , a base counter may be added to the base keyID value output by the hashing function. In an embodiment where the base counter value is zero, this action may be omitted. The base keyID is then provided as a keyID in block  to obtain the base key record from the key repository . The base key record may not contain an actual DEK, but may provide information useful for the rest of the techniques described herein, including a current counter value, as described below. In one embodiment, the current counter value is not persistent in the encryption switch , but is kept in the base key record. Thus, to obtain the current counter value, the encryption switch  may construct a keyID using the base keyID and the base counter, as described above, to obtain the base key record.","Upon receiving the base key record, the encryption switch  may then in block  extract the counter value from the base key record. The structure of the base key record may vary depending on the key repository . For example, in a NetApp LKM key repository, a key record (referred to as a Key Object) according to one embodiment contains:","KeyClass\u2014Identifies the type of key contained in the Key Object, for example \u201ckcn.1998-01.com.brocade:DEK_AES256_XTS\u201d;","KeyFormat\u2014Identifies the wrapping of the key, e.g. plaintext, encrypted with a link key, etc., for example, \u201ckfn.2001-03.com.decru:wrapped_OCK\u201d;","KeyIDValue\u2014is the Primary ID of the Key Object","KeyAttribute[1..24]\u2014name value pairs for attributes, wherein the Name is the name of the key attribute and the Value is the value of this attribute. In one embodiment, one of these attributes is used as a Key Count attribute.","Before a Key Attribute is used in a NetApp LKM, it must be defined in the Key Attribute table. One may use the NetApp LKM key attribute add command to enter an attribute into the LKM attribute table. The table provides a mapping between the attribute name and the following values: (1) Display Name\u2014user friendly name for the key attribute; (2) Type\u2014the data type of the key attribute's value; and (3) IsPrimary\u2014Boolean field that determines whether or not the key attribute can be used as database key when searching for the key object in the LKM key database.","The KeyClass, KeyFormat, and KeyIDValue tuple serves as the primary database key for accessing key records. The actual value for the encryption key being stored in the key repository  is stored in one of the KeyAttributes, identified as Key_Content.","According to one embodiment, the Key Count attribute includes three data fields, defined as follows: a 2 byte Count field, a 2 byte Sequence field, and a 2 byte Key State field.","There is no Key Count KeyAttribute for a regular key record containing a DEK; only the base key record contains that attribute. Other key records for that MediaID will contain the Key_Content attribute with the actual key, which is not contained in the base key record, according to one embodiment.","The base key record, which is the first record in the key repository  entered for a MediaID, contains the Count and Sequence fields in the Key Count attribute, but does not contain actual key data. The Count field is incremented each time a new generation of a key is created for a MediaID for non-tape storage media, while the Sequence field is incremented each time a new key is created for a new segment of a tape volume MediaID. Thus, depending on the type of storage media identified by the MediaID, the Count or Sequence field may be extracted from the base key record in block  and added to the base keyID in block .","A tape volume may have multiple keys associated with it, one for each segment. However, the keyID generator described above generates the same base keyID for all tape segments. There may also be multiple keys for a LUNSN active concurrently during a re-keying operation, each containing the same base keyID. The Key Count attribute keeps track of how many keys have been generated for a MediaID. This field allows retrieval of all key records associated with a given MediaID.","The Key State field of the Key Count KeyAttribute is used to indicate the status of a key, such as compromised, deleted, archived, etc.","Although the structure of the key record in other key repositories may differ, similar Count and Sequence fields may be stored in the key record as application specific data, allowing the same technique to be used, possibly with different field names, depending on the key repository implementation. In one embodiment, where an RSA RKM key repository is to be used, because the RSA key repository does not allow for directly setting the keyID value in a key record, an alias attribute may be used for storing the keyID. The alias attribute can be directly set, and can be used as a primary key for key repository lookup, thus provides an equivalent technique to that used in the NetApp LKM embodiment.","In block , the current counter, extracted from the base key record Key Count attribute Count or Sequence field, is added to the base keyID to form a keyID. Finally, in block , the keyID is used to obtain the key record for the current key for the MediaID in the key repository , extracting the current key from the key record.","A similar scenario is illustrated in , except that in this scenario, the encryption switch  obtains an earlier generation key instead of the current key. Blocks - and - are the same as blocks - and -, respectively, of , and will therefore not be described again. In this scenario, however, instead of using the counter obtained from the base key record directly, the encryption switch in block  decrements the counter before performing blocks -. By decrementing the counter before using it to construct the keyID and obtaining the key record, the encryption switch  may obtain a previous generation of the key or the key for segments of a tape volume other than the most recently written segment. By decrementing the counter once, the immediate previous generation key or tape segment key may be obtained, and by decrementing the counter more than once, earlier key generations or tape segment keys may also be obtained.","Although not shown in , the encryption switch  may easily obtain any desired range of generations of the key used to encrypt data stored on the storage medium stored with the medium associated with the MediaID by cycling through the steps -, if more than one previous generation key is to be obtained, or by directly decrementing the generation counter to the desired generation if a single generation is to be obtained. Similarly, the keys for any desired range of tape volume segments can be obtained.",{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIG. 6","FIG. 4"],"b":["600","640","400","440","650","660","670","680"]},"In a non-tape medium, such as a RAID array  or a JBOD , stored data may be rekeyed from time to time with a new encryption key, typically to increase security by avoiding the use of stale keys. In one embodiment, older generation keys may be used to read stored data, but only the current generation key may be used to write data. During a rekeying process, the old key may be obtained using the technique of , then a new key may be generated for the storage medium identified by the MediaID and stored into the key repository  using the technique of . The currently encrypted data is then read using the old key, obtained as described above, decrypted, and then encrypted with the new key and rewritten to the storage medium.","For tape volumes, rekeying is typically not performed, thus generally only a single generation of key is used for encrypting the data written to any tape segment. Instead, different segments on the tape may be encrypted with different encryption keys. Thus a given tape volume may have multiple keys associated with it, each for different portions of the tape. The same technique is used for tape volumes as is described in , but in the case of a tape volume, instead of adding a generation number, such as found in the Count field of the Key Count KeyAttribute in a NetApp LKM embodiment, a sequence number identifying the tape segment, such as found in the Sequence field of the Key Count KeyAttribute in a NetApp LKM embodiment, is added to the base keyID. In the NetApp LKM embodiment described above, the base key record maintains two separate attributes, one used for a generation count, and a second used as a sequence number for media, such as tape, that can have several concurrent keys associated with the MediaID. In another embodiment, a single attribute in the key record may be used for both purposes.","The generation count and sequence numbers described above are typically initialized as a zero in the base key record, and incremented by one for every generation or tape volume segment. But any convenient initial value may be used, and an increment value greater than one may be used if desired, regardless of the initial value.","The hash function chosen for the above technique preferably has a very low likelihood of generating the same hash value for different MediaID and sequence values. If the encryption switch  generates a new keyID that is in use by the key repository, the key repository will indicate the existence of a record with the same keyID. The encryption switch  may then generate a new keyID by once again incrementing the sequence number or generation count, adding it to the base keyID, and trying again to create a new key record with the new keyID.",{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 7","b":["150","150","170","710","170","700"]},"A Key Archive Client (KAC) module  provides the encryption switch  with a general interface to interact with the various key repositories , via specific plug-in modules or adapters  that perform the necessary translations for specific key repositories . For example, in , plugin  is an LKM plugin, designed to interact with a NetApp LKM repository .","A security processor management module  provides an interface between a security processor module  and the key archive client . The security processor module  performs key generation, key encryption, and key injection into the cryptographic engines of the encryption switch . In one embodiment, the security processor module  is a security processor operating system that provides FIPS Level 3 compliance.","Turning to , a block diagram illustrates major hardware components of the encryption switch  that execute the software architecture of . The encryption switch  may be constructed as a standalone switch or as a blade in a larger data center switch chassis. If the encryption switch  is a blade, then the portion of  enclosed in the dotted line may be sufficient, while the additional components may be used for a standalone switch. The dashed line indicates a secure cryptographic module , which performs encryption and decryption for the encryption switch . The cryptographic module  preferably is protected from physical tampering by physical security techniques such as a hardened case and tampering detection hardware that interface with the security processor  contained in the cryptographic module , so that an attempt to tamper with the cryptographic module  will cause the security processor to destroy encryption information contained in the cryptographic module , including destruction of encryption key information used for communication with the key repository .","According to this embodiment, a plurality of encryption FPGAs  that perform the actual algorithms for encryption and decryption of data interact with a pair of Fibre Channel protocol ASICs  for transmitting and receiving data from initiators and targets on the SAN . A control FPGA  controls the operation of the encryption FPGAs , and provides an interface to a blade processor  and the security processor .","The blade processor  provides processing capability for the switch operating system, including software for interacting with the key repository , such as the key archive client . The blade processor  also controls Gigabit Ethernet ports  and a smart card interface  used for authentication purposes. In a standalone switch , an additional control processor  provides additional control functions for the encryption switch , through a PCI-e bridge , and connections to the blade processor . The control processor  and a USB controller  provide further control for RS232 and 10\/100 M Ethernet links .","The above-described techniques provide a capability to use a key repository to provide a secure database for the storage of encryption keys that allows easy lookup of encryption keys in the key repository, using a deterministic transformation of an identifier for the media on which the encrypted data is stored as a base for the key repository lookup key, without needing to create and maintain external lookup tables to associate key repository lookup keys with the media identifiers. The techniques also provide an easy way to obtain one or multiple generations of keys without keeping information external to the key repository that would need to be replicated across a distributed cluster of switches, thus making manageability of key information more secure and avoiding consistency problems.","Although the above description has been written in the context of embodiments using in-band devices such as encryption switches to encrypt and decrypt data passing between hosts and storage devices, the scope of the present invention is not limited to such embodiments. For example, in some embodiments, instead of encryption and decryption occurring at intervening switches, the encryption and decryption may be performed at the storage devices of the SAN  that serve as targets, or at the hosts that serve as initiators of SAN requests. In some embodiments, the key repository may use out-of-band communication to the device performing encryption or decryption, allowing the initiator or target device to perform its own encryption or decryption using the keys retrieved from the key repository. Although described in the context of a SAN, the above-described techniques are applicable to any environment in which encryption keys are stored in a key repository.","Aspects of the invention are described as a method of control or manipulation of data, and may be implemented in one or a combination of hardware, firmware, and software. Embodiments of the invention may also be implemented as instructions stored on a machine-readable medium, which may be read and executed by at least one processor to perform the operations described herein. A machine-readable medium may include any mechanism for tangibly embodying information in a form readable by a machine (e.g., a computer). For example, a machine-readable medium (sometimes referred to as a program storage device or a computer readable medium) may include read-only memory (ROM), random-access memory (RAM), magnetic disc storage media, optical storage media, flash-memory devices, electrical, optical, and others.","Various changes in the details of the illustrated operational methods are possible without departing from the scope of the following claims. For instance, the illustrative flowchart steps or process steps of  may perform the identified steps in an order different from that disclosed here, including concurrently. Alternatively, some embodiments may combine the activities described herein as being separate steps. Similarly, one or more of the described steps may be omitted, depending upon the specific operational environment in which the method is being implemented. In addition, acts in accordance with  may be performed by a programmable device executing instructions organized into one or more program modules. A programmable device may comprise a single computer processor, a special purpose processor (e.g., a digital signal processor, \u201cDSP\u201d), a plurality of processors coupled by a communications link or a custom designed state machine. Custom designed state machines may be embodied in a hardware device such as an integrated circuit including, but not limited to, application specific integrated circuits (\u201cASICs\u201d) or field programmable gate array (\u201cFPGAs\u201d). Storage devices, sometimes called computer readable media, suitable for tangibly embodying program instructions include, but are not limited to: magnetic disks (fixed, floppy, and removable) and tape; optical media such as compact disc read-only memory devices (CD-ROMs) and digital versatile discs (\u201cDVDs\u201d); and semiconductor memory devices such as Electrically Programmable Read-Only Memory (\u201cEPROM\u201d), Electrically Erasable Programmable Read-Only Memory (\u201cEEPROM\u201d), Programmable Gate Arrays and flash devices.","The above description is intended to be illustrative, and not restrictive. For example, the above-described embodiments may be used in combination with each other. Many other embodiments will be apparent to those of skill in the art upon reviewing the above description. The scope of the invention therefore should be determined with reference to the appended claims, along with the full scope of equivalents to which such claims are entitled. In the appended claims, the terms \u201cincluding\u201d and \u201cin which\u201d are used as the plain-English equivalents of the respective terms \u201ccomprising\u201d and \u201cwherein.\u201d","While certain exemplary embodiments have been described in details and shown in the accompanying drawings, it is to be understood that such embodiments are merely illustrative of and not devised without departing from the basic scope thereof, which is determined by the claims that follow."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":["The accompanying drawings, which are incorporated in and constitute a part of this specification, illustrate an implementation of apparatus and methods consistent with the present invention and, together with the detailed description, serve to explain advantages and principles consistent with the invention. In the drawings,",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIGS. 4-6","FIG. 3"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 7","FIGS. 3-6"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 8","FIG. 7"]}]},"DETDESC":[{},{}]}
