---
title: Master data framework
abstract: Systems and techniques for providing a master data framework. The framework receives user input and automatically generates, in accordance with the input, a persistent definition of a business object type. The input can be simple declarations and need not be provided in any particular programming language. Definitions generated by the framework adhere to a same data model, regardless of the business object type they are defining. The framework allows the user to create a definition of a business object type by associating two or more definitions of other business object types. The framework provides services that can be applied, without further customization, to any definition of business object types generated by the framework. These services, for example, can be used by a calling application to instantiate business objects or to change a state of a business object instance.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08352478&OS=08352478&RS=08352478
owner: SAP AG
number: 08352478
owner_city: Walldorf
owner_country: DE
publication_date: 20041029
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The present specification relates to data processing and data objects.","Data objects are elements for information storage in object-oriented computing systems. Data objects can describe the characteristics of an item using a series of data fields that, for example, can correspond to described characteristics. Typically, a programmer will predefine standard object classes, referred to in the present specification as object types, that are hardcoded into a set of machine-readable instructions for performing operations. Object types are blueprints for describing individual objects using a defined set of class attributes (or properties). Instantiated objects that are members of such standard object types can be applied in a variety of different data processing activities by users, for example, customers who are largely unaware of the structure of the standard object types.","One example of a data object is a business object, which is typically used in data processing to describe the characteristics of an item or a process related to the operations of an enterprise. A business object can represent, by way of example, a document, a sales order, a product, a piece of manufacturing equipment, an employee, and even the enterprise itself.","A business object usually includes multiple layers, at the core of which is a kernel that represents the object's data. Also typically included is an interface layer that, among other things, defines an interface consisting of a set of clearly defined methods, which are said to be associated with the business object. Such methods, referred to in the instant specification as services, can be, for example, those that read, write, or delete data during run time from the kernel of the business object.","Like other data objects, a business object can be instantiated. The data of a business object instance is usually only accessible by invoking one of its associated services. The application invoking the service will be referred to in the present specification as a calling application. When executing a service on a business object instance, the calling application can change the object instance's data, that is, the object instance's state.","As with other data objects, business objects may be of a particular type. Conventionally, in a computing system of an enterprise (referred to in the instant specification as an enterprise system), one must usually define services for each business object type being used in the system, and the interface layer for a particular type of business object is typically specific to and is compatible with only the services defined for that type. Thus, one must typically define an interface layer and the services of layer whenever a new object type is being implemented in the enterprise system.","The present invention provides methods and apparatus, including computer program products, for providing a master data framework. The framework receives user input and automatically generates, in accordance with the input, a persistent definition of a business object type. The input can be simple declarations and need not be provided in any particular programming language. Definitions generated by the framework adhere to a same data model, regardless of the business object type they are defining.","The framework allows the user to create a definition of a business object type by associating two or more definitions of other business object types, which can be previously created and stored in memory. To entities external to the framework, for example, a calling application, an instance of the business object type so defined appears as one business object instance.","Because it generates object type definitions that adhere to the same data model, the framework can provide services that can be applied, without further customization, to any business object definition it generates, regardless of type. The services, for example, can be used by a calling application to instantiate business objects or to change a state of a business object instance. The services of the framework can perform other tasks, as will be described below.","In one general aspect, the invention features a computer program product, tangibly stored on machine readable medium, for providing a master data framework. The product includes instructions operable to cause a processor to receive information describing a business object type. The product includes instructions to, in response to user input, create a definition of the business object type. The definition is in accordance with a data model usable for defining different business object types. The data model is a standard data model used in an enterprise system.","In another general aspect, the invention features a computer-implemented method, which includes receiving information describing a business object type. The method includes, in response to user input, creating a definition of the business object type. The definition is in accordance with a data model usable for defining different business object types. The data model is a standard data model used in an enterprise system.","In another general aspect, the invention features a master data framework that includes a first component configured to receive information describing a business object type. The framework includes a second component configured to create, in response to user input, a definition of the business object type. The definition is in accordance with a data model usable for defining different business object types. The data model is a standard data model used in an enterprise system.","The invention can be implemented to realize one or more of the following advantages. A user without programming expertise can generate definitions of business object types. Such a user need only make simple object declarations, for example, declarations associating previously created definitions of business objects types. Programming errors can thus be reduced or eliminated.","Business objects types defined by using the framework have a collection of readily available services regardless of business object types. To provide a service that is executable on the business objects, a user need only associate the service with the business objects. The user need not define services for each business object type.","Furthermore, services associated with a business object need be implemented only once, and one need not define interfaces and services for each type of business object implemented in an enterprise system. Changes to services can be effected centrally within the framework. Although the system provides the described features for the implementation of services, the system is flexible and does not, however, require one to use these features to implemented services. That is, it is possible to define interfaces and services for each object type and, thus, each object type can have its respective interfaces and services. One implementation includes all of the above described advantages.","The details of one or more implementations of the invention are set forth in the accompanying drawings and the description below. Other features, objects, and advantages of the invention will be apparent from the description and drawings, and from the claims.","Like reference symbols in the various drawings indicate like elements.","As shown in , a master data framework  includes one or more design time components  and one or more run time components . Design time components  are those used during design time, a period in which business object types are defined as necessary, for example, to accommodate the specific data processing activities of an enterprise system. At least one of the design time components is configured to generate the above-described definitions in accordance with user input and, furthermore, such that the definitions adhere to a same data model, which will be described below. The framework can include one or more services that facilitate design time tasks. Run time components  are those used during run time, a period in which applications call on services of the framework , for example, to instantiate data objects and access or change a state of the instantiated data objects. As will be further described below, run time services use semantics supplied by a calling application as needed to instantiate business objects, or access and\/or change states of business object instances. Table 1 below provides examples of services that can be implemented. Alternatively, fewer or additional services are implemented.","Alternatively, the framework  can include one or more components that performed both design time and run time tasks. In this case, the framework can include a single engine operable to performed all of the above tasks.","In one implementation, the framework is a data management Layer (\u201cDML\u201d), which is available (as a part of MDM version 3.0) from SAP AG of Walldorf, Germany.",{"@attributes":{"id":"p-0032","num":"0031"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Service","Brief description of possible use(s)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Persistency handling","Interface with databases, e.g., table locking, synchronous and\/or"]},{"entry":[{},"asynchronous updating, and buffering."]},{"entry":["Transaction control","Define logical units of work, trigger saving and\/or"]},{"entry":[{},"discarding of runtime changes, lock data objects, and unlock"]},{"entry":[{},"data objects."]},{"entry":["Deletion","Physically remove data objects from a database, and mark"]},{"entry":[{},"a data object with a deletion flag."]},{"entry":["Hierarchy checks","Ensure that a strict hierarchy or network is free of cycles"]},{"entry":[{},"(which are direct or indirect self references)."]},{"entry":["Status management","Provide status schema for data objects with transition"]},{"entry":[{},"rules in status net. A data object can have several status at"]},{"entry":[{},"the same time possible (e.g., new and locked)."]},{"entry":["Message handling","Collect error and\/or success messages, e.g., for error"]},{"entry":[{},"reporting on UI, and save messages to protocol database."]},{"entry":["Text handling","Check locale, and text type settings."]},{"entry":["Extensibility","Change and\/or extend object type definitions (which can"]},{"entry":[{},"be freely done at any time)."]},{"entry":["Administration data","Log time stamp of creation and\/or last change of a data"]},{"entry":[{},"object type and\/or segments of a data object type, log user(s)"]},{"entry":[{},"effecting the creation and\/or change. (This service can be"]},{"entry":[{},"useful for auditing tasks.)"]},{"entry":["Authority concept","Assign maintenance authorities to users dependent on"]},{"entry":[{},"object type, and refine by authority checks on object"]},{"entry":[{},"instance level."]},{"entry":["Distribution services","Effect Distribution proxy and\/or message type, inbound"]},{"entry":[{},"and\/or outbound processes, key mapping, matching and\/or"]},{"entry":[{},"merging, object staging, object structure explosion,"]},{"entry":[{},"registration for distribution, and serialization."]},{"entry":["UI","Provide UI(s) that reflect the object model and operate"]},{"entry":[{},"APIs, and provide help for inputting values wherever value"]},{"entry":[{},"entry is required."]},{"entry":["Owner\/namespace","Implement ownership feature. Object instances or object"]},{"entry":[{},"type segments can have an owner (e.g., an organization, or"]},{"entry":[{},"an application) that controls the change of those object"]},{"entry":[{},"instances or object type segments. For object instances, the"]},{"entry":[{},"owner is specified by adding an additional key field (and it"]},{"entry":[{},"is possible to have a same external key for objects belonging"]},{"entry":[{},"to different owners)."]},{"entry":["Change Management","Evaluate and assign complex validities to states of data"]},{"entry":[{},"objects and provide services to build valid states. Can be"]},{"entry":[{},"used to control maintenance and release processes (for"]},{"entry":[{},"specifying, e.g.., which user is allowed to change which"]},{"entry":[{},"object using which change request)."]},{"entry":["Simple validity","Evaluate validity based on time dependency, e.g., by"]},{"entry":[{},"evaluating date-from and\/or date-to fields. (This service is"]},{"entry":[{},"similar to but less complex than the above-described change"]},{"entry":[{},"management service.)"]},{"entry":["Change history","Provides history tables for logging all changes and an"]},{"entry":[{},"ability to reconstruct the state of an object for a given time in"]},{"entry":[{},"the past (useful for auditing purposes)."]},{"entry":["Classification","Assign object to classification classes, and valuate"]},{"entry":[{},"properties of classes. Classification may also use"]},{"entry":[{},"standardized classification schemes (e.g., UC\/CNET)."]},{"entry":["Search for objects","Search for objects by information contained in any object"]},{"entry":[{},"part or object relations, formulate complex search criteria"]},{"entry":[{},"(e.g., AND\/OR, exclusive search, pattern search, and"]},{"entry":[{},"interval search). Also search for objects by using a search"]},{"entry":[{},"engine (e.g., Google-like searches)."]},{"entry":["Reporting","Use object data for reporting purposes (multi-dimensional"]},{"entry":[{},"aggregation and analysis including graphical presentation of"]},{"entry":[{},"results)."]},{"entry":["Document","Attach documents of any type (e.g., text, pictures,"]},{"entry":["management","movies) to data objects."]},{"entry":["Where used list","Run a where-used-list for all places where an object"]},{"entry":[{},"instance is used\/referred."]},{"entry":["Versioning","Manage several versions of an object (the framework still"]},{"entry":[{},"knows that the different versions refer to a single object)."]},{"entry":["Group","Grouping data objects, e.g., for search purposes."]},{"entry":["Archiving","Remove obsolete data from the operational data base and"]},{"entry":[{},"put it to an archive file (e.g. because it must not be"]},{"entry":[{},"completely deleted according to some laws)."]},{"entry":["Workflow","Use data objects in workflows, e.g., for approval"]},{"entry":[{},"processes (approval can be contingent, for example, on the"]},{"entry":[{},"particular user who is creating and\/or changing the object,"]},{"entry":[{},"and\/or on one or more rules other users have to approve for a"]},{"entry":[{},"particular action before the action becomes effective)."]},{"entry":["Draft saving","Save incomplete and\/or inconsistent data but let it not"]},{"entry":[{},"become operational (processes will run on the current active,"]},{"entry":[{},"consistent state). Ensure consistency on activating the draft."]},{"entry":["Comparison of objects","Compare objects including all object parts, return"]},{"entry":[{},"differences down to attribute level."]},{"entry":["Mass change","API and UI for executing the same change (e.g., replace"]},{"entry":[{},"A by B, or add 3 everywhere) on many objects by a single"]},{"entry":[{},"action instead of maintaining each object on its own."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 2","b":["200","100","202","202","204","206","204","206"]},"The data model  requires that each definition includes a data set component  that is associated with the above-described object key  and, furthermore, describes the attributes of a business object type, the data type for each attributes, and any syntax requirements for each attribute. The data set component  can specify, for example, that a particular business object type includes a first attribute called geographic location and a second attribute called coordinates. The data set component  can further specify that the data types of the first and second attributes are text and numbers, respectively. A syntax requirement for the second attribute can be, for example, a rule that does not allow data values other than numbers. Entry of a character string, for example, would not be permitted for the second attribute, which requires number values. In one implementation, the data set component is implemented by using Set Types, which is a software tool provided by SAP AG of Walldorf, Germany to describe a grouping of one or more attributes.","The data model  requires that each definition includes a relations component  that is associated with the object key  and, furthermore, describes one or more relations a business object instance may have with other business object instances. A relation, in general, associate two object type definitions and, thus, specify the relationship between an object instance of one of the two object types and an object instance of the other of the two object types. An object type definition can include more than one relation and, thus, more than two definitions can be associated.","As can be seen, there can be at last three types of relations, which are called tight, loose, and hierarchy relations. Objects instances associated by a relation have a parent-to-child relationship, in which the child object instance is a component of the parent object instance. By way of example, in a relation between object instances that represent an employee and an address, the former is the parent object instance and the latter is a child object instance. The parent object instance can be further associated with other objects instances, as either a parent or a child.","In a tight relation, the associated object instances together form a complex object. The child object instance does not appear, to entities external to the framework, for example, a calling application, as an individual business object instance. It appears as a component of its parent object instance. The child object instance, thus, need not have an external key, need not be externally locked, i.e., protected from a change in state, need not be posted or published to entities external to the framework. One cannot access information of the child object instance without going through the parent object instance. In order to access such information, one is generally required to retrieve the parent object instance. In a sense, the parent object instance can control when and how the child object instance is changed.","In a loose relation, in contrast, the child object instance can appear as it own individual object instance. Information regarding the child object instance can be arbitrarily accessed without going through the parent object instance. The child object instance, thus, may need an external key, a lock, and to be posted or published external to the framework.","A hierarchy relation is generally a tree-like structure with branches relating one object instance to another. In one implementation, the relations component  is implemented by using Interlinkages, a software tool provided by SAP AG.","In the instant specification, an object type that includes a tight relation is referred to as a complex object type and an object instance of a complex object type, which instance is formed by associating object instances with a tight relation, is referred to as a complex object instance. Object definitions that do not include a tight relation are referred to as simple object definitions, and object instances that do not have a tight relation (but may include a loose relation) are referred to as simple object instances. A complex object type is created by defining a tight relation between two object types (which can be complex or simple).","In one implementation, the framework is aware of and builds only simple object instances. At run time, it is an API layer (e.g., the API layer  of ) that evaluates whether a definition of an object type includes a tight relation to other object types and builds the complex object instance from the component object instances. (The framework simply generates the simple object instances that make up the complex object instance.) The complex object type can be described with only a tight relation attribute and is simply a virtual construct. In tables where object types are listed, there are no entries for complex object types.","Optionally, the data model  specifies that each definition includes a differentiation key component  that is associated with the object key . The component  specifies which differentiation key can be used for an object instance. A business object type can include attributes that require different data values for different conditions. For example, a business object type representing a product can include an attribute that is an identification for a storage location, and the data values that are valid for this attribute can vary from manufacturing plant to manufacturing plant. A differentiation key is typically used to implement different variations of instances of the business object type that occur for different conditions, for example, the described example involving the storage location identification. In one implementation, the differentiation key component  is implemented by using Linkhandler, a software tool provided by SAP AG.","Optionally, the data model  specifies that each definition includes a text component  that is associated with the object key . The text component describes the type of text that a business object type can include.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 3","b":["300","100","300","300"]},"As can be seen, the definition  adheres to the above described data model. The definition  includes an object key component  that includes a field  for a GUID, which is an internal component of the key. The object key component  also includes an external component , which includes two key fields  and  for the NAME and GROUP of the definition, respectively.","The definition  includes a data set component , which specifies that business objects of this type include four attributes: NAME, COUNTRY, STATE, and NUMBER. The component  also specifies the type of data values that can be used for each attributes. An alphanumeric string can be used for the attribute NAME, an alpha string can be used for the attributes COUNTRY and STATE, and numbers can be used for the attribute NUMBER. Additionally, the component  specifies syntax requirements for the data values for each attributes. The NAME and COUNTRY attributes share a same syntax requirement, which limits the length of their strings to less than 25 characters. The syntax requirement for the attribute STATE militates that the length of the string be two characters long. The syntax requirement for the attribute NUMBER does not allow negative numbers.","The definition  includes a relations component , which specifies that any combination of three relations, tight, loose, and hierarchy, are allowed. Furthermore, the component  specifies that attributes describing each type of relation are also allowed. Attributes of a relation can, for example, describe inheritance characteristics of a relation, describe the nature of a relation between two objects, and describe an ordinal counter for relations (when there are several relations of the same type being used for a business object).","The definition  includes a differentiation key component  that, in the instant example, specifies that a differentiation key for distinguishing countries can be use. Such a differentiation key may be needed, for example, to indicate that for countries other than the United States, the attribute STATE is not needed.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 4","b":["400","300","400","400","402","402"]},"The business object instance  also includes values for the above-described four attributes. The values for the NAME, COUNTRY, CITY, AND NUMBER attributes are: Tesla, United States, AK, and 47, respectively.","The business object instance  also includes a loose object relation to an object instance that has a GUID of OF88 and that represents an oil field. In particular, the business object instance  represent an oil well that is located in an oil field, which is represented by the business object instance having the GUID value of OF88.","The business object instance  further includes one differentiation key that distinguishes the business object types representing oil wells located in the United States from those located in other countries. The business object types representing oil wells located in countries other than the U.S. do not have the attribute STATE.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 5","b":["500","500","100"]},"The framework  provides a user interface that allows a user to provide information needed to create a definition that adheres to the above-described data model (step ). In general, the information needed includes a description of the object key, attributes, and relations. Note that no data values are required to perform the process . The interface, which can be graphical, includes fields for receiving the needed information. Optionally, the fields can include pull down menus listing selectable elements of an object type definition.","The interface can include one or more tables having cells, in which the user can input the required information. Alternatively, the interface can include two or more windows, a first of which represents the business object type being defined, and a second or more of which include elements of a business object type (for example, keys, standard attributes, and relations). The interface allows the user to drag and drop selected elements into the first window and thereby define a business object type.","Optionally, the framework  can provide, through the interface, a wizard for creating a definition. The wizard prompts the user for the information needed for the framework  to create a persistent definition of a business object type.  shows an example of the user interface.","As shown in , the framework  receives, by user input through the user interface, the information needed to create a definition that adheres to the above-described data model (step ). In general, such information describes what is possible and allowed for instances of the object type. The information can be simple declarative statements or some graphical equivalent (for example, the above-described drag and drop and field completion techniques).","The framework creates a persistent definition of a business object type in accordance with information received from the user input (step ). The definition is organized in accordance with the above-described data model , which is standard for all definitions created by the framework. Creating a persistent definition includes generating the data representing the definition. The portion of the engine that generates this data, also known as a persistency handler, can be used to generate all definitions, regardless of the type of business objects they represent. Such an advantageous result can be achieve because the framework uses a standard data model for its definitions.","The framework stores the definition in memory (step ). In particular, the framework stores the data representing the definition in memory, which is a data store that is accessible to the framework .","The framework can associate one or more services with a business object type. Such associations can be made in accordance with user input. There can be a default set of services that is associated with every business object type. The framework, in one implementation, has a service architecture, and services with which the framework links, and not the framework itself, store data, including the above-described definitions for business object types and information describing any association between object types and services.","Alternative to the framework generating persistent data that represents definitions of object types, the framework can include an interface to existing database tables, which typically do not have or is required to have exactly the same name, structure, fields, or data types as would be implemented if the framework were to generate persistent data representing definitions. A mapping between the data of such tables and the data representing the framework definition can be implemented such that the table fields can be, for example, read, inserted, updated, and deleted through the interface. It is sufficient that the tables include the needed information in one form or another because the described mapping can be used to obtain the needed information. Moreover, the tables can be located in a database system not previously used by the framework and executed by a computing device that is remote from one executing the framework (but accessible to the framework through a network).",{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 7","b":["700","700","700","100"]},"The framework  provides a user interface that allows a user to create a current definition of a business object type by associating two or more previously created definitions of business object type (step ). The user interface can include, for example, one or more tables that can be used to relate two or more previously created definitions. In particular, one table can lists previously created definitions and their respective GUIDs. Another of the tables can include a row, in which the inclusion of GUIDs of previously created definitions would create a new definition that is a combination of the definitions included in the row. Alternatively, the user interface can include the above described windows, one of which includes icons representing previously created definitions. A new definition can be created by dragging and dropping selected icons into the window that represents the business object type being defined. In one implementation, the framework provides in the user interface a list of definitions for simple business objects.","The framework receives user input selecting two or more previously created definitions (step ). The selection can be effected as described above in reference to .","The framework creates the current definition in accordance with the user selection (step ). The current definition is simply an association between the two previously created definitions. The framework stores the current definition in memory (step ).","Optionally, the framework can include an interface to an external data object repository. The framework can use the interface, which can be a proprietary interface, to obtain, from the repository, definitions of object types, either by a process that abstracts a definition of an object type from existing definitions in the repository or by a process that simply imports definitions currently existing in the repository. A definition can be passed to the framework by using, for example, XML (extensible markup language) or WSDL (Web services description language) description formats. Once it obtains a definition of a business object type, the framework can generate items required to implement the object type.","As can be seen from the above discussion, the framework  provides functionalities that facilitate the creation of business object definitions at design time. In addition to these design time functionalities, the framework also provides functionalities that facilitate run time tasks, as will be further described below.",{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 8","b":["100","802","804","806","808"]},"The engine  generally provides master data functionalities, services, and tools. It is the engine  that implements the services provided by the framework , examples of which are listed above in Table 1 and further described below in reference to . Optionally, the engine  can import the master data functionalities, services, and tools from modules external to the framework . The modules can be those that were generated and used in a computing system of an enterprise before the framework  was implemented in the system.","The API layer  provides an interface to calling applications that are typically external to the framework. The API layer is configured to recognize definitions having the above-describe data model, that is, data model . Because all definitions created by using the framework adhere to such a data model, the API is compatible with these definitions, regardless of the type of business objects they define.","As mentioned above, the interface  allows the engine  to use plugged-in application logic. The engine  can use such logic, for example, to perform checks on data values for object instances.","The user interface  allows the engine to interact with a user to, for example, create definitions of business object types as described above in reference to . The user interface can be graphical in nature.","Optionally, the run time components of framework  also include an exchange interface proxy  for implementing Web services and an interface  for implementation the distribution of master data. The exchange interface proxy  can be, for example, XI 3.0 available from SAP AG.",{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 9","b":["802","902","804"]},"The engine selects the appropriate definition and instantiates the business object (step ). Selection and instantiation can be done automatically, i.e., without requiring user input. The engine uses the values provided by the calling application to effect instantiation. Typically, instantiation includes generating one or more layers of a business object, including the above described kernel and the interface layer. Other layers that can be generated include, for example, an integrity layer and an access layer. The integrity layer represents the business logic of the object, including rules and constraints that apply to the object. The access layer defines the technologies, for example, COM\/DCOM (component object model\/distributed component object model) that can be used gain access to the object's data.","The engine provides the instantiated business object to the calling application (step ). The instantiated object can be stored in a database external to the framework.","Optionally, the engine  can use application logic to perform semantic checks on data values (step ). Examples of such semantic checks include, for example, ensuring that a data value falls within some expected range specified by business logic.",{"@attributes":{"id":"p-0078","num":"0077"},"figref":"FIG. 10","b":["100","100","1002","1004","1006","1008"]},"The invention can be implemented in digital electronic circuitry, or in computer hardware, firmware, software, or in combinations of them. The invention can be implemented as a computer program product, i.e., a computer program tangibly embodied in an information carrier, for example, in a machine-readable storage device, for execution by, or to control the operation of, data processing apparatus, for example, a programmable processor, a computer, or multiple computers. A computer program can be written in any form of programming language, including compiled or interpreted languages; and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A computer program can be deployed to be executed on one computer or on multiple computers at one site or distributed across multiple sites and interconnected by a communication network.","Method steps of the invention can be performed by one or more programmable processors executing a computer program to perform functions of the invention by operating on input data and generating output. Method steps can also be performed by, and apparatus of the invention can be implemented as, special purpose logic circuitry, for example, an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).","Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer. Generally, a processor will receive instructions and data from a read-only memory or a random access memory or both. The essential elements of a computer are a processor for executing instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, for example, magnetic, magneto-optical disks, or optical disks. Information carriers suitable for embodying computer program instructions and data include all forms of non-volatile memory, including by way of example semiconductor memory devices, for example, EPROM, EEPROM, and flash memory devices; magnetic disks such as internal hard disks and removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in special purpose logic circuitry.","To provide for interaction with a user, the invention can be implemented on a computer having a display device such as a CRT (cathode ray tube) or LCD (liquid crystal display) monitor for displaying information to the user and a keyboard and a pointing device such as a mouse or a trackball by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, such as visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input.","The invention can be implemented in a computing system that includes a back-end component, for example, as a data server, or that includes a middleware component, for example, an application server, or that includes a front-end component, for example, a client computer having a graphical user interface or an Web browser through which a user can interact with an implementation of the invention, or any combination of such back-end, middleware, or front-end components. The components of the system can be interconnected by any form or medium of digital data communication, for example, a communication network. Examples of communication networks include a local area network (\u201cLAN\u201d), a wide area network (\u201cWAN\u201d), and the Internet.","A number of implementations of the invention have been described. Nevertheless, it will be understood that various modifications may be made without departing from the spirit and scope of the invention. For example, an object class can be declared with modifiers that indicate whether the class is public, abstract, or final, a class name, a superclass name, and a list of the interfaces implemented by the class. Process steps can be performed in different order. Accordingly, other implementations are within the scope of the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
