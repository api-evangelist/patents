---
title: Converting dependency relationship information representing task border edges to generate a parallel program
abstract: According to an embodiment, based on task border information, and first-type dependency relationship information containing N number of nodes corresponding to data accesses to one set of data, containing edges representing dependency relationship between the nodes, and having at least one node with an access reliability flag indicating reliability/unreliability of corresponding data access; task border edges, of edges extending over task borders, are identified that have an unreliable access node linked to at least one end, and presentation information containing unreliable access nodes is generated. According to dependency existence information input corresponding to the set of data, conversion information indicating absence of data access to the unreliable access nodes is output. According to the conversion information, the first-type dependency relationship information is converted into second-type dependency relationship information containing M number of nodes (0≦M≦N) corresponding to data accesses to the set of data and containing edges representing inter-node dependency relationship.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09043803&OS=09043803&RS=09043803
owner: Kabushiki Kaisha Toshiba
number: 09043803
owner_city: Tokyo
owner_country: JP
publication_date: 20120110
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATION(S)","FIELD","BACKGROUND","DETAILED DESCRIPTION"],"p":["This application is based upon and claims the benefit of priority from Japanese Patent Application No. 2011-004159, filed on Jan. 12, 2011; the entire contents of which are incorporated herein by reference.","Embodiments described herein relate generally to an information processing apparatus and a computer program product.","A technology is known in which a computer program written for a sequential computing device is parallelized in such a way that it can be processed in parallel by a plurality of cores or processors. While performing parallelization of such a computer program, it is common to parallelize the loops accounting for the majority of the computation time in the computer program. While parallelizing a program containing loops; if it is not clear whether there is dependency between iterations of a loop, a technology is already known that enables performing parallelization when the developer determines that there exists no dependency between the iterations of the loop.","However, in the conventional technology, parallelization of a computer program having data dependency between iterations of a loop is a difficult task. On the other hand, it can also be an option to perform parallelization while ignoring the dependency between iterations. However, in that case, the developer has to insert synchronizations manually by taking into account the dependency relations of all of the data. That puts a lot of burden on the developer. Besides, the method in which the developer determines whether or not to perform parallelization is not practical unless the instructions for parallelization issued by the developer are confined to a loop-by-loop basis. In that regard, there has been a demand for a method or an apparatus that would generate a sophisticated parallel program at a low cost.","According to an embodiment, an information processing apparatus includes an input unit, a generating unit, an instructing unit, and a converting unit. The input unit is configured to receive task border information about task borders of a plurality of tasks and receive first-type dependency relationship information that contains N number of nodes (N is an integer equal to or greater than 1) corresponding to data accesses to a single set of data and that contains edges representing a first-type dependency relationship expressing restrictions on an order of data accesses between the nodes. At least one of the nodes has an access reliability flag that indicates whether corresponding data access is reliable or unreliable. The generating unit is configured to, based on the first-type dependency relationship information, identify task border edges, out of edges extending over the task borders, which have an unreliable access node with unreliable data access linked to at least one end thereof, and configured to generate presentation information containing at least one of the unreliable access nodes that are linked to the task border edges. The instructing unit is configured to receive dependency existence information, which indicates existence of a dependency relationship among the data accesses corresponding to the single set of data, and configured to, according to the dependency existence information, output, to the unreliable access node, conversion information that contains information indicating absence of data access to the unreliable access node. The converting unit is configured to, according to the conversion information, convert the first-type dependency relationship information into second-type dependency relationship information that contains M number of nodes (0\u2266M\u2266N) corresponding to the data accesses to the single set of data and contains edges representing a second dependency relationship between the nodes.","Various embodiments will be described hereinafter with reference to the accompanying drawings.","First Embodiment",{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 1","b":["10","10","10","101","102","103","104","105","106"]},{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 2","b":["101","111","110","111","101","102","111","102","102","112"]},"Subsequently, based on the task border information  and based on the first-type dependency relationship information  analyzed by the analyzing unit , the generating unit  generates presentation information  for the purpose of presentation (S). The instructing unit  determines whether dependency existence information  has been input (S); and, when the dependency existence information  is determined to have been input, the system control moves to S. The instructing unit  refers to the dependency existence information  and generates or updates conversion information  (S), and the system control returns to S. The generating unit  reflects, in the presentation information , the conversion information  that has been updated based on the dependency existence information .","On the other hand, when it is determined that the input of the dependency existence information  has completed and that there is no input of the dependency existence information  at Step S, the system control moves to S. The converting unit  refers to the conversion information  that is generated or updated by the instructing unit , and converts the first-type dependency relationship information  that is analyzed by the analyzing unit  into second-type dependency relationship information  (S). Subsequently, the parallelizing unit  refers to the second-type dependency relationship information  that is obtained by conversion by the converting unit , and generates a parallel program  having synchronizations inserted therein (S).","In the following description, the explanation of each functional block of the parallelization apparatus  is given for the most basic configuration in which the functional blocks are tandemly connected in the sequence illustrated in . However, the first embodiment is not limited to that case. Alternatively, for example, the first embodiment can be implemented for a configuration in which a plurality of functional blocks operate in a coordinated manner; or can be implemented for a configuration in which the sequence of some functional blocks is interchanged; or can be implemented for a configuration in which a particular functional block is divided into a plurality of functional blocks; or can be implemented for a configuration having a combination of the abovementioned three configurations. Besides, the first embodiment can also be implemented by dividing the functional blocks into a plurality of units.","Explained below in detail are the operations performed by various constituent elements of the parallelization apparatus . The input unit  receives the program code  and the task border information  into the parallelization apparatus .  illustrates an example of the program code  and  illustrates an example of the task border information .","The program code  illustrated in  is written in a pseudo-language imitating C language, which is a commonly used programming language. In the program code , a digit and a colon \u201c:\u201d written at the start of each line represent a line number that is assigned to enable identification of that line during the explanation. In the example illustrated in , the program code  has data access expressions \u201ca\u201d, \u201cb\u201d, \u201cc\u201d, \u201cs\u201d, \u201ct\u201d, \u201cu\u201d, \u201cv\u201d, \u201cp\u201d, \u201cq\u201d, \u201c*p\u201d, and \u201c*q\u201d; has the assignment operator \u201c=\u201d; and has the addition operator \u201c+\u201d. The data access expressions are broadly divided into direct access expressions and indirect access expressions. In the following example, each indirect access expression has an asterisk \u201c*\u201d attached thereto. Thus, the indirect access expressions can be distinguished from the direct access expressions.","Herein, the direct access expressions represent those data access expressions which do not make use of dynamic data for determining the position of data to be accessed. For example, with the direct access expression \u201ca\u201d, data \u201ca\u201d is accessed without the use of dynamic data. In contrast, the indirect access expressions represent those data access expressions which make use of dynamic data for determining the position of data to be accessed. For example, with the indirect access expression \u201c*p\u201d written in the fifth line, such data is accessed that is present at the position indicated by dynamic data \u201cp\u201d. Herein, the data present at the position indicated by dynamic data \u201cp\u201d means, for example, that the memory address of that particular data is held by the dynamic data \u201cp\u201d.","With a direct access expression, the data to be accessed is certainly identifiable. In contrast, with an indirect access expression, there are times when the data to be accessed is not identifiable. Hence, the data accessed with the indirect access expression \u201c*p\u201d is sometimes abstractly expressed as data \u201c*p\u201d.","The task border information  illustrated in  indicates that labels \u201clabel_\u201d and \u201clabel_\u201d, which are respectively written in the sixth and tenth lines in the program code  illustrated in , represent task borders.  schematically illustrates an example when the program code , illustrated in , is divided into tasks using the task border information  illustrated in . In this example, according to the task border information , the operations of the program code  are divided into a task , a task , and a task . Meanwhile, a task represents a unit of operations executed by a central processing unit (CPU), and includes one or more operations. Moreover, a task border represents information that indicates a border for dividing an operation, such as data accesses expressed by the program code, into tasks.","In the program code  illustrated in ; the operations are performed in the order of the task , the task , and the task . For convenience of diagrammatic illustration and explanation, the following explanation is given under the assumption that a task border is present at the border between any two different tasks. In the example illustrated in , a task border  is present as the border between the task  and the task ; a task border  is present as the border between the task  and the task ; and a task border  is present as the border between the task  and the task . Meanwhile, in the task border information  in , the information corresponding to the task border  is not included. Thus, it is not necessary to include information corresponding to all task borders in the task border information, and it is also possible that a task border is present in an implicit manner.","Herein, the task border information  is input, for example, by the user (the developer) from a user interface (UI). However, alternatively, based on an analysis result obtained by analyzing the program code , the task border information  can be generated automatically for the input purpose.","The analyzing unit  analyzes the program code  and outputs dependency relationship information.  illustrates an example of the dependency relationship information obtained by analyzing the program code  illustrated in . Herein, as described above, the dependency relationship information output by the analyzing unit  is referred to as the first-type dependency relationship information .","With respect to each set of data written in the program code ; the analyzing unit  considers, as nodes, the data access expressions which are likely to access that set of data, and generates a dependency graph that expresses, with edges between the nodes, the order that needs to be followed in order to obtain a correct execution result. Herein, as long as it is not analyzed that any particular data will not be accessed, it is analyzed that the particular data is likely to be accessed.","A node represents information corresponding to the data accesses to a single set of data and having an access reliability flag that indicates whether the particular data access is reliable or unreliable. For a single set of data, N number of nodes (where N is an integer equal to or greater than 1) is present. An edge represents information expressing restrictions on the order of data access that needs to be followed in order to obtain a correct execution result.","In , the data \u201ca\u201d, data \u201cb\u201d, and data \u201cc\u201d in the program code  are respectively illustrated by a dependency graph , a dependency graph , and a dependency graph . For convenience of explanation, it is assumed that the dependency relationships between the other data do not become dependency relationships between tasks. In  and in similar diagrams referred to hereinafter, if a node has the alphabet \u201cW\u201d written therein, that node indicates a write access; and a node has the alphabet \u201cR\u201d written therein, that node indicates a read access.","In , as edges are illustrated a true dependence representing reading after writing; an anti-dependence representing writing after reading; and an output dependence representing writing after writing. For example, \u201ca=0\u201d written in the first line and \u201ca=2\u201d written in the fourth line indicate that values \u201c0\u201d and \u201c2\u201d are respectively substituted in the data \u201ca\u201d. In the dependency graph , the output dependence representing writing after writing is illustrated as an edge that links the node corresponding to \u201ca=0\u201d with the node corresponding to \u201ca=2\u201d.","The analyzing unit  analyzes the data accessed by each node of a dependency graph and accordingly sets the access reliability flag to each node. The access reliability flag is set to have either a value indicating \u201creliable\u201d or a value indicating \u201cunreliable\u201d. A node that is assigned with the value indicating \u201creliable\u201d in the access reliability flag is referred to as a reliable access node, and a node that is assigned with the value indicating \u201cunreliable\u201d in the access reliability flag is referred to as an unreliable access node. In  and in similar diagrams referred to hereinafter, the reliable access nodes are illustrated with a \u201c\u2022 (filled circle)\u201d and the unreliable access nodes are illustrated with a \u201c\u2218 (open circle)\u201d. Moreover, in the following explanation, when a value indicating \u201creliable\u201d or \u201cunreliable\u201d is set in an access reliability flag, it is described as \u201csetting of a value of an access reliability flag to \u201creliable\u201d (or \u201cunreliable\u201d)\u201d.","When it can be regarded that, with respect to the at least one external input value of the program code  being analyzed, a node accesses the data corresponding to the external input value; and the analyzing unit  sets the node to have \u201creliable\u201d as the value of the access reliability flag; while, on the other hand, when it cannot be regarded that a node accesses the data, the analyzing unit  sets the node to have \u201cunreliable\u201d as the value of the access reliability flag. Herein, an external input points to data for which the values are input from the outside of the program code ; and an external input value points to the value of the data that is input by means of the external input. In the example of the program code  illustrated in , the data \u201cp\u201d and data \u201cq\u201d written in the fifth and eighth line, respectively, are input by means of the external input.","In a direct access expression, since the data to be accessed is identifiable irrespective of the external input values, the access reliability flag is set to the value \u201creliable\u201d. In contrast, in an indirect access expression, the value of the access reliability flag is set according to the analysis result of the dynamic data that is used in deciding the access destination. In the example illustrated in , regarding the access reliability flag of the nodes corresponding to indirect access expressions; it cannot be determined whether the dynamic data \u201cp\u201d and the data \u201cq\u201d, which are used in deciding the access destinations, take arbitrary values or take limited values. Hence, in each of the data \u201ca\u201d, the data \u201cb\u201d, and the data \u201cc\u201d; the node corresponding to the data access expression \u201c*p\u201d as well as the node corresponding to a data access expression \u201c*q\u201d is generated as an unreliable access node.","Meanwhile, in a case when the dynamic data used in deciding the access destination of an indirect access expression could be analyzed, it is possible either to generate the node corresponding to that indirect access expression as a reliable access node or not to generate that node. Since a dependency graph is constructed for each set of data; there is a possibility that, with respect to a single indirect access expression, the type or the existence criterion is different for the node corresponding to each set of data.","In response to an instruction issued by the user in an interactive manner using the generating unit  and the instructing unit ; the parallelization apparatus  generates the conversion information , which is put to use by the converting unit . Herein, the user points either to a person using the parallelization apparatus  or to another apparatus. For example, the user can be the developer of the parallel program or can be a dependency existence determining apparatus that automatically determines existence of dependency in the data accesses of data.","The generating unit  generates the presentation information  by referring to the first-type dependency relationship information  generated by the analyzing unit  and by referring to the task border information  input from the input unit .  illustrate examples in which the first-type dependency relationship information  and the task border information  is combined regarding the data \u201ca\u201d, the data \u201cb\u201d, and the data \u201cc\u201d, respectively. Thus, in ; the task border information  is added while expressing the dependency graphs , , and that are illustrated in  corresponding to the data \u201ca\u201d, the data \u201cb\u201d, and the data \u201cc\u201d, respectively.","In the example illustrated in , regarding the dependency graph related to the data \u201ca\u201d; nodes , , , , , and respectively represent the data access expression \u201ca\u201d of \u201ca=0\u201d written in the first line in the program code , the data access expression \u201ca\u201d of \u201ca=2\u201d written in the fourth line in the program code , the data access expression \u201c*p\u201d of \u201cs=*p\u201d written in the fifth line in the program code , the data access expression \u201c*q\u201d of \u201c*q=4\u201d written in the eighth line in the program code , the data access expression \u201ca\u201d of \u201ct=a\u201d written in the 11-th line in the program code , and the data access expression \u201ca\u201d of \u201cv=a+c\u201d written in the 13-th line in the program code .","In an identical manner, in the example illustrated in , regarding the dependency graph related to the data \u201cb\u201d; nodes , , , and respectively represent the data access expression \u201cb\u201d of \u201cb=1\u201d written in the second line in the program code , the data access expression \u201c*p\u201d of \u201cs=*p\u201d written in the fifth line in the program code , the data access expression \u201c*q\u201d of \u201c*q=4\u201d written in the eighth line in the program code , and the data access expression \u201cb\u201d of \u201cu=b\u201d written in the 12-th line in the program code .","Moreover, in the example illustrated in , regarding the dependency graph related to the data \u201cc\u201d; nodes , , , , and respectively represent the data access expression \u201c*p\u201d of \u201cs=*p\u201d written in the fifth line in the program code , the data access expression \u201cc\u201d of \u201cc=3\u201d written in the seventh line in the program code , the data access expression \u201c*q\u201d of \u201c*q=4\u201d written in the eighth line in the program code , the data access expression \u201cc\u201d of \u201cc=5\u201d written in the ninth line in the program code , and the data access expression \u201cc\u201d of \u201cv=a+c\u201d written in the 13-th line in the program code .","The generating unit  does not convert all of the first-type dependency relationship information  into the presentation information , but limits the first-type dependency relationship information  that is to be converted into the presentation information . That enables the user to easily or speedily conclude the task of issuing instructions for generating the conversion information .","Explained below is a method for limiting the first-type dependency relationship information  that is to be converted into the presentation information . Hereinafter, an edge extending over a task border is referred to as a task border edge; a node linked to a task border edge is referred to as a task border node; and an edge having at least one unreliable access node linked thereto is referred to as an unreliable edge. Besides, an edge that is not only a task border edge but also an unreliable edge is referred to as an unreliable task-border edge.","In order to enable the user to easily or speedily conclude the task of issuing instructions, the generating unit  generates such presentation information  that is related to at least one unreliable access node linked to at least one unreliable task-border edge. Thus, if the user goes on sequentially issuing instructions regarding at least one unreliable access node linked to at least one unreliable task-border edge, it becomes possible to eliminate the unreliable task-border edges with the least number of user instructions.","On the other hand, as far as an unreliable access node not linked to an unreliable task-border edge is concerned, a corresponding instruction may go to waste depending on the result of an instruction issued regarding a node lying closer to the task border than that particular unreliable access node.","Explained below is an example in which the generating unit  generates presentation information related to the dependency graph . In the dependency graph illustrated in , the nodes and are present as unreliable access nodes. Besides, as a task-border edge that extends over a task border and that is linked to at least one of the nodes and ; there exist three unreliable task-border edges, namely, a single unreliable task-border edge that intersects the task border  and two unreliable task-border edges that intersect the task border .",{"@attributes":{"id":"p-0100","num":"0099"},"figref":["FIG. 10","FIG. 10"],"b":["114","201","114","403","404","450","403","404"],"i":["a ","a ","a ","a. "]},"Meanwhile, the presentation information  is, for example, display information generated from a rendering application programming interface (API) of an operating system (OS) while the parallelization apparatus  is running as a computer program. For example, the presentation information  is transmitted to the user in the form of image information that is displayed on a display. Alternatively, the presentation information  can also be transmitted in the form of data in a file or in a memory.","As described above, it is only necessary to generate the presentation information  related to at least one unreliable access node that is linked to an unreliable task-border edge. Hence, as illustrated in the example in , the node and the node that are positioned on either side of the unreliable task-border edge  are not presented. Rather, for example, the presentation information  can be generated related only to the node while excluding the node ","Even regarding the nodes that are not directly linked to an unreliable task-border edge, the generating unit  can be configured to recognize the nodes that may get involved with task-border edges and the nodes that will not get involved with task-border edges, and to accordingly provide different methods of generating the presentation information.","For example, the node illustrated in  or the node illustrated in  is not linked to any task border edge and does not get involved in any task border edge. For that reason, the method of presentation can be so changed that the node or the node is excluded from the presentation information , or the node or the node is displayed in a different display color than the display color of the other nodes. In this way, if the method of presentation for the nodes not involved with a task border edge is set to be different than the method of presentation for the nodes that are likely to get involved with a task boarder edge, it becomes possible to generate such presentation information  that is helpful to the user in issuing instructions.","Explained below is an exemplary method that enables the generating unit  to detect nodes that do not get linked to task boundary edges. The generating unit  identifies all reliable write nodes, which point to the reliable access nodes performing the write operation. In the example illustrated in , the nodes and are reliable write nodes.","When there exists at least a single node identified as a reliable write node in at least a single path from a node N, which is included in a task T, into another task T; it is determined that the node N would not get linked to the task border edge between the task Tand the task T.","For example, in the example illustrated in , in a path that reaches the task  from the node via the nodes and , there exists the node identified as a reliable write node. Hence, the node is not linked to the task border edge of the task border . In an identical manner, it can be determined that the node is not linked to any of the task borders included in the dependency graph illustrated in . Similarly, it can also be determined that the node illustrated in  is not linked to any of the task borders included in the dependency graph ","Herein, a path can be followed only via the edges having the same orientation. In the example illustrated in , while reaching the node from the node via the nodes , , and ; the node can be reached via only those edges which have the same orientation. Hence, that case confirms with the abovementioned explanation of a path. In contrast, while reaching the node from the node via the node illustrated in ; the node needs to be reached from the node and the node needs to be reached from the node via the node . In this case, the edge heading from the node toward the node and the edge heading from the node toward the node via the node have different orientations. Hence, that case does not confirm with the above-mentioned explanation of a path.","Regarding a method for the generating unit  to detect a node that does not get linked to a task border edge as described above, the following method can be considered if the attention is paid to two threads and a task border therebetween. That is, in this method, firstly, with respect to one task direction adjacent to a task border edge, a reliable write node having the least task border distance is identified. It is determined whether or not at least a single reliable write node that has been identified is present on at least one of the paths leading to task border edges from each node included in the first-type dependency relationship information  (dependency graph). If no reliable write node that has been identified is determined to be present, it is determined that there is a possibility of a link between the identified node and a task border edge. On the other hand, if a reliable write node that has been identified is determined to be present, it is determined that the identified node does not get linked to a task border edge.","Herein, the task border distance, which is the distance from a single node or from a single edge up to a single task border, is defined as the least number of nodes that are passed while reaching the task border from the single node or from the single edge. With respect to a single node, the task border distance is defined to be equal to the number of task borders. For example, in the example illustrated in , from the node up to the task border , the task border distance is \u201c0\u201d; while from the node up to the task border , the task border distance is \u201c2\u201d.","The instructing unit  receives the dependency existence information  and generates the conversion information . Herein, the dependency existence information  represents the information regarding the existence of nodes or edges that are elements of dependency graphs. The conversion information  represents the information illustrating a method for the converting unit  to convert the first-type dependency relationship information  into the second-type dependency relationship information .",{"@attributes":{"id":"p-0112","num":"0111"},"figref":["FIG. 11","FIG. 11","FIG. 10"],"b":["115","115","301","403","301"],"i":["a ","a ","a. "]},"From the dependency existence information , the instructing unit  generates the conversion information  so as to enable reversal of values of the access reliability flags of the nodes that are included in the dependency existence information .  illustrates an example of the conversion information  generated from the dependency existence information  illustrated in . In the example illustrated in , from the dependency existence information  illustrated in , \u201cchange flag node A\u201d is generated as the conversion information  that enables reversal of value of the access reliability flag of the node A (the node ). For example, depending on the information related to the task border nodes of the unreliable task-border edge extending over the task border , the user operates the UI of the instructing unit  and selects a node for which the value of the access reliability flag is to be reversed.","In the examples illustrated in , the dependency existence information  and the conversion information  is illustrated to be having different formats. However, alternatively, it is also possible to have the same format for the dependency existence information  and the conversion information .","Until the generating unit  and the instructing unit  finish inputting the dependency existence information  to the instructing unit , the user keeps on communicating with the parallelization apparatus . Thus, the conversion information  generated by the instructing unit  is input to the generating unit . By reflecting that conversion information in the presentation information , the generating unit  updates the presentation information .  illustrates an example of new presentation information  that is updated by reflecting the conversion information  illustrated in  in the presentation information  illustrated in . In this example, it is illustrated that the conversion information  illustrated in  reverses the value of the access reliability flag of the node A (the node ). Thus, in the new presentation information  illustrated in , the node A (the node ) is updated to a reliable access node from an unreliable access node.","Moreover, as illustrated in , assume that \u201cno access node B\u201d is input to the instructing unit  as the dependency existence information  indicating that the node B (the node ) does not access the data \u201ca\u201d. According to the dependency existence information  that has been input, the instructing unit  adds a command for deleting the node B (the node ) in the conversion information  illustrated in  and updates the conversion information . The updated conversion information  is input to the generating unit , which reflects that conversion information  in the presentation information  and updates the presentation information .","With the update of the presentation information  as illustrated in , the unreliable task-border nodes related to the data \u201ca\u201d are eliminated. Hence, the focus is moved to performing the operation of generating the conversion information  and the presentation information  for the subsequent set of data (for example, the data \u201cb\u201d). Depending on the presentation information , the user sequentially inputs the dependency existence information . Once inputting of the dependency existence information  for the dependency graphs of all sets of data (in the example illustrated in , for the data \u201ca\u201d, the data \u201cb\u201d, and the data \u201cc\u201d) and updating of the conversion information  is complete, it is determined that the dependency existence information  has been completely input. That marks the end of the communication with the user.",{"@attributes":{"id":"p-0118","num":"0117"},"figref":"FIG. 16","b":["107","115"]},"With the use of the conversion information  generated by the instructing unit , the converting unit  converts the first-type dependency relationship information  into the second-type dependency relationship information . That is, according to the conversion information , the converting unit  converts the first-type dependency relationship information  into the second-type dependency relationship information  that contains M number of nodes (0\u2266M\u2266N) corresponding to the data accesses to a single set of data and that contains edges indicating a second dependency relationship between those nodes.","In the conversion information , the nodes indicated with a \u201cchange flag\u201d instruction are subjected to a reversal in the values of the respective access reliability flags. For example, if an access reliability flag has the value \u201cunreliable\u201d, that value is changed to the value \u201creliable\u201d due to the \u201cchange flag\u201d instruction. Moreover, the nodes indicated with a \u201cdelete\u201d instruction are deleted. In the example illustrated in , regarding the data \u201ca\u201d in the conversion information ; it is illustrated that the access reliability flag of the node A (the node ) is reversed, and the node B (the node ) is deleted. Regarding the data \u201cb\u201d, it is illustrated that the access reliability flag of a node C (the node ) is reversed, and a node D (the node ) is deleted. Regarding the data \u201cc\u201d, it is illustrated that a node E (the node ) is deleted.",{"@attributes":{"id":"p-0121","num":"0120"},"figref":["FIGS. 17","FIGS. 7","FIG. 17"],"b":["18","19","301","302","303","112","8","9","107","311","312","313","113","105","107"],"i":["a","b","c ","a","b","c"]},"With reference to , regarding the data \u201ca\u201d, the access reliability flag of the node illustrated in  is reversed to have the value \u201creliable\u201d (a node ) according to \u201cchange flag node A\u201d written in the conversion information  illustrated in . Moreover, the node illustrated in  is deleted (see the task  in ) according to \u201cdelete node B\u201d. Along with the reversal of the value of the access reliability flag of the node and the deletion of the node , edge information related to the node and the node is also changed. Where, a node corresponds to the node illustrated in .","With reference to , regarding the data \u201cb\u201d, the access reliability flag of the node illustrated in  is reversed to have the value \u201creliable\u201d (node ) according to \u201cchange flag node C\u201d written in the conversion information  illustrated in . Moreover, the node illustrated in  is deleted (see the task  in ) according to \u201cdelete node D\u201d. Along with the reversal of the value of the access reliability flag of the node and the deletion of the node , edge information related to the node and the node is also changed.","With reference to , regarding the data \u201cc\u201d, the node illustrated in  is deleted (see the task  in ) according to \u201cdelete node E\u201d written in the conversion information  illustrated in , and edge information related to the node is also changed. Where, a node corresponds to the node illustrated in ; and a node corresponds to the node illustrated in .","In this way, the parallelizing unit  makes use of the second-type dependency relationship information  that obtained by conversion by the converting unit  based on the conversion information , and determines the positions of synchronizations and generates the parallel program  having synchronizations inserted therein.","The parallelizing unit  extracts the task border edges included in the second-type dependency relationship information and analyzes execution order restrictions that need to be followed at the time of execution.  illustrates an example in which the task border edges illustrated in , , and  are associated with the program code  illustrated in .","Herein, task border edges , , and are the edges between the task  and the task . The task border edge links a node and a node from the node toward the node ; the task border edge links the node and a node from the node toward the node ; and the task border edge links a node and a node from the node toward the node . Besides, a task border edge is the edge between the task  and the task , and links a node and a node from the node toward the node ","The execution order restrictions are applied according to the orientations of the task border edges. Since no task border edge is present in between the task  and the task , no execution order restrictions are applied. In contrast, between the task  and the task  are present the execution order restrictions of the task border edges , , and . Similarly, between the task  and the task  is present the execution order restriction of the task border edge . In order to obtain a correct calculation result, such order restrictions need to be followed.","Meanwhile, the parallelizing unit  can also be configured to perform optimization of the synchronizations that are output. For example, a method of inserting the requisite minimum synchronizations is known. The execution order restrictions have an inclusion relation between them. Thus, there are times when a particular execution order restriction is satisfied, the other execution order restrictions are also satisfied. In the example illustrated in , if the execution order restriction represented by the task border edge is followed, the execution order restrictions represented by the task border edges and are also followed. Hence, as illustrated in , the requisite minimum execution order restrictions between tasks are only regarding the task border edges and ","Explained below is an example of an inclusion relation detecting algorithm for detecting the inclusion relation between such execution order restrictions. Consider the case of the task A, the task B, and two dependency relationships Dand Doriented from the task A toward the task B. Compare the start points and the end points of the two dependency relationships Dand D. When the execution order of the start point of the dependency relationship Dis either same as or later than the execution order of the start point of the dependency relationship Dand when the execution order of the end point of the dependency relationship Dis either same as or earlier than the execution order of the end point of the dependency relationship D, the dependency relationship Dincludes the dependency relationship D. As a result, once the execution order restriction represented in the dependency relationship Dis satisfied, the execution order restriction represented in the dependency relationship Dalso gets satisfied.","This represents the inclusion relationship detecting algorithm for a simple example as illustrated in . However, in a case when the tasks are divided at a plurality of locations as illustrated in  or when taking into consideration the local variables of the C language, it is necessary to implement an inclusion relationship detecting algorithm according to the input-output information supported by the parallelization apparatus.","The parallelizing unit  outputs the parallel program  having synchronizations inserted therein that satisfy the execution order restrictions represented by the task border edges.  illustrates an example of the parallel program  that is generated by extracting the requisite minimum task border edges from the task border edges illustrated in . An execution order restriction is expressed by transfer of a token (TOKID_x: where ID_x is an identifier), and the task border edge corresponds to a token  and the task border edge corresponds to a token . The tokens correspond to commands put_token and get_token having the same identifier; and after the command put_token is executed, it is guaranteed that the corresponding command get_token is spared from execution.","According to the first embodiment, in the generating unit  and the instructing unit , such dependency relationship information is provided which enables the user to determine the positions for inserting synchronizations not by having to refer to all of the information but only by referring to the individual information. That makes it possible to easily insert synchronizations of high quality.",{"@attributes":{"id":"p-0134","num":"0133"},"figref":["FIG. 23","FIGS. 7 to 9","FIG. 5","FIG. 23"],"b":["10","103","104","105","112","102","106","710","711","712"]},"As compared to the parallel program  illustrated in  according to the first embodiment, the parallel program illustrated in  has fewer parts that can be subjected to parallel execution. In the parallel program  illustrated in , a part R and a part S can be subjected to parallel execution; a part T and a part U can be subjected to parallel execution; the part T and the part S can be subjected to parallel execution; and the part S and the part U can be subjected to parallel execution. Moreover, the part T and \u201cv=a+c\u201d in the task  can also be subjected to parallel execution. In contrast, in the parallel program not according to the first embodiment, only a part V and a part W illustrated in  can be subjected to parallel execution. Hence, as compared to the parallel program not according to the first embodiment, the parallel program  according to the first embodiment can be said to be sophisticated from the perspective of parallelization.","Meanwhile, the first embodiment is not confined to the abovementioned example. Alternatively, the program code  can be provided as a text file having stored therein text data written in a programming language such as C language or Java (registered trademark). Besides, the program code  can be provided as a file of text data written in an independent programming language. Moreover, the program code  need not be text data having easily comprehensible structure for a person, but can be a binary file having binary data stored therein.","Furthermore, all the information of the program code  need not be stored in a single file, but can be dividedly stored in a plurality of files. Moreover, the program code  need not be in the format of a file, and can be in the form of data stored in a memory. For example, as the program code , it is possible to input a syntactic tree that represents data generated in a memory by a syntactic parsing apparatus of C language. Meanwhile, the program code  need not have the description of all the necessary operations, but can also be a part of a larger program code.","The task border information  is provided, for example, as a text file having stored therein text data indicating the task border positions in the program code . However, the task border information  need not be a file of text data having easily comprehensible structure for a person, but can be a binary file having binary data stored therein.","Moreover, the task border information  need not be in the format of a file, and can be in the form of data stored in a memory. For example, a task-border-position specifying apparatus with a graphical user interface (GUI) can be provided for generating the task border information . In that case, for example; the task-border-position specifying apparatus displays the program code  on a screen so that intended positions of the task borders can be specified using a pointing device such as a mouse, and the specified positions can be output as task borders to the memory. Meanwhile, the task border information  need not be specified by the user, but can be output by a different apparatus upon analyzing the program code . For example, with the use of a task-border-information generating apparatus, a \u201clabel_\u201d, the label \u201clabel_\u201d, and the label \u201clabel_\u201d illustrated in  can be recognized as task borders and the positions thereof can be output to the memory. Moreover, for example, the program code  written in C language can be analyzed and searched for the positions of loops, and the task borders can be recognized to be at such positions that are half of the loop iteration frequency, and those positions can be output to the memory.","Meanwhile, the program code  and the task border information  can be combined to be a single set of data. For example, in an example in which a portion of the program code  is bracketed off in a labeled curly bracket and the curly bracket is used to separate a task; the program code  and the task border information  get combined.","A task is a portion of the operation for expressing the program code . One task can contain a plurality of discontinuous operations. For example, in the example illustrated in , the task  and the task  are illustrated to be different tasks. However, alternatively, as illustrated in , the task  and the task  can also be considered to be a single task . When the task  and the task  are considered to be the single task , it is not possible to perform parallel execution of the task  and the task . In that case, there is no need to take into consideration the dependency between the task  and the task . Hence, the task border , which is the border between the anterior half of the task  and the task , as well as the task border , which is the border between the task  and the posterior half of the task , serve as the task borders in the program code .","Besides, the program code  or the task border information  can also hold parent-child information of the tasks included therein. For example, in the case of parallelizing only the loop portions of the program code  including pre-processing, loops, and post-processing; child tasks for performing parallel execution of the loops are started from parent tasks including pre-processing and post-processing. By taking into consideration the dependency relationships only between the child tasks to be subjected to parallel execution, the parallelizing unit  either can be spared from optimizing the dependency relationships between the parent tasks and the child tasks or can be configured to perform optimization by taking into consideration the dependency relationships between the parent tasks and the child tasks. Meanwhile, the relationship between the parent tasks and the child tasks is not confined to two levels, but can be of an arbitrary number of levels. That is, the child tasks can further start grandchild tasks.","A task border partitions not the program code  but the operations expressed by the program code . There are examples, as illustrated in the example in , when partitioning of the program code  and partitioning of the operations expressed by the program code  is equivalent. However, there are times when partitioning of the program code  and partitioning of the operations expressed by the program code  is not equivalent. For example, if loops of C language are included with respect to the program code , partitioning of the program code  and partitioning of the operations expressed by the program code  becomes not equivalent. The inside of a loop written in C language represents operations for only a single iteration in the program code . However, in actuality, the operations may be performed for a plurality of iterations. Hence, it is also possible to specify a task border midway of loop iteration. For example, if the loop has 100 iterations, a task border can be specified at the end of the fiftieth iteration. By specifying the task border in this way, it becomes possible to implement data partitioning parallelization using arrays.","As long as the task borders represent the information that enables identification of the tasks to which the data accesses belong, there is no restriction on the format of the task borders. For example, by holding the information of the task to which the data accesses belong, the portion at which the belonging task changes can be considered to be the task border edge.","There are various types to data access expressions. Apart from the data access expressions used in the example illustrated in , for example, function calls of C language can also become a type of data access expression. In a case when the data \u201ca\u201d and the data \u201cb\u201d are accessed in a function f( ) either the function call f( ) can be considered to be a data access expression of the data \u201ca\u201d and the data \u201cb\u201d, or, instead of considering the function call f( ) as a data access expression, a data access expression in the function can be directly used. As in the case of considering the function call f( ) to be a data access expression of the data \u201ca\u201d and the data \u201cb\u201d, it is possible that a single data access expression accesses a plurality of sets of data.","A direct access expression and an indirect access expression differ according to the type of the program code . In the example illustrated in , the data access expression \u201ca\u201d is classified as a direct access expression. However, it is not the only case. Alternatively, for example, in C++ language, depending on the type definition of a variable \u201ca\u201d; the data access expression \u201ca\u201d illustrated in  may be an indirect access expression.","Meanwhile, it is not necessary that the identifier constituting a data access expression has a correspondence relation of 1:1 with the data to be accessed. In the example illustrated in , although the data access expression \u201ca\u201d is assumed to access the data \u201ca\u201d, the same correspondence relation is not present in C language. Rather, in C language, the identifier \u201ca\u201d itself does not enable determining whether the data access expression \u201ca\u201d access a local variable \u201ca\u201d or a global variable \u201ca\u201d. Hence, it is also necessary to analyze the variable declaration given in the program code . If the analyzing unit  is configured to be capable of analyzing C language, it becomes possible to determine, without having to using dynamic data, whether the data access expression \u201ca\u201d accesses a local variable \u201ca\u201d or a global variable \u201ca\u201d. With that, the data access expression and the data can be related to each other.","In the description given above, a dependency graph is expressed with a structure in which the true dependence, the anti-dependence, and the output dependence are represented as edges. However, that is not the only possible case. Alternatively, as long as a dependency graph, that is, the first-type dependency relationship information  is expressed equivalently to the structure thereof, it is also possible to express a stricter dependence. For example, in a definition usage tree expressing the relationship between definitions of data and usage of data as well as expressing the order relation of definitions; the anti-dependence is not demonstratively represented as edges. However, it is possible to derive the anti-dependence from the order relation of definitions. For example, in an order array in the program code  that represents the order relation of data accesses; in addition to the fact that the order relation of read accesses are expressed, it is also possible to insert synchronizations either by deriving the dependency relationship from that order relation or by using only the order relation.","In the description given above, as illustrated in , dependency graphs are constructed regarding the data that is accessed only by direct access expressions. However, that is not the only case. That is, dependency graphs can also be constructed regarding the data that is accessed by indirect access expressions. For example, in , there is a possibility that the data access expression \u201c*p\u201d written in the fifth line as well as the data access expression \u201c*q\u201d written in the eighth line reads data \u201cz\u201d that is not expressed in the program code. Hence, by constructing dependency graphs related to the data \u201c*p\u201d and the data \u201c*q\u201d, a correct parallel program can be generated even when the data \u201cz\u201d is accessed by the data \u201c*p\u201d and the data \u201c*q\u201d.","Meanwhile, the nodes of a dependence graph may not hold the information that indicates a write access or a read access. Even when there is no read\/write information, there are times when the generating unit  or the parallelizing unit  can make use of the read\/write information depending on the method of presenting the information or depending on the method of parallelizing. For example, using the order relation as the dependency relationship information falls under that case.","The edges of a dependency graph can also be made to express loop dependency or control dependency. The parallelizing unit  can recognize the edges representing loop dependency or control dependency, and insert synchronizations in an appropriate manner.","In a dependency graph, it is sufficient if at least one node has the access reliability flag. If a particular node does not have the access reliability flag, it is possible to treat that node to be equivalent to a node having the access reliability flag or to supplement the information about the access reliability flag from other information. For example, regarding a read access node not having the access reliability flag, a read access node in the dependency graph for an indirect access expression can be treated to be the node having \u201cunreliable\u201d as the access reliability flag. In this example, as the dependency existence information, it is also possible to input the data corresponding to each read access node in the dependency graphs for indirect access expressions.","Regarding the access reliability flag depending on an external input value that has not been analyzed, the analyzing unit  can set \u201creliable\u201d as that access reliability flag. For example, as compared to the program code  illustrated in , a program code  illustrated in  has the following if statement added therein: \u201cif data \u201cz\u201d has value \u201c0\u201d, data \u201cp\u201d points to data \u201ca\u201d. According to the program code  illustrated in FIG. ; if the data \u201cz\u201d has the value \u201c0\u201d, the data access expression \u201c*p\u201d accesses the data \u201ca\u201d. In that case, in a precise sense, the value \u201c0\u201d of the external input \u201cz\u201d may not be obtained. Hence, in the dependency relationship information of the data \u201ca\u201d, \u201cunreliable\u201d is set as the access reliability flag of the node corresponding to the data access expression \u201c*p\u201d. However, since the if statement in the program code  illustrated in  can be interpreted to have been written under the assumption that the condition of having \u201c0\u201d as the value of the data \u201cz\u201d is satisfied, the node corresponding to the data access expression \u201c*p\u201d of the data \u201ca\u201d can also be considered to be a reliable access node.",{"@attributes":{"id":"p-0154","num":"0153"},"figref":["FIG. 26","FIG. 25","FIG. 6","FIG. 3","FIG. 26","FIG. 6"],"b":["112","2002","301","111","301","302","303"],"i":["a ","a","b ","c "]},"In the description given above, the presentation information  and the first-type dependency relationship information  express the same structure. However, that is not the only case, and it is also possible that the presentation information  and the first-type dependency relationship information  express different structures. For example, as a dependency graph illustrated in , the first-type dependency relationship information  related to the data \u201ca\u201d is held as the order array of data accesses; and, in the presentation information , can be converted into a dependency graph  divided on a task-by-task basis as illustrated in . In this way, when the presentation information  and the first-type dependency relationship information  express different structures; the instructing unit  can receive the dependency existence information  with respect to the presentation information , but needs to appropriately convert the dependency existence information  into the conversion information .","The generating unit  may not contain some portion held by the first-type dependency relationship information  in the presentation information . For example, even if the first-type dependency relationship information  is holding the read\/write information of nodes, it is possible for the generating unit  not to contain that read\/write information in the presentation information . For example, by limiting the elements of a dependency graph that can provide the dependency existence information , it becomes possible to not contain the access reliability flags in the presentation information  and to make them function as the parallelization apparatus . More particularly, even if the information about nodes is not directly included in the presentation information ; as illustrated in , a program code  can be included in the presentation information  and the edges linking the data access expressions in the program code  can be included in the presentation information . As another example, without including the information about edges in the presentation information , only the information about nodes can be included.","Besides, supplementary information of the presentation information  can be received from the input unit , and the generating unit  can include that supplementary information in the presentation information . The examples of the supplementary information with respect to the presentation information  include critical path information and execution path information.","The generating unit  can identify at least one node and, at the time of generating the presentation information  of each node depending on whether or not the identified node is present in at least one of the paths leading to task border edges from the nodes included in the first-type dependency relationship information, can treat the identified node to be different from a reliable write node. Irrespective of the type of the identified node, the method of generating the presentation information  can be changed with the identified node considered to be a border. For example, only the nodes on the task border side of the identified node can be included in the presentation information . Meanwhile, instead of identifying nodes, the same result can be achieved by identifying edges.","Regarding the method that is employed by the generating unit  for identifying at least one node and generating the presentation information  depending on whether or not the identified node is present in at least one of the paths leading to a task border edge from the nodes included in the first-type dependency relationship information ; the method of expression differs depending on what type of data structure is used at the time of holding the first-type dependency relationship information , and there are a plurality of methods which, in essence, perform the same operations.","For example, when the order relation is used as the first-type dependency relationship information , the presentation information  can be generated depending on the order relation between each node and the task border. That method is same as the method of generating the presentation information  depending on whether or not an identified node is present in at least one of the paths. Thus, if the order relation is in the order of a particular node, at least one of the identified nodes, and the task border, the identified node lies in at least one of the paths leading to the task border from the particular node. In contrast, if the order relation is in the order of all identified nodes, a particular node, and the task border, the identified nodes do not lie on any of the paths leading to the task border from the particular node.","Meanwhile, the generating unit  can generate the presentation information  by selecting the information to be presented as well as selecting the method of presentation. As a first example thereof, a presentation policy can be considered in which only the information related to a single selected unreliable task-border edge is presented. As a second example, a presentation policy can be considered in which all of the dependency relationship information related only to the data \u201ca\u201d is not presented. As a third example, a presentation policy can be considered in which the task border edges are displayed in an accented color such as red and the other edges are displayed in an unaccented color such as black. As a fourth example, a presentation policy can be considered in which only those nodes or edges are presented for which the dependency existence information  needs to be input from the instructing unit . As a fifth example, a presentation policy can be considered in which the sizes of nodes are changed according to the distances from task borders. These five presentation policies are only exemplary, and it is also possible to implement other presentation policies or implement a combination of a plurality of presentation policies. Besides, a presentation policy either can be incorporated in the generating unit  or can be input from outside.","Moreover, the generating unit  can also be configured to implement a combination of the method of identifying at least one node and generating the presentation information  depending on whether or not the identified node is present in at least one of the paths leading to a task border edge from the nodes included in the first-type dependency relationship information ; and the method of generating the presentation information of each node according to the presentation policy. For example, it is possible to think of a method in which only the unreliable access nodes on the inside of the identified task are included in the presentation information .","Herein, whether or not the identified node is present corresponds to distinguishing the operations with respect to the node between portions requiring human judgment and portions not requiring human judgment. Besides, by distinguishing between portions requiring human judgment and portions not requiring human judgment according to the presentation policy, it becomes possible to perform the operations in an easier and speedier manner.","Meanwhile, as the dependency existence information , the instructing unit  can receive the dependency existence information not of the nodes but of the edges. For example, in the dependency graph illustrated in , by issuing an instruction that the two edges extending over the task border  are not present; it becomes possible to analyze the fact that the node does not access the data \u201ca\u201d.","Alternatively, as the dependency existence information , the instructing unit  can receive the dependency existence information of a plurality of nodes or edges. For example, the instructing unit  can receive dependency existence information which indicates that none of the unreliable access nodes in the dependency graph illustrated in  is involved in dependency. In that case, from the dependency graph , the node and the node can be deleted.","Still alternatively, as the dependency existence information , the instructing unit  can input data and correspondence information of the data. For example, if \u201cdata \u201c*p\u201d and data \u201ca\u201d do not have correspondence relation\u201d is input as the dependency existence information , the converting unit  can remove the node of the data access expression \u201c*p\u201d from the dependency graph of the data \u201ca\u201d and remove the node of the data access expression \u201ca\u201d from the dependency graph of the data \u201c*p\u201d.","In the instructing unit , the input of the dependency existence information  can be completed while in the state of not receiving an instruction related to any unreliable task-border edge, and the system control may proceed to the conversion of dependency relationship information performed at S illustrated in . In this case, there is a possibility that a task border edge has an unreliable access node linked thereto. The manner in which that unreliable access node is treated depends on the mounting policy of the entire apparatus. For example, if it is to be considered that data is accessed from the unreliable access node, that unreliable access node is converted into a reliable access node. On the other hand, if it is to be considered that data is not accessed from the unreliable access node, that unreliable access node is deleted and the dependency relationship information is reconstructed. Moreover, in this case, since there is a possibility of incorrect operations, a warning can also be issued.","Meanwhile, the parallel program  is, for example, an executable file. Alternatively, the parallel program  can also be a text file in which is stored the text data written in a programming language such as C language or Java (registered trademark) or a text file in which is stored the text data written in an independent programming language of the parallelization apparatus . Regarding the parallel program , all of the information need not be stored in a single file but can be dividedly stored in a plurality of files. Moreover, the parallel program  need not be in the format of a file, and can be in the form of data stored in a memory. For example, the parallel program  can be executable data that has been output by a compiler during execution and that is stored in memory. Furthermore, the parallel program  need not have the description of all the necessary operations. Rather, the parallel program  can be an object file that is used in combination with other object files.","As described above, according to the first embodiment, from among a huge amount of data access related information that is included in the program code , the requisite minimum information is selected and presented. That enables the user to easily and speedily issue a change instruction regarding the dependency relationship of data accesses between tasks. As a result, a sophisticated parallel program can be generated at a low cost.","Moreover, according to the first embodiment, only the requisite minimum nodes are presented, and the information on the respective surrounding nodes is also presented. That enables the user to know the information related to the surrounding nodes as well.","Second Embodiment",{"@attributes":{"id":"p-0172","num":"0171"},"figref":["FIG. 30","FIG. 30","FIG. 1"],"b":["20","20","116","20","5001","5002","5003","5004","5005","5006"]},{"@attributes":{"id":"p-0173","num":"0172"},"figref":"FIG. 31","b":["5001","111","110","111","201","5002","111","112","202"]},"Subsequently, based on the task border information \u2032 and based on the first-type dependency relationship information  analyzed by the analyzing unit , the generating unit  generates the presentation information  for the purpose of presentation (S). The instructing unit  determines whether the dependency existence information  has been input (S) and, when the dependency existence information  is determined to have been input, the system control moves to S. The instructing unit  refers to the dependency existence information  and generates or updates the conversion information  (S), and the system control returns to S. The generating unit  reflects, in the presentation information , the conversion information  that has been updated based on the dependency existence information .","On the other hand, when it is determined that the input of the dependency existence information  has completed and that there is no input of the dependency existence information  at Step S, the system control moves to S. The converting unit  refers to the conversion information  that is generated or updated by the instructing unit , and converts the first-type dependency relationship information  that is analyzed by the analyzing unit  into the second-type dependency relationship information  (S). Subsequently, the repositioning unit  refers to the second-type dependency relationship information  that is obtained by conversion by the converting unit , and generates and outputs the parallel program \u2032 having repositioned synchronizations (S).","In the following description, the explanation of each functional block of the synchronization optimization apparatus  is given for the most basic configuration in which the functional blocks are tandemly connected in the sequence illustrated in . However, the second embodiment is not limited to that case. Alternatively, for example, the second embodiment can be implemented for a configuration in which a plurality of functional blocks operate in a coordinated manner; or can be implemented for a configuration in which the sequence of some functional blocks is interchanged; or can be implemented for a configuration in which a particular functional block is divided into a plurality of functional blocks; or can be implemented for a configuration having a combination of the above-mentioned three configurations. Besides, the second embodiment can also be implemented by dividing the functional blocks into a plurality of units.","The input unit  receives the program code \u2032 and the task border information \u2032 into the synchronization optimization apparatus . Herein, the program code \u2032 represents a parallel program that is already divided on a task-by-task basis using some known method and that has the tasks subjected to parallelization. Thus, the program code \u2032 contains the task border information \u2032.",{"@attributes":{"id":"p-0178","num":"0177"},"figref":["FIG. 32","FIG. 32"],"b":["111","110","111","111","1","2","3","110"]},"The analyzing unit  analyzes the program code \u2032 and the task border information \u2032, and outputs the first-type dependency relationship information .","The analyzing unit  refers to synchronization information specified in the program code \u2032 and analyzes execution order restrictions applied on the computer program by the program code \u2032. In the example illustrated in , the synchronization information contains the commands put_token and get_token and contains identifiers for identifying tokens that are transferred using those commands. The command put_token is a command for delivering a token, while the command get_token is a command for receiving a token. The analyzing unit  analyzes that the commands put_token and get_token having the same identifier are in a corresponding relation.",{"@attributes":{"id":"p-0181","num":"0180"},"figref":["FIG. 33","FIG. 32","FIG. 33"],"b":["111","111","111","912","1","913","2","911","3","911","912","901","912","913","902","911","913","903"]},"Herein, the term \u201cblock\u201d refers to consecutive processing not containing a synchronization code. The analyzing unit  extracts such a block from each task in the program code \u2032. In the example illustrated in , the 17-th to 20-th lines in the task  constitute a single block . Similarly, the third line and the fourth line in the task  constitute a single block , while the sixth line in the task  constitutes a single block . Moreover, the 11-th line and the 12-th line in the task  constitute a single block , while the 14-th line in the task  constitutes a single block .","In , the command put_token and the command get_token that are in a correspondence relation are linked with arrows indicating synchronization positions. The analyzing unit  refers to the correspondence relation of the synchronization information illustrated in  and analyzes execution order restrictions in the program code \u2032 illustrated in .",{"@attributes":{"id":"p-0184","num":"0183"},"figref":"FIG. 34","b":["111","5002"],"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":["(1) An execution order restriction is applied in which the blocks included in the same task are to be executed in downward sequence from above (i.e., from the blocks having smaller line numbers to the blocks having larger line numbers).","(2) An execution order restriction is applied in which, for blocks included in different tasks, the operation prior to the corresponding command put_token is followed by the operation subsequent to the command get_token."]}},"For example, the block  included in the task  and the block  included in the task  are included in different tasks. Hence, between the block  and the block , the execution order restriction (2) is applied by the commands put_token and get_token having TOKID_ as the identifier. In contrast, between the blocks  and  that are included in the same task , the execution order restriction (1) is applied in which execution is performed in downward sequence from above.","In this way, by analyzing the execution order restrictions in the program code \u2032, the execution order restrictions among the blocks are obtained as illustrated in . There, the execution is performed in the sequence of the block  and the block . After executing the block , the block  and the block  are executed. After executing the blocks  and , the block  is executed.","The analyzing unit  refers to the execution order restrictions that have been analyzed and analyzes the first-type dependency relationship information .  illustrates an example of the first-type dependency relationship information  that is analyzed by referring to the execution order restrictions illustrated in . In , the program code illustrated on the left side is given only for the purpose of enabling greater understanding of the correspondence relation of each node. In actuality, the first-type dependency relationship information  does not hold the information regarding the program code.","Once the data access expressions are executed in the order of the execution order restrictions, the analyzing unit  generates a dependency graph by referring to the execution order of the data access expressions. For example, in the block , \u201ca=0\u201d, \u201ca=2\u201d, and \u201cs=*p\u201d are accessed in that particular order; then in the block , \u201c*q=4\u201d is accessed; then in the block , \u201ct=a\u201d is accessed; and then in the block , \u201cv=a+c\u201d is accessed. From such an access order, a dependency graph illustrated in  is generated. Regarding the data \u201cb\u201d and the data \u201cc\u201d, dependency graphs and are respectively generated in an identical manner.","When the nodes that are linked to the edges specified in the first-type dependency relationship information  belong to different tasks, the analyzing unit  analyzes that task borders are present at such edges. In the example illustrated in , as described above, the task border between the tasks  and  is referred to as the task border , the task border between the tasks  and  is referred to as the task border , and the task border between the tasks  and  is referred to as the task border .","Meanwhile, the generating unit , the instructing unit , and the converting unit  have identical functions to the functions of the generating unit , the instructing unit , and the converting unit , respectively, illustrated in  according to the first embodiment. Moreover, the operations are also identical to the operations performed in the parallelization apparatus  according to the first embodiment. Hence, the explanation thereof is not repeated.","The repositioning unit  refers to the second-type dependency relationship information  obtained by conversion by the converting unit , re-determines the positions of synchronizations, and generates the parallel program \u2032 having the re-determined synchronizations inserted therein. The operations performed by the repositioning unit  differ from the operations performed by the parallelizing unit  in the parallelization apparatus  in the following points:\n\n","For example, the dependency existence information  identical to that explained in the first embodiment is provided to the program code \u2032 containing the task border information \u2032; and, the conversion information  illustrated in  is generated based on the dependency existence information . With respect to the second-type dependency relationship information , which is obtained by the converting unit  by converting the first-type dependency relationship information  on the basis of the conversion information ; the repositioning unit  analyzes necessary synchronizations in an identical manner to that explained in the first embodiment and outputs the parallel program \u2032 having optimized synchronizations as illustrated in .","In this way, according to the second embodiment, instead of inputting a sequential program, even if a parallel program that has already been subjected to parallelization is input; it is still possible to perform meaningful processing. That is, with respect to the parallel program that has been input, synchronizations are optimized so as to enable achieving enhancement in the performance of the parallel program.","Third Embodiment","In a third embodiment, while a parallel program is running, a runtime library is configured to change dependency relationship information that indicates the dependency relationship of data accesses in a parallel program.",{"@attributes":{"id":"p-0196","num":"0199"},"figref":["FIG. 37","FIG. 31","FIG. 1"],"b":["1230","1230","1220","1221","1210","116"]},"If the parallelization system  illustrated in  is compared to the parallelization apparatus  according to the first embodiment, some constituent elements of the parallelization apparatus  are included in the code converting unit  and the other constituent elements are included in the runtime library unit . The interface  included in the parallel program \u2033 is, for example, an API of the runtime library unit . Via the interface , the parallel program \u2033 can communicate with the runtime library unit .","Moreover, as compared to the parallelization apparatus  illustrated in , the parallelization system  illustrated in  has an interface (I\/F) inserting unit  and an information generating unit  added therein.","In the third embodiment, in the code converting unit , the parallelizing unit \u2032 refers to task border information \u2033 and generates a parallel program A by parallelizing a program code \u2033. The interface inserting unit  refers to the first-type dependency relationship information , which is analyzed by the analyzing unit  on the basis of the program code \u2033 and the task border information \u2033, as well as refers to the presentation information , which is obtained by the generating unit  by converting the first-type dependency relationship information ; and generates the parallel program \u2033 by inserting the interface  in the parallel program A that is generated by the parallelizing unit \u2032.","Moreover, between the program code \u2033 that is input as a sequential program and the parallel program A that is obtained by conversion of the program code \u2033, mutually and functionally equivalent memory access is performed. For example, in the program code \u2033, if the indirect access expression \u201c*p\u201d accesses the data \u201ca\u201d, even in the parallel program A that is obtained by parallelizing the program code \u2033, the indirect access expression \u201c*p\u201d refers to the same data \u201ca\u201d.",{"@attributes":{"id":"p-0201","num":"0204"},"figref":"FIG. 38","b":["1500","1500","1600","1601","1603"]},"The synchronization interface inserting unit  refers to the first-type dependency relationship information  and inserts a synchronization interface  in the parallel program \u2033. The relationship information generating unit  receives the presentation information  and generates relationship information  that expresses a correspondence relation between write accesses for the dynamic data, which is used in deciding the access destinations of indirect access expressions, and nodes corresponding to indirect access expressions for which the existence of access is determined by the write accesses. Based on the relationship information , the dependency-existence-information updating interface inserting unit  inserts a dependency-existence-information updating interface  in the parallel program \u2033.","The interface  includes the synchronization interface  and the dependency-existence-information updating interface  that are inserted in the parallel program \u2033 by the interface inserting unit .","The first-type dependency relationship information  generated in the code converting unit  is delivered to the runtime library unit  via a first-type-dependency-relationship-information file  that expresses the dependency relationship between data accesses using the extensible markup language (XML) format. The first-type dependency relationship information  generated by the analyzing unit  is first stored in the first-type-dependency-relationship-information file  by a dependency information output unit , and delivered to the runtime library unit  and input to a converting unit .","In the first embodiment, the user generates the dependency existence information  and inputs it using the instructing unit . In contrast, in the third embodiment, the dependency existence information  is generated by the information generating unit  via the dependency-existence-information updating interface  of the parallel program \u2033, and is input to an instructing unit .","The runtime library unit  and the parallel program \u2033 are compiled to an executable state and are executed in a program execution environment of a processor. The parallel program \u2033 is executed along with the runtime library unit  in, for example, an execution environment that is partially or entirely common with the runtime library unit . Once the execution starts, the converting unit  in the runtime library unit  reads the first-type dependency relationship information  that is stored in the first-type-dependency-relationship-information file .","Meanwhile, along with the execution of the parallel program \u2033, the execution result of the dependency-existence-information updating interface  that has been inserted is delivered to the information generating unit  in the runtime library unit . The execution result of the dependency-existence-information updating interface  contains, for example, the information indicating whether or not the interface  has been executed. Depending on the execution result for the interface , the information generating unit  generates the dependency existence information . That dependency existence information  is input to the instructing unit .","From the dependency existence information  input thereto, the instructing unit  generates the conversion information . Subsequently, based on the conversion information , the converting unit  converts the first-type dependency relationship information , which has been read from the first-type-dependency-relationship-information file , into the second-type dependency relationship information . The second-type dependency relationship information  is input to the synchronization interface  in the parallel program \u2033. The synchronization interface  reflects the second-type dependency relationship information  during synchronization of tasks of the parallel program \u2033.","The parallelization system  according to the third embodiment can have a number of variations. For example, the code converting unit  can be included in the execution environment of the parallel program \u2033. Besides, regarding the method of transferring the first-type dependency relationship information  between the code converting unit  and the execution environment, various methods can be implemented. For example, the first-type dependency relationship information  can be transferred not only by storing it in a file but also as data in a memory. Similarly, regarding the method of inserting the interface  in the parallel program \u2033, various methods can be implemented. For example, the interface  can be inserted not only on a line-by-line basis in the program code but also on a block-by-block basis, where each block has a plurality of lines in the program code.","Moreover, the operations of the interface  and the runtime library unit , which serves as the function of the interface , can also be performed in many ways. For example, there can be separate interfaces for deleting unreliable access nodes and for changing unreliable access nodes into reliable access nodes, or there can be a single interface performing both of those functions.","According to the third embodiment, the parallelization system  monitors the execution of the parallel program \u2033 by inserting the interface . However, that is not the only possible case. That is, the execution of the parallel program \u2033 can also be monitored by implementing some other method. For example, a method can be implemented in which, instead of inserting anything in the parallel program \u2033, the OS is instructed to monitor the execution of the program code of the parallel program \u2033; and, when a CPU command under monitoring is executed, synchronization or dependency existence is updated. In the case of instructing the OS to monitor the execution status; the relationship information  is referred to for setting, in the OS, the commands to be monitored by the OS and the operations to be performed in response to the execution of those commands.","Meanwhile, the functions of the parallelization system  illustrated in  can also be implemented using hardware or using software running in the CPU. Alternatively, the functions can be implemented by a combination of hardware and software. Moreover, regarding the program code \u2033, the task border information \u2033, the input unit , the analyzing unit , the first-type dependency relationship information , and the information generated and used by those components; a number of variations are possible as described in the first embodiment.","Besides, the method of using the second-type dependency relationship information , which is obtained by conversion by the runtime library unit , is also not limited to the explanation given above. For example, each time the second-type dependency relationship information  is updated, the updating details can be stored as trace information, which can be put to use at the time of generating the parallel program as dependency relationship information that reflects dynamic information.","Explained below with reference to a sample code is the configuration of the parallel program or the operations of the runtime library unit .  illustrates an example of the program code \u2033 that is input to the code converting unit . In the program code \u2033, the data represents the dynamic data used in deciding the access destination of the indirect access expression \u201c*p\u201d; and a data access by the indirect access expression \u201c*p\u201d points to an unreliable access node. In this program code \u2032, the data accessed by the data \u201cp\u201d is decided depending on the branching of the if statement condition written between the second line and the sixth line.","When the if statement yields \u201ctrue\u201d, the code \u201cp=&a\u201d is executed and the indirect access expression \u201c*p\u201d accesses the data \u201ca\u201d. In contrast, when the if statement yields \u201cfalse\u201d, the code \u201cp=&b\u201d is executed and the indirect access expression \u201c*p\u201d accesses the data \u201cb\u201d. Thus, the access to the node of the indirect access expression \u201c*p\u201d can be decided according to the result of the if statement condition.",{"@attributes":{"id":"p-0216","num":"0219"},"figref":"FIG. 40","b":["110","111","111","2","3","111"]},{"@attributes":{"id":"p-0217","num":"0220"},"figref":"FIG. 41","b":["102","111","112","1301","1302","1303"],"i":["a","b","c "]},{"@attributes":{"id":"p-0218","num":"0221"},"figref":["FIG. 42","FIG. 39","FIG. 40"],"b":["111","110","110","111","1400","1401","1402","1400","1401","1410","1401","1402","1411","1400","1402","1412"]},{"@attributes":{"id":"p-0219","num":"0222"},"figref":["FIG. 43","FIGS. 40 to 42","FIG. 43"],"b":["112","111","102","1","1400","2","1401","3","1402","1400","1402","1410","1411","1412","2"]},"By referring to the edges extending over the task borders  to , the analyzing unit  can identify the dependency relationship between the respective tasks. At that time, if no node of the target data exists in a particular task, even if an edge is present at the task border related to that particular task, there is no dependency relationship between that particular task and the data. For example, in the example illustrated in , regarding the data \u201ca\u201d, it is illustrated that an unreliable task-border edge is present between the task Task and the task Task. Regarding the data \u201cc\u201d, it is illustrated that an unreliable task-border edge is present between the task Task and the task Task.","On the basis of the task border information \u2032, the parallelizing unit \u2032 converts the program code \u2033 into the parallel program A. For example, the parallelizing unit \u2032 converts the program code \u2033 into the parallel program A that is divided on a task-by-task basis. In the parallel program A; the tasks Task, Task, and Task are defined by codes \u201cTask\u201d, \u201cTask\u201d, and \u201cTask\u201d, respectively, along with curly brackets \u201c{ . . . }\u201d.","With respect to the parallel program A generated by the parallelizing unit \u2032, the interface inserting unit  inserts commands or functions valid_node( ), invalid_node( ), post_sync( ), and wait_sync( ); and generates the parallel program \u2033.  illustrates an example of the parallel program \u2033 generated on the basis of the program code \u2033 illustrated in . In the following explanation, for the sake of convenience, the commands or functions valid_node( ), invalid_node( ), post_sync( ), and wait_sync( ) are explained as commands.","The commands valid_node( ) and invalid_node( ) represent dependency-existence-information updating interfaces. The commands post_sync( ) and wait_sync( ) represent synchronization interfaces. A dependency-existence-information updating interface inserted in the parallel program A is the dependency-existence-information updating interface . In an identical manner, a synchronization interface inserted in the parallel program A is the synchronization interface . These commands are the interfaces (APIs) that are used in communicating with the runtime library unit  and that constitute the interface .","The dependency-existence-information updating interface  monitors the write accesses to the dynamic data that is used in deciding the access destinations of indirect access expressions included in the parallel program \u2033, and sends the monitoring result to the runtime library unit .","The commands valid_node( ) and invalid_node( ) that constitute the dependency-existence-information updating interface  are interfaces for updating the dependency existence information related to the unreliable task-border nodes. The commands valid_node( ) and invalid_node( ) update the information regarding unreliable nodes as well as change the unreliable nodes into reliable nodes or delete unreliable nodes. The commands valid_node( ) and invalid_node( ) are inserted by the interface inserting unit  at the access locations for those variables which are responsible for unreliable task-border nodes. Herein, variables affecting the state of unreliable task-border nodes are the variables used in deciding the access destinations of the abovementioned indirect access expressions. More particularly, in a programming language such as C language, pointers or array indices represent such variables.","The relationship information generating unit  generates the relationship information  that is related to the existence of accesses between unreliable task-border nodes included in the presentation information  and the data accesses that decide the existence of accesses of those unreliable task-border nodes. Herein, the relationship information  is referred to for inserting the commands valid_node( ) and invalid_node( ).","The relationship information  that is generated by the relationship information generating unit  contains position information indicating the positions in the parallel program A for inserting the commands valid_node( ) and invalid_node( ) and contains arguments to be assigned to those commands. An argument contains identifiers for identifying the node to which the corresponding command points to. Herein, a variable access represents, for example, substitution of an address in a pointer variable that is an indirect access expression.",{"@attributes":{"id":"p-0228","num":"0231"},"figref":["FIG. 45","FIG. 43","FIG. 45"],"b":["112","1","2","3","111","102","1220","112","116"]},{"@attributes":{"id":"p-0229","num":"0232"},"figref":["FIG. 46","FIG. 45","FIG. 46"],"b":["1602","1602","116","1602","1","2"]},"The dependency-existence-information updating interface inserting unit  analyzes the accesses with respect to the variables in the program code and extracts such data accesses that exert influence on the existence of the data accesses with respect to those variables or affect changing of the access reliability flag from \u201cunreliable\u201d to \u201creliable\u201d of unreliable access nodes. At that time, the dependency-existence-information updating interface inserting unit  performs this type of analysis regarding all types of accesses, such as a direct access expression and an indirect access expression, related to a particular variable.","The following explanation is given with reference to the program code \u2033 that is a sequential program illustrated in . As is the case in the third line in the program code \u2033, when the code is written so as to set the data \u201ca\u201d in the indirect access expression \u201c*p\u201d; the interface inserting unit  refers to the relationship information  illustrated in . More particularly, from the relationship information  illustrated in , the dependency-existence-information updating interface inserting unit  can obtain the information regarding the commands valid_node( ) and invalid_node( ) that are to be inserted as dependency-existence-information updating interfaces. The dependency-existence-information updating interface inserting unit  refers to the relationship information  and, for example, inserts the dependency-existence-information updating interfaces that are associated with the monitoring position information on the code \u201cp=&a\u201d.","As illustrated in , regarding the data \u201ca\u201d, there exist two unreliable task-border nodes, namely, a node identified by the identifiers \u201cVAR_ID_\u201d and \u201cNODE_ID_\u201d and a node identified by the identifiers \u201cVAR_ID_\u201d and \u201cNODE_ID_\u201d. Thus, as written in the fourth and fifth lines in the parallel program \u2033 illustrated in , commands valid_node(VAR_ID_, NODE_ID_) and valid_node(VAR_ID_, NODE_ID_) are inserted with the aim of changing those nodes into reliable access nodes. Similarly, regarding the data \u201cb\u201d, there exist two unreliable task-border nodes, namely, a node identified by the identifiers \u201cVAR_ID_\u201d and \u201cNODE_ID_\u201d and a node identified by the identifiers \u201cVAR_ID_\u201d and \u201cNODE_ID_\u201d. Regarding these nodes, as written in the sixth line in the parallel program \u2033 in , commands invalid_node(VAR_ID_, NODE_ID_) and invalid_node(VAR_ID_, NODE_ID_) are inserted with the aim of deleting those nodes.","Meanwhile, in the third embodiment, the explanation is given for an example in which the substitution with respect to the indirect access expression \u201c*p\u201d is monitored by the insertion performed by the dependency-existence-information updating interface . However, it is not the only possible case. Alternatively, it is possible to monitor the reference with respect to the indirect access expression \u201c*p\u201d or to monitor the substitution as well as the reference with respect to the indirect access expression \u201c*p\u201d.","The commands post_sync( ) and wait_sync( ) constituting the synchronization interface  are synchronization interfaces for controlling inter-task synchronization. When there exists an edge starting from a particular access node, the command post_sync( ) is inserted immediately after the code statement specifying that access. In contrast, when there exists an edge leading to a particular access node, the command wait_sync( ) is inserted immediately prior to the code statement specifying that access.","In comparison with the first-type dependency relationship information  illustrated in  or in ; in the example of the parallel program \u2033 illustrated in , a command post_sync(VAR_ID_, NODE_ID_) is inserted immediately after an access with respect to the data \u201ca\u201d by a direct access expression as written in the 15-th line. Moreover, commands post_sync(VAR_ID_, NODE_ID_), post_sync(VAR_ID_, NODE_ID_), and post_sync(VAR_ID_, NODE_ID_) are inserted immediately after an access with respect to the data \u201cc\u201d by the indirect access expression \u201c*p\u201d as written in the 17-th line.","Regarding the command wait_sync( ), immediately prior to an access with respect to the data \u201cc\u201d by a direct access expression as written in the 24-th line, a command wait_sync(VAR_ID_, NODE_ID_) is inserted. Similarly, immediately prior to an access with respect to the data \u201cb\u201d by a direct access expression as written in the 26-th line, a command wait_sync(VAR_ID_, NODE_ID_) is inserted. Moreover, immediately prior to an access with respect to data \u201ct\u201d by the indirect access expression \u201c*p\u201d as written in the 33-rd line, a command wait_sync(VAR_ID_, NODE_ID_) and a command wait_sync(VAR_ID_, NODE_ID_) are inserted.","Explained below in a schematic manner are the functions performed by each command constituting the interface .","(a) Command valid_node( ):","Sends, to the converting unit  via the information generating unit  and the instructing unit  of the runtime library unit , the conversion information  used in changing the node specified in the argument into a reliable access node.","More particularly, when the command valid_node( ) is executed in the interface ; to the information generating unit  are delivered an argument containing an identifier that identifies data and a node and an identifier that identifies the node, and an instruction for changing the node that has been specified in the argument into a reliable access node. The information generating unit  refers to the information received from the command valid_node( ) and generates the dependency existence information . The instructing unit  refers to the dependency existence information  and generates the conversion information  that is used in changing the node that has been specified in the argument into a reliable access node, and sends that conversion information  to the converting unit . Meanwhile, in an identical manner, execution results of the commands invalid_node( ), post_sync( ), and wait_sync( ), described later, are also sent to the converting unit .","The converting unit  refers to the conversion information  sent thereto and accordingly updates the second-type dependency relationship information . In a case such as at the time of executing the parallel program \u2033 for the first time when the second-type dependency relationship information  does not exist, the second-type dependency relationship information  can be generated on the basis of the first-type dependency relationship information  read from the first-type-dependency-relationship-information file . Meanwhile, when there is an access with respect to an indirect access expression, the command valid_node( ) is inserted for a number of times that is equal to the number of unreliable task-border nodes corresponding to the data set in that indirect access expression. In the command valid_node( ), the unreliable task-border nodes corresponding to the data set in the indirect access expression are specified in the arguments.","(b) Command invalid_node( ):","Sends, to the converting unit  via the information generating unit  and the instructing unit  of the runtime library unit , the conversion information  used in deleting the node specified in the argument. The converting unit  refers to the conversion information  and deletes unreliable access nodes from the second-type dependency relationship information . In a case such as at the time of executing the parallel program \u2033 for the first time when the second-type dependency relationship information  does not exist, the second-type dependency relationship information  can be generated on the basis of the first-type dependency relationship information  read from the first-type-dependency-relationship-information file . Meanwhile, when there is an access with respect to an indirect access expression, the command invalid_node( ) is inserted for a number of times that is equal to the number of unreliable task-border nodes corresponding to the data not set in that indirect access expression. In the command invalid_node( ), the unreliable task-border nodes corresponding to the data not set in the indirect access expression are specified in the arguments.","(c) Command post_synch( ):","Checks the second-type dependency relationship information  and, when a node specified in the argument is present, sends the conversion information  used in deleting the edge starting from that particular node to the converting unit  via the information generating unit  and the instructing unit  of the runtime library unit . In a case such as at the time of executing the parallel program \u2033 for the first time when the second-type dependency relationship information  does not exist, the second-type dependency relationship information  can be generated on the basis of the first-type dependency relationship information  read from the first-type-dependency-relationship-information file . Meanwhile, the command post_sync( ) is inserted when the edge starting from the target node is a reliable task-border edge or an unreliable task-border edge.","(d) Command wait_sync( ):","Refers to the second-type dependency relationship information ; checks, when the node specified in the argument is present, whether or not there exists an edge reaching that node; and sends, to the converting unit  via the information generating unit  and the instructing unit  of the runtime library unit , a request to determine whether to start execution or to wait for synchronization. In response to that request, the converting unit  refers to the second-type dependency relationship information  based on the conversion information . At that time, the converting unit  uses the conversion information  only for the purpose of referring to the second-type dependency relationship information , and does not make any changes in the dependency relationship information. In a case such as at the time of executing the parallel program \u2033 for the first time when the second-type dependency relationship information  does not exist, the second-type dependency relationship information  can be generated on the basis of the first-type dependency relationship information  read from the first-type-dependency-relationship-information file . Meanwhile, the command wait_sync( ) is inserted when the edge leading to the target node is a reliable task-border edge or an unreliable task-border edge.","With the commands inserted into the parallel program \u2033 by the dependency-existence-information updating interface inserting unit , the execution results of the dependency-existence-information updating interface  are delivered to the information generating unit . Based on those execution results, the information generating unit  generates the dependency existence information . By referring to the dependency existence information , the data accesses in the running parallel program \u2033 are monitored. In other words, it can be said that the dependency-existence-information updating interface inserting unit , the dependency-existence-information updating interface , and the information generating unit  constitute a monitoring unit for monitoring the data accesses in the parallel program \u2033. Meanwhile, in the case of instructing the OS to monitor the data accesses as described above, the functional components constituting a monitoring unit are different than in the third embodiment.",{"@attributes":{"id":"p-0249","num":"0252"},"figref":["FIG. 47","FIG. 51","FIG. 44","FIG. 47","FIG. 44","FIG. 51","FIGS. 47 and 51"],"b":["116","116"]},"Firstly, explained below with reference to  is an execution image in chronological order when the if statement yields \u201ctrue\u201d.","(1) Each of the task Task, the task Task, and the task Task starts execution. The task Task need not wait for synchronization and thus starts operations. The task Task executes the command wait_sync(VAR_ID_, NODE_ID_). Herein, as illustrated in , the node specified in the argument is present. Thus, firstly, it is checked whether there exists an edge starting from the node specified in the argument. Since such an edge exists, the task Task falls into a synchronization waiting mode. The task Task executes the command wait_sync(VAR_ID_, NODE_ID_). In this case, since the node specified in the argument is present, it is checked whether there exists an edge leading to that node. Since such an edge exists, the task Task also falls into the synchronization waiting mode. Meanwhile, the tasks Task and Task, which cannot start operations while in the synchronization waiting mode, perform polling and repeatedly check the respective conditions.","(2) The task Task continues with the processing of the computer program and finishes processing of the if statement. In this example, it is assumed that the if statement yields \u201ctrue\u201d. There, the task Task executes the commands valid_node(VAR_ID_, NODE_ID_) and valid_node(VAR_ID_, NODE_ID_) written in the fourth and fifth lines, respectively, and updates the target nodes to reliable access nodes in the second-type dependency relationship information . Moreover, the task Task executes the commands invalid_node(VAR_ID_, NODE_ID_) and invalid_node(VAR_ID_, NODE_ID_) written in the sixth and seventh lines, respectively, and deletes not only the target nodes but also the edges linked to those nodes.","Thus, for example, when the commands valid_node(VAR_ID_, NODE_ID_) and valid_node(VAR_ID_, NODE_ID_) are executed, the information generating unit  generates the dependency existence information  according to the arguments. The conversion information , which is used in changing the nodes that are specified in the arguments into reliable access nodes, is sent to the converting unit  via the instructing unit  of the runtime library unit .","The same is the case regarding the commands invalid_node(VAR_ID_, NODE_ID_) and invalid_node(VAR_ID_, NODE_ID_). The converting unit  refers to the conversion information  sent thereto and updates the second-type dependency relationship information . The interface  reflects the updated second-type dependency relationship information  in the execution of the parallel program \u2033.",{"@attributes":{"id":"p-0255","num":"0258"},"figref":["FIG. 48","FIG. 45"],"b":["113","1","2","1","3","2","1","2","3","112","1","2","1","3","1301","1","2","1","2","3","2","2","1302","1"],"i":["a","b"]},"(3) The task Task continues with the execution and, after setting the value \u201c2\u201d in the direct access expression \u201ca\u201d written in the 15-th line, executes the command post_sync(VAR_ID_, NODE_ID_) written in the 16-th line. Since the target node (VAR_ID_, NODE_ID_) is present, the edge starting from that node (VAR_ID_, NODE_ID_) is deleted.  illustrates an example of the second-type dependency relationship information  after deleting that edge. In comparison with , it can be seen that the edge starting from the node (VAR_ID_, NODE_ID_) and leading to the node (VAR_ID_, NODE_ID_) is deleted (dependency graph -).","(4) The task Task continues with the execution and sets the value of the indirect access expression \u201c*p\u201d, that is, the value \u201c2\u201d of the data \u201ca\u201d in the data \u201cc\u201d written in the 17-th line. Subsequently, with respect to the node related to the indirect access expression \u201c*p\u201d, the command post_sync(VAR_ID_, NODE_ID_) written in the 18-th line and the command post_sync(VAR_ID_, NODE_ID_) written in the 19-th line are executed. Since the target nodes (VAR_ID_, NODE_ID_) and (VAR_ID_, NODE_ID_) are present, the edges starting from those nodes are deleted.  is an example of the second-type dependency relationship information  after deleting those edges. In comparison with , it can be seen that the edge starting from the node (VAR_ID_, NODE_ID_) and leading to the node (VAR_ID_, NODE_ID_) as well as the edge starting from the node (VAR_ID_, NODE_ID_) and leading to the node (VAR_ID_, NODE_ID_) is deleted (dependency graph -, dependency graph -).","(5) The task Task continues with the execution, and executes the command post_sync(VAR_ID_, NODE_ID_) written in the 20-th line. In this case, since the target node (VAR_ID_, NODE_ID_) has already been deleted, no operation is performed in actuality.","(6) Meanwhile, the task Task, which is performing polling in response to the command wait_sync(VAR_ID_, NODE_ID_), refers to the second-type dependency relationship information  illustrated in  and detects that the edge leading to the target node (VAR_ID_, NODE_ID_) has been deleted. Hence, the task Task starts the execution.","(7) In an identical manner, the task Task, which is performing polling in response to the command wait_sync(VAR_ID_, NODE_ID_), refers to the second-type dependency relationship information  illustrated in  and detects that the edge leading to the target node (VAR_ID_, NODE_ID_) has been deleted. Thus, the task Taks also starts the execution.","(8) The task Task executes the command wait_sync(VAR_ID_, NODE_ID_) written in the 32-nd line. However, since the edge leading to the target node (VAR_ID_, NODE_ID_) has already been deleted, no operation is performed. Subsequently, according to the code written from the 33-rd line to the 35-th line, the task Task sets the value of the data \u201ct\u201d in the data accessed by the indirect access expression \u201c*p\u201d and sets a value obtained by adding the value of a direct access expression \u201cv\u201d and the value \u201c3\u201d in a direct access expression \u201cu\u201d. Moreover, in the value of the direct access expression \u201cv\u201d, the task Task sets a value obtained by adding the value of a direct access expression \u201cs\u201d and the value \u201c5\u201d.","(9) The task Task sets the value \u201c3\u201d in the direct access expression \u201cc\u201d written in the 24-th line and executes the command wait_sync(VAR_ID_, NODE_ID_) written in the 25-th line. However, as illustrated in , since the edge leading to the target node (VAR_ID_, NODE_ID_) does not exist, the task Task continues with the execution.","(10) Subsequently, the task Task sets the value \u201c4\u201d in the direct access expression \u201cb\u201d written in the 26-th line and executes the command post_sync(VAR_ID_, NODEID2). However, as illustrated in , since the edge leading to the target node (VAR_ID_, NODE_ID_) does not exist, no operation is performed in actuality. The task Task sets the value \u201c5\u201d in the direct access expression \u201cc\u201d.","Explained below with reference to  is an execution image in chronological order when the if statement yields \u201cfalse\u201d.","(1) Each of the task Task', the task Task, and the task Task starts the execution. The task Task can start the operations. The task Task executes the command wait_sync(VAR_ID_, NODE_ID_). Herein, as illustrated in , since there exists an edge starting from the node specified in the argument, the task Task falls into the synchronization waiting mode. The task Task executes the command wait_sync(VAR_ID_, NODE_ID_). In that case too, since the node specified in the argument is present, it is checked whether there exists an edge leading to that node. Since such an edge exists, the task Task also falls into the synchronization waiting mode. The tasks Task and Task, which cannot start operations while in the synchronization waiting mode, perform polling and repeatedly check the respective conditions.","(2) The task Task continues with the processing of the computer program and finishes processing of the if statement. In this example, it is assumed that the if statement yields \u201cfalse\u201d. There, the task Task executes the commands valid_node(VAR_ID_, NODE_ID_) and valid_node(VAR_ID_, NODE_ID_) written in the 10-th and 11-th lines, respectively, and updates the target nodes to reliable access nodes in the second-type dependency relationship information . Moreover, the task Task executes the commands invalid_node(VAR_ID_, NODE_ID_) and invalid_node(VAR_ID_, NODE_ID_) written in the 12-th and 13-th lines, respectively, and deletes not only the target nodes but also the edges linked to those nodes. Subsequently, the task Task continues with the execution.",{"@attributes":{"id":"p-0267","num":"0270"},"figref":["FIG. 52","FIG. 45"],"b":["113","2","1","2","3","1","2","1","3","112","2","1","2","3","1302","1","2","1","3","1301"],"i":["b","a"]},"(3) Meanwhile, the task Task, which is performing polling in response to the command wait_sync(VAR_ID_, NODE_ID_), refers to the second-type dependency relationship information  illustrated in  and confirms that no unreliable task-border edge exists related to the indirect access expression \u201c*p\u201d of the data \u201ca\u201d. Hence, the task Task comes out of polling and starts operations.","(4) The task Task executes the command wait_sync(VAR_ID_, NODE_ID_) written in the 32-nd line. Since the node (VAR_ID_, NODE_ID_) that is specified in the argument is present, it is checked whether there exists an edge leading to that node. Since such an edge exists, the task Task falls in the synchronization waiting mode.","(5) The task Task sets the value \u201c2\u201d in the direct access expression \u201ca\u201d written in the 15-th line and executes the command post_sync(VAR_ID_, NODE_ID_) written in the 16-th line. However, since the target node (VAR_ID_, NODE_ID_) has already been deleted, no operation is performed.","(6) In the data \u201cc\u201d written in the 17-th line, the task Task sets the value of the indirect access expression \u201c*p\u201d, that is, the value of the data \u201cb\u201d. Subsequently, the task Task executes the command post_sync(VAR_ID_, NODE_ID_) written in the 18-th line. Since the target node (VAR_ID_, NODE_ID_) is present, the task Task deletes the edge starting from that node (VAR_ID_, NODE_ID_).  illustrates an example of the second-type dependency relationship information  after deleting that edge. In comparison with , it can be seen that the edge linking the node (VAR_ID_, NODE_ID_) to the node (VAR_ID_, NODE_ID_) has been deleted (dependency graph \u2033).","(7) Meanwhile, the task Task, which is performing polling in response to the command wait_sync(VAR_ID_, NODE_ID_), refers to the second-type dependency relationship information  illustrated in  and detects that the edge leading to the target node (VAR_ID_, NODE_ID_) has been deleted. Hence, the task Task starts the execution.","(8) The task Task executes the command post_sync(VAR_ID_, NODE_ID_) written in the 19-th line. However, since the target node (VAR_ID_, NODE_ID_) has already been deleted, no operation is performed.","(9) The task Task executes the command post_sync(VAR_ID_, NODE_ID_) written in the 20-th line. Since the target node (VAR_ID_, NODE_ID_) is present, the task Task deletes the edge starting from that node (VAR_ID_, NODE_ID_).  illustrates an example of the second-type dependency relationship information  after deleting that edge. In comparison with , it can be seen that the edge linking the node (VAR_ID_, NODE_ID_) to the node (VAR_ID_, NODE_ID_) has been deleted (dependency graph \u2033-. The task Task ends the execution.","(10) The task Task sets the value \u201c3\u201d in the direct access expression \u201cc\u201d written in the 24-th line and executes the command wait_sync(VAR_ID_, NODE_ID_) written in the 25-th line. Since the edge leading to the target node (VAR_ID_, NODE_ID_) does not exist, the task Task continues with the execution.","(11) The task Task sets the value \u201c4\u201d in the direct access expression \u201cb\u201d written in the 26-th line and executes the command post_sync(VAR_ID_, NODE_ID_) written in the 27-th line. Since the target node (VAR_ID_, NODE_ID_) is present, the task Task deletes the edge starting from the node (VAR_ID_, NODE_ID_).  is an example of the second-type dependency relationship information  after deleting that edge. In comparison with , it can be seen that the edge linking the node (VAR_ID_, NODE_ID_) to the node (VAR_ID_, NODE_ID_) has been deleted (dependency graph \u2033-). The task Task sets the value \u201c5\u201d in the direct access expression \u201cc\u201d written in the 28-th line and ends the execution.","(12) Meanwhile, the task Task, which is performing polling in response to the command wait_sync(VAR_ID_, NODE_ID_), refers to the second-type dependency relationship information  illustrated in  and detects that the edge leading to the target node (VAR_ID_, NODE_ID_) has been deleted. Hence, the task Task starts the execution. Subsequently, according to the code written from the 33-rd line to the 35-th line, the task Task sets the value of the data \u201ct\u201d in the data accessed by the indirect access expression \u201c*p\u201d and sets a value obtained by adding the value of the direct access expression \u201cv\u201d and the value \u201c3\u201d in the direct access expression \u201cu\u201d. Moreover, in the value of the direct access expression \u201cv\u201d, the task Task sets a value obtained by adding the value of the direct access expression \u201cs\u201d and the value \u201c5\u201d.","In this way, according to the third embodiment, the runtime library unit  modifies the parallel execution status of the tasks in accordance with the execution result of the parallel program \u2033. As far as the execution image illustrated in  is concerned, the unreliable access nodes are updated during the execution. Hence, it becomes possible to perform a greater number of parallel executions as compared to the execution image illustrated in . Meanwhile, although not explained in this example, depending on the parallel program, it is necessary to insert synchronizations also with respect to the inter-task dependency in the dynamic data that is used in deciding the access destinations of indirect access expressions.","According to the method explained in the third embodiment, the runtime library unit  refers to the dependency relationship information of the parallel program \u2033; and, depending on the reference result, can control the parallel execution status. Moreover, by updating the dependency relationship on the access-by-access basis of data, the parallel execution management can be performed at a granular level.","The configuration of the parallelization system  according to the third embodiment is not limited to the configuration illustrated in . Rather, there are various other configurations that can be implemented. For example, the code converting unit  can be partially or entirely incorporated in the runtime library unit .","Moreover, regarding the program code \u2033, the task border information \u2033, the input unit , the analyzing unit , and the first-type dependency relationship information , as well as all of the above-mentioned information and the information generated and used by the components; a number of variations are possible in a similar manner as already described in the first embodiment.","Besides, regarding the method of transferring the first-type dependency relationship information  between the code converting unit  and the runtime library unit , various methods can be implemented other than transferring the first-type dependency relationship information  using the first-type-dependency-relationship-information file . For example, to the code converting unit  can be appended a binary converting unit that converts the parallel program \u2033 into a binary code, and the first-type dependency relationship information  can be embedded in the binary code of the parallel program \u2033. Moreover, even in the case of transferring the first-type dependency relationship information  in a file, various methods such as using a normal text file or expressing the information in the binary form are possible.","Furthermore, regarding the insertion of the interface  in the parallel program \u2033, various methods can be implemented. Moreover, regarding the functions provided in the runtime library unit  or regarding the interfaces (APIs), a number of variations are possible. For example, in the third embodiment, the operation for updating the second-type dependency relationship information  or dissolving synchronizations is carried out by inserting an API in the parallel program \u2033. However, alternatively, a program code written to perform those operations can be directly inserted in the parallel program \u2033. Besides, as far as the insertion of APIs for achieving synchronization is concerned, it is not the only option to insert an API on a variable-by-variable basis. Rather, various methods of insertion can be implemented. For example, only the requisite minimum APIs can be inserted so as to satisfy the dependency relationship between threads. Moreover, the two APIs corresponding to the commands valid_node( ) and invalid_node( ) can be combined into a single API. Similarly, for example, the same API that is inserted in succession in the fourth and fifth lines illustrated in  can also be combined into a single API.","Meanwhile, the entire system or the individual functional blocks constituting the system can be implemented using hardware, using software, or using a combination of hardware and software.","As described above, in contrast to the case when the task border information is not referred to and when the dependency existence information  is updated regarding all unreliable access nodes including those unreliable access nodes which do not exert any influence on the task borders; according to the third embodiment, the dependency existence information is updated regarding only those unreliable access nodes which are linked to the task border edges. For that reason, it becomes possible to curb updating overhead at runtime, thereby enabling achieving reduction in the runtime overhead. Besides, since the dependency relationship information is updated by referring to the latest information during the execution and since the analysis is performed by referring to the updated dependency relationship information, it becomes possible to perform parallelization that is determined to be the most appropriate at that point of time during the execution.","Fourth Embodiment","In a fourth embodiment, while the sequential program is running, a runtime library is configured to change the dependency relationship information that indicates the dependency relationship of data accesses. That makes it possible to perform detailed analysis of reliable dependency relationship.",{"@attributes":{"id":"p-0288","num":"0291"},"figref":["FIG. 56","FIG. 56","FIG. 37"],"b":"1240"},"Explained below in a schematic manner are the differences between the analysis system  according to the fourth embodiment and the parallelization system  according to the third embodiment. In the parallelization system  according to the third embodiment, the code converting unit  outputs the parallel program \u2033. In contrast, in the analysis system  according to the fourth embodiment, a code converting unit \u2032 outputs a program code referred to as a profile program . Moreover, in the parallelization system  according to the third embodiment, the second-type dependency relationship information  output by the runtime library unit  is input to the interface  in the parallel program \u2033. In contrast, in the analysis system  according to the fourth embodiment, a runtime library unit \u2032 outputs the second-type dependency relationship information  to the outside and does not include it to the profile program .","More specifically, in the analysis system  according to the fourth embodiment, an interface inserting unit \u2032 in the code converting unit \u2032 receives a program code A from the input unit . The interface inserting unit \u2032 generates an interface \u2032 by referring to the program code A and generates the profile program  by inserting the interface \u2032 in the program code A. Herein, the interface \u2032 in the profile program  does not receive the second-type dependency relationship information .","The runtime library unit \u2032 includes an output unit  for outputting the second-type dependency relationship information  to the outside. Thus, the output unit  outputs the second-type dependency relationship information , which is input thereto from the converting unit , to the outside of the runtime library unit \u2032 (i.e., to the outside of the analysis system ). Meanwhile, there is no particular restriction on the data format of the second-type dependency relationship information  that is output. That is, the second-type dependency relationship information  can be in any of the various data formats such the text data format, the binary data format, the image data format, or the XML format.","In an identical manner to the interface inserting unit  according to the third embodiment, the interface inserting unit \u2032 analyzes the presentation information  and the program code A, and generates relationship information that holds a dependency-existence-information updating interface in a corresponding manner with monitoring position information indicating the positions for inserting the dependency-existence-information updating interface.",{"@attributes":{"id":"p-0293","num":"0296"},"figref":"FIG. 57","b":["1602","1500","1602","111","1602"]},"The interface inserting unit \u2032 generates the profile program  by inserting the interface \u2032, which is generated by referring to the relationship information \u2032, into the program code A that is a sequential program.  illustrates an example of the program code of the profile program  generated in the abovementioned manner.","The example in  is for the profile program  generated by inserting the interface \u2032 in the program code \u2033 illustrated in . In the profile program  illustrated in , a task border  is defined between the 11-th line and the 12-th line, and a task border  is defined between the 14-th line and the 15-th line. The code from the first line to the 11-th line is referred to as the task Task, the code from the 12-th line to the 14-th line is referred to as the task Task, and the code from the 15-th line to the 17-th line is referred to as the task Task.","As illustrated in , the profile program  is generated in the following manner. According to the relationship information \u2032 illustrated in , at the position of the code \u201cp=&a, the commands valid_node(VAR_ID_, NODE_ID_) and valid_node(VAR_ID_, NODE_ID_) are inserted as the interface \u2032. Similarly, at the position of the code \u201cp=&b\u201d, the commands valid_node(VAR_ID_, NODE_ID_) and valid_node(VAR_ID_, NODE_ID_) are inserted as the interface \u2032.","Meanwhile, in the fourth embodiment, although the explanation is given for the example of inserting an interface for monitoring only the substitution in the pointer variable \u201cp\u201d, it is not the only possible case. Alternatively, it is also possible to monitor the access to the other pointer variables \u201cp\u201d. For example, it is also possible to monitor the access to the pointer variable \u201cp\u201d written as \u201cc=*p\u201d in the 11-th line in .","When the profile program  has the program code illustrated in , the first-type dependency relationship information  that is not yet changed due to the execution of the profile program  is explained above with reference to .  illustrates an example of the second-type dependency relationship information  that is output as a result of executing the profile program . The dependency relationship is analyzed regarding each of the data \u201ca\u201d, the data \u201cb\u201d, and the data \u201cc\u201d in the first-type dependency relationship information ; and dependency graphs , , and , respectively, are obtained. Meanwhile,  illustrates an example in which the if statement that is written in the profile program  illustrated in  yields \u201ctrue\u201d.","In the profile program  illustrated in , the commands valid_node(VAR_ID_, NODE_ID_) and valid_node(VAR_ID_, NODE_ID_) that constitute the interface \u2032 are executed, and the unreliable access nodes identified by the identifiers (VAR_ID_, NODE_ID_) and (VAR_ID_, NODE_ID_) are changed to reliable access nodes. Meanwhile, if a node specified in an argument is already changed to a reliable access node, no operation is performed in response to the command valid_node( ).","In the third embodiment described earlier, the interface inserting unit  analyzes the parallel program A for generating and inserting the relationship information. Alternatively, as described in the fourth embodiment, a sequential program can be configured to analyze the program code for generating and analyzing the relationship information.","As described above, in contrast to the case when the task border information is not referred to and when the dependency existence information  is updated regarding all unreliable access nodes including those unreliable access nodes which do not exert any influence on the task borders; according to the fourth embodiment, the dependency existence information is updated regarding only those unreliable access nodes which are linked to the task border edges. For that reason, it becomes possible to curb updating overhead at runtime, thereby enabling achieving reduction in the runtime overhead.","If the computer program is optimized by referring to the dependency relationship information in which the information during the execution is reflected, it becomes possible to generate a computer program having superior performance. For example, as the first-type dependency relationship information  of the parallelization apparatus  according to the first embodiment, it is possible to use the second-type dependency relationship information  that is output by the output unit  in the analysis system  according to the fourth embodiment. With that, the unreliable access nodes can be changed to reliable access nodes by reflecting the information during the execution, and the presentation information  can be reduced. Along with that, a decrease in the dependency existence information can also be expected. As a result, the first-type dependency relationship information can be converted into the second-type dependency relationship information with fewer operations.","Explained below with reference to  is a configuration that can be commonly implemented in the first to four embodiments. As illustrated in , the information processing apparatus according to the first to fourth embodiments can be put to practice with, for example, a commonly-used computer.","With reference to ; a CPU , a random access memory (RAM) , a read only memory (ROM) , a display control unit , and a communication interface (I\/F)  are connected to a bus . In addition, a hard disk drive (HDD) , a drive device , and an input I\/F  are also connected to the bus .","The CPU  follows instructions from computer programs stored in the ROM  or the HDD , and controls the entire computer while using the RAM  as the work memory. The display control unit  converts display control signals, which are generated by the CPU , into signals displayable on a display device  and outputs those signals to the display device .","The HDD  is used to store the computer programs executed by the CPU  or to store the data referred to by the computer programs. The drive device  can have a recording medium  attached thereto in a detachable manner and is configured to perform reading and writing of data with respect to the recording medium . Herein, the recording medium  compatible to the drive device  can be a disk recording medium such as a compact disk (CD), a digital versatile disk (DVD), or a flexible disk, or can be a readable\/writable and nonvolatile semiconductor memory.","The input I\/F  receives data from the outside. For example, the input I\/F  has a predetermined interface such as a universal serial bus (USB) or an IEEE1394 interface (IEEE1394 stands for Institute of Electrical and Electronics Engineers 1394), through which data is received from an external device. To the input I\/F  is connected an input device such as a keyboard  or a mouse . For example, in response to the display on the display device , the user can operate the input device and issue instructions to the computer.","The communication interface  communicates with an external communication network using a predetermined protocol.","Meanwhile, with the computer programs running in the CPU , it is possible to implement the functional blocks constituting the parallelization apparatus  according to the first embodiment; implement the functional blocks constituting the synchronization optimization apparatus  according to the second embodiment; implement the functional blocks constituting the parallelization system  according to the third embodiment; and implement the functional blocks constituting the analysis system  according to the fourth embodiment. The computer programs for implementing the abovementioned embodiments can be provided in the form of installable or executable files on a computer-readable recording medium such as a compact disk read only memory (CD-ROM), a flexible disk, or a DVD. Alternatively, computer programs for implementing a program parallelization system can be stored in advance in the ROM .","Still alternatively, the computer programs for implementing the abovementioned embodiments can be saved on a computer connected to a network and downloaded from that computer via the network. Moreover, the computer programs for implementing the program parallelization system can be made available for distribution through the network such as the Internet.","Herein, the computer programs for implementing the abovementioned embodiments contain units for implementing the functions of the abovementioned constituent elements (for example, with reference to the first embodiment, the input unit , the analyzing unit , the generating unit , the instructing unit , the converting unit , and the parallelizing unit ). Regarding the actual hardware, the CPU  retrieves the computer programs from, for example, the HDD  and runs them so that the computer programs are loaded in the RAM . As a result, the functions of the abovementioned constituent elements are implemented in the RAM .","Meanwhile, in the embodiments described above, it is only a single computer in which the functional blocks of the apparatus or the system according to the embodiments are implemented. However, that is not the only possible case. Alternatively, for example, one or more of the functional blocks can be implemented in a different computer. In that case, the communication of data between the functional blocks can be performed using the recording medium  or via the network.","While certain embodiments have been described, these embodiments have been presented by way of example only, and are not intended to limit the scope of the inventions. Indeed, the novel embodiments described herein may be embodied in a variety of other forms; furthermore, various omissions, substitutions and changes in the form of the embodiments described herein may be made without departing from the spirit of the inventions. The accompanying claims and their equivalents are intended to cover such forms or modifications as would fall within the scope and spirit of the inventions."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 32"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 33"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 34"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 35"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 36"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 37"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 38"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 39"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 40"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 41"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 42"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 43"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 44"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 45"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 46"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 47"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 48"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 49"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 50"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 51"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 52"},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 53"},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 54"},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 55"},{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 56"},{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 57"},{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 58"},{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 59"},{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 60"}]},"DETDESC":[{},{}]}
