---
title: Detection of polymorphic virus code using dataflow analysis
abstract: A method and apparatus for detecting polymorphic viral code in a computer program is provided. The apparatus comprises an emulator, an operational code analyzer and an heuristic analyzer. The emulator emulates a selected number of instructions of the computer program. The operational code analyzer collects and stores information corresponding to operands and operators used in the instructions and the state of registers/flags after each emulated instruction execution. The heuristic analyzer determines a probability that the computer program contains viral code based on an heuristic analysis of register/flag state information supplied by the operational code analyzer.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07069583&OS=07069583&RS=07069583
owner: Computer Associates Think, Inc.
number: 07069583
owner_city: Islandia
owner_country: US
publication_date: 20010714
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","TECHNICAL FIELD","DESCRIPTION OF THE RELATED ART","SUMMARY","DETAILED DESCRIPTION"],"p":["This application claims the benefit of co-pending provisional application Serial No. 60\/218,922, filed Jul. 14, 2000 and entitled \u201cDETECTION OF POLYMORPHIC VIRUS CODE USING DATAFLOW ANALYSIS.\u201d","The present disclosure relates to detection of computer viruses. More specifically, the disclosure relates to detection of polymorphic virus code using dataflow analysis.","Computer viruses are a major problem in modem day computing. Generally, a computer virus is a computer program or some unit of computer executable code, e.g., instructions to which a computer responds, such as a code block, code element or code segment. When the viral code is executed on a computing device\/system, it typically attaches to other programs or sets of computer instructions and\/or replicates itself. In this way, the virus exists within and \u201cinfects\u201d otherwise normal programs. Infected programs can exist anywhere in the computer system or even the operating system itself, and if not detected can cause potentially devastating problems.","The virus may spread from one computer file to another, and from one machine to another by attaching itself to a file or program in a removable storage medium, such as floppy disk, compact disc (CD), digital versatile disc (DVD), etc., that is accessible when the computer runs or accesses the infected file or program. If a user then places that infected medium into a second computer and the second computer runs or accesses the infected file or program, the virus will attempt to infect the second computer, and so forth. In addition, the virus may spread from one computing machine to another by attaching to data transmissions between the computer machines via a network or other transmission medium.","A file virus is a computer program that modifies other programs so that the next time the program modified by the virus is run the virus gains control over the execution flow. For example, the file virus may attach itself to a computer program (\u201csubject program\u201d). In order to be attached to the subject program, the virus may insert\/append itself anywhere in a file that represents the program on a selected computer platform. Another method of infecting a program is by substituting a clean copy of the subject program with the file virus. In each of these examples, the virus gains control over execution flow of the infected program. When the infected program is executed the virus code may gain access to system resources to start propagating itself and perhaps performing other activities, for example, cause damage to an infected computer and\/or information stored on the computer, prevent the computer from being used in its normal manner, etc.","Techniques for detecting computer viruses include (a) scanning suspected files for known virus signatures (templates), (b) emulating and heuristically analyzing the execution flow, and (c) a combination of the two. Finding virus signatures may be the most efficient method for detecting viruses in terms of speed. Unfortunately, searching for plain virus strings inside infected files are rarely successful now because of rapid developments within the art of computer virus creation over the past decade. In particular, creators of computer viruses now usually employ combinations of various obfuscation techniques to protect their viral code from anti-virus scanners.","Some common obfuscation techniques for viruses include virus code encryption, polymorphism in a decryptor of an encrypted virus, polymorphism in the plain (unencrypted virus code), slow polymorphic virus code in the plain (unencrypted virus code), and slow polymorphic virus decryptor code.","A virus code may be encrypted and then attached to a file in its encrypted form. The encryption technique may be polymorphic (for example, vary from one generation to another, so that the byte stream of each new viral infection is different from its predecessor). Each time the virus runs it will decrypt its own code in memory before control is transferred to it. Only a small portion of a virus code, which is known as a \u201cdecryptor\u201d, may be constant from one generation to another.","The decryptor may be generated by the virus code in such a way that it contains different code for each new generation of the virus. The decryptor's byte stream may be different for every new infection of the same virus. Under such circumstances, there are no constant byte streams that can be used for virus identification in an entire virus code span.","For some viruses, each new virus infection generates an unencrypted virus code different from its predecessor. Some other viruses generate new unencrypted code that is based on time rather than on the number of generations. Thus, the stream of bytes over the entire virus code remain constant over successive generations. In such instances, it is difficult to identify the virus as being polymorphic.","In other instances, a decryptor may appear as a constant code which changes only after a predetermined period of time or a predetermined number of new virus infections. The decryptor might not change at all for several generations of the virus. For such viruses, the code of the decryptor appears to be not polymorphic.","Polymorphism of a virus code may make it harder, and sometimes even nearly impossible, to use virus string detection to identify an infected file. Emulating a virus code is one of the possible solutions for detecting the virus. In such instances, when an emulator runs through a virus decryptor, the decryptor decrypts the virus code and then the code can be identified, via constant string matching, as containing a virus. If the virus decryptor is polymorphic, it usually consists of collections of instructions that are not used directly in the decryption process. In such instances, the emulator would have to emulate a larger amount of operational codes in order to decrypt an encrypted virus code.","The initial number of instructions for emulation is set at a level that allows decryption of encrypted viruses to identify the virus patterns. In practice, the amount of instructions needed to be emulated by the emulator to decrypt a polymorphic virus is quite large. The number of instructions set for decryption of a polymorphic viral code might create unnecessary performance overhead costs, if emulation is performed on files that are clean from viruses but are encrypted or look like they are encrypted, e.g., compressed files.","The present disclosure provides a method of detecting polymorphic virus code in a computer program. In one embodiment, the method includes emulating a selected number of instructions of the computer program, collecting and storing information corresponding to a state of a plurality of registers\/flags after each emulated instruction execution, and determining a probability that the computer program contains polymorphic viral code based on an heuristic analysis of the stored register\/flag state information.","The present disclosure also provides an apparatus for detecting polymorphic virus code in a computer program. The apparatus includes, in accordance with one embodiment, an emulator, an operational code analyzer and an heuristic analyzer. The emulator emulates a selected number of instructions of the computer program. The operational code analyzer analyzes a plurality of registers\/flags accessed during emulated execution of the instructions. The heuristic analyzer determines a probability that the computer program contains viral code based on an heuristic analysis of register\/flag state information supplied by the operational code analyzer.","The emulator may emulate a second predetermined number of instructions (which is greater than the first predetermined number of instructions) if the probability determined by the heuristic analyzer is above a predetermined threshold. The second predetermined number of instructions may correspond to execution of a polymorphic decryptor.","The operational code analyzer may monitor the plurality of registers and\/or flags for improper register\/flag usage. The heuristic analyzer may maintain, for each of the plurality of registers and\/or flags, a corresponding count of a number of times that the register\/flag was improperly used during the emulated instructions. The operational code analyzer may monitor operand values of the emulated instructions. The operational code analyzer, according to one embodiment, detects when an operand value of an instruction which is set is not used by the instruction. The operational code analyzer also may detect when an undefined operand of an instruction is used by the instruction.","The present disclosure provides tools for detecting polymorphic viral code in a computer program by emulating execution of a selected number of instructions of the computer program.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 5","b":["50","50","51","52","53","54","56","57","58","50"]},"A potentially infected program file may reside on\/in, for example, hard disk  and\/or a removable storage medium that may be read\/accessed through removable storage drive . Also, the program file may be downloaded to the computer system or computer through network .","A block diagram of an apparatus, in accordance with an embodiment of the present disclosure, for detecting polymorphic viral code in a computer program is shown in . Apparatus  comprises emulator , operational code analyzer  and heuristic analyzer . A method of detecting polymorphic viral code in a computer program, in accordance with one embodiment, will be described with reference to . Emulator  emulates a selected number of instructions of the computer program (step ). Information corresponding to a state of a plurality of registers\/flags after each emulated instruction execution is collected by operational code analyzer  and supplied to heuristic analyzer  (step ). Heuristic analyzer  determines a probability that the computer program contains viral code based on an heuristic analysis of the stored register\/flag state information (step ).","The present disclosure provides methods of detecting a polymorphic viral code at earlier stages of emulation. The operand and operator values of instructions emulated may be monitored. Special consideration may be given to unused values and those instances in which the operand\/operator value is calculated without being defined. A plurality of these instances found during emulation may contribute to a determination that a polymorphic viral code is present. Once the suspect instances are identified, there is a higher probability that the code is viral or used by a virus decryptor. The emulator then is allowed to emulate a larger amount of instructions. Thus, emulation time is spent only on emulating code which has a high probability of containing a virus.","A method, in accordance with one embodiment, for detecting polymorphic viral code in a computer program, will be described with reference to . An amount of instructions to be emulated for preliminary identification of the code is defined (step ). Instructions in the program are retrieved from instruction store  and emulated by emulator  one-by-one (step ). For the emulated instruction, operands and operators that were involved in the emulated instruction execution are identified by operational code analyzer  (step ). States of registers and flags  are collected (step ) and processed, along with the operands and operators, for the emulated instruction. If it is determined (step ) that the number of instructions emulated is less than the number of instructions defined in step , then steps - are repeated for the next instruction. If the number of instructions emulated is not less than the number of instructions defined in step , then the processed information collected in step  is heuristically analyzed by heuristic processor  in step . If it is determined (step ) based on the heuristic analysis that there is a high probability that the code is polymorphic then the number of instructions to be emulated is increased (step ) and emulation of the increased number of instructions to detect polymorphic viral code is performed.","The emulator retrieves the byte codes at a current instruction pointer position of the instruction store, and decodes and emulates the retrieved instruction. Once the instruction is emulated, the emulator passes control over to the operational code analyzer. The operational code analyzer extracts information about any operands and\/or operators involved in the emulated execution of the instruction along with the state of CPU registers and flags. The operational code analyzer passes the gathered information to the heuristic processor. The heuristic processor collects and maintains data corresponding to each register\/flag used by the emulated instruction. The heuristic processor may maintain counters  corresponding to respective registers\/flags, with each counter keeping track of the number of times the corresponding register\/flag triggered improper register usage state.","The conditions of the register\/flag triggering an improper register usage state are shown in the state diagram in . During emulation of the program, a register\/flag may be in one of the following three states: (a) undefined; (b) set; and (c) used. If a register\/flag is loaded with an unknown value, its state is \u201cundefined.\u201d Once the value that is loaded into a register\/flag is known, the register\/flag is in a \u201cset\u201d state. If a value in the register\/flag is employed by a CPU instruction, the register\/flag is in a \u201cused\u201d state.","Once the emulator has finished emulating the defined number of instructions set for identification of the program to be analyzed, the heuristic processor weighs the numbers collected for improper register\/flag usage against the number of emulated instructions. The calculated numbers are compared with statistics representing average numbers of improperly used registers\/flags for polymorphic and non-polymorphic viral code. The number of instructions to be emulated subsequently is based on identification of the emulated file as being polymorphic. If the file is identified to be polymorphic the number of instructions to be emulated is increased to cover execution of the polymorphic decryptor.","The apparatus and methods described above may be embodied in a computer program (or some unit of code) stored on\/in computer readable medium, such as memory, hard drive or removable storage media. The apparatus and methods also may be in the form of a computer data signal, in one or more segments, embodied in a transmission medium, such as the Internet, an intranet, or another (wired or wireless) transmission medium. The present disclosure also encompasses, of course, execution of the computer program stored on\/in a program storage device in a computing device\/system, such as, for example, shown in .","The viral code detection methodologies described herein may be performed by a computer in one or a combination of the following circumstances. The viral code detection methodologies may be performed periodically (e.g., once\/twice per day) or at selected times (e.g., each time the computer is powered up or restarted) by the computer on all relevant electronic files. In addition, the viral code detection methodologies may be performed on a file (or a data stream received by the computer through a network) before the file is stored\/copied\/executed\/opened on the computer.","The specific embodiments described above are illustrative, and many variations can be introduced on these embodiments without departing from the spirit of the disclosure or from the scope of the appended claims. Elements and\/or features of different illustrative embodiments may be combined with each other and\/or substituted for each other within the scope of this disclosure and appended claims.","For example, the heuristic analyzer may be a rule-based module and\/or adapted with other artificial intelligence techniques to determine whether the subject program likely contains polymorphic viral code (and therefore the number of instructions to be emulated should be increased to cover execution of the polymorphic decryptor). For example, the rule-based heuristic analyzer may include a learning component. When, after the heuristic analyzer has determined that the subject program likely contains polymorphic viral code, it is determined through additional emulation that the subject program contains polymorphic viral code, the positive identification of polymorphic viral code may be fed back to the learning component for fortifying the rules in the rule base and\/or adding additional rules.","Further, while the heuristic analyzer in one embodiment is rule-based, it may be, in another embodiment, an intelligent network, such as a neural network.","A neural network is an information processing modality which comprises a number of interconnected neuron-like processing elements that send data to each other along connections.  shows a diagram of a single processing element . The processing element receives inputs X, X, . . . X), either from other processing elements or directly from inputs to the network. It multiplies each of its inputs by corresponding weights w, w, . . . wand adds the results together to form a weighted sum . It then applies a transfer function  (which is typically non-linear) to the weighted sum, to obtain a value Z known as the state of the element. The state Z is then either passed on to one or more other elements along weighted connections, or provided as an output signal. Collectively, states are used to represent information in the short term, while weights represent long-term information or learning.","Processing elements in a neural network typically are organized into layers: input layer processing elements (those which receive input data values); output layer processing elements (those which produce output values); and hidden layer processing elements (all others). Hidden layer processing elements allow the neural network to build intermediate representations that combine input data in ways that help the model to learn the desired mapping with greater accuracy.  shows a diagram illustrating the concept of hidden layer processing elements. Inputs i, i, iare supplied to a layer of input processing elements . The outputs of the input elements are passed to a layer of hidden elements . Hidden layer elements pass outputs to a layer of output elements , and the output elements produce output values o, o, . . . o. While the hidden layer processing elements are shown exemplarily in  as one layer of processing elements, neural networks may have multiple or no hidden layers.","Neural networks employ a technique of learning through repeated exposure to sample data and adjustment of the internal weights. The training process generally involves the following steps:\n\n","Neural networks are able to capture nonlinearity and interactions among independent variables automatically without pre-specification. Training the neural network by applying specific, selected sample sets helps the network to develop quickly a general input-output model. Trained neural networks model the input-output relationship typically without requiring training with each and every possible set of inputs. Thus, neural networks are particularly suitable for, amongst other applications, pattern detection and recognition, even when a set of subject input values was not one of the samples used to train the network.",{"@attributes":{"id":"p-0045","num":"0047"},"figref":"FIG. 7"},"As one of ordinary skill in the art would recognize and understand, other networks may be used, alternatively. For a description of this and other neural networks, see, for example, David E. Rumelhart and James L. McClelland, Parallel Distributed Processing, Explorations in the Microstructure of Cognition, The MIT Press, Cambridge, Mass., U.S.A., 1986, and James L. McClelland and David E. Rumelhart, Explorations In Parallel Distributed Processing, A Handbook of Models, Programs, and Exercises, The MIT Press, Cambridge, Mass. 1988, the teachings of which are incorporated herein by reference.","Additional variations may be apparent to one of ordinary skill in the art from reading the following U.S. provisional applications, which are incorporated herein by reference:\n\n"],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The features of the present disclosure would be more readily understood from the following detailed description by referring to the accompanying drawings wherein:",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
