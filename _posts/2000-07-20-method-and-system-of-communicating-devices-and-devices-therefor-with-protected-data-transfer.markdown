---
title: Method and system of communicating devices, and devices therefor, with protected data transfer
abstract: A method and a communicating system to enhance the reliability of communication between devices by protecting against failure of a device, e.g. due to power interruption. Additional data is included in communication primitives transmitted between communicating devices. The additional data relates to state data of the device having generated the additional data. The additional data is used to check the state data. The state data may also be derivable from the additional data upon receiving the additional data back from an other device.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07828218&OS=07828218&RS=07828218
owner: Oracle America, Inc.
number: 07828218
owner_city: Redwood City
owner_country: US
publication_date: 20000720
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["1. Field of the Invention","The present invention relates to a method of communicating between a first device and a second device. The invention is specifically applicable in the field of smart cards communicating with terminals.","2.Relevant Background","Communications between smart cards and terminals are usually used to conduct one of a plurality of secure protocols that are needed for a service to be provided by the smart cards.","Especially when using a contactless smart card, a problem may arise from the fluctuating supply current from the terminal to the smart card due to movement of the smart card through an energizing electromagnetic field. The power fluctuations may be so strong and fast that the smart card may lose supply power before performing all communication steps required by a protocol. What is needed is a mechanism to continue a protocol after a full or partial loss of power and in general to assure integrity of the smart card data used in performing the protocol. Due to the risks of power fluctuations, normally all communication steps required by a protocol for a contactless smart card need be done within 150 msec. There is a need to increase the period of time available for the protocol, without introducing further risks as to communication failures.","WO-A-89\/02140 (Eglise e.g.) discloses a mechanism against a data carrying device, like a card or a token, being taken away from a terminal prior to completion of a transaction. The data carrying device is storing credit value which is decremented under the control of a machine during the course of a service. Such a service may be a telephone call or providing electricity. The problem to be solved by this prior art document is to ensure that a user of the data carrying device is allowed to remove this device from the terminal at any time without losing important credit data which might occur when the user withdraws the device from the terminal prior to completion of a transaction. A similar loss of relevant credit data might occur when power is temporarily lost.","To solve this problem, the data carrying device according to Eglise e.a., each time a data communication step with the machine is carried out, stores additional information which is as indication for the data communication step concerned. To that end, Eglise e.a. propose to use two flags and three parameters. The values of the flags change in accordance with the steps made whereas the parameter values change in accordance with the stored credit value and its updates during successive operations. Whenever a data carrying device is removed from the machine too early or power is lost, the values of the flags and the parameters which are stored in the non-volatile memory of the data carrying device are a unique indication of the last performed communication step. Thus, when communications between the machine and the data carrying device start again the previous transaction can still be successfully completed.","U.S. Pat. No. 4,877,945 (Fujisaki) discloses an IC card which is provided with a function to exclude erroneous recording. The IC card is arranged to communicate with a terminal. At the beginning of a communication, the terminal sends a start command whereas, at the end of the communication it sends an end command to the IC card. Upon receiving the start command, the IC card checks whether a validity flag stored in a table in its EEPROM memory indicates either a valid status or an invalid status. An invalid status indicates that the last communication procedure between the IC card and a terminal has not been completed correctly, whereas a valid status indicates that the last communication procedure has been completed correctly.","When, upon receiving a start command, the IC card detects that its validity flag is valid it starts the communication procedure with the terminal after having changed the status of the validity flag into \u201cinvalid\u201d. It carries out the communication procedure with the terminal and upon receiving the end command from the terminal it changes the validity flag into \u201cvalid\u201d. However, when the communication procedure is interrupted prior to completion the validity flag remains invalid thus indicating that its data content is invalid.","When, upon receiving a start command, the IC card detects that its validity flag is invalid it informs the terminal thereof and no communication will be carried out. Thus, no communication procedure can be carried out with an IC card having invalid data.","In order to reuse an IC card having invalid data, Fujisaki discloses a correction mechanism which includes sending an end command to the IC card making the IC card change its validity flag to \u201cvalid\u201d.","U.S. Pat. No. 3,636,695 (Feiken) discloses a similar mechanism against interruption of communication between an IC card and a terminal, Feiken also uses a validity flag to indicate whether or not a transaction has been correctly completed on the card. Moreover, Feiken discloses a mechanism for correctly completing an unfinished balance process after which not only the validity flag is reset to its valid status but also the data content of the card will have the correct value.","An objective of the present invention is to enhance the reliability of communications between two communicating devices by protecting against failure of one or more of those devices, e.g. due to power interruption. Such communicating devices may be a smart card and a terminal but can alternatively be of any known type, e.g. computers communicating with one another through a network.","In order to obtain this object, the present invention in a first embodiment claims a method of communicating between at least a first device and a second device;","the first device comprising a first processor, first memory means and first input\/output means, the first memory means and first input\/output means being coupled to the first processor;","the second device comprising a second processor, second memory means and second input\/output means, the second memory means and second input\/output means being coupled to the second processor;","the method comprising at least the following steps carried out by the first processor:\n\n","Thus, the protection against failure of a device, e.g. due to power loss, is obtained by augmenting the ordinary communication between the devices with additional data which is essentially private to the device to be protected. The device to be protected communicates via the other device to itself by transmitting additional data pertaining to its own internal state.","The state of a device comprises all data necessary for a program running on the device to be able to continue with the next program step (l) in the program after having received a reply from the other device. Some of the state data may be called \u201cpersistent state data\u201d, i.e. data to be stored by the device for a period possibly extending beyond the end of the protocol, e.g. by utilizing non-volatile memory such as EEPROM. Moreover, there is \u201cvolatile state data\u201d, that is related to optional next program steps in the program running on the device. Which option is chosen may depend on the instructions received from the other device. The program needs to store these state data to be able to continue the program at its proper point after having received instructions from the other device. Usually, these state data are stored in volatile memory. Thus, these state data may be lost after a power interruption. Failure of power might especially occur when contactless smart cards are used.","The second device, after having received a communication primitive of the first device extracts the first additional data from the communication primitive and stores it in its own memory. After having carried out a next program step in its own program, the second device adds second additional data to a communication primitive to be transmitted to the first device. This second additional data has a predetermined relationship with the first additional data. The first device will receive the second additional data transmitted by the second device in the next message.","The relationship between the second and first additional data may be simple: they may equal one another. Then, the first device receives the first additional data unaltered by the second device. However, beneficial to efficient use of communication bandwidth, the first additional data, or part of it, may, in a further embodiment, additionally be used by the second device as input to the processing step described in step f. Furthermore, the second device may in addition to storing the first additional data process the first additional data itself provided this processing results in processed second additional data being transmitted to the first device in the second communication primitive for which the first relationship to the first state data can be verified in the first device, e.g. by first inverting the processing done in the second device to the additional data. The modification to the first additional data may in this way convey extra information from the second device to the first device, possibly also resulting in more efficient use of communication bandwidth.","The additional data is used by the first device to check whether the program running on it is waiting at the proper stage. This is done by checking whether the received additional data has the predetermined relationship with the state data. The state data may be stored itself in a non-volatile part of the memory of the first device and will, thus, be present even after a power failure. Alternatively, the non-volatile part of the memory may store data from which these state data may be derived, as will be explained hereinafter.","Preferably, in this first embodiment, the method comprises the following steps after step l:\n\n","In this latter embodiment the third communication primitive not only includes additional data having a predetermined relationship with the second state data, but also with the first state data. By providing any additional data with data which has a predetermined relationship with all prior state data of all prior program steps in the program in the device to be protected, the device will be able to restore the entire program after a power failure.","The same kind of protection may be obtained with the second device. Therefore, the invention in a second embodiment also relates to a method of communicating between at least a first device and a second device;","the first device comprising a first processor, first memory means and first input\/output means, the first memory means and first input\/output means being coupled to the first processor;","the second device comprising a second processor, second memory means and second input\/output means, the second memory means and second input\/output means being coupled to the second processor;","the method comprising at least the following steps carried out by the first processor:\n\n","The present invention also relates to distributed processing in the sense that it is not restricted to communications between two devices. It also relates to situations in which one processor is transmitting communication primitives to a shared data storage or data transmission means, such as a central memory which stores this communication primitive. One of a plurality of other devices may read this communication primitive from the central memory. Of course, after having read the communication primitive from the central memory, there must be a mechanism to inform other devices that the communication primitive has been read and processed. This can be done by removing the communication primitive from the central memory after being read. However, alternatively, the communication primitive may remain stored in the central memory. Then, an indication may be added to the communication primitive in the central memory to inform other devices that the communication primitive has been read by one device and need not be processed by another device.","The relationship between the additional data and the state data may be based on using one or more of the following methods, either alone or in combination: applying an encryption method, applying a cryptographic hash function, and applying an encryption with one-time pad function.","For carrying out the method in accordance with the first embodiment of the present invention, the invention also relates to a system as claimed in independent claim .","For carrying out a method in according with the second embodiment of the present invention, the present invention also relates to a system as claimed in independent claim .","The present invention also relates to devices arranged to communicate with one another for carrying out the method in accordance with the invention. Therefore, the invention also relates to a device comprising a processor, memory means and input\/output means, the memory means and input\/output means being coupled to the processor;","the processor being arranged to carry out at least the following steps:\n\n","Such a device may be a smart card.","Preferably, the processor is arranged to carry out the following steps after an interruption and restoration of power to the processor:","receiving from either the other device or a central memory at least one communication primitive having a predetermined relationship with last state data established in accordance with a last program step carried out by the first program;","resuming running the first program with a further program step following the last program step.","The present invention also relates to a device, which may be a terminal arranged to communicate with a smart card, comprising a processor, memory means and input\/output means, the memory means and input\/output means being coupled to the processor;","the processor being arranged to carry out the following steps:\n\n","The present invention will be illustrated with reference to some drawings which are intended for illustration purposes only. The present invention is only limited in scope by the annexed claims.",{"@attributes":{"id":"p-0047","num":"0091"},"figref":"FIG. 1","b":["2","6","4","8"]},"The coil  is for contactless communication with another device, such as a terminal , through electromagnetic energy, as is known to persons skilled in the art. Preferably, power necessary for the microprocessor  to operate is also provided via the coil  from the other device, e.g. the terminal . How this is done is also known to persons skilled in the art and needs no further explanation here. Of course, the coil  may be substituted by any other type of interface means, or input\/output means known in the art. The coil  may, for instance, be substituted by electrically conducting pads by means of which an electrical contact can be made with the terminal .","The memory  has been drawn as a single block. However, the memory  will normally comprise RAM (Random Access Memory), ROM (Read Only Memory), and EEPROM (Electrically Erasable Programmable Read Only Memory). These types of memory are known to persons skilled in The art. If necessary, other memory types may be added to the smart card . The EEPROM will be used by the microprocessor to store information on the card  itself in a non-volatile manner, i.e. it remains stored in the EEPROM, even after a power failure.","The terminal  comprises a coil . The coil  is used by the terminal  to communicate with the smart card  via the coil  of the smart card . Both power and data will be transmitted through the coil  to the smart card , as is known to persons skilled in the art. Of course, when the smart card  has another type of input\/output means than coil , the terminal  may need to be provided with a suitable other type of input\/output means. Therefore, coil  may be substituted for by any other type of input\/output means known from the art, e.g. connectors for making an electrically conductive contact.","The processor  of the terminal  is also connected to a memory , a display , and a keyboard . The display  may be of any type known in the art, e.g. a monitor or an LCD display. The keyboard  may be substituted by any other type of input means for providing a user with the possibility of inputting relevant data like a touch screen or any other type of input means known from the art. The keyboard  or equivalent means, and the display  may be absent.","Preferably, the processor  may be coupled to other remote processors (not shown) through a communication line . Then, the remote processor(s) may execute part of the communication protocol with the smart card . This is for instance necessary when the transaction between the terminal  and the smart card  relates to a debiting or crediting transaction regarding an account held by a remote device.","The memory  has been shown as a single block. However, in practice the memory  will comprise several types of memory including possibly one or more of the following memory types: RAM, ROM, EEPROM, and a hard disk. As in the smart card  the non-volatile memory types store executable programs and other data required for the intended functions of the device. Typically, at least part of the working memory and the non-volatile memory type is for exclusive use by the device while executing programs.","Usually, communication between the terminal  and the smart card  is not permanent or fixed and may be (re-)initiated at any convenient time. Such a situation is typical for communications between smart cards and terminals. However, such communications also occur in a client-server relation between computers communicating with one another through a data network such as the Internet. Therefore, the present invention is not restricted to smart cards and terminals for communicating with smart cards only but is also applicable to other devices arranged to communicate with one another. Data communications between devices typically take place as an exchange of units of data, usually referred to as \u201cpackages\u201d, \u201cmessages\u201d, or \u201ccommunication primitives\u201d. Thus, within the context of the present invention, a communication primitive is any type of message including, for instance, instructions, statements, and\/or data. Such a communication primitive comprises a header and a payload as is known to persons skilled in the art.","The present invention is also applicable to three or more devices arranged to communicate with one another through a communication network.  schematically shows such a situation. The devices  and  may refer to the same type of devices as referred to in .","Device  is arranged to communicate with other devices and comprises at least a processor  connected to an interface  and a memory . The interface  functions as the input\/output means between the processor  and a communication network . The communication network  may, e.g., be the PSTN (Public Switched Telephone Network) or any other kind of communication network, either WAN (Wide Area Network) or LAN (Local Area Network), or other. It may also be the Internet. The interface  may be of any type known to persons skilled in the art.","The memory  has been shown as one single block. However, practically the memory  will comprise RAM, ROM, EEPROM, or any other kind of memory, either alone or in combination, as is known to persons skilled in the art. They may be realized in one or more physical units.","As will be explained below, for implementing one special embodiment of the present invention, there may be a central memory  which is accessible by any of the devices , ,  through the network  for storing and extracting data. The central memory  may be provided with some intelligence (not shown) for carrying out storing, reading and erasing actions, as is known to persons skilled in the art. Thus, the central memory  may be part of a shared data storage or data transmission means.","The network  that connects the devices , ,  may be publicly accessible in the sense that many devices may simultaneously use the network, using any known network-allocation procedure to perform communication in a pseudo private fashion. Sharing the network allows data communication to be shared by any of the other devices connected to the network. Therefore, when using a shared network the privacy of communicated data as well as of the pattern of communication does not actually exist. Then, if required, the privacy of the users of the devices must be provided by other means, often including cryptography. On the other hand, sharing the data communicated by any of the devices connected to the shared network allows the communication between the devices connected to the media in fact to be performed by a number of physically distinct devices which for the purpose of a particular communication collaborate as a single \u201clogical\u201d device.","A device or equally a collection of collaborating devices takes part in the communication either in the role of initiator, commonly referred to as the \u201cclient\u201d, or in the role of respondent, commonly referred to as the \u201cserver\u201d. Consequently, a particular sequence of messages will be exchanged between the client and the server in order to provide a \u201cservice\u201d which is being delivered by the server to the client. In the arrangement shown in  the terminal  is the client whereas the smart card  is the server.","The system of communicating devices may also include devices which are realized as distinct processes, or threads of control, on a single computer that communicates via a shared memory.","The data communication between such devices, of any kind or structure, commonly is performed in an orderly fashion with a sequence of messages being exchanged between the devices, starting with an initial message from the client. For the purpose of the communication, the message or communication primitives are identifiable by the receiving party as appropriate in the ordered sequence of messages.","Each message or communication primitive received conveys information required by the receiving device to proceed a single step forward toward the goal of the communication sequence. To that end the receiving device implements in some form functions commonly known as a \u201cstate engine\u201d to recognize the received communication primitive as fitting in the sequence and, if appropriate, to further interpret the data in the communication primitive. The state engine in general comprises executable codes and descriptive data stored in the memory of the device that in combination describes\n\n","In particular the working memory of the receiving device may contain such descriptive data which may be updated immediately before a message has been sent in its entirety to the other device to reflect the progress made in the orderly sequence of messages. The working memory of the receiving device may also comprise the results of processing the received message data, e.g. modifying or storing any data received in the messages. Such descriptive data in the working memory is usually referred to as \u201cstate data\u201d or briefly \u201cstate\u201d.","Logical devices , ,  communicating in accordance with the present invention by means of orderly exchanging communication primitives each maintain in the memory , ,  data defining the state of the communication.","The state data will normally be stored in volatile memory. Thus, after a power failure, it is not certain that the state data in the volatile memory is still valid. It may have been lost partially or entirely. In order to confirm that the state data within the working memory is still valid after the device has received a next communication primitive of the other device the present invention proposes a special method which will be explained hereinafter. It is to be understood that the method also protects against partial or entire loss of state data due to other causes than power failure.","In accordance with the present invention, in the system and method described at least one of the communication devices includes additional data in at least one of the communication primitives it sends to the other device. This additional data is a representation of the internal state as generally described by data stored in its working memory. This will be further illustrated with reference to and . In and a communication method in accordance with the invention is illustrated between two devices, i.e. a device A (the server, for instance smart card ) and device B (the client, for instance the terminal ).","Device A is typically a server which has to maintain state data relating to the messages received and the data these messages contain. Specifically, any security status, such as authentication or an established temporary encryption key, obtained by the client in the course of the on-going exchanging of communication primitives may be part of the server state data.","Device B is typically a client and typically contains special processing instructions to handle such a communication primitive that includes such additional data. Specifically, the client, as part of processing the received communication primitive, will extract the additional data from the communication primitive as will explained hereinafter.","The communication process starts with device B sending a communication request to device A in order to carry out a predetermined protocol with device A (step ).","In step , device A receives the communication request from device B and starts the communication.","The next step, step , is to carry out a first program step in accordance with a predetermined program in reply to the communication request received from device B.","After having executed the first program step device A stores in its working memory state data related to the point in the program where the program has to wait for further data and\/or instructions of device B, or data from which the state data can be derived, step .","In step , in order to receive the proper input from device B, device A sends a communication primitive including additional data which has a predetermined relationship to its own state data to device B.","In step , device B receives the message from device A.","In step , device B checks whether the message received comprises an end of process instruction. If so, device B goes to the end of its program (step ). If not, the device B continues with step  in which device B extracts the additional data regarding the state data of device A from the received message.","In step , device B stores this additional data in its memory , preferably without processing this additional data.","In step , device B carries out a next program step in accordance with its own program.","In step , device B stores state data relating to its own process in its memory .","In step , device B reads the additional data relating to the state data of device A, which was stored in memory  in step , from memory .","In step , device B sends a communication primitive including at least this latter additional data to device A. This communication primitive may further comprise instructions to be executed by device A.","In step  device B checks whether its process has reached its end. If so, it jumps to step  (end). If not, it jumps back to step , and waits for a further message of device A.","In step , device A receives the communication primitive from device B.","In step , device A extracts the additional data related to the state data of device A from the received communication primitive.","In step , device A checks whether the extracted additional data is correct. This may be done in several ways. For example, when device A has stored its last valid state data in memory, it can simply compare the extracted additional data with these stored data to check whether they are equal. Alternatively, device A may have stored data from which the last valid state data can be uniquely derived. An example will be given below with reference to . Then device A has to derive the last valid state data first from these stored data, after which a comparison with the extracted additional data can be made.","If the check is found to be positive device A is allowed to continue the running program. Then it continues with step  via step . However, if it is established that the checking step  does not provide a positive result somewhere an error has occurred. Such an error may be caused by different circumstances. For instance, there may have been a power failure to device A resulting in a partial or entire loss of the state data stored in memory . Another reason may be that the received additional data has been changed accidentally or on purpose. Whatever the reason is that the checked process is negative the program in device A cannot just continue running. Now two different steps can be made. Either, after possibly having informed device B via a warning message that an error has occurred (step ), device A starts a recovery process (step ) or jumps to the end of its program (not indicated in ).","The recovery process (step ) is possible when the additional data received from device B comprises enough and reliable information for device A to derive from it all necessary state data to continue its program at the point where the last program step was made prior to waiting for further input from device B. After a correct recovery process, which is checked in step , the program can continue with step . If the recovery has not been successful a message to that end may be generated and transmitted to device B (step ), and the program stops (step ).","In step , the device A carries out a next program step in accordance with its own program.","In step , once again, after having carried out the next program step, device A stores the state data valid by that time in its memory , or data from which the state data can be derived.","If, as indicated in step , it is established that the program can be finished, it goes to step . Else, the program continues with step  in order to start a new cycle in accordance with the present invention. After step  the program may continue with step .","During the recovery step , the device A will examine whether or not the received additional data from device B is associated with a state of a point in its program where it could have been if no error would have occurred. In most cases, this will only be possible if device A had stored some relevant data in its non-volatile memory part, which is still present after any power failure. These relevant data in the non-volatile memory part need not be huge. Most of the data may have been stored in the volatile part of the memory  and may be received back from device B in the next communication primitive, e.g., contained in the additional data.","The recovery process can be easily implemented when the device A generates the additional data at any time such that it has a predetermined relationship not only with last state data in the running program, but also with all prior state data. Then, it is easier for the device A to establish which program steps were already taken in the program and, thus, which states were already obtained in the past.","The invention is not limited to the generation of such additional data with a predetermined relationship with state data in device A only. It is also applicable to device B. Thus, also device B may be provided with the option of generating additional data related to the state data of the program running on the device B. Such additional data generated by device B will be transmitted to device A with the next communication primitive and will be extracted from any communication primitive by device A. After having executed any instruction, device A will insert further additional data having a predetermined relationship with (e.g., they may be equal to the additional data received from device B in a next communication primitive to be transmitted to device B. Then, device B has the same level of protection as has device A.","For both device A and device B, the additional data as generated may have a predetermined relationship with all prior state data within the respective devices A and B.","In the explanation to and given above a simple relationship between the additional data received by device B and later retransmitted to device A has been assumed: they may equal one another. Then, device A receives the additional data unaltered by device B. However, beneficial to efficient use of communication bandwidth, the additional data, or part of it, may, in a further embodiment, additionally be used by device B as input to the processing step described in step . Furthermore, device B may in addition to storing the received additional data process the received additional data itself provided this processing results in processed new additional data being transmitted to device A for which the relationship to the state data in device A can be verified by device A, e.g. by first inverting the processing done in device B to the additional data. The modification to the additional data may in this way convey extra information from the second device to the first device, possibly also resulting in more efficient use of communication bandwidth.","The present invention is also applicable to a distributed environment as shown in . Then, device A may e.g. be smart card . However, instead of directly communicating all communication primitives to one device B, device A may actually send its communication primitives first to the central memory . Two or more devices ,  are arranged to check with the central memory , at times that they have executing time available, whether or not the central memory  comprises a communication primitive to be processed. One option is that such a device ,  reads a present communication primitive from the central memory  and afterwards removes the communication primitive from the central memory . Thus, it can be avoided that another device also reads that communication primitive from central memory  in order to process it.","Another option is, that the device having read such a communication primitive present in central memory  adds an identification, for instance a flag, to the communication primitive in central memory  indicating that the communication primitive has already been read by one of the devices ,  and need not be processed by another device anymore. Then, the central memory  will collect all communication primitives during a protocol. When these communication primitives are all related to single state data of the program carried out in device , after a power failure or other error, the device  can collect all the communication primitives from central memory  in order to recover the interrupted process. Of course, in the embodiment where each communication primitive comprises all relevant data from all prior state data of the process in device , it is not necessary to store all consecutive communication primitives but only to keep the last communication primitive in store.","Sometimes, after a power interruption and restoration, device  may simply request device  to retransmit the last communication primitive, and device  may be able to resume running its program.","Preferably, the communication primitives comprise identification data for identifying that the communication primitives comprise additional data related to state data in one of the devices , , .","As will be explained below, the relationship between the additional data and the state data, may be based on using encryption technology, cryptographic hash functions (one-time functions) and encryption with a one-way pad.","The most simple relationship between the additional data and the state data is a one-to-one relationship, i.e., the additional data equals the state data valid after the last program step carried out by the program. However, in most cases, state data is confidential and is only allowed to be known by the device concerned. Then, the additional data is not allowed to disclose the state data to the outside world and protection against discovery of this state data is provided.","One option of protecting the state data is to encrypt it with an encryption key only known to the device related to that state data. The encrypted state data is then sent as the additional data in the communication primitive to the other device (or to the central memory ). The device stores the state data (or other data from which the state data can directly be derived) in its working memory. After having received the next communication primitive of the other device the device checks whether the additional data received from the other device equals the encrypted form of the state data. To that end, it decrypts the received additional data and compares the decrypted additional data with the stored state data. Alternatively, it can encrypt its stored state data and compare the result with the received additional data.","Both in cases where the additional data comprises the state data itself and cases where it comprises encrypted state data, using a cryptographic hash (one-way function) can further enhance the security. Such a cryptographic hash is generated by the device associated with the state data, preferably, using a cryptographic key, preferably, only known to that device in a manner known to persons skilled in the art. Such a hash is added to the additional data and does not alter it. However, the hash has a predetermined relationship with the content of the additional data. Therefore, if the content of the additional data is altered accidentally or on purpose this will be established directly by checking the relationship between the hash and the content of the altered additional data. By using such a hash the device, upon receiving the returned additional data with the hash, can not only check the validity of the returned additional data but also use it to derive state data from it if its own state data has been lost partly or entirely. Such derived state data may be used to resume a program that is, e.g., interrupted by a power failure.","Advantageously, the cryptographic key used either as encryption key or hashing key is derived from a random or pseudo random value, for instance, generated when the device receives it first communication primitive. This (pseudo) random value may have a relationship with the content of the communication primitive received. The device stores this (pseudo) random value in its non-volatile memory part prior to sending a responding communication primitive to the other device.","The (pseudo) random value may be used as a value from which state data can be derived. Alternatively, it may be used as a cryptographic key either for the encryption process or the hashing process or both. Moreover, in a further embodiment, the cryptographic key changes each time an encryption or a hashing process is used, which further promotes security. Of course, then, each time a new cryptographic key is used its value may need to be stored in the non-volatile part of the memory. Any method of generating consecutive cryptographic keys may be used. For instance, a new key may be generated by a combination between an existing key and some content of a received communication primitive or by combining two earlier keys in a specified way. However, using one-way (hash) functions may advantageously be used as will be explained hereinafter with reference to .",{"@attributes":{"id":"p-0106","num":"0153"},"figref":"FIG. 4","b":["300","302","304","1","304"]},"The result of step (n) is transmitted as additional data in the next message by the device to another device (or to memory ), step . In step , the device waits for a return message.","After having received such a return message the device extracts the additional data from the return message, step . In steps  to , the device applies the one-way function to the random number stored in non-volatile memory as many times until the result obtained equals the extracted additional data. If no errors have occurred, the first time, this will be n times. Then, the program knows that the last program step carried out was related to the first possible state, and the program continues with state number , step . If, after n times applying the one-way function to the random number still no match has been achieved an error has occurred and the program continues with an error routine, step .","Then, to prepare for the next step, 1 is subtracted from n, step , and the process continues with step (). However, in a preferred embodiment, the result of this step may be obtained by caching the required value while performing the iteration in step , as is known to persons skilled in the art. So, for any next state in the program, applying the one-way function to the random number is 1 less than in the preceding step. Since a one-way function is used this ensures that an other device is never able to derive the next additional data related to the next state: provided other devices do not know the (pseudo) random number generated in step  by the fundamental property of cryptographic one-way functions it is infeasible to reverse the calculation made by the device, and so predict data for the next state.",{"@attributes":{"id":"p-0110","num":"0157"},"figref":"FIG. 4"},"In a hashing process, for instance, the result of step (n) is not directly sent as additional data in the next message but this result is used as a key to calculate an authenticating hash over all state data to be transmitted in the next message. This may advantageously be done when the state data comprises more information than just a number of the state concerned. Then, after having received the next return message and having extracted the additional data from the next return message the hash is used to check the correctness of the returned state data. This checked state is used to continue the program. Again, the number of times of applying the one-way function to the stored random number to arrive at a key to be used in the hashing function may be decreased by 1 for any next state to be transmitted. The key used in any transmission step may be stored in non-volatile part of the memory, however, it is not necessary to store the key since it can be derived from the stored random number and the one-way function used.","In an encryption process, the result of step (n) is not directly sent as additional data in the next message but this result is used as a key to encrypt all state data to be transmitted in the next message. This may advantageously be done when the state data is not allowed to be revealed to external devices. Then, after having received the next return message and having extracted the additional data from the next return message the additional data is decrypted to obtain state data. This encrypted state data is used to continue the program. Again, the number of times of applying the one-way function to the stored random number to arrive at a key to be used in the encryption process may be decreased by 1 for any next state to be transmitted. The key used in any transmission step may be stored in non-volatile part of the memory, however, it is not necessary to store the key since it can be derived from the stored random number and the one-way function used, and, preferably, from the current value of n identifying the current state possibly included in the additional data.","Keys generated in a way as explained with reference to  can also be used in a process where both hashing and encryption are used."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0043","num":"0087"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0044","num":"0088"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0045","num":"0089"},"figref":"FIGS. 3","i":["a ","b "],"b":"3"},{"@attributes":{"id":"p-0046","num":"0090"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
