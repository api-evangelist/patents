---
title: System and method for multiple channel video transcoding
abstract: A system and a method for manipulating video data received over a media channels is disclosed herein. The method includes using an index table to reference stored video data, including motion vectors, so that they can be efficiently accessed by encoder and decoder portions of a transcoder, where the decoder generates source pixel images, and the encoder generates estimated motion vectors based on the motion vector data stored.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07403564&OS=07403564&RS=07403564
owner: ViXS Systems, Inc.
number: 07403564
owner_city: Toronto, Ontario
owner_country: CA
publication_date: 20011121
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CO-PENDING APPLICATIONS","FIELD OF THE DISCLOSURE","BACKGROUND","DETAILED DESCRIPTION OF THE FIGURES"],"p":["This application is related to U.S. patent application Ser. No. 09\/819,147 entitled \u201cDEVICE AND METHOD FOR COMPRESSION OF A VIDEO STREAM,\u201d filed Mar. 27, 2001; U.S. patent application Ser. No. 09\/917,967 entitled \u201cMETHOD AND DEVICE FOR VIDEO PROCESSING,\u201d filed Jul. 30, 2001; U.S. patent application Ser. No. 09\/918,384 entitled \u201cMETHOD AND SYSTEM FOR ACCESSING DATA,\u201d filed on Jul. 30, 2001; and U.S. patent application Ser. No. 09\/918,380 entitled \u201cSYSTEM AND METHOD FOR MULTIPLE CHANNEL VIDEO\u201d filed on Jul. 30, 2001.","This invention relates generally to a system for processing video streams, and more particularly to a system and method of storing data used in video processing.","Unlike analog tuners for analog broadcast systems that can decode received analog media data with very simple circuitry, digital media data, such as moving video, generally requires processor intensive operations to reconstruct the digital media. The cost and effort of decoding of multiple simultaneous digital media streams can be prohibitive if the media streams have a relatively large amount of data associated with the media streams, such as data transmission rate required to support the high definition television (HDTV) 1920\u00d71080i format. This problem is currently solved by compression schemes that take advantage of continuity in inter-frame content to create very highly packed data. The Motion Picture Experts group (MPEG) has proposed methods that include the use of motion estimation for of blocks of images between frames to perform compression.","The step to compress video data is processor and memory bandwidth intensive. Motion estimation, a compression step, requires a large amount of the computational work that can use up a significant amount of available bandwidth. In common motion estimation methods, a frame of image data is first subdivided into a plurality of fragments or blocks. Next, a fragment or group of blocks of the current frame image is compared against one or more fragments or group of blocks in another frame or frames. The optimal fragment or group of blocks in each of the alternate frames may not be in the same location as the current frame. This location is often different between each of the alternate frame or frames and the current frame. The location of fragments with respect to a previous frame is represented as a motion vector. A complex processor and memory bandwidth intensive search algorithm that has to consider a plurality of fragments combinations is generally used to construct each motion vector.","With extremely high resolutions, such as the 1920\u00d71080i format, the data rate of such a compressed stream will be very high. This high data rate poses at least three sets of problems. First, to record or save such a stream over any length of time requires large amounts of storage that can be prohibitively expensive. Second, many display devices that can be used to view such a stream may not be capable of displaying such a high resolution data stream. Third, where there is a data network with multiple viewing or receiving devices, such a network will typically have a fixed bandwidth or capacity. Such a network may be physically incapable of simultaneously supporting multiple viewing devices. In addition, there can be a plurality of motion vectors are generally required to build each fragment or macroblock of a frame. This further adds to the processing and bandwidth problem.","Accordingly, there is a need for an improved system and method for processing video streams.","In accordance with at least one embodiment of the present invention, a system for transcoding is provided. The system includes a first general purpose processor to receive digital video data and provide parsed video data. The system further includes a second processor coupled to the first processor to access the parsed video data, the second processor includes a video transcoder. In accordance with a specific embodiment of the disclosure, illustrated in , motion vector data and quantization information is stored in memory, and accessed using an index table to reduce memory bandwidth used by the system. An advantage of the present invention is that media channels may be efficiently received and transcoded. Another advantage is that real-time playback of video channels is more efficiently supported.",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIGS. 1-5"},"Referring now to , a high level functional block diagram of a video processing system is illustrated according to at least one embodiment of the present invention. Video processing system  includes input buffer  to receive data representing a video image to be provided to MPEG decoder . MPEG decoder  creates either the video image or an optionally scaled down representation of the video image decompressed frames in memory (RAM1 ). Additionally, MPEG decoder  can obtain the motion vectors and quantization information from the decompression process. For our purposes, we shall call the collection of motion vectors and quantization information for each macroblock the macroblock information. The macroblock information are saved in memory (RAM2 ). Note that the macroblock information are not normally saved in memory using a standard MPEG decoder. Also note that in other embodiments, memories  and  can include dynamic random access memory, static dynamic random access memories, hard drive storage devices, and the like.","MPEG encoder , in one embodiment, performs many of the steps of normal MPEG encoding, but avoids the computationally intensive motion estimation step by retrieving the motion vectors previously saved in RAM2 . By retrieving the set of surrounding motion vectors and building a new set of motion vectors, MPEG encoder  can avoid the expensive search that is required in conventional motion estimation. Output buffer  includes a bit bucket that accumulates data bits before it out to a final destination, such as memory or any output ports to a device coupled to receive such data.","Note further that within each picture data quantization information for each macroblock can vary depending on the content of each macroblock. Using larger quantization values will generate more compressed data, and result in smaller data streams, but will also introduce loss of detail in each macroblock. In a well encoded source MPEG2 stream (received data) the quantization information from each macroblock will be optimized and, in accordance with the present disclosure, we can reuse this quantization information as is disclosed in pending patent application Ser. No. 09\/990,737 entitled \u201cMETHOD AND SYSTEM FOR RATE CONTROL DURING VIDEO TRANSCODING,\u201d and filed concurrently with the present application on Nov. 21, 2001, and is hereby incorporated herein by reference. In fact, a higher quality picture can be obtained by reusing this quantization information, thereby allowing larger quantization for macroblocks that can afford to lose detail associated with aggressive compression, while preserving detail for macroblocks that should contain greater details.","Referring to , a transcoding method is illustrated according to at least one embodiment of the present invention. With reference to the specific embodiment illustrated in , elements with labels from - indicate functions the decoder portion, and elements - identify functions encoder portion of the transcoder. Note that this example assumes an image downscale of \u00bd\u00d7\u00bd. A macroblock, in MPEG terminology, is a 16\u00d716 matrix of individual picture elements. A block in MPEG terminology is an 8\u00d78 matrix of individual picture elements. When downscaling by \u00bd\u00d7\u00bd, it is assumed that a 2\u00d72 set macroblocks are converted to form a single macroblock. The \u00bd\u00d7\u00bd downscaling operation is typically performed with an effort to preserve as much content of the original image as possible, while presenting the final result in a smaller bitmap. Downscaling is well understood to mean a process where a group of picture elements are combined in some fashion to create another group consisting of less picture elements. For downscaling of \u00bd\u00d7\u00bd several options are available. For example, one possible implementation, the picture elements are blended in a predefined method. However, one reasonably versed in the art will understand that there are multiple ways to blend them to achieve the same results or perhaps to even scale without blending.","In step , a macroblock being decoded is retrieved and bit parsed. In step , a variable length decode, using a Huffman decoder for example, is performed, and can be run level or run length decoding, to retrieve information about a particular block. The information retrieved contains a series of run-level sequences, each representing an 8\u00d78 spare matrix (known as a block) with a run of sequential zero values implicitly defined by the run. When referred to as run-level within the MPEG scope, the run refers not to repeated runs of the value in level, but to consecutive runs of 0. In the case of MPEG, the block is built in a zigzag fashion.","After the decode, the process dequantizes the generated block in step , which involves multiplying each element in the block with an element in a matrix. As is well known in the art, dequantization is inverse quantization, where a matrix of fixed constants might be retrieved or determined at the start of the decoding process, rarely changing as the stream is decoded. Each element of the sparse matrix is multiplied with this constant value from the corresponding entry in this matrix of constants. To understand the significance of the inverse quantization process, it should be understood first that during the compression process, the blocks, in one embodiment, went through a discrete cosine transform (DCT) step to convert the picture blocks into the frequency domain. In this representation of the picture blocks, the original blocks can still be retrieved (up to arithmetic rounding resulting from limitations in number representation) without any loss. In the frequency domain, the block of data has an interesting property. The main determinants of the appearance of the image to the human eye is primarily decided by the terms of the block (matrix) that are in the top left corner (starting at indices [0,0,] of the matrix). Changes to the terms to the bottom right of the block tend to have less of a visible effect on the reconstructed blocks to the human eye. The purpose of quantization during the encoding process is to take advantage of this property and attempt to treat terms that are close to zero and positioned closer to the bottom right, as zero, while preserving as much of the information in the top left corner as possible.","After the block has been dequantized, an inverse discrete cosine transform (IDCT) method is applied to the block of data in step  to obtain the block in its raw form. Steps -  proceed via a loop through the end of macroblock decision step , until a complete macroblock is obtained. For MPEG, this macroblock typically consists of 4 (2\u00d72) blocks of information in the Y (luma, or brightness) and 1 block of Cr and 1 block of Cb. When the complete macroblock is obtained, the process proceeds to test decoder motion vector step , where motion vectors for the macroblock are determined or identified. If there is no motion vector for a particular macroblock, in one embodiment, the macroblock is downscaled by a scale factor, such as 1, 2, 4 or 8, and written out in step .","Where there is a set of motion vectors, the motion vectors will be saved in step  into a storage area, such as memory  (), that holds all the original motion vectors used to build this frame. In step , motion compensation is performed to build a new macroblock. This new macroblock is then downscaled and output in step .","In step , if the frame has finished, the process initializes the frame encoder, at , which will start to encode a macroblock in step . If the current macroblock has no motion vectors (determined at step ), then the macroblock is read in step , from the downscaled and decompressed frame created during the decoding process, and each block in the macroblock undergoes a discrete cosine transform in step . If the current macroblock has motion vectors (determined in step ), the four sets of neighboring motion vectors are retrieved from storage in step  and are used to build the original image frame in steps  and . In this example, note that scaling of \u00bd\u00d7\u00bd, is used. Retrieval of more motion vectors for other scale factors would be required. For example, if scaling by \u2153\u00d7\u2153, 9 motion vectors would be used. If scaling is by \u2156\u00d7\u2156, between 4 to 9 motion vectors would be used, depending on how the resultant motion vector is generated.","In step , the new motion vector can be built in multiple ways. In one method, a simple averaging modulo of \u00bd can be applied to each component of the vectors from each of the four sets of motion vectors. In an alternate embodiment, the most frequently occurring motion vector (\u0394X, \u0394Y) from each set of kth-motion vectors can be selected, with an arbitrary method for breaking ties. One possible method of breaking ties is to choose the element that is closest to the top left motion vector. With the new motion vector built in step , the process proceeds to read the macroblock from the stored decompressed image frame and then builds a delta frame containing the result of applying a reverse motion compensation step to obtain the delta macroblock in step . At this point, the delta macroblock is sent to the unit that performs a discrete cosine transform (DCT) on all in step  (rounding integer division of each element by elements of a matrix). The resulting quantized matrix representation of each block is then variable length encoded in step , and the compressed result is sent to the output encoded macroblock unit in step . This process continues until detecting the encoder end of frame in step , signaling the decoder to begin working on the next frame. Note that with use of double buffering of the motion vectors, and queuing other command streams, both the encoder and decoder steps may both run in parallel.","One feature of at least one embodiment is that, where there are motion vectors, the motion vectors will be saved in step , into a storage area that holds all the original motion vectors used to build the processed frame. In addition, the computation intensive and costly motion estimation step is avoided by retrieving the stored motion vectors and building a new motion vector set using simple process steps in step . By avoiding the expensive motion estimation step, the present invention may provide a much more cost-effective solution that achieves largely the same quality of transcoding as systems that searches the motion vectors from scratch.","Referring next to , a compressed video transcoding system is illustrated according to another embodiment of the present invention. Compressed video transcoding system , herein referred to as transcoding system , can include part all or none of video processing system  () in various implementations. Transcoding system  includes media source , transcoder device , host central processing unit (CPU) , a bus\/memory controller  (i.e. a north bridge chip), host dynamic random access memory (DRAM) , system input\/output (I\/O) bus , network controller , and device memory .","Transcoder device , in one embodiment, includes processor , Huffman decoder , input bit bucket , memory controller , decoder instruction packet (DIP) sequencer , video processor , and system direct memory access (DMA) bus interface . In at least one embodiment, processor  is a general purpose processor, such as a RISC processor, while DIP sequencer , and video processor  are specialized data processors optimized to handle specific tasks efficiently. In one embodiment, the video processor , sequencer , and processor  are integrated on to a common substrate, such as a semiconductor substrate or a package substrate. Transcoding system  can include additional elements, as appropriate, without departing from the spirit or the scope of the present disclosure.","In at least one embodiment, media data stream  represents digital media data from one or more sources , each source can have one or more media data channels. Media source  can include any source of media data streams, such as a MPEG player, a data server connected to transcoding system  via network controller , and the like. In one embodiment, media data stream  is in a byte, or word format when received at he system . In other embodiments, the media data stream  can be a bit stream that is organized into bytes or an appropriate word size by the system . Once in an appropriate word format, the data is transmitted to memory controller . In one embodiment, the media data stream  is treated as a client of the memory controller . The media data stream can be provided to the memory controller  through a shared or dedicated set of input pins, or through the system I\/O bus . Generally, the memory controller  will arbitrate among each of its clients based on a predefined prioritization scheme, such as a round robin scheme, or based on a fixed prioritization as will be discussed greater with reference to .","The data from media data stream  is stored in device memory . Device memory  can include flash memory, random access memory, a cache, and the like. Once data streams are stored in the device , a plurality of clients, including the processor  and video processor , can access the memory  through controller  and access the data streams from memory . This allows the system  to process data in parallel.","Processor , in one embodiment, uses input bit bucket  as a staging area to support bit-level accesses to the data stored in the memory , and to buffer data thereby reducing latency between the processor  and the data stored in the memory . For example, the processor  may request any bit or multiples of bits in a variable range by using the input bit bucket . For example, the processor can request a byte, or appropriate size word, starting at bit  of an address location. The returned value will have the value of bit  appropriately aligned to a boundary of the actual data provided to the processor .","Processor , in one embodiment, is a general purpose processor, such as a MIPs processor, or a specialized processor, such as an ASIC. A general purpose processor is a data processor that performs one or more functions specified by software, where it is understood that software would include firmware. In one embodiment, processor  access received video data and performs error correction; filtering, such as parsing or decoding of the media data stream  generates decoder instruction packets (DIPs) for a desired media data channel received through media data stream . The DIPs include specific instructions and\/or control information to be used by the DIP sequencer  and vector processor  to generate new macro blocks. Once generated, the DIPs can be stored in device memory  by memory controller . In another embodiment, one or more of the error correction, filtering, or parsing functions are performed by another component of device . For example, a bit stream filter (not shown) could be used to perform filtering operations on media data stream  before it is stored in device memory  by memory controller . Processor  can also utilize a dedicated Huffman decoder  to perform a Huffman decoding process. Huffman decoder  can include a simple variable bit lookup table in hardware or software that speeds up the decoding process.","DIP sequencer  acts as a control unit to the video processor . In fact, the DIP sequencer can be considered part of the video processor . The sequencer  is a client to the memory controller  from which receives data and provides the data to the video processor (transcoder)  along with control signals.","Video processor , in one embodiment, is a video transcoder that receives the DIPs and control signals from the DIP sequencer  and then proceeds to perform media decoding in a pipelined fashion to maximize throughput. In at least one embodiment, video processor  uses decompression block  to decompress the DIPs. The data output of decompression block  is transmitted to scalar block , where the decompressed video data is scaled by a scale factor and then output to compression block . Compression block , in one embodiment, compresses the output of scalar block  to generate a compressed data, such as a video frame, and transmits the compressed data to output bit bucket , which stores bits of compressed video data until an entire word is ready to be stored by the memory controller . A particular implementation of video processor  is discussed in greater detail with reference to .","Memory controller  treats video processor  as a client and retrieves its data from output bit bucket  and stores it in device memory . Once a frame of compressed media is retrieved from the video processor  and stored in the memory , it can be accessed by system DMA bus interface  and sent to north bridge  using system I\/O bus . North bridge , in turn, routes the data to host DRAM . Host DRAM , in one embodiment, serves as storage for the final media data channel to be distributed to the rest of the system. In one embodiment, host processor  schedules when the final media data channel will be sent to network controller , which handles the distribution and broadcast of the final media data channel. In one embodiment, the network controller is connected to a plurality of display devices used to display transmitted information. Note that the north bridge  represents an integrated or multi-chip solution for interfacing the host CPU  to the system (host) memory  and the IO bus .","Referring now to , a particular implementation of video processor  is illustrated according to at least one embodiment of the present invention. Recall that video processor  decompresses a media data channel (in the form of DIPs) parsed from media data stream  using decompression block , scales the output using scalar block , and then compresses the scaled output using compressor block . In one implementation of the present invention, decompression block  includes deZigZag\/dequantizer block , inverse discrete cosine transform (IDCT) block , motion compensation , and macroblock buffer , while compression block  includes buffered motion predictor block , discrete cosine transform (DCT) block , quantizer\/ZigZag block , and Huffman encoder . It will be appreciated that one or more components of decompression block  and\/or compression block  may be implemented separately.","As discussed previously, in one embodiment, the decoder instruction packets (DIPs) are retrieved from device memory  () by DIP sequencer  through the Memory Controller . In this case, DIP sequencer  can then forward the DIPs to the transcoder  in a manner operable to provide the DIPs to an appropriate location. For example, the sequencer  can provide data to individual blocks by directly addressing and providing data through a bus local to the transcoder , or the sequencer  can write control land and\/or data information to a register backbone that is accessible by the transcoder  blocks. During a normal data flow, the sequencer will enable the deZigZag\/dequantizer block  to retrieve data.","In one embodiment, the DIP Sequencer retrieves DIPs based on elementary stream data received over media data stream  and stored in memory . Recall that, in at least one embodiment, media data stream  () includes one or more MPEG video data channels. In this case, the MPEG algorithm for compression of the video channel has usually a stage in the algorithm for a discrete cosine transform (DCT), which performs a time domain to frequency domain transform. As a result of this transformation, the elements in the frequency domain, post-DCT, that are closest to the top left element of the resulting matrix with indices (0,0) are weighted more heavily compared to elements at the bottom right of the matrix. If the matrix in the frequency domain were to use less precision to represent the elements in the lower right half of the matrix of elements, the smaller values in the lower right half will get converted to zero if they are below a threshold based on a quantization factor. Dividing each element by a quantization factor is one method utilized to produce more zero elements. MPEG and related algorithms often apply larger quantization values to decrease the precision of the matrices in the frequency domain, resulting in more zero elements, and hence decrease the data transmission  rate. Accordingly, in one embodiment, deZigZag\/dequantizer block  dequantizes the results of a DCT operation on media data channel.","Similarly, although the normal way to represent a matrix is in a (row, column) format, the distinct properties of a matrix produced as a result of a DCT function lend themselves to a different method of representing the post-DCT matrix. In one embodiment, the post-DCT matrix is represented in a zigzag manner, e.g. (1,1), (2,1), (1,2), (1,3), (2,2), (3,1), (4,1),(3,2), (2,3), etc. By representing the post-DCT matrix in this manner, a relatively long run of zeros in the post-DCT matrix is likely to be encountered. As a result, the post-DCT matrix can be more efficiently represented by using a (Run, Level) format, where Run represents the number of consecutive zeros and Level represents the value of the next non-zero element of the post-DCT matrix. The (Run, Level) pair can then be encoded via a fixed Huffman table to further compress the post-DCT matrix.","The output from deZigZag\/dequantizer block , in one embodiment, is sent, or otherwise made available, to a component that converts the output from a frequency domain to a time domain. For example, if the parsed channel of media data stream  (represented by DIPs) was previously processed according to a discrete cosine transform, the output from deZigZag\/dequantizer block  could be sent to inverse discrete cosine transform (IDCT) block  where the output is converted from a frequency domain to a time domain using an inverse discrete cosine transform function to generate a block of data. Other methods for conversion between a frequency domain and a time domain may be used without departing from the spirit or  the scope of the present invention. The blocks generated by IDCT block  can be stored in macroblock buffer . When enough blocks are generated to form a macroblock, macroblock buffer  will send the macroblock of data down along with macroblock information (containing motion vector and quantization information) to motion compensator .","In one embodiment, motion compensator  can operate as discussed previously with reference to step  of , where motion compensator  stores macroblock information for later use. In an alternate embodiment, the stored macroblock information contains only quantization information. If the macroblock transmitted to motion compensator  is part of a reference frame (I-Frame), motion compensator  decodes the macroblock and writes the decoded results and only the quantization information to device memory  () using memory controller . The reference frames generally are used to decode other non-reference frames that have to be constructed from the motion vectors.","The new macroblock generated by motion compensator , in one embodiment, is sent to scalar block , where the macroblock is scaled using a scale factor. For example, if the macroblock includes a 4\u00d74 matrix of blocks and a scale factor of 2 is used, the resulting scaled macroblock would include a 2\u00d72 matrix of blocks. The resulting scaled macroblock is then transmitted to buffered motion predictor  to begin the compression process.","In one embodiment, when enough scaled macroblocks are generated to form a new complete macroblock, the associated stored motion vectors are processed by a motion vector generator, such as buffered motion predictor , to generate a new set of motion vectors. In an alternate embodiment, motion vectors can be generated based upon the macroblocks of adjacent frames in a traditional manner.","Reference frames are passed to DCT  a block at a time. DCT  takes each block and transforms the block of data from a time domain into a frequency domain, for example by performing a discrete cosine transform, as discussed previously. In one embodiment, if the macroblock does not have any motion vectors associated with it, such as an intraframe or I-frame, the macroblock is passed directly from scalar  to DCT block , for example using an internal data path, without being processed by motion predictor .","The modified block output by DCT , in one embodiment is sent to quantizer\/ZigZag block , where the block is quantized and\/or transformed, or \u201czigzagged\u201d from a (row, column) format to a format more optimized for run level encoding. The quantized and\/or zigzagged output from quantizer\/ZigZag block  can then be sent to Huffman encoder , which compacts or compresses the output from quantizer\/ZigZag block  and sends the results of the compression as a bit stream to output bit bucket . In one embodiment, output bit bucket is capable of storing data in a bit level manner at any bit location with a low latency. For example, the output bit bucket can operate as a buffer to accumulate the bit stream output from Huffman encoder  so that it can be written to device memory  in an efficient manner.","The transcoder  further includes an IDCT portion  which performs an IDCT on the data from the quantizer. This data is combined with data from the motion predictor  and stored to correct for the effects of lossy compression. In some embodiments, correction for lossy compression is used, as the frames generated by the transcoder can be used as reference frames to form other frames. The propagation of errors can be limited by providing for a step to correct for lossy compression, thereby improving the accuracy of the data generated by the encoder portion.",{"@attributes":{"id":"p-0066","num":"0065"},"figref":["FIG. 5","FIG. 5"],"b":["340","510","514","520","525","530","535","535"]},"Referring to , a method for using transcoding system  is discussed according to at least one embodiment of the present invention. Transcoding method  initiates with step , where media data stream  () is received by, or transmitted to, transcoder device . As discussed previously, media data stream  can be stored in device memory  (FIG. ) for later retrieval. In step , processor  parses media data stream  to identify a desired data channel, such as a video data channel sent from a MPEG player. Processor  can also perform other processes on media data stream  in step , such as error correction, filtering, etc.","In step , the parsed data channel, in one embodiment, is transmitted to video processor  in the form of decoder instruction packets (DIPs). Decompression block  of video processor  decompresses the DIPs, as discussed previously with reference to . In step , the output of decompression block  is scaled by scalar block  () using a scale factor to reduce the amount of data associated with an element of the desired channel of media data stream . For example, by scaling a macroblock of a MPEG video channel, less data is needed to represent each frame. In step , the scaled data output from scalar block  is compressed by compression block , as discussed previously with reference to . The compressed output from compression block  is then output to one or more receiver units. The receiver units could include a variety of media devices, such as video display terminals, audio devices, and the like.","As a result of the procession performed by transcoding system , a channel of media data stream  () is downscaled or compressed, resulting less data associated with the channel. For example, video processor  () could downscale a channel of a video data stream (media data stream ) from a MPEG player, resulting in a channel having less data per frame. This downscaling would then allow the video data channel to be transmitted faster and\/or more efficiently over a network or other medium. For example, in one embodiment, media data stream  includes a plurality of video data channels to be used for real-time playback. In this case, by individually downscaling one or more of the video data channels, they may be transmitted more quickly and\/or more efficiently, thereby supporting the real-time playback of the video channels.","The particular embodiments disclosed herein are susceptible to various modifications and alternative forms. Specific embodiments therefore have been shown by way of example in the drawings and detailed description. It should be understood, however, that the drawings and detailed description are not intended to limit the invention to the particular form disclosed, but on the contrary, to the maximum extent permitted by law, the invention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the following claims, and their equivalents. For example, in the system illustrated in , the connections between the decoder  and the memories  and  may represent separate busses or common busses. Likewise, the connection between the encoder  and the output buffer and the connection between the decoder and the input buffer may represent the same or different connections, and may even be common with the connections to the memories  and . Also, in another embodiment of the present invention, one of a normal mode of operation, where the encoder determines the motion vectors, and a motion vector reuse mode as described herein is selected. Selection of one mode will generally be based on the availability of previously saved macroblock information. Note that in another embodiment, during a normal mode of operation, the decoder would not save motion vectors.","One implementation of the invention is as sets of computer readable instructions resident in the random access memory of one or more processing systems configured generally as described in the FIGS. Until required by the processing system, the set of instructions may be stored in another computer readable memory, for example, in a hard disk drive or in a removable memory such as an optical disk for eventual use in a CD drive or DVD drive or a floppy disk for eventual use in a floppy disk drive. Further, the set of instructions can be stored in the memory of another image processing system and transmitted over a local area network or a wide area network, such as the Internet, where the transmitted signal could be a signal propagated through a medium such as an ISDN line, or the signal may be propagated through an air medium and received by a local satellite to be transferred to the processing system. Such a signal may be a composite signal comprising a carrier signal, and contained within the carrier signal is the desired information containing at least one computer program instruction implementing the invention, and may be downloaded as such when desired by the user. One skilled in the art would appreciate that the physical storage and\/or transfer of the sets of instructions physically changes the medium upon which it is stored electrically, magnetically, or chemically so that the medium carries computer readable information.","A data instruction packet (DIP or \u201cDIP packet\u201d) is a data packet that can contain both instruction information and data.  illustrates one example of a DIP packet.","The DIP illustrated in  has a header portion, a configuration portion, and a data portion. The header of the DIP comprises an opcode and a size indicator. The opcode portion of the DIP indicates an instruction, or other control information to be associated with a specific DIP packet. In one embodiment, the size portion of the header indicates whether there is a size payload associated with the DIP. For example, the size portion can have a value to indicate that there is no configuration or data associated with the DIP, only the size of the header. Another embodiment allows a size portion value to indicate the DIP is terminated by an end of DIP (EOD) indicator. Another embodiment allows a size portion value to indicate that the size of the DIP is specified a subsequent number of bytes. For example, the size portion value can indicate that the next two or four bytes contains an unsigned integer specifying size of the DIP.","The configuration portion of the DIP can contain configuration information specifically related to its specific opcode. For example, a DIP could have an opcode to indicate picture control information is included, whereby the configuration portion can be predefined such that a DIP decoder would access the control information from the configuration portion at a predefined location(s): Note that the configuration portion of the DIP is optional depending upon the actual DIP. Also, the configuration portion can contain the size payload data described above.","The data portion of the instruction packet can contain data associated with the DIP packet. For example, compressed or uncompressed video data could be included as part of a specific DIP. Note the presence of data portion is based upon the opcode. In a mode where no configuration or data portion is available, the header portion can specify a specific operation to be performed independent of configuration and operation data.","In accordance with a specific mode of the disclosure, the DIP packets are used to packetize digital video data, such as elementary stream data, in such a manner that the video data is independent of the type of data from which it is received. Therefore, if a specific video standard, such as the MPEG standard, changes in the future, or if a different digital video standard is desired to be supported, the procedure used to generate the DIPS could change to accommodate the received video data while leaving the DIP format unchanged. This provides for efficiency in that hardware can be designed independent of specific video standards.","Examples of specific DIP opcodes include a DIP opcode indicating the DIP contains video time stamp information, a DIP opcode indicating that picture configuration information is contained within the DIP, a DIP opcode indicating slice or macro block information is included with the DIP, a DIP opcode indicating scaled macroblock information is included in the DIP, a DIP opcode indicating that quantizer matrix data is included in the DIP, a DIP opcode indicating that the last picture DIP should be repeated, and\/or a DIP opcode indicating a specific picture location, such as end of a slice, frame, or macroblock. It will be understood that additional opcodes can be included to support other functions, and that the actual DIP containing the opcode is generally stored and subsequently decoded.",{"@attributes":{"id":"p-0078","num":"0077"},"figref":["FIG. 8","FIG. 3","FIG. 8","FIG. 3"],"b":["300","710","330","390","15","715","345"]},"DIP generator  includes an elementary stream reader , a data instruction packet generator , and a pointer control portion . In one embodiment, each of the elements - can be implemented in software on a general purpose processor having a combination of input and output ports for providing the data to and from the individual software modules. In another embodiment, the elements - can be implemented in hardware having input and output ports coupling components to one another.","Memory  includes portions to store elementary stream data , DIP data , and DIP pointer data .","In operation, the elementary stream reader  receives elementary stream data, or other video data, from memory portion . In one embodiment, the elementary stream data  has first been received from a media source , as illustrated in , and stored in portion . Generally, this data will be stored as elementary stream data representing a video image. As discussed with reference to , the data can be received as the result of a client request to a memory controller. The elementary stream reader receives the video data so that it may be packetized by the data instruction packet generator . The data instruction packet generator generates the actual DIP that includes the instructions and data necessary for subsequent control and operation of the video processor portion , of .","In addition to packetizing video data for use by the video processor , the data instruction packet generator can generate DIPS to configure the video processor . In one embodiment, each macro block of data is stored as a single DIP. In other embodiments a plurality of macroblocks can be associated with a single DIP. For example, an entire slice of data can be transmitted as part of a single DIP. Likewise, it will be appreciated that any number of DIP variations can be implemented to transmit video information.","As a specific DIP is generated by the data instruction packet generator  it is written back to a DIP storage portion  which may be part of memory . It will be appreciated that the DIP storage portion  can be volatile memory, or non-volatile memory, such as a hard drive. In one embodiment, the DIP storage portion  can be a circular buffer associated with a frame buffer that is accessed by the video processor. Generally, the access of elementary stream data by elementary stream reader  and the generation of DIPs occurs in real time relative to the viewing of the image being generated. Once the DIP data is stored in the memory location , the data input controller  can receive the DIP data to provide it to a DIP decoder, as will be discussed later.","In accordance with a specific embodiment of the invention, a pointer control portion  tracks when a new DIP is generated and stores a pointer to the DIP in a storage location . Uses of the DIP pointer data will be discussed in greater detail herein.",{"@attributes":{"id":"p-0085","num":"0084"},"figref":["FIG. 9","FIG. 3","FIG. 9","FIG. 9","FIG. 8"],"b":["303","390","340","345","350","341","346","715","347","348","350"]},"The video processor  includes additional detail relative to its scalar block . Specifically the scalar block  further comprises scale buffer  and scale engine . The DIP sequencer  is coupled to the memory controller  which in turn is coupled to one or more memory devices such as the device memory . Note a cache memory  is illustrated that can include data stored in memory .","In operation, the input control module  of the DIP sequencer  will receive specific DIP information through the memory controller . In one embodiment, the DIP input control module submits client read requests to the memory controller . The memory controller  will receive DIPs either through cache memory , or device memory . Upon receiving the requested DIP, the decoder  will perform an operation based on the opcode portion of the DIP packet. In one embodiment, the DIP decoder module  will include microcode associated with each one of the DIP opcodes. Based on the specific opcode, the DIP sequencer  will interface with the video processor portion  through the DIP output control module .","For example, if the opcode in a specific DIP indicates picture configuration data is included, the DIP decoder module  will execute a function, in hardware or software, that would write to appropriate registers of the video processor  to configure it with specific information. For example, specific scale information, such as information related to the source picture size and the target picture size that is included as part of a DIP packet could be stored into one or more registers that control the functions of the scale engine .",{"@attributes":{"id":"p-0089","num":"0088"},"figref":"FIGS. 10-14","b":"350"},"In one embodiment of the present disclosure, the DIP sequencer accesses DIPs stored in device memory  and provides information representing macroblocks to the video processor . Generally, the DIP data provided to the transcoder  will be compressed data representative of a macroblock of video. By providing the data to the video processor , along with appropriate decompression information, the video processor can decompress the data to derive the decompressed macroblock data. For purposes of discussion it is to be understood that there may be several decompression processes performed by the video processor  before uncompress macro buffer data is stored in scale buffer . However, for purposes of discussion, it will be stated that the DIP sequencer  provides macro block data to the scale buffer. It should be further understood, that in another embodiment of the present disclosure that the DIP sequencer would perform some or all of the decompression functions performed by the video processor.","Once macro block data is stored in the scale buffer  of the scale block , the scale engine  can access the macroblock data stored in the scale buffer  to provide scaled macroblocks the scale engine can use traditional scaling methods, or the scaling methods disclosed herein to generate scaled images. In order to better facilitate understanding of the present invention, it is useful to reference , which illustrates the relationship of macroblocks with respect to an image frame.",{"@attributes":{"id":"p-0092","num":"0091"},"figref":["FIG. 10","FIG. 10","FIG. 10"]},"The frame of  will be associated with a specific resolution. For example, the frame of  can be considered a source frame having a resolution of 1920 pixels by 1080 pixels. Since each macroblock represents a 16 pixel by 16 pixel portion of the frame, the number of macroblocks used to represent a frame is dependent upon the resolution of the frame. It should be noted that, while the term macroblock has a specific meaning, for purposes of discussion and\/or implementation block sizes other than a traditional macroblock can be used in other embodiments of the present invention.","In operation, the macroblocks of the frame illustrated in  are stored in the scale buffer  prior to being accessed by the scale engine , which creates destination macroblocks representing a scaled image. For example, to generate a destination image having a resolution of less than 1920 by 1080, for example a resolution of 1280 by 720, it would be necessary for the scale engine  to access multiple source macroblocks. As illustrated in , four macroblocks would be needed in order to generate a new destination macroblock DM(DMR0,DMC0), which is the macroblock associated with the row labeled DMR0 and the column labeled DMC0. In other words, when an image is being scaled down, a single destination macroblock is generated from more than one source macroblocks.","For the scale engine  to perform a scaling efficiently, the source macroblocks should be available to the scale engine  through the scale buffer . In accordance with a specific embodiment of the present disclosure, this is accomplished by loading in a first set of macroblocks, such as a slice of data (i.e., the first row of macroblocks (0,0) through (n,0)) or a first plurality of slices. A new destination slice will generate a new row or macroblocks containing horizontal data bounded by DMR0. Therefore, a single slice of source macroblocks does not contain enough macroblock data to generate the destination macroblocks used to represent a new slice. In accordance with a specific embodiment of the disclosure, only a portion of a row of macroblocks is also loaded. For example, to generate the destination macroblock DM(DMR0, DMC0) at least the source macroblocks M(0,1) and M(1,1) for the second row of macroblocks M(x,1) are needed. This specific embodiment provides for efficiencies over known methods by allowing for destination macroblocks to be generated by storing less than an entire slice of video data into the scale buffer, thereby reducing the size of the scale buffer.","The source macroblocks no longer needed to generate a subsequent destination macroblock can be overwritten once the destination macroblock is generated. Note that the size of the scale buffer in this embodiment will be determined by the actual scale factor being implemented, or by the maximum scale factor that can be implemented. For example, referring to , it can be seen that as many as nine source macroblocks can be needed to generate a destination macroblock (see M(DMR1,DMC1) for the destination block size indicated. In this embodiment the scale buffer would need to accommodate storing two slices, plus three additional macroblocks of a third slice. A greater portion of the third slice can be included when it is desirable to provide additional buffering to assure the scale engine  does not stall.","One advantage of this embodiment is that since the source macroblocks are stored sequentially, for example relative to scan order, the DIP packets representing the macroblocks are accessed sequentially.  illustrates DIP packets for each of the macroblocks stored immediately sequential in the address space. In accordance with a specific embodiment of the disclosure, each of the DIP packets can have a different size. By accessing the DIP packets sequentially allows the DIP sequencer to determine where one packet begins and another packet ends. Therefore, all of the DIP packets associated with a specific slice of macroblocks can be stored sequentially in memory , thereby allowing adjacent macroblocks to be accessed from memory  sequentially.  illustrates the DIP data  stored in a portion of memory device , which may be frame memory, or cache memory. The DIP data  is stored in sequential manner in memory from DIP (0,0) through DIP (n,m) as illustrated by the memory representation . In one embodiment, the location of each subsequent DIP is discernable only after a current DIP is read. Generally, this is accomplished by storing the DIPs in immediately adjacent locations to each other, relative to linear memory space. Memory representation , which illustrates data stored in the scale buffer , represents the macroblock data generated from the DIP data . Note that in  it is illustrated that the macroblocks associated with the first slice, and macroblocks M(0,1) through macroblock (3,1) are stored. While this is more than the number of macroblocks needed to generate the destination macroblock M(DMR0,DMC0), it allows for additional information to be stored to assure the scale engine  does not stall. It will be appreciated that additional scale buffer sizes may be used depending upon the latency designed into the present invention.",{"@attributes":{"id":"p-0098","num":"0097"},"figref":["FIGS. 13 and 14","FIG. 9","FIG. 13","FIG. 14"],"b":["351","353","390"]},"In one embodiment, the pointer values are stored in the DIP pointer portion in such a manner that there is a known spacing between each pointer. For example, pointer values can be stored in immediately adjacent words. By having pointers stored at known, or readily calculable locations, it is possible for the DIP input control module  to access specific DIPs based upon a destination macroblock that is to be generated. Being able to access DIPs out of order represents an advantage over the know art, and the previously describe method, in that a scale buffer having a reduced size is realized since it is only necessary to accommodate those source macroblocks needed by the scale engine  to generate a specific destination macroblock. Therefore, it is possible for the DIP input control module  to access just those source DIPs needed to generate a desired destination macro block. For example, referring again to , it is possible to access only the DIPs associated with macroblocks M(0,0), M(1,0), M(1,0), and M(2,0) to generated the destination macroblock M(DMR0,DMC0).","In accordance with one embodiment of the present disclosure, the source DIPs are stored within the memory  in the actual scan order. In another embodiment, the source DIP packets are stored in an expected access order such as a scale order. The term scale order is used to indicate the order that source macroblocks need to be accessed to accommodate generation of a destination macroblocks in specific order. For example, while the scan order sequence for macroblocks is left to right across each row of macroblocks, starting with the top row and proceeding to the bottom row, the scale order sequence is based upon the order that the destination macroblocks are to be generated. Therefore, where an order of destination macroblocks to be generated is M(DMR0,DMC0) followed by M(DMR0,DMC1), one example of a scan sequence would be to access the source macroblocks in the following order: M(0,0), M(1,0), M(0,1), M(1,1), M(2,0), M(3,0), M(2,1), M(3,1). Note that since the macroblocks M(0,0) and M(1,0) are used to generate only the macroblock M(DMR0,DMC1), they can be overwritten by subsequent macroblocks once they are no longer needed.","Since a pointer table is maintained indicating where each sequential DIP is stored, the actual order the DIP itself is stored in memory is not as important for purposes of knowing where the DIP is stored. However, in another embodiment the DIPS are stored in a scale access order, as opposed to a scan access order, to improve the likely hood that data that is to be accessed immediately sequential is stored on a common page of memory, thereby reducing latency associated with accessing DIP data from memory. Likewise, it will be appreciated that the actual order that the DIP pointers are saved can be based upon the scale sequence, or in a sequential manner other than scan sequential. For example, the pointers themselves could be stored in a manner to access sequential DIPS relative to a scan access sequence.",{"@attributes":{"id":"p-0102","num":"0101"},"figref":["FIGS. 15-18","FIG. 15"],"b":"810"},"At step , a second set of macroblock data is stored into the scale buffer. The second set of macroblock data represents a portion of a slice of frame data. As previously discussed, in one embodiment, the second set of data includes those macroblocks of a video slice that are needed to begin generation of a new scaled set of macroblocks.",{"@attributes":{"id":"p-0104","num":"0103"},"figref":["FIG. 16","FIG. 16","FIG. 15"],"b":["810","811","812","810","811","352","812"]},"At step  a determination is made whether the method of  has stored all macroblocks associated with a frame buffer in the scale buffer. If all macroblocks have been stored, the flow is finished. If all the macroblocks in the frame have not been stored the flow proceeds to step , whereby the next macroblock is stored in the frame buffer. It will be appreciated that storing the next macroblock at step  can overwrite a previous macroblock no longer used. The method of  illustrates a method where one or more entire slices of data and a portion of a subsequent slice of data are used to avoid storing only entire slices of video. In addition, the method the  facilitates the use of DIPS which have been stored in a scan sequential manner without the use of a pointer table.","The method of  is generally analogous to the method of . Steps , and  are used to load the initial macroblocks into a scaled buffer. Subsequently, at step  a new macroblock is generated based upon the stored information. Once the new macroblock is generated, the flow proceeds to step  where it is determined whether or not the frame buffer has been completed. If not, the flow proceeds to step  where the next macroblock is loaded and the flow returns to step  wherein a new macroblock is generated. This loop repeats itself until the entire frame has been generated.",{"@attributes":{"id":"p-0107","num":"0106"},"figref":"FIG. 18","b":"860"},"In one embodiment, the first macroblock of a specific frame is identified from an elementary stream stored in memory. The elementary stream is generally stored in memory as a result of receiving digital video data, such as an MPEG stream.","At step  a DIP is generated for the current macroblock. In one embodiment, the DIP is generated by including a DIP opcode and a representation of the video data accessed from memory into a payload portion of a DIP packet, where the opcode indicates that the DIP packet contains macroblock information. In another embodiment, it would be possible to first process the macroblock information accessed from the elementary stream data to create a specific format for the macroblock data before being stored in the DIP.","At step  the current DIP is stored to memory. In one embodiment, the current DIP can be stored into a circular buffer associated with a frame buffer. In this embodiment, the DIP would be readily accessed by a subsequent portion of the video processing device. In another embodiment, the DIPs would be stored to a system memory resource, such as a hard drive for access later by the video processing device.","At step  the pointer to the current DIP is stored in a DIP pointer location. Because the DIPs can have variable sizes it can be beneficial to keep track of the current DIP's location by having a pointer indicating where the current DIP is stored. This allows the current DIP to be subsequently accessed out of order. The pointer would be stored in a pointer location of the memory in a readily deterministic known manner. For example, each of the pointers can have a fixed size thereby resulting in a fixed distance between pointers. This is advantageous when it is desirable to load only those macroblocks to the scale buffer that are needed to generate a specific macroblock, thereby reducing the required size of the scaled buffer.","At step  a determination is made as to whether or not the flow of  is done. In one embodiment the flow of  is done when an entire frame of data has been processed by generating DIPs from the elementary stream of a specific frame or when there is no more data to process. If the process is done, the flow terminates otherwise the flow proceeds to step .","At step , a next macro block of the frame is identified as a current macro block. In one embodiment the next macro block is the next macro block in scan sequential order. In yet another embodiment, the next macroblock will be the next macro block anticipated to be accessed. For example, the next macroblock to be accessed can be the next macroblock in scale sequential order.",{"@attributes":{"id":"p-0114","num":"0113"},"figref":"FIG. 19","b":"851"},"Next, at step , the stored DIPS are accessed in a second sequential order different than the first sequential order. For example, if the DIPS were stored in a scan sequential order at step  the DIPS could be accessed in a scale sequential order at step . As previously described, DIPS can be accessed in a different order by having a pointer table with entries indicating where each DIP is stored in memory. Therefore, if the DIPS are stored in a first sequential manner, such as a scale sequential manner, it would still be possible to access the DIPS out of order without parsing through multiple DIPS to determine where a specific DIP begins. An embodiment implementing the specific embodiment illustrated in  would be advantageous in embodiments where just those macroblocks needed to generate a specific new macro block are to be stored in the scale buffer.","Referring to , the bit manipulator  is coupled to the general purpose data processor . In a specific embodiment, the general purpose data processor  is a microprocessor\/microcontroller core integrated onto a semiconductor device as part of an application specific integrated circuit (ASIC) herein described. Likewise, the bit manipulator  is integrated onto the ASIC, and is accessible by the processor  to support bit manipulation of data.","In one operating embodiment, the processor  provides read requests to the microcontroller . The processor  can generate read requests in response to a variety of situations, including when: data at a new address is being requested; data buffered in the bit manipulator reaches a predefined watermark; and, when the processor  determines an amount of data available in the bit manipulator  is less than a predetermined number of bytes. In one embodiment the processor  can determine an amount of data available in the bit manipulator by reading a register associated with the bit manipulator. In another embodiment the processor  can determine an amount of data available in the bit manipulator by receiving interrupts from the bit manipulator that indicate a specific amount of data has been used.","In the implementation illustrated, all data requested by the processor  is returned via the bit manipulator . Note that in other embodiments the processor  could indicate to the memory controller  which data is to be returned through the bit manipulator  and which data is to be returned directly to the processor . As illustrated data is returned to the bit manipulator  via a bus, such as a dedicated bus, a read bus, or a read\/write bus.","In an alternate operating embodiment, the bit manipulator  can interface with the processor  such that its own memory control logic could request data from the memory controller .","Data received by the bit manipulator  can be subsequently accessed by the processor . In one embodiment, the data is accessed by processor  by reading registers associated with the bit manipulator . For example, the bit manipulator  can have a set of registers that return a specific number of bits from 1 to N, where N is the bus size of the processor's  read bus. In addition, the bit manipulator can have a bit offset register that indicates the location of the first bit of the data to be returned. In another embodiment, data can be accessed from the bit manipulator by providing control signals indicating a data size and providing appropriate control information.",{"@attributes":{"id":"p-0121","num":"0120"},"figref":"FIG. 20","b":["335","910","905","930","920"]},"In one embodiment, the line buffer  is a circular buffer that acts as a first-in-first-out (FIFO) to store data returned from memory via the memory controller . In one embodiment the data received has a word sized based on the size of the data bus from the memory. For example the line buffer can receive 32 bit wide data words where the memory configuration supports a 32-bit word. In another embodiment the size of the data bus is based on the size of the data bus of the general purpose processor .","The bit access controller  receives request for specific data from the processor  and provides the specific bits requested over the data bus of the processor. Note that the size of the data bus between the processor  and the bit manipulator  can be different than the size of the data bus between the memory and the bit manipulator. In the example illustrated, the data bus to the processor  is a 16-bit wide bus. Based on the request from the processor  one to 16 bits of data will be returned. Note that when fewer than the maximum number of data bits are returned to the processor , the unused bits can be either one-filled, or zero-filled based on a predetermined setting, which can be a fixed or variable setting.","Registers  are accessible by the processor , and are operably coupled to the bit access controller  and line buffer . In one embodiment, as discussed in greater detail herein, the processor  can monitor the status of the bit manipulator , provide control to bit manipulator , and access data from the bit manipulator  by accessing the registers .","The interrupt logic  is used to track the amount of data available in the bit manipulator . In one embodiment, an interrupt is provided to the processor  every time a predefined amount of data in the line buffer  is used. In another embodiment, the predefined amount of data is user selectable by programming a register of register set  to indicate an interrupt should be generated every time a specific number of data has been read from the line buffer . For example, a register can be programmed to monitor 8-bits, 16-bits, 32-bits, 64-bits, or 128-bits of data has been used. In another embodiment, a total number of current bytes of data stored in the line buffer is maintained in a register of the register set .","By providing a way for the processor  to monitor the amount of data available in the line buffer, it is possible for the processor  to issue memory access requests to the memory controller , thereby assuring data is maintained in the bit manipulator. Also, by providing a way for the processor  to monitor the amount of data available in the line buffer, it is possible for the processor  to make sure data is available for cache storage before a request for data is issued to the bit manipulator . This allows the processor  to delay a data request to the bit manipulator  unless it is assured that reads to the bit manipulator will not stall a data access request that is to be cached.",{"@attributes":{"id":"p-0127","num":"0126"},"figref":["FIG. 21","FIG. 20"],"b":["930","910"]},"The register set includes a plurality of registers, including a top register and a base register which specify an address range in which the line buffer storage locations reside. A tail register pointer to a next valid line of the line buffer where data is to be accessed. Note that the pointers may indicate an actual line of the line buffer where data is to be accessed, or a line of the line buffer that is offset from the actual line buffer line where the data is to be accessed. The head register points to a next available line of the line buffer where valid data is to be stored.","A bit offset register indicates an offset to the first bit of the next set of bits to accessed. For example,  indicates the bit offset pointer pointing to bit . A bit indicated by the bit offset value will be the bit left justified by the bit manipulator output. Note, in an alternate embodiment, the bits returned could be right justified.","A watermark register stores a value that indicates when additional data needs to be loaded into the line buffer. The watermark value can indicate an offset from the tail or head pointer that is compared to the head or tail pointer respectively to determine when data is to be accessed. Alternatively, the watermark value can indicate a fixed location that is compared to the location of the tail pointer to determine when data is to be accessed. Various embodiments use the watermark to initiate a process of interrupting processor , or allowing processor  to read the watermark and other registers to determine when additional data is to be loaded into the bit manipulator.","As previously discussed, the line buffer count register can store a value indicating the amount of valid data associated with the line buffer. For example, the line buffer count register can indicate the number of bytes stored in the line buffer  that are yet to be accessed.",{"@attributes":{"id":"p-0132","num":"0131"},"figref":"FIG. 22","b":["335","955","330","330","950","955","955","950","950"]},{"@attributes":{"id":"p-0133","num":"0132"},"figref":"FIG. 23"},"The bit shifter  aligns the bit values stored in location , based upon the bit offset, so that left most bits of data output by the bit shifter  are those specified by the bit offset value. The mask  zero-fills or one-fills the bits not specifically requested by a data request. For example, in one embodiment, if three bits of data are requested they will be left justified while the mask will zero-fill the right-most 13 bits.","In one embodiment of the present invention, accesses to the bit manipulator  are in response to a GET_BIT(X) function where X specifies a number of bits to be returned. Instead of using internal registers and processor operations, the processor  accesses a specific address location corresponding to a register of the bit manipulator . For example, 16 specific address locations (registers) can be used to implement sixteen commands GET_BIT(1) through GET_BIT(16), where the bit manipulator  returns the requested amount of data and updates the registers appropriately, including the bit offset value, which is incremented by the amount of the data read. In another embodiment, additional commands can be provided to the bit manipulator that accesses a specific number of bits but do not increment the bit offset register or the tail register. For example, in one embodiment an entire word of data can be accessed without incrementing the tail register.","In the previously described embodiments, the data instruction packets have been used to send macroblock data to the transcoder . For example, the source macroblock information data can be received at the transcoder  as part of the DIPs. Referring to , it is illustrated that the video data (i.e. source motion vectors and quantization information), which is part of media data stream , is received at the device , and stored in device memory  ready for further processing. Next, the system  retrieves the stored data, including the source motion vectors, and generates DIPs to be used by the transcoder . In one embodiment DIPs are received at the transcoder  to control the operation of decoding and encoding functions. In one embodiment, a first DIP contains the source macroblock information used by the decoder, to generate the source pixel data, and a second DIP contains the source information used by the encoder to allow for motion vector prediction to be performed as described in pending patent application entitled \u201cDevice and Method for Compression of a Video Stream\u201d, Filed on Mar. 27, 2001, and having application Ser. No. 09\/819,147, which is herby incorporated herein by reference. When the motion vectors and quantization information are transmitted as part of the DIPs the macroblock information data for a specific macroblock can be transferred between the memory controller  and the device memory  up to seven a times. First, when macroblock information data is originally received, second, when retrieved to assemble the decoder DIP, third, when retrieved to assemble the encoder DIP, fourth, when storing the decoder DIP, fifth, when storing the encoder DIP, sixth, when the decoder DIP is accessed to the decoder, and seventh when the encoder DIP is accessed by the encoder. An alternate embodiment of the present disclosure is discussed herein that reduces the number of times the macroblock information would be transmitted between the memory controller  and the device memory , thereby reducing the amount of memory bandwidth. Such an alternate embodiment for improving the memory bandwidth utilization is described in .",{"@attributes":{"id":"p-0137","num":"0136"},"figref":["FIG. 24","FIG. 24","FIGS. 3","FIG. 25","FIG. 26","FIG. 24"],"b":["25","27"]},"At step , of the method illustrated in , source video information is received. With reference to , the source video information is part of the media data stream . In one embodiment, the source video information contains macroblock information, such as is associated with MPEG-type information.  illustrates a source frame drawn, using light solid lines, having a plurality of macroblocks forming an X\u00d7Y array, where X is a number representing a specific macroblocks, and Y is a number representing a specific row of macroblocks. For example, source macroblock (1,2), also referred to as SMB(1,2), is the source macroblock that resides in both column  and row  of the source frame.","At step , the source video information is stored. With respect to the specific embodiment herein, the disclosure will focus on the macroblock information portions of the source video information.  illustrates a memory map whereby a source data array has been saved, whereby. In one embodiment, each node within the source data array includes specific macroblock configuration data (MBCONFIG) for a corresponding macroblock, as well as the macroblock information associated with the specific macroblock. With reference to , the source video information can be stored in memory . The macroblock configuration data stored in the MBCONFIG field includes various information pertaining to a specific macroblock. For example, the MBCONFIG field can indicate whether or not a motion compensation operation will be processed using a forward prediction, backward prediction, or both forward and backward prediction. In addition, the MBCONFIG field can store data indicating whether or not a first or second least significant bit of a motion vector identifies half pixel information to be used, a value for a pitch indicator can be included to indicate how to access the next node in the source motion vector array, as well as any other types of information which may be relevant or useful to pass along for subsequent purposes of decoding or encoding the received source video.","At step  a destination picture information is received. Generally, the destination picture information includes resolution information for the destination picture.  illustrates a destination frame, see bold dashed lines superimposed over the source frame. The destination frame has a plurality of macroblocks arranged in an M\u00d7N array, where M is a number representing a column of macroblocks in the destination frame, and N is a number representing a row of macroblocks in the destination frame. For example, destination macroblock (1,2), or DMB(1,2)), is the destination macroblock that resides in both column  and row  of the destination frame.","At step , an index table is created based upon the destination picture information and the source picture information. Specifically, it can be determined which source macroblocks need to be access to generate each destination macroblock. For example, when the destination picture is to be downscaled relative to the source picture, as illustrated in , multiple macroblocks from the source frame contain information needed by the decoder to generate each destination macroblock. For example, in order to generate the destination macroblock (0,0), which is the upper left destination macroblock of the array of , the decoder\/encoder will need source macroblock information for source macroblocks:","SMB(0,0), SMB(0,1), SMB(1,0), and SMB(1,1). These four source macroblocks are needed because the destination macroblock contains at least some data from each of these macroblocks.","Based on the source and destination image resolution information, the index table is generated having a plurality of entries, each entry having a pointer to a macro block's source motion vector and quantization information previously stored at step . The entries in the index table are arranged relative to the other index table entries such that when the index table is accessed in a predefined manner, for example from the first entry to the last entry, the pointers within the entries can be used to access the source motion vectors, stored at step , in the order needed by the decoder and encoder to generate destination macroblock information.","The index table created at step  is stored in memory. Referring to , a first macroblock info (comprising motion vector(s) and quantization information) index table includes POINTER  through POINTER LAST, where POINTER LAST indicates the last motion vector of a source macroblock that needs to be address in order to complete generation of a specific frame of video data. Referring to the embodiment of , it can  be seen that each destination macro needs data from four source macroblocks, therefore, the total number of entries in the index table  of  is M\u00d7N\u00d74.","Index table entries, in addition to containing a pointer to a specific source node, include a field for indicating a last source macroblock associated with a specific destination macroblock to be generated. This last source macroblock indicator can be utilized by the decoder, or the encoder, determine when enough source data has been received to generate a destination macro lock.",{"@attributes":{"id":"p-0146","num":"0145"},"figref":["FIG. 27","FIG. 27"]},"In one embodiment, entry location  corresponds to the first entry of the source data array illustrated in , and contains POINTER . It will be noted that a specific source macroblocks generally be referenced by more than one entry of the index table. For example, in , entry  and entry  both reference source macroblock SMB(0,1). This is because the source macroblock SMB(0,1) contains data needed by both destination macroblocks DMB(0,0) and DMB(0,1).","At step , one or more data instruction packets are generated that reference an entry of the index table. Generally, this DIP will reference the first entry of an index table which is used by the decoder and encoder to access the data and generate destination macroblocks. Note, that if multiple destination targets exist, additional index tables can be generated and stored. By storing macroblock information data a single time, and generating index tables through which the decoder and encoder can access the vectors in a specific order, the memory bandwidth is reduced over the embodiment where the memory must save two sets of DIPs for each destination picture being generated.",{"@attributes":{"id":"p-0149","num":"0148"},"figref":"FIG. 28","b":"1050"},"At step , a plurality of source macroblock information is accessed in the first order based upon the order of the first index table entries. Referring to , the first plurality of source macroblock information is accessed based upon the pointers values stored within the entries of INDEX TABLE 1. At step , specific image data is generated based on the data accessed at step . In one embodiment, a decoder generates the source pixel set using the accessed macroblock information. In another embodiment, an encoder portion of a transcoder generates an estimated motion vector based upon the data accessed at step . The generation of the pixel set and the estimated motion vector generally occurs real-time simultaneously with the generation of the source pixel set. Note that real-time simultaneous means that the two functions can occur simultaneously in time (at the exact same time) using separate processing modules to meet the real-time needs of system, or can occur sequentially using one or more processing modules, whereby the processing module(s) perform the two functions fast enough to accommodate real-time requirements of an application that depends on the completion both results.","For example, real-time simultaneous for a video application means that the source pixels from the decoder and the estimated motion vector from the encoder are generated fast enough to be used in the generation of destination macroblocks a desired a frame display rate. For example, a specific real-time display rate may be 20, 30, or 60 times per second.","Steps , , and  are analogous to steps , , and  for a second destination system. For example, two monitors can receive representation of a source image. It will be appreciated that in accordance with this specific embodiment, that only one copy of the additional source data, i.e. source macroblock information, is stored in memory to support one or more destination images.","It should be noted, that the index table will generally be static for a given picture because the scaling between a source pictures and a destination pictures changes relatively infrequently. By using fixed size nodes to store the source data, each macroblock of a new source frame can be saved in the same the macroblock footprint as the previous set of macroblocks, thus allowing the same index table to be used to access macroblock data for multiple frames without being changed.",{"@attributes":{"id":"p-0154","num":"0153"},"figref":["FIG. 29","FIG. 26"],"b":["1102","1102","1102","330"]},"The controller  interfaces with memory controller  which interfaces with a memory  to store this data. In addition, the controller  acquires information from the video source to determine a size of the source video image received. The size of the source indicates the resolution and\/or the number of macroblocks used to represent each source frame. The source image size is stored at a block , which can be a memory location, such as a register or a portion of memory . In addition, destination image sizes are stored in blocks  for a first destination image size, and in block  for a second destination image size. The destination image sizes indicate the resolution of a desired output picture to be generated by the encoder . For purposes of discussion, only the first destination image size stored in block  will be referenced. In addition, it will be appreciated that more that two destination image size portions can be included if it is desirable to generate more than two destination images. In one embodiment, controller  corresponds to memory controller  as illustrated in . Likewise, memory  corresponds to device memory  in a specific embodiment.","An index table generator  receives or otherwise accesses the source size stored in  and the destination size stored in . Based upon the source and destination sizes, the index table generator will generate an index table having a format as previously discussed. The memory controller  coordinates the storage of the index table generated by the generator  to the memory . In one embodiment, index table generator  can be implemented by processor  by executing code in software or firmware.","Encoder  subsequently uses the memory controller  to retrieve the source macroblock information stored at the memory  by referencing pointers of the specific entries within the index table. In a similar manner, the decoder can also access the source macroblock information stored at the memory . Note, that the encoder and decoder can be designed to allow for a common read to the memory , to obtain a specific motion vector. Also, the encoder and decoder can share a common cache to reduce activity on the memory bus. In one embodiment, the encoder  can be implemented by a portion of the compression block  (), and the decoder  can be implemented by a portion of the decompression block .","In the preceding detailed description of the figures, reference has been made to the accompanying drawings which form a part thereof, and in which is shown by way of illustration specific preferred embodiments in which the invention may be practiced. These embodiments are described in sufficient detail to enable those skilled in the art to practice the invention, and it is to be understood that other embodiments may be utilized and that logical, mechanical, chemical and electrical changes may be made without departing from the spirit or scope of the invention. To avoid detail not necessary to enable those skilled in the art to practice the invention, the description may omit certain information known to those skilled in the art. Furthermore, many other varied embodiments that incorporate the teachings of the invention may be easily constructed by those skilled in the art. Accordingly, the present invention is not intended to be limited to the specific form set forth herein, but on the contrary, it is intended to cover such alternatives, modifications, and equivalents, as can be reasonably included within the spirit and scope of the invention. The preceding detailed description is, therefore, not to be taken in a limiting sense, and the scope of the present invention is defined only by the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 8","FIG. 3"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 9","FIG. 3"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIGS. 15-19"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 27","FIG. 26"]},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 29"}]},"DETDESC":[{},{}]}
