---
title: Remote scoring and aggregating similarity search engine for use with relational databases
abstract: A system and method for defining a schema and sending a query to a similarity search engine to determine a quantitative assessment of the similarity of attributes between an anchor record and one or more target records. The similarity search engine makes a similarity assessment in a single pass through the target records having multiple relationship characteristics. The similarity search engine is a server configuration that communicates with one or more database management systems for providing data persistence, data retrieval and access to user defined functions. The architecture enables search activities to be segmented among multiple remote database management systems for reducing the time required to perform searches. Implementation provisions include a method by which a secure transport driver may be configured for a datasource and a method by which configuration files may be persisted to either filesystem storage or a relational database.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07386554&OS=07386554&RS=07386554
owner: Infoglide Software Corporation
number: 07386554
owner_city: Austin
owner_country: US
publication_date: 20030902
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application is a continuation-in-part of U.S. Provisional Application 60\/407,755 filed on Sep. 3, 2002, and is a continuation-in-part of U.S. application Ser. No. 10\/618,840 filed on Jul. 14, 2003.","The invention relates generally to the field of search engines for use with large enterprise databases. More particularly, the present invention is a similarity search engine that, when combined with one or more relational databases, gives users a powerful set of standard database tools as well as a rich collection of proprietary similarity measurement processes that enable similarity determinations between an anchor record and target database records.","Information resources often contain large amounts of information that may be useful only if there exists the capability to segment the information into manageable and meaningful packets. Database technology provides adequate means for identifying and exactly matching disparate data records to provide a binary output indicative of a match. However, in many cases, users wish to determine a quantitative measure of similarity between an anchor record and target database records based on a broadly defined search criteria. This is particularly true in the case where the target records may be incomplete, contain errors, or are inaccurate. It is also sometimes useful to be able to narrow the number of possibilities for producing irrelevant matches reported by database searching programs. Traditional search methods that make use of exact, partial and range retrieval paradigms do not satisfy the content-based retrieval requirements of many users. This has led to the development of similarity search engines.","Similarity search engines have been developed to satisfy the requirement for a content-based search capability that is able to provide a quantitative assessment of the similarity between an anchor record and multiple target records. The basis for many of these similarity search engines is a comparison of an anchor record band or string of data with target record bands or strings of data that are compared serially and in a sequential fashion. For example, an anchor record band may be compared with target record band #1, then target record band #2, etc., until a complete set of target record bands have been searched and a similarity score computed. The anchor record bands and each target record band contain attributes of a complete record band of a particular matter, such as an individual. For example, each record band may contain attributes comprising a named individual, address, social security number, driver's license number, and other information related to the named individual. As the anchor record band is compared with a target record band, the attributes within each record band are serially compared, such as name-name, address-address, number-number, etc. In this serial-sequential fashion, a complete set of target record bands are compared to an anchor record band to determine similarity with the anchor record band by computing similarity scores for each attribute within a record band and for each record band. Although it may be fast, there are a number of disadvantages to this \u201cband\u201d approach for determining a quantitative measure of similarity.","Using a \u201cband\u201d approach in determining similarity, if one attribute of a target record band becomes misaligned with the anchor record band, the remaining record comparisons may result in erroneous similarity scores, since each record attribute is determined relative to the previous record attribute. This becomes particularly troublesome when confronted with large enterprise databases that inevitably will produce an error, necessitating starting the scoring process anew. Another disadvantage of the \u201cband\u201d approach is that handling large relational databases containing multiple relationships may become quite cumbersome, slowing the scoring process. Furthermore, this approach often requires a multi-pass operation to fully process a large database. Oftentimes, these existing similarity search engines may only run under a single operating system.","There is a need for a similarity search engine that provides a system and method for determining a quantitative measure of similarity in a single pass between an anchor record and a set of multiple target records that have multiple relationship characteristics. It should be capable of operating under various operating systems in a multi-processing environment. It should have the capability to similarity search large enterprise databases without the requirement to start over again when an error is encountered. There is a need for a similarity search engine that provides remote scoring and aggregation within one or more data base management systems remote from a search manager for improved network performance, data base management system performance and overall similarity search engine performance. The connection between the similarity search engine and the remote database management systems should be secure. The similarity search engine should be able to employ persistent storage for data structures essential to operation.","The present invention of a Remote Scoring and Aggregating Similarity Search Engine (SSE) for use with one or more relational databases is a system and method for determining a quantitative assessment of the similarity between an anchor record and a set of one or more target records. It makes a similarity assessment in a single pass through the target records having multiple relationship characteristics. It is capable of running under various operating systems in a multi-processing environment and operates in an error-tolerant fashion with large enterprise databases. By providing remote scoring and aggregating within the databases, improved database, network and overall similarity search engine performance are achieved over prior SSE, including the parent provisional application 60\/356,812 of this continuation-in-part application. The U.S. Provisional Application 60\/356,812, filed on Feb. 14, 2002 in incorporated herein by reference.","The present invention comprises a set of robust, multi-threaded components that provide a system and method for similarity scoring, aggregating and ranking attributes of database documents defined by Extensible Markup Language (XML) documents. This search engine uses a unique command syntax known as the XML Command Language (XCL). At the individual attribute level, similarity is quantified as a score having a value of between 0.00 and 1.00 that results from the comparison of an anchor value (search criterion) vs. a target value (database field) using a distance function. At the document or record level, which comprises one or more attributes, similarity is value normalized to a score value of between 0.00 and 1.00 for the document or record. The example of Table 1 illustrates the interrelationships between attributes, anchor values, target values, distance functions and scores.",{"@attributes":{"id":"p-0010","num":"0009"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":[{},"ANCHOR","TARGET","DISTANCE",{}]},{"entry":["ATTRIBUTE","VALUE","VALUE","FUNCTION","SCORE"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Name","John","Jon","StringDifference","0.75"]},{"entry":["City","Austin","Round Rock","GeoDistance","0.95"]},{"entry":["Shirt Color","Navy","Dark Blue","SynonymCompare","1.00"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}}},"br":{}},"This Similarity Search Engine (SSE) architecture is a server configuration comprising a Gateway, a Virtual Document Manager (VDM), a Search Manager (SM) and one or more SQL Databases. The SSE server may serve one or more clients. The Gateway provides command and response routing as well as user management. It accepts commands from the client and routes those commands to either the VDM or the SM. The purpose of the VDM is XML document generation, and the purpose of the SM is generating Structured Query Language (SQL) request from client queries and managing the search processes. The Database Management System (DBMS) performs document searching, document attribute scoring and document score aggregation. The VDM and the SM each receive commands from the Gateway and in turn make calls to the SQL Database. The SQL Database provides data persistence, data retrieval and access to User Defined Functions (UDFs). The Gateway, VDM and SM are specializations of a unique generic architecture referred to as the XML Command Framework (XCF), which handles the details of threading, distribution, communication, resource management and general command handling.","There are several system objects that the SSE relies on extensively for its operation. These include a Datasource object, a Schema object, a Query object and a Measure object. A Datasource object is a logical connection to a data store, such as a relational database, and it manages the physical connection to the data store. A Schema object, central to SSE operation, is a structural definition of a document with additional markup to provide database mapping and similarity definitions. A Query object is a command that dictates which elements of a database underlying a Schema object should be searched, their search criteria, the similarity measures to be used and which results should be considered in the final output. A Measure object is a function that operates on two strings and returns a similarity score indicative of the degree of similarity between the two strings. These Measure objects are implemented as User Defined Functions (UDFs).","Significant improvements in search performance may be achieved by constructing UDFs for implementation in the SQL databases that provide remote document scoring and aggregation within the SQL databases. Previous systems issued an SQL command to the DBMS for each comparison of document attributes involved in a search. Thus, a search with 10 attribute anchor values resulted in 10 database transactions, each requiring the DBMS to schedule the request, parse the SQL, invoke appropriate UDFs to score the comparison, prepare a result set, and return the results to the SSE. The SSE would then aggregate the results of the individual attribute comparison requests in order to \u201croll up\u201d the overall score for the document. This approach had adverse effects on the performance of the SSE server, the DBMS, and the network. Remote scoring and aggregation minimizes these adverse effects.","Prior SSE servers are limited in its capacity to service clients because of the volume of database requests it must launch and manage. Each client transaction resulted in multiple database requests and responses between an SSE server and a DBMS, which can soon become saturated to the point that new requests must wait for others to complete before the SSE server has capacity to handle them. And since the prior SSE servers must wait for the results of all the database requests before they can score the document, search latency is impacted by any delay at the DBMS. Finally, the prior SSE servers are further burdened by the need to perform a multistage \u201croll up\u201d, where results for the various anchor values are aggregated in a hierarchical fashion to yield scores for each group and the scores for child groups are aggregated to yield scores for the entire document.","Regarding the impact on the SSE server, the present invention relocates the \u201croll up\u201d to the DBMS from the SSE server. By the SSE server passing the DBMS an SQL command that returns the similarity score for each qualified document, the number of database transactions per search drops from one per anchor value to one overall. This can greatly reduce the transaction overhead on the part of the SSE server, simplify the launching and tracking of requests, and eliminate the need for SSE server to get involved in aggregation of scores. The result is a substantial increase in the capacity of the SSE server to process client requests. Depending on the choice of DBMS and SSE server components, the performance gain resulting from this novel configuration may be in the 30-60% range.","A second impact of the use of remote scoring and aggregation is a significant reduction in the volume of network traffic between the SSE server and the DBMS. This is accompanied by a reduction in the \u201cburst\u201d nature of the interaction, which has resulted in undesirable peaks and valleys in demands for network capacity.","To process a single search request with prior SSEs, an SQL statement is issued for each attribute anchor value specified by the client. Each of these requires an SQL packet to be prepared by the SSE server, transferred to the DBMS, and placed on the DBMS request queue. For a typical multi-attribute search involving 7-10 anchor values, this means 7-10 SQL requests soon followed by 7-10 responses. With each search instigating 14-20 network transactions, there soon comes a point when the volume of search traffic has an adverse impact on the network. The problem is exacerbated by the tendency of the SSE server to launch requests 7-10 at a time. Even more serious is the network impact of the result sets, which may contain a record for every record in the database that is searched. However, these are all needed by prior SSE servers, which have to collect all the results before it can begin the process of scoring and aggregating.","In the present invention where the scoring and aggregation are relocated to the DBMS, network traffic for SSE server becomes more manageable. Since only one SQL statement is needed, the request-handling overhead on both the SSE server and the DBMS is greatly reduced. The SSE server no longer has to inventory responses or hold some results for a client request while waiting for others to arrive. Another important consequence of the shift to remote scoring and aggregation is the smoothing of the network load, since each search requires only a single request and response. The result set for the present invention is about the same size as for prior systems, but only one is returned per search. Furthermore, since all the results are merged at the DBMS, it becomes possible to order the result set within the DBMS such that the highest scoring documents arrive first at the SSE server. With this new arrangement, the SSE server may obtain the scores it needs from just the first records in the result set, allowing it to skip the rest of the results and complete the operation sooner.","Remote scoring and aggregation can improve DBMS performance in several ways. In the present invention, the DBMS has only one SQL statement to queue, parse, strategize, etc. Depending on the DBMS, there is some additional execution performance to be gained by virtue of submitting one complex SQL statement, whose performance the DBMS may be able to optimize, rather than a sequence of simpler SQL statements that would have to be executed independently. The additional work required for aggregation is minimized by the SSE's use of fully normalized weights in the SQL command. As a result, the DBMS has only to compute a straightforward weighted sum to produce the document-level score, avoiding the tree-wise \u201crollup\u201d required with prior SSEs.","A side-effect of locating the target database at a remote location is that complete search requests and results sets may be exposed to a network that is not itself secure. Therefore, the deployment of remote scoring and aggregation may require the establishment of a secure connection between the similarity search engine and the remote database management system.","Another deployment consideration is the capability to maintain critical configuration data structures in persistent storage. In some implementations, the XML configuration files employed by the similarity search engine were always stored in the local filesystem of the server hosting the similarity search engine. Though the local filesystem provided a basic persistence service, it could not provide update journaling, online backup, locking, and replication services on a par with database management systems. Therefore, the implementation of the remote scoring and aggregating similarity search engine is extended to include support for persistence drivers.","An embodiment of the present invention is a method for performing similarity searching by remote scoring and aggregating comprising the steps of persisting user defined functions and configuration files for a similarity search server in one or more remote database management systems, receiving a request by the similarity search server from one or more clients for initiating a similarity search, the request designating an anchor document and at least one search document, generating one or more commands from the client request, sending the one or more commands from the similarity search server to the one or more remote database management systems, executing the one or more commands in the one or more database management systems to determine normalized document similarity scores using the persisted user defined functions and configuration files, generating a search result from the similarity scores in the one or more database management systems; and sending the search result to the search server for transmittal to the one or more clients. The step of executing one or more commands may comprise identifying a persisted schema document for defining a structure of search terms, providing persisted target search values, and designating persisted measure, choice and weight algorithms to be used to determine normalized document similarity scores. The step of executing the one or more commands may further comprise using persisted user defined functions contained within libraries of the database management systems for implementing measure algorithms to determine attribute similarity scores, weighting functions and choice algorithms for determining normalized document similarity scores. The step of executing the one or more commands may further comprise computing attribute token similarity scores having values of between 0.00 and 1.00 for the corresponding leaf nodes of the anchor document and a search document using designated persisted measure algorithms, multiplying each token similarity score by a designated persisted weighting function, and aggregating the token similarity scores using designated persisted choice algorithms for determining a document similarity score having a normalized value of between 0.00 and 1.00 for the at least one search document. The step of generating a search result may further comprise designating a persisted structure to be used by a result dataset, and imposing persisted restrictions on the result dataset. The step of receiving a request may comprise designating measures that override persisted measures for determining attribute token similarity scores, designating choice algorithms that override persisted choice algorithms for aggregating token similarity scores into document similarity scores, and designating weights that override persisted weights to be applied to token similarity scores. The step of generating a search result may further comprise structuring the similarity scores by imposing restrictions on the similarity scores according to a designated persisted user defined function. The step of imposing restrictions may be selected from the group consisting of defining a range of similarity scores to be selected and defining a range of percentiles of similarity scores to be selected. The step of generating a search result may further comprise sorting the similarity scores according to a designated persisted user defined function. The step of generating a search result may further comprise grouping the similarity scores according to a designated persisted user defined function. The step of generating a search result may further comprise executing statistics commands according to a designated persisted user defined function. The step of executing the one or more commands to determine normalized document similarity scores may further comprise computing a normalized similarity score having a value of between 0.00 and 1.00, whereby a normalized similarity indicia value of 0.00 represents no similarity matching, a value of 1.00 represents exact similarity matching, and values between 0.00 and 1.00 represent degrees of similarity matching. The step of sending the one or more commands may further comprise invoking an instance of a datasource object for implementing an interface for the datasource, the datasource object comprising a name, a uniform resource locator, a username, a password and a protocol driver designation. The protocol driver designation may be a Secure Sockets Layer. The method may further comprise the step of establishing a secure connection between the similarity search server and the one or more remote database management systems. The step of persisting configuration files for a similarity search server may comprise persisting configuration files for a gateway, a virtual document manager and a search manager. The step of persisting configuration files for the gateway may comprise persisting a username value, a template value and datasource driver. The step of persisting configuration files for the virtual document manager may comprise persisting a datatype value, a datasource value, a schema value, and a datasource driver. The step of persisting configuration files for the search manager may comprise persisting a measure value, a choice value, a parser value, a datasource value, a schema value, a statistic value, and a datasource driver. The step of executing the one or more commands in the one or more database management systems may comprise executing one coalesced search command to generate all similarity scores of multiple search documents for maximizing the processing once records have been loaded into memory and minimizing the number of disk accesses required. The step of executing the one or more commands in the one or more database management systems may comprise executing commands in multiple database management systems for increased performance, each database management system containing a partition of a total target database to be searched. The method may further comprise the step of horizontally partitioning the total target database to be searched among the multiple database management systems. The method may further comprise the step of vertically partitioning the total target database to be searched among the multiple database management systems. The method may further comprise the step of horizontally and vertically partitioning the total target database to be searched among the multiple database management systems. The method of may further comprise the step of selecting user defined functions for measure algorithms from the group consisting of name equivalents, foreign name equivalents, textual, sound coding, string difference, numeric, numbered difference, ranges, numeric combinations, range combinations, fuzzy, date oriented, date to range, date difference, and date combination. The method may further comprise the step of selecting user defined functions for choice algorithms from the group consisting of single best, greedy sum, overall sum, greedy minimum, overall minimum, and overall maximum. An embodiment of the present invention is a computer-readable medium containing instructions for controlling a computer system to implement the method described above.","Another embodiment of the present invention is a system for performing similarity searching by remote scoring and aggregating comprising means for persisting user defined functions and configuration files for a similarity search server in one or more remote database management systems, means for receiving a request by the similarity search server from one or more clients for initiating a similarity search, the request designating an anchor document and at least one search document, means for generating one or more commands from the client request, means for sending the one or more commands from the similarity search server to the one or more remote database management systems, means for executing the one or more commands in the one or more database management systems to determine normalized document similarity scores using the persisted user defined functions and configuration files, means for generating a search result from the similarity scores in the one or more database management systems, and means for sending the search result to the search server for transmittal to the one or more clients. The means for receiving a request by the similarity search server may be a gateway connected to a client network, the gateway also connecting to a search manager and a virtual document manager. The means for generating one or more commands by the similarity search server may be a search manager connected between a gateway and a database network interface. The means for sending the one or more commands from the similarity search server to one or more remote database management systems may be a database network interface connected to a secure database network, the secure database network connecting to the database management systems. The means for executing the one or more commands may be the remote database management systems, the remote database management systems including a library of user defined functions. The means for sending the search results may be the remote database management systems connected to a secure database network, the secure database network connecting to a database network interface of the similarity search server. The configuration files for the similarity search server may comprise configuration files for the gateway, the virtual document manager and the search manager. The means for persisting user defined functions and configuration files may comprise file system persistence drivers and database persistence drivers. The means for sending the one or more commands and the means for sending the search results may be a persistence driver based on a Secure Sockets Layer protocol. The means for executing the one or more commands in the one or more remote database management systems may comprise one coalesced SQL search command to generate all similarity scores of multiple search documents for maximizing the processing once records have been loaded into memory and minimizing the number of disk accesses required. The means for executing the one or more commands may comprise means for executing commands in multiple remote database management systems for increased performance, each remote database management system containing a partition of a total target database to be searched. The system may further comprise means for horizontally partitioning the total target database to be searched among the multiple database management systems. The system may further comprise means for vertically partitioning the total target database to be searched among the multiple database management systems. The system may further comprise means for horizontally and vertically partitioning the total target database to be searched among the multiple database management systems. The user defined function for a measure algorithm may be selected from the group consisting of name equivalents, foreign name equivalents, textual, sound coding, string difference, numeric, numbered difference, ranges, numeric combinations, range combinations, fuzzy, date oriented, date to range, date difference, and date combination. The user defined function for a choice algorithm may be selected from the group consisting of single best, greedy sum, overall sum, greedy minimum, overall minimum, and overall maximum. The means for sending the one or more commands from the similarity search server to one or more remote database management systems may be via a secure database network connection, and the means for sending the search results to the search is via a secure database network connection.","Yet another embodiment of the present invention is a system for performing similarity searching by remote scoring and aggregating comprising user defined functions and configuration files for a similarity search server persisted in one or more remote database management systems, one or more clients communicating with a similarity search server for requesting a similarity search between an anchor document and at least one search document, the similarity search server processing the similarity search request and constructing one or more commands from the similarity search request, the similarity search server communicating with one or more remote database management systems for transmitting the one or more commands, the one or more remote database management systems executing the one or more commands to obtain a similarity search result, the one or more database management systems communicating with the similarity search server for transmitting the search result, and the similarity search server processing the similarity search result and communicating with the one or more clients for transmitting a similarity search response to the one or more clients. The system may further comprise a secure client network connection for transmitting a similarity search request and similarity search response between the one or more clients and the similarity search server. The system may further comprise a secure database network connection for transmitting the one or more commands and the search results between the one or more remote database management systems and the similarity search server.","Before describing the architecture of the Similarity Search Engine (SSE), it is useful to define and explain some of the objects used in the system.","The SSE employs a command language based on XML, the Extensible Markup Language. SSE commands are issued as XML documents and search results are returned as XML documents. The specification for Extensible Markup Language (XML) 1.0 (Second Edition), W3C Recommendation 6 Oct. 2000 is incorporated herein by reference. The syntax of the SSE Command Language XCL consists of XML elements, their values and attributes that control the behavior of the SSE. Using SSE commands, a client program can define and execute searches employing the SSE.","The SSE commands are shown here in abstract syntax notation using the following conventions:","Regular type Shows command words to be entered as shown (uppercase or lowercase)","Italics Stands for a value that may vary from command to command","XML tags are enclosed in angled brackets. Indentations are used to demark parent-child relationships. Tags that have special meaning for the SSE Command Language are shown in capital letters. Specific values are shown as-is, while variables are shown in italic type. The following briefly defines XML notation:",{"@attributes":{"id":"p-0070","num":"0069"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["<XXX>","Tag for XML element named XXX"]},{"entry":["<XXX =\u201c\u201d\/>","XML element named XXX with specified"]},{"entry":[{},{"i":["value ","attribute"]}]},{"entry":["<XXX><\/XXX>","XML element named XXX containing "]},{"entry":["<XXX>","XML element named XXX containing"]},{"entry":["<YYY><\/YYY>","element named YYY with the that"]},{"entry":["<\/XXX>","appears between the tags. In xpath notation,"]},{"entry":[{},"this structure would be written as XXX\/YYY"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"A datasource can be considered a logical connection to a data store, such as a relational database. The datasource object manages the physical connection to the data store internally. Although the SSE may support many different types of datasources, the preferred datasource used in the SSE is an SQL database, implemented by the vdm.RelationalDatasource class.","A relational datasource definition is made up of attributes, comprising Name, Driver, URL, Username and Password, as described in Table 2.",{"@attributes":{"id":"p-0073","num":"0072"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["ATTRIBUTE","PURPOSE"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Name","Within the context of an SSE, the name uniquely"]},{"entry":[{},"identifies this datasource"]},{"entry":["Driver","The actual class name of the JDBC driver used to"]},{"entry":[{},"connect to the relational data store"]},{"entry":["URL","The URL, as defined by the driver, used to locate"]},{"entry":[{},"the datasource on a network"]},{"entry":["Username","The username the SQL database requires for a login"]},{"entry":["Password","The password the SQL database requires for a login"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"A schema is at the heart of everything the SSE does. A schema is a structural definition of a document along with additional markup to provide SQL database mapping and similarity definitions. The definition of a schema comprises Name, Structure, Mapping and Semantics, as described in Table 3.",{"@attributes":{"id":"p-0075","num":"0074"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["ATTRIBUTE","PURPOSE"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Name","Within the context of an SSE, the name uniquely"]},{"entry":[{},"identifies this schema"]},{"entry":["Structure","The structure clause of a schema defines the XML output"]},{"entry":[{},"format of documents which are built based on this"]},{"entry":[{},"schema."]},{"entry":["Mapping","The mapping clause of a schema defines how each of the"]},{"entry":[{},"elements of the structure map to relational fields and"]},{"entry":[{},"tables as defined by the datasource"]},{"entry":["Semantics","The semantics clause of a schema defines the default"]},{"entry":[{},"similarity settings to be used when issuing a query"]},{"entry":[{},"against this schema\/datasource"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"A query is an XCL command that dictates which elements of a schema (actually the underlying database) should be searched, their search criteria, the similarity measures to be used and which results should be considered in the final output. The query format is sometimes referred to a Query By Example (QBE) because an \u201cexample\u201d of what we are looking for is provided in the query. Attributes of a query comprise Where clause, Semantics, and Restrict, as described in Table 4. An XCL query command may be translated into one or more SQL statements containing measures, which may be transmitted to an SQL Database.",{"@attributes":{"id":"p-0077","num":"0076"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["ATTRIBUTE","PURPOSE"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Where clause","The WHERE clause serves as the QBE portion of the"]},{"entry":[{},"query, this is what we are looking for."]},{"entry":["Semantics","The SEMANTICS clause of a query determines how"]},{"entry":[{},"we want to search the database. This includes:"]},{"entry":[{},"similarity functions to use to compare values"]},{"entry":[{},"weights of elements in the overall score"]},{"entry":[{},"how to combine the element scores into an overall score"]},{"entry":["Restrict","The RESTRICT clause of a query dictates which"]},{"entry":[{},"portions of the result we are interested in. E.g. those"]},{"entry":[{},"document that score 0.80 or greater, or the top"]},{"entry":[{},"20 documents etc.."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"A measure, in terms of implementation, is a function that takes in two strings and returns a score (from 0 to 1) of how similar the two strings are. These measures are implemented as User Defined Functions (UDFs) and are compiled into a native library in an SQL Database. Measures are made up of attributes comprising Name, Function and Flags, as described in Table 5.",{"@attributes":{"id":"p-0079","num":"0078"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["ATTRIBUTE","PURPOSE"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Name","Within the context of an SSE, the name uniquely"]},{"entry":[{},"identifies this measure"]},{"entry":["Function","The associated native measure implementation"]},{"entry":[{},"associated to this name. For example, a measure"]},{"entry":[{},"named \u201cString Difference\u201d may actually call"]},{"entry":[{},"the STDIFF( ) function"]},{"entry":["Flags","There are several other flags that indicated whether"]},{"entry":[{},"the function operates on character data, numeric"]},{"entry":[{},"data, date data etc. or a combination of them."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"As discussed above, the present invention is a system and method for using a relational Database Management System (DBMS) to compare an anchor value (or set of anchor values) against a set of target values in the database to determine a similarity score indicating how closely the values being compared are to being the same. This process of similarity scoring takes place in two main phases. First is the application of measures to determine the degree of similarity between each anchor value attribute and the corresponding target value attributes in the database. Second is the aggregation of these individual attribute scores to yield an overall similarity score for the document. Though many methods of aggregating scores are available, the present Similarity Search Engine (SSE) employs a weighted average such that each anchor value attribute has a weight that indicates its relative contribution to the score of its group or document, and each group has a weight that indicates its relative contribution to the score of its parent group or parent document. This treewise aggregation is performed \u201cbottom up\u201d according to the hierarchical structure of the document until a single score is produced for the uppermost \u201croot\u201d node of the hierarchy. This operation is sometimes called a \u201crollup\u201d.","Turning now to ,  depicts a high level architecture  of a prior art Similarity Search Engine (SSE) that makes use of the existing RDBMS infrastructure and the ability to extend built-in RDBMS functionality via the use of User Defined Functions (UDFs)  as similarity measures. The SSE architecture  includes Clients , a Client Network , a Gateway , a Virtual Document Manager (VDM) , a Search Manager (SM)  and an SQL Database . The Gateway , VDM , and SM  comprise an SSE Server . The Gateway  provides routing and user management from one or more Clients  via a Client Network . The Clients  initiate similarity searches by sending search requests to the Gateway  via the Client Network . After a similarity search has been completed, the Gateway  sends results of a requested similarity search back to the requesting Client  via the Client Network . The VDM  provides XML document generation. The SM  configures SQL requests to the SQL Database  and performs document aggregation and scoring. The SQL Database  provides data persistence and retrieval, document attribute scoring, and storage of User Defined Functions (UDFs). One of the functions of the UDFs is to provide document attribute scoring within the SQL Database . In , the SM  receives individual attribute similarity scores from the SQL Database  and performs document scoring and aggregation itself. Because of the high volume of requests for attribute scores required in a typical similarity search, the ability of the SSE shown in  to access remote databases is constrained by the resulting high level of network traffic required between the SM  and the SQL Database , as well as the processing capability of the SM  and the SQL Database.","Turning now to ,  depicts a high level architecture  of a Similarity Search Engine (SSE) that makes use of the existing RDBMS infrastructure and the ability to extend built-in RDBMS functionality via the use of User Defined Functions (UDFs)  as similarity measures to remote databases. The SSE architecture  includes Clients , a Client Network , a Gateway , a Virtual Document Manager (VDM) , the Search Manager (SM) , a Database Network  and one or more remote SQL Databases . The Gateway , VDM , SM , and Database Network Interface  comprise an SSE Server . The Gateway  provides routing and user management from one or more Clients  via a Client Network . The Clients  initiate similarity searches by sending search requests to the Gateway  via the Client Network . After a similarity search has been completed, the Gateway  sends results of a requested similarity search back to the requesting Client  via the Client Network . The VDM  provides XML document generation. The SM  constructs Structured Query Language (SQL) statements for transmittal to the SQL Databases  via the Database Network Interface  and a Database Network . The SQL Databases  provides data persistence and retrieval, document attribute scoring, document aggregation and scoring, and storage of User Defined Functions (UDFs) . One of the functions of the UDFs is to provide document attribute scoring within the SQL Databases . An advantage of multiple SQL Databases  is that they provide the capability to partition the target database among several SQL Databases , which enable simultaneous or parallel processing of similarity searches using UDFs . In , the SQL Databases  perform both individual attribute similarity scoring and aggregation, as well as coalescing searches for greater efficiency. The features introduced and discussed relative to  is the relocation of the second phase of scoring from the SM  to the SQL Databases , so that where the SM  shown in  received individual attribute similarity scores from the SQL Database  and performed the document scoring and aggregation itself, the system shown in  allows the SQL Databases  to perform the document scoring and aggregation and the SM  receives just the document-level similarity scores. Because of the high volume of requests for attribute scores required in a typical similarity search, the ability of the SSE shown in  to access remote databases is constrained by the resulting high level of network traffic required between the SM  and the SQL Database . The ability to search remote databases is an important feature of the system shown in . It allows searching any database of any size located anywhere without moving the data. Once the data and document scoring are separated from the search server, as shown in , communication between the database and the search server is minimized. This enables the use of database table partitioning to achieve further improvements the stability, scalability, and performance of similarity search.","The Gateway  serves as a central point of contact for all client communication by responding to commands sent by one or more clients. The Gateway  supports a plurality of communication protocols with a user interface, including sockets, HTTP, and JMS. The Gateway  is implemented as a class available in the unique generic architecture referred to as the XML Command Framework (XCF), which handles the details of threading, distribution, communication, resource management and general command handling. A user may be added to a user definition file in order to log on and log off of the SSE.","The Gateway  includes several instances of command handlers inherited from the generic XCF architecture to properly route incoming XML Command Language (XCL) commands to an appropriate target, whether it is the VDM , the SM , or both. These command handlers used by the Gateway  for routing are shown in Table 6.",{"@attributes":{"id":"p-0085","num":"0084"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 6"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["COMMAND",{}]},{"entry":["HANDLER","FUNCTIONALITY"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["xcf.commands.SynchronizedPassthrough","Passes an XCL command"]},{"entry":["(SPT)","through to one or more"]},{"entry":[{},"targets, one after the other. If"]},{"entry":[{},"one of the commands passed"]},{"entry":[{},"through fails, the command"]},{"entry":[{},"handler reports the failure"]},{"entry":[{},"and terminates execution."]},{"entry":["xcf.commands.Passthrough","Passes an XCL command to"]},{"entry":["(PT)","one target. The target must"]},{"entry":[{},"determine and report success"]},{"entry":[{},"or failure."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Table 7 shows the routing of commands types processed by the Gateway , and which command handler is relied upon for the command execution.",{"@attributes":{"id":"p-0087","num":"0086"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 7"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["COMMAND","COMMAND",{},"COMMAND"]},{"entry":["TYPE","OPERATION","ROUTING","HANDLER"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["SCHEMA","Write","VDM, SM","SPT"]},{"entry":["SCHEMA","Delete","VDM, SM","SPT"]},{"entry":["DATASOURCE","Write","VDM, SM","SPT"]},{"entry":["DATASOURCE","Delete","VDM, SM","SPT"]},{"entry":["DOCUMENT","Write","VDM, SM","SPT"]},{"entry":["DOCUMENT","Delete","VDM, SM","SPT"]},{"entry":["MEASURE","All","SM","PT"]},{"entry":["CHOICE","All","SM","PT"]},{"entry":["STATISTICS","All","SM","PT"]},{"entry":["QUERY","All","SM","PT"]},{"entry":["All others","\u2014","VDM","PT"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":["210","220","210","230"]},"The VDM  is responsible for XML document management, and connects between the Gateway  and the SQL Database . The VDM  is implemented by a class, which is available in the unique generic architecture referred to as the XML Command Framework (XCF), which handles the details of threading, distribution, communication, resource management and general command handling. The XCF is discussed below in more detail. Therefore, the VDM  inherits all the default command handling and communication functions available in all XCF Command Servers. Unlike XML databases having proprietary storage and search formats, the VDM  uses existing relational tables and fields to provide dynamic XML generation capabilities without storing the XML documents.","The VDM  provides its document management capabilities through Document Providers. A Document Provider is responsible for generating and storing XML documents based on a schema definition. Although described embodiments of the SSE server only implement one DocProvider, which is an SQL based document provider, if the DocProvider implements the interface, the document provider can be any source that generates an XML document. For example, document providers may be file systems, web sites, proprietary file formats, or XML databases. For a user to retrieve relational data, the user must know where the data resides and how it is connected. A datasource definition and its implementation provide an object that encapsulates all the connection information.","There are several types of command handlers required by the VDM  in order to satisfactorily execute XCL commands. These include the document related command handlers shown in Table 8.",{"@attributes":{"id":"p-0091","num":"0090"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 8"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["COMMAND HANDLER","FUNCTIONALITY"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["vdm.commands.DocumentRead","Builds an XML document based on"]},{"entry":[{},"a schema, its mapping, and"]},{"entry":[{},"a primary key, by assembling"]},{"entry":[{},"from records and fields."]},{"entry":["vdm.commands.DocumentWrite","Writes an XML document based on"]},{"entry":[{},"a schema, its mapping, and"]},{"entry":[{},"a primary key, by disassembling"]},{"entry":[{},"into records and fields."]},{"entry":["vdm.commands.DocumentDelete","Deletes an XML document based on"]},{"entry":[{},"a schema, its mapping, and"]},{"entry":[{},"a primary key, by removing"]},{"entry":[{},"relevant records."]},{"entry":["vdm.commands.DocumentCount","Counts the number of unique"]},{"entry":[{},"documents for a particular"]},{"entry":[{},"schema."]},{"entry":["vdm.commands.DocumentLock","Locks a document based on its"]},{"entry":[{},"schema name and primary key."]},{"entry":[{},"Subsequent locks on this document"]},{"entry":[{},"will fail until it is unlocked."]},{"entry":["vdm.commands.DocumentUnlock","Unlocks a document based on"]},{"entry":[{},"its schema name and primary key."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":"220"},{"@attributes":{"id":"p-0092","num":"0091"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 9"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["COMMAND HANDLER","FUNCTIONALITY"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["vdm.commands.SchemaWrite","Initializes a DocProvider based on the"]},{"entry":[{},"schema and mapping defined for the"]},{"entry":[{},"schema."]},{"entry":["xcf.commands.ComponentRead","Provides a means to read a schema."]},{"entry":["vdm.commands.SchemaDelete","Uninitializes a DocProvider and drops it"]},{"entry":[{},"from the list of available schemas."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":"220"},{"@attributes":{"id":"p-0093","num":"0092"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 10"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["COMMAND HANDLER","FUNCTIONALITY"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["vdm.commands.DatasourceWrite","Creates and initializes the"]},{"entry":[{},"vdm.ConnectionInfo object that"]},{"entry":[{},"contains all relevant datasource"]},{"entry":[{},"information."]},{"entry":["vdm.commands.DatasourceDelete","Uninitializes a datasource"]},{"entry":[{},"and removes it from the list of"]},{"entry":[{},"available datasources."]},{"entry":["xcf.commands.ComponentRead","Provides a means to read a"]},{"entry":[{},"datasource."]},{"entry":["vdm.commands.DatasourceMetadata","Connects to the datasource"]},{"entry":[{},"and examines all the tables, field"]},{"entry":[{},"types and lengths, indices, view"]},{"entry":[{},"defined in the datasource so"]},{"entry":[{},"that the DocProvider may make"]},{"entry":[{},"informed decisions on how to"]},{"entry":[{},"best handle the data."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":["220","240","280"]},"Turning now to ,  depicts an example XML document, used by the VDM  shown in , which maps the relationships between the XML documents to be dealt with and relational databases. The map can specify that when building an XML document from the database, the data in claim\/claimant\/name should come from the claimants table of the database, while \/claim\/witness\/name should come from the Witnesses table. Conversely, when writing an existing XML document of this form out to the database, the map will tell the driver that it should write any data found at \/claim\/claimant\/name out to the claimants table, in this case to the \u201cname\u201d field, and write the data found at \/claim\/witness\/name out to the \u201cname\u201d field of the Witnesses table. Through describing these relationships, the map allows the VDM to read, write, and delete XML documents.","Turning to ,  shows a dataset having an XML form that represents relationships between XML documents and relational databases that is stored in a Java model called a Dataset.  represents the basic structure of a map file. At the beginning of initialization, the XML map is parsed and used to build a hierarchy of Datasets, one level of hierarchy for each database table referenced in the map. This encapsulation of the XML parsing into this one area minimizes the impact of syntax changes in the XML map. These Datasets have the XML form shown in .  depicts an example of a Dataset in XML form. The <EXPRESSION> tag indicates whether the Dataset describes a document based on a relational table or a document based on a SQL statement. If the expression value is \u201ctable,\u201d then initializing a relational driver with this Dataset will allow full read\/write functionality. However, if the expression value is \u201csql,\u201d then the initialized driver will allow documents to be generated from the database, but not to be written out to it. During initialization, SQL statements are created for select, insert, and delete functionality using the Dataset's <EXPRESSION> data. If the type attribute equals \u201ctable,\u201d then the statements are built using the table name and the field names.","Each Dataset has one to n <BIND> tags. In the common usage, in which the Dataset is describing a relational table, these bindings define the key fields used in the master-detail relationship. The topmost Dataset's binding simply describes its primary key. Since it has no relationship with any higher-level Dataset, its binding does not have the <MASTER> element that other Datasets' binds have. A Dataset's <PATH> tag describes where the data being read from the table should go in the overall final XML document, or vice-versa when writing XML out to the database.","Each Dataset will also have 1 to n <FIELDS>. These fields are the fields that are used to build the select and insert statements, and are any fields of interest contained within the table that the Dataset describes. Each of these fields contains a <TYPE> that describes the data type of the database's field (e.g., String, Int, Double), and <PATH> which describes the mapping of this XML leaf to the database field. When building an XML document, the path describes the database field that data is pulled from. In writing an XML document back to the database, this path is the target field that the leaf's data is to be written to. If the information being written out or read in lies in the attribute of the leaf, this can be specified by including a path to the leaf, and then the attribute name preceded by an @ (e.g. <PATH>Claim\/@dateEntered<\/PATH>). In the minimum, there will always be at least one Dataset for any given map. For expression of a multiple tables in a one-to-many relationship, the Dataset form allows for nesting of child Datasets within it. A Dataset can have zero through n child Datasets.","Composition of documents follows this basic algorithm shown in . A row is taken from the topmost array of arrays, the one representing the master table of the document. The portion of the XML document that takes information from that row is built. Next, if there is a master-detail relationship, the detail table is dealt with. All rows associated with the master row are selected, and XML structures built from their information. In this manner, iterating through all of the table arrays, the document is built. Then, the master array advances to the next row, and the process begins again. When it finishes, all of the documents will have been built, and they are returned in String form.","Turning back to , the SM  is responsible for SQL statement generation, and connects between the Gateway  and the SQL Databases  via the Database Network Interface  and the Database Network . The SM  is implemented as a class available in the unique generic architecture referred to as the XML Command Framework (XCF), which handles the details of threading, distribution, communication, resource management and general command handling. The XCF is discussed below in more detail. Therefore, the SM  inherits all the default command handling and communication functions available in all XCF Command Servers. The SM  does not maintain any of its own indexes, but uses a combination of relational indexes and User Defined Functions (UDFs)  to provide similarity-scoring methods in addition to traditional search techniques. A simple SQL command sent by the SM  is used to register a UDF  with an SQL Database .","There are several types of command handlers required by the SM  in order to satisfactorily execute XCL commands. These include the schema related command handlers shown in Table 11.",{"@attributes":{"id":"p-0101","num":"0100"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 11"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["COMMAND HANDLER","FUNCTIONALITY"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["search.commands.SchemaWrite","Stores a simple XML version"]},{"entry":[{},"of a schema."]},{"entry":["xcf.commands.ComponentRead","The default component reader"]},{"entry":[{},"provides a means to read a schema."]},{"entry":["vdm.commands.ComponentRemove","The default component deleter"]},{"entry":[{},"provides a means to"]},{"entry":[{},"delete a schema."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":"230"},{"@attributes":{"id":"p-0102","num":"0101"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 12"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["COMMAND HANDLER","FUNCTIONALITY"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["search.commands.DatasourceWrite","Creates and initializes the"]},{"entry":[{},"vdm.ConnectionInfo object that"]},{"entry":[{},"contains all relevant datasource"]},{"entry":[{},"connection information."]},{"entry":["vdm.commands.ComponentRemove","The default component deleter"]},{"entry":[{},"provides a means to"]},{"entry":[{},"delete a datasource."]},{"entry":["xcf.commands.ComponentRead","The default component reader"]},{"entry":[{},"provides a means to"]},{"entry":[{},"read a datasource."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":"230"},{"@attributes":{"id":"p-0103","num":"0102"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 13"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["COMMAND HANDLER","FUNCTIONALITY"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["search.commands.MeasureWrite","Stores a simple XML version"]},{"entry":[{},"of a measure"]},{"entry":["xcf.commands.ComponentRead","The default component reader"]},{"entry":[{},"provides a means to read"]},{"entry":[{},"a measure."]},{"entry":["vdm.commands.ComponentRemove","The default component deleter"]},{"entry":[{},"provides a means to delete"]},{"entry":[{},"a measure."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":"230"},{"@attributes":{"id":"p-0104","num":"0103"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 14"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["COMMAND HANDLER","FUNCTIONALITY"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["search.commands.ChoiceWrite","Stores a simple XML version"]},{"entry":[{},"of a choice."]},{"entry":["xcf.commands.ComponentRead","The default component reader"]},{"entry":[{},"provides a means to read a choice."]},{"entry":["vdm.commands.ComponentRemove","The default component deleter"]},{"entry":[{},"provides a means to delete"]},{"entry":[{},"a choice."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":["230","240","270","280"]},"Regarding the SQL Databases  shown in , the SQL Databases  are relational DataBase Management Systems (DBMS) that organize data into tables with rows and columns. Consider the example dataset of names shown in . Each row in the dataset refers to the name of a person and each column refers to an attribute of that name. In , a person's name is defined as NAME_FIRST, NAME_MIDDLE, NAME_LAST. The first, middle, and last name are not guaranteed to be unique as there may be many people that share that name combination. Therefore, the dataset introduces a column to uniquely identifying this \u201cperson\u201d by a number, referred to as PKEY, and the dataset guarantees that no two people share the same PKEY. This column is also known as a Primary Key.","Consider another example dataset of addresses shown in . Each row in the dataset of  refers to a person's address, which is made up of the three attributes ADDRESS, CITY, STATE. As in , a PKEY field is introduced to uniquely identify the \u201clocation\u201d to which this address belongs.","Structured Query Language (SQL) is a standard data manipulation language (DML). The following SQL statements could be issued to retrieve data from the datasets shown in  and :\n\n","and\n\n","Most DBMSs provide a set of built-in functions that programmers can use to manipulate the individual column values. For example LCASE and UCASE will change the case of a column. The following SQL statement would result in the dataset shown in .\n\n","In addition to the built-in functions, most DBMS vendors provide the opportunity for developers to build their own functions and register them with the database. These are known as User Defined Functions (UDFs). UDFs can be written in a programming language other that that defined by the DBMS. These languages may include C, C++, Java, and other compiled languages. Once these functions have been coded and compiled in their native format, they must be defined to the DBMS using the DBMS Data Definition Language (DDL). The DDL describes the following:\n\n","The use of remote scoring aggregation allows an SSE to interact with the DBMS at the document level rather than at an attribute level. This opens the possibility of using multiple DBMSs operating in parallel to further boost performance, scalability and reliability. Handling of large data sets presents a problem to any search that needs to perform a similarity comparison of every record in a database table. Since the UDFs are executed for every record and every attribute in the search database, as the database grows, performance can become a major issue. In general, as the search database size increases, the time it takes to search for each anchor document increases, although not linearly. As the table grows in size, the performance penalty increases. The solution is to split the table into smaller blocks and assign each block to a different database instance, preferably located in different hardware. This allows each DBMS to manage and search a smaller dataset, improving search performance as well as data scalability. The data can be subdivided in several ways: horizontal partitioning, vertical partitioning, or a combination of both.","Turning to ,  shows horizontal partitioning that groups the data by records (rows) such that a large dataset (1 million records)  is separated into N smaller datasets  (1M\/N records each) that can be assigned to N separate search databases , each with its own set of UDFs and hardware. As in , the Databases  are connected via a Network  to an SSE Server , which in turn connects to Clients  via a Network . Horizontal partitioning greatly improves search performance by allowing each small partition  to be searched in parallel, hence reducing the time by 1\/N, where N is the number of partitions. Each horizontal partition  can be scored independently, leaving it to the application to select and combine the results. Furthermore, it is possible to order the partition searches such that the overall search can stop when any one of the partition searches meets the search criteria.","Turning now to ,  shows vertical partitioning that groups the data by attributes (columns). In this case, a large attribute set  is grouped by a logical set of attributes  (primary, secondary, etc.) and assigned to different SSE search databases . As in , the Databases  are connected via a Network  to an SSE Server , which in turn connects to Clients  via a Network . Vertical partitioning groups the data by attributes. The most important attributes can be given their own table and scored first. The application can then examine the results to determine which other attributes need to be scored. If a document scores high enough in the first search, the application may be able to determine that there is a match without having to incur the costs of the secondary search on the less important attributes. This can significantly improve performance where certain attributes (such as personal names) tend to dominate the overall scores.","Turning now to ,  shows a combination of horizontal and vertical partitioning, where a large dataset  is partitioned into smaller partitions  that are distributed geographically throughout the large dataset . Each of the smaller partitions  is connected to different search databases . As in , the Databases  are connected via a Network  to an SSE Server , which in turn connects to Clients  via a Network . The combination of both horizontal and vertical partitioning techniques take advantage of smaller and more efficient search datasets .","Scalability can also be achieved at the database level by allowing the DBMS to partition the data itself. This is a capability of certain enterprise level DBMS, i.e. DB2 UDF EEE. The search server deals with one search database and its UDFs. The DBMS manages the distributed computing at the backend. This improves the scalability but the search performance is unknown.","In order to provide the notion of similarity, a set of functions has been developed to calculate the \u201cdistance\u201d or \u201cdifference\/similarity\u201d of two values, returning a normalized floating point value (between 0 and 1 inclusive) that indicates the closeness or similarity of the two values. These are known as single attribute measures. For example,  shows several similarity functions that are related to name matching, including closeness of names, sounds and strings. Several functions for address matching are shown in , including closeness of street names, cities, and ZIP codes. The examples shown in  and  illustrate measuring two strings and returning a normalized score based on their similarity. These are simply examples yet the design allows for UDFs that support any combination of the DBMS datatypes. For example, some measures may deal with dates, numbers, CLOBs (character large objects), and BLOBs (binary large objects). With these functions registered as defined, the extended SQL may be used to provide a \u201csimilarity\u201d score\u201d of how close two records are. For example, the closest match to \u201cBRIAN BAILEY\u201d in the example list of names in the dataset NAMES shown in  may be determined by using the following SQL statement:\n\n","Turning to ,  shows the results of determining a match between people by including both name and address information in the query. For example, consider an anchor name and address such as:","BENJAMIN TOBEY living on 740 HUMMING BIRD LANE in KILLEN.",{"@attributes":{"id":"h-0005","num":"0000"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0119","num":"0000"},"ul":{"@attributes":{"id":"ul0011","list-style":"none"},"li":{"@attributes":{"id":"ul0011-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0012","list-style":"none"},"li":"select names.pkey,NAME_DIFF(name_first,\u2018BENJAMIN\u2019) AS s1,\n        \n        "}}}},"BENJAMIN MOBLEY living on 704 HUMMINGBIRD LANE in KILLEEN, which is a close match to the anchor search criteria of","BENJAMIN TOBEY living on 740 HUMMING BIRD LANE in KILLEN.","The examples above have illustrated UDFs that compare two values and return a floating-point similarity score. The present invention also allow for UDFs that take in multiple attributes and generates a score for all those attributes. Consider the following UDF DDL:\n\n","RETURNS FLOAT BY VALUE","ENTRY_POINT \u2018whole_name\u2019 MODULE_NAME \u2018MyFunctions\u2019;","This UDF compares both first and last names, then returns a score. Here the measure can understand the nuances between swapped first and last names and try several combinations to come up with the best score. The following is an example SQL statement that calls the UDF above, which invokes a similarity comparison based on the whole name:\n\n","A UDF can also be used to restrict the results based on a similarity score. For example, suppose a client wishes to return those records where the first name is \u201cpretty close to JOHN\u201d. Using the following SQL statement, the similarity UDF could be used to filter the returned records to meet the search criteria.\n\n","Consider the following SQL statement:\n\n","Similarity UDFs can be also used for sorting result sets. To sort a result set based on the person's last_name as compared to \u201cRIGLEY\u201d, consider the following SQL statement:\n\n","An important feature of UDFs is that they can be used where the return type of the UDF can be used in this case a float. This allows for restricting, sorting, or grouping based on similarity score as well as in any numerical calculation. In the above examples, observation of the records indicates which of the records has the highest score. But in order to calculate the overall score, there can be many solutions to come up with the best overall score. One of the simplest method of forming an overall score is to divide the sum of the score by the number of attributes that make up the score. In the case of our \u201cBRIAN BAILY\u201d example discussed above with reference to  and , the total score would be\n\n(1+0.949)\/2=0.975.\n\nIn some cases, a user may want to place emphasis on a particular attribute's score as it may play a greater role in the overall score. In the \u201cBRIAN BAILY\u201d example, a user may determine that the score of the last_name should play a bigger role in the overall score and therefore want to weight it at \u00be of the overall score. The calculation would then be\n\n(1*0.25)+(0.949*0.75)=0.962.\n\nThis allows all of the \u201cBAILY\u201ds (and similar values) in the dataset to generate a higher overall score, regardless of first name. Because the results of the SQL statement are returned to the caller (client), any client-side processing of the results to determine the overall score is acceptable within the scope of the present invention. Average and Weighted Average are simply the most common implementations.\n","In the client-side overall scoring solution, every record must be returned to the client in order for the client to determine the overall score. This may introduce excessive network traffic and database input and output. One solution would be to use standard SQL arithmetic to generate the necessary result set. In the case of the AVERAGE solution, the generated SQL statement for the case of two attributes may look like the following:\n\n","In the case of weighted average, dynamically generating the query based on weights for each attribute may look like the following SQL statement for the case of two attributes:\n\n","Average and Weighted Average are fairly simple to implement using standard SQL based arithmetic. However, a more complex overall scoring method may not be able to be expressed in SQL. A solution to this problem is to place the overall scoring logic on the RDBMS itself via the use of UDFs. Instead of the UDFs producing a score by computing the distance\/similarity of two values, the UDF produces a score by taking in a series of other scores and generating an overall score. For example, consider a UDF that computes the highest of two scores. It may be defined to database via the following DDL:\n\n","Generally speaking, the majority of time required in accessing a database is the time required to get data from disk into memory. As a performance optimization technique, it is therefore beneficial to do as much work as possible while the data exists in memory. In the above examples, with the exception of restriction, the database iterates through all the records (or rows), producing a score for each record in the database. The score is generated by comparing the anchor values in the current record with the target values from a search record, and combining the individual scores into an overall score. Assuming that getting the database record into memory is the slowest part of the operation, it is desirable to maximize the number of operations performed on that data before the database and operating system swap the record back out to disk. The goal then is to score as many search records against the current records while the current record is still in memory. For example, assume a dataset of last_names, and also a high volume of requests for queries of this data set. Further assume that at any given time, there are 5 distinct queries of the dataset. Without search coalescing, we would issue the following five separate SQL queries to satisfy the search requests.\n\n","Turning now to  and ,  and  describe the Measures implemented as UDFs in an embodiment of the SSE. The term \u201ctokenized Compare\u201d is used in the Measure descriptions of  and . In the present context, it means to use domain-specific (and thus domain-limited) knowledge to break the input strings into their constituent parts. For example, a street address can be broken down into Number, Street Name, Street Type, and, optionally, Apartment. This may improve the quality of scoring by allowing different weights for different token, and by allowing different, more specific measures to be used on each token.","Turning now to ,  depicts a process  for remotely scoring and aggregating by a Similarity Search Engine (SSE). The process of remote similarity scoring and aggregating takes place in seven main steps. An SSE receives a client's request  for a similarity search as a QUERY command that includes a WHERE-clause containing the anchor values for the search. The weights to be used in combining the scores for the various values are either given in the request APPLY clause or obtained from the specified schema for the search. The anchor values needed for the search are provided in the request. The Search Manager then constructs an SQL statement , which includes the weights. However, the weights need to be normalized such that the normalized weight for each search value represents its relative contribution to the overall score and that all the normalize weights add up to 1.00.","To normalize the weights, the weights are first normalized within their repeating groups such that the sum is 1.00, using the following formula:\n\n\/(12)\n","where",{"@attributes":{"id":"p-0138","num":"0173"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u0175","is the partially normalized weight"]},{"entry":[{},"w","is the raw weight"]},{"entry":[{},"n","is the number of values in the repeating group"]},{"entry":[{},"wi","is the raw weight of the i-th value out of n"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":[{},{}],"in-line-formulae":[{},{}],"i":["\u011d=g","g","+g","+ . . . +gn","\u0175","+\u0175","+ . . . +\u0175n"]},"where",{"@attributes":{"id":"p-0140","num":"0175"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u011d","is the normalized weight for the group"]},{"entry":[{},"g","is the raw weight for the group"]},{"entry":[{},"gi","is the raw weight for the i-th group under the same parent"]},{"entry":[{},"\u0175j","is the partially normalized weight of the j-th value under"]},{"entry":[{},{},"the same parent"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":[{},{}],"in-line-formulae":[{},{}],"i":["W","\u011d","*\u011d","* . . . *\u011dn","\u0175"]},"where",{"@attributes":{"id":"p-0142","num":"0177"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["W","is the fully normalized weight for the anchor value"]},{"entry":["\u011di","is the normalized weight for the i-th level group containing the value"]},{"entry":["\u0175","is the partially normalized weight for the anchor value"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Once the normalized weights have been calculated, the Search Manager inserts them into an SQL statement , which has the following format:\n\n","where pkey is the primary key for the document being scored;",{"@attributes":{"id":"p-0145","num":"0181"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Mi","is the UDF that implements the similarity measure for the i-th value;"]},{"entry":["aj","is the j-th anchor value specified in the request;"]},{"entry":["tj","is the field (column) in TABLE that is mapped to the j-th anchor"]},{"entry":[{},"value and contains the target values for the search; and"]},{"entry":["Wj","is the fully normalized weight associated with the j-th anchor value."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"After constructing an SQL request statement , the Search Manager presents the SQL statement to the DBMS . One method of connecting to the DBMS is the Java Database Connection (JDBC) protocol, which encapsulates the SQL statement as a text string within a connection object that provides the necessary access controls for the DBMS. The connection is synchronous, so the connection is maintained until the Search Manager receives the result from the DBMS. The DBMS then executes the received SQL statement . As described above, the SSE's similarity measures are implemented in the DBMS as User Defined Functions (UDFs). These are represented as M1, M2, . . . , Mn in the SQL statement shown above. The input parameters passed to the measure UDF are the anchor value and target field that contains the target values to be scored. The normalized weights W1, W2 . . . Wn are treated as constants, so once the UDF results are available, the overall score can be calculated as a simple weighted sum:\n\n1122\n","where",{"@attributes":{"id":"p-0148","num":"0184"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"S","is the value to be returned as SCORE"]},{"entry":[{},"si","is the score returned by the UDF call Mi(ai, ti)"]},{"entry":[{},"Wi","is the normalized weight for anchor value ai"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The DBMS completes the transaction by returning a result set to the Search Manager , consisting of a list of key values and scores. The key value identifies the document to which the corresponding score pertains. When the SQL command has completed by the DBMS, depending on the QUERY, the Search Manager may have some additional steps to perform. These are unrelated to the remote scoring, but are noted here for completeness. If the QUERY command includes a RESTRICT clause, then the client does not wish to receive scores for every document in the database but is interested in only a certain number of scores or the scores within a given range. In these cases, the Search Manager truncates the result set so that only the requested scored are returned. The ordering of scores in descending order facilitates this process and allows the Search Manager to stop processing the result set when it sees that there will be no more scores that meet the restriction. If the QUERY command includes a SELECT clause, then the client wishes to receive the target values considered by the measure along with the score for the comparison. For such requests, the Search Manager calls the Virtual Document Manager (VDM) to obtain the corresponding values , using the document key included in the result set. Finally, the Search Manager packages the document keys, similarity scores, and other requested data as a result set and returns it to the client making the request . This completes the transaction.","Turning now to  and , the architecture of the similarity search engine includes a DATASOURCE object that encapsulates the transport-level protocols used in the connection.  shows a DATASOURCE. The DRIVER element within the DATASOURCE specifies the protocol driver for the connection.","The administrative utility for the similarity search engine allows the protocol driver to be selected at the time the connection to the database is established. One of these \u201cpluggable\u201d drivers implements the industry-standard Secure Sockets Layer or SSL protocol for the connection. SSL is also known as Transport Layer Security or TLS. Because it is based on Public Key Infrastructure or PKI, SSL requires an additional server to act as the Certificate Authority.  shows an example DATASOURCE specifying an SSL driver for DB2.","Turning now to , persistence is implemented in a collection of drivers that may be configured to suit the needs of the user. The primary drivers are the Filesystem Driver and the Database Driver, providing filesystem persistence and database persistence, respectively. In the current implementation, the filesystem persistence driver has the path name:\n\n","A persistence driver is invoked by including a PERSISTENCE element in the configuration file to be persisted. PERSISTENCE elements for filesystem persistence and database persistence are given in  and , respectively. The filesystem PERSISTENCE element contains a LOCATION element indicating the directory node in the filesystem where persisted files are to reside.  shows an example implementation.","The database PERSISTENCE element contains URL, DRIVER, USERNAME, PASSWORD, and TABLE elements indicating the location of the database table where the persisted files are to reside.  shows an example implementation. The table is created with columns for PATH and VALUE, where PATH contains the pathname of the persisted file and VALUE contains the contents of the file represented as an XML text string.","Some supporting drivers are also included. The composite persistence driver () binds one or more of the primary drivers with a regular expression defining their domains of control. The path prepending driver () is used to construct virtual keys from physical keys by prepending a logical path to the physical keys referenced by the inner primary driver. A keyword replacing driver () is also employed to perform required keyword substitutions.  is a class diagram showing the drivers described above.","Example invocations of the persistence drivers for the configuration files for the command manager, search manager, and virtual document manager are shown in , , and , respectively.  is an example invocation of the persistence drivers for rersisting the command manager configuration files for the gateway, which includes a username value, a template value and a datasource driver designation.  is an example invocation of the persistence drivers for persisting the search manager configuration files, which includes a measure value, a choice value, a parser value, a datasource value, a schema value, a statistic value, and a datasource driver designation.  is an example invocation of the persistence drivers for persisting the virtual document manager configuration files, which indudes a datatype value, a datasource value, a schema value, and a datasource driver designation. The template value shown in . and  is a mechanism for designating a particular template to be used with a particular driver for keyword substitution of virtual keys.","Although the present invention has been described in detail with reference to certain preferred embodiments, it should be apparent that modifications and adaptations to those embodiments might occur to persons skilled in the art without departing from the spirit and scope of the present invention."],"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF THE DRAWINGS"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["These and other features, aspects and advantages of the present invention will become better understood with regard to the following description, appended claims, and accompanying drawings wherein:",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 16","FIG. 6"]},{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 17","FIG. 8"]},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 19","FIG. 18"]},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 32"},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 33"},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 34"},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 35"},{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 36"},{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 37"},{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 38"}]},"DETDESC":[{},{}]}
