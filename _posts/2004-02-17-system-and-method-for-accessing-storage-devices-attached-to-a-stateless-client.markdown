---
title: System and method for accessing storage devices attached to a stateless client
abstract: A system and method for accessing storage devices attached to a stateless client. In one embodiment, the system may include a server configured to execute an application and a stateless client coupled to the server, whereby a user interacts with the application. The system may further include a storage device locally coupled to the stateless client, where the storage device is accessible by the user via the server. In various specific implementations of the system, the storage device may be a solid-state mass storage device or a mass storage device employing magnetic or optical media. In another specific implementation of the system, the storage device may be locally coupled to the stateless client via an interface such as Universal Serial Bus (USB) or IEEE 1394 (e.g. FireWire).
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07996631&OS=07996631&RS=07996631
owner: Oracle America, Inc.
number: 07996631
owner_city: Redwood
owner_country: US
publication_date: 20040217
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF EMBODIMENTS","Overview of Stateless-Client\/Server System Architecture"],"p":["1. Field of the Invention","This invention relates to computer systems and, more particularly, to client\/server systems employing stateless clients.","2. Description of the Related Art","One common architecture for providing computing services to a number of users is the client\/server architecture. Generally speaking, client\/server architectures provide one or more server computer systems, each of which may be configured to provide some type of computing service to users via one or more client computer systems. Computing services provided by servers on behalf of clients may include email services, web hosting\/internet access, database services, or any other type of software application or service. Often, multiple client systems will share access to a smaller number of server systems.","In typical client\/server architectures, a given server system is more computationally powerful than a given client system. For example, a server system may typically include faster and\/or multiple processors, more system memory, greater storage resources, greater storage\/network bandwidth, etc. than a typical client system. However, in many client\/server architectures, client systems are structurally similar to server systems, in that both types of systems may include local processing and storage capability, and both types of systems may be capable of running operating systems and application programs.","In some instances, the number of client systems in a given installation may greatly exceed the number of server systems, for example in enterprise environments where the services to be provided are not individually resource-intensive (e.g., email, web browsing, office applications) but are provided to a large number of users. Providing each user in such an installation with a client system including a processor, local storage, an operating system, and applications may result in substantial administrative costs, as such systems typically need to be upgraded, repaired, patched, or replaced over time. For example, security or functionality patches may be frequently issued for some operating systems, and preserving system integrity and availability may require that such patches are applied to each client system in a timely fashion. In turn, such patching may require individual intervention on the part of a system administrator or a complex automated system for centrally managing the configuration of client systems.","Alternatively, a client\/server installation may employ stateless client systems. Typically, stateless client systems lack inbuilt application processing or storage resources. Rather than execute an operating system or applications, stateless clients may be configured to allow a user to access an operating system and applications running on a server system. In such an installation, administrative costs may be greatly reduced, as individual client patching and upgrading may be generally unnecessary, and simpler stateless client design may increase client reliability.","Users of client\/server systems may often have the need or desire to be able to use removable or portable storage media with their applications. For example, users may wish to access data stored on optical or magnetic disks or other types of storage media. However, typical stateless clients do not include support for local storage devices. In particular, since typical stateless clients do not run operating system software locally, they do not provide the capability of locally interfacing to storage devices.","Various embodiments of a system and method for accessing storage devices attached to a stateless client are disclosed. In one embodiment, the system may include a server configured to execute an application and a stateless client coupled to the server, whereby a user interacts with the application. The system may further include a storage device locally coupled to the stateless client, where the storage device is accessible by the user via the server.","In various specific implementations of the system, the storage device may be a solid-state mass storage device or a mass storage device employing magnetic or optical media. In another specific implementation of the system, the storage device may be locally coupled to the stateless client via a Universal Serial Bus (USB) interface.","A method is also contemplated that in one embodiment may include executing an application on a server, a user interacting with the application via a stateless client, and the user accessing a storage device via the server, where the storage device is locally coupled to the stateless client.","While the invention is susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood, however, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.","Turning now to , a block diagram illustrating one embodiment of a stateless-client\/server system is shown. In the illustrated embodiment, system  includes a plurality of stateless clients and configured to communicate with a plurality of server systems and via a network . Additionally, in the illustrated embodiment, each of stateless clients and is locally coupled to a respective one of storage devices and . It is noted that like reference numbers refer to like elements herein, and that a plurality of like elements distinguished by a letter suffix may be referred to generically in the plural or singular by a reference number without a letter suffix. For example, it is contemplated that in various embodiments, an arbitrary number of stateless clients , server systems , and storage devices  may be employed.","Stateless clients , which may also be referred to as ultra-thin stateless clients, may be configured to allow users to interact with various applications that execute on one or more of servers . As described in greater detail below in conjunction with the description of , in some embodiments stateless clients  may include hardware to support a user interface, such as interface hardware to drive input and output devices such as keyboards and video display devices, for example. Such embodiments may further include hardware to support interfaces to network  and storage devices . However, such embodiments of stateless clients  may lack an operating system and may not locally execute applications or locally store application data accessible by users. That is, application execution and data storage may take place on servers  and\/or storage devices , whereas the hardware resources of stateless clients  may be configured to convey data and commands to and from servers  and\/or storage devices  on behalf of one or more users. Since such embodiments of stateless clients  lack resources for locally executing application or operating system software or storing application data or \u201cstate,\u201d they may be referred to as \u201cstateless.\u201d One example of a stateless client  is given by the Sun Ray family of ultra-thin client systems available from Sun Microsystems, Inc., although other embodiments of stateless clients are possible and contemplated.","In contrast to stateless clients , in the illustrated embodiment, servers  may include resources for execution of applications and operating system software as well as data storage. As described in greater detail below in conjunction with the description of , in various embodiments servers  may include one or more microprocessors as well as system memory and storage devices such as hard disk drives, for example. Servers  may in various embodiments be configured to execute one or more operating systems, such as Sun's Solaris operating system, Linux, Microsoft Windows, or any suitable operating system. Additionally, servers  may in various embodiments be configured to execute one or more user applications. For example, servers  may execute web browser applications, database applications, office productivity applications, multimedia applications, or any other suitable type of application software.","It is also contemplated that in some embodiments, one or more instances of servers  may be configured as a storage server. For example, in one embodiment server may be configured as a network attached storage (NAS) server comprising storage devices such as arrays of disk drives. In such an embodiment, server may be configured to provide storage for application data for use by applications executing on other servers . In some embodiments, storage servers may be employed in system architectures in which application execution resources are segregated from data storage resources.","Stateless clients  may be configured to communicate with servers  via network . In one embodiment, network  may be a local area network (LAN), such as an Ethernet network, for example, and may employ wired and\/or wireless networking protocols. In other embodiments, one or more of stateless clients  and servers  may be geographically distant, such as in different buildings or cities. In such embodiments, network  may include wide-area networking functionality employing telecommunications-based network protocols. For example, network  may include a T1 or T3 interconnect, or a high-bandwidth optical interconnect.","Generally speaking, a given stateless client  may provide a user with input and output access to applications executing on one or more of servers . In some instances, a user may wish to provide input to or receive output from an application via a storage medium not otherwise accessible within system . For example, a user may have files stored on a portable hard drive or a removable storage medium such as a floppy or ZIP disk, CD-ROM\/DVD-ROM, Flash-based keychain device, or another similar storage device. The user may wish to access these files for reading or writing from within some application executing on a server .","In the illustrated embodiment, stateless clients  are locally coupled to storage devices . Storage devices  may be any suitable type or format of storage device. In one embodiment, storage device  may be a mass storage device employing magnetic media, such as a portable hard drive or a removable-medium floppy, ZIP disk, or cartridge-based drive, or any other type of magnetic media-based storage device. In another embodiment, storage device  may be a mass storage device employing optical media, such as read-only or writable\/rewritable CDs or DVDs, according to any of the various standards and formats for such media. In yet another embodiment, storage device  may be a solid-state mass storage device employing any of various solid-state memory technologies such as volatile, battery-backed random access memory (RAM), or nonvolatile read-only memory (ROM) or Flash memory, for example. In some embodiments, a storage device  may be directly coupled to a given stateless client  via an interface such as Universal Serial Bus (USB), Firewire\/IEEE 1394, or any suitable peripheral interconnect interface. In other embodiments, a storage device  may be coupled to a given stateless client  through another peripheral. For example, a memory card may be coupled to a stateless client  through a USB-attached card reader into which the memory card may be inserted.","As noted above, in the illustrated embodiment, stateless clients  may have no resident operating system or internal user-accessible data storage. As described in greater detail below, a storage device  may be locally coupled to a given stateless client , but may be accessible to a user of given stateless client  via a given one of servers , such that the user may manipulate content of the storage device  via an application executing on given server .","Hardware Architecture of an Exemplary Stateless Client","One exemplary embodiment of a stateless client  is illustrated in . In the illustrated embodiment, stateless client  includes an audio interface , a video interface , a USB interface , a smart card interface , and a network interface , each coupled to control hardware . Additionally, stateless client  is shown coupled to a number of devices via its several interfaces. Specifically, audio interface  is coupled to an audio peripheral , and video interface  is coupled to a video display device . USB interface is coupled to a keyboard , a mouse , and one or more storage devices . Smart card interface  is coupled to a smart card , and network interface  is coupled to a network such as network  of .","Audio peripherals  may in various embodiments include any type of audio input or output device, or multiple such devices, such as speakers, headphones, microphones, external amplifiers, or recording devices, for example. Audio interface  may be any suitable interface for driving audio output devices and\/or receiving input from audio input devices. For example, in one embodiment audio interface  may include digital-to-analog (D\/A) conversion logic to convert digital audio data received from one of the other interfaces (for example, from an application executing on a server  via network  and network interface ) to analog signals suitable for driving audio output devices. In some embodiments, audio interface logic may also include analog-to-digital (A\/D) conversion logic to convert analog signals received into digital data that may be conveyed to another device or an application on a server via another of stateless client 's interface. In various embodiments, audio interface  may include amplification circuitry for driving unamplified output devices, or may include additional audio processing logic such as multichannel audio output mixing, audio synthesis, or digital audio effects processing, for example.","Video display device  may in various embodiments include any suitable video display device, such as a cathode-ray tube (CRT) monitor or a liquid-crystal display (LCD) monitor. In some embodiments, it is contemplated that video display device  may be built into the same chassis as stateless client , while in other embodiments video display device  may be separate from and coupled to stateless client , such as through a video cable. Video interface  may include logic configured to convert video data received from one of the other interfaces (for example, from an application executing on a server  via network  and network interface ) to analog or digital signals in a format suitable for driving the attached video display device . In some embodiments, video interface  may support multiple different types of video display devices  or may support driving multiple such devices simultaneously. In one embodiment, video interface  may include frame buffer and display driver logic, while complex rendering tasks are performed in software on a server .","USB interface  may include logic configured to support transferring data to and from various USB-compliant peripheral devices according to one or more versions of the USB interface standard, such as USB 1.1 or USB 2.0, for example. USB interface  may include support for multiple physical USB interface ports within stateless client ; in an alternative embodiment, an external USB hub (not shown) may be attached to increase the number of USB ports available for attaching devices. It is contemplated that in some embodiments of stateless client , a different peripheral interface for devices may be provided instead of or in addition to USB interface . For example, in one alternative embodiment, stateless client  may implement a Firewire\/IEEE 1394 interface configured for coupling to peripherals such as storage devices . In various embodiments, storage devices  may be any of the types of storage devices described above in conjunction with the description of .","Keyboard  and mouse  may be any suitable variants of textual input and pointing devices. Mouse  may include touchpad devices or joysticks in various embodiments. In some embodiments, keyboard  and mouse  may be combined in the same chassis. In one embodiment of stateless client , a dedicated interface such as a PS\/2 or serial interface (not shown) separate from USB interface  may be used to couple keyboard  and\/or mouse .","In the illustrated embodiment, smart card interface  may be configured to allow a user to couple a smart card  to stateless client . In some embodiments, smart card  may be used to authenticate a user and allow the user to access applications executing on a server . For example, smart card  may include a secret code or biometric information that uniquely identifies a given user, such that a user may not need to provide other identifying or authenticating information to begin or continue using a given stateless client  to access applications. It is contemplated that in some embodiments of stateless client , smart card interface  may be omitted, and users may use conventional combinations of usernames and passwords entered, e.g., via keyboard , for authentication.","Network interface  may in various embodiments be configured to process various networking protocol layers (such as those defined by the Open Systems Interconnect (OSI) layered networking model, for example) to allow data sent to or from stateless client  via network  to be appropriately encapsulated or extracted. For example, network interface  may include logic configured to send and receive signals in the physical network layer, such as electrical signals transmitted via coaxial or twisted-pair electrical cable, optical signals transmitted via fiber-optic cable, or wireless radio signals. Network interface  may further be configured to perform error detection on received signals, decode network packets to determine whether they are destined for a given stateless client , and\/or other networking functions. In the illustrated embodiment, network interface  may be configured to send or receive data from any of the other interfaces of stateless client . In various embodiments, network interface  may implement support for one or more different types of network infrastructure, such as wired Ethernet, Fibre Channel, Token-Ring, or wireless protocols such as IEEE 802.11 (Wi-Fi), for example.","Control hardware  may be configured to coordinate data exchange among the various other components within stateless client . For example, in one embodiment control hardware  may include an embedded microprocessor and a firmware program used by the microprocessor to control data flow within stateless client . In some embodiments, the various interfaces of stateless client  may be implemented according to a bus interface standard such as the Peripheral Component Interconnect (PCI) bus standard. In such embodiments, control hardware  may include logic configured to manage data buses, including arbitrating conflicts among devices, allocating device bandwidth through flow control, etc. It is noted that in the illustrated embodiment, the operation of control hardware  may be transparent to a user of stateless client ; that is, a user may not be able to interact directly with control hardware  or any buffers or resources it employs in managing the hardware of stateless client .","Storage Device Organization and Management","In some embodiments, storage devices  may implement an organizational hierarchy through which various elements or portions of the storage device may be defined and accessed.  illustrates one embodiment of a storage device  configured to implement a logical hierarchy. In the illustrated embodiment, storage devices  includes a plurality of unit interfaces -, which may be configured to couple to stateless client  through USB interface , for example. A plurality of logical units (LUNs) -are accessible through unit interface , and LUN includes a plurality of partitions -. It is contemplated that in other embodiments storage devices  may implement arbitrary numbers and organizations of unit interfaces , LUNs , and partitions .","Unit interfaces  may be configured to allow access to different types of functionality within a given storage device . For example, in one embodiment a storage device  configured as a portable MP3 player may include audio playback capability in addition to data storage capability. In such an embodiment, a particular unit interface may be defined for accessing audio capabilities of this storage device , while another unit interface may be defined for accessing stored data files themselves. In some embodiments, storage device  may implement a single unit interface .","In some embodiments, storage device  may implement several distinct devices. For example, a given storage device  may be configured as a multiformat memory card reader, and may include multiple slots configured to accept different types of memory cards such as Compact Flash (CF) cards, Secure Digital (SD) cards, Memory Stick cards, and\/or other types of cards. LUNs  may be configured to allow access to each distinct device implemented within storage device . For example, each of three card slots corresponding to the three memory card types just mentioned may correspond to a respective LUN -. In some embodiments of storage device , such as a portable hard drive embodiment employing a single hard disk, a single LUN  may be implemented.","Partitions  may be used in some embodiments to further subdivide a given LUN . In one embodiment, a partition  may be a software construct managed by an operating system or application, such as an application executing on a server , to facilitate organization of data. Such partitions may also be referred to as logical or virtual partitions. For example, a user may choose to organize a given storage device  into multiple logical partitions  according to different types of data to be stored. Later, the user may a particular partition  on which to perform some action, such as a backup operation. In some embodiments, a single partition  may be defined to represent the entirety of data stored on a given storage device .","As previously noted, stateless clients  may lack operating systems or other local software. Thus, in some embodiments, storage devices  may be managed by software configured to execute on one or more of servers . One embodiment of a software system configured for management of storage devices locally coupled to stateless clients is illustrated in . In the illustrated embodiment, several software modules are executable by a given server . These modules include one or more applications , which are configured to interface with one or more kernel modules . In turn, kernel modules  are configured to interface with a storage service daemon . Storage service daemon  receives information from device manager , and both modules interact with storage devices  via network  and stateless clients  (shown in ).","In the illustrated embodiment, server  is configured to provide a user execution mode as well as a kernel execution mode, which may also be referred to as user space and kernel space, respectively. Software executing in user execution mode may be less privileged than software executing in kernel execution mode. For example, operating system software may restrict the degree to which user space software may access system resources, such as system memory allocated to various software modules as well as data storage and communication resources. By limiting the degree to which user-space software modules may interact with one another (e.g., by providing each user-space module a protected memory region in which to execute) and by coordinating access to shared system resources through kernel-space software (e.g. by providing kernel-space entrypoints through which user-space software accesses such resources), an operating system may increase system stability and integrity. For example, limiting the privileges of user-space software may help prevent an errant application from corrupting other applications or system resources, which might otherwise result in data loss or system failure.","Applications  may be any software applications configured to access and manipulate data storage presented by storage devices . For example, in various embodiments applications  may be word processors or other office productivity applications, applications for generating or viewing web-based Internet content, databases, multimedia generation and\/or presentation applications, or any other type of application. In the illustrated embodiment, applications  may be configured to access data stored on storage devices  for creation, deletion, reading, writing, or other operations via an application programming interface (API) presented by kernel modules . Such an API may include a set of function calls specific to the supported operations, for example. In the illustrated embodiment, applications  execute in user space.","Kernel modules  may be configured to present to applications  an interface to storage devices . For example, in one embodiment kernel modules  may include data structures that allow a given storage device  to appear to applications  as a block-type storage device capable of reading or writing data in blocks of a given size (e.g., 512 or 1024 bytes), or as a character-type or \u201craw\u201d storage device capable of reading or writing data in variable quantities. In alternative embodiments, kernel modules  may present other types of device models instead of or in addition to block- and character-type devices. Kernel modules  may be additionally configured to provide a file system whereby such block or character storage device representations may be organized into a hierarchy of files, directories, and\/or partitions.","In some embodiments, kernel modules  may be configured to provide applications  with common interfaces to any type of storage device regardless of whether that storage device is attached to a stateless client , is internal to a particular server , or is otherwise accessed via network , such as in the network-attached storage case described previously. In such embodiments, storage service daemon  may be configured to provide protocol and interfacing support specific to storage devices  locally coupled to stateless clients . More generally, storage service daemon  may serve to provide a software interface between applications  and storage devices .","For example, as described in greater detail below, in one embodiment storage service daemon  may be configured to establish control of each LUN  of the storage devices  attached to a particular stateless client , to receive requests for accessing a given LUN  from kernel modules , and to assemble commands for carrying out those accesses according to the specific access protocols implemented by various storage devices  (e.g., SCSI commands for hard disk type storage devices, MMC-2 commands for CD\/DVD type devices, etc.). Also, in one embodiment storage service daemon  may be configured to establish control of each USB interface  implemented among the various stateless clients  interacting with a given server  and to execute the previously mentioned commands according to a USB protocol appropriate to each interface (e.g., bulk-only protocol for hard disks, control-bulk-interrupt (CBI) protocol for CD\/DVD devices, etc.).","It is noted that in the illustrated embodiment, storage service daemon  is implemented within user space. In many conventional computer systems, the majority or entirety of software support for storage devices is implemented within kernel space. However, in many embodiments, kernel-space software is specific to a particular operating system platform, such as Unix or Windows. Thus, if kernel-level device support for different operating system platforms is desired, such support may need to be developed separately for each desired platform. Further, since kernel space software is typically more privileged than user space software, the burden of testing and validating kernel space software to ensure system stability and integrity may be greater than for user space software. For some embodiments, implementing storage service daemon  in user space may simplify development of the aforementioned storage services for a given platform, and may also simplify reuse and validation of the relevant code across different operating system platforms.","In the illustrated embodiment, device manager  may be configured to detect transitions in the availability of various storage devices  and to communicate such transitions to storage service daemon . More generally, device manager  may be configured to detect the presence of a given storage device  coupled to a given stateless client . For example, in some embodiments, storage devices  may be attached or detached from USB interface  of a given stateless client  at any time, which transitions may be referred to as \u201chotplugging events\u201d of storage devices . Device manager  may be configured to detect hotplugging events corresponding to various storage devices , and may communicate such events to storage service daemon , which in one embodiment may responsively update its data structures to reflect the addition or deletion of available storage device . Storage service daemon  may in turn convey such events to kernel modules , which in one embodiment may responsively allocate or delete block-type or character-type storage devices corresponding to storage devices  and\/or modify a file system to reflect such allocations or deletions.","Device manager  may in some embodiments be configured to collect additional information regarding storage devices  that appear or disappear during hotplugging events, such as the network address of the stateless client  corresponding to a given storage device , identification information corresponding to a given storage device  (such as a manufacturer or device ID, for example), and\/or client-specific interface information (such as an input\/output device address or interrupt channel, for example). Device manager  may also be configured to collect other or different information regarding storage devices  and may convey any such information to storage service daemon  along with notification of a hotplugging event. In some embodiments, it is contemplated that the functionality of device manager  may be incorporated within storage service daemon .",{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 5","FIG. 1","FIG. 5"],"b":["500","20","10","165","10","151","10"]},"Subsequent to the user establishing a session on given server , an application  may execute on given server  (block ). For example, the user may invoke an application such as a web browser, word processor, or another type of application. In an alternative embodiment, application  may execute on given server  prior to the user establishing a session via given stateless client . For example, the user may have previously invoked application  via a different stateless client , discontinued using the different stateless client , and subsequently established communication with given server  from given stateless client . Application  may have continued to execute throughout this sequence, subsequent to its original invocation.","The user may then interact with application  via given stateless client  (block ). For example, the user may enter text and control menus of application  via keyboard  and mouse . Control information generated by those peripherals may be conveyed to given server  over network , and server  may send graphical information back to given stateless client  via network  for display on video display device .","In one embodiment, the user may subsequently couple a storage device  to given stateless client  (block ). For example, the user may attach a portable hard drive to USB interface . Device manager  may then detect the hotplugging event resulting from the coupling of storage device  to given stateless client  and may notify storage service daemon  of the hotplugging event (block ). Storage service daemon  may responsively probe storage device , for example to determine the presence of unit interfaces  and LUNs , and may generate control data structures dependent on the probe results (block ). Storage service daemon  may further signal kernel modules  regarding the addition of storage device  (block ), and kernel modules  may responsively create block- and\/or character-type device interfaces for use by application . Kernel modules  may additionally update a file system to reflect the created device interfaces (block ).","Once a device interface is made available, the user may access storage device  via given server  (block ). For example, the user may instruct application  to save a copy of a document in a file on the portable hard disk attached as storage device . Application  may responsively issue write requests to kernel modules . In Storage service daemon  may then assemble a write command pertinent to storage device  as described above, and may convey the command along with the data to be written to storage device  via network  and given stateless client .","In some embodiments, the functionality of storage service daemon  and kernel modules  may be implemented by several discrete modules of code configured to perform separate functions. One such embodiment is illustrated in . In the illustrated embodiment, as in that shown in , several software modules are executable by a given server . Applications  and device manager  may be illustrative of those instances illustrated in  and described above. In the embodiment of , kernel modules  include kernel interface  and file system , each configured to interface with applications , as well as daemon interface  configured to interact with kernel interface . Storage service daemon  includes a plurality of device threads , a remote disk driver , and a protocol driver , each of which interfaces with the successive module. Device threads  are configured to interface with daemon interface , and protocol driver  is configured to interact with storage devices  via network  and stateless clients . It is noted that like the embodiment illustrated in  and described above, in the illustrated embodiment storage service daemon  is configured to operate in user space, whereas kernel modules  are configured to operate in kernel space.","As described previously, kernel modules  may collectively present a common set of storage device interfaces to applications . In the illustrated embodiment, kernel interface  may comprise the public interface for storage-related system calls. That is, kernel interface  may be configured to receive system calls pertaining to reading, writing, and configuration\/status querying of block-type or character-type devices corresponding to storage devices . In some embodiments, one instance of kernel interface  may be instantiated for each logical partition  and\/or each LUN  that exists within each storage device .","Some applications  may not reference block-type or character-type devices directly, but instead may reference files or directories maintained by a file system such as file system . In the illustrated embodiment, file system  may be configured to implement one or more file system types dependent on the operating system environment(s) supported by server . For example, file system  may implement a Unix\/Linux-type file system, a Windows-type file system, or other types of file systems, and\/or combinations of these. File system  may be configured to translate file references received from applications  into device references that may then be passed to kernel interface  as described above.","In the illustrated embodiment, daemon interface  is configured to convey device access requests from kernel interface  to storage service daemon . In some embodiments, one instance of daemon interface  may be instantiated for each LUN  that is mapped by storage service daemon . In some such embodiments, an additional instance of daemon interface  may also be configured to manage the allocation and deallocation of identifying state to storage devices  and their partitions  as storage devices  are attached and removed from various stateless clients . For example, in an embodiment implementing a Unix-type operating system environment, daemon interface  may be configured to allocate device minor numbers to partitions  when a hotplugging event resulting from attachment of a particular storage device  is detected. Similarly, daemon interface  may place corresponding minor numbers on a free list when a hotplugging event resulting from detaching a particular storage device  is detected.","Additionally, in some embodiments device access requests may not be able to be serviced as quickly as they may be generated by applications . For example, in some embodiments where USB peripherals are used, one transaction to a given unit interface  may need to complete before another transaction to that unit interface  may be issued. In some such embodiments, daemon interface  may maintain queuing data structures that may be configured to store pending access requests received from kernel interface  before those requests are serviced by storage service daemon . It is contemplated that in other embodiments, such queuing data structures may alternatively be maintained within storage service daemon , or that both daemon interface  and storage service daemon  may include support for queuing.","Since the public storage interface presented to applications  is provided through kernel interface , the interface between daemon interface  and storage service daemon  may remain private with respect to applications , which in some embodiments may simplify the implementation and maintenance of kernel modules . For example, in such an embodiment the interface between storage service daemon  and kernel modules  may be modified or tuned without disturbing the interface presented to applications . However, in an alternative embodiment, it is contemplated that daemon interface  and kernel interface  may be implemented in a single module.","Within storage service daemon , data transfers to and from storage devices  may be managed by device threads . In the illustrated embodiment, an individual device thread  may be created corresponding to unit interface  and each LUN  when a new storage device  is detected via a hotplugging event, as described in greater detail below in conjunction with the description of . In embodiments where an instance of daemon interface  is also provided for each LUN , there may be a one-to-one correspondence between daemon interface  and the LUN device threads . As noted above, in some embodiments each device thread  may implement one or more queuing data structures in which access requests destined for a corresponding unit interface  or LUN  may reside while waiting to be serviced.","In one embodiment, each device thread  may be separately schedulable for execution by server . For example, server  may be configured to implement a multithreaded execution environment. In such an environment, individual executable processes may spawn related executable threads that may share the resources of the parent process, thereby reducing context switch overhead when switching between such threads. In some embodiments, allocating individual device threads  per LUN  and\/or unit interface  may improve server 's ability to schedule and allocate resources. However, it is contemplated that in some embodiments, control of all LUNs  and\/or unit interfaces  may be implemented within a single schedulable thread or process, or may be apportioned among threads or process in other than a one-to-one ratio.","Different storage devices  may define different protocols for data access, depending on the device type. Remote disk driver  may be configured to implement specific access protocols or \u201ccommand sets\u201d implemented by various storage devices , and to assemble commands according to those protocols upon receiving an access request from a particular device thread . Some exemplary command sets that may be supported by remote disk driver  and their corresponding types of storage devices include: SCSI (some hard disk devices), QIC-157 (tape storage devices), SFF 8070i and UFI (floppy and\/or ZIP-type drives), ATAPI\/MMC-2 (CD\/DVD-type devices), and RBC (Flash memory-type devices). It is contemplated that remote disk driver  may support various combinations of these command sets as well as others not listed here.","Additionally, different USB protocols may be defined for different types of storage devices . In the illustrated embodiment, protocol driver  may be configured to assemble data access commands provided by remote disk driver  into USB transactions according to the relevant protocol for the storage device . For example, protocol driver  may select a bulk-only protocol for hard disks, or a control-bulk-interrupt (CBI) protocol for CD\/DVD devices. As noted above, in some embodiments it is contemplated that stateless clients  may implement another peripheral interface instead of or in addition to USB, such as a Firewire\/IEEE 1394 interface, for example. In such embodiments, protocol driver  may be configured to assemble commands received from remote disk driver  into transactions appropriate to the targeted storage device  according to the implemented peripheral interface.",{"@attributes":{"id":"p-0066","num":"0065"},"figref":["FIG. 7","FIG. 6","FIG. 1","FIG. 3","FIG. 6","FIG. 7"],"b":["700","25","25","10","25","20","440","430"]},"Subsequent to the hotplugging event, one or more unit interface threads may be spawned corresponding to the unit interface(s) present within hotplugged storage device  (block ). For example, in one embodiment device threads  may instantiate one thread per unit interface , although in other embodiments other correspondences between device threads  and unit interfaces  are possible and contemplated.","Unit interface threads may then probe their respective devices within storage device  and spawn one or more additional threads corresponding to the logical unit(s) present within hotplugged storage device  (block ). In one embodiment, for example, device threads  may instantiate one thread per LUN , although in other embodiments other correspondences between device threads  and LUNs  are possible and contemplated.","Once threads corresponding to the logical structure of hotplugged storage device  have been instantiated, kernel modules  may be notified of the hotplugging event (block ). For example, in one embodiment device threads  may notify a master controller instance of daemon interface  of the hotplugging event. Responsively, identifying information corresponding to the logical structure of hotplugged storage device  may be allocated and the structure mapped for access by software (block ). In one embodiment, daemon interface  may be configured to allocate minor numbers to each partition  and LUN  detected within hotplugged storage device . Additionally, in various embodiments, daemon interface  or device threads  may create device nodes such as character-type or block-type device nodes corresponding to each LUN  and\/or each partition , which device nodes may facilitate access to storage device  by, e.g., applications .","Once the logical structure of hotplugged storage device  has been identified and mapped, a request to access the storage device may occur (block ). In one embodiment, an application  may request to access a file stored within hotplugged storage device , or may request to access hotplugged storage device  directly as a character or block-type device. In such embodiments, application  may pass its request to file system  or directly to kernel interface , such as through an API.","The access request may then be queued (block ). For example, in one embodiment the access request may be queued within daemon interface , while in another embodiment it may be conveyed directly to storage service daemon  and queued within a corresponding one of device threads . In some embodiments, additional processing of the access request may occur before queuing. In one such embodiment the size of the request may be calculated and adjusted or translated to correspond to a block size employed by hotplugged storage device , for example in a system where the block size used by software differs from the block size used by a given physical storage device .","A device command may subsequently be assembled for a given queued access request (block ). For example, a given device thread  may retrieve a queued access request corresponding to its LUN  and may pass the request to remote disk driver , which may in turn assemble a device command according to a protocol defined for hotplugged storage device , as described previously. The assembled command may then be executed (block ). In the illustrated embodiment, protocol driver  may execute the assembled command according to a protocol specific to the peripheral interface through which hotplugged storage device  is coupled to corresponding stateless client . For example, protocol driver  may execute the command according to a particular USB mass storage device protocol as described above.","Hotplugged storage device  may receive such commands via network  and stateless client  and may process them, returning data and\/or processing status (block ). For example, hotplugged storage device  may a read access request or a write access request along with data to be written, or another type of request such as a status or information request. Hotplugged storage device  may then retrieve or store the relevant information, and return an indication to storage service daemon  of the status of the operation as well as any data requested, if available.","At any time subsequent to being attached to stateless client , hotplugged storage device  may be detached, and a corresponding hotplugging event may be detected by device manager  (block ). Device manager  may in turn notify storage service daemon  of the hotplugging event. Responsively, allocated identifying and\/or mapping state may be deallocated (block ). For example, in one embodiment device threads  corresponding to detached storage device  may be deallocated. In some embodiments, a given storage device  may be detached while one or more applications  have open references to data structures in its partitions . In some such embodiments, daemon interface  may leave allocated identification resources associated with such partitions (such as minor numbers or other state), but may mark such resources as stale, such that the identification resources may still be referenced by applications  but may reflect the absence of the underlying partitions . For example, an error condition may be returned to an application  that attempts an access request to a partition  with stale status. Daemon interface  may be configured to deallocate the resources corresponding to a stale partition  when the last application  maintaining an open reference to the stale partition closes it.","It is noted that in some embodiments, multiple access requests may occur between the time a given storage device  is attached and detached from a corresponding stateless client . Alternatively, in some instances no access requests may occur during this time. Corresponding variations in the operation illustrated in  are possible and contemplated.","Exemplary Server System Embodiment","As shown in  and , server  may be configured to execute one or more software modules. One exemplary embodiment of a server computer system is illustrated in . In the illustrated embodiment, server system  includes a processor  coupled to a system memory  via interface logic . Interface logic  is coupled to a network interface  and may couple to additional devices.","Processor  may be any type of processor. In some embodiments, processor  may be a general-purpose microprocessor that implements one or more instruction set architectures such as SPARC, x86, Power\/PowerPC, or any other suitable architecture or variant thereof. In other embodiments, processor  may be an embedded processor, a digital signal processor, or another processor capable of executing instructions. In the illustrated embodiment, processor  may be configured to access system memory  or another device to store and retrieve program instructions and data.","Interface logic  may be configured as bridge logic. In some embodiments, interface logic  may function as a \u201cnorth bridge\u201d coupling processor  and system memory , and may be configured to translate memory access requests originating from processor  to the appropriate format for system memory  and vice versa. In such an embodiment, interface logic  may also be configured for coupling to other peripheral buses to which peripheral devices may be attached, such as graphics adapters, storage devices, network interfaces, and other such devices. In some embodiments, interface logic  may couple to a \u201csouth bridge\u201d interface circuit (not shown), which may be configured for coupling to additional peripheral devices such as pointing devices, keyboards, etc. In other embodiments, interface logic  may incorporate all peripheral interface logic in addition to providing a memory interface. It is contemplated that in some embodiments, all or part of interface logic  may be incorporated into processor .","Network interface  may be any interface suitable for coupling server system  to a network such as network  of , for example. In various embodiments, network interface  may be adapted to couple server system  to wired networks employing electrical or optical cable, to wireless networks, or to a combination thereof. Network interface  may in one embodiment support a networking protocol standard such as Ethernet, while in other embodiments it may support other protocols or combinations or protocols such as Token-Ring, Fiber\/Copper Distributed Data Interface (F\/CDDI), Fibre Channel, or any other suitable protocol.","System memory  may include any of various types of memory technologies, or combinations thereof. In some embodiments, system memory  may be largely comprised of some variant of synchronous dynamic RAM (SDRAM), but in other embodiments static RAM (SRAM) or another RAM technology may be used. In some embodiments, system memory  may include additional resources for error detection and\/or correction, such as parity bits or error correcting code (ECC) bits, which may be separate from resources dedicated to storage of data or instructions.","In some embodiments, system memory  may be one embodiment of a computer-accessible medium configured to store program instructions executable by processor  as well as data accessible by processor . The program instructions and data may comprise any software program, module or application, such as any of the software modules illustrated in  or , for example. Such program instructions and data are illustrated as code  within system memory  in the illustrated embodiment. However, in other embodiments, program instructions and\/or data may be received, sent or stored upon different types of computer-accessible media. Generally speaking, a computer-accessible medium may include storage media or memory media such as magnetic or optical media, e.g., disk or CD-ROM, such as may be coupled to server system  through interface logic , for example. A computer-accessible medium may also include volatile or non-volatile media such as RAM (e.g. SDRAM, DDR SDRAM, RDRAM, SRAM, etc.), ROM, etc, such as may be included within system memory . Further, a computer-accessible medium may include transmission media or signals such as electrical, electromagnetic, or digital signals, conveyed via a communication medium such as network and\/or a wireless link.","Although the embodiments above have been described in considerable detail, numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
