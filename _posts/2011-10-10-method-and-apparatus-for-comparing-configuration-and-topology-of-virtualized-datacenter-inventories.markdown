---
title: Method and apparatus for comparing configuration and topology of virtualized datacenter inventories
abstract: Disclosed herein is a method of verifying that a reconstructed inventory of a virtualized computer system has been accurately reproduced from an original inventory of a virtualized computer system. A first snapshot and a second snapshot are received, where the first snapshot is a snapshot of the original inventory and the second snapshot is a snapshot of the reconstructed inventory. The first snapshot and the second snapshot are then analyzed to determine that hierarchical relationships, roles and permissions, configuration settings, and/or custom definitions of items in the original inventory match hierarchical relationships of corresponding items in the reconstructed inventory.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09063768&OS=09063768&RS=09063768
owner: VMware, Inc.
number: 09063768
owner_city: Palo Alto
owner_country: US
publication_date: 20111010
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["Software for managing a virtualized data center is responsible for monitoring physical hosts and virtual machines (VMs) running in the physical hosts and, further, for performing management operations such as provisioning and configuration tasks. One example of such management software is vSphere\u2122 by VMware of Palo Alto, Calif. The complete set of hosts, VMs, data storage elements (datastores), networks, and the organization of these elements into data centers, clusters, and resource pools, managed by such software, is commonly referred to as a virtualized computer inventory (hereinafter referred to as the \u201cinventory\u201d). In particular, the virtualized computer inventory comprises both topological data related to the foregoing elements and the configuration settings thereof.","Under certain circumstances, migration or reconstruction of an inventory may be desired or needed. For example, when a given cluster and the settings associated therewith have been tested in development and are ready to be moved into production, a production inventory is generated based on the development inventory. To give another example, an existing inventory that works well for a data center or across multiple data centers may be replicated by administrators for use with different data centers.","One existing technique for performing inventory migrations or reconstructions is described in U.S. patent application Ser. No. 13\/020,300, filed Feb. 3, 2011 and entitled \u201cProgrammatic Snapshot and Revert of Virtualized Data Center Inventory,\u201d which is incorporated by reference herein. According to this technique, a VM management center is queried to retrieve and store relationships between various entities, the permissions and roles associated with those entities, and the configuration settings of those entities. From this stored data, code for reconstructing the inventory of the virtualized computer system is generated.","A reconstructed virtualized computing inventory may not always be an exact copy of the original virtualized computing inventory. For example, an error may occur during the reconstruction of a virtualized computing inventory, or the reconstructed virtualized computing inventory may be based on erroneously-analyzed topology and\/or configuration settings of an original virtualized computing inventory. Therefore, it is desirable to confirm this after reconstruction.","One or more embodiments of the present invention provide a technique of verifying that a reconstructed inventory of a virtualized computer system has been accurately reproduced from an original inventory of a virtualized computer system. The technique includes the steps of retrieving first and second snapshots, wherein the first snapshot is a snapshot of the original inventory and the second snapshot is a snapshot of the reconstructed inventory, and analyzing the first snapshot and the second snapshot to determine that hierarchical relationships of items in the original inventory match hierarchical relationships of corresponding items in the reconstructed inventory. In some embodiments, the technique further includes the steps of analyzing the first snapshot and the second snapshot to determine that configuration settings of items in the original inventory match configuration settings of corresponding items in the reconstructed inventory.","Further embodiments of the present invention include, without limitation, a non-transitory computer-readable storage medium that includes instructions that enable a processing unit to implement one or more aspects of the above methods.",{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 1","FIG. 2"],"b":["100","100","104","106","108","108","106","108","108"]},"A virtual machine (VM) management center  is also included in system . VM management center  manages the virtual computer inventory, including managing data centers , the virtual machines running within each host computer , provisioning, migration, resource allocations, and so on. In one embodiment, VM management center  is configured to interact with agent  included in host computers  to exchange information using application programming interface calls (API) calls.","A VM management center client (vSphere client) , as shown in , is executed on a host computer  which is separate from virtualized computer system . Here, vSphere client  is configured to interact with VM management center  using various techniques including, but not limited to, API calls, web services messages, and the like. VSphere client  can be used to perform one or more tasks requested by an administrator, such as configuring storage and network connections, managing a service console, or querying data from host computers via agent . In one embodiment, a stand-alone desktop application version of vSphere client  is provided. In another embodiment, a browser based application provides the functionality of vSphere client .","VM management center  is used by an administrator to customize roles and permissions for various users. The administrator may perform this task by selecting from an extensive list of permissions to grant to each role and assigning roles the users. In one embodiment, such roles and permissions are stored separately from VM management center  in a lightweight directory access protocol (LDAP) database , as illustrated in . In other embodiments, the roles and permissions may be stored within and managed by VM management center . VM management center  can also provide full audit tracking to provide a detailed record of every action and operation performed on the virtualized computer inventory. As described in greater detail herein, embodiments of the invention provide a user interface for snapshot client  that allows an administrator to create a snapshot of an inventory managed by VM management center .",{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 2","FIG. 2"],"b":["108","102","108","108","202","204","206","108","210","212","214","216","214","216","216"]},"The virtual machines run on top of hypervisor , which is a software interface layer that enables sharing of the hardware resources of host computer  by the virtual machines. Hypervisor  may run on top of the operating system of the host computer  or directly on hardware components of the host computer . Each virtual machine includes a guest operating system and one or more guest applications. The guest operating system is a master control program of the virtual machine and, among other things, the guest operating system forms a software platform on top of which the guest applications run. As also shown, agent  is provided in hypervisor , by which specific information pertaining to the virtualization settings and configurations of host computer , and any VMs included therein, are transmitted to VM management center  as will be further described below. However, in the event that the VM management center  is unavailable, the databases to which the VM management center  is attached, e.g., LDAP  any additional databases (not shown) that include the information may be queried directly by the snapshot client .",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 3","b":["300","300","302","304","306","102","306","308","312","326","330","308","310","312","314","316","324","316","318","322","318","320","326","328","330","332","334","300"]},"The relationships set forth in virtualized computer inventory  are explicit relationships that are identifiable based on the hosts, clusters, and VMs view shown in . However, implicit relationships, which are relationships between entities that are not identifiable according to the view presented in FIG. \u2014may be present in virtualized computer inventory . Relationship  represents an implicit relationship that exists between resource pool  and virtual application  that is not shown when viewing virtualized computer inventory  according to the view in . Under other views, e.g., hosts and clusters view, the implicit relationship may be viewed as an explicit relationship. These implicit relationships are identifiable by parsing and processing information associated with virtualized computer inventory , as further described below in conjunction with .",{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 4","FIGS. 1-3"],"b":"400"},"As shown, method  begins at step , where snapshot client  running in host computer  initializes a process to determine relational data between entities included in an inventory managed by a management server, i.e., virtualized computer inventory  and VM management center , respectively. To accomplish this determination, snapshot client , at step  illustrated in , queries VM management center  for a list of object references that each reference a different entity included in virtualized computer inventory , e.g., folder , data center , folders -, etc. as illustrated in .","At step , snapshot client  obtains, for each object reference, a name of the referenced entity. In one example, data center  in virtualized computer inventory  is associated with the name \u201cMain_Datacenter.\u201d At step , snapshot client  obtains, for each object reference, a name of a data center to which each referenced entity belongs. Continuing with reference to the virtualized computer inventory , snapshot client  determines that each of entities - belong to data center . This is useful because certain entity names (e.g., of distributed virtual switches) are required to be unique within a particular data center, but not across one or more data centers. Thus, the obtained names of data centers can be used when reconstructing virtualized computer inventory  to specify precisely which entity is being restored.","At step , snapshot client  obtains, for each object reference that references a VM entity, a name of a resource pool to which the VM entity belongs. Thus, according to virtualized computer inventory , snapshot client  determines that VM  belongs to resource pool . This information is useful because the explicit parent for a VM is a VM folder, but a resource pool may exist as an implicit parent to the VM. More specifically, a VM may reside within a resource pool, even though the resource pool is not a parent to the VM. During reconstruction of virtualized computer inventory , a VM must be added to virtualized computer inventory  before it can be moved into a resource pool.","At step , snapshot client  queries VM management center  for each object reference to determine a parent entity to the referenced entity. For example, with respect to virtualized computer inventory , the parent to resource pool  is resource pool , and the parent to host system  is compute resource .","At step , snapshot client  creates, based on the determined parent entities, parent to child relationships between the entities. At step , snapshot client  creates, based on the determined parent entities, child to parent relationships between the entities. In addition, snapshot client  identifies, based on the parent to child and child to parent relationships between the entities, remaining implicit relationships between the entities. For example, in vSphere\u2122, a VM may belong to a folder, a virtual application (vApp), or both. A vApp is a multi-VM package that provides a standard way to describe operational policies for a high-level system that is executable by, for example, a cloud operating system. For example, a vApp directed to customer relationship management (CRM) might include a VM for a database server, a VM for an application server and a VM for a web server.","In the case that the VM belongs to a folder and a vApp, the folder is an explicit parent to the VM, while the vApp is an implicit parent to the VM. Thus, snapshot client  identifies relationships between entities by querying VM management center  for VMs that are managed by each vApp included in virtualized computer inventory . Host  further identifies any parent folders to each vApp included in virtualized computer inventory . Such identifications are necessary when reconstructing virtualized computer inventory . For example, when reconstructing virtualized computer inventory  using vSphere\u2122, a vApp must be added before the vApp is included in a folder. Therefore, the folder must be tracked during the reconstruction of virtualized computer inventory  so that the vApp is moved properly after being added. Note that snapshot client  is configurable to remove any redundant relational data, thereby decreasing the overall amount of memory and processing resources required to store and generate the snapshot. For example, every host contains a list of VMs that are currently running on that host. When VM management center  adds a host to an inventory, this list of VMs is retrieved from the host and these are automatically added to the inventory, so no relational data between hosts and VMs needs to be analyzed when creating a snapshot to the inventory. At step , snapshot client  stores the obtained and determined data as inventory relational data in a memory, e.g. memory .","Referring now back to , at step , snapshot client  initializes a process to determine configuration data associated with the inventory. At step , illustrated in , snapshot client  queries VM management center  for virtual application (vApp) configuration data associated with virtualized computer inventory . In turn, VM management center , if required, communicates with agents  included in hosts  to obtain configuration data. This configuration data specifies at least the VMs included in each vApp, and any resource settings corresponding thereto, e.g., CPU and memory limitations, shares, and reservations of the vApp.","At step , snapshot client  queries VM management center  for resource pool configuration data associated with virtualized computer inventory , e.g., configuration data associated with resource pool . This configuration data specifies at least the VMs included each resource pool, and any resource settings corresponding thereto, e.g., central processing unit (CPU) and memory limitations, shares, and reservations of the resource pool.","At step , snapshot client  queries VM management center  for compute resource configuration data associated with virtualized computer inventory , e.g., configuration data associated with compute resource . Compute resource configuration data is pertinent to the creation of a cluster and\/or a host when reconstructing virtualized computer inventory  in order to reflect specific hardware configurations associated therewith.","At step , snapshot client  queries VM management center  for networking configuration data associated with virtualized computer inventory , e.g., configuration data associated with network . The networking configuration data specifies at least port groups and network shaping settings.","At step , snapshot client  queries VM management center  for datastore configuration data associated with virtualized computer inventory , e.g., configuration data associated with datastore . The datastore configuration data specifies at least input\/output (IO) policies associated with each datastore included in virtualized computer inventory .","In addition, at step , snapshot client  queries VM management center  for any additional data that is required to perform a reconstruction of virtualized computer inventory . Finally, at step , snapshot client  stores the queried configuration data as inventory configuration data in memory .","Referring now back to , at step , snapshot client  initializes a process to determine security associated with the inventory. At step , illustrated in , snapshot client  queries VM management center  for all of the permissions defined within virtualized computer inventory . In one embodiment, these permissions are hierarchical, and snapshot client  collects all permissions and then maps them to according to their placement within virtualized computer inventory . For example, if a given permission applies to data center  and all VMs included therein, this information is stored so that, during reconstruction of virtualized computer inventory , the permission can be applied to a restored data center , the permission indicating that it also applies to all child VMs of data center .","At step , snapshot client  queries VM management center  and collects all of the roles defined within virtualized computer inventory , where each role belongs to one or more permissions. At step , snapshot client  stores the permissions and roles as inventory security data in memory .","Referring now back to , at step , snapshot client  creates an inventory snapshot data structure that encapsulates the inventory relational data, the inventory configuration data, and the inventory security data. In one embodiment, the inventory relational data is processed to be represented using a linked list. More specifically, each node in the linked list represents a different entity in the virtualized computer inventory , where each edge that links two node entities represents the relationship between the two node entities. Accordingly, the linked list may be used to facilitate the reconstruction process described below in conjunction with . Finally, at step , snapshot client  persists the data structure to one or more data files, and method  ends.","Thus, upon completion of the steps in method , the one or more data files include all information required to generate code that, when executed, reconstructs virtualized computer inventory  in the same or another VM management center . In one embodiment, reconstructing an inventory is performed via a two-phase process. The first phase involves parsing a snapshot of virtualized computer inventory  and generating code for reconstructing virtualized computer inventory  in whole, or in part. The second phase involves executing the code to reconstruct virtualized computer inventory . In one embodiment, the code is generated in a format that is executable by software that possesses the security rights to reconstruct virtualized computer inventory  within VM management center . One example of such software is PowerCLI for VMware vSphere\u00ae available from VMware, Inc. of Palo Alto, Calif., or one of a variety of other suitable command-line interpreter systems.","Several advantages are realized when using this two-phase process and generating code instead of actively executing the reconstruction process. For example, the code is distributable to multiple administrators so that each administrator can easily reconstruct virtualized computer inventory . In another example, the code is modifiable to, when executed, cause the reconstruction of only a portion of virtualized computer inventory  (e.g., only reconstructing a cluster as needed). In yet another example, the code is modifiable to, when executed, reconstruct virtualized computer inventory  with differently-named entities. Such renaming enables, for example, an administrator to recreate a topology with a different set of entities, e.g., a same hierarchy of a datacenter, cluster and resource pool, but a different set of host machines.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 5A-5C","FIGS. 1-4"],"b":["500","300"]},"As shown, method  begins at step , where snapshot client  receives one or more files (i.e., the files generated at step  in ) that comprise a snapshot of virtualized computer inventory . At step , snapshot client  initializes a process to generate relational data code that, when executed, restores relational data between entities included in virtualized computer inventory .","Referring now to , at step , snapshot client  parses the one or more files to identify each entity included in the snapshot. Continuing with the linked list described above in conjunction with , snapshot client  begins at the root of the linked list and identifies each entity by traversing the nodes and edges included in the linked list in a parent to child fashion. Accordingly, at step , the snapshot client  sets a next entity included in the snapshot as a current entity. At step , snapshot client  determines whether all entities in the snapshot have been parsed. Thus, steps  and  ensure that each and every entity included in the snapshot are processed by snapshot client .","At step , snapshot client  determines whether the entity is a data center and, if so, at step  snapshot client  generates code that, when executed, adds the data center to virtualized computer inventory  and associates the data center with a corresponding name included in the one or more files.","At step , snapshot client  determines whether the entity is a cluster and, if so, at step  snapshot client  generates code that, when executed, adds the cluster to virtualized computer inventory  and associates the cluster with a corresponding name included in the one or more files. Because clusters include one or more hosts, snapshot client  also generates code that, when executed, adds to virtualized computer inventory  the hosts that are included in the cluster, and, further, adds all VMs to virtualized computer inventory  that are associated with the hosts. More specifically, in vSphere\u2122, when a host is added to the virtualized computer inventory , all VMs that belong to the host are automatically added, thereby eliminating the need to track which VMs belong to which hosts. In addition, the code is supplemented to, when executed, associate the cluster with corresponding configuration settings included in the one or more files.","At step , snapshot client  determines whether the entity is a compute resource (i.e., a standalone host that is not part of a cluster). Because a compute resource is not part of a cluster, snapshot client  also generates code that, when executed, adds the compute resource to virtualized computer inventory , and, further, adds all VMs to virtualized computer inventory  that are associated with the compute resource, as described above.","At step , snapshot client  determines whether the entity is a vApp and, if so, at step  snapshot client  generates code that, when executed, adds the vApp to virtualized computer inventory  and associates the vApp with a corresponding name included in the one or more files. In addition, at step , snapshot client  must consider that the vApp may include other vApps and\/or VMs. Thus, snapshot client  must also generate code that, when executed, associates the vApp with child vApps or child VMs thereof. However, for this association to succeed, each child VM must already be established within the reconstructed virtualized computer inventory , otherwise execution of the code would fail when attempting to create an association between the vApp and a non-existent child VM. These issues, however, are avoided as described below.","With respect to child vApps: because snapshot client  traverses the linked list in a parent to child fashion, when a child vApp is reached, code to generate the parent vApp has, inherently, already been generated. Further, since execution of the code occurs in a sequential fashion, when execution of code to add the child vApp occurs, execution of code to add the parent vApp has already been executed. As a result, each child vApp can be readily associated with its parent. With respect to child VMs, since a vApp is a child to a cluster or a compute resource, and since snapshot client  traverses the linked list in a parent to child fashion, code to generate the parent cluster or compute resource\u2014and any VMs associated therewith\u2014has already been generated at step  or at step . Therefore, the code generated at step  executes after any child VMs associated with this vApp have, inherently, already been added to the inventory and can be readily associated with the vApp.","At step , snapshot client  determines whether the entity is a non-root folder. In vSphere\u2122, all virtualized computer inventories consist of a number of default root folders, which are implicitly added when virtualized computer inventory  is reconstructed. For example, a root network folder is added whenever a data center is added, where a parent to the root network folder is a data center. There are also datastore folders, host folders, and VM folders, where a root folder of each type is implicitly added to virtualized computer inventory  when the data center is added to virtualized computer inventory . When snapshot client  encounters a root folder, snapshot client  generates no code. However, when snapshot client  encounters a non-root folder, snapshot client  generates code that, when executed, adds the folder to virtualized computer inventory  and associates the folder with a corresponding name included in the one or more files.","As previously described herein, a folder entity may include one or more VMs. As also previously described, each VM must be associated with either a compute resource or a cluster, and that a parent to a VM is typically a VM folder. Accordingly, if snapshot client  encounters a VM folder in the linked list before snapshot client  encounters the compute resource or the cluster associated with the VMs included in the VM folder, then no code for reconstructing the VMs has been generated. As a result, the VMs cannot be moved into the appropriate VM folder. Snapshot client  avoids this situation, however, by moving VMs into folders as part of a second traversal of the linked list, after all VMs are guaranteed to have been added to the inventory. This second traversal is described in further detail below at step .","At step , snapshot client  determines whether the entity is a resource pool and, if so, at step , snapshot client  further determines whether the resource pool is a root resource pool. As previously described herein, in vSphere\u2122, a root resource pool is added by default whenever a cluster or a compute resource is added to virtualized computer inventory . However, if the entity is not a root resource pool, then, at step , snapshot client  adds the resource pool and associates the resource pool with any VMs included therein. By similar reasoning as for the vApps described above in step , method  guarantees that the VMs included in a resource pool already exist in virtualized computer inventory  when the resource pool is added to virtualized computer inventory . In addition, because resource pools can be nested, snapshot client  also places the resource pool under, if any, an appropriate parent resource pool. Again, because the linked listed is traversed in a parent to child fashion, method  guarantees that the parent resource pool will already be added to virtualized computer inventory . Finally, snapshot client  modifies the resource pool, if necessary, to match any corresponding resource pool settings included in the snapshot.","When snapshot client  has traversed all nodes included in the linked list, snapshot client  executes step  and generates code that, when executed, causes all entities to be moved into their appropriate folders. As previously described, the code generated at step  must be executed subsequent to the code generated throughout the first traversal of the linked list. This guarantees that, when the code to move the entities into their appropriate folders is executed, each of the entities has already been added to the reconstructed virtualized computer inventory . A similar constraint applies to hosts, networks, and datastores. To perform step , snapshot client  traverses the linked list to determine, if any, a parent folder for each entity, and generates code that, when executed, moves the entity into its corresponding parent folder. When an entity is added to a virtualized computer inventory, it is implicitly added to the root folder for its type. For example, VMs are automatically added to a root VM folder for a given data center. Therefore, if the parent folder for an entity is a root folder, snapshot client  foregoes generating code to move the entity into a parent folder, thereby increasing efficiency.","Referring now back to step , at step , snapshot client  initializes a process to generate configuration data code that, when executed, restores configuration data associated with the inventory.","At step , snapshot client  initializes a process to generate security data code that, when executed, restores security data associated with the inventory, i.e., permissions and roles. Because permissions can be propagated, snapshot client  is not required to add permissions for each entity in virtualized computer inventory . Instead, snapshot client  generates code to add each permission at a highest possible level in virtualized computer inventory  and then sets the permissions to propagate accordingly. For example, if a permission corresponds to a data center and all of the VMs included therein, snapshot client  is not required to explicitly associate each included VM with a permission. Instead, snapshot client  generates code that, when executed, associates the permission with the data center and sets a \u201cpropagate\u201d attribute accordingly. However, if a permission exists only for a particular VM, snapshot client  explicitly associates the VM with the permission.","At step , snapshot client  initializes a process to receive modifications to the data code. At step , snapshot client  presents the data code to a user. For example, snapshot client  may display, to the user, the data code in a text editor. At step , snapshot client  determines that the user has completed his or her updates to the data code. This may be triggered, for example, by detecting that the text editor is closed and that the data code has been updated. Such updates involve, for example, removing portions of code that generate a specific portion of virtualized computer inventory . In another example, the updates involve modifying the names of one or more entities included in virtualized computer inventory , which is efficiently accomplished by searching for and replacing specific text within the data code. In yet another example, the data code may include markers that are associated with specific portions of code, e.g., code associated with the reconstruction of resource pools. Advantageously, a user may select one or more of the markers so that only the code segments included in the data code and associated with the selected markers are executed by the snapshot client , as described below in step . Accordingly, the user is able to reconstruct specific sub-portions of the virtualized computer inventory .","At step , snapshot client  parses the data code to determine whether the updates\u2014if any\u2014have established errors in the data code. Optionally, snapshot client  may indicate to the user that his or her updates have damaged the data code.","Finally, at optional step , snapshot client  executes the relational data code, the configuration data code, and the security data code to reconstruct virtualized computer inventory . In one embodiment, snapshot client  routes the code to VM management center  for execution. Accordingly, any updates made to the relational data code, the configuration data code, and\/or the security data code are reflected when the virtualized computer inventory  is reconstructed, as described below in conjunction with .",{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 6","b":["600","600","602","602","604","612","604","606","608","610","612","614","614","616","618","620"]},"To perform the partial reconstruction of inventory , a snapshot of virtualized computer inventory  is first generated according to method  described above in conjunction with . Next, data code is generated based on the snapshot and optionally edited by a user according to method  described above in conjunction with . In the example shown in , portions of the data code that would otherwise, when executed, cause cluster  and all entities included therein to be reconstructed, are removed from the data code. Accordingly, reconstructed virtualized computer inventory \u2032 does not include cluster , as intended by the user.","As set forth above, one or more embodiments of the invention set forth a programmatic method for archiving and reconstructing a virtualized computer inventory, in whole or in part. Advantageously, such archiving and reconstruction may be used, e.g., for disaster recovery, where periodic archiving is executed such that multiple versions of a virtualized computing inventory may be immediately reconstructed. First, a VM management center is queried to retrieve and store relationships between various entities, the permissions and roles associated with those entities, and the configuration settings of those entities. From this stored data, code for reconstructing the entire inventory of the virtualized computer system is generated. The code is generated in user-editable format to enable administrators to customize the inventory that is reconstructed from the code. The archiving and storing further allows efficient creation of production inventories from development inventories.","In some cases, a reconstruction of an inventory may undergo one or more errors that result in the reconstructed inventory not being identical to the original inventory. Such errors may occur, for example, if one or more portions of the code used in the reconstruction fail to execute properly. Therefore, embodiments of the invention also include a programmatic method for verifying that the reconstructed inventory is identical to the original inventory. These embodiments are described in further detail below in conjunction with , - and A-B.",{"@attributes":{"id":"p-0065","num":"0064"},"figref":["FIG. 7","FIGS. 3-4","FIGS. 1-2"],"b":["700","700"]},"As shown, method  begins at step , where snapshot client  generates a first mapping table of explicit paths of entities included in the original inventory from a snapshot of the original inventory. In one embodiment, to create the first mapping table, snapshot client  accesses the snapshot of the source inventory in which entities are organized as a linked list and traverses the linked list, as described above in conjunction with . As described above, each node in the linked list represents a different entity in the source inventory, and each edge that links two nodes represents the topological path between the two nodes.","The structure of the first mapping table is now described. Each entry in the first mapping table corresponds to a different entity and includes a first field that stores a complete path to the entity and a second field that stores configuration data associated with the entity. For example, referring to , the explicit path of a VM named \u201cfoo\u201d is \u201c\/Data_Center_A\/VM_Folder_A\/foo\u201d, and the explicit path of a resource pool named \u201cRP1\u201d is \u201c\/Data_Center_A\/Host_Folder_A\/Cluster_A\/RP1. An example of the first mapping table is illustrated in Table 1.",{"@attributes":{"id":"p-0068","num":"0067"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Explicit Path","Entity Data"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\/Data_Center_A\/VM_Folder_A\/foo","{VM:foo}"]},{"entry":["\/Data_Center_A\/VM_Folder_A\/bar","{VM:bar}"]},{"entry":["\/Data_Center_A\/VM_Folder_B\/zoo","{VM:zoo}"]},{"entry":["\/Data_Center_A\/Host_Folder_A\/Cluster_A\/RP_1","{RP:RP_1}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"At step , snapshot client  generates a second mapping table of explicit paths of entities included in the reconstructed inventory from a snapshot of the reconstructed inventory. An example of the second mapping table is illustrated in Table 2, where the contents of Table 2 are the same as Table 1, but are ordered differently.",{"@attributes":{"id":"p-0070","num":"0069"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Explicit Path","Entity Data"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\/Data_Center_A\/VM_Folder_A\/foo","{VM:foo}"]},{"entry":["\/Data_Center_A\/Host_Folder_A\/Cluster_A\/RP_1","{RP:RP_1}"]},{"entry":["\/Data_Center_A\/VM_Folder_A\/bar","{VM:bar}"]},{"entry":["\/Data_Center_A\/VM_Folder_B\/zoo","{VM:zoo}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"At step , snapshot client  determines whether the explicit path of each entity in the first mapping table matches the explicit path of a corresponding entity in the second mapping table, and vice-versa. In one embodiment, to execute step , snapshot client  parses the first mapping table in a contiguous, row-by-row manner, and locates for each row in the first mapping table a corresponding row in the second mapping table. If snapshot client  determines that, for one or more rows in the first mapping table, no corresponding row is included in the second mapping table, then method  proceeds to step , where snapshot client  returns an error message. In some embodiments, the error message may include a detailed description of any discrepancies identified by snapshot client  at step . For example, if Table 2 were to instead include an explicit path of \u201c\/Data_Center_A\/VM_Folder_A\/zoo\u201d for the VM \u201czoo\u201d, then it is determined that the VM \u201czoo\u201d was placed into the incorrect VM folder \u201cVM_Folder_A\u201d in the reconstructed inventory. As indicated above, snapshot client  also determines whether the explicit path of each entity in the second mapping table matches the explicit path of each corresponding entity in the first mapping table. In this way, snapshot client  may effectively determine whether additional entities are improperly included in the reconstructed inventory, e.g., a resource pool that was added twice as a result of erroneous reconstruction code being executed. Moreover, the techniques described above account for each of the linked lists being ordered differently, which may occur as a result of the snapshot of the original inventory and the snapshot of the reconstructed inventory being generated at different times, or according to varying techniques. Assuming, therefore, that snapshot client  determines that the explicit path of each entity in the first mapping table matches the explicit path of each corresponding entity in the second mapping table, and vice-versa, then method  proceeds to step .","In some cases, an entity may not have an explicit path to another entity. For example, a virtual machine that is not included in a VM folder (i.e., an explicit parent) may be included in a vApp (i.e., an implicit parent). As described above, snapshot client  is configured to also analyze the implicit path of each entity. Accordingly, at step , snapshot client  generates a third mapping table of implicit paths of entities included in the original inventory from the snapshot of the original inventory.","In one embodiment, snapshot client  generates both the third mapping table and a fourth mapping table (described below at step ) in a manner similar to method steps - described above, respectively. In one example, in a virtualized computing inventory managed by vSphere\u2122, the explicit parent for a VM is a VM folder, whereas the implicit parent for a VM can be a resource pool or a vApp. For example, snapshot client , when encountering a node that is representative of a VM, may determine that the implicit path of the VM is a resource pool named \u201cRP1\u201d. An example of the third mapping table is illustrated in Table 3.",{"@attributes":{"id":"p-0074","num":"0073"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 3"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Implicit Path","Entity Data"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/Data_Center_A\/VM_Folder_A\/foo","{RP:RP_1}"]},{"entry":[{},"\/Data_Center_A\/VM_Folder_A\/bar","{RP:RP_1}"]},{"entry":[{},"\/Data_Center_A\/VM_Folder_A\/zoo","{RP:RP_2}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"At step , snapshot client  generates a fourth mapping table of implicit paths of entities included in the reconstructed inventory from the snapshot of the reconstructed inventory.",{"@attributes":{"id":"p-0076","num":"0075"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 4"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Implicit Path","Entity Data"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/Data_Center_A\/VM_Folder_A\/foo","{RP:RP_1}"]},{"entry":[{},"\/Data_Center_A\/VM_Folder_A\/zoo","{RP:RP_2}"]},{"entry":[{},"\/Data_Center_A\/VM_Folder_A\/bar","{RP:RP_1}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"At step , snapshot client  determines whether the implicit path of each entity in the third mapping table matches the implicit path of a corresponding entity in the fourth mapping table, and vice-versa. If, at step , snapshot client  determines that the implicit path of each entity in the third mapping table matches the implicit path of a corresponding entity in the fourth mapping table, then method  proceeds to step . Otherwise, method  proceeds to step , where snapshot client  returns an error message that indicates any discrepancies identified at step .","As described above, method steps - involve verifying implicit relationships of entities between both the original inventory and the reconstructed inventory. It is noted that, even if an entity does not have an explicit relationship, method steps - are nonetheless executed by snapshot client  to perform an implicit relationship comparison.","The foregoing techniques involve verifying topology settings of all entities included in the reconstructed inventory match the topology settings of all corresponding entities included in the original inventory. However, in some embodiments, snapshot client  may be configured to verify only a subset of entities included in the reconstructed inventory against a subset of corresponding entities included in the original inventory.",{"@attributes":{"id":"p-0080","num":"0079"},"figref":["FIG. 8","FIGS. 1-2"],"b":"800"},"As shown, method  begins at step , where snapshot client  generates a first mapping table of configuration settings for entities included in the original inventory from a snapshot of the original inventory. In one embodiment, snapshot client  may, in lieu of generating the first mapping table of configuration settings, refer back to the first mapping table of explicit paths generated at step  in , which includes, in the second column, configuration data associated with each entity in the original inventory.","At step , snapshot client  generates a second mapping table of configuration settings for entities included in the reconstructed inventory from a snapshot of the reconstructed inventory. Again, snapshot client  may, in lieu of generating the second mapping table of configuration settings, refer back to the second mapping table of explicit paths generated at step  in , which includes, in the second column, configuration data associated with each entity in the reconstructed inventory.","At step , snapshot client  determines whether the configuration settings of each entity in the first mapping table match the configuration settings of each corresponding entity in the second mapping table. In one example, a cluster entity may be associated with high-availability settings and power-management settings that are included in the configuration data associated with the cluster.","In one embodiment, to execute step , snapshot client  parses the first mapping table in a contiguous, row-by-row manner, and locates for each row a corresponding row in the second mapping table. Snapshot client  then compares the configuration data of each entity. In some embodiments, snapshot client  implements a comparator interface that parses each configuration attribute to ensure that they completely match. For example, snapshot client  may verify each attribute between a VM in a reconstructed inventory and a VM in an original inventory while ignoring a unique ID associated with the VM, since the unique IDs of the VMs would likely be different across the reconstructed inventory and the original inventory. In some embodiments, snapshot client  is configured to also compare the configuration settings of each entity in the second mapping table to make sure they match the configuration settings of each corresponding entity in the first mapping table, to ensure that additional configuration settings were not erroneously established when reconstructing the reconstructed inventory.","In some cases, configuration data of an entity may require snapshot client  to execute analysis that extends beyond the configuration data itself. For example, a vApp may be composed of two or more VMs, where the vApp relies on a particular bootup order of the two or more VMs that is specified in the vApp's configuration settings. Thus, snapshot client  is required to verify not only the bootup order configuration of the VMs included in the vApp, but also to verify that the VMs are included in the reconstructed inventory and are in the appropriate location(s).","Consider, for example, that the vApp is composed of two VMs: a first VM with a unique identifier \u201cvm-123\u201d and named \u201cfoo\u201d, and a second VM with a unique identifier \u201cvm-456\u201d and named \u201cbar\u201d. Further, consider that, in the original inventory, the corresponding vApp is composed of two VMs: a first VM with a unique identifier \u201cvm-245\u201d and named \u201cfoo\u201d, and a second VM with a unique identifier \u201cvm-576\u201d and named \u201cbar\u201d. To compare the configuration settings of the entities across the original inventory and the reconstructed inventory, snapshot client  may use the unique identifier of each VM to look up the VM's explicit path, which is stored in Table 1 and\/or Table 2. Accordingly, because snapshot client  has access to the explicit paths of each VM included the vApp, snapshot client  can also verify that the VMs are included in the reconstructed inventory, thereby ensuring that the vApp will be able to boot properly. Any other configuration data of other types of entities that utilize entity IDs is verified by snapshot client  in a similar manner.","Referring back now to step , if snapshot client  determines that the configuration settings of each entity in the first mapping table match the configuration settings of each corresponding entity in the second mapping table, then method  ends. Otherwise, at step , snapshot client  returns an error message according to the techniques described herein.",{"@attributes":{"id":"p-0088","num":"0087"},"figref":["FIG. 9","FIGS. 1-2"],"b":["900","900","902","116"]},"In one embodiment, both the snapshot of the original inventory and the snapshot of the reconstructed inventory include a set of roles, where each role defines one or more users allowed to perform the role, a description of the role (i.e., a permission), and a set of one or more entities to which the role applies. For example, in the snapshot of the reconstructed inventory, a role included in the set of roles may specify that a given user \u201cuser A\u201d may power-on VM \u201cVM_B\u201d. In this example, the role allows the power-on operation to be applied to entity \u201cVM_B\u201d by user \u201cuser A.\u201d","To verify that the set of roles included in the original inventory matches the set of roles included in the reconstructed inventory, at step , snapshot client  sets, as a current role, a first role included in a set of roles stored in the first snapshot.","At step , snapshot client determines whether a role that corresponds to the current role is included in a set of roles stored in the second snapshot. In one embodiment, each role is associated with an identifier that is unique to the inventory in which the role is included, e.g., the reconstructed inventory. Thus, similar to the mapping between the unique ID of a VM and the name of the VM, there is a mapping between the unique ID of each role and the name of the role. Accordingly, to ensure that the set of roles matches between the original inventory and the reconstructed inventory, snapshot client  traverses the unique ID to name mapping of each role to determine whether the basic configuration for each role is the same across the original inventory and the reconstructed inventory, e.g., the one or more users allowed to perform the role, the description of the role, and the set of one or more entities to which the role applies.","If, at step , snapshot client  determines that a role that corresponds to the current role is included in a set of roles stored in the second snapshot, then method  proceeds to step . Otherwise, method  proceeds to step , and snapshot client  returns an error message indicating that the set of roles are not equivalent between the original inventory and the reconstructed inventory.","At step , snapshot client  determines whether all attributes of the role match all attributes of the current role. If, at step , snapshot client  determines that all attributes of the role match all attributes of the current role, then method  proceeds to step . Because some roles may apply to a group of entities, and the entities are stored by entity ID, snapshot client  is also configured to traverse the entity unique ID to name mapping, as described above in conjunction with , and use that name to ensure that the entities referred to by the current role are, in fact, the same entities referred to by the role.","At step , snapshot client  determines whether additional roles included in the set of roles are stored in the first snapshot. If, at step , snapshot client  determines that additional roles included in the set of roles are stored in the first snapshot, then method  proceeds to step .","At step , snapshot client  sets, as the current role, a next role included in the set of roles stored in the first snapshot. In this way, snapshot client  accounts for each of the roles included in the first snapshot, thereby verifying that the reconstructed inventory does, in fact, include the appropriate roles. As described herein, snapshot client  may repeat method steps  by instead parsing the roles included in the second snapshot and comparing each role to a corresponding role in the first snapshot, which allows snapshot client  to identify any roles that should not be included in the reconstructed inventory.",{"@attributes":{"id":"p-0096","num":"0095"},"figref":["FIGS. 10A-10B","FIGS. 1-2"],"b":"1000"},"In particular, snapshot client  is configured to verify the correctness of custom fields according to techniques similar to those described above in conjunction with . More specifically, each of the snapshot of the original inventory and the snapshot of the reconstructed inventory includes a mapping table of custom field definitions to entity types. For example, in vSphere\u2122, the name of a custom field \u201cdescription\u201d applies to all VMs included in the inventory. Table 5 illustrates an example mapping of custom field definitions to entity types. The first row shows the \u201cDescription\u201d custom field, which applies to all entities in the inventory. The second row shows the \u201cAlias\u201d custom field, which applies only to VMs in the inventory.",{"@attributes":{"id":"p-0098","num":"0097"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 5"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Custom Field Type","Entity Data"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Description","{All Entities}"]},{"entry":[{},"Alias","{VMs}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Accordingly, each entity includes in its configuration settings a value for the custom field definitions with which the entity is associated. As a result, there exists in each of the first and second snapshots an additional table for mapping entities to the appropriate values for these custom fields. Table 6 illustrates an example of such a mapping.",{"@attributes":{"id":"p-0100","num":"0099"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 6"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Entity","Custom Field Value(s)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["{VM:foo}","{Description: \u201cExch_Server\u201d, Alias: \u201cTom's_DB\u201d}"]},{"entry":["{RP:RP_1}","{Description: \u201cMain Resource Pool\u201d}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Accordingly, snapshot client  is configured to verify that each of the custom field definitions matches across the original inventory and the reconstructed inventory, and that each of the custom field definitions apply to the same entity types, described below in method steps -. Snapshot client is also configured to traverse each entity and convert the unique ID associated therewith to the corresponding explicit path in order to ensure that that the values for the custom fields are correct, which is described below in method steps -.","As shown, method  begins at step , where snapshot client  receives a first snapshot of an original inventory and a second snapshot of a reconstructed inventory. At step , snapshot client  sets, as a current custom field definition (CFD), a first CFD included in a set of CFDs stored in the first snapshot. At step , snapshot client  determines that a CFD that corresponds to the current CFD is included in a set of CFDs stored in the second snapshot. Otherwise, at step , snapshot client  returns an error message. At step , snapshot client  determines that the CFD matches the current CFD. Otherwise, at step , snapshot client  returns an error message. At step , snapshot client  determines that additional CFDs included in the set of CFDs stored in the first snapshot. Otherwise, at step , snapshot client  returns an error message.","At step , snapshot client  sets, as the current CFD, a next CFD included in the set of CFDs stored in the first snapshot, and method steps - are repeated until each of the CFs stored in the first snapshot are analyzed by snapshot client . In this way, snapshot client  accounts for each of the custom field definitions included in the first snapshot, thereby verifying that the reconstructed inventory does, in fact, include the same custom field definitions.","Turning now to , at step , snapshot client  sets, as a current custom field (CF), a first CF included in a set of CFs stored in the first snapshot. At step , snapshot client  determines that a CF that corresponds to the current CF is included in a set of CFs stored in the second snapshot. Otherwise, at step , snapshot client  returns an error message. At step , snapshot client  determines that the CF matches the current CF. Otherwise, at step , snapshot client  returns an error message. At step , snapshot client  determines that additional CFs included in the set of CFs stored in the first snapshot. At step , snapshot client  returns an error message.","At step , snapshot client  sets, as the current CF, a next CF included in the set of CFs stored in the first snapshot, and method steps - are repeated until each of the CFs stored in the first snapshot are analyzed by snapshot client . In this way, snapshot client  accounts for each of the custom field values of entities included in the first snapshot, thereby verifying that each entity in the reconstructed inventory is, in fact, associated with the same custom field values.","The various embodiments described herein may employ various computer-implemented operations involving data stored in computer systems. For example, these operations may require physical manipulation of physical quantities\u2014usually, though not necessarily, these quantities may take the form of electrical or magnetic signals, where they or representations of them are capable of being stored, transferred, combined, compared, or otherwise manipulated. Further, such manipulations are often referred to in terms, such as producing, identifying, determining, or comparing. Any operations described herein that form part of one or more embodiments of the invention may be useful machine operations. In addition, one or more embodiments of the invention also relate to a device or an apparatus for performing these operations. The apparatus may be specially constructed for specific required purposes, or it may be a general purpose computer selectively activated or configured by a computer program stored in the computer. In particular, various general purpose machines may be used with computer programs written in accordance with the teachings herein, or it may be more convenient to construct a more specialized apparatus to perform the required operations.","The various embodiments described herein may be practiced with other computer system configurations including hand-held devices, microprocessor systems, microprocessor-based or programmable consumer electronics, minicomputers, mainframe computers, and the like.","One or more embodiments of the present invention may be implemented as one or more computer programs or as one or more computer program modules embodied in one or more computer readable media. The term computer readable medium refers to any data storage device that can store data which can thereafter be input to a computer system\u2014computer readable media may be based on any existing or subsequently developed technology for embodying computer programs in a manner that enables them to be read by a computer. Examples of a computer readable medium include a hard drive, network attached storage (NAS), read-only memory, random-access memory (e.g., a flash memory device), a CD (Compact Discs)\u2014CD-ROM, a CD-R, or a CD-RW, a DVD (Digital Versatile Disc), a magnetic tape, and other optical and non-optical data storage devices. The computer readable medium can also be distributed over a network coupled computer system so that the computer readable code is stored and executed in a distributed fashion.","Although one or more embodiments of the present invention have been described in some detail for clarity of understanding, it will be apparent that certain changes and modifications may be made within the scope of the claims. Accordingly, the described embodiments are to be considered as illustrative and not restrictive, and the scope of the claims is not to be limited to details given herein, but may be modified within the scope and equivalents of the claims. In the claims, elements and\/or steps do not imply any particular order of operation, unless explicitly stated in the claims.","Virtualization systems in accordance with the various embodiments, may be implemented as hosted embodiments, non-hosted embodiments or as embodiments that tend to blur distinctions between the two, are all envisioned. Furthermore, various virtualization operations may be wholly or partially implemented in hardware. For example, a hardware implementation may employ a look-up table for modification of storage access requests to secure non-disk data.","Many variations, modifications, additions, and improvements are possible, regardless the degree of virtualization. The virtualization software can therefore include components of a host, console, or guest operating system that performs virtualization functions. Plural instances may be provided for components, operations or structures described herein as a single instance. Finally, boundaries between various components, operations and data stores are somewhat arbitrary, and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of the invention(s). In general, structures and functionality presented as separate components in exemplary configurations may be implemented as a combined structure or component. Similarly, structures and functionality presented as a single component may be implemented as separate components. These and other variations, modifications, additions, and improvements may fall within the scope of the appended claims(s)."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4A-4D"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 5A-5C"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIGS. 10A-10B"}]},"DETDESC":[{},{}]}
