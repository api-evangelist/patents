---
title: Generation of Administration framework for server systems
abstract: A generator mechanism for generating an administration framework for server systems. In one embodiment, the administration framework may be generated from meta-information that describes elements of configuration data and relationships among the elements. The mechanism may provide automatic generation of the administration framework. In one embodiment, the administration framework may be a stack on an administration server that includes several layers each including one or more generated components. In one embodiment, the generation mechanism may generate management beans of a management layer, representing business logic of the server; configuration beans of a data representation layer; and a presentation layer for accessing and administering generated components. The data representation layer may provide transparency to the persistent store for the other layers. A production generation of the administration framework may be performed and instances of generated components may be deployed on other servers.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07412497&OS=07412497&RS=07412497
owner: Sun Microsystems, Inc.
number: 07412497
owner_city: Santa Clara
owner_country: US
publication_date: 20020725
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF EMBODIMENTS OF THE INVENTION","CONCLUSION"],"p":["1. Field of the Invention","This invention relates to computer networks, and more particularly to a dynamic administration framework for distributed server systems.","2. Description of the Related Art","An application server is a server program in a computer in a distributed network that provides the business logic for an application program. The application server is frequently viewed as part of a three-tier application, consisting of a graphical user interface (GUI) server, an application (business logic) server, and a database server. More descriptively, it can be viewed as dividing an application into:\n\n","Older, legacy application databases and transaction management applications are part of the back end or third tier. The application server is the middleman between browser-based front-ends and back-end databases and legacy systems.","A Web server is a program that, using the client\/server model and the World Wide Web's Hypertext Transfer Protocol (HTTP), serves the files that form Web pages to Web users (whose computers contain HTTP clients that forward their requests). Every computer on the Internet that contains a Web site must have a Web server program.","In servers based on the J2EE (Java 2 Platform, Enterprise Edition) distributed computing model, the business presentation is typically represented using servlets and\/or Java Server Pages (JSPs), and the business logic typically runs in the form of distributed components such as Enterprise JavaBeans (EJBs).","J2EE (Java 2 Platform, Enterprise Edition) is a Java platform designed for the mainframe-scale computing typical of large enterprises. Sun Microsystems (together with industry partners such as IBM) designed J2EE to simplify application development in a thin client tiered environment. J2EE simplifies application development and decreases the need for programming and programmer training by creating standardized, reusable modular components and by enabling the tier to handle many aspects of programming automatically. J2EE includes a number of components, including:\n\n","The J2EE Application Programming Model is the standard programming model used to facilitate the development of multi-tier, thin client applications. The J2EE Platform includes policies and APIs such as the Java servlets and Java Message Service (JMS).","The Sun\u2122 One Application Server provides a robust J2EE e-commerce platform for the development, deployment, and management of application services to a broad range of servers, clients, and devices. The Sun\u2122 One Application Server maximizes application re-use and developer collaboration and demonstrates the potential of leveraging Java for large-scale web and wireless applications.","The Sun\u2122 One Web Server is a software product for developers engaged in building dynamic Web applications for e-commerce sites. Multiplatform support makes it possible for developers to work in the operating system environment of their choice. The product works with Java\u2122 Servlet and JavaServer Pages\u2122 technologies to generate personalized content and speed development. Its centralized server management, content management, and rapid application development features combine to deliver a powerful means for enterprises to move their businesses to the Internet.","Java\u2122 Management Extensions (JMX) is an open technology for management and monitoring for deployment across industries wherever management and\/or monitoring may be needed or desired. JMX may be used, for example, for adapting legacy systems, implementing new management and monitoring solutions and plugging into future solutions. JMX may provide tools for building distributed, Web-based, modular and dynamic solutions for managing and monitoring devices, applications and service-driven networks.","A bean may be defined as a component, a reusable program building block that may be combined with other components in the same or other computers in a distributed network to form an application. Examples of components include, but are not limited to, buttons in a graphical user interface and interfaces to a database manager. Components may be deployed on different servers in a network and may communicate with each other for needed services. A component may run within a context called a container. Examples of containers include, but are not limited to, pages on a Web site, Web browsers, and word processors.","A managed bean, or MBean, is a Java object that represents a JMX manageable resource. MBeans may follow the JavaBeans\u2122 components model, thus providing a direct mapping between JavaBeans components and manageability. Because MBeans provide instrumentation of managed resources in a standardized way, they can be plugged into any JMX agent.","The open source schema2beans library (schema2beans jar file) allows the generation of a set of java bean classes from a DTD or XML Schema file. This set of beans may be used to represent an XML file as a graph of java beans. Elements of the graph may be added, changed and\/or removed, graphs may be merged and compared, and events may be generated and obtained on any change in the graph. The graph may be written back as a DTD or XML Schema file. The package of this library is includes a schema2beans runtime and schema2beans generator, both part of the same schema2beans jar file.","XPath is a language that describes a way to locate and process items in documents (e.g. Extensible Markup Language (XML) documents) by using an addressing syntax based on a path through the document's logical structure or hierarchy. This makes writing programming expressions easier than if each expression had to understand typical XML markup and its sequence in a document. XPath also allows the programmer to deal with the document at a higher level of abstraction. XPath is a language that is used by and specified as part of both the Extensible Stylesheet Language Transformations (XSLT) and by XPointer (SML Pointer Language). It uses the information abstraction defined in the XML Information Set (Infoset). Since XPath does not use XML syntax itself, it may be used in contexts other than those of XML.","A generator mechanism that may be used to generate an administration framework for server systems such as application and web server systems is described. In one embodiment, the administration framework may be generated from meta-information that describes elements or properties of configuration data, and that may describe relationships (e.g. hierarchical relationships) among the elements of the configuration data. During development, configuration data, and thus the meta-information describing the configuration data, may be changed. The generation mechanism may provide an automatic way to generate the administration framework rather than having to manually make changes to the administration framework to support changes in configuration data. In one embodiment, XML may be used as a data representation language for the meta-information.","The meta-information may include a representation of the elements and element attributes of a persistent store of configuration information. The meta-information may be represented in formats including, but not limited to, markup languages such as XML, schemas, DTDs, etc. In one embodiment, all meta-information may be contained in one file (e.g. an XML file or a schema file). In one embodiment, the meta-information file may be generated by a user or users, for example a server system designer or developer, to describe the elements of configuration data of the server system and the relationships among the described elements. In one embodiment, the meta-information may be accessed by administration framework generator(s) to generate components of the administration server to be used at runtime for monitoring and managing the system.","In one embodiment, the administration framework may be a stack implemented on an administration server that includes several layers each including one or more components. At least a portion of each of these layers may be generated by the generation mechanism from the meta-information. In one embodiment, the generation mechanism may generate one or more management beans (e.g. MBeans) of a management layer, each representing business logic of the server. In one embodiment, the generation mechanism may generate one or more configuration beans of a data representation layer. In one embodiment, the generation mechanism may generate one or more components of a presentation layer (e.g. an administration user interface (UI)) for use in displaying, locating, accessing, managing and modifying configuration elements and\/or attributes as represented in the configuration beans.","At runtime, the generated administration UI of the presentation layer may be used to access the management layer (e.g. management beans) to perform administration, monitoring and configuration operations. The management layer may access the data representation layer (e.g. configuration beans) to access the server configuration information. The data representation layer may abstract the other layers from the persistent store, and thus may provide data storage format and location transparency to the persistent store for the other layers.","In one embodiment, when the system is ready to go from development to a production environment, a production generation of the administration framework may be performed and the system may be deployed. In one embodiment, deployment may include implementing instances of components generated on the administration server (e.g. the configuration beans representing the configuration information and the management beans implementing the business logic) on one or more other servers (e.g. application servers) to which the server system is to be deployed. The server components may then access the management beans and the in-memory representation of the configuration information (e.g. the configuration beans) to perform server tasks.","While the invention is described herein by way of example for several embodiments and illustrative drawings, those skilled in the art will recognize that the invention is not limited to the embodiments or drawings described. It should be understood, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims. The headings used herein are for organizational purposes only and are not meant to be used to limit the scope of the description or the claims. As used throughout this application, the word \u201cmay\u201d is used in a permissive sense (i.e., meaning having the potential to), rather than the mandatory sense (i.e., meaning must). Similarly, the words \u201cinclude\u201d, \u201cincluding\u201d, and \u201cincludes\u201d mean including, but not limited to.","Embodiments of a dynamic administration framework for server systems such as application and web server systems are described. Embodiments may address the generation as well as the runtime behavior of the administration framework and one or more of its components. Given meta-information that describes a system, a generation mechanism may generate one or more of the components of the administration framework for administration of that system. In one embodiment, the generated components may include components that are implemented as Java beans. In one embodiment, at least a portion of the generated components may include, but are not limited to, one or more of program (e.g. business) logic for the server(s) and access functions for accessing configuration information of the server system. In one embodiment, the administration framework may include an administration user interface (UI) that may be generated from the meta-information and that may be used to manage and monitor components of the generated administration framework.","In one embodiment, generated components of the administration framework may include an in-memory representation of configuration information for the server system. In one embodiment, the in-memory representation of configuration information may include a plurality of components (e.g. beans) generated from the meta-information. In one embodiment, each of the plurality of components included in the in-memory representation of configuration information may represent an element of the configuration information; each of these components may be located and accessed to access the corresponding configuration element.","\u201cIn-memory\u201d is used herein to distinguish representations of the configuration information on the server(s) in a server system from the backend storage of the configuration information. The in-memory representation of the configuration information may be used, for example, during development of the server system and\/or during runtime of the server system. The in-memory representation may be stored in various memory media of a server including one or more of, or a combination of, RAM (e.g. SDRAM, DDR SDRAM, RDRAM, SRAM, etc.), ROM, and local storage devices such as disks. For example, in a system supporting virtual memory, a portion of the in-memory representation may be stored in active storage (e.g. RAM) and other portions may be stored in or \u201cswapped out\u201d to hard disk or other high volume storage devices.","During development, configuration data, and thus the meta-information describing the configuration data, may be changed. The generation mechanism as described herein may provide an automatic way to generate the administration framework rather than having to manually make changes to the administration framework to support changes in configuration data. If an element or attribute changes, the generation mechanism may provide an automatic method to update the administration framework rather than having to locate and make changes to every instance of the element or attribute manually.","Embodiments of the administration framework may provide storage transparency to the backend storage of configuration data. Backend storage of configuration information for a system (which may be referred to as a persistent store) may be distributed across one or more data storage devices, and may be formatted in accordance with one of a variety of heterogeneous data storage formats (e.g. file-based, LDAP, etc.). The data storage format and\/or distribution of the persistent store may be changed, for example to meet changing requirements of the system. Through storage transparency, frontend clients may access the persistent store of configuration data independent of the distribution and\/or data storage format of the persistent store. In one embodiment, the administration framework may provide a generic application programming interface (API) that provides the storage transparency between the persistent store of configuration information and clients of the persistent store. The API (which may be referred to as a configuration API) may provide a unified view of the persistent store of configuration information, and may provide a generic interface for accessing heterogeneous data storage formats that may be used in the backend storage. Through the generic interface provided by the API, a frontend process or component may access multiple stores on different backend storage devices using a single operation (e.g. a write or a read operation).","One embodiment may include an event notification mechanism that may allow events (e.g. changes in configuration data) to be propagated in a distributed system running several virtual machines (VMs) (e.g. Java Virtual Machines (JVMs)).","One embodiment may provide a generic, pluggable, extensible verification and validation mechanism that may be reusable in stand-alone (off-line) applications and in applications server (on-line).",{"@attributes":{"id":"p-0045","num":"0051"},"figref":["FIGS. 1A and 1B","FIGS. 1A and 1B"]},"In general, a web application may be defined as an Internet or Intranet-based application comprising a collection of resources that are accessible through uniform resource locators (URLs). The resources may include web pages comprising HTML, XML, scripting code such as Javascript or VBScript, or other types of elements. The resources may also include any of various types of executable programs or components, such as CGI programs, Java servlets, JavaBeans components, CORBA components, downloadable code such as Java classes or ActiveX components, etc. The resources may also include any other type of resource addressable through a URL.",{"@attributes":{"id":"p-0047","num":"0053"},"figref":"FIG. 1A","b":"100"},"The web browser may run in any type of client computer . For example, the web browser may run in a desktop computer or workstation running any of various operating systems, such as Windows, Mac OS, Unix, etc., or the web browser may run in a portable computing device, such as a personal data assistant, smart cellular phone, etc. The client computer  may use a network connection for communicating with a web server  via a network , such as the Internet or an Intranet. The client network connection may be a connection of any type, such as a PPP or SLIP dialup link, an Ethernet or token ring connection, an ISDN connection, a cable modem connection, any of various types of wireless connections, etc. Although web applications are often associated with particular communication protocols, such as HTTP or SSL, it is noted that any communication protocol, including TCP-based protocols and UDP-based protocols, may be used to communicate over the network .","As the web server  receives a request from a client computer , the web server may treat the request differently, depending on the type of resource the request references. For example, if the request references a document , such as an HTML document, then the web server may process the request itself, e.g., by retrieving the document from the web server's local file system or from a local cache and returning the document to the client computer. For other types of requests, e.g., requests referencing executable components, such as Java servlets, JavaBeans components, C program modules, CORBA components, etc., the web server  may broker the request to an application server . For example, as shown in , there may be a plurality of application servers  in a cluster, and the web server  may select an application server to which to broker the request, e.g., using load balancing techniques. The web server  may interface with an application server  using various techniques, e.g., through an in-process extension, such as an ISAPI or NSAPI extension.","The application server  may be configured as a part of an application server cluster. Although  illustrates an application server cluster with only two application servers, it is noted that the cluster may comprise any number of application servers. Each application server  may interface with various types of other servers or systems. For example, as illustrated in , the application servers  may communicate with a database . Each application server  in the cluster may interface with the same systems, or the application servers  may differ in which systems they interface with. For example, application server B is shown to interface with a backend system , e.g., a CICS, R\/3, PeopleSoft, or other type of backend system. For example, the backend system  may be responsible for managing enterprise data or performing business functions for an enterprise.","Application servers  in a cluster may or may not be in close physical proximity to each other. The application server computers may be connected to each other in any of various ways. For example, in one embodiment, each application server computer may be a member of a single local area network (LAN). In another embodiment, various of the application server computers may be located in two or more LANs, wherein the LANs are networked together.","While  illustrates web server  and application servers  as implemented on different computing devices, it is noted that in various embodiments one or more web servers  and one or more application servers  may be implemented in software on a computing device. For example, web server  and application server B may be implemented on a single computing device. In some embodiments, one or more web servers  and\/or one or more application servers  may be implemented on virtual machines (VMs) (e.g., Java Virtual Machines (JVMs)). The virtual machines may be implemented on one or more computing devices. For example, in , web server  and application servers A and B may each be implemented in a separate virtual machine, or alternatively one or more of the servers may be implemented in a single virtual machine.","In alternative embodiments, as illustrated in , a client computer  may communicate directly with an application server  or application server cluster, without interfacing through a web server. As one example, the application servers  may run an enterprise resource planning application, and the client computers  may be computers within the enterprise that are connected to the application servers  via a WAN. In this example, the client computers may run \u201cthick client\u201d software, e.g., client software that comprises a portion of the enterprise resource planning application logic. The client computer software may interface directly with executable programs or components running on the application servers, e.g., through a protocol such as the Internet Inter-Orb Protocol (IIOP).","As noted above,  represent exemplary architectures only, and many variations are possible. As a small handful of examples of alternative embodiments, multiple web servers may be present to receive requests from client computers and broker the requests to application servers, the web server may itself interface directly with a database, application servers may interface with various other types of systems, such as specialized authentication servers, e-commerce servers, other types of legacy systems, etc.",{"@attributes":{"id":"p-0055","num":"0061"},"figref":["FIG. 2","FIG. 2","FIG. 2"],"b":["200","204","226","226","204","200","224","226","204","224","222","224","224","200","224","200","224","200","224","200"]},"In one embodiment, all elements or properties of the persistent store  may be represented in one or more meta-information  files (e.g. an XML file). In one embodiment, all elements or properties of the persistent store  may be represented in exactly one meta-information  file (e.g. an XML file). In one embodiment, there may be one such file per server instance in the server system. In one embodiment, XML may be used as a data representation language for the meta-information. The meta-information  may include rules defining the system configuration data. The meta-information may describe elements to be administered and their attributes. For example, an element called \u201cserver\u201d may have attributes such as name, locale(s), log-root, etc. These attributes may have default values described in the meta-information , as well as a list of correct possible values, and in one embodiment may be described as REQUIRED or IMPLIED.","Meta-information  file may include representations of configuration information for the application server . In one embodiment, this configuration information may include server-level configuration information, e.g. information describing data of persistent store  and information describing deployed applications that servers associated with the administration server  may run. In one embodiment, meta-information  may not include application-level configuration data. In one embodiment, the meta-information  may be configuration information in any of different formats including, but not limited to, XML, LDAP, DTD, schema, database-based, and file-based.","In one embodiment, the meta-information  may include server and component configuration information as well as registered application information. In one embodiment, deployed applications may be stored, for example, as jar files, with application configuration info within the jar files (e.g. application.xml, etc). The following illustrates the structure of an exemplary meta-information  file that uses tags (e.g. an XML file), and is not intended to be limiting:",{"@attributes":{"id":"p-0059","num":"0065"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<Domain>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<resources... \/>"]},{"entry":[{},"<Application>"]},{"entry":[{},"..."]},{"entry":[{},"<WebAppComponent>"]},{"entry":[{},"..."]},{"entry":[{},"<EJBComponent>"]},{"entry":[{},"..."]},{"entry":[{},"<\/Application>"]},{"entry":[{},"<Application ... \/>"]},{"entry":[{},"<Server...>"]},{"entry":[{},"<web container>"]},{"entry":[{},"..."]},{"entry":[{},"<etc...>"]},{"entry":[{},"<\/Server>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/Domain>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In one embodiment, there is a hierarchical relationship among the elements of the configuration data. In this embodiment, the elements and their hierarchical relationship are represented in meta-information .","In one embodiment, the meta-information  may be accessed by generator mechanism  to generate beans . Beans  may provide a bean representation of the configuration data of the backend persistent store . In one embodiment, beans  may be generated in a hierarchical relationship to represent a hierarchical relationship of configuration data elements as described in meta-information .","A bean  may include one or more methods for performing business logic of the server system that may perform operations on, or using, one or more elements of the persistent store . A bean may also include \u201cget\u201d and \u201cset\u201d methods for the attributes of the corresponding elements. These generated methods may implement the constraints on the data elements defined in the meta-information . Elements may have sub-elements that may be used to describe hierarchical data of the system. For example, an element \u201cserver\u201d may have sub-elements \u201cweb-container,\u201d \u201cresources,\u201d \u201capplications,\u201d etc. Each of these sub-elements may also have sub-elements and attributes.","In one embodiment, the generator mechanism  may generate a bean  for each corresponding element in meta-information . Beans  may represent every element in the meta-information  file. For example, if there are five elements under the root, there will be five beans representing the elements. In one embodiment, a bean  may include other beans  and\/or references to other beans . In one embodiment, elements have a one-to-one correspondence to generated beans .","In one embodiment, generator mechanism  to generate beans  using the open source schema2beans library. In one embodiment, beans  may be exposed so that the beans may be modified by users.","In one embodiment, the generator mechanism  may generate, from meta-information , one or more bean methods in a bean  to describe the containment relationship between elements. These methods may facilitate adding, removing, and replacing a sub-element, or accessing a sub-element give a primary key, for example. A primary key may be included in the meta-information for each element, and may include one or more of the attributes of the element. For example, the primary key for the \u201cserver\u201d element may be its name, since servers may have different names. Other bean methods may also be generated, for example for getting the number of sub-elements of a certain type (e.g., the number of applications for the server).","In one embodiment, application server may include a configuration API  that may provide an interface to the persistent store  as represented in meta-information , and thus may abstract the persistent store  to provide flexibility of storage and location transparency. In one embodiment, the configuration API  may provide access to the meta-information  file (any element, any attribute). In one embodiment, configuration API  is a generic API. In one embodiment, the core configuration API is not generated by administration framework generator , and may be used \u201cas is\u201d in any of a variety of server applications to provide an interface to persistent stores  in any of a variety of formats. Generated beans and other components may use the configuration API as a generic, transparent access method to the backend storage of the persistent store , independent of the format of the backend storage.","The persistent store  of configuration information may be distributed across one or more data storage devices, and may be formatted in accordance with one of a variety of heterogeneous data storage formats (e.g. file-based, LDAP, etc.). The data storage format and\/or distribution of the persistent store may be changed, for example to meet changing requirements of the system. Through storage transparency, frontend clients may access the persistent store of configuration data independent of the distribution and\/or data storage format of the persistent store. The configuration API may provide a unified view of the persistent store of configuration information, and may provide a generic interface for accessing heterogeneous data storage formats that may be used in the backend storage. Through the configuration API, a frontend process or component may access multiple stores on different backend storage devices using a single operation (e.g. a write or a read operation).","In one embodiment, the configuration API  may provide storage transparency. The backend storage (persistent store ) may be changed without requiring change to the generated front end provided by the administration framework. For example, if the backend storage format of the persistent store  is changed (e.g. from file-based to LDAP), the administration framework may not need to be regenerated. The context may be changed inside the configuration API  (for example, one or more different storage adapters  may be plugged in to support the new backend format), and the changed persistent store  may be accessed by the previously generated administration framework through the configuration API .","The configuration API  may provide a generic interface to manage (e.g. create, read, validate, write and\/or delete) the system configuration information of persistent store  as represented in meta-information  and the generated beans . The administration framework, through the configuration API , may be independent of the technology used in the persistent store . The generated administration framework and its components may use the configuration API  to provide support for any type of persistent store . For example, the persistent store  may be an XML file, an object database, a relational database or any other type of file-based or database repository.","Clients of the configuration API  may do a lookup using the configuration API  to get an in-memory representation of the corresponding configuration data from persistent store . This data for may be, for example, a representation of a Java Properties file, an XML file or other file including configuration information. The configuration API's clients may include one or more of, but are not limited to, an administration server, a deployment backend, and the containers that comprise the server. The deployment backend may register applications and\/or modules and then register the URLs of those applications and\/or modules. The configuration API  supports the deployment backend by providing the ability to store these values in the meta-information file, enabling containers (e.g. EJB containers) and other entities to query for them.","The configuration API  may include one or more of, but is not limited to, configuration context  which may include beans , a factory for creating the beans, and a mechanism (e.g. XPath) to look up the beans, a notification mechanism, and a change management mechanism. For example, a lookup may be performed on an Xpath expression (e.g. \/server\/container) using XPath. The lookup may return a bean  that represents the ejbcontainer. APIs of beans  returned by a lookup may then be called.","Configuration API  functionality may include, but is limited to, one or more of, basic configuration operations (e.g. set and get elements and attributes APIs), event notification, cloning, bean lookup mechanism (e.g. XPath) support, change management (e.g. add, update, delete, set), read only operations, auto commit, advanced configuration (e.g. one API to access attributes), intelligent refresh, get DTD default values, DOM-like API support (e.g. appendChild, removeChild), finding APIs, serialization and deserialization. The configuration API  may provide support for distributed systems. In one embodiment, the configuration API  may provide hierarchical semantics into the configuration data. The configuration API  may be used to iterate through nodes and navigate to a desired attribute.","In one embodiment, the configuration API  may include configuration context . Configuration context  may provide an interface that includes APIs to read, persist, and access persistent store  data. Configuration context  may provide central in-memory abstraction of the configuration data. Configuration context  may provide an interface to perform accesses (e.g. reads and writes) to the persistent store . Configuration context  may be used by the \u201cabove\u201d layers (e.g. management and data presentation layers) to access persistent store  data. Storage adapters  of configuration API  may be used (and switched) below the configuration to interface to the particular persistent store  format. The configuration context  may be used, for example by containers, to look up configuration data as desired. In one embodiment, configuration context  may be used to write to multiple storages on different machines with a single operation. In one embodiment, a configuration context  may be created for each server during server initialization.","In one embodiment, the generator mechanism  may generate one or more components (e.g. beans ) of configuration context  using meta-information . In one embodiment, configuration context  may be included in configuration API . Configuration context  may include information that represents the meta-information . In one embodiment, at least some of generated beans  may be included as components of the configuration context , and may be used as accessible representations of the meta-information . Beans  in configuration context  may include \u201cget\u201d and \u201cset\u201d methods for the attributes of the corresponding elements. These beans  may also include one or more bean methods that describe the containment relationship between two elements. In one embodiment, configuration context  may include APIs to look up beans  of the configuration context . In this embodiment, beans  including business logic may reside outside of configuration context , and may use the lookup APIs to access the beans  of configuration context .","APIs may be provided to the configuration context  for functions including one or more of, but not limited to: reading from, refreshing, and writing to the persistent store ; tracking and managing changes to the configuration context ; looking up a bean or multiple beans (e.g. using XPath). APIs may also be provided for one or more factory classes for constructing and\/or deleting configuration context  and\/or components of configuration context .","A configuration context  represents a hierarchical view of the configuration attributes from persistent store  as represented in the meta-information file. The configuration context  may read the configuration attributes from the meta-information file. In one embodiment, a configuration factory may be provided to construct a configuration context . The configuration context  may have a one-to-one relationship with the meta-information file.","In one embodiment, the configuration context  may track configuration changes. In one embodiment, the configuration API  may keep track of and otherwise manage changes in the configuration context . One embodiment may provide mechanisms for obtaining or resetting the changes in the configuration context . In one embodiment, the configuration changes may be serialized and sent across to another configuration context (for example, in another VM) to be updated on the other configuration context . In one embodiment, a query language (e.g. XPath) may be used to track where to make the changes.","In one embodiment, the configuration API  may include one or more storage adaptors  that may support multiple accesses in read or write mode to the data of persistent store . The configuration API  may handle concurrent access and may manage and\/or prevent conflicts. In one embodiment, the configuration API  may manage the number of instances of the configuration context  in the server system to prevent the configuration context  from overwriting changes in persistent store . In one embodiment, the configuration API  may detect stale data in the configuration context  due to changes in storage.","One embodiment may provide a change management mechanism. A configuration context  in one server (e.g., a virtual machine (VM) such as a Java Virtual Machine (JVM)) may be modified. The configuration API  may track the changes, and may serialize objects representing the changes and send them \u201cacross wire\u201d to update other configuration contexts  with the information from these serialized objects. Thus, instead of saving changes to persistent store  and reading them back into another VM, configuration contexts  may be updated in memory without going to persistent store .","In one embodiment, the generator mechanism  may generate, from meta-information , an administration user interface (UI)  that provides support for users to administer the system. The administration UI  may be used, for example, for administration of the generated beans . In one embodiment, the generated administration UI  may include one or more servlets for driving the administration UI , and one or more JSPs for each page of the UI. These JSPs may be customized by users if desired.","Embodiments may be used in rapid development environments. In a development project, data representations may change as the project matures. The generation mechanism  as described herein may ease the manual development process and help in keeping the administrative code consistent with the data representation. The automation of change control provided by the generation mechanism  may enable a rapid, flexible development environment. Through the meta-information  file and the framework generator , users who desire to manage server configurations and the developers of the server configurations may not have to manually write management code. In one embodiment, when the product is ready to go from development to a production environment, a production generation of the administration framework may be performed and the system may be deployed.","In one embodiment, meta-information  file may be generated by users of the server system. In one embodiment, the users may represent the configuration information in the meta-information  in a desired format, and the framework generator  may generate one or more components of the administration framework. Once the administration framework is generated, the administration framework may be compiled with application server or system-specific components.","The compiled system may then be used at runtime. A user may access the generated administration UI , for example to edit a user property. The property may be changed using the UI. The administration UI  may then locate and access one or more beans  to access the user property. The one or more beans may then use the generic interface provided by the configuration API  to access and, if needed or desired, modify the property in persistent store .",{"@attributes":{"id":"p-0084","num":"0090"},"figref":"FIG. 3","b":["212","200","222","206","210","204","216","200"]},{"@attributes":{"id":"p-0085","num":"0091"},"figref":"FIG. 3","b":["226","204","200","224","226","204","224","222"]},"In one embodiment, all elements or properties of the persistent store  may be represented in one meta-information  file (e.g. an XML file). The meta-information may describe elements to be administered and their attributes. The meta-information  may be used, for example, by the generator mechanism  to generate components including, but not limited to, one or more of configuration beans , management beans , and components of administration UI .",{"@attributes":{"id":"p-0087","num":"0093"},"figref":"FIG. 4","b":["200","202","202","200","200"]},"A server system may include a persistent store  that includes configuration information for one or more server instances such as application servers A and B and an administration server . In one embodiment, the configuration information may include information that is common to the server instances. The server instances may be viewed as clients of the persistent store .","In one embodiment, the administration framework generation mechanism as described herein may be used during the development process. In one embodiment, a meta-information file may be generated by users of the server system. In one embodiment, the users may represent the configuration information in the meta-information file in a desired format, and the framework generator may generate one or more components of the administration framework. Once the administration framework is generated, the administration framework may be compiled with application server or system-specific components.","In one embodiment, when the system is ready to go from development to a production environment, a production generation of the administration framework may be performed and the system may be deployed. Deployment may include implementing beans  and configuration context  on servers  to which the server system is to be deployed. Each server  may include server components  (e.g. applications provided by the servers ) which may access configuration data managed in memory by configuration context  via beans .","Embodiments of the dynamic administration framework as described herein may provide storage and location transparency to the persistent store  for the servers  and . Using the administration framework, the servers may not need to know the location(s) of persistent store  and\/or the storage model of the configuration data. The administration framework may be independent of storage type of the persistent store  and may isolate client code from storage details. For example, file-based storage may be supported during system development and Lightweight Directory Access Protocol (LDAP)-based storage may be supported during production. The administration framework may provide a single point of access for core server, administration and application configuration. The administration framework may provide consistent in-memory representation of the configuration information.","One embodiment may provide an event-driven change management mechanism. In one embodiment, a configuration context  on the administration server  may be changed. Each server  may register a listener with the administration server  to listen for change notification events generated by the administration framework on the administration server . A user may access the generated administration UI  on administration server  to change an element of the configuration data as represented in memory by configuration context A. The administration UI  may then locate and access one or more of beans A to access the element. The one or more beans may then use the generic interface provided by configuration API A to access and, if needed, modify the element in persistent store . The changes may be serialized and sent to one or more other application servers  that have a global configuration context  in memory and that have registered listeners. The serialized changes may be deserialized on the receiving server  and the configuration context may be updated in memory. The administration server  may save the changes to the persistent store . In one embodiment, the application servers  never go to disk for updates. The application servers  receive notifications of changes and update their configuration contexts  in memory. Thus, changes to configuration data may be sent to multiple instances of a server . The changes may be propagated to any instance of the server  with a registered listener.",{"@attributes":{"id":"p-0093","num":"0099"},"figref":"FIG. 5","b":["204","202","200","204"]},"In one embodiment, the administration framework may be a stack including several layers. Embodiments may address the generation of the administration framework components and runtime behavior of those components. In one embodiment, the runtime system includes a presentation layer (e.g. administration UI ), a management layer (e.g. management beans  and management bean server ), a data representation layer (e.g. configuration context  and configuration beans ), a configuration API  (which may include configuration context  and storage adapter(s) ) and a persistent store . Embodiments may generate components of one or more layers of the stack, which may include the presentation layer, management layer and data representation layer. The configuration APIs for each system may include a configuration context  that keeps track of changes performed to the configuration in the system.","In one embodiment, the generated administration framework may provide a unified view and access (via the configuration API) to administration information (persistent store ) that may be distributed across multiple locations and multiple storages. For example, given a new DTD and a specified location for attaching to an existing configuration context, a unified access\/view may be generated for this sub-tree from the same configuration context. Thus, the administration framework may be used to administer complex applications such as an application server system including a multiple machine configuration and complex clusters.","In one embodiment, the administration framework data representation layer may include an Application Programming Interface (API), which may be referred to as a configuration API . The configuration API  may be an interface to the persistent store , and thus may abstract the persistent store  from the clients of the API (e.g. the application servers) and thus may provide flexibility of storage and location transparency to the clients. The configuration API  may include convenience objects or beans (configuration beans ) that may represent elements in the persistent store . The configuration beans  may be generated and may encapsulate the configuration data in-memory for access at runtime. In one embodiment, the configuration beans  may inherit from a common class that hides the data access mechanism(s).","Configuration beans  may include \u201cget\u201d and \u201cset\u201d methods for the attributes of the corresponding elements. These generated methods may implement the constraints define in the meta-information . Elements may have sub-elements that may be used to describe hierarchical data of the system. For example, the element called server may have sub-elements called web-container, resources, applications, etc. Each of these sub-elements may also have sub-elements and attributes. In one embodiment, the generator mechanism  may generate one configuration bean  per element. The generator mechanism  may generate one or more configuration bean methods to describe the containment relationship between two elements. These methods may facilitate adding, removing, and replacing a sub-element, or accessing a sub element give a primary key, for example. A primary key may be included in the meta-information for each element, and may include one or more of the attributes of the element. For example, the primary key for the server element may be its name, since servers may have different names. Other configuration bean methods may also be generated, for example for getting the number of sub-elements of a certain type (e.g., the number of applications for the server).","The configuration API  may provide a generic interface to manage (e.g. create, read, validate, write and\/or delete) the system configuration information in persistent store  and the generated configuration beans . The configuration API  abstracts persistent information in persistent store  from the clients of the configuration API . The configuration API  may provide storage transparency for the clients of persistent store . The data used by the administration framework may be kept in the persistent store . The administration framework, through the configuration API , is independent of the technology used in the persistent store . The generated administration framework and its components may use the configuration API  to provide support for any type of persistent store . For example, the persistent store  may be an XML file, an object database, a relational database or any other type of file-based or database repository.","Clients of the configuration API  may do a lookup using the configuration API  to get an in-memory representation of the corresponding configuration data from persistent store . This data for may be, for example, a representation of a Java Properties file, an XML file or other file including configuration information. The configuration API's clients may include one or more of, but are not limited to, an administration server, a deployment backend, and the containers that comprise the server. The deployment backend may register applications and\/or modules and then register the URLs of those applications and\/or modules. The configuration API  supports the deployment backend by providing the ability to store these values in the meta-information file, enabling containers (e.g. EJB containers) and other entities to query for them.","The configuration API  may include one or more of, but is not limited to, a configuration context , configuration beans , a configuration factory for creating the beans, and a mechanism (e.g. XPath) to look up the beans, a notification mechanism, and a change management mechanism. Configuration API  functionality may include, but is limited to, one or more of, basic configuration operations (e.g. set and get elements and attributes APIs), event notification, cloning, bean lookup mechanism (e.g. XPath) support, change management (e.g. add, update, delete, set), read only operations, auto commit, advanced configuration (e.g. one API to access attributes), intelligent refresh, get DTD default values, DOM-like API support (e.g. appendChild, removeChild), finding APIs, serialization and deserialization.","The configuration API  may provide support for distributed systems. In one embodiment, the configuration API may include a configuration context  that may be used to write consistently to multiple storages on different machines with a single operation. In one embodiment, a configuration context  may be created on a server during server initialization. Containers may use the configuration context  to look up configuration data of interest. In one embodiment, the configuration API  may provide hierarchical semantics into the configuration data. The configuration API  may be used to iterate through nodes and navigate to a desired attribute.","In one embodiment, the configuration context  may encompass the configuration information from the meta-information file. APIs may be provided to the configuration context  for functions including one or more of, but not limited to: reading from, refreshing, and writing to the persistent store ; tracking and managing changes to the configuration context ; looking up a bean or multiple beans (e.g. using XPath); and factory class for generating and\/or deleting configuration contexts  and\/or components (e.g. configuration beans) of configuration context .","A configuration context  represents a hierarchical view of the configuration attributes from persistent store  as represented in the meta-information file. The configuration context  may read the configuration attributes from the meta-information file. In one embodiment, a configuration factory may be provided to construct a configuration context . The configuration context  may have a one-to-one relationship with the meta-information file.","In one embodiment, elements of the configuration data may be represented by the generated configuration beans . In one embodiment, each element is represented by a corresponding configuration bean . In one embodiment, some elements (e.g. PCDATA elements) may be attributes in a parent element. For example, to change an element in a DTD, a configuration context  may be accessed to lookup a configuration bean  representing that element. APIs provided by the bean may then be used to manage the element. Configuration beans  may include generic and specific APIs. Generic APIs may be used on the base class, e.g., getAttributeValue, setAttributeValue, appendChild, etc. Specific APIs may be used on the specific bean, e.g., addJmsResource, getName, etc.","In one embodiment, the configuration context  may be obtained from cache or created, which may include generation of configuration beans . In one embodiment, the configuration beans  may be generated by a configuration factory of the configuration API . In one embodiment, once a configuration context  is obtained, configuration beans  may be looked up using an exact lookup mechanism or a lookup that accepts a query language generic to the data storage format of the persistent store, e.g. XPath, statement.","In one embodiment, the configuration context  may include a notification mechanism that allows clients to register a listener if the clients desire to hear about changes. The configuration context may send notification about configuration changes (e.g. add, update, delete, set, etc.) to all registered listeners as indicated at  of .","In one embodiment, the configuration context  may track configuration changes. One embodiment may provide mechanisms for obtaining or resetting the changes in the configuration context . The configuration changes may be serialized and sent \u201cacross wire\u201d to one or more other configuration contexts (for example, in other VMs and\/or on other server systems) to be updated on the other configuration contexts . In one embodiment, a query language (e.g. XPath) may be used to track where to make the changes.","In one embodiment, a query mechanism may be provided that uses a query language to access the persistent store  (through the configuration beans ) and to hide the persistent store  implementation. In one embodiment, XPath may be used as the query language to navigate through the hierarchical structure of the configuration data and to address parts of the data. Other embodiments may use other query languages than XPath. To provide storage transparency, the query mechanism may run on top of any storage implementation, for example XML and LDAP implementations.","In one embodiment, using the query language (e.g. XPath), from a simple description (e.g. a String), a corresponding configuration bean may be created and\/or accessed in memory without having to navigate from the top of the hierarchy. The configuration beans may include \u201cget element\u201d and \u201cset element\u201d methods for the attributes and sub-elements of an element. These get and set element methods may accept the name of the element and the name of the attribute, and may accept or return an element or attribute value (depending on the method) when invoked to perform an operation on the element.","The query language (e.g. XPath) may allow a configuration attribute in a tree of data to be uniquely identified. The query language may be used for updating changes in other configuration contexts . Listeners may listen for changes and get the changed value using the query language.","In one embodiment, the configuration API  may include one or more storage adaptors  that may support multiple accesses in read or write mode to the data of persistent store . The configuration API  may handle concurrent access and may manage and\/or prevent conflicts. In one embodiment, the configuration API  may manage the number of instances of the configuration context  in the server system to prevent the configuration context  from overwriting changes in persistent store . In one embodiment, the configuration API  may detect stale data in the configuration context  due to changes in storage. In one embodiment, the configuration API  may keep track of and otherwise manage changes in the configuration context .","The management layer may include management beans  that include the business logic of the system. The management beans  may be generated by the generator mechanism  from meta-information , and may be used as base classes by the developer to add application-specific business logic. The management beans  may expose the management interface to the external world. Business logic implemented by a management bean may include (more or less) complex validation that may involve (e.g. access and potentially modify) one or more data elements. Thus, a management bean  may access one or more configuration beans  in performing the business logic as indicated by the management bean . In one embodiment, configuration beans  do not themselves include any business logic.","In one embodiment, the management beans  generated by the generator mechanism  may be MBeans, Java beans that adhere to the JMX standards. In one embodiment, MBeans may be one of several types as defined by the JMX specification including, but not limited to, standard, dynamic and model MBeans.","In the management layer, using the management beans , application-specific integrity constraints and\/or business logic that interact with the administered application(s) may be coded. In one embodiment, the management beans  may encapsulate business logic that may include rules (which may be dynamic) that are application-dependent. The management beans framework allows the developer to enter these business rules as management bean methods.","In one embodiment, a dependency relationship may exist between configuration beans  of the data representation layer and the management beans  of the management layer. Management beans  may be generated to work with the generated configuration API  components (e.g. configuration beans ). Each management bean  may reference the configuration context  and look up one or more configuration beans , e.g. using XPath. The configuration beans  may be used to perform functions including, but not limited to, getting and setting attributes of the persistent store , on behalf of the business logic as defined in the management beans .","The data representation layer and its configuration beans  may implement static validation of particular elements and attribute values, and may be responsible for persisting the data in a transparent way. The management layer and its management beans  may implement business rules that may access one or more attributes or administered elements at a time and that may apply business rules to them. For example, the management bean  representing a server element may have methods that may start or shut down a server. This operation may involve many attributes of the server element as well as other attributes in other elements. These methods, implemented by the management layer, may be complex and may involve multiple, potentially heterogeneous attributes and elements. The methods access the attributes and elements of the configuration data through corresponding configuration beans  of the data representation layer.","In one embodiment, the presentation layer may be Web-based and may include components  including, but not limited to, one or more of servlets, JSPs, HTML documents, and images. In one embodiment, the presentation layer may be packaged as a Web Application. The presentation layer may be an administration user interface (UI)  that provides support for the user to administer the system. The presentation layer may be generated, and the generated presentation layer administration UI  may be used for administration of the generated management beans  (business logic) of the management layer. In one embodiment, the generated administration UI  may include one or more servlets for driving the administration UI , and one or more JSPs for each page of the UI. These JSPs may be customized by users if desired. The administration UI  allows the user to perform management operations of the system including, but not limited to, one or more of: creating configurable items (elements); entering attribute values for the elements; configuring the elements (e.g. changing property values of the elements); validating the changes against rules described in the meta-information (e.g. through calls to the Management beans); persist and\/or retrieve changes; handling multiple access to the configuration store; deleting configured elements; getting lists of items; selecting items from lists; grouping related items into presentation pages; and navigating from items to related items (e.g. via links). The relationships between the items may be described in the meta-information.","In one embodiment, the runtime framework used by the generated presentation layer may be Sun's Sun ONE Application Framework (JATO). The JATO framework unites familiar concepts such as display fields, application events, component hierarchies, and a page-centric development approach, with a design based on the Model-View-Controller. In one embodiment, the generated code may include a view and controller Layer including Java Beans called View Beans, as well as Beans inheriting from the JATO-predefined View Objects, and JSP using these ViewBeans. In one embodiment, the generated code may also include a Model Layer that may serve as the glue between the JATO framework and the back-end management beans layer. In one embodiment, the JSPs may be customized to change the look and feel of the pages and to add, remove or modify icons and other interface items. Such modifications may be made without affecting the business logic of the system.","In one embodiment using JMX, third party tools may be integrated for administration instead of using the generated administration UI . In one embodiment, JMX-enabled components may be added to the administration UI . The administration UT  may detect new components and may expose interface(s) to the detected components.",{"@attributes":{"id":"p-0120","num":"0126"},"figref":"FIG. 6","b":["260","226","204","226","226","224","224","212","210","224","216","210"]},"At runtime , the generated administration UI  of the presentation layer may be used to access the management layer (e.g. management beans ) to perform administration , monitoring  and configuration  operations.","The administration server may allow changes to the configuration of a running application server instance. These configuration changes may result in a notification to the core system. In one embodiment, some changes may require a server restart before they take effect. Changes may be categorized as application changes, resource changes and other changes.","In one embodiment, application (or standalone module) attributes may be changed dynamically. A change may result in the new application attributes going into effect immediately; any new requests will get the new configuration. In one embodiment, existing application instances may generate exceptions on lookups or other accesses. In one embodiment, resources may or may not change dynamically.","Event Notification Mechanism","One embodiment may include an event notification mechanism that may allow events (e.g. changes in configuration data) to be propagated in a distributed system running several virtual machines (VMs) (e.g. Java Virtual Machines (JVMs)). In one embodiment, each VM may be an execution engine of an application server. While described herein in reference to distributed application server systems, embodiments of the notification mechanism as described herein may be used in other types of distributed systems.","The configuration API may support the administration server to update configuration data of multiple server components. Any server component that has configuration data may need to be updated by the administration server. The components may have configuration data and accessors to those data (e.g., IMQ).",{"@attributes":{"id":"p-0126","num":"0132"},"figref":"FIG. 7","b":["302","304"]},"As indicated at , if changes have been made, then the event notification mechanism may start the distributed notification to inform clients (e.g. other server instances) of the changes. Clients may have registered listeners with the event notification mechanism. As indicated at , the registered listeners may be iterated, and server instances with registered listeners may be sent event notification(s) as indicated at . Server instances that receive event notifications may update the appropriate elements and\/or attributes in memory as indicated by the event notification(s).","Using this mechanism, only configuration data changes are sent to registered server instances. Modifications to configuration information are made in-memory on the administration server, and notifications of the changes are sent to registered server instances. Using this mechanism, the event notification mechanism and configuration information updating on server instances are performed without having to go to the persistent store to store or retrieve configuration data.",{"@attributes":{"id":"p-0129","num":"0135"},"figref":"FIG. 8","b":["322","324","326","328","328","330","332","334"]},"In one embodiment, the event notification mechanism may use the configuration API configuration context, which tracks changes done to the configuration in a virtual machine (VM). These changes may be obtained\/reset anytime from the configuration context. In order to send notifications to another VM, a set of configuration changes may be serialized and sent \u201cacross the wire\u201d to another configuration context in another VM.","Using the configuration API, the receiving VM may incrementally apply only the changed elements to its instance of the configuration context. In one embodiment, a query language (e.g. XPath) may be used to determine the locations of changes in the configuration context.","The notification mechanism, built upon the configuration API, may be abstracted from the details of the persistence of the configuration data (including what is loaded into memory versus what is in the persistent store), and may be abstracted from the tracking of changes. In addition, the serialization mechanism may avoid reloading from any persistent back-end store in every receiving VM.","In one embodiment, notifications may be sent over a RMI (Remote Method Invocation) channel between VMs using a wire protocol (e.g. JRMP wire protocol). In one embodiment, the changes cached in the configuration context may be categorized into one or more notifications; there may be a many-to-many relationship between configuration context cached changes and notifications.","Once the notifications are received in the target VM, the associated configuration changes may be applied to an instance of the configuration context in that VM. The notifications may then be passed on to registered listeners, along with a copy of the modified configuration context. Once the listeners successfully complete the change processing, the global configuration context in a target VM may be replaced by the modified configuration context.","The notification mechanism and handling of configuration changes may be generic and the same mechanism may be applied to other distributed middleware. The application-specific handling resides in the categorization of configuration changes to notifications, and the implementation for the categorization mechanism may be pluggable to achieve desired application-specific handling.",{"@attributes":{"id":"p-0136","num":"0142"},"figref":"FIG. 9","b":["340","356","342","352","350","344","344","346","346","348","348","352","350","352","356","350"]},{"@attributes":{"id":"p-0137","num":"0143"},"figref":["FIG. 10","FIG. 9"],"b":["362","356","364","352","350","352","350","350"]},"Pluggable Verification and Validation for Configuration Data","As previously mentioned, embodiments may provide data transparency for storage information that allows different implementations to be used for the persistent store data, e.g. XML, LDAP, database, etc. Some implementations may include parsers (e.g. parsers for XML data) that may validate data, but that may have restrictions. If the data is in a database, LDAP, or other storage implementations, parsers may not be used.","One embodiment may provide a pluggable semantic verification and syntactic validation mechanism for configuration data. One embodiment of this data verification and validation mechanism may be reusable in stand-alone (off-line) applications and in the application server (on-line). In one embodiment, this mechanism may be based on the configuration API. In one embodiment, this mechanism may be generic, pluggable, and extensible. This mechanism may be transparent to factors such as the type and location of storage. In one embodiment, the data verification and validation mechanism may be implemented as one or more pluggable modules that may be plugged into the configuration API framework. In one embodiment, data-specific information may not be hard-coded in the configuration API to keep it generic. This mechanism may be referred to as a generic test case mechanism or framework.","In one embodiment, a test case may include a java class that implements an interface that allows a check method to be called generically from the administration framework. This check method may return a result object that includes the result of the test, e.g. whether the test passed or failed, and that may include additional information on why the test failed, etc. In one embodiment, a list of test cases and other information on the test cases (e.g., when each test case is to be run, whether the test case needs to be run offline or online, etc.) may be kept in an editable file (e.g., a markup language file such as an XML file).","In one embodiment, the same test cases may be used both for off-line and on-line cases. One embodiment may provide for the propagation of exceptions in case of errors. One embodiment may support both warnings and errors. In the case of a warning, an operation may be executed and the user may be provided with a warning message.","Verification and validation of data may occur in multiple places, and the usage may vary. For example, data may need to be verified before the server starts up and accesses the data. As another example, the administration server may validate data before setting user-entered values. As yet another example, the user may validate data using a stand-alone program.",{"@attributes":{"id":"p-0143","num":"0149"},"figref":"FIG. 11","b":["404","200","402","404","400","406","406","404","406","400","408","406","406","406","406","406","408","406","400","206","410","400","200","402"]},{"@attributes":{"id":"p-0144","num":"0150"},"figref":"FIG. 12","b":["430","432"]},"At , if the change is determined to be valid, then the change may be made to the configuration data as indicated at . In one embodiment, the user may be notified of the successful change. At , if the change is determined to be invalid, then at , if the change is invalid due to an error, then the error may be handled as indicated at . In one embodiment, an exception may be thrown, which in one embodiment may result in an error message being displayed on the administration UI.","At , if the change is invalid due to a warning, then a warning message may be generated as indicated at , which in one embodiment may be displayed to the user on the administration UI, and the change may be made to the configuration data as indicated at . After the change is made as indicated at , then one or more listeners may be notified of the change. For example, the change may be made on an administration server, and the configuration API may send an event notification to registered listeners for one or more application servers so that the application servers may update instances of the configuration context to keep the instances in synchronization with the configuration context on the administration server.",{"@attributes":{"id":"p-0147","num":"0153"},"figref":"FIG. 13","b":["450","452","454","456","458"]},"At , if the change is determined to be valid, then the configuration API may be notified as indicated at . At , if the change is determined to be invalid, then at , if the change is invalid due to an error, then the error may be handled as indicated at . In one embodiment, an exception may be thrown, which in one embodiment may result in an error message being displayed on the administration UI. At , if the change is invalid due to a warning, then a warning message may be generated, which in one embodiment may be displayed to the user on the administration UI, and the configuration API may be notified, with the warning, as indicated at . The configuration API may then make the change to the configuration data as indicated at . The change may be made to the configuration context and, in one embodiment, may be propagated to the persistent store of configuration data. After the change is made as indicated at , then the configuration context may send an event notification to one or more listeners as indicated at . For example, the change may be made at  on an administration server, and the configuration context may send an event notification to registered listeners at  for one or more application servers so that the application servers may update instances of the configuration context to keep the instances in synchronization with the configuration context on the administration server and in the persistent store.","Various embodiments may further include receiving, sending or storing instructions and\/or data implemented in accordance with the foregoing description upon a carrier medium. Generally speaking, a carrier medium may include storage media or memory media such as magnetic or optical media, e.g., disk or CD-ROM, volatile or non-volatile media such as RAM (e.g. SDRAM, DDR SDRAM, RDRAM, SRAM, etc.), ROM, etc. as well as transmission media or signals such as electrical, electromagnetic, or digital signals, conveyed via a communication medium such as network and\/or a wireless link.","The various methods as illustrated in the Figures and described herein represent exemplary embodiments of methods. The methods may be implemented in software, hardware, or a combination thereof. The order of method may be changed, and various elements may be added, reordered, combined, omitted, modified, etc.","Various modifications and changes may be made as would be obvious to a person skilled in the art having the benefit of this disclosure. It is intended that the invention embrace all such modifications and changes and, accordingly, the above description to be regarded in an illustrative rather than a restrictive sense."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0023","num":"0029"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0024","num":"0030"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0025","num":"0031"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0026","num":"0032"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0027","num":"0033"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0028","num":"0034"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0029","num":"0035"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0030","num":"0036"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0031","num":"0037"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0032","num":"0038"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0033","num":"0039"},"figref":["FIG. 10","FIG. 9"]},{"@attributes":{"id":"p-0034","num":"0040"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0035","num":"0041"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0036","num":"0042"},"figref":"FIG. 13"}]},"DETDESC":[{},{}]}
