---
title: Graphical object classification
abstract: In one implementation, a graphical object classification system includes an acquisition module, a signature generation module, and a classification module. The acquisition module accesses a representation of a graphical object. The signature generation module generates an appearance-invariant signature of the graphical object based on the representation. The classification module classifies the graphical object based on the appearance-invariant signature.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09213463&OS=09213463&RS=09213463
owner: Hewlett-Packard Development Company, L.P.
number: 09213463
owner_city: Houston
owner_country: US
publication_date: 20110407
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATION","BACKGROUND","DETAILED DESCRIPTION"],"p":["This application is a U.S. National Stage Application of and claims priority to International Patent Application No. PCT\/US2011\/031615, filed on Apr. 7, 2011, and entitled \u201cGRAPHICAL OBJECT CLASSIFICATION.\u201d","Graphical object classification systems classify graphical objects (e.g., icons, portions of images, buttons, etc.) to determine the types or classes of those graphical objects. This classification can be useful to determine which graphical objects are included within an image. Alternatively, such classification can be useful to identify a graphical object or objects of a particular type or class.","Typically, graphical object classification systems classify graphical objects using templates. That is, graphical objects are compared with templates and are classified into classes associated with the templates matched or satisfied by those graphical objects (e.g., the templates the graphical objects most similarly resemble).","Graphical objects are typically classified by graphical object classification systems (or classification systems) based on templates of the graphical objects. That is, to classify a graphical object, that graphical object is compared with a group of templates, each of which is related to a class (or type) of graphical object. If the graphical object matches (or satisfies) a template, that graphical object is classified in the class related to that template.","The appearance of graphical objects can be altered, however, due to changes in resolution of a display, parameters of a graphical user interface, and\/or color inversion of an image, for example. Furthermore, the appearance of graphical objects can change temporarily or dynamically. For example, the appearance of a graphical object can change as a user interacts with the graphical object or based on a status associated with the graphical object. As specific examples, the color, shading, or other attribute of a graphical object can change when a user moves a mouse pointer over the graphical object, when the user selects the graphical object with a mouse pointer (e.g., clicks on the graphical object), or when a functionality associated with the graphical object is not available. As another example, the appearance of a graphical object can change when a notification or message from a software application associated with the graphical object is available. Specifically, for example, the appearance of a graphical object (e.g., an icon) associated with an electronic mail software application can change when there are unread messages in an electronic mailbox.","As a result of such changes in appearance or transformations, classifying graphical objects based on templates can be unreliable after a transformation of a graphical object. Moreover, generating templates for each possible transformation or appearance of a graphical object can be impractical and inefficient due to data storage restraints and\/or the number of possible transformations.","Implementations discussed herein classify graphical objects based on appearance-invariant signatures of those graphical objects. For example, an appearance-invariant signature can be generated based on a representation (e.g., a bitmap representation or a representation based on a matrix of pixel values) of a graphical object. Such representations can be referred to as graphical object representations. The appearance-invariant signature is then used to classify the graphical object at a classification module. That is, the appearance-invariant signature is a proxy for the graphical object during classification of the graphical object.","The appearance-invariant signature has attributes or characteristics that vary little in response to changes in the appearance (e.g., changes due to transformations) of the graphical object. Thus, a graphical object can be classified into the same class before and after a transformation of the graphical object. Said differently, a graphical object classified into a class using an appearance-invariant signature generated from a representation of the graphical object before a transformation is classified into the same class using another appearance-invariant signature generated from a representation of the graphical object after the transformation.","Such classification systems can be used within a variety of environments. For example, such classification systems can be used to classify icons (i.e., graphical objects) included within synthetic or artificial images such as graphical user interfaces or other images that include icons. That is, a classification system can be used to analyze an image and determine what classes (or types) of icons are included within that image.","As a specific example, such classification systems can be particularly beneficial to software automation. For example, a software automation tool can be configured to perform some task within a graphical user interface (\u201cGUI\u201d). That is, the software automation tool performs the task by manipulating (e.g., clicking on or emulating mouse clicks at) controls of the GUI. Because the appearance of the GUI can change (e.g., be transformed due to application of a skin or new visual layer to the GUI), classification of the controls of the GUI (i.e., the graphical objects of the GUI) using appearance-invariant signatures can mitigate or prevent changes in classification of the controls after the change in appearance.","As used herein, the singular forms \u201ca,\u201d \u201can,\u201d and \u201cthe\u201d include plural referents unless the context clearly dictates otherwise. Thus, for example, the term \u201cgraphical object\u201d is intended to mean one or more graphical objects or a combination of graphical objects. Additionally, as used herein, the term \u201cmodule\u201d refers to hardware (e.g., a processor or circuitry) and\/or software (e.g., firmware, programming, machine- or processor-executable instructions, commands, or code) that is stored at a memory and executed or interpreted (or hosted) at a processor. In other words, a module can be hardware and\/or a combination of hardware and software stored at a memory accessible to the hardware.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 1","b":["111","116","120","111","116","131","133","135","111","116","120","120","111","116","111","116","111","116","111","116","131","111","116","133","111","116","135"]},"Classification system  can identify the class of classes , , and  into which each graphical object from graphical objects - is classified using a variety of methodologies. For example, classification system  can store graphical objects in (or of or having) a common class at a portion of a data store such as a database table or file system directory associated with (or designated for) graphical objects in that class. As another example, classification system  can annotate or apply a watermark to each a graphical object to indicate or identify the class in which that graphical object is included. As yet another example, classification system  can output (e.g., to a display device, via communications link, to a database, or to a file) an identifier of a class in which a graphical object is included after that graphical object is processed or analyzed, for example, as discussed in more detail herein, at classification system . In some implementations, classification system  can output an identifier of the graphical object (e.g., a name or a reduced-size copy of the graphical object (i.e., a thumbnail)) and an identifier of the class in which the graphical object is included.","Graphical objects are portions of an image. For example, graphical objects can be icons within an image. Icons are portions of an image or sub-images within an image that represent a resource and\/or a functionality. As a specific example, controls within a GUI are icons that represent resources and\/or functionalities available or accessible via the GUI. Examples of such controls include control buttons (e.g., push buttons and radio buttons), check boxes, edit boxes, lists (e.g., scroll lists and drop-down lists), applications access controls (e.g., icons that represent software applications), file access controls (e.g., icons that represent files), and resource access control (e.g., icons that represent resources such as services accessible via a communications link).","As a specific example of graphical objects that are controls within a GUI,  is an illustration of classification of a group of controls at a graphical user interface, according to an implementation. Graphical user interface  illustrated in  includes radio button group  with three radio button controls (labeled \u201cOPTION ,\u201d OPTION ,\u201d and \u201cOPTION \u201d), check box group  with three check box controls (labeled \u201cSELECTION ,\u201d SELECTION ,\u201d and \u201cSELECTION \u201d), drop-down list control  (including entries \u201cVALUE ,\u201d VALUE ,\u201d and \u201cVALUE \u201d), edit box control , and push button controls  and . In other implementations, graphical user interface  can include additional or fewer controls that the controls illustrated in . For example, graphical user interface  can exclude edit box control  and can include an application access control (e.g., an icon) that represents an application and causes the application to be executed at a computing device hosting graphical user interface .","Classification system  accesses controls - (or representations thereof) at graphical user interface  and classifies controls - into classes -. Class  is associated with radio button controls. Thus, classification system  classifies each radio button control of radio button group  into class . In some implementations, classification system  also classifies radio button group  into class . That is, classification system  classifies the individual radio button controls (i.e., each radio button and associated text) and radio button group  (i.e., the aggregate of the individual radio button controls) into a common class. In other implementations, classification system  classifies the individual radio button controls and radio button group  into different classes.","Similarly, classification system  classifies each check box control of check box group  into class . Class  is associated with check box controls. In some implementations, classification system  also classifies check box group  into class . That is, classification system  classifies the individual check box controls (i.e., each check box and associated text) and check box group  (i.e., the aggregate of the individual check box controls) into a common class. In other implementations, classification system  classifies the individual check box controls and check box group  into different classes.","Classification system  classifies drop-down list control  into class . Class  is associated with drop-down list controls. Classification system  classifies edit box control into class . Class  is associated with edit box controls. Classification system  classifies push buttons  and  into class . Class  is associated with push button controls.","Said differently, classification system  classifies controls - at graphical user interface  into various classes using appearance-invariant signatures based on attributes of controls - (or of the representations of controls -) such that the control in each class of classes - share common attributes. In some implementations, classification system  can classify controls into additional, fewer, and\/or other classes than illustrated in .",{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 3","FIG. 3"],"b":["300","310","320","330","300","300","300","300"]},"Acquisition module  includes hardware such as a processor or application-specific integrated circuit (\u201cASIC\u201d), software stored at a memory and executed from the memory at a processor, or a combination thereof to access representations of graphical objects. For example, acquisition module  can be a screen capture utility (e.g., a software application) hosted at a processor. Signature generation module  includes hardware such as a processor or ASIC, software stored at a memory and executed from the memory at a processor, or a combination thereof to generate appearance-invariant signatures of graphical objects. Classification module  includes hardware such as a processor or ASIC, software stored at a memory and executed from the memory at a processor, or a combination thereof to classify graphical objects based on appearance-invariant signatures of those graphical objects. For example, classification module  can be a classification software library including object codes hosted at a processor.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 4","b":["400","400","400","300"]},"A representation of a graphical object such as a GUI control is accessed at block . For example, acquisition module  can receive a bitmap representation of a GUI. As a specific example, classification system  is hosted at a computing device hosting the GUI, and acquisition module  generates a screenshot of the GUI. Acquisition module  can then parse the screenshot to access bitmap representations of the controls at the GUI. For example, acquisition module  can apply an edge-detection filter to the GUI and select portions of the GUI for which the edge-detection filter generated rectangular features. The selected portions (e.g., portions of the GUI screenshot) are then used as representations of the controls at the GUI. More specifically, in this example, the portions of the GUI screenshot are accessed by acquisition module  as bitmap representations of the controls.","As another example, representations such as bitmap representations of graphical objects can be provided to acquisition module  via, for example, a communications interface module or application programming interface (\u201cAPI\u201d) of classification system . Moreover, representations of individual graphical objects can be accessible to classification system  at a data store (i.e., a data storage device, a data storage service, or a combination thereof), and acquisition module  can access representations of graphical objects at that data store.","An appearance-invariant signature of the graphical object is then generated from the representation of the graphical object at block . For example, acquisition module  provides the representation of a graphical object to signature generation module , and signature generation module  generates the appearance-invariant signature of the graphical object. An appearance-invariant signature of a graphical object is a value or a collection of values (i.e., a vector) that is used to classify the graphical object, and includes (or has) attributes that do not significantly change in response to variations in the graphical object. That is, an appearance-invariant signature of a graphical object is generated from a representation of the graphical object and includes attributes substantially the same as or identical to another appearance-invariant signature generated from a representation of the graphical object after a transform.","In other words, the two appearance-invariant signatures are substantially the same or identical one to another within a classification system (or to a classification module such as classification module ). Two (or more) appearance-invariant signatures are substantially the same or identical if a classification module classifies the graphical objects represented by those appearance-invariant signatures into the same class. That is, the appearance-invariant signatures are substantially the same or identical if a classification module produces a common classification result for each appearance-invariant signature. Said differently, an appearance-invariant signature based on a transformed graphical object is substantially the same or identical to an appearance-invariant signature based on the original graphical object (i.e., the transformed graphical object before it was transformed) if the graphical object is classified into the same class for each appearance-invariant signature.","A graphical object is transformed if it is altered or changes to have a different appearance. That is, a transformation of a graphical object is a change in color, shape, size, orientation, or other attribute of the graphical object. As an example, applying a new skin or visual layer to a GUI can transform the controls of the GUI. That is, the appearance of the controls is altered, but the functionalities of those controls remain the same.  illustrate graphical objects before and after various transformations.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 5","FIG. 2","FIG. 2","FIG. 5"],"b":["171","176","170","170"]},{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 6","FIG. 2","FIG. 6","FIG. 6"],"b":["170","171","176"]},{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 7","FIG. 2","FIG. 7"],"b":["171","176","170","170","171","172","176"]},{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 8","FIG. 2","FIG. 8"],"b":["170","171","176","170","171","176","170"]},"As illustrated in  the controls of a GUI can have altered appearances due to changes in resolution of a display, a visual layer, color options, and\/or other parameters. Moreover, the appearance of other graphical objects can change due to these and\/or other parameters. As a result of such changes, classifying graphical objects based on templates (i.e., graphical objects accessed at an earlier time and associated with particular classes) can be unreliable after a transformation of a graphical object. Moreover, generating templates for each possible transformation or appearance of a graphical object can be impractical and inefficient due to data storage limitations and\/or the number of possible transformations. Accordingly, an appearance-invariant signature can be used to classify a graphical object to prevent or mitigate changes in classification of that graphical object after it has been transformed.","Referring to , the graphical object is then classified using the appearance-invariant signature at block . With reference to , signature generation module  provides the appearance-invariant signature for the graphical object to classification module , and classification module  classifies the graphical object into a class. That is, classification module  determines into which class a graphical object will be classified based on the appearance-invariant signature for the graphical object. Said differently, classification module  can determine or identify appearance-invariant signatures that share common attributes and group or classify those appearance-invariant signatures (or the graphical objects related thereto) into classes.","As a specific example, classification module  can implement a support vector machine (\u201cSVM\u201d) such an SVM utilizing a Gaussian kernel. In other words, classification module  can be a support vector machine based classification module. In some implementations, the SVM or the SVM kernel has been previously trained. For example, the SVM can have been configured using a supervised training procedure in which groups of appearance-invariant signatures for each of a variety of classes were provided to the SVM. The SVM then generates or defines support vectors that are used by the SVM to discriminate between appearance-invariant signatures of graphical objects from those classes (i.e., to identify the attributes of the appearance-invariant signatures associated with those classes) to classify the graphical objects.","Alternatively, the SVM can be configured using an unsupervised training methodology in which a group of appearance-invariant signatures are provided to the SVM, and the SVM then generates or defines support vectors to separate the appearance-invariant signatures into classes (or groups) the SVM determines are significant (e.g., differ by some measure such as a statistical, geometric, or Euclidean measure). In other implementations, other classification modules and\/or training methodologies can be used.","In other implementations, classification module  can be a different type of classification module. For example, classification module  can be based on K-means clustering, Mean-Shift clustering, or GrabCut clustering.","Process  can include additional or fewer blocks than those illustrated in . For example, process  can include an additional block at which an identifier of the class into which a graphical object is classified can be output, for example, to a log file, to a user at a display, or via a communications link. As another example, multiple appearance-invariant signatures can be used to classify a graphical object. In other words, block  can be repeated to generate multiple appearance-invariant signatures, and the graphical object can be classified based on two or more appearance-invariant signatures. For example, the appearance of some graphical objects can change temporarily or dynamically, for example, as a user interacts with the graphical object or based on a status associated with the graphical object. More specifically, for example, the color, shading, or other attribute of a graphical object can change when a user moves a mouse pointer over the graphical object or when the user selects the graphical object with a mouse pointer. An appearance-invariant signature can be generated before the user interacts with the graphical object and another appearance-invariant signature can be generated while the user interacts with the graphical object. Both appearance-invariant signatures can then be used to classify the graphical object.","As a specific example, a button at a GUI can have a default appearance (or state), a shaded appearance when a mouse pointer is over (i.e., hovers on) the button, and a depressed appearance when the button is selected. An appearance-invariant signature can be generated for each appearance (or state) of the button and the button can be classified using each of the appearance-invariant signatures. That is, each of the appearance-invariant signatures can be provided to a classification module to classify the button.","Additionally, one or more blocks of process  can be rearranged. For example, process  can be repeated for multiple graphical objects such as controls at a GUI. Furthermore, although process  is discussed above with reference to an example environment within classification system, process  is applicable within other environments.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 9","b":["900","900","900"]},"Process  is an example methodology to generate an appearance-invariant signature for a graphical object. As illustrated in , an appearance-invariant signature can be a composite signature (i.e., the signature includes multiple portions) generated from a multi-dimensional (here, two-dimensional) representation of a graphical object. For example, the multi-dimensional representation of the graphical object can be a two-dimensional bitmap of the graphical object. More specifically, a first signature vector (i.e., a first component or portion of an appearance-invariant signature) is generated at  and a second signature vector is generated at block  for the representation of a graphical object. The first and second signature vectors can also be referred to as signals. Thus, an appearance-invariant signature can include multiple signals.","The first signature vector is generated by integrating along a first dimension of the representation of the graphical object at block . A derivative of the result vector (or signal) of the integrating is then determined (or taken) along the second dimension of the representation of the graphical object at block . For example, a two-dimensional bitmap of the representation of the graphical object can be integrated along the y-axis and the derivative along the x-axis of the result can then be taken.","The result vector of the derivative is then transformed into a different domain at block . For example, the result vector of the derivative can be transformed to the log-domain. Additionally, other transformations of the result vector can also be performed in conjunction with or in place of the transform to the log-domain. As a specific example, a Fourier transform is performed on the result vector of the derivative and the phase components are discarded (i.e., to retain only the magnitude components of the Fourier transform). The result vector of the Fourier transform is then transformed into the log-domain. Finally, a Fourier transform is performed on the result vector of the log-domain transform and the phase components are discarded (i.e., to retain only the magnitude components of the Fourier transform). The result vector of block  is the first signature vector generated at block .","Similarly, the second signature vector is generated by integrating along the second dimension of the representation of the graphical object at block . A derivative of the result vector of the integrating is then taken along the first dimension of the representation of the graphical object at block . For example, a two-dimensional bitmap of the representation of the graphical object can be integrated along the x-axis and the derivative along the y-axis of the result can then be taken. That is, the integral is taken along the dimension at block  along which the derivative was taken at block , and the derivative is taken along the dimension at block  along which the integral was taken at block .","The result vector of the derivative is then transformed into a different domain at block . For example, the result vector of the derivative can be transformed to the log-domain. Additionally, other transformations of the result vector can also be performed in conjunction with or in place of the transform to the log-domain. As a specific example, a Fourier transform is performed on the result vector of the derivative and the phase components are discarded. The result vector of the Fourier transform is then transformed into the log-domain. Finally, a Fourier transform is performed on the result vector of the log-domain transform and the phase components are discarded. The result vector of block  is the second signature vector generated at block .","An appearance-invariant signature for a graphical object can also include additional components or signals. As illustrated in , gradient information related to the graphical object can be generated (or calculated) to be included at the appearance-invariant signature. As an example, a histogram of the gradient angles of the graphical object can be calculated from the representation of the graphical object. The histogram can be another vector (or signal or component) that is included within the appearance-invariant signature.","Moreover, color information related to a graphical object can be generated (or calculated) from the representation of the graphical object at block . For example, a percentage (i.e., a value representing a percentage) of the graphical object that is within a range of color values (i.e., values within the representation of the graphical object that represent colors) can be determined. In some implementations, a group of values that represent the percentages of the graphical object that are within various ranges of color values can be generated at block . Such a value or values are another vector (or signal or component) that is included within the appearance-invariant signature.","The vectors generated at process  (e.g., the results of blocks , , , and ) are aggregated (or combined) at block  to define the appearance-invariant signature. In one implementation, the first signature vector, the second signature vector, the gradient information, and the color information are concatenated (in the order generated) to define the appearance-invariant signature. In other words, the appearance-invariant signature is a composite of the first signature vector, the second signature vector, the gradient information, and the color information.","Process  can include addition or fewer blocks than those illustrated in . Additionally, one or more blocks can be rearranged. For example, process  can be implemented at signature generation module operable to generate multiple signature vectors in parallel and the first signature vector and the second signature vector are generated concurrently. Furthermore, although process  is discussed above with reference to an example environment including a signature generation module, process  is applicable within other environments.",{"@attributes":{"id":"p-0063","num":"0062"},"figref":["FIG. 10","FIG. 10"],"b":["400","1000","1000","1000","1020","1010","1030","1040","1010","1020","1030","1040"]},"Processor  is any of a variety of processors. For example, processor  can be a general-purpose processor or an application-specific processor and can be implemented as hardware and\/or software hosted at hardware. Hardware is, for example, a microprocessor, a microcontroller, an application-specific integrated circuit (\u201cASIC\u201d), a programmable logic device (\u201cPLD\u201d) such as a field programmable gate array (\u201cFPGA\u201d), and\/or other circuitry that performs operations. Software is, for example, processor-executable instructions, commands, codes, firmware, and\/or programming stored at a memory and executed (or hosted) at a processor. Software can be defined using one or more programming languages such as Java\u2122, C++, C, an assembly language, a hardware description language, and\/or another suitable programming language. For example, a processor can be a virtual machine hosted at a computer server including a microprocessor and a memory.","In some implementations, processor  can include multiple processors. For example, processor  can be a microprocessor including multiple processing engines (e.g., computation, algorithmic or thread cores). As another example, processor  can be a computing device including multiple processors with a shared clock, memory bus, input\/output bus, and\/or other shared resources. Furthermore, processor  can be a distributed processor. For example, processor  can include multiple computing devices, each including a processor, in communication one with another via a communications link such as a computer network.","Memory  can be separate from processor  or can be external and accessible to processor . Typically, as illustrated in , memory  includes processor-executable instructions or codes (e.g., computer codes or object codes) defining software that is executed by processor  during operation of computing device . For example, memory  can be a random-access memory (\u201cRAM\u201d) that includes processor-executable instructions that define operating system , device drivers , and classification system  (e.g., a software application that implements a process such as process ). In other words, operating system , device drivers , classification system , and other software stored as processor-executable instructions (not shown) at memory  and executed at processor  are hosted at computing device  (or at processor ). Classification system  can include components such as, for example, an acquisition module, a signature generation module, and a classification module. The components of classification system  can be implemented as sub-routines, functions, software libraries (e.g., statically-linked libraries and\/or dynamically-linked or -loaded libraries), and\/or other modules of classification system .","Typically, operating system , device drivers , classification system , other software applications (i.e., processor-executable codes or instructions that implement software applications when hosted at a processor) and\/or data values are stored at non-volatile processor-readable medium . In some embodiments, processor  transfers or loads operating system , device drivers , classification system , the other software applications, and\/or data values into memory  during an initialization or boot sequence of computing device , and operating system , device drivers , classification system , the other software applications, and\/or data values are accessed or executed from memory  during operation of computing device . That is, non-volatile processor-readable medium  can function as a persistent or non-transient data store or memory for the codes, instructions, data value, and\/or other information stored during operation of computing device  at memory . Thus, memory  and non-volatile processor-readable medium  can be referred to generically as memory of computing device .","Examples of processor-readable media include, but are not limited to: magnetic storage media such as a hard disk, a floppy disk, and\/or magnetic tape; optical storage media such as a compact disc (\u201cCD\u201d), a digital video disc (\u201cDVDs\u201d), a compact disc read-only memory (\u201cCD-ROM\u201d), and\/or a holographic device; magneto-optical storage media; non-volatile memory such as read-only memory (\u201cROM\u201d), programmable read-only memory (\u201cPROM\u201d), erasable programmable read-only memory (\u201cEPROM\u201d), electronically erasable read-only memory (\u201cEEPROM\u201d), and\/or FLASH memory; and RAM. In other words, processor-readable media are media from which a processor can access information (e.g., processor-executable instructions or codes and\/or data values). Thus, non-volatile processor-readable medium  is a processor readable memory and memory  is also a processor-readable medium.","Examples of processor-executable code or instructions (e.g., computer code or instructions) include, but are not limited to, micro-code or micro-instructions, machine instructions, such as produced by a compiler, and files containing higher-level instructions that are executed by a computer using an interpreter. For example, an implementation may be realized or implemented using Java\u2122, C++, a script interpreter, or other object-oriented programming language and development tools. Additional examples of processor-executable code include, but are not limited to, script instructions, encrypted code, and compressed code.","Non-volatile processor-readable medium  can be, for example, a hard disk within computing device  that includes software loaded or copied to non-volatile processor-readable medium  from another processor-readable medium such as a DVD or CD. In some implementations, non-volatile processor-readable medium  can be external to or removable from computing device . For example, non-volatile processor-readable medium  can include a Universal Serial Bus\u2122 (\u201cUSB\u201d) interface (or interface module) and non-volatile processor-readable medium  can be FLASH memory device with a USB interface. In other implementations, non-volatile processor-readable medium  can be integrated with processor . In yet other implementations, non-volatile processor-readable medium  can be remote from computing device  and computing device  can access non-volatile processor-readable medium  via a communications link (e.g., a computer network). As a specific example, non-volatile processor-readable medium  can be (or be at) a data store or data storage service accessible via a communications link operatively coupled to communications interface module . Computing device  can boot by copying processor-executable codes or instructions from non-volatile processor-readable medium  to memory  via communications interface module , and executing the processor-executable codes or instructions at processor .","Communications interface module  is an interface accessible to processor  to communicate with (i.e., transmit symbols representing data to and receive such symbols from) other processors and\/or computing devices via a communications link. In other words, communications interface module  can receive data from processor  and transmit symbols representing those data via a communications link. In some implementations, classification system  outputs information related to classification of graphical objects via communications interface module .","Moreover, communications interface module  can receive symbols from other communications interface modules via a communications link and send data represented by those symbols to processor . For example, communications interface module  can be a telephone network interface, a twisted-pair network interface, a coaxial network interface, a fiber-optic network interface, a wireless network interface such as a wireless local area network (\u201cWLAN\u201d) or a cellular network, and\/or some other network or communications interface module.","In some implementations, computing device  can include additional modules or components. For example, computing device  can include a graphical interface module (not shown) to provide signals to a display to output information relation to classification of graphical objects. That is, computing device  can output, for example, identifiers of the classes within which classification system  classifies graphical objects.",{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 11","b":["1100","1100"]},"A representation of a graphical object is accessed at block . The representation of the graphical object is then compared with a group of templates of representations of graphical objects to determine whether the representation of the graphical object matches (or satisfies) a template at block . If the representation of the graphical object matches a template, the graphical object is classified in a class associated with the template. That is, the template is associated with a class and the graphical object is classified into the class associated with the template if the representation of the graphical object matches the template.","If the representation of the graphical object does not match (or satisfy) a template at block , process  proceeds to block  at which an appearance-invariant signature of the representation of the graphical object is generated. For example, the appearance-invariant signature can be generated as discussed above in relation to . The graphical object is then classified based on the appearance-invariant signature at block . For example, a classification module determines into which class a graphical object will be classified based on the appearance-invariant signature for the graphical object.","Process  can include addition or fewer blocks than those illustrated in . Additionally, one or more blocks can be rearranged. Furthermore, process  is applicable within many environments. For example, process  can be implemented at a computing device including multiple processors and in communication with various processor-readable media that is configured to host a classification system.","As an example of a system including one or more processors and processor-readable storage media,  is a schematic block diagram of system  including a processor and storage media, according to an implementation. As illustrated in , system  includes one or more processors  operatively coupled to storage medium , storage medium , and storage medium . One or more processors  can access instructions or code at storage medium , storage medium , and storage medium . Storage media , , and  can be any processor-readable media and\/or related devices to access processor-readable media. For example, storage medium  can be a hard disk drive including a magnetic storage medium, storage medium  can be an optical drive such as a DVD drive and can accept DVD storage media on which processor-readable instructions such as processor-readable instructions that implement a report generation tool can be stored, and storage medium  can be a FLASH memory drive with a Universal Serial Bus (\u201cUSB\u201d) interface. In some implementations, storage media , , and\/or  can be local to (e.g., coupled to a common computing device) one or more processors . In some implementations, storage media , , and\/or  can be remote from (e.g., coupled to a separate computing device) one or more processors  and in communication with one or more processors  via communications link. Furthermore, one or more of storage media , , and\/or  can be local to one or more processors  and one or more of the remaining of storage media , , and\/or  can be remote from one or more processors .","As a more specific example, one or more processors  can be included within a computing device such as a communications device having an internal hard disk drive data store represented by storage medium  and a removable solid-state data store such as a Secure Digital High-Capacity (\u201cSDHC\u201d) memory card represented by storage medium . The computing device can also include a USB host controller to communicate with a USB FLASH memory drive represented by storage medium . One or more processors  can access processor-readable instructions such as processor-readable instructions that implement an operating system, software application such as a classification system, and\/or one or more processes at any of storage media , , and\/or . Said differently, one or more processors  can interpret or execute instructions at processor-readable media via storage medium , storage medium , and\/or storage medium . For example, a computing device can execute a classification system stored at a remote storage medium.","Alternatively, for example, storage media  and  can be remote from a computing device including one or more processors  and storage medium  can be local to that computing device. The computing device including one or more processors  can download a classification system from one or both of remote storage media  or  via communications link such as a communications network to local storage medium  and execute the classification system from local storage medium .","In some implementations, system  can include one or more memories such as RAM that function as a cache between one or more of storage medium , storage medium , and\/or storage medium  and one or more processors  for instructions or code stored (or accessible) at one or more of storage medium , storage medium , and\/or storage medium .","While certain implementations have been shown and described above, various changes in form and details may be made. For example, some features that have been described in relation to one implementation and\/or process can be related to other implementations. In other words, processes, features, components, and\/or properties described in relation to one implementation can be useful in other implementations. As a specific example, implementations discussed in relation to graphical user interfaces, controls of graphical user interface, and\/or software automation are applicable to other environments. Furthermore, it should be understood that the systems and methods described herein can include various combinations and\/or sub-combinations of the components and\/or features of the different implementations described. Thus, features described with reference to one or more implementations can be combined with other implementations described herein."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":["FIG. 5","FIG. 2"]},{"@attributes":{"id":"p-0010","num":"0009"},"figref":["FIG. 6","FIG. 2"]},{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 7","FIG. 2"]},{"@attributes":{"id":"p-0012","num":"0011"},"figref":["FIG. 8","FIG. 2"]},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 12"}]},"DETDESC":[{},{}]}
