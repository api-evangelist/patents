---
title: Interactive physical design tuning
abstract: An architecture for providing interactive sessions for physical database design is described, allowing users to readily try different options, identify problems, and obtain physical designs in a flexible way. Embodiments based on a .NET assembly and modifications to a database management system (DBMS) are also described.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08214402&OS=08214402&RS=08214402
owner: Microsoft Corporation
number: 08214402
owner_city: Redmond
owner_country: US
publication_date: 20090615
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION","CONCLUSION"],"p":["Automated physical design tuning involves a database management system (DBMS) recommending a set of physical structures that increase the performance of an underlying database. Physical design has been formulated as a problem statement, traditionally: Given a workload W and a storage budget B, find the set of physical structures, or configuration, that fits in B and results in the lowest execution cost for W. Most modern commercial DBMS's have some facilities for automated design tuning. In general, however, it has not been possible to include in the tuning process information beyond the basic information of the design tuning problem statement.","For instance, it has not been possible to tune a given workload for maximum performance under a storage constraint while at the same time ensuring that no query degrades by more than 10% with respect to the original configuration. As another example, it has not been possible to enforce that the clustered index on a table T cannot be defined over certain columns of T that would introduce hot-spots (without specifying which of the remaining columns should be chosen). As yet another example, in order to decrease contention during query processing, there is no way to avoid any single column from a table from appearing in more than, say, three indexes (the more indexes a column appears in, the more contention arises due to exclusive locks during updates). While some new approaches allow more flexibility in the specification of a physical design tuning problem, existing solutions require that the whole specification to be provided upfront, without possibility of interaction.","Described herein are techniques for flexible and interactive physical design tuning.","The following summary is included only to introduce some concepts discussed in the Detailed Description below. This summary is not comprehensive and is not intended to delineate the scope of the claimed subject matter, which is set forth by the claims presented at the end.","An architecture for providing interactive sessions for physical database design is described, allowing users to readily try different options, identify problems, and obtain physical designs in a flexible way. Embodiments based on a .NET assembly and modifications to a database management system (DBMS) are also described.","Many of the attendant features will be explained below with reference to the following detailed description considered in connection with the accompanying drawings.","Overview","Embodiments discussed below relate to interactive physical design tuning of databases. For background,  shows a physical design tuning tool . The tuning tool  is an application used by a DBA to explore alternate configurations of a database  managed by a DBMS. Different storage boundaries  (e.g., memory limits) and physical configurations and workloads  (sets of queries) can be tested for performance results. The tuning tool  may function as a database client that communicates with the DBMS through an interface (an API provided by the database) to submit \u201cwhat-if\u201d scenarios that the DBMS explores, tests, and provides feedback on without necessarily executing the queries. In other words, the DBMS  can give feedback on how well a query optimizes or performs according to a possible configuration. As a result, the tuning tool  may output some configuration  (e.g., some set of indexes I . . . Im) deemed to be ideal for the given boundaries  and workload . Generally, the tuning tool  may test many configurations for a query before deciding which configuration is optimal. Regarding what-if facilities or instrumentation of a DBMS, description is provided elsewhere, for example, see \u201cSelf-Tuning Database Systems: A Decade of Progress\u201d, VLDB '07, ACM 978-1-59593-649-Mar. 7, 2009.","The scenarios mentioned in the Background above show that the state-of-the-art techniques for physical design tuning are inflexible. Referring to , the typical approach has been to specify a simple scenario, submit same to the DBMS, and receive a recommended configuration. Flexible and interactive refinement has not been possible. The inventors have observed that goals or constraints of tuning the physical design of a database system are often not fully specified upfront, but instead become apparent through experimentation, feedback, analysis, etc. Current physical design tools are monolithic, expose tuning options that are set at the beginning, and generate, without further user input, a final configuration to deploy into a production system.","Embodiments described below shift the design approach and allow tuning sessions to be highly interactive. Current monolithic architectures in physical design tools force users to specify the whole problem upfront and prevent users from making changes a posteriori or in general interacting with the system. Explanation will begin with description of an architecture for interactive sessions, followed by a review of Windows PowerShell as an infrastructure component that can support the architecture. Explanation will proceed with description of interactive tuning processes, followed by presentation of illustrative examples.","Layered Architecture for Physical Design Tuning",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 2","b":["148","150","152","154"]},"A low-level API layer  may expose, in formats that are simple to consume (e.g., XML), the functionality of the Core DBMS layer  (and also the DBMS itself). As an example, they may expose primitives to manipulate a what-if mode of the DBMS and also may expose rich explain modes which, after optimizing queries, surface optimization information use at higher levels of the DBMS. The explain mode may provide useful information about the optimization of a query, such as the final plan obtained by the optimizer, cardinality estimates for intermediate results, access path requests, etc. (it may be thought of as an extension to existing modes in relational systems, such as showplans in Microsoft SQL Server). The low level API layer  may also encapsulate existing DBMS functionality, such as mechanisms that monitor and gather workloads.","A High-level API layer  if provided to facilitate access to the lower level APIs  and Core DBMS layer . Physical design tools were previously built on top of the low-level APIs only exposed a rigid functionality (e.g., point to a workload, set the storage constraint, and optimize). The high-level API layer  exposes the internal representations and mechanisms in a modular way. Basic concepts such as queries, indexes, databases, tables, and access-path requests are exposed as instantiable classes. In addition to these data structures, the high-level API layer  exposes composable and simple algorithms sometimes found in previous tuning tools. For instance, this layer may expose mechanisms to merge two indexes, or to obtain the best set of indexes for a single query. These primitive data structures and algorithms are not necessarily meant to be consumed by DBAs, but instead provide a foundational abstraction for applications to be built on top, as explained next. In one embodiment, described later, the high-level API layer  may be implemented as a .NET assembly , which is executed by a .NET VM  (Virtual Machine), sometimes called a managed code environment.","Front-ends  are based on both the low-level APIs  and high-level APIs  and deliver functionality to end users. One example of a front-end  is an interactive scripting platform to interact with physical database designs. The scripting language understands and works with the data structures and algorithms exposed by the underlying layers and allows users to write interactive scripts to tune the physical design of a database. Common tasks, such as minimizing the cost for a single storage constraint (or other functionality provided by previous physical design tools), can be implemented as pre-existing scripts that can be accessed using graphical user interfaces by relatively inexperienced DBAs.","As mentioned, a front-end  can be implemented by a scripting environment. For example, Windows Powershell  (tm), available from Microsoft Corporation is a scripting language that can be used as a front-end  in the architecture. A prototype implementation of the architecture using Windows Powershell  will also be described.","Windows Powershell","Windows PowerShell is an interactive, extensible scripting language that integrates with the Microsoft .NET Framework. It provides an environment to perform administrative tasks by execution of cmdlets (i.e., commandlets, which are basic operations), scripts (which are composition of cmdlets), stand-alone applications, or by directly instantiating regular .NET classes. The main features of Windows PowerShell include tight integration with .NET, strict naming conventions, object pipelines, and data providers.","Windows PowerShell integrates with the .NET framework and leverages the .NET framework to represent data. Windows PowerShell understands .NET classes natively, as illustrated below. Thus, new classes written in the .NET framework are easily available as first-class citizens in Windows PowerShell.","Windows PowerShell uses strict naming conventions. Cmdlets in Windows PowerShell follow a verb-noun naming convention, and parameters are passed in a unified manner. Some examples of such built-in cmdlets are Start-Service, which starts an OS (operating system) service in the current machine, Get-Process, which returns a list of processes currently executing, Clear-Host, which clears the screen, and Get-ChildItem which, if located in a file system directory, returns all its subdirectories or files. There are also aliases for the common cmdlets.","PowerShell also provides facilities to construct object pipelines. Similar to Unix shells, cmdlets can be pipelined using the \u201c|\u201d operator. However, unlike Unix shells, which typically pipeline strings, Windows PowerShell pipelines .NET objects. For instance, the script:",{"@attributes":{"id":"p-0032","num":"0031"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"> Get-Process | Sort-Object -Property Handles -Desc |"]},{"entry":[{},"Select-Object -first 5 | Stop-Process"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0033","num":"0032"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"> Get-ChildItem -Path *.tex | Where-Object -FilterScript { $ .Length -It"},{"entry":"100000 } | Foreach-Object -Process { Get-Content $ | Select-String"},{"entry":"constraint } | Measure-Object Count : 404"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},{"@attributes":{"id":"p-0034","num":"0033"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"> dir *.tex | ? { $ .Length -It 100000 } | % { gc $ | Select-String"]},{"entry":[{},"constraint } | measure Count : 404"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"PowerShell has the ability to expose hierarchical data models by means of data providers, which are then accessed and manipulated using a common set of cmdlets. As an example, the file system is one such provider. When situated in some node inside the file system provider, Get-ChildItem can be used to obtain the subdirectories or files in the current location, access contents of elements using Get-Content, and navigate the provider using Set-Location (aliased as cd). However, Windows PowerShell natively exposes the registry and the environment variables as providers. There also are third party providers that give a unified surface to access, query, and modify Active Directory, SharePoint and SQL Server, among others.","The next section describes how take advantage of the different features of Windows PowerShell to provide an interactive experience for physical design tuning.","Interactive Physical Design Tuning","A prototype implementation that enables interactive physical design tuning sessions will now be described. The architecture of this implementation is described first, followed by discussion of examples of how the implementation can be used.  shows how the different layers of architecture  map to the implementation. An implementation of each layer of the architecture  will be described in detail.","Low-Level APIs","The Core DBMS  and Low-level APIs  are implemented by instrumenting a database server, for instance Microsoft SQL Server . Some components (e.g., what-if optimization) are already part of this particular database server, while others (e.g., access-path request interception) were added.","High-Level APIs","The high-level API layer  is implemented by introducing a new .NET assembly  that encapsulates and exposes classes and algorithms relevant to physical design tuning. Among the classes that the assembly exposes are Database, Table, Index, Column, Query, Configuration, and Request classes. These are rich in functionality, so for instance the Index class may have methods that return merged and reduced indexes and methods that create hypothetical versions of the index in the database. The Query class may have methods that evaluate (optimize) it under a given configuration, and methods that return its set of access-path requests.","Additionally, as part of the .NET assembly , a sophisticated caching mechanism may be built to avoid optimizing the same query multiple times in the database server. Instead, each query remembers previous optimizations and, if asked again to optimize itself with a previously seen configuration, it returns the cached values without doing the expensive work again.","Because these classes are exposed in an assembly, the definitions thereof can be loaded directly into Windows PowerShell which may be used to explore, in interactive form, the physical design of a database, as illustrated in .",{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 3","b":["180","182","184","186","188","190"]},"Front-End","While the example above is useful, call the .NET methods directly can be inefficient. Also, using such methods directly may be a time consuming way to accomplish tuning a database design. Using the capabilities of Windows PowerShell, functionally such as a provider, visualizations, cmdlets, and scripts can be used.","PowerShell providers are .NET programs that allow a user to work with data stores as though they were mounted drives or file systems, which simplifies accessing external data outside the PowerShell environment. A PowerShell provider can be implemented that exposes the information about a tuning session in a hierarchical and intuitive object model.  shows an XML representation  of a portion of a simplified version of a hierarchy exposed by a provider. By using this provider, the state of a tuning session can be easily manipulated and navigated as shown in .  shows a transcript  of an example interactive tuning session using a provider. Note that file system style commands such as \u201ccd\u201d and \u201cdir\u201d can be used to navigate and view database information, tuning information, configuration information, and so on.",{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 6","b":["250","250","250","252"]},"In addition to a provider, the bare .NET classes and methods of the .NET assembly may be provided with composable cmdlets.  shows an example PowerShell session with two example cmdlets  and .","Scripts are another feature of the implementation.  shows an example script . The script is a simplified implementation of a common operation called refinement, in which a given input configuration is repeatedly \u201crelaxed\u201d via merging and reduction operations until it fits in the available storage, so that the expected cost of the resulting configuration is as low as possible. At each iteration, all possible transformations are calculated (using a cmdlet) and the one that is expected to result in the smaller execution cost is obtained. This process is repeated until a valid configuration is reached:","Other common algorithms may be similarly implemented, such as the relaxation based tuning approach in \u201cAutomatic physical database tuning: A relaxation-based approach\u201d (N. Bruno and S. Chaudhuri., In Proceedings of the ACM International Conference on Management of Data (SIGMOD), 2005). One embodiment implements a version that handles constraint language, described in \u201cConstrained physical design tuning\u201d (N. Bruno and S. Chaudhuri, In Proceedings of the International Conference on Very Large Databases (VLDB), 2008). This script is called TuneConstrained-Workload and takes as inputs a workload, a timeout, and a set of constraints. Such a script may be implemented by using the .NET classes exported by the high-level APIs and may be implemented as a PowerShell script in fewer than 100 lines of code.","A Sample Interactive Tuning Session",{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIGS. 9-11","b":["310","310","310"]},{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 12","FIG. 12","figure 330"],"b":["332","334","336","338"]},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 13","b":["360","362","360","364"]},"Embodiments and features discussed above can be realized in the form of information stored in volatile or non-volatile computer or device readable media. This is deemed to include at least media such as optical storage (e.g., CD-ROM), magnetic media, flash ROM, or any current or future means of storing digital information. The stored information can be in the form of machine executable instructions (e.g., compiled executable binary code), source code, bytecode, or any other information that can be used to enable or configure computing devices to perform the various embodiments discussed above. This is also deemed to include at least volatile memory such as RAM and\/or virtual memory storing information such as CPU instructions during execution of a program carrying out an embodiment, as well as non-volatile media storing information that allows a program or executable to be loaded and executed. The embodiments and features can be performed on any type of computing device, including portable devices, workstations, servers, mobile wireless devices, and so on."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present description will be better understood from the following detailed description read in light of the accompanying drawings, wherein like reference numerals are used to designate like parts in the accompanying description.",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIGS. 9-11"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 13"}]},"DETDESC":[{},{}]}
