---
title: Method and memory device for performing an operation on data
abstract: A method and memory device for implementing long operations and supporting multiple streams are provided. In one embodiment, a memory device receives data and a command from a host to perform an operation on the data, wherein a time required for the memory device to complete the operation exceeds a maximum response time for the memory device to respond to the command. The memory device begins performing the operation on the data and, before exceeding the maximum response time and before completing the operation, sends the context of the operation to the host. At a later time, the memory device receives from the host: (i) a command to resume performing the operation and (ii) the context. The memory device then resumes performing the operation on the data based on the context received from the host.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08516232&OS=08516232&RS=08516232
owner: SanDisk Technologies Inc.
number: 08516232
owner_city: Plano
owner_country: US
publication_date: 20090630
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF THE PRESENTLY PREFERRED EMBODIMENTS","Introduction","CONCLUSION"],"p":["A memory device, such as a smart card or an SD card, can be used as an embedded secure module in a host, such as a personal computer (PC) or a mobile phone, to simultaneously support multiple tasks and application streams from the host. Access to the secure module is often asynchronous because applications running on the host are often not synchronized and because a secure module may only be able to execute a single operation at any moment in time. As a result, multiple applications on a host may need to time-share the secure module. As shown in , data from two or more different applications are divided into multiple blocks and are stored in two or more data buffers until the blocks can be processed by the secure module. In applications such as security processing (e.g., digital signature and encryption generation), blocks of data cannot be processed separately, as the processing of a given block depends on previously-processed blocks. Therefore, when processing two concurrent streams, the current context is saved in the secure module and later used for processing subsequent blocks. However, saving the context in the secure module can consume a relatively-large amount of memory, which can be a problem for memory devices, such as smart cards and SD cards, that have limited memory space. When used as secure modules, such storage devices may further require a special state management block, which can significantly increase the price of the secure module. Also, the performance of the secure module can significantly decrease because repeatedly writing the context to non-volatile memory can take a relatively-long time and decrease the life cycle of the non-volatile memory.","Another difficulty encountered with security processing in secure modules is that the time needed to complete a security operation (e.g., RSA key generation or RSA signature) can be longer than a maximum response time for the memory device to respond to the command. Smart cards deal with this situation by using a special \u201cnot ready\u201d command (such as a \u201cNULL\u201d procedure byte defined in ISO-7816-3) to instruct the host to keep waiting (see ). However, with this approach, the host may need to wait a relatively-long time until the operation is complete and may not be able to interrupt the operation. Additionally, there is a risk that the host driver could put the secure module in sleep mode during this time, which can result in the secure module's volatile memory being erased. Further, for some secure modules, such as SD cards, such special \u201cnot ready\u201d commands cannot be implemented since they are not defined at the physical protocol level.","Embodiments of the present invention are defined by the claims, and nothing in this section should be taken as a limitation on those claims.","By way of introduction, the embodiments described below are directed to a method and memory device for performing an operation on data. In one embodiment, a memory device receives data and a command from a host to perform an operation on the data, wherein a time required for the memory device to complete the operation exceeds a maximum response time for the memory device to respond to the command. The memory device begins performing the operation on the data and, before exceeding the maximum response time and before completing the operation, sends the context of the operation to the host. At a later time, the memory device receives from the host: (i) a command to resume performing the operation and (ii) the context. The memory device then resumes performing the operation on the data based on the context received from the host.","Other embodiments are possible, and each of the embodiments can be used alone or together in combination. Accordingly, various embodiments will now be described with reference to the attached drawings.","The following embodiments provide a method and memory device for performing an operation on data. As noted above, some operations that a host asks a memory device to perform may take longer than the maximum response time given to the memory device to respond to the command. Some of the embodiments described below present a solution to this \u201clong operations\u201d problem that avoids the disadvantages encountered with prior solutions. Other embodiments described below can be used to support multiple applications without increasing cost and without decreasing security. The \u201clong operations\u201d embodiments and the \u201cmultiple streams\u201d embodiments discussed below can be used alone or in combination with each other. Before turning to these embodiments, the following section discusses an exemplary memory device that can be used to implement either or both of these embodiments. It should be noted that other types of memory devices can be used.","Exemplary Memory Device",{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 1","FIG. 1"],"b":["100","100","100","110","120","110","111","120","112","50","150","100","50"]},"The controller  also comprises a central processing unit (CPU) , a crypto-engine  operative to provide encryption and\/or decryption operations (the crypto-engine  can be implemented in hardware or software), read access memory (RAM) , read only memory (ROM)  which stores firmware for the basic operations of the memory device , and a non-volatile memory (NVM)  which stores a device-specific key used for encryption\/decryption operations.","The memory  can take any suitable form. In one embodiment, the memory  is a mass storage device that takes the form of a solid-state (e.g., flash) memory and can be one-time programmable, few-time programmable, or many-time programmable. However, other forms of memory can be used. In this embodiment, the memory  comprises a public partition  that is managed by a file system on the host  and a hidden protected system area  that is internally managed by the controller . The hidden protected system area  stores firmware (FW) code  which is used by the controller  to control operation of the memory device , as well as a content encryption key (CEK) , which will be described below.","The public partition  and the hidden protected system area  can be part of the same memory unit or can be different memory units. The hidden protected system area  is \u201chidden\u201d because it is internally managed by the controller  (and not by the host's controller) and is \u201cprotected\u201d because objects stored in that area  are encrypted with the unique key stored in the non-volatile memory  of the controller . Accordingly, to access objects stored in that area , the controller  would use the crypto-engine  and the key stored in the non-volatile memory  to decrypt the encrypted objects. Preferably, the memory device  takes the form of a secure product from the family of products built on the TrustedFlash\u2122 platform by SanDisk Corporation.","In this embodiment, protected content files A, B are stored in the host  and are protected by cryptography algorithms. For example, the content A, B can be encrypted and signed using key stored in the memory device  (e.g., in the controller's NVM  or in some other location).","The memory device  and host  can communicate with each other via a host interface . In one embodiment, for operations that involve the secure transfer of data, the crypto-engine  in the memory device  and the crypto-engine in the host  can be used to mutually authenticate each other and provide a key exchange (this is optional and not mandatory). The mutual authentication process calls for the host  and memory device  to exchange unique certification IDs. The host  and the memory device  can perform mutual authentication based on PKI. After mutual authentication is complete, it is preferred that a session key be used to establish a secure channel for communication between the memory device  and the host . It should be noted that single authentication can also be performed.","The controller  can be implemented in any suitable manner. For example, the controller  can take the form of a microprocessor or processor and a computer-readable medium that stores computer-readable program code (e.g., software or firmware) executable by the (micro)processor, logic gates, switches, an application specific integrated circuit (ASIC), a programmable logic controller, and an embedded microcontroller, for example. Examples of controllers include, but are not limited to, the following microcontrollers: ARC 625D, Atmel AT91SAM, Microchip PIC18F26K20, and Silicon Labs C8051F320. The controller  can also be implemented as part of the memory  control logic.","Example Methods for Performing an Operation on Data","After the host  sends a command to the memory device , the host  will expect the memory device  to respond to the command within a certain amount of time. Depending on the application, the maximum response time can range from a few hundred milliseconds to a few seconds, for example. If the memory device  does not respond to the command within the maximum response time allotted, the host  may assume that an error occurred. A problem occurs, however, when the memory device  is asked to perform an operation that takes longer than the maximum response time. For example, the time required for the memory device  to complete a security operation, such as an RSA key generation operation or an RSA signature operation, may exceeds a maximum response time for the memory device  to respond to the command. Smart cards deal with this situation by using a special \u201cnot ready\u201d command to force the host  to give the smart card more time to complete the operation. However, a special \u201cnot ready\u201d command may not be available to all memory devices because of protocol definitions. Further, even if a special \u201cnot ready\u201d command is available, forcing the host  to wait until the operation is complete can lead to performance degradation and other issues, such as losing data during a power cycle or reset.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 2","FIG. 1","FIG. 2"],"b":["200","100","100","50","210","100","100","100","220"]},"If the memory device  were to perform the operation to completion, the memory device  would exceed the maximum response time to respond to the command. So, in this embodiment, before exceeding the maximum response time and before completing the operation, the memory device  sends (i) an indication that the operation on the data is not complete and (ii) the context of the operation (act ). In this way, the memory device  can be considered to have interrupted the operation and needs to resume the operation at a later time. The indication and context will now be discussed.","The indication that the operation on the data is not complete informs that host  that it will need to provide another command to the memory device  to continue the operation. This indication can take any suitable form, such as, for example, a flag in the normal response provided to the host . It should be noted that this indication is different from the special \u201cnot ready\u201d command discussed in the background section above. The special \u201cnot ready\u201d command forces the host to wait until the memory device has completed the long operation and needs to be pre-defined in the protocol used by the host and the memory device. In contrast, the indication provided to the host  in this embodiment merely informs the host  that it needs to send an additional command in order to instruct the memory device  to continue with the operation (e.g., a similar or identical command to the one previously issued to the memory device  that caused it to perform the operation in the first place) and can be provided using native send\/receive (read\/write) commands. (In some embodiments, both the \u201cnot ready\u201d command and the indication can be used together.) Further, because this indication does not force the host  to wait for the memory device  to complete the operation, this embodiment gives the host  more control over executing operations on the memory device . That is, after receiving the indication, instead of sending another command to the memory device  to allow it to continue with the operation, the host  can send a different command to the memory device  for a different operation. In this way, the host  can interleave operations from other applications (i.e., handle \u201cmultiple streams\u201d), as will be described in more detail below.","As mentioned above, in addition to providing the operation-not-complete indication, the memory device  also sends the current context of the operation to the host . As used herein, \u201ccontext\u201d includes the minimal set of data that is saved to allow the operation to be able to be continued after interruption. This minimal set of data can be, for example, the current execution state and\/or the partial result of an operation. Many different types of operations and, accordingly, many different types of context can be used. For example, the operation can be a cryptographic operation, and the memory device  can generate a secret key for use in the cryptographic operation. Examples of cryptographic operations included, but are not limited to, an AES operation, a DES operation, an RC4 operation, an RSA operation, a DH operation, a DSS operation, an ECDH operation, an ECDSS operation, a MQV operation, a SHA1 operation, a SHA256 operation, a SHA384 operation, a SHA512 operation, an HMAC operation, a CBC-MAC operation, and a CMAC operation. If the cryptographic operation takes the form of an AES operation, a CBC-MAC operation, a CMAC operation, or a DES operation, the context can take the form of a current initial vector. Likewise, if the cryptographic operation takes the form of a SHA1 operation, a SHA256 operation, a SHA384 operation, a SHA512 operation, or a HMAC operation, the context can take the form of a current digest value. Additionally, if the cryptographic operation takes the form of a code block chaining (\u201cCBC\u201d) operation, the context can take the form of a last encrypted block. As mentioned above, in addition to or instead of an encryption operation, other types of operations can be performed. For example, the operation can be an operation to read or write data in non-encrypted form, perform a calculation on data, or transit\/receive data over a wired or wireless network.","As noted above, from the context, the memory device  can resume the operation from the point at which it left off. Accordingly, at a later time, when the host  sees fit, the host  would send the memory device  a command to resume performing the operation, along with the context previously provided to the host  by the memory device  (act ), and the memory device  would resume performing the operation on the data based on the context received from the host  (act ). If the memory device  can complete the operation within the maximum response time to respond to the command, the operation will be complete. However, if the memory device  still cannot complete the operation, acts , , and  are repeated as often as needed to complete the operation.","It should be noted that, in these embodiments, the context is stored in the host  and not in the memory device . (Alternatively, the context can be stored on yet another so-called proxy (e.g., another host\/server\/memory device).) Storing the context in the host  solves the problems discussed in the background section above. Specifically, storing the context in the host  instead of the memory device  avoids consuming a relatively-large amount of memory in the memory device , which can be particularly important for memory devices such as SD cards, which can have a restricted amount of memory. Also, storing the context in the host  avoids the need for (and expense of) a special state management block in the memory device . Further, by taking advantage of the host's resources (e.g., more RAM and stronger CPU), these embodiments avoid the negative impact on the memory device's performance and memory life cycle caused when the context is stored in the memory device .","There are many alternatives that can be used with these embodiments. For example, the memory device  can encrypt the context before providing the context to the host , thereby adding a level of security. The key used for such encryption can be a secret key stored in the memory device , as described above. The secret key can also be used to sign the context before providing the context to the host , thereby providing even additional security, as a digital signature based on a secret that is stored in the memory device  will allows detection of any change that may occur by mistake or as result of attack. Additionally, the memory device  can send operational information to the host  along with the context. The memory device  would receive this operational information back from the host  along with the context and can analyze the operational information to detect a fault or tampering of the context. Operation information can take any suitable form, such as, but not limited to, data length, identification of the algorithm that was used, the key size, and\/or the session number.","Also, as mentioned above, because the operation-not-finished indication provided by the memory device  does not force the host  to wait for the memory device  to be finished with the operation, this embodiment gives the host  more control over executing multiple operations on the memory device . This flexibility is illustrated in . Here, the host  provides data and the initial command to perform an operation to the memory device  (along with an initial context, if any). After the memory device  is done with the first part of the operation (i.e., the part of the operation that the memory device  can complete before exceeding the maximum response time), the memory device  returns the context to the host  for storage. As mentioned above, because the context is stored in the host  and not in the memory device , the memory device  does not suffer the performance and other issues described above when the context is stored in the memory device .","In this embodiment, when the memory device  sends the context to the host , it also sends an indication (e.g., a flag) to indicate that the host  needs to send an additional command to resume the operation at a later time. In response to this indication, the host sends a command to resume performing the operation, along with the previously-stored context, and the above-described process is repeated. The command to resume the operation can come immediately after the host  receives the indication. However, if the command to resume comes at a later time, the memory device  would be released to execute another command for another operation of the same or different application on the host . In this way, the host  can interleave commands from multiple applications between commands to perform the long operation. It should be noted that interleaving can take any suitable pattern. So, instead of alternating between commands from the first and second applications, the host  can provide two or more consecutive commands from one application before providing a command from another application.","In the above example, the memory device  was responsible for providing the host  with an indication that the host  needs to send an additional command to complete the operation. The controller  in the memory device  can know what the maximum response time is and can ensure that the response and the operation-not-complete indication is provided to the host  in time. Alternatively, the buffer of the memory device  can be designed such that the buffer can only store enough data that can be processed within the maximum response time. Nevertheless, the memory device  would still be responsible for determining whether the operation-not-complete indication should be provided to the host , as it is the memory device \u2014not the host \u2014in this embodiment that knows whether the operation needs to be continued.","In an alternate embodiment, instead of the memory device  being responsible for informing the host  that it needs to send an additional command to continue the operation, the host  can take this responsibility. Accordingly, in this alternative embodiment, the memory device  does not need to provide the host  with an operation-not-complete indication because the host  is tracking if and when the operation is complete. This alternative provides similar advantages of interleaving commands from different applications and operations. As illustrated in , the host  provides data and the initial command to perform an operation to the memory device  (along with an initial context, if any). In this embodiment, the host  arranges the data to be processed in a series of blocks, with each block containing no more data than can be processed within the maximum response time of the memory device . After the memory device  is done processing the first block of data from this first application, it returns the context of the operation to the host  for storage. (As mentioned above, because the context is stored in the host  and not the memory device  in this embodiment, the memory device  does not suffer the performance and other issues described above when the context is stored in the memory device .) Since the host  organizes the data into blocks, it knows if an additional command is needed to complete the operation if there are additional blocks that need processing. So, the memory device  does not need to send an operation-not-complete indication to the host , as in the previously-described embodiment.","When the memory device  is done processing the first block from the first application, the host  can send the memory device  another command. In the example shown in , the host  sends the memory device  a command from a second application to process a first block of data from that second application. The above-described process is then applied to that block of data, and the memory device  is released to perform another operation (here, a command from the first application to process a second block of data). In this way, the host  can interleave commands to support multiple streams from multiple applications. (Breaking down a transaction into multiple blocks also protects against a system crash.) It should be noted that interleaving can take any suitable pattern. So, instead of alternating between the first and second applications as shown in , the host  can provide two or more consecutive commands from one application before providing a command from another application. Also, while the first and second applications are initialized by the same host  in this example, in other embodiments, the applications are initialized by different hosts (e.g., when both hosts have the same encryption and signature keys).","As shown by the illustration in , the context of the operation is returned to the application on the host , and the process of storing the context is handled by the application. Storing the context on the host  not only eliminates the requirement of additional RAM memory and internal non-volatile memory in the memory device , but it also eliminates the requirement for management firmware in the memory device , as every application will handle the context for its own stream(s). Additionally, the application does not need to understand what the context includes. It is just needs to store the context and provide it together with next command.","It is intended that the foregoing detailed description be understood as an illustration of selected forms that the invention can take and not as a definition of the invention. It is only the following claims, including all equivalents, that are intended to define the scope of the claimed invention. Finally, it should be noted that any aspect of any of the preferred embodiments described herein can be used alone or in combination with one another."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIGS. 5 and 6"}]},"DETDESC":[{},{}]}
