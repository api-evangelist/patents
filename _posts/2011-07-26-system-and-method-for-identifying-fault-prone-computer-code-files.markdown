---
title: System and method for identifying fault prone computer code files
abstract: Metrics associated with computer code files within a codebase may be analyzed to identify bug-prone files. Functions of the method or system may determine metrics corresponding to each file of a plurality of codebase files within an application codebase. The functions may also store the metrics corresponding to each codebase file in a record of a database table, rank order the plurality of codebase files according to at least one metric, and flag each codebase file having a ranking over a threshold value of the metric. The codebase file metrics may describe fault-inducing characteristics of the plurality of codebase files and include both a total number of previous faults and a total number of changes that are associated with each codebase file.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09268665&OS=09268665&RS=09268665
owner: Trimble Navigation Limited
number: 09268665
owner_city: Sunnyvale
owner_country: US
publication_date: 20110726
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF TECHNOLOGY","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The present disclosure relates generally to identifying fault prone computer code and more specifically to a system and a method configured analyze metrics associated with codebase code files to identify files that are most likely to cause faults when executed.","The background description provided herein is for the purpose of generally presenting the context of the disclosure. Work of the presently named inventors, to the extent it is described in this background section, as well as aspects of the description that may not otherwise qualify as prior art at the time of filing, are neither expressly nor impliedly admitted as prior art against the present disclosure.","Complex software applications often require massive collections of source code files organized within codebases. Codebases are usually created by engineers, software developers, and other technicians who write individual code files describing the application's modules, methods, functions, etc. These files are included within the application's codebase. To keep the files organized, the codebase may be conceptually maintained in a tree structure maintained by a version control system. Within the code tree, a branch generally describes a version of an application module that was changed, but does not include any new features, while a trunk may include a module with new features. Teams of engineers design, develop and deploy software across distant locations. Multiple versions of software files are often deployed from these different locations while other developers work on updates to the same files. Errors or \u201cbugs\u201d may only be present in certain versions, therefore to locate and fix any bugs, particular versions of the software must be located and tested to determine which version(s) are causing the problem.","During the lifetime of an application, software developers commit or merge multiple file versions, patches, edits, etc., to the codebase. These commit operations tell the version control system that a group of changes will be made final and available to all users. That group of changes is typically maintained in a change list. Each group of changes in a single commit action includes a unique change list ID.","Of course, whenever a software developer performs a commit action, he or she also possibly introduces bugs to the codebase. To counter the inevitable introduction of bugs, most software development teams are complimented by a quality assurance team to perform automated and manual testing of the files within the codebase. Ideally, quality assurance teams perform tests on the submitted files until the codebase reaches a confirmed level of code maturity and stability. However, because the complex development and execution relationships between the various files in the code tree, it is difficult to measure an exact level of quality assurance. For example, development of an application follows numerous paths along the code tree including various branches and trunks during the development cycle. Accounting for and writing tests for every possible code path in a complex application would consume a significant amount of resources and time. Further, it has been observed that bugs are not distributed linearly within a codebase, but rather, bugs occur in \u201cbursts\u201d where a single bug causes multiple, other bugs in a cascading effect throughout the code base. Thus, testing a percentage of the total amount of code within the codebase will not account for an equal percentage of the total number of bugs that are present in the codebase (i.e., scanning fifty percent of the total amount of code within the codebase will not account for fifty percent of the total bugs in the codebase).","Some techniques to identify and analyze bugs within a codebase have focused on providing a Boolean indicator of whether a particular piece of the codebase was more or less likely to include a bug. For example, cache techniques may rank files within a codebase according to the number of lines of code within the file. Then, each of the ranked files and its closest relatives may receive a \u201chit\u201d if it had been changed to fix a bug. Files that have been fixed most recently may remain in the cache, while those that have been changed less recently may be removed from the cache. These techniques allow a \u201chit or miss\u201d identification of fault-prone files within a cache selection of the codebase.","A computer-implemented method or a computer system or a computer-readable medium storing a set of instructions for execution on a processor operates to identify fault-prone code by determining, ranking, and analyzing metrics associated with codebase code files. Functions of the method or system or stored on a computer-readable medium may determine metrics corresponding to each file of a plurality of codebase files within a codebase for an application. The functions may also store the metrics corresponding to each codebase file in a record of a database table, rank order the plurality of codebase files according to at least one metric, and flag each codebase file having a ranking over a threshold value of the metric. The codebase file metrics may describe fault-inducing characteristics of the plurality of codebase files and include both a total number of previous faults and a total number of changes that are associated with each codebase file.","In some embodiments, the computer-implemented method or computer system or computer-readable medium storing a set of instructions for execution on a processor operates to detect a change to the plurality of codebase files and update the metrics corresponding to each file of the plurality of codebase files. Some embodiments may then continuously rank order the plurality of codebase files according to the updated metrics to account for fault-inducing changes to the codebase files.","The metrics may further include one or more of a file ID, a change list ID, a number of lines of code within the file, a time the file was last edited, a change density, a total number of faults, a fault density, logical coupling relatives, and spatial relatives. The change density may include a number of times the file has been changed compared to the number of lines of code within the file and the fault density may include the total number of faults compared to the number of lines of code within the file. The logical coupling relatives may include a measurement of a number of times a file is changed in conjunction with a change action for another file in the codebase, while the spatial relatives may include a measurement of a number of times a file is changed in conjunction with a change action for another file in a same folder or package as the file.","In further embodiments, rank ordering the plurality of codebase files may include determining a weighted average of the metrics for each codebase file and ranking the plurality of codebase files according to the weighted average. Further, rank ordering may include a subset of the plurality of codebase files that are ranked according to at least one metric. The subset may include a folder, an extension, a feature, or a package of a codebase file.","In still further embodiments, the system may include a processor and a memory that stores various structures and modules to identify fault-prone code. For example, a version control module may be stored in the memory and have an API defining functions that are executable by the processor to store codebase files within a codebase and manage a change list for tracking changes to the codebase files. Also, a database may be stored in the memory and include a plurality of records that each store a set of metrics corresponding to each codebase file stored in the codebase. A bug organizer module may be stored in the memory and have an API defining functions that are executable by the processor to determine the sets of metrics for each codebase file, store the sets of metrics in the records, and rank order the codebase files within a table of the database according to the sets of metrics.","The features and advantages described in this summary and the following detailed description are not all-inclusive. Many additional features and advantages will be apparent to one of ordinary skill in the art in view of the drawings, specification, and claims hereof. Additionally, other embodiments may omit one or more (or all) of the features and advantages described in this summary.","Generally speaking, a debugging system and method may identify files within a codebase that are most likely to include bugs by measuring and analyzing particular metrics that are associated with each file in the codebase. The file metrics may be associated with a version history of the codebase and include a plurality bug localities and heuristics as described below.",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1","b":["100","102","103","104","103","102","103","102","104","106","102","106","106","102","106","107","107","107","107","102","102","104","104","107","102","107","106","106"],"i":["a ","a ","b ","a ","b","a. "]},"The version control API  may also associate the change list ID , comments , and metrics with the code files when a developer, automatic code generator, or other entity or device performs the commit action or other action (e.g., an edit action, a bug counting action, etc.) with the code file . A bug organizer API  may identify and extract codebase files from the codebase  that have one or more metrics associated with the files. The bug organizer API  may then organize the extracted codebase files into a database  according to the file metrics. The database  may then sort and order the extracted codebase files into an ordered set of codebase files  according to the metrics. A member of the ordered set  may be selected as a baseline file  that includes a value of the metrics such that those files having a value above  or below  the value of the baseline file  metrics are identified as most likely to include bugs. A quality assurance team may then focus their attention on only those codebase files that are most likely to include bugs. A bug tracking system  may also maintain a bug list having identifiers that reference one or more bugs that have been identified and\/or fixed within the codebase files . Where the bug list includes an identifier corresponding to a fixed bug, a change list ID may also correspond to the bug list ",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 2","b":["200","200","202","204","202","202","202","104","204","202","202","204","102","200","106"]},"The metrics  may include any information that is useful to identify bug-prone codebase files. In some embodiments, the metrics  include a file ID , a change list ID , a number of lines of code within the file , a time the file was last edited , a number of times the file has been changed , a change density  (i.e., a number of times the file has been changed compared to the number of lines of code within the file), a total number of bugs found in the file , a bug density  (i.e., a number of bugs found in the file compared to the number of lines of code within the file), logical coupling relatives , and spatial relatives .","A version control API  may associate a change list ID  with the file . In some embodiments, the API  associates a unique change list ID with any file that is added to the codebase  in a commit action. For example, the API  may execute a commit action to add several files to the codebase  that have been edited by a developer merely to add or remove features or to correct a fault. The version control API  may attach comments to each changed file or to a particular change list ID  that indicate whether the file or files associated with that change list ID were edited to add or remove features or to correct a fault.","The lines of code  metric may indicate a file having more bugs because files with more lines of code tend to contain more bugs. While bugs are not evenly distributed throughout the codebase , a file having a high the number of code lines may be a good indicator that the file will also contain bugs. Additionally, longer files may also be harder for a developer to understand and increase the likelihood of a fault within the file.","The last edit time  metric may be selected as an indicator that a bug may have been introduced to the file because older files are more likely have had their bugs fixed than newer files. If a file has not been modified in a long time, then it is more likely that the file has stabilized and is not a source of bugs.","The number of changes  metric may also be used to identify bug-prone code files because more changes increase the opportunities for introducing bugs to the file.","The change density  metric may be selected to balance the effect of file length  against the number of changes . A file may be changed many times because it is very large. However, a small file that is changed often may indicate a greater opportunity for bug introduction across a small number of code lines. The change density  may be a measure of the number of changes versus the number of lines of code  in the file.","The total number of bugs found  metric may indicate that an associated file is bug prone. In some embodiments, the metric  may be incremented whenever the file  is associated with a change that fixes a bug. For example, in a commit action, the version control API  may associate a change list ID and comments with any file  that is edited. The bug organizer API  may search the comments for any word, phrase, or symbol that indicates the file  corresponding to the change list ID and comments was edited to fix a bug. In some embodiments, the API  searches the comments for words such as bug, fix, repair, patch, error, fault, etc., that indicate that the comments are associated with a file  that has been changed to fix a bug. Further, an identifier of the bug list may also correspond to a change list ID and, thus, contribute to the total number of bugs found  metric. In other words, a file  that, at least at one time, included a bug, is more likely to continue to have a bug.","The bug density  metric accounts for the number of bugs in the file  against the number of code lines  in the same file . For example, a file  including many thousands of lines of code , but only three total bugs  may be much less bug prone than a file including only five lines of code  and two total bugs . The bug density  may be a measure of the total number of bugs versus the number of lines of code  in the file.","The logical coupling relatives  include a metric to assess how many times the file  was changed in conjunction with other files. For example, files that are changed at the same time often share resources or rely on each other in some way during execution. Therefore, a change in any file that relies on another file during execution may introduce bugs in that other file. Further, two files that are changed at the same time may also introduce bugs in those two files. In some embodiments, associating file IDs and a change list ID may indicate a number of files that were changed at the same time. The logical coupling relatives  may be ranked according to the smallest coupling distance. For example, a coupling distance between two files fileA and fileB is equal to:",{"@attributes":{"id":"p-0033","num":"0032"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":{"mn":"1","mrow":{"mi":["number","of","times","fileA","and","fileB","were","changed","together"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}},"mo":"."}}},"br":{},"b":["103","224"]},"When the bug likelihood is averaged for a number of the \u201cclosest\u201d files to fileA, using a bug likelihood that comes from the number of \u201cclosest\u201d files to calculate a logical coupling might cause endless recursions. For example, if the ten files logically coupled to fileA are {fileB, fileC, fileD, . . . , fileJ, fileK}, using the logical coupling metric to calculate the files' bug likelihood might result in the bug likelihood of fileA depending on the bug likelihood of fileB, and the bug likelihood of fileB depending on the bug likelihood of fileA (i.e., if fileA is logically coupled with fileB, fileB is also logically coupled with fileA). To avoid this computational issue, the bug likelihood that depends on logical coupling relatives of fileA should not be used when averaging the bug likelihood of the logical coupling relatives of fileA.","The spatial relatives  include a metric to assess the relatives of files that are in the same package or folder within the codebase . Much like logical coupling , a file within the same package or folder as another file may cause bugs in that other file. In some embodiments, associating file ID, package IDs, folder IDs, extensions, etc., to a change list ID may indicate a number of files that were changed at the same time and within the same file, package, folder, etc. A spatial relative depends on the logical coupling distance as described above except that the compared files need to be in the same folder\/package in the codebase . In other words, calculating spatial relatives  requires that files have a small or \u201cclosest\u201d coupling distance and the files need to be in the same folder\/package.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIGS. 3 and 4","b":["300","400","103","300","400","103","103","108","106","102","110","300","400","300","400","310","312","314","316","318","320","322","324","402","404","112","300","400","110","103","103","112","106","108","102","108","116","118","114","110","102","108","102","310","312","314","316","318","320","322","324","402","404"],"i":["a ","a"]},"Importantly, the data tables  and  may permit analysis and ranking of codebase files according to whether a file or subset of codebase files is more fault-prone than another file or files (e.g., a baseline file ). Past bug identification and analysis techniques using only a cache of the codebase files did not allow fault risk analysis among files that were not in the cache. In other words, past cache-based systems for analyzing fault-prone code retained files in the cache that were considered fault prone, but these fault-prone files were not ranked one above another as more or less fault prone than other files in the codebase. The database system  employing the data tables  and  may permit the addition of other metrics to the analysis without completely retraining the bug organizer API  on the code tree as required in a cache-based system.","A first data table  may be created by the bug organizer API  from the codebase files  and include at least some of the metrics described above. In some embodiments, the table  includes data for each of the files within the codebase as a data table record . The data may include the name of each file  selected from the codebase, a changelist ID , a number of lines of code in the file , a time of the last change to the file , a total number of changes to the file , a change density , a total number of bugs in the file , and a bug density  to name only a few possible types of data that may be stored in the table .","A second data table  may be created from the codebase files  and include at least some of the metrics described above. In some embodiments, the table  is created by the bug organizer API  and includes a file ID , a change list ID , a logical coupling relative metric , and a spatial relatives metric .",{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 5","FIG. 5","FIGS. 1-4"],"b":["500","102","500","100","300","500","100","102","103","500","108","100","500","600"]},"At block , the method  may store the metrics  and codebase files  of the codebase  and the various metrics in the bug analyzer database . In some embodiments, the bug organizer API  creates one or more tables (e.g., tables  and ) and populates those tables with the metrics  portion of each file  within the database . The method  may populate the database  using files  that include a last change time  that is more recent that a particular threshold. For example, files having a last changed time  of greater than one month, six months, or another period may indicate that the file is generally stable and bug-free. Block  may be configured by a user to select files having a last changed time  according to a user-defined threshold (e.g., one month, six months, etc.). The API  may also store both the code  and metrics  portions of each file  in the database . To populate the database tables  and , the bug organizer API  may be trained on the code tree to identify each folder, extension, etc., of the codebase  and organize the files  according to the metrics described above. The API  may first cycle through the files  of various codebase directories to collect the metrics  for each file ID. The API  may also cycle through the change list  to determine the number of bugs  for each file. In some embodiments, the API  may parse and analyze the codebase  and the change list IDs and comments for each codebase file to determine the total number of bugs for each file. For example, the API  may initiate a first loop to parse and analyze the codebase . The API  may then parse the comments within each change list  that correspond to a change list ID . A file corresponding to a file ID  that is associated with a change list ID  and a change list comment including words that indicate a fixed bug (i.e., fix, bug, error, fault, glitch, issue, undocumented feature, challenge, design side effect, problem, etc.) will be a \u201chit\u201d such that block  will increment the total number of bugs  corresponding to that file ID .","At block , each file entry within the data tables  and  may be updated to include the metrics or more information for one or more files as determined by the API  from the change lists  and other data. In some embodiments, the API  monitors the last change time  metric for files within the codebase  and executes block  if the last change time  metric is updated. In other embodiments, the API  monitors other metrics or a combination of metrics to determine when the database  and tables  and  should be updated. Block  ensures that the method  continuously updates the database  and tables  and  so that the ranking described below is an accurate representation of the current codebase . By ensuring that the database  includes an accurate representation of the current codebase , the method  is able to continuously rank the files in the database  and allows accounting for the introduction of fault-inducing code into the codebase files  as developers and other methods edit or add to the codebase .","At block , a subset of the records  for analysis may be determined. In some embodiments, a subset is determined as a query to the codebase  or the database  according to one or more criteria. For example, to analyze only C++ files, the bug organizer API  may initiate a query to the database  to select only those files  including a file ID  with a \u201c.cpp\u201d file extension. Additionally, the bug organizer API  may query a particular directory or sub-directory of the codebase  to retrieve a particular set of files  and populate the database  for later analysis. The API  may initiate a SQL-like string to create various subsets and determine a total number of files  within the subset.","At block , the files  may be ranked according to the metrics and averages of the metrics for the files retrieved from the database . In some embodiments, the files  may be rank ordered according one or more of the metrics , , , , , , , , , and  or a weighted combination of the metrics. Additionally, each ranking may then be totaled and averaged to determine an average ranking  for each file  based on the metrics. The method  may also determine each ranking  according to various file characteristics such as determining a file's overall percentile within the database  or within a targeted folder of the codebase . Also, the method  may also retrieve any files from the database  that include a metric that is above a given percentile threshold. In some embodiments, a baseline file  may be determined as including a metric ranking or an average ranking above or below which a file may be fault-prone and likely to include one or more bugs to be corrected. For example, a ranking  may be used as a limit in a query to the database  to determine files that should be flagged for further analysis.","At block , the method may flag each file  that includes a particular metric or total average  above a threshold value. In some embodiments, the block  may include a flag  for each file that includes an average ranking  or a ranking of a single metric , , , , , , , , , and , combination of metrics, or a weighted combination of the metrics above the baseline . The flag  may be used by another API to indicate which files are likely to be fault-prone. The flagged files may then be reviewed to determine if the file includes a bug and, if so, fixed.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 6","FIG. 1","FIG. 2","FIGS. 3 and 4","FIG. 5"],"b":["600","601","500","102","601","600","102","104","108","110","200","600","600"]},"As shown in , the system  includes a processor  that is coupled to an interconnection bus . The processor  includes a register set or register space , which is depicted in  as being entirely on-chip, but which could alternatively be located entirely or partially off-chip and directly coupled to the processor  via dedicated electrical connections and\/or via the interconnection bus . The processor  may be any suitable processor, processing unit or microprocessor. Although not shown in , the system  may be a multi-processor system and, thus, may include one or more additional processors that are identical or similar to the processor  and that are communicatively coupled to the interconnection bus .","The processor  of  is coupled to a chipset , which includes a memory controller  and a peripheral input\/output (I\/O) controller . As is well known, a chipset typically provides I\/O and memory management functions as well as a plurality of general purpose and\/or special purpose registers, timers, etc. that are accessible or used by one or more processors coupled to the chipset . The memory controller  performs functions that enable the processor  (or processors if there are multiple processors) to access a system memory  and a mass storage memory .","The system memory  may include any desired type of volatile and\/or non-volatile memory such as, for example, static random access memory (SRAM), dynamic random access memory (DRAM), flash memory, read-only memory (ROM), etc. The mass storage memory  may include any desired type of mass storage device. For example, if the fault-prone code identification system  is used to implement a bug organizer module  having an API  and a version control module  (as described by the method  of ), the mass storage memory  may include a hard disk drive, an optical drive, a tape storage device, a solid-state memory (e.g., a flash memory, a RAM memory, etc.), a magnetic memory (e.g., a hard drive), or any other memory suitable for mass storage. As used herein, the terms module, function, operation, procedure, routine, step, and method refer to computer program logic or computer executable instructions that provide the specified functionality to the computing device. Thus, a module, function, operation, procedure, routine, step, and method can be implemented in hardware, firmware, and\/or software. In one embodiment, program modules and routines (e.g., the bug organizer module , the API , and the version control module  are stored in mass storage memory , loaded into system memory , and executed by a processor  or can be provided from computer program products that are stored in tangible computer-readable storage mediums (e.g. RAM, hard disk, optical\/magnetic media, etc.). Mass storage  may also include a database  storing a plurality of codebase files , a version history , a code tree , and change list  and a database interface module through which the bug organizer module , the API , the version control module , etc., may access the parametric objects .","The peripheral I\/O controller  performs functions that enable the processor  to communicate with peripheral input\/output (I\/O) devices  and  and a network interface  via a peripheral I\/O bus . The I\/O devices  and  may be any desired type of I\/O device such as, for example, a keyboard, a display (e.g., a liquid crystal display (LCD), a cathode ray tube (CRT) display, etc.), a navigation device (e.g., a mouse, a trackball, a capacitive touch pad, a joystick, etc.), etc. The I\/O devices  and  may be used with the bug organizer module  and version control  to receive attributes and formulas and display user interfaces as described in relation to , above. The network interface  may be, for example, an Ethernet device, an asynchronous transfer mode (ATM) device, an 802.11 wireless interface device, a DSL modem, a cable modem, a cellular modem, etc., that enables the fault-prone code identification system  to communicate with another computer system having at least the elements described in relation to the fault-prone code identification system .","While the memory controller  and the I\/O controller  are depicted in  as separate functional blocks within the chipset , the functions performed by these blocks may be integrated within a single integrated circuit or may be implemented using two or more separate integrated circuits.","The fault-prone code identification system  may also implement the bug organizer module  and version control module  on remote computing devices  and . The remote computing devices  and  may communicate with the computing device  over an Ethernet link . For example, the computing device  may receive code base files  from a remote computing device , . In other embodiments, the bug organizer module  and\/or the version control module  may be retrieved by the computing device  from a cloud computing server  via the Internet . When using the cloud computing server , the bug organizer module  and\/or the version control module  may be programmatically linked with the computing device . The bug organizer module  and\/or the version control odule  may be a Java\u00ae applet executing within a Java\u00ae Virtual Machine (JVM) environment resident in the computing device  or the remote computing devices , . The bug organizer module  and\/or the version control module  may also be \u201cplug-ins\u201d adapted to execute in a web-browser located on the computing devices , , and .","Using the systems and procedures described above, a user can easily identify fault-prone code within a codebase within various subsets of the codebase and continuously rank the files according to their likelihood of presently including a bug. The subset may be created \u201con the fly\u201d at any point in the lifetime of the codebase to instantly analyze code and understand the distribution of errors throughout the codebase. Furthermore, by providing a ranking of the likelihood that each file includes a bug, quality control systems and personnel are able to prioritize the correction of the fault-prone code. Likewise, identifying fault-prone code allows further analysis of the circumstances that lead to bugs and improvement of the metrics used to first identify the fault-prone code.","Throughout this specification, plural instances may implement components, operations, or structures described as a single instance. Although individual operations of one or more methods are illustrated and described as separate operations, one or more of the individual operations may be performed concurrently, and nothing requires that the operations be performed in the order illustrated. Structures and functionality presented as separate components in example configurations may be implemented as a combined structure or component. Similarly, structures and functionality presented as a single component may be implemented as separate components. These and other variations, modifications, additions, and improvements fall within the scope of the subject matter herein.","For example, the system  may include but is not limited to any combination of a LAN, a MAN, a WAN, a mobile, a wired or wireless network, a private network, or a virtual private network. Moreover, while only two remote computing devices  and  are illustrated in  to simplify and clarify the description, it is understood that any number of client computers are supported and can be in communication within the system .","Additionally, certain embodiments are described herein as including logic or a number of components, modules, or mechanisms. Modules may constitute either software modules (e.g., code embodied on a machine-readable medium or in a transmission signal, wherein the code is executed by a processor) or hardware modules. A hardware module is tangible unit capable of performing certain operations and may be configured or arranged in a certain manner. In example embodiments, one or more computer systems (e.g., a standalone, client or server computer system) or one or more hardware modules of a computer system (e.g., a processor or a group of processors) may be configured by software (e.g., an application or application portion as a hardware module that operates to perform certain operations as described herein.","In various embodiments, a hardware module may be implemented mechanically or electronically. For example, a hardware module may comprise dedicated circuitry or logic that is permanently configured (e.g., as a special-purpose processor, such as a field programmable gate array (FPGA) or an application-specific integrated circuit (ASIC)) to perform certain operations. A hardware module may also comprise programmable logic or circuitry (e.g., as encompassed within a general-purpose processor or other programmable processor) that is temporarily configured by software to perform certain operations. It will be appreciated that the decision to implement a hardware module mechanically, in dedicated and permanently configured circuitry, or in temporarily configured circuitry (e.g., configured by software may be driven by cost and time considerations.","Accordingly, the term \u201chardware module\u201d should be understood to encompass a tangible entity, be that an entity that is physically constructed, permanently configured (e.g., hardwired), or temporarily configured (e.g., programmed) to operate in a certain manner or to perform certain operations described herein. As used herein, \u201chardware-implemented module\u201d refers to a hardware module. Considering embodiments in which hardware modules are temporarily configured (e.g., programmed), each of the hardware modules need not be configured or instantiated at any one instance in time. For example, where the hardware modules comprise a general-purpose processor configured using software, the general-purpose processor may be configured as respective different hardware modules at different times. Software may accordingly configure a processor, for example, to constitute a particular hardware module at one instance of time and to constitute a different hardware module at a different instance of time.","Hardware modules can provide information to, and receive information from, other hardware modules. Accordingly, the described hardware modules may be regarded as being communicatively coupled. Where multiple of such hardware modules exist contemporaneously, communications may be achieved through signal transmission (e.g., over appropriate circuits and buses) that connect the hardware modules. In embodiments in which multiple hardware modules are configured or instantiated at different times, communications between such hardware modules may be achieved, for example, through the storage and retrieval of information in memory structures to which the multiple hardware modules have access. For example, one hardware module may perform an operation and store the output of that operation in a memory device to which it is communicatively coupled. A further hardware module may then, at a later time, access the memory device to retrieve and process the stored output. Hardware modules may also initiate communications with input or output devices, and can operate on a resource (e.g., a collection of information).","The various operations of example methods described herein may be performed, at least partially, by one or more processors that are temporarily configured (e.g., by software) or permanently configured to perform the relevant operations. Whether temporarily or permanently configured, such processors may constitute processor-implemented modules that operate to perform one or more operations or functions. The modules referred to herein may, in some example embodiments, comprise processor-implemented modules.","Similarly, the methods or routines described herein may be at least partially processor-implemented. For example, at least some of the operations of a method may be performed by one or processors or processor-implemented hardware modules. The performance of certain of the operations may be distributed among the one or more processors, not only residing within a single machine, but deployed across a number of machines. In some example embodiments, the processor or processors may be located in a single location (e.g., within a home environment, an office environment or as a server farm), while in other embodiments the processors may be distributed across a number of locations.","The one or more processors may also operate to support performance of the relevant operations in a \u201ccloud computing\u201d environment or as a \u201csoftware as a service\u201d (SaaS). For example, at least some of the operations may be performed by a group of computers (as examples of machines including processors), these operations being accessible via a network (e.g., the Internet) and via one or more appropriate interfaces (e.g., application program interfaces (APIs).)","The performance of certain of the operations may be distributed among the one or more processors, not only residing within a single machine, but deployed across a number of machines. In some example embodiments, the one or more processors or processor-implemented modules may be located in a single geographic location (e.g., within a home environment, an office environment, or a server farm). In other example embodiments, the one or more processors or processor-implemented modules may be distributed across a number of geographic locations.","Some portions of this specification are presented in terms of algorithms or symbolic representations of operations on data stored as bits or binary digital signals within a machine memory (e.g., a computer memory). These algorithms or symbolic representations are examples of techniques used by those of ordinary skill in the data processing arts to convey the substance of their work to others skilled in the art. As used herein, an \u201calgorithm\u201d is a self-consistent sequence of operations or similar processing leading to a desired result. In this context, algorithms and operations involve physical manipulation of physical quantities. Typically, but not necessarily, such quantities may take the form of electrical, magnetic, or optical signals capable of being stored, accessed, transferred, combined, compared, or otherwise manipulated by a machine. It is convenient at times, principally for reasons of common usage, to refer to such signals using words such as \u201cdata,\u201d \u201ccontent,\u201d \u201cbits,\u201d \u201cvalues,\u201d \u201celements,\u201d \u201csymbols,\u201d \u201ccharacters,\u201d \u201cterms,\u201d \u201cnumbers,\u201d \u201cnumerals,\u201d or the like. These words, however, are merely convenient labels and are to be associated with appropriate physical quantities.","Unless specifically stated otherwise, discussions herein using words such as \u201cprocessing,\u201d \u201ccomputing,\u201d \u201ccalculating,\u201d \u201cdetermining,\u201d \u201cpresenting,\u201d \u201cdisplaying,\u201d or the like may refer to actions or processes of a machine (e.g., a computer) that manipulates or transforms data represented as physical (e.g., electronic, magnetic, or optical) quantities within one or more memories (e.g., volatile memory, non-volatile memory, or a combination thereof), registers, or other machine components that receive, store, transmit, or display information.","As used herein any reference to \u201csome embodiments\u201d or \u201can embodiment\u201d means that a particular element, feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment. The appearances of the phrase \u201cin some embodiments\u201d in various places in the specification are not necessarily all referring to the same embodiment.","Some embodiments may be described using the expression \u201ccoupled\u201d and \u201cconnected\u201d along with their derivatives. For example, some embodiments may be described using the term \u201ccoupled\u201d to indicate that two or more elements are in direct physical or electrical contact. The term \u201ccoupled,\u201d however, may also mean that two or more elements are not in direct contact with each other, but yet still co-operate or interact with each other. The embodiments are not limited in this context.","As used herein, the terms \u201ccomprises,\u201d \u201ccomprising,\u201d \u201cincludes,\u201d \u201cincluding,\u201d \u201chas,\u201d \u201chaving\u201d or any other variation thereof, are intended to cover a non-exclusive inclusion. For example, a process, method, article, or apparatus that comprises a list of elements is not necessarily limited to only those elements but may include other elements not expressly listed or inherent to such process, method, article, or apparatus. Further, unless expressly stated to the contrary, \u201cor\u201d refers to an inclusive or and not to an exclusive or. For example, a condition A or B is satisfied by any one of the following: A is true (or present) and B is false (or not present), A is false (or not present) and B is true (or present), and both A and B are true (or present).","In addition, use of the \u201ca\u201d or \u201can\u201d are employed to describe elements and components of the embodiments herein. This is done merely for convenience and to give a general sense of the description. This description should be read to include one or at least one and the singular also includes the plural unless it is obvious that it is meant otherwise.","Still further, the figures depict preferred embodiments of a map editor system for purposes of illustration only. One skilled in the art will readily recognize from the following discussion that alternative embodiments of the structures and methods illustrated herein may be employed without departing from the principles described herein","Upon reading this disclosure, those of skill in the art will appreciate still additional alternative structural and functional designs for a system and a process for identifying terminal road segments through the disclosed principles herein. Thus, while particular embodiments and applications have been illustrated and described, it is to be understood that the disclosed embodiments are not limited to the precise construction and components disclosed herein. Various modifications, changes and variations, which will be apparent to those skilled in the art, may be made in the arrangement, operation and details of the method and apparatus disclosed herein without departing from the spirit and scope defined in the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
