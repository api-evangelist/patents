---
title: Method and device for performing a query on a markup document to conserve memory and time
abstract: A method of performing a query on a Markup document, which includes steps of receiving a query and designing a plurality of filters to reflect a structural linkage of a condition tree representing the query. The step of designing the plurality of filters includes designing a highest-level filter that can become active only if an event-based parser indicates that an element for which the highest-level filter is searching has been found. The step of designing the plurality of filters also includes designing a lowest-level filter that can become active only when the highest-level filter has become active and when the parser indicates that an element for which the lowest-level filter is searching has been parsed. The method also includes a step of parsing a Markup document, and a step of checking the lowest-level filter to determine whether it has found the element for which it has been searching.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06920462&OS=06920462&RS=06920462
owner: Siemens Aktiengesellschaft
number: 06920462
owner_city: Munich
owner_country: DE
publication_date: 20011119
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["This application is based on and hereby claims priority to European Application No. 00125159.4 filed on Nov. 17, 2000 in Europe, the contents of which are hereby incorporated by reference.","The invention relates to a method for performing a query on a document created using a Markup language and to software and hardware configured to carry out the method. More specifically, the invention enables the time required to perform a query to be reduced and enables the size of the memory required to perform the query to be reduced as compared to the related art.","There are two basic ways to interface a parser with an application, namely, using an object-based interface and an event-based interface. A Markup language that is becoming popular at the time of writing this application is XML (Extensible Markup Language), and two types of interfaces have been developed for use with XML. The DOM (Document Object Model) interface is an object-based interface and the SAX (Simple Application Programming Interface) is an event-based interface. Related art methods of searching a Markup document using either of these interfaces involve constructing a tree representing the document to be searched.","With a parser using an object-based interface, such as the DOM, the parser explicitly builds a tree of objects that contains all of the elements of the XML document. In contrast, a SAX parser usually accepts a document handler that receives callbacks invoked by the SAX parser. The callbacks inform the document handler of events that are read by the SAX parser. Such events can be, for example, a start-tag and an end-tag. The sequence of callbacks allows the document handler to build a tree of objects of all of the XML elements as they appear in the XML document. However, constructing such a tree requires a great deal of memory and time, and a query, typically, runs several times over the constructed tree.","It is accordingly an object of the invention to provide a method and a device which overcomes the hereinafore-mentioned disadvantages of the heretofore-known methods and devices of this general type in such a way that the time required to perform a query of a markup document (a document containing data and markup) can be reduced and the size of the memory required to perform the query can be reduced.","With the foregoing and other objects in view there is provided, in accordance with one aspect of the invention a method of performing a query on a Markup document, which includes steps of receiving a query and designing a plurality of filters to reflect a structural linkage of a condition tree representing the query. The step of designing the plurality of filters includes designing a highest-level filter that can become active only if an event-based parser indicates that an element for which the highest-level filter is searching has been found. The step of designing the plurality of filters also includes designing a lowest-level filter that can become active only when the highest-level filter has become active and when the parser indicates that an element for which the lowest-level filter is searching has been parsed. The method also includes a step of parsing a Markup document, and a step of checking the lowest-level filter to determine whether it has found the element for which it has been searching.","A query is expressed as a condition tree, which has at every single condition a linkage to a filter, as described above. A single condition determines its result by evaluating its linked filter. A composite condition determines its value by evaluating all of its sub-conditions.","In accordance with an added feature of the invention, the step of designing the plurality of filters includes: designing at least one intermediate-level filter that can become active only when the highest-level filter has become active and when the parser indicates that an element for which the intermediate-level filter is searching has been parsed; and designing the lowest-level filter to become active only when the intermediate-level filter has become active.","In accordance with an additional feature of the invention, the lowest-level filter is defined as a first lowest-level filter; and the method includes steps of designing a second lowest-level filter that can become active only when the highest-level filter has become active and when the parser indicates that an element for which the lowest-level filter is searching has been parsed; and checking the second lowest-level filter to determine whether it has found the element for which it has been searching.","In accordance with another feature of the invention, the value filter is designed to become active only when the highest-level filter has become active and when the parser indicates that an element for which the value filter is searching has been parsed. If the first lowest-level filter has found the element for which it has been searching and the second lowest-level filter has found the element for which it has been searching, an element is obtained from the value filter that is linked to the elements in the first lowest-level filter and in the second lowest-level filter.","In accordance with a further feature of the invention, the method includes designing a value filter that will become active only when the highest-level filter has become active and when the parser indicates that an element for which the value filter is searching has been parsed; and if the lowest-level filter has found the element for which it has been searching, obtaining an element from the value filter that is linked to the element in the lowest-level filter.","In accordance with a further added feature of the invention, computer executable instructions for performing the method are stored on a computer-readable medium.","In accordance with a concomitant feature of the invention, a computer device is programmed to perform the method by executing the instructions that have been stored on a computer readable medium.","One aspect of the invention enables desired information to be read from a Markup document in an extremely efficient manner and involves using an event-based interface to read the document such that a tree need not be constructed representing the Markup document.","Reference will now be made in detail to the preferred embodiments of the present invention, examples of which are illustrated in the accompanying drawings, wherein like reference numerals refer to like elements throughout.","One aspect of the invention involves using an event-based interface to read a Markup document. An exemplary embodiment of the invention will be described that uses a SAX interface to read an XML document. However, it should be apparent that the invention could be constructed using another event-based interface constructed for use with another Markup language, and therefore, the invention should not be construed as being limited to use with XML documents.","One aspect of the invention is based upon the concept of constructing a condition tree representing the query to be performed on the document and constructing filters in accordance with the tree, instead of constructing a tree of document elements beforehand. The filters are document handlers that are hierarchically registered with each other and at the topmost level with a parser. The filter cascade begins with the construction of forwarding filters to narrow the elements to read from. A query filter is created which also serves as a forwarding filter. During the creation of the query filter, the condition expression, as part of the query, is read and a condition cascade is initialized. The condition cascade uses the composite design pattern to represent the conditions and their Boolean links. After construction of the query filter, a filter chain for a value filter is created. At the bottom level, this is mostly, an \u201cexistence\u201d, \u201celementlist\u201d, or \u201cattribute\u201d filter which serves as a value filter. If a query filter was created due to the presence of a condition in the query, this value filter is linked to the condition. If the query did not contain a condition, the value filter serves as the filter from which the results are directly obtained. The topmost filter is registered with the parser, for example, an XML parser supporting the SAX interface. The topmost filter then delegates to all of the lower level filters, including the \u201cquery\u201d, \u201cexistence\u201d, \u201celementlist\u201d, \u201cforwarding\u201d and\/or \u201cattribute\u201d filters. The query filter evaluates the condition at certain check points which are at the end of its designated scope. In the example provided below, the evaluation would be at the end of the element \u201cimplementation\u201d. If there are composite conditions, they would evaluate their sub-conditions based upon the Boolean expressions that link them together. Finally, if the condition is evaluated to be true, the associated value filter is read.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 1","FIG. 2"]},"Referring to , one will see the creation of methods used to implement the filters performing the query. The filters are registered hierarchically. The forwarding filter \u201csoftpkg\u201d  is registered with an SAX parser  and will be activated upon receiving a callback from the parser  indicating that a \u201csoftpkg\u201d event has been read. The forwarding filter \u201cimplementation\u201d  is registered with the forwarding filter \u201csoftpkg\u201d  such that the filter \u201cimplementation\u201d  can receive callbacks from the parser  only after the filter \u201csoftpkg\u201d  has been activated. The filter \u201cimplementation\u201d  will be activated upon receiving a callback indicating that an \u201cimplementation\u201d event has been activated. The attribute filter \u201cAttributeFilter\u201d  is registered with the filter \u201cimplementation\u201d  such that the filter \u201cAttributeFilter\u201d  can receive callbacks from the parser  only after the filter \u201cimplementation\u201d  has been activated. The filters , ,  are, in effect, SAX document handlers.","After the filters , ,  have been created and properly registered, the document to be queried, in this example, \u201cpackage.csd\u201d is parsed. After parsing the document, the \u201cgetlength\u201d method is performed to see if the \u201cAttributeFilter\u201d  has obtained one or more results in response to the query, and if so, the \u201cgetResult\u201d method is performed to obtain one or more results from the \u201cAttributeFilter\u201d .","Because the filters , ,  receive callbacks from the parser  in response to the events as they are being read by the parser , and because the filters , ,  are hierarchically registered, the filters , ,  enable a query to be performed on the document without having to produce a tree representing the document. In effect, a query tree is continually applied to the elements of the document as the document is being parsed. The filters , ,  act to \u201cfilter out\u201d the event or events that are of interest in response to the query, if in fact, at least one such event exists in the document. It can be seen that the condition expression only has to be \u201cparsed\u201d once for queries to any number of different XML Markup documents.","An example of a complex query will now be discussed. Referring to , one will see the hierarchy of filters that can be used to perform the complex XQL query-\u201csoftpkg\/implementation @id\u201d on the XML document. The forwarding filter \u201csoftpkg\u201d  is registered with the SAX-parser and will become active only when a \u201csoftpkg\u201d element is found. The forwarding filter \u201cimplementation\u201d  is registered with the filter \u201csoftpkg\u201d  and can become active only when the filter \u201csoftpkg\u201d  is active and when an \u201cimplementation\u201d element is found. A first hierarchical filter chain  is registered with the filter \u201cimplementation\u201d to find \u201cos\u201d elements having name attributes of \u2018WinNT\u2019 where these \u201cos\u201d elements are also children of \u201cimplementation\u201d elements. A second hierarchical filter chain  is registered with the filter \u201cimplementation\u201d  to find \u201ccompiler\u201d elements having name attributes of \u2018MSVC\u2019 where these \u201ccompiler\u201d elements are also children of \u201cimplementation\u201d elements. The leftmost filter shown in  is an attribute filter that is used as a value filter  to temporarily store \u201cid\u201d attributes of \u201cimplementation\u201d elements. The \u201cname\u201d attribute filters are checked to see if the desired elements have been found. If the \u201cname\u201d attribute filter in the first filter chain  has found an element for which it is searching, and if the \u201cname\u201d attribute filter in the second filter chain  has found an element for which it is searching, then the necessary composite condition is satisfied and the one or more \u201cid\u201d attributes in the value filter  are obtained from the value filter  in response to the query.","The computer language C++, for example, could be used to construct computer executable instructions that would implement the filters, and the computer executable instructions could be stored on a computer readable medium, such a ROM (read only memory) or a RAM (random access memory). The computer executable instructions could also be stored on a portable computer disk for downloading into a computer device at a later time, wherein the computer device, upon executing the instructions, would perform the method described hereinabove.","The invention has been described in detail with particular reference to preferred embodiments thereof and examples, but it will be understood that variations and modifications can be effected within the spirit and scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["These and other objects and advantages of the present invention will become more apparent and more readily appreciated from the following description of the preferred embodiments, taken in conjunction with the accompanying drawings of which:",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 3"}]},"DETDESC":[{},{}]}
