---
title: Operating system managing a linked list of callback dynamic function tables for acquiring exception handling information from a runtime environment
abstract: In an exemplary media implementation, one or more electronically-accessible media include electronically-executable instructions that utilize an application programming interface, the application programming interface facilitating creation of callback-type dynamic function tables; each callback-type dynamic function table including a begin address, an end address, and a callback function, each callback-type dynamic function table corresponding to a code heap that stores code for multiple functions in a runtime environment; wherein interaction between the runtime environment and an operating system is precipitated upon calling the callback function to acquire exception handling and/or unwind information. In another exemplary media implementation, one or more electronically-accessible media include at least part of an operating system that is configured to request from a runtime environment exception handling and/or unwinding information for functions that are managed by the runtime environment.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07634778&OS=07634778&RS=07634778
owner: Microsoft Corporation
number: 07634778
owner_city: Redmond
owner_country: US
publication_date: 20030626
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This disclosure relates in general to exception handling and in particular, by way of example but not limitation, to facilitating exception handling with regard to functions of a runtime environment.","A computer program typically includes many functions\/methods that are executed while the computer program is running. The functions are executed by one or more processors in conjunction with at least one memory. The memory is used to store information for the functions, and such memory may include processor registers, cache memory, one or more stacks, main memory, some combination thereof, and so forth. A stack, for example, is usually employed to store information for multiple functions in a linear (e.g., temporal) manner.",{"@attributes":{"id":"p-0004","num":"0003"},"figref":"FIG. 1","b":["101","105","101","103"]},"For example, information for function A (A) is at the bottom (or at least the lowest illustrated portion) of stack . When function B is called, information for function B (B) is added onto stack . Similarly, information for function C (C) . . . information for function L (L), information for function M (M), and information for function N (N) are gradually added to the stack.","Each of information for a function  may include such information as ongoing variable(s), stack pointer(s), instruction pointer(s), data in the registers of processor(s) that represents at least part of a current state of the processor(s), some combination thereof, and so forth. This information may be useful when an exception occurs.","Although modem programming entails significant debugging and testing, every imaginable event cannot be fully predicted. Such unexpected events can be accommodated and\/or hidden from user view through exception handling routines\/procedures. However, every function does not usually include error handling information. To reach a function that includes error handling information, stack  is unwound until information for a function  relates to a function that can handle unexpected events. In other words, information entries  of stack  are traced back through, walked back up, etc. during a typical error handling procedure.","To that end, assuming function N cannot handle the experienced exception, stack unwinding 105 NM is used to unwind stack  from a state appropriate for function N to a state appropriate for function M. If function M also does not possess appropriate error handling information, stack unwinding ML is used to unwind stack  from a state appropriate for function M to a state appropriate for function L. Stack  is thusly unwound until information for a function  that relates to a function that can handle the unexpected event is reached.",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2","b":["201","201"]},"An exemplary organization for file  includes first and second portions: code  and an unwind table or tables . Code  organizes individual code sections for functions A-N in an ordered fashion. Specifically, code  illustrates code for function A, code for function B, code for function C . . . code for function L, code for function M, and code for function N.","Unwind table  is organized into three parts: unwind information , exception handling (EH) information , and code address (CA)-to-pointer information . Each of these three parts , , and  are subdivided into sections that are directed to particular functions. Specifically, each part , , and  illustrates sections for function N, for function M . . . . Although not explicitly illustrated, each part , , and  may have sections for all functions A, B, C . . . L, M, and N. In certain described implementations, unwind information  corresponds to so-called \u201cr data\u201d, exception handling information  corresponds to so-called \u201cx data\u201d, and code address (CA)-to-pointer information  corresponds to so-called \u201cp data\u201d.","For CA-to-pointer information , each section that is directed to a particular respective function includes one or more of at least three entries: a start address, a final address, and an unwind pointer. The start address and the final address relate to the addresses of the code for the respective function in code . These addresses may be relocatable virtual (RVA) addresses that are offsets from the beginning of code  and\/or file . The unwind pointer is a reference that points to a section of unwind information  for the respective function. Thus, CA-to-pointer information  may imply that information from the address range of the coding to an unwind pointer for a function is provided, may imply that information for a mapping from instruction pointer (IP) addresses associated with a function to an unwind pointer thereof is provided, may imply that both information types are provided, and so forth.","As illustrated for unwind information , each section that is directed to a particular respective function includes at least two entries: an unwinding description and an exception handling (EH) pointer. The unwinding description describes how the stack can be unwound from the particular respective function back to the previous function. For example, an unwinding description of unwind information  for function N describes how to effectuate stack unwinding 105NM for stack . Each exception handling pointer for a respective function is a reference that points to a section of exception handling information  for that respective function.","For exception handling information , each section (if present) includes exception handling information for a particular respective function. The exception handling information includes (native) exception handling tables or similar that explains how to handle one or more exceptions that have been experienced.","Illustrated file , and unwind table  thereof, can be effectively navigated quickly by an operating system (OS) when an exception occurs because it is cleanly and orderly organized. Consequently, standard computer science algorithms targeted to searching for and\/or locating desired information may be employed.","Unfortunately, code that is compiled on-the-fly and\/or in ad hoc situations cannot be so easily organized logically and orderly in prescribed manners with predictable, static formats. Accordingly, there is a need for schemes and techniques that facilitate exception handling in a dynamic environment.","In an exemplary media implementation, one or more electronically-accessible media include electronically-executable instructions that utilize an application programming interface, the application programming interface facilitating creation of callback-type dynamic function tables; each callback-type dynamic function table including a begin address, an end address, and a callback function, each callback-type dynamic function table corresponding to a code heap that stores code for multiple functions in a runtime environment; wherein interaction between the runtime environment and an operating system is precipitated upon calling the callback function to acquire exception handling and\/or unwind information. In another exemplary media implementation, one or more electronically-accessible media include at least part of an operating system that is configured to request from a runtime environment exception handling and\/or unwinding information for functions that are managed by the runtime environment.","In an exemplary electronic device implementation, an electronic device includes: a runtime environment that is managing code for multiple functions; and an operating system that is managing a linked list of dynamic function tables that are searched when an exception occurs, the operating system adapted to call a callback function as indicated by a dynamic function table of the linked list of dynamic function tables to request that the runtime environment provide exception handling and\/or unwind information for at least one function of the multiple functions; wherein the runtime environment is capable of providing to the operating system the exception handling and\/or unwind information for the at least one function of the multiple functions responsive to the callback function.","In another exemplary media implementation, one or more electronically-accessible media include a data structure, the data structure including: a begin address; an end address; and a callback function that, when called, returns from a runtime environment exception handling and\/or unwind information for a function associated with at least one address that is between the begin address and the end address.","In another exemplary media implementation, one or more electronically-accessible media include electronically-executable instructions that include: a callback function, the callback function accepting as input an instruction pointer that is associated with an address of a function from a runtime environment and producing as output data for code address-to-pointer information for the function having the address that is associated with the instruction pointer; wherein the callback function may be called by an operating system and implemented by the runtime environment.","Other method, system, approach, apparatus, application programming interface (API), device, media, procedure, arrangement, etc. implementations are described herein.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 3","b":["302","302","304","304","1","304","2","304","302"]},"In a described implementation, dynamic function table linked lists  may be used, for example, for code that is not completely compiled into a static file. Each particular process may correspond to a particular dynamic function table . A header of the particular dynamic function table  includes a high level address range of the entire process, such as a first address and a last address of the process.","Generally, each dynamic function table  also includes a list of CA-to-pointer information for multiple functions. As shown for dynamic function table () specifically, a listing of \u201cn\u201d entries for CA-to-pointer information for functions #, #, # . . . #n\u22121, and #n is included. Each CA-to-pointer information entry may include, for example, a start address, a final address, and an unwind pointer for the respective function to which the entry is directed. In certain described implementations, each entry of CA-to-pointer information for a given function may correspond to a so-called \u201cruntime function entry\u201d.","Hence, each dynamic function table  is directed to a process and includes multiple CA-to-pointer information entries. Each respective CA-to-pointer information entry is directed to a respective function of the process and includes CA-to-pointer information for the respective function. The listing of CA-to-pointer information entries in any given dynamic function table  may be sorted or unsorted.","When an exception is experienced, an OS of the device or system uses the relevant current instruction pointer to check a high level range of each header for each dynamic function table  until a match is found. In other words, the OS moves along dynamic function table linked list  from one dynamic function table  to the next and checks to determine if the instruction pointer is an address that is between the first address and the last address. If so, a dynamic function table  match is found, and a CA-to-pointer information entry for the particular function at issue is (assuming no errors) present somewhere in that matching dynamic function table .","The OS then traverses the listing of CA-to-pointer information entries in the matched dynamic function table  until the CA-to-pointer information entry that has a start address and a final address defining a range that includes the instruction pointer is located. This CA-to-pointer information entry is for the particular function at issue. The OS can then use the unwind pointer in this CA-to-pointer information entry to locate unwind information and proceed to handling the exception.","Thus, when an exception occurs, the OS moves along dynamic function table linked list  until a matching dynamic function table  is found, and it then traverses the entries thereof until the matching CA-to-pointer information entry for the function currently being examined or unwound is located. Due to the linear nature of this approach, it is satisfactory as long as the length of dynamic function table linked list  does not become too excessive, especially to the extent that sorted dynamic function tables  are utilized. However, in a runtime environment, the length of dynamic function table linked list  can quickly become unwieldy and unmanageable.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 4","b":["400","404","410","404","406","406"]},"In a described implementation with JIT compiling , intermediate code  is provided that includes one or more functions. Optionally, intermediate code  may be platform independent (e.g., \u201cwrite-once\u201d) code. JIT compiling  transforms intermediate code  into compiled code  that includes one or more functions that may be consumed by a processor. However, instead of compiling the entirety of intermediate code  to produce one static file for compiled code , JIT compiling  compiles parts of intermediate code  into portions of compiled code . This JIT compiling  may be performed as it is needed, as it is requested, as time permits, and so forth.","As illustrated, intermediate code  includes four functions: function One( ), function Two( ), function Three( ), and function Four( ). JIT compiler  compiles these four respective intermediate code  parts into four respective portions of compiled code : function One( ), function Two( ), function Three( ), and function Four( ). However, the order of the functions has changed during the compiling because the compiling is performed as each function is called, which may not be in the same order as the functions are presented within intermediate code .","Thus, functions may be compiled in an unknown, unpredictable, and\/or non-sequential order by JIT compiler  in a runtime environment . Furthermore, one or more functions of intermediate code  may not be compiled into one or more functions for compiled code  in any given session for runtime environment . For example, a given function of intermediate code  may not be compiled for compiled code  until it is called, and it may not be called in a given session.","When executing functions of compiled code , exceptions can be experienced. Consequently, an exception handling mechanism is also employed for compiled code . One approach is to create at least one dynamic function table  for compiled code . However, each dynamic function table  is established based on a high level range of addresses, and such a high level range of addresses for multiple functions is not known for compiled code  because functions are being dynamically added thereto.","Another approach is to create a new dynamic function table  for each newly compiled function of compiled code . The first address and the last address, as well as an unwind pointer (e.g., for the CA-to-pointer information), is known and\/or can be determined by runtime environment  at the time of compiling for any given individual function. However, in a runtime environment  with JIT compiling , there may be thousands and thousands of such JIT compiled functions for compiled code . Dynamic function table linked list  can therefore extend to over 100,000 dynamic function tables  that are linked together. Searching such a linked list is time consuming and can degrade performance.","Yet another approach is to further rely on runtime environment  to manage some of the exception handling responsibilities for compiled code  that has been JIT compiled . This approach is described further herein. For example, a callback dynamic function table  that corresponds to multiple functions of compiled code  can be employed. This correspondence  between multiple functions of compiled code  and callback dynamic function table  is described further below.","Callback dynamic function table  includes a callback function . Callback dynamic function table  may be used in a separate dynamic function table linked list  with no dynamic function tables , or callback dynamic function table  may be included in a dynamic function table linked list  with sorted and\/or unsorted dynamic function tables .","When handling an exception for a given function of compiled code  that corresponds to callback dynamic function table , the OS that is performing the exception dispatching initiates callback function . Initiating callback function  notifies runtime  of an exception with respect to the given function. Responsive to a call to callback function , runtime  consults the code, state, and\/or other information that it is managing, especially as they relate to the given function. Runtime  responds to the OS with information that is sufficient to enable the OS to continue with exception handling. For example, runtime  can provide the OS with exception handling and\/or unwind information by (i) determining and (ii) passing a reference to CA-to-pointer information for the given function to the OS.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 5","b":["410","412","508","406","406","406"]},"In a described implementation, OS  manages callback-type dynamic function tables  that include a callback function . This management may be separate from the management of any other exception handling\/unwinding mechanisms. Alternatively, OS  may manage callback-type dynamic function tables  in conjunction with the management of dynamic function tables  of dynamic function table linked list . For example, callback-type dynamic function tables  may be linked into dynamic function table linked list  along with dynamic function tables .","As illustrated, runtime environment  includes compiled code . Compiled code  includes compiled versions of function One( ), function Two( ), function Three( ), function Four( ), and so forth. As noted above, with JIT compiling , functions for a given process are compiled from intermediate code  when (and if) requested. Consequently, the size that is ultimately occupied by the given process is often unknown as a first function, such as function One( ) of compiled code , is being executed by a processor.","To account for this unknown ultimate size for the given process, runtime environment  allocates (or has allocated) a chunk of memory of a relatively arbitrary size from one or more heaps. This chunk of memory may then be shared by multiple processes as well as by multiple functions.","Code heap  is a chunk of memory that has been allocated for runtime environment  by runtime environment  and\/or by OS . Code heap  has a begin address  and an end address . Although not so explicitly illustrated in , code heap  may include functions and other information for multiple processes, as well as heap managing information for use by runtime .","In a described implementation, there is a correspondence between code heap  and callback dynamic function table . Callback dynamic function table  includes (e.g., values for) begin address  and end address  of code heap . In other words, callback dynamic function table  corresponds to code for functions between begin address  and end address  of code heap , and begin address  and end address  of callback dynamic function table  reflects this correspondence.","As a result, each callback-type dynamic function table  may correspond to multiple functions for one process and\/or multiple functions across multiple processes. Because each callback-type dynamic function table  corresponds to multiple functions, dynamic function table linked list  is grown at a significantly reduced rate (as compared to one dynamic function table  per function). Dynamic function table linked list  is therefore shorter and more quickly searched and otherwise more easily managed by OS .","In an example use of callback dynamic function table , when an exception is discovered and exception handling\/unwind information is being acquired by OS  for a current function associated with a current instruction pointer, OS  searches dynamic function table linked list . OS  searches dynamic function table linked list  by moving along dynamic function tables  and\/or callback-type dynamic function tables  until address checking determines that the current instruction pointer is between begin address  and end address  of callback dynamic function table . OS  then initiates callback function  of callback dynamic function table . When OS  makes a call to callback function , OS  is effectively asking\/requesting runtime environment  for help in acquiring exception handling\/unwind information. Responsive to callback function , runtime  provides information to OS  to help with exception handling\/unwinding.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 6","b":["412","412","412"]},"When OS  calls callback function , OS  includes a current instruction pointer and a reference to the callback dynamic function table  that was discovered to have a begin address  and an end address  that jointly form a range that contains the current instruction pointer. Thus, the current instruction pointer and the callback dynamic function table reference are passed from OS  to runtime environment  for callback function . Runtime  performs the exception handling\/unwinding callback analysis for callback function  and passes back to OS  a reference to CA-to-pointer information for the function associated with the current instruction pointer. This analysis is described further below with particular reference to .","The reference to CA-to-pointer information references CA-to-pointer information for the function currently at issue (e.g., being unwound and\/or considered for exception handling abilities). This reference to CA-to-pointer information may be, for example, a pointer to CA-to-pointer information that is stored in a code heap  by runtime  for the function at issue. Upon following the reference, OS  may attain the CA-to-pointer information for the function of the current instruction. This CA-to-pointer information may include a start address, a final address, and an unwind pointer for the function that is associated with the current instruction. This information as it relates to the associated function at issue is described further below with reference to .",{"@attributes":{"id":"p-0060","num":"0059"},"figref":["FIG. 7","FIGS. 4-6","FIGS. 5 and 6"],"b":["700","404","406","406","502","504","506","504","506","502","508","502","406","502"]},"As illustrated, code heap  includes a heap structure , a code for function One , code for (one or more) other functions , and so forth. Heap structure  includes information for managing (e.g., organizing, controlling, etc.) code heap . For example, heap structure  may include contents (e.g., a table, an index, etc.) that identifies functions that are included as part of code heap . These identifications may include the address locations\/ranges of different code segments for different functions of code heap , such as code for function One .","Code for function One  is bounded by start address  and final address . Code for function One  includes multiple portions: a code header , function One , unwind information , and CA-to-pointer information . Each of these portions of code for function One , as indicated by the dashed line in code header , may include aspects in addition to those illustrated in  and described below.","Function One  includes the machine language, chip-consumable instructions for function One. Code header  includes a reference to CA-to-pointer information, which points to CA-to-pointer information .","CA-to-pointer information  includes a start address, a final address, and an unwind pointer. The values of the start address and the final address equate to and\/or reflect start address  and final address , respectively. The unwind pointer references unwind information .","Unwind information  includes unwind information and an exception handling pointer. The exception handling pointer, if present, references exception handling information for function One. The unwinding description describes how to unwind the stack from function One to the preceding function. This unwinding description may be used by, for example, OS  to unwind the stack.","Each of these addresses, such as start address  and final address , may be RVA addresses that are offsets from or relative to begin address  of code heap . Hence, the start address and the final address of CA-to-pointer information  may be stored as RVA addresses. Similarly, both of (i) the reference to CA-to-pointer information of code header  and (ii) the unwind pointer of CA-to-pointer information  may effectuate their respective references relative to begin address .","Application of and interaction with code heap organization  in the context of using and creating a callback dynamic function table  is described further below with reference to  and , respectively.",{"@attributes":{"id":"p-0068","num":"0067"},"figref":["FIG. 8","FIGS. 3-7"],"b":["800","800","802","808","800"]},"At block , a new code heap is initialized with a runtime environment. For example, runtime  may initialize code heap . At block , a begin address and an end address of the new code heap is noted. For example, runtime  may note begin address  and end address  for code heap . It should be noted that the new code heap initialization may be effectuated with the cooperation of an allocator or similar component that may be a constituent of OS .","At block , a dynamic function table is created that corresponds to the code heap. The dynamic function table is created with the noted begin address, the noted end address, and a callback function. For example, a callback dynamic function table  that includes begin address , end address , and callback function  may be created by runtime , by OS , by a combination of runtime  and OS , and so forth.","In a described implementation, runtime  causes OS  to create callback dynamic function table  by requesting an addition to dynamic function table linked list . For example, runtime  can use an application programming interface (API) to request that OS  create a new table in dynamic function table linked list .","By way of example only, for a Microsoft\u00ae Windows\u00ae OS, a runtime component can call an Install Dynamic Function Table(table, first address, last address, . . . ) API, with the table parameter set to callback dynamic function table, the first address set to begin address, and the last address set to end address. The table parameter may also be set to sorted dynamic function table or unsorted dynamic function table when installing non-callback-type dynamic function tables. Generally, OS  may also provide an API for use by runtime  in order to remove a dynamic function table (including callback-type dynamic function tables ) from dynamic function table linked list .","At block , a callback-type dynamic function table for the code heap is added to a linked list of dynamic function tables. For example, callback dynamic function table , which includes begin address , end address , and callback function , may be added to dynamic function table linked list . If dynamic function table linked list  is managed by OS , then OS  adds callback dynamic function table  thereto.",{"@attributes":{"id":"p-0074","num":"0073"},"figref":["FIG. 9","FIGS. 3-7"],"b":["900","900","10","902","920","900","900","508","406","508","902","908","918","920","406","910","916"]},"At block , an exception is discovered that results from execution of a function in a runtime environment. For example, an exception may result from execution of function One (using the machine language of function One ) in runtime environment . It should be noted that OS  may not be aware at the time of the exception that the code responsible for the exception is being executed as part of runtime environment .","With the discovery of the exception, OS  begins an exception handling procedure that typically includes unwinding one or more frames of the stack. Although the description herein focuses on exception handling as a result of an exception that occurs with\/in runtime environment , exceptions also occur at addresses that fall within the range of currently loaded static executable images. OS  therefore considers, at least from time to time, both static unwind tables (not explicitly shown in ) for files that are not part of runtime environment  and at least one dynamic function table linked list . Generally, upon discovery of an exception, OS  first searches the static unwind tables. If the corresponding unwinding information, etc. cannot be attained through the static unwind tables, OS  then searches dynamic function table linked list . However, OS  may alternatively search dynamic function table linked list  prior to and\/or overlapping with a search of the static unwind tables.","At block , a dynamic function table linked list is searched using the current instruction pointer. For example, the high level ranges of sorted\/unsorted dynamic function tables  may be searched as well as begin\/end addresses \/ of callback-type dynamic function tables  as OS  moves along dynamic function tables of dynamic function table linked list .","At block , the callback dynamic function table for the current instruction pointer is located. For example, a callback dynamic function table  that has a begin address  that is lower than and an end address  that is higher than the current instruction pointer may be located.","At block , the callback function is initiated. For example, OS  can call callback function  using the current instruction pointer and a reference to the located callback dynamic function table  as arguments for the call. Initiating the callback function serves to notify runtime environment  that OS  is requesting exception handling and\/or unwinding information to handle an exception with regard to the current instruction pointer.","At block , responsive to initiation of the callback function and the current instruction pointer, code for the runtime function is ascertained. For example, runtime environment  may consult a global table that covers multiple code heaps . Such a global table includes an entry for each runtime function that maps (i) start address \/final address  code ranges for each code for functions \/ to (ii) code headers . If a global table is employed, the mapping may also include an identification of the relevant code heap , especially if RVA addresses are used.","Alternatively, a table (of multiple tables) with mappings similar to those described above for a global table may be included at each heap structure  where the table is for the functions included in the associated code heap . If multiple such per-code-heap tables are employed, runtime environment  searches each table at each heap structure  until the function associated with the current instruction pointer is ascertained. Runtime environment  may also maintain a table that maps code heaps  to address ranges defined by begin\/end addresses \/ so that the relevant heap structure  may be ascertained without searching through multiple heap structures .","At block , a code header of the runtime function is accessed. For example, once the code for the function associated with the current instruction pointer is ascertained, then code header  therefor may be accessed. In short, the actions of blocks  and  may correspond to (i) finding a code heap  for the current instruction pointer and (ii) finding\/accessing a code header  of code heap  for the current instruction pointer. In the description that follows, code for function One  is used as an example. Thus, code header  of code for function One  may be inspected as part of the accessing.","At block , a reference to CA-to-pointer information is extracted from the code header of the runtime function. For example, the reference to CA-to-pointer information may be extracted from code header . At block , the reference to CA-to-pointer information is passed to the operating system as a response to and\/or output of the callback function. For example, the reference to CA-to-pointer information of code header  that references CA-to-pointer information  may be provided from runtime environment  to OS .","More generally, runtime environment  may provide to OS  data for CA-to-pointer information. This data for CA-to-pointer information may comprise a reference to CA-to-pointer information . Alternatively, this data for CA-to-pointer information may comprise CA-to-pointer information . In other words, runtime environment  may alternatively directly provide to OS  the start address value, the final address value, and\/or an unwind pointer for code for function One .","At block , the reference to CA-to-pointer information is used to attain the CA-to-pointer information. This CA-to-pointer information includes an unwind pointer that points to unwind information. For example, OS  may use the reference to CA-to-pointer information, possibly in conjunction with begin address  if relative addressing is employed, to attain the CA-to-pointer information from CA-to-pointer information . CA-to-pointer information  includes an unwind pointer that points to unwind information .","At block , the unwind pointer is used to attain unwind information. For example, the unwind pointer attained from CA-to-pointer information  may be used by OS  to access unwind information  and to extract the unwinding description therefrom. OS  may then unwind the frame on the stack that is associated with function One.","The aspects, features, components, etc. of  and the methods of , for example, are illustrated in diagrams that are divided into multiple blocks. However, the order and\/or layout in which the operating environments and methods are described and\/or shown is not intended to be construed as a limitation, and any number of the blocks can be combined, rearranged, augmented, omitted, etc. in any manner to implement one or more systems, methods, devices, procedures, media, APIs, apparatuses, arrangements, etc. for exception handling. Furthermore, although the description herein includes references to specific implementations such as those of  (as well as the exemplary operating environment of ), the operating environments and methods can be implemented in any suitable hardware, software, firmware, or combination thereof and using any suitable runtime language(s), runtime environment(s), application programming interface(s), memory structure(s), and so forth.",{"@attributes":{"id":"p-0088","num":"0087"},"figref":"FIG. 10","b":["1000","1000"]},"Exemplary electronic device operating environment  is only one example of an environment and is not intended to suggest any limitation as to the scope of use or functionality of the applicable electronic (including computer, game console, television, etc.) architectures. Neither should electronic device environment  be interpreted as having any dependency or requirement relating to any one or to any combination of components as illustrated in .","Additionally, exception handling may be implemented with numerous other general purpose or special purpose electronic device (including computing system) environments or configurations. Examples of well known electronic (device) systems, environments, and\/or configurations that may be suitable for use include, but are not limited to, personal computers, server computers, thin clients, thick clients, personal digital assistants (PDAs) or mobile telephones, watches, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set-top boxes, programmable consumer electronics, video game machines, game consoles, portable or handheld gaming units, network PCs, minicomputers, mainframe computers, distributed or multi-processing computing environments that include any of the above systems or devices, some combination thereof, and so forth.","Implementations for exception handling may be described in the general context of electronically-executable instructions. Generally, electronically-executable instructions include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. Exception handling, as described in certain implementations herein, may also be practiced in distributed computing environments where tasks are performed by remotely-linked processing devices that are connected through a communications link and\/or network. Especially in a distributed computing environment, electronically-executable instructions may be located in separate storage media, executed by different processors, and\/or propagated over transmission media.","Electronic device environment  includes a general-purpose computing device in the form of a computer , which may comprise any electronic device with computing and\/or processing capabilities. The components of computer  may include, but are not limited to, one or more processors or processing units , a system memory , and a system bus  that couples various system components including processor  to system memory .","System bus  represents one or more of any of many types of wired or wireless bus structures, including a memory bus or memory controller, a point-to-point connection, a switching fabric, a peripheral bus, an accelerated graphics port, and a processor or local bus using any of a variety of bus architectures. By way of example, such architectures may include an Industry Standard Architecture (ISA) bus, a Micro Channel Architecture (MCA) bus, an Enhanced ISA (EISA) bus, a Video Electronics Standards Association (VESA) local bus, a Peripheral Component Interconnects (PCI) bus also known as a Mezzanine bus, some combination thereof, and so forth.","Computer  typically includes a variety of electronically-accessible media. Such media may be any available media that is accessible by computer  or another electronic device, and it includes both volatile and non-volatile media, removable and non-removable media, and storage media.","System memory  includes electronically-accessible storage media in the form of volatile memory, such as random access memory (RAM) , and\/or non-volatile memory, such as read only memory (ROM) . A basic input\/output system (BIOS) , containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules\/instructions that are immediately accessible to and\/or being presently operated on by processing unit .","Computer  may also include other removable\/non-removable and\/or volatile\/non-volatile storage media. By way of example,  illustrates a hard disk drive or disk drive array  for reading from and writing to a (typically) non-removable, non-volatile magnetic media (not separately shown); a magnetic disk drive  for reading from and writing to a (typically) removable, non-volatile magnetic disk  (e.g., a \u201cfloppy disk\u201d); and an optical disk drive  for reading from and\/or writing to a (typically) removable, non-volatile optical disk  such as a CD-ROM, DVD, or other optical media. Hard disk drive , magnetic disk drive , and optical disk drive  are each connected to system bus  by one or more storage media interfaces . Alternatively, hard disk drive , magnetic disk drive , and optical disk drive  may be connected to system bus  by one or more other separate or combined interfaces (not shown).","The disk drives and their associated electronically-accessible media provide non-volatile storage of electronically-executable instructions, such as data structures, program modules, and other data for computer . Although exemplary computer  illustrates a hard disk , a removable magnetic disk , and a removable optical disk , it is to be appreciated that other types of electronically-accessible media may store instructions that are accessible by an electronic device, such as magnetic cassettes or other magnetic storage devices, flash memory, CD-ROM, digital versatile disks (DVD) or other optical storage, RAM, ROM, electrically-erasable programmable read-only memories (EEPROM), and so forth. Such media may also include so-called special purpose or hard-wired integrated circuit (IC) chips. In other words, any electronically-accessible media may be utilized to realize the storage media of the exemplary electronic system and environment .","Any number of program modules (or other units or sets of instructions\/code) may be stored on hard disk , magnetic disk , optical disk , ROM , and\/or RAM , including by way of general example, an operating system , one or more application programs , other program modules , and program data . By way of example but not limitation, operating system  may correspond to OS .","A user may enter commands and\/or information into computer  via input devices such as a keyboard  and a pointing device  (e.g., a \u201cmouse\u201d). Other input devices  (not shown specifically) may include a microphone, joystick, game pad, satellite dish, serial port, scanner, and\/or the like. These and other input devices are connected to processing unit  via input\/output interfaces  that are coupled to system bus . However, input devices and\/or output devices may instead be connected by other interface and bus structures, such as a parallel port, a game port, a universal serial bus (USB) port, an infrared port, an IEEE 1394 (\u201cFirewire\u201d) interface, an IEEE 802.11 wireless interface, a Bluetooth\u00ae wireless interface, and so forth.","A monitor\/view screen  or other type of display device may also be connected to system bus  via an interface, such as a video adapter . Video adapter  (or another component) may be or may include a graphics card for processing graphics-intensive calculations and for handling demanding display requirements. Typically, a graphics card includes a graphics processing unit (GPU), video RAM (VRAM), etc. to facilitate the expeditious performance of graphics operations. In addition to monitor , other output peripheral devices may include components such as speakers (not shown) and a printer , which may be connected to computer  via input\/output interfaces .","Computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computing device . By way of example, remote computing device  may be a personal computer, a portable computer (e.g., laptop computer, tablet computer, PDA, mobile station, etc.), a palm or pocket-sized computer, a watch, a gaming device, a server, a router, a network computer, a peer device, other common network node, or another electronic device type as listed above, and so forth. However, remote computing device  is illustrated as a portable computer that may include many or all of the elements and features described herein with respect to computer .","Logical connections between computer  and remote computer  are depicted as a local area network (LAN)  and a general wide area network (WAN) . Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets, the Internet, fixed and mobile telephone networks, ad-hoc and infrastructure wireless networks, other wireless networks, gaming networks, some combination thereof, and so forth.","When implemented in a LAN networking environment, computer  is usually connected to LAN  via a network interface or adapter . When implemented in a WAN networking environment, computer  typically includes a modem  or other means for establishing communications over WAN . Modem , which may be internal or external to computer , may be connected to system bus  via input\/output interfaces  or any other appropriate mechanism(s). It is to be appreciated that the illustrated network connections are exemplary and that other means of establishing communication link(s) between computers  and  may be employed.","In a networked environment, such as that illustrated with electronic device environment , program modules or other instructions that are depicted relative to computer , or portions thereof, may be fully or partially stored in a remote memory storage device. By way of example, remote application programs  reside on a memory component of remote computer  but may be usable or otherwise accessible via computer . Also, for purposes of illustration, application programs  and other electronically-executable instructions such as operating system  are illustrated herein as discrete blocks, but it is recognized that such programs, components, and other instructions reside at various times in different storage components of computing device  (and\/or remote computing device ) and are executed by data processor(s)  of computer  (and\/or those of remote computing device ).","Although systems, media, devices, methods, procedures, apparatuses, techniques, approaches, procedures, arrangements, and other implementations have been described in language specific to structural, logical, algorithmic, and functional features and\/or diagrams, it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or diagrams described. Rather, the specific features and diagrams are disclosed as exemplary forms of implementing the claimed invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The same numbers are used throughout the drawings to reference like and\/or corresponding aspects, features, and components.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
