---
title: Efficient write-watch mechanism useful for garbage collection in a computer system
abstract: An efficient write-watch mechanism and process. A bitmap is associated with the virtual address descriptor (VAD) for a process, one bit for each virtual page address allocated to a process having write-watch enabled. As part of the write-watch mechanism, if a virtual address is trimmed to disk and that virtual address page is marked as modified, then the corresponding bit in the VAD is set for that virtual address page. In response to an API call (e.g., from a garbage collection mechanism) seeking to know which virtual addresses in a process have been modified since last checked, the memory manager walks the bitmap in the relevant VAD for the specified virtual address range for the requested process. If a bit is set, then the page corresponding to that bit is known to have been modified since last asked. If specified by the API, the bit is cleared in the VAD bitmap so that it will reflect the state since this time of asking. If the bit is not set, to determine if the page was modified, the page table entry (PTE) is checked for that page, and if the PTE indicates the page was modified, the page is known to be modified, otherwise that page is known to be unmodified since the last call. One enhancement uses page directory tables to locate a series of trimmed pages, sometimes avoiding the need to access the PTE.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07065617&OS=07065617&RS=07065617
owner: Microsoft Corporation
number: 07065617
owner_city: Redmond
owner_country: US
publication_date: 20040420
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATION","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT"],"p":["This application is a continuation of U.S. application Ser. No. 09\/628,708 filed Jul. 31, 2000, now U.S. Pat. No. 6,738,875 B1, issued May 18, 2004.","The invention relates generally to computer systems, and more particulary to memory management in computer systems.","Application programs often allocate memory that is not used, or is used briefly and then unused thereafter. As memory is a resource that may become scarce, application programs are supposed to deallocate memory that is no longer needed. However, applications often fail to do so, and this memory misuse leads to low memory conditions and otherwise degrades system performance. Applications also tend to access memory after they manually free it, which also causes major problems.","The concept of \u201cgarbage collection\u201d has been developed to automatically manage application memory by reclaiming memory space allocated to applications that is not being used. Garbage collection operates on behalf of the application, without the application's assistance, to look for objects that are unused. A garbage collector operates by scanning for cross-generation pointers in memory, which indicate an object still in use. One type of garbage collection is sequential in nature, wherein a garbage collection mechanism runs whenever memory is needed. While the collection mechanism is run to analyze the memory (e.g., a set of allocated objects) that is not being used, the application is temporarily halted so that it cannot be modifying memory. A significant problem with sequential garbage collection is that the application often experiences inconvenient and\/or undesirable pauses during the collection operation.","Another type of garbage collection is concurrent in nature, wherein the garbage collectors run at the same time as the application and collect only a portion of unused memory at a time. Only when the collector has done the bulk of its work is the application temporarily halted to prevent it from writing to memory just as that memory is being freed, whereby the application is not significantly paused. To look for objects that are unused, the garbage collector enumerates locations that have been written into so it can scan for the cross-generation pointers, i.e., rather than scan large amounts of system memory, only changed memory is examined. However, this requires a more complex collector to concurrently track memory that is being actively used by an application, and also requires multiple passes to locate any memory earlier determined to be unused but that an application has since used while the collector was performing other work.","To track which memory has changed with contemporary operating systems and microprocessors, write-protect and write-watch are techniques that have been attempted. Write-protect generally operates by protecting sections of memory (e.g., pages) allocated to an application. Then, whenever the application writes to a protected page, a page fault is triggered. By the page fault, the collector thus knows that this page was written to, and can record the page as changed, e.g., in some data structure used for tracking changed pages. The collector then unprotects the page to allow the change and allow the application to use it. Some time later, the collector will free unused memory and reset the tracking process. Conventional write-watch is somewhat similar to write-protect, except that write-watch tracks memory usage without protecting the page and generating the page fault exception.","While write-protect and write-watch thus enable concurrent garbage collection mechanisms, such mechanisms have heretofore been highly inefficient. Indeed, write-protect is significantly slower than write-watch. At the same time, past write-watch techniques have degraded system performance so significantly that that a number of write-watch garbage collection efforts have been abandoned.","Briefly, the present invention provides a method and system that enables an efficient write-watch mechanism, while adding as little as one bit per virtual page address being watched, and that operates without substantially degrading performance even on large address ranges. To this end, a bitmap is associated with the Virtual Address Descriptor (VAD) for a process, one bit for each virtual page address allocated to a process with write-watch enabled. As part of the write-watch mechanism if a virtual address is trimmed to disk and that virtual address page is marked as modified, then the corresponding bit in the VAD is set for that virtual address page. Only when a modified page is trimmed is the bitmap accessed during normal system operation, providing extremely fast write-watching.","The memory manager may receive an API call (e.g., from a garbage collection mechanism) seeking to know which virtual addresses in a process have been modified since last checked, e.g., since the last time the garbage collection mechanism asked. To determine this, the memory manager walks the bitmap in the relevant VAD for the specified virtual address range for the requested process. If a bit is set, then the page corresponding to that bit is known to have been modified since last asked. The bit is cleared in the VAD bitmap (if specified by the API), and a result returned for that page, (e.g., the page number is added to an array that is returned).","If the bit is not set, then there is still a chance that the page was modified, just not trimmed. To determine if the page was modified, the page table entry (PTE) is checked for that page, and if the PTE indicates the page was modified, a corresponding bit is set in the PFN database, the modified bit in the PTE is cleared, (if reset is requested by the API, any other processors are interrupted), and the result may be returned for that virtual page address. Otherwise that page is known to be unmodified since the last call.","One enhancement to the present invention looks at the page directory tables corresponding to the write-watched pages for that process for which status has been requested, each of which indicates whether a group of (e.g., 1024) pages have been trimmed. If the pages have been trimmed, then any zero bits in the VAD corresponding to this group are known to be unmodified, since any modified, trimmed page would have had its bit set in the VAD when trimmed. The portion of the VAD bitmap corresponding to the trimmed page directory thus reflects the modified state of pages in this page directory, whereby the PTE need not be checked for that portion. An appropriate result is returned to the caller, and the bitmap portion cleared (if requested) so that it will reflect whether it has been modified since the time last asked.","Other advantages will become apparent from the following detailed description when taken in conjunction with the drawings, in which:","Exemplary Operating Environment",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1"},"Moreover, those skilled in the art will appreciate that the invention may be practiced with other computer system configurations, including hand-held devices, multi-processor systems, microprocessor-based or programmable consumer electronics, network PCs, minicomputers, mainframe computers and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote memory storage devices.","With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a conventional personal computer  or the like, including a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. The system memory includes read-only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within the personal computer , such as during start-up, is stored in ROM . The personal computer  may further include a hard disk drive  for reading from and writing to a hard disk, not shown, a magnetic disk drive  for reading from or writing to a removable magnetic disk , and an optical disk drive  for reading from or writing to a removable optical disk  such as a CD-ROM or other optical media. The hard disk drive , magnetic disk drive , and optical disk drive  are connected to the system bus  by a hard disk drive interface , a magnetic disk drive interface , and an optical drive interface , respectively. The drives and their associated computer-readable media provide non-volatile storage of computer readable instructions, data structures, program modules and other data for the personal computer . Although the exemplary environment described herein employs a hard disk, a removable magnetic disk  and a removable optical disk , it should be appreciated by those skilled in the art that other types of computer readable media which can store data that is accessible by a computer, such as magnetic cassettes, flash memory cards, digital video disks, Bernoulli cartridges, random access memories (RAMs), read-only memories (ROMs) and the like may also be used in the exemplary operating environment.","A number of program modules may be stored on the hard disk, magnetic disk , optical disk , ROM  or RAM , including an operating system  (preferably Windows\u00ae 2000), one or more application programs , other program modules  and program data . A user may enter commands and information into the personal computer  through input devices such as a keyboard  and pointing device . Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner or the like. These and other input devices are often connected to the processing unit  through a serial port interface  that is coupled to the system bus, but may be connected by other interfaces, such as a parallel port, game port or universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video adapter . In addition to the monitor , personal computers typically include other peripheral output devices (not shown), such as speakers and printers.","The personal computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be another personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the personal computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) . Such networking environments are commonplace in offices, enterprise-wide computer networks, Intranets and the Internet.","When used in a LAN networking environment, the personal computer  is connected to the local network  through a network interface or adapter . When used in a WAN networking environment, the personal computer  typically includes a modem  or other means for establishing communications over the wide area network , such as the Internet. The modem , which may be internal or external, is connected to the system bus  via the serial port interface . In a networked environment, program modules depicted relative to the personal computer , or portions thereof, may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Note that the present invention is described herein with respect to the Windows\u00ae 2000 (formerly Windows\u00ae NT\u00ae) operating system. However, as can be readily appreciated, the present invention is not limited to any particular operating system, but rather may be used with any operating system, and moreover, has many uses in general computing.","Efficient Write-Watch","As will be understood, the present invention is primarily directed to an efficient write-watch mechanism and process, as described in the Microsoft Windows\u00ae 2000 operating system\/environment, that are useful for garbage collection mechanisms. Nevertheless, it should be understood that the present invention is capable of operating with virtually any operating system and\/or operating environment, and may be used for write-watch purposes other than for garbage collection, e.g., for detecting processes that corrupt others' memory. Moreover, as used herein, the term \u201cpage,\u201d \u201cpages\u201d or the like represent any section of memory, fixed or variable in size, that can be manipulated by computer memory management.","Turning to  of the drawings, there is shown exemplary components for performing efficient write-watching in accordance with various aspects of the invention. In general, an application , places application programming interface (API) calls to the operating system  through a set of APIs  to perform various tasks. The application may also interface with an application environment, such as COM+  or the like. The COM+ environment  may include a garbage collection process\/mechanism , e.g., the garbage collection mechanism  may be built into or otherwise associated with the architecture . Via API calls or the like, the COM+ architecture works with a memory manager  in the operating system  to transparently and concurrently (relative to the application) implement garbage collection. In keeping with the invention as described below, such calls will result in information (e.g., an array of virtual memory locations) that indicate which virtual memory addresses have been written to (\u201cmodified\u201d or sometimes referred to as \u201cdirtied\u201d) since the last time that the garbage collection mechanism  called. In this manner, the garbage collection mechanism  will know the locations that it needs to scan to see whether it can free objects or the like. Note that as shown herein, the garbage collection mechanism  operates as part of COM+ , however as can be readily appreciated, the mechanism can be implemented in many ways, including, for example, a separate application running in the background, integrated into the operating system, in other architectures layered between the application an the operating system, and so forth.","As will be understood, a suitable garbage collection mechanism  is concurrent in that it does not significantly interrupt the application as it operates to free up virtual memory. However, as will become apparent, the present invention will provide benefits with any component that needs to know when memory has been written to since last asked, including, for example, sequential garbage collection mechanisms. For purposes of simplicity, the garbage collection mechanism  will not be described in detail herein, except to generally note that it places calls specifying that certain memory be write-watched, and then calls as desired to find which of that write-watched memory has changed since it last asked. For flexibility, the calling mechanism can determine whether the call should reset the state to write-watch anew, or leave the state as is, e.g., the garbage collection mechanism  can inquire as to which virtual page addresses have changed, without being considered as having asked and thereby resetting the states. Although not described in detail herein, a separate reset call or the like may be provided to rapidly reset an entire range of virtual page addresses without reporting whether the virtual page addresses in the range have been dirtied.","The operating system  enables the use of virtual memory via the memory manager . Virtual memory allows an application to address large amounts of memory (e.g., up to four gigabytes) even though a machine may not have that much physical RAM. The memory manager  works with or otherwise includes a cache manager (not separately shown) to provide addressable memory beyond the amount of RAM in the system via disk swapping techniques. Memory management is further described in the references, \u201c\u00ae, \u201d by Helen Custer, Microsoft Press (1993); and \u201c\u201d by David A. Solomon, Microsoft Press (1998), hereby incorporated by reference herein.","To manage virtual memory, the memory manager  maintains a set of information on a per-process basis, e.g., as generally represented in , for the process (which may be a process of the application ). One piece of information that the memory manager  maintains for each process is a list of the virtual addresses that have been allocated for that process, maintained in a virtual address descriptor (VAD) tree  for rapid searching. For example, whenever a process (e.g., ) requests access to some specified memory location or locations, the memory manager  searches the VAD tree  to determine whether the process is entitled to access the specified virtual memory.","In accordance with one aspect of the present invention, a range of virtual memory allocated to a process (e.g., ) may be specified as write-watched, via an API call (e.g., VirtualAlloc (n, writewatch), where n is the number of allocation units requested, which in Windows\u00ae 2000 are referred to as pages). Then, as described below, when later asked, e.g., via a GetWriteWatch( ) API, GetResetWriteWatch( ) API or the like, the memory manager , via a write-watch process\/mechanism , will efficiently determine whether a requested range of virtual page addresses has been written to (on a per page basis) since the last time the reset call was placed, and provide this information to the caller. In one implementation, an array  identifying modified virtual page addresses is returned in response to a call, although as can be readily appreciated, the information may be returned in other ways, e.g., a corresponding bitmap of ones and zeroes indicating whether each virtual page address in a specified range is modified or unmodified may be alternatively returned.","To efficiently track whether a virtual page address is modified (sometimes referred to as \u201cdirty\u201d or \u201cdirtied\u201d) or unmodified, a preferred embodiment of the present invention employs a combination of information, some of which is already maintained by the operating system , along with a new set of information. For efficiency, in one embodiment the new set of information comprises a single bit per virtual page address associated with each page range maintained in the VAD tree , i.e., each VAD in the VAD tree  that is write-watched has a bitmap (e.g., ) allocated thereto, having a size corresponding to the number of virtual page addresses in the range. For example, a VAD entry in the VAD tree  representing twenty virtual page addresses will have a bitmap of twenty bits in size, although as can be appreciated, the bitmap may be larger (rounded up to the nearest byte boundary), or, although less efficient, more than one bit can be used to track a given virtual page address's write-watch status. As described below, however, a single bit per virtual page address may be used to track the write-watch state.","In accordance with one aspect of the present invention, each write-watch bitmap \u2013in the VAD tree  includes bits with values that indicate whether a virtual page address that the bit represents was modified at a time it was trimmed to disk. More particularly, and as generally described below with reference to the flow diagram of , memory management often requires that a page's data in physical RAM be cached to disk so that the RAM page can be used for another application, while preserving the previous information. If the write-watched page is marked as modified, the corresponding bit in the appropriate write-watch VAD bitmap (e.g., ) is set at the time the page is written to disk (\u201ctrimmed\u201d). Then, when later asked whether that range is modified, the memory manager  can efficiently return the information directly from the relevant VAD, without having to access the disk. Note that rather than walk the entire VAD tree  for write-watched virtual page address ranges, e.g., to locate the relevant VAD and its associated bitmap , a separate linked-list  of write-watched VADs may be maintained to provide more-efficient write-watch servicing, since typically such lists are relatively small compared to the entire VAD tree .","If the bit in the VAD bitmap is not set, it does not mean that the virtual page address is not modified. Instead, it means either that the virtual page address was not written to, or was modified, but not trimmed to disk. In this situation, the memory manager  may determine whether the virtual page address is modified based on a flag maintained with the virtual page address mapping information. More particularly, as generally represented in  and described in the aforementioned \u00ae references, each process that has virtual memory allocated thereto has one or more page directories \u2013maintained therefor by the memory manager , primarily used for converting a virtual address to a physical page of memory. The relevant virtual page address directory is located from part (e.g., the upper bits) of the virtual address provided by the application . Each page directory (e.g., ) has a number of page directory entries (PDEs), wherein each entry serves as an index to one of a set of page tables \u2013. Each page table (e.g., ) includes page table entries (PTEs), one of which (indexed from another part of the virtual address) identifies the actual physical page in memory (RAM ), along with flags regarding the state of the virtual page address, such as whether the virtual page address is currently mapped to a physical page (valid) or has been trimmed to disk (invalid). One of the flags, represented as the flag location  in , has a value that indicates whether the virtual page address has been modified since last mapped to a physical page (e.g., recalled from disk). Note that this tracking is already done by the memory manager  in the Windows\u00ae 2000 operating system, and thus no extra time is taken by the write-watch mechanism  to track this information during memory writing operations.","In accordance with one aspect of the invention, if a given virtual page address in the specified range was not both written to and trimmed to disk, (i.e., the relevant bit in the relevant VAD bitmap is not marked), the memory manager  instead determines whether that virtual page address is unmodified or modified based on the flag  setting in the page table entry for that virtual page address. However, because the write-watch process  may be concerned with whether the virtual page has been modified since last asked in a write-watch call, this flag cannot remain set in a GetResetWriteWatch( ) API call, else it would always indicate modified while the page is valid (i.e., in actual memory, not trimmed to disk), including possibly in the next call. Thus, the flag  needs to be cleared once it is used by the write-watch mechanism  in the memory manager . However, the information of the modified state of the page cannot be lost, else it may not be properly swapped to disk, and is thus written to another database of information, a PFN database  has a modified flag  set in an atomic operation. Note that the PFN database  maintains state information about the actual physical memory installed in a system, e.g., there is a record in the PFN database  for each page of physical memory, not one for each virtual memory page address. The PTE flag  may then be cleared. Note that in a multi-processor system, any other processors are interrupted at this time, since they may be sharing the PTE. When later trimming pages, the memory manager  can then determine whether a page in physical memory is unmodified or modified based on the PFN database flag  instead of the PTE flag  (either flag marked as modified indicates that the page data has changed relative to the disk copy and thus the in-memory page needs to be preserved).","To enhance the speed of determining whether the virtual page addresses in a specified write-watch range have been modified, prior to checking the PTE for a virtual address that was not marked as modified in the VAD bitmap , a flag  in the relevant entry in the page directory is checked to determine whether the page directory is marked as trimmed, e.g., the entire set of virtual page addresses referenced via that page directory have been trimmed to disk. If so, then it is known that the virtual page address in question was trimmed, whereby the relevant bitmap in the VAD tree  reflects the modified or unmodified state of each virtual page address corresponding to the page directory . Note that as described above, this is because virtual address pages that are modified and trimmed have their modified status rippled up to the VAD bitmap at the time of trimming. In other words, any unmarked (e.g., zero) bits in the VAD bitmap corresponding to this range are known to represent unmodified virtual page addresses, since any modified, trimmed page has its bit set in the VAD bitmap when trimmed. The portion of the VAD bitmap corresponding to the trimmed page directory thus reflects the modified or unmodified state of pages in this page directory, whereby the PTE need not be located and checked (and processors interrupted) for any pages in that trimmed part of the range. As can be readily appreciated, simply running the VAD bitmap is significantly faster than checking a set of PTEs.","Turning to an explanation of the operation of the present invention,  represents one part of the write-watch mechanism  in the memory manager  that sets the relevant bit in the VAD bitmap whenever a modified page is trimmed to disk. As can be seen in this simplified flow diagram, via step  only pages marked as modified in the PTE are considered when updating the VAD bitmap , however via step  a page that is not marked as modified in the PTE but marked as modified in the PFN database  is still preserved. If marked modified in the PTE at step , the trimming process determines at step  whether the virtual page address is being write-watched, e.g., by examining the short list  () of write-watched page ranges for this process . If not write-watched, the page is trimmed as normal (step ), otherwise steps  and  are first executed to locate and set the relevant bit in the write-watch VAD bitmap before the page is trimmed. Note that during normal write-watch operation, (e.g., not considering the operations during the various write-watch API calls), the relevant VAD bitmap only need be accessed to set the relevant bit when a modified page is trimmed, thus keeping the overall write-watch process  highly efficient. In other words, while it would be feasible to set the relevant bit in the VAD bitmap whenever a virtual page address is modified, such an extra step on each memory write would degrade system performance. Instead, the performance hit of updating the VAD bitmap occurs only when a page is trimmed to disk during low physical memory conditions, (memory pressure), and indeed, this is relatively insignificant compared to the impact on system performance as pages are swapped to and from disk.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIGS. 6 and 7","b":["68","600","80","70","80"],"sub":"1"},"At step , the bitmap associated with the relevant VAD is examined beginning at the bit corresponding to the first virtual page address in the specified range. Step  tests the bit, i.e., to determine whether the bit's value indicates that the page is modified (and, as described above, was trimmed since last asked). If so, step  branches to step  wherein the bit is cleared (if this is the reset API) and at step  the virtual page address identity is added to the information (e.g., the array  or bitmap or the like) to be returned to the caller (step ). Steps \u2013 generally repeat the process for the remainder of the specified range, with the information returned to the caller at step .","Returning to step , if the bit is not set, then the write-watch process  needs to look further to determine whether the virtual page address was modified since last asked (and reset). To this end, step  branches to step  of .","At step , the page directory entry (PDE) of the virtual page address under scrutiny is accessed, and at step  is evaluated to determine if this page (and any others to which this PDE corresponds) have been trimmed to disk, i.e., whether the PTE is valid or invalid. If invalid (trimmed), then the write-watch bitmap in the VAD accurately reflects the modified\/unmodified state of each virtual page address mapped by this PDE. Steps \u2013 rapidly traverse the bitmap recording modified pages until either the end of the range is reached or the pages in the PDE are exhausted. As can be readily appreciated, running the bitmap in this manner provides a significant performance improvement, as, for example, in one implementation a PDE may have 1,024 page table entries therein, allowing large sets of trimmed virtual pages to be rapidly processed. When either the requested range (e.g., the bitmap) or the PDE is exhausted, the write-watch process  returns to step  of  to either move on to the next bit\/virtual page address (step ) or return the write-watch information (step ), as described above.","If, however, at step  the page directory for the virtual page address being evaluated does not indicate that the virtual page address was trimmed, the write-watch process  instead branches to step  where it looks to the PTE of the page (represented by the current bit) to determine whether the virtual page address is modified (although not trimmed), which is determined by the flag  as described above. If not modified, (step ), the process returns to step  of , to either move on to the next bit\/virtual page address (step ) or return the write-watch information (step ), as described above. However, if via steps  and  the PTE indicates that the virtual page address is modified, the operations represented by steps  and  are executed (if in the reset API case), to set the flag  in the PFN database  (step ) and clear the flag  in the PTE (step ) for this virtual page address as described above, interrupting multiple processors if present, as described above. The virtual page address is added to the information (e.g., the array  of modified pages to be returned to the caller) at step . The process then returns to step  of  to either move on to the next bit (representing the next virtual page address) at step , or return the write-watch information at step , as described above.","In this manner, write-watch itself is extremely fast, as during normal operation only a single bit per virtual page address needs to be set, and only when that page is modified and trimmed to disk. When later requested to report the write-watch results, the bitmap for a VAD is traversed extremely rapidly, only checking the PTE when pages are valid.","As can be seen from the foregoing detailed description, there is provided a method and system for efficiently performing write-watch on ranges of memory. Indeed, tests have shown increases in performance of up to ten times relative to other known write-watch techniques. The write-watch technique of the present invention adds as little as one bit to each write-watch page, and does not significantly impact system performance in normal system operation, only adding extra time to track writes when disk swapping under memory pressure.","While the invention is susceptible to various modifications and alternative constructions, certain illustrated embodiments thereof are shown in the drawings and have been described above in detail. It should be understood, however, that there is no intention to limit the invention to the specific form or forms disclosed, but on the contrary, the intention is to cover all modifications, alternative constructions, and equivalents falling within the spirit and scope of the invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIGS. 6\u20137"}]},"DETDESC":[{},{}]}
