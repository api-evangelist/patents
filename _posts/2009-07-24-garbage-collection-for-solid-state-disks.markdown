---
title: Garbage collection for solid state disks
abstract: Described embodiments provide a method of recovering storage space on a solid state disk (SSD). An index and valid page count are determined for each block of a segment of an SSD. If the valid page count of at least one block in the segment is zero, a quick clean is performed. A quick clean deallocates blocks having zero valid pages and places them in a queue for erasure. Otherwise, a deep clean is performed. A deep clean determines a compaction ratio, N-M, wherein N is a number of partially valid blocks and M is a number of free blocks required to compact the valid data from the N partially valid blocks into M entirely valid blocks. At least one data structure of the SSD is modified to refer to the M entirely valid blocks, and the N partially valid blocks are placed in the queue for erasure.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08166233&OS=08166233&RS=08166233
owner: LSI Corporation
number: 08166233
owner_city: Milpitas
owner_country: US
publication_date: 20090724
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["The subject matter of this application is related to U.S. patent application Ser. No. 12\/436,227filed May 6, 2009, Ser. No. 12\/477,996 filed Jun. 4, 2009, and Ser. No. 12\/478,013 filed Jun. 4, 2009, the teachings of all of which are incorporated herein in their entireties by reference. The subject matter of this application is also related to U.S. patent application Ser. No. 12\/475,710 filed Jun. 1, 2009, Ser. No. 12\/475,716 filed Jun. 1, 2009, Ser. No. 12\/508,915 filed Jul. 24, 2009, Ser. No. 12\/643,471 filed Dec. 21, 2009, Ser. No. 12\/649,490 filed Dec. 30, 2009, Ser. No. 12\/722,828 filed Mar. 12, 2010, Ser. No. 12\/730,627filed Mar. 24, 2010, Ser. No. 12\/731,631 filed Mar. 25, 2010, Ser. No. 12\/767,985 filed Apr. 27, 2010, Ser. No. 12\/768,058 filed Apr. 27, 2010, Ser. No. 12\/769,882 filed Apr. 29, 2010 and Ser. No. 12\/769,910 filed Apr. 29, 2010.","1. Field of the Invention","The present invention relates to flash memory storage devices, and, in particular, to garbage collection routines for solid state disks (SSDs).","2. Description of the Related Art","Flash memory is a type of non-volatile memory that is electrically erasable and re-programmable. Flash memory is primarily used in memory cards and USB flash drives for general storage and transfer of data between computers and other digital products. Flash memory is a specific type of electrically erasable programmable read-only memory (EEPROM) that is programmed and erased in large blocks. One commonly employed type of flash memory technology is NAND flash memory. NAND flash memory forms the core of the flash memory available today, especially for removable universal serial bus (USB) storage devices known as USB flash drives, as well as most memory cards. NAND flash memory exhibits fast erase and write times, requires small chip area per cell, and has high endurance. However, the I\/O interface of NAND flash memory does not provide full address and data bus capability and, thus, generally does not allow random access to memory locations.","There are three basic operations for NAND devices: read, write and erase. The read and write operations are performed on a page by page basis. Page sizes are generally 2bytes, where N is an integer, with typical page sizes of, for example, 2,048 bytes (2 kb), 4,096 bytes (4 kb), 8,192 bytes (8 kb) or more per page. Pages are typically arranged in blocks, and an erase operation is performed on a block by block basis. Typical block sizes are, for example, 64 or 128 pages per block. Pages must be written sequentially, usually from a low address to a high address. Lower addresses cannot be rewritten until the block is erased.","A hard disk is addressed linearly by logical block address (LBA). A hard disk write operation provides new data to be written to a given LBA. Old data is over-written by new data at the same physical LBA. NAND flash memories are accessed analogously to block devices, such as hard disks. NAND devices address memory linearly by page number. However, each page might generally be written only once since a NAND device requires that a block of data be erased before new data is written to the block. Thus, for a NAND device to write new data to a given LBA, the new data is written to an erased page that is a different physical page from the page previously used for that LBA. Therefore, NAND devices require device driver software, or a separate controller chip with firmware, to maintain a record of mappings of each LBA to the current page number where its data is stored. This record mapping is typically managed by a flash translation layer (FTL) in software that might generate a logical to physical translation table. The flash translation layer corresponds to the media layer of software and\/or firmware controlling an HDD.","Associated with each page is a spare area (typically 100-500 bytes) generally used for storage of error correction code (ECC) information and for storage of metadata used for memory management. The ECC is generally needed for detecting and correcting errors in the user data stored in the page, and the metadata is used for mapping logical to and from physical addresses. As such, the additional bytes of memory are \u201chidden\u201d from the user and are not available for storing data. The first block (block 0) of a flash die is generally provided from the manufacturer error-free, and is commonly used by designers to include program code and associated metadata for block management.","Typically, for high capacity solid state disks (SSDs), several design tradeoffs might be considered when implementing a method to maintain a logical to physical translation table. These tradeoffs typically include: efficient random access memory (RAM) usage; efficient flash usage; fast address lookup for both read operations and write operations; and fast reconstruction of the translation table on device startup.","Several techniques are known in the art for maintaining the logical to physical translation table. One such approach is known as direct page mapping, an example of which is described in the paper by Andrew Birrell & Michael Isard, et al., A DH-PFD, Vol. 41, Issue 2, pp. 88-93, (April 2007), which is incorporated herein by reference in its entirety (hereinafter \u201cBirrell\u201d). Direct page mapping maintains a lookup table in RAM having an entry for each flash page, and a summary page for metadata at the end of each block, from which the logical to physical translation table may be reconstructed at startup. For example, a direct page mapped translation table might contain, for every LBA, a logical sector number corresponding to a physical block number and a physical page number. Thus, direct page mapping comprises a single-level logical-to-physical translation. The summary page for each block might contain the LBA and valid bits for each page in the block so that the translation table can be reconstructed at startup. Thus, the direct page mapping scheme requires a large amount of RAM (on the order of 1-2 MB per GB of user storage) to store the translation table, which can become burdensome for higher capacity SSDs.","Another approach is known as block mapping. Block mapping generally classifies blocks as either data blocks (D-blocks) or update blocks (U-blocks). The total size of the D-blocks is the effective storage space for user data. U-blocks are invisible to users. Generally, when a write command cannot be accommodated in the D-block corresponding to the LBA, a U-block is allocated to receive the new data and the old data in the D-block is invalidated. Subsequent writes to that D-block will be received by the allocated U-block. When the U-block becomes full, another U-block might be allocated, or the U-block might be merged with the original D-block. Thus, block mapping maintains a lookup table in RAM that maps a logical block to a physical block. Block mapping lacks a page-level map, relying instead on the typical case that data is stored in sequential order within the block. For example, a block mapped translation table might contain a logical sector number corresponding to a logical block number and a logical page number. The logical block number can be translated into a physical block number and the logical page number might correspond to a physical offset within the physical block. Thus, block mapping comprises a two-level logical-to-physical translation. The size of the translation table is proportional to the number of blocks in the flash memory, thus requiring less RAM than a page mapped translation table.","However, because block mapping does not have a page-level map, the flash media may be inefficiently utilized when the data access workload is non-sequential. For non-sequential data access workloads, block mapping might require data to be copied and re-written numerous times to maintain the correct mapping. An example of block mapping is described in the paper by Jeong-Uk Kang & Heeseung Jo, et al., A S-FTLNAND FM6& , pp. 161-170, (Oct. 22-25, 2006), which is incorporated herein by reference in its entirety (hereinafter \u201cKang\u201d).","A third approach for maintaining the logical-to-physical translation table is known as superblock mapping. Superblock mapping groups together a set number of adjacent logical blocks into a superblock. Superblock mapping maintains a page global directory (PGD) in RAM for each superblock. Page middle directories (PMDs) and page tables (PTs) are maintained in flash. Each LBA can be divided into a logical block number and a logical page number, with the logical block number comprising a superblock number and a PGD index offset. The logical page number comprises a PMD index offset and a PT index offset. Each entry of the PGD points to a corresponding PMD. Each entry of the PMD points to a corresponding PT. The PT contains the physical block number and the physical page number of the data. Super-block mapping, thus, comprises a four-level logical-to-physical translation and provides page-mapping.","The PMD's and PT's are stored in the spare areas of the flash pages to provide page-mapping without using an excessive amount of RAM. However, because the spare area is used to store page-level mapping information, less memory is available for error correction codes (ECC). Further, the limited amount of memory available in the spare area precludes storing complicated mapping information. Finally, reconstruction of the translation table at startup can be time-intensive. An example of a superblock mapping scheme is described in Kang.","As described above, for write operations NAND devices store the new data for the LBA on a new page, unlike hard disk drives (HDDs) that can rewrite individual physical sectors. Thus, a NAND device generally requires that a block be erased before new data can be written to the block. Further, as described above, often a NAND device will write new data for a given LBA to an erased page that is a different physical page from the page previously used for that LBA. Thus, NAND devices also generally require the device driver software or the separate controller chip periodically initiate a process to erase data that is \u201cstale\u201d or out-of-date. As would be apparent to one of skill in the art, without periodically erasing out-of-date data, the flash memory would fill up with data that is mostly out-of-date. This inefficiency would reduce the realized flash memory capacity because less current data could be stored. Therefore, device driver software or controller chips generally periodically run a \u201cgarbage collection\u201d routine adapted to provide efficient flash memory utilization by erasing out-of-date blocks. An example of a garbage collection routine is described in Kang. Garbage collection routines impact performance of the flash memory system by utilizing processor resources and potentially delaying write operations to the flash media.","However, NAND device blocks can be erased a limited number of times before device failure (typically on the order of 100,000 erasures). Therefore, over the operational life of an SSD, blocks of flash memory will fail and become unusable. Thus, the device driver software or the separate controller chip should minimize the number of erasures, and must also maintain a record of bad blocks. For example, device driver software or controller chips might implement wear leveling to spread the erasing and writing of blocks over the entire flash memory evenly to avoid repeatedly erasing and writing a given subset of blocks.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter.","Described embodiments provide a method of recovering storage space on a solid state disk (SSD). An index and valid page count are determined for each block of at least one segment of an SSD. If the valid page count of at least one block in the segment is zero, then a quick clean is performed. For some embodiments, a quick clean deallocates blocks having zero valid pages from the segment of the SSD and places the deallocated blocks in a queue for erasure. Otherwise, a deep clean is performed. For some embodiments, a deep clean determines a compaction ratio, N-M, for the at least one segment of the SSD, wherein N is a number of partially valid blocks and M is a number of free blocks corresponding to compiled valid data from each of the N partially valid blocks. Valid data from each of the N partially valid blocks is compacted into M free blocks, forming M entirely valid blocks. At least one data structure of the SSD is modified to refer to the M entirely valid blocks, and the N partially valid blocks are placed in the queue for erasure.","In accordance with embodiments of the present invention, garbage collection operations for solid state disks (SSDs) are provided. Garbage collection operations allow a flash memory storage system to update a logical memory location by writing data to a new physical memory location without necessarily updating or erasing the previously used physical memory location simultaneously. Garbage collection operations \u201cclean\u201d physical memory locations containing out-of-date or invalid data at a later time. Embodiments of the present invention might provide garbage collection operations to prioritize which blocks to clean in order to minimize the performance impact of garbage collection operations on a given flash memory storage system.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 1","b":["100","100","102","100","104","114","118","102","100","102"]},"Flash controller  controls transfer of data between flash media  and an external device coupled to communication link . Flash controller  might be implemented as a system-on-chip (SoC). Flash controller  might include internal RAM buffer  and might also be coupled to additional external memory, shown as external RAM buffer . In an exemplary embodiment, internal RAM buffer  comprises 128 kB of static RAM (SRAM) and external RAM buffer  comprises 512 MB of double data rate version 2 dynamic RAM (DDR2 DRAM). RAM buffer  might act as a cache for processor , while RAM buffer  might act as a read\/write buffer between flash media  and communication link . Although shown in  as a single processor, processor  might be implemented with multiple processors (not shown). Processor  includes software and\/or firmware as needed for operation, including those for garbage collection in accordance with exemplary embodiments of the present invention, as described subsequently, with respect to .",{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 2","FIG. 2"],"b":["116","104","202","102","104","202","102","208","208","118","100","208","210","118","102","114","112","208","118","212","212","118","208","208","118","202","210","208"]},"For example, flash controller  () receives requests for flash media access from external devices, such as read or write operations, from communication link . Received requests are processed by host layer . Host layer  i) controls all host interface specific commands (e.g. SATA commands), ii) coordinates host-side data transfers and command execution, and iii) processes any other host commands (e.g. status updates). Host layer  is in communication with buffer layer . FTL  also interfaces with buffer layer . Since data transfers between communication link  and flash media  are temporarily stored in buffer memory, buffer layer  generally directs the data traffic between host layer  and FTL . For example, if an external host (not shown) provides, via communication link , data to be written to flash media , buffer layer  might coordinate temporary storage of the data in buffer  until FTL  coordinates writing the data to flash media . Similarly, if the external host requests to read data from flash media , buffer layer  might temporarily store the data in buffer  until host layer  coordinates sending the data to the host via communication link .",{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 3","FIG. 3"],"b":["300","208","300","302","208","300","208","300","104","100"]},"At step , FTL  performs an initial scan of a given segment of flash media , such as, for example, a selected group of one or more superblocks.  shows detail of an exemplary initial scan sub-routine of garbage collection method  of . As shown in , initial scan  is initiated at step . At step , FTL  analyzes blocks in each of the selected superblocks to determine the number of valid pages in each block of the superblock. Based on the analysis of step , FTL , at step , constructs an index, for example a bitmap or another type of index, and a count of valid pages in each block. At step , initial scan  is complete.","Returning to , at step , FTL  scans the indices and counts of valid pages (or \u201cvalid page count\u201d) in each block generated during initial scan . If any blocks contain less than a threshold number of valid pages, a quick clean operation is initiated at step . If no blocks contain less than the threshold number of valid pages, a deep clean operation is initiated at step . In some embodiments of the present invention, the threshold number of valid pages might be zero. A threshold value of zero valid pages might be selected since blocks containing zero valid pages are entirely invalid, and can be easily cleaned, as shown in .",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 5","b":["308","502","504","208","506","208","208","118","208","308","100","308","508","300","312"]},"Returning to , if, at step , no blocks contain fewer than the threshold number of valid pages, for example, all blocks contain at least one valid page, a deep clean operation is initiated at step . Deep clean operation  might be performed \u201cin-line\u201d if space must be freed immediately, meaning that deep clean operation  could delay read or write operations to flash media , or deep clean operation might be performed in system idle time if it is not critical to free the space. For example, if there are fewer than a minimum threshold of available blocks in the superblock, deep clean operation might be performed \u201cin-line\u201d to increase free storage space. Deep clean operation  is shown in greater detail in .","As shown in , deep clean operation  is initiated at step . At step , the data gathered during initial scan  is used to create an ordered list of the blocks of a selected superblock. For example, at step , FTL  might use the valid page count for each block to create an ordered list of blocks, starting with the block containing the fewest valid pages and continuing to the block containing the most valid pages.","At step , FTL  determines a compaction ratio indicative of a number, N, of partially valid blocks that can be compacted into a number, M, of entirely valid blocks, thus freeing N-M blocks for erasure (where N is greater than or equal to M, and N and M are integers greater than or equal to zero). FTL  determines the compaction ratio by processing the ordered list of blocks starting with the block containing the fewest valid pages. Thus, FTL  can free the largest number of blocks with the least amount of data movement for valid data. At step , if the value of N-M is not greater than a predetermined threshold, processing continues to step . At step , the list of blocks is reordered, accounting for partially valid blocks that were already accounted for in the compaction ratio determined in step . From step , the method returns to step  and a new compaction ratio is determined at step  that is again tested against the predetermined threshold at step . If, at step , the compaction ratio is greater than the predetermined threshold, at step , FTL  allocates M free blocks from the free block pool. At step , the M free blocks are used to store the valid data compacted from the N partially valid blocks, which now are invalid blocks. At step , FTL  updates the data structures for the N invalid blocks to refer to the M new blocks. For example, the data structures might include at least one of: a logical-to-physical translation table, one or more summary pages, a page global directory, one or more page middle directories and one or more page tables.","At step , deep clean operation  might be performed \u201cin-line\u201d if space must generally be freed immediately, as described above. Thus, at step , in embodiments of the present invention, if there are fewer than a minimum threshold of available blocks in the superblock, deep clean operation  might be performed \u201cin-line\u201d to increase free storage space, meaning that deep clean operation  might delay read or write operations to flash media  in order to erase one or more of the N invalid blocks immediately at step . Once the invalid blocks are erased, deep clean operation  is complete at step . If the number of available blocks in the superblock is greater than a minimum threshold, at step  FTL  places the N invalid blocks in the queue to be erased, which can be performed during idle time of flash memory storage system . Once the N invalid blocks are placed in the queue to be erased, deep clean operation  finishes at step  and method  advances to step  of  where garbage collection completes.","As would be apparent to one skilled in the art, there is a tradeoff between the frequency of performing garbage collection operations and efficient usage of system resources. For example, by waiting longer to perform garbage collection method , more blocks of data in each superblock become invalid. More invalid data blocks increases the likelihood that quick clean operation  can be performed and minimizes the data that must be moved if deep clean operation  is required. However, waiting longer to perform a garbage collection operation reduces the storage space available to the end-user of flash memory storage system  since invalid blocks might not be freed quickly and, thus, more blocks are used to store invalid data. As described above, garbage collection might be performed upon exceeding a predetermined threshold ratio of used blocks to available blocks within a given superblock. Some embodiments of the present invention further allow for the predetermined threshold ratio of used blocks to available blocks within a given superblock to be configurable by a user of flash memory storage system . For example, in embodiments of the present invention, the threshold ratio of used blocks to available blocks is a user-configurable register value of flash controller .","Reference herein to \u201cone embodiment\u201d or \u201can embodiment\u201d means that a particular feature, structure, or characteristic described in connection with the embodiment can be included in at least one embodiment of the invention. The appearances of the phrase \u201cin one embodiment\u201d in various places in the specification are not necessarily all referring to the same embodiment, nor are separate or alternative embodiments necessarily mutually exclusive of other embodiments. The same applies to the term \u201cimplementation.\u201d","While the exemplary embodiments of the present invention have been described with respect to processing blocks in a software program, including possible implementation as a digital signal processor, micro-controller, or general purpose computer, the present invention is not so limited. As would be apparent to one skilled in the art, various functions of software may also be implemented as processes of circuits. Such circuits may be employed in, for example, a single integrated circuit, a multi-chip module, a single card, or a multi-card circuit pack.","The present invention can be embodied in the form of methods and apparatuses for practicing those methods. The present invention can also be embodied in the form of program code embodied in tangible media, such as magnetic recording media, optical recording media, solid state memory, floppy diskettes, CD-ROMs, hard drives, or any other machine-readable storage medium, wherein, when the program code is loaded into and executed by a machine, such as a computer, the machine becomes an apparatus for practicing the invention. The present invention can also be embodied in the form of program code, for example, whether stored in a storage medium, loaded into and\/or executed by a machine, or transmitted over some transmission medium or carrier, such as over electrical wiring or cabling, through fiber optics, or via electromagnetic radiation, wherein, when the program code is loaded into and executed by a machine, such as a computer, the machine becomes an apparatus for practicing the invention. When implemented on a general-purpose processor, the program code segments combine with the processor to provide a unique device that operates analogously to specific logic circuits. The present invention can also be embodied in the form of a bitstream or other sequence of signal values electrically or optically transmitted through a medium, stored magnetic-field variations in a magnetic recording medium, etc., generated using a method and\/or an apparatus of the present invention.","It should be understood that the steps of the exemplary methods set forth herein are not necessarily required to be performed in the order described, and the order of the steps of such methods should be understood to be merely exemplary. Likewise, additional steps may be included in such methods, and certain steps may be omitted or combined, in methods consistent with various embodiments of the present invention.","As used herein in reference to an element and a standard, the term \u201ccompatible\u201d means that the element communicates with other elements in a manner wholly or partially specified by the standard, and would be recognized by other elements as sufficiently capable of communicating with the other elements in the manner specified by the standard. The compatible element does not need to operate internally in a manner specified by the standard.","Also for purposes of this description, the terms \u201ccouple,\u201d \u201ccoupling,\u201d \u201ccoupled,\u201d \u201cconnect,\u201d \u201cconnecting,\u201d or \u201cconnected\u201d refer to any manner known in the art or later developed in which energy is allowed to be transferred between two or more elements, and the interposition of one or more additional elements is contemplated, although not required. Conversely, the terms \u201cdirectly coupled,\u201d \u201cdirectly connected,\u201d etc., imply the absence of such additional elements. Signals and corresponding nodes or ports may be referred to by the same name and are interchangeable for purposes here.","It will be further understood that various changes in the details, materials, and arrangements of the parts which have been described and illustrated in order to explain the nature of this invention may be made by those skilled in the art without departing from the scope of the invention as expressed in the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Other aspects, features, and advantages of the present invention will become more fully apparent from the following detailed description, the appended claims, and the accompanying drawings in which like reference numerals identify similar or identical elements.",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 5","FIG. 3"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 6","FIG. 3"]}]},"DETDESC":[{},{}]}
