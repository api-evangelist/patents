---
title: Method and apparatus for increasing performance of HTTP over long-latency links
abstract: The invention increases performance of HTTP over long-latency links by pre-fetching objects concurrently via aggregated and flow-controlled channels. An agent and gateway together assist a Web browser in fetching HTTP contents faster from Internet Web sites over long-latency data links. The gateway and the agent coordinate the fetching of selective embedded objects in such a way that an object is ready and available on a host platform before the resident browser requires it. The seemingly instantaneous availability of objects to a browser enables it to complete processing the object to request the next object without much wait. Without this instantaneous availability of an embedded object, a browser waits for its request and the corresponding response to traverse a long delay link.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07694008&OS=07694008&RS=07694008
owner: Venturi Wireless
number: 07694008
owner_city: Sunnyvale
owner_country: US
publication_date: 20050504
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["1. Technical Field","The invention relates to improvements in the performance of computer networks. More particularly, the invention relates to increasing performance of HTTP over long-latency links by pre-fetching objects concurrently via aggregated and flow-controlled channels.","2. Description of the Prior Art","Internet Web pages embed many types of URLs and objects. Standard browsers that display Internet Web pages can fetch some of these objects in parallel from their Web server repository. Schemes that use a browser's capability to fetch objects in parallel reduce the time taken by a browser to display pages that have many embedded objects. However, the degree of parallelism is limited due to backward compatibility, effectiveness of TCP flow control, and simplicity of browser implementation when downloading certain types of objects, such as JavaScripts and StyleSheets. The currently well-known Web browsers always download JavaScripts in sequence and StyleSheets in a separate phase.","The sequential fetching of objects degrades the end user experience with such URLs in high latency and low bandwidth networks, such as radio access networks. In short, servers are waiting for new requests to arrive but clients do not issue them until previous corresponding responses are received. This causes the link to be under used.","A general purpose cache on a browser is used to improve the time taken to revisit the same Web page. However, the general purpose cache does not help the first visit to a Web page over a wireless link. Also, a subsequent revisit may not be of benefit if the browser has cleared parts of its cache to accommodate objects from subsequent fetches from other Web sites. Thus, the use of a general purpose cache does not provide a consistent and predictable improvement in performance.","The HTTP 1.1 Request Pipelining standard (RFC 2616) allows the degree of concurrency to be increased if it is properly employed when both ends support it. However, modern browsers do not use it in an optimal fashion for many reasons, such as backward compatibility, simplicity of implementation, and effectiveness of flow control. Thus, the standard does not change the browser behavior, and therefore fails to optimize the link use at all times.","It would be advantageous to provide a method and apparatus that mitigates the negative impact of sequential access in low bandwidth and high delay networks without altering browser behaviors.","The invention mitigates the negative impact of sequential access in low bandwidth and high delay networks without altering browser behaviors. This is achieved by increasing the degree of parallelism over the long-latency link by imposing a different downloading strategy, i.e. pre-fetch, from an agent to a gateway server. The issue of low degrees of parallelism is localized between the browser and the agent where there is virtually no latency and bandwidth limitation for HTTP transactions. The issue, therefore, is alleviated.","In one embodiment, the invention comprises a piece of software (client) that communicates with corresponding server software which readies the necessary object to be available on the platform hosting the browser. Low utilization over long-latency links occurs when browsers try to download objects from source Web servers in sequence or in a degree of concurrency that is less-than-optimal. This contributes to a major latency experienced by the end user. This latency can be greatly reduced by using the pre-fetching mechanism of this invention. Thus, the invention increases performance of HTTP over long-latency links by pre-fetching objects concurrently via aggregated and flow-controlled channels. The agent and gateway together assist a Web browser in fetching HTTP contents faster from Internet Web sites over long-latency data links. The gateway and the agent coordinate the fetching of selective embedded objects in such a way that an object is ready and available on a host platform before the resident browser requires it. The seemingly instantaneous availability of objects to a browser enables it to complete processing the object to request the next object without much wait. Without this instantaneous availability of an embedded object, a browser waits for its request and the corresponding response to traverse a long delay link. The invention is not limited to cache history on a browser. It actively performs selective fetch from the gateway server in a highly concurrent fashion, prior to the browser requesting a particular object. It does not require any support from Web browsers and end source servers. It also does not introduce any flow control issue under the high degree of parallelism. Thus, the invention improves HTTP performance of client-server implementations, especially with Web sites that use many JavaScripts and Style Sheets.","Definitions","HTTP: Hyper Text Transfer Protocol\u2014a TCP\/IP based protocol to transfer Web pages, documents, etc. over the Internet.","HTML: Hyper Text Markup Language.","API: Application Programming Interface.","VTP: A Transport Protocol.","XML: Extension Hyper Text Markup Language.","As of today, publicly available HTTP browsers open a limited number of concurrent TCP connections to Web servers due to the decreased flow control effect as the number of TCP connections increase. This limits the degree of concurrency for the downloading of page objects. The HTTP1.1 Pipelining standard supra. tries to solve this problem by allowing the sending out of multiple requests through the same TCP connection before their responses are received. However, due to backward compatibility and the limitations of browsers and servers, the degree of concurrency is often low.","In addition, several types of objects, such as JavaScripts and Cascading Style Sheets, are often downloaded sequentially by browsers due to implementation simplicity. This further decrease the degree of concurrency, and therefore, the use of the long-latency link, due to the time spent on waiting for responses.","The preferred embodiment of the invention comprises an agent and gateway system that, by using an independent flow control mechanism (VTP), is not concerned by the number of TCP connections virtually opened between the browser host platform and the source Web (or proxy) server, and that is therefore useful for downloading objects in parallel. By using a cache on the client side, Web objects can be downloaded in parallel as soon as the agent is aware of them, independent from the implementation of end browsers and source Web servers.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1","b":["11","10","12","17","13","14","19","16","14"]},"Where the degree of parallelism is low and the number of requests is low, the invention identifies the fact that many browsers branch JavaScripts and Style Sheets in a sequential manner, rather than in parallel. Thus, the invention explicitly pre-fetches this type of object, with dramatically improved overall performance.","For example, a Web page may have several JavaScripts and Style Sheets and many GIFs. These are some of the components of a Web page, and they are used for rendering the Web page. The Web page may also comprise additional HTML, JPEGs, and FLASH, etc.","The inventors have identified two objects, i.e. JavaScripts and Style Sheets, as major factors that slow the system down, although the invention is not limited to the pre-fetching of just these objects. A browser may already perform some parallel fetching, but JavaScripts and Style Sheets are not typically fetched, nor is any effort made to discriminate in the type of object that is being fetched. By selectively pre-fetching these certain objects, such as these types of objects, the system's performance is dramatically improved. Thus, the preferred embodiment implements client-side selective pre-fetching which, in the presently preferred embodiment, comprises JavaScript and Style Sheet pre-fetching.","The invention preferably comprises pre-fetcher  and a cache  components, the latter of which is introduced in the client part of the system. To pre-fetch, the system also comprises a parser, a pre-fetch handler, and a storage system to keep the pre-fetched objects (discussed below in greater detail).","In operation, the browser requests an object. The object is sent back through the server to the client. If the object is a description of a Webpage e.g. HTML the client parses it for the agent and determines that the Web page has certain components in it. In the preferred embodiment, the parser determines if there are any JavaScripts or Style Sheets, for example, in the Web page. If there are, rather than waiting for those objects to be requested by the user's browser, those objects are obtained from the Web server by the agent. Thus, when a Web page comes back to the user, the Web page goes back to the browser, and concurrently the page does not pause while the JavaScript is fetched.","The Web page is a description object. It specifies component objects. Main page is always the first object that comes back, and it describes what is needed to render a page. Most of the time, the browser fetches JavaScript and Style Sheet objects one at a time. Every time such an object is fetched, the user must wait for a time delay. The inventors have observed that the browser does not do the same thing for the other type of objects, such as GIFs, JPEGs, or FLASH. The typical browser fetches other types of objects in parallel, at least to a certain degree, and somehow only fetches certain types of objects one at a time.","The browser parses the page description, and while the page description is operated upon by the browser, the parsing element is also parsing the page description to identify JavaScripts and Style Sheets. These particular objects are of a type that are normally sequentially fetched. The pre-fetch mechanism is used concurrently with the browser to go to the original Web server to fetch these objects while the browser is still loading the page. The system fetches these objects and brings them over to the cache, so that these objects are now resident at the cache. As a result, rather than have to go out across the system with its concomitant latency, to get these objects to complete the building of the Web page sequentially, it is only necessary access the client locally to complete loading the Web page. This speeds the system up considerably. Thus, the invention uses parallelism and selective pre-fetching to give the impression of reduced round trip.","Functional Specification","Problem Definition","In current client architectures, HTML pages are fetched when requested by the browser. In certain situations, the browser requests pages, such as JavaScripts, sequentially. Sequential requests do not maximize VTP as there is no parallelism. To maximize VTP, pre-fetch on the client is required.","Assumptions","Implementation of the invention assumes that the browser performs HTML requests sequentially for certain files, such as JavaScripts.","Requirements","The invention implements a client pre-fetch feature with the following requirements:\n\n","Functionality","The following functional components are required: post HTML processing, client side pre-fetch control, and file cache.","The post HTML processing module is for parsing an HTML page to retrieve a list of URLs to pre-fetch, regardless of their file extension. This list of URLs is fed into the client pre-fetch control module.","The client side pre-fetch control module performs HTTP requests for identified objects.","The file cache handles caching pre-fetch file locally on persistence storage.","Usability","The invention is preferably implemented with a provision for end users to enable or disable file fetch. For this feature, the GUI presents an option to either enable or disable this feature. On a disable, the local cached file, as well as internal pre-fetch record, is cleared.","Design Specification","This discussion provides details of the design for the post HTML processing, client pre-fetch control, and file cache modules.","Overview",{"@attributes":{"id":"p-0051","num":"0054"},"figref":["FIG. 2","FIG. 2"],"b":["11","20","25","20","21","23","22","24","21","23","27","26","18"]},"Module Design","The following discussion describes the module design for each subsystem, i.e. post HTML processing, client pre-fetch control, and file cache. In each of , discussed below, operational flow is indicated by a numeral and an asterisk, e.g. \u201c*.\u201d",{"@attributes":{"id":"p-0054","num":"0057"},"figref":"FIG. 3","b":["1","2","3","4","5","6","7"]},{"@attributes":{"id":"p-0055","num":"0058"},"figref":"FIG. 4","b":["1","2","3","4","5","6"]},{"@attributes":{"id":"p-0056","num":"0059"},"figref":"FIG. 5","b":["1","2","3","4","5","6","7","8"]},"Post HTML Processing Module Design","The post HTML processing module produces a list of URLs to pre-fetch. Each URL is fed into the client pre-fetch control module.","Client Prefetch Control Module Design","The client prefetch control module contains the decision logic to determine whether and when to fetch a page. Pre-Fetch URL is stored in a index linked list structure. Once it determines that an URL should be pre-fetched, it establishes a bypass connection to the local cache module. The cache address and port number is determined by querying the local cache module. When the connection is established and it receives data from the local cache, the connection is closed immediately. Therefore, the local cache must be configured to continue with the download even when the connection is closed.","VTP (UDP) Transport Design","Overview of Operation","The following discussion describes the design of a UDP based VTP protocol of the type that may be used in connection with the practice of a preferred embodiment of the invention.","This protocol provides sequenced, reliable delivery of data as with TCP. It however employs a different rate control mechanism that better suite for environments with high bandwidth variation and packet loss rate. In addition this protocol also supports multiplexing several transport flows over a single flow controlled channel between two hosts. One of the main goals of this protocol is to perform better in those areas that TCP does not: high bandwidth, high delay, and\/or high packet drops. Some of the drawbacks of TCP over wireless include its small initial send window, large maximum send window size, and very aggressive congestion control mechanisms.","This protocol provides reliable delivery of data as provided by TCP. It however employs a different rate control mechanism that is better suited for environments with high bandwidth variation and packet loss rate. In addition, this protocol also supports multiplexing multiple application data flows over a single channel between two hosts. This allows a greatly increased number of application conversation between two hosts without the side effect of reduced flow-control effectiveness experienced when employing a high number of TCP connections between them.","Connection Establishment","UDP is connectionless, datagram oriented protocol. In VTP, a logical connection must be established between the client and server for one or more of the following reasons:\n\n","VTP connections between two hosts are setup before to any application level flow is setup. Once the VTP connection is established, an individual application conversation between two VTP-connected hosts requires no three-way hand-shaking. A VTP end-point redirecting mechanism allows TCP flows being redirected into this VTP tunnel without experience long setup delay.","VTP connection setup includes authentication and sequence number exchange to guarantee delivery of control packets and data packets from individual application flows (TCP flows).","A new connection is opened if there was no prior connection with the server. A connection open request is initiated from the client by sending a REQ_CONN (request connection) packet to the server. A connection request identifier is sent in every REQ_CONN packet to match REQ_CONN and REQ_ACK packets. The client should start a timer after it sends this packet. If the REQ_CONN timer goes off, send another REQ_CONN packet with a different connection request identifier. If no response is received from other side after sending some n (configurable parameter) number of REQ_CONN packets, the client gives up and reports \u201ccannot establish connection\u201d to the caller. After the client sends the REQ_CONN packet, it changes the status of that connection from closed (VTP_CLOSED) to \u201cconnection in progress\u201d (VTP_REQ_CONN) state.","The server opens a socket and binds to some well known port for listening to client connect requests. Whenever the server gets a REQ_CONN packet, it should allocate a new real connection node and reply to REQ_CONN packet by sending REQ_CONN+ACK packet. At this point, the server moves that connection into \u201cconnection established\u201d (VTP_EST) state. Once the client gets the REQ_CONN+ACK packet, it can move its real connection node into \u201cconnection established\u201d state.","The client acknowledges the server's REQ_CONN+ACK packet with an ACK packet. Note that the client can deduce its round trip time to the server from REQ_CONN and REQ_CONN+ACK packets and the server can deduce round trip time between itself and this client from REQ_CONN+ACK and ACK packet from the client. Each end should get an RTT estimate as often as necessary to know the network.","If the real connection is opened successfully, data can be sent on a virtual connection by calling ta_send( ).","Data Flow and Explicit Rate Flow Control","One of the goals of any transport layer is to send data efficiently and to get the maximum throughput possible from the network. Once a connection is established, any of the intermediate routers between the sender and receiver might go down or some more new connections might be established that use one or more of links in the path. The sender should never send any data that leads to congestion in the network. The amount of data that the sender can send without getting any feedback from the receiver is called the \u201csend window\u201d and it is calculated as:\n\nSend_Window=(const1*bandwidth*delay)+(const2)\n\nwhere:\n\n","The throughput of a connection is limited by the amount of data the network can carry and the amount of buffer space the receiver has to store this data before it passes it up to the application layer. In the invention, receiver buffers are not regarded as a constraint. Because the network is the bottleneck now, the sender should never send any more data than the network can accept, taking into account buffers in intermediate routers and in the sending host. For example, a sender and receiver with 1 Mbps link are interconnected by a 128 kbps link. The throughput is now constrained by the 128 kbps (16 KBytes\/s) link. If the sender has, e.g. 2 MB of data to send, it should not burst out all of these data quickly because they can get dropped at the intermediate router. To be exact, the sender should not send any more than \u02dc16 KB in one second. This makes it clear that if the sender has knowledge of bandwidth of the bottleneck link in the path from itself to the receiver, it can regulate its sending rate so that no packets are dropped in between.","To continue the example in above paragraph, say the send window is 30 KB. Because all the data are there to send, a complete send window worth of bytes can be sent at a time. This generates a burst of packets at the next router and, if there is no buffer space to hold these packets, they just end up getting dropped. To avoid this, because the sender knows the bandwidth it can send those bytes in a controlled way. This is the flow control aspect of transport. As long as the bandwidth available to this connection remains the same, the chances of dropping a packet are less. The send window is necessary to avoid network congestion and flow control is necessary to avoid bursts.","Once the sender sends its window's worth of bytes, it closes its window and it should wait for feedback from the receiver. Ideally, if the sender has data to send it should never stop sending it until all the data reaches other end i.e. the sender should never close its send window. The sender should open its send window again when it gets feedback from the receiver saying it got some or all of the data the sender has sent. Note that the sender should not free the data in its send window until it is positively acknowledged by the receiver. To keep the send window always open and have room for more data, the receiver should send its feedback as frequently as necessary.","It is clear that the knowledge of bandwidth and trip time for the transport to work efficiently. The following sections describe how VTP gets the bottleneck bandwidth and trip time.","Round Trip Time","Round trip time (RTT) is the time taken for a packet to reach the other end and to come back. This time includes queuing, transmission delays at the sender, queuing and processing delays at intermediate routers, and processing delay at the final host. Trip time (TT) is the time a packet takes from the sender to the receiver. VTP uses the following equation to deduce RTT:\n\nRTT=(time from last packet sent to received)\u2212(delay at receiver)\u2212(size of(pkt)\/bandwidth)\n","RTT is measured only when the sender releases one or more packets in response to a SACK, i.e. positively ACKed. It is not measured when SACK says the receiver did not receive anything because the second term in the equation needs a data packet.","The following example shows RTT computation:",{"@attributes":{"id":"p-0084","num":"0095"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"receiver","sender"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"t4---> 1","send 1 2 <---time t1"]},{"entry":[{},"t5---> 3","send 3 4 <---time t2"]},{"entry":[{},"t6---> 6","send 5 6 <---time t3"]},{"entry":[{},"t7---> SACK says receiver got 1, 3, 6.","SACK arrives <-- time t8"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"RTT@sender = (t8 \u2212 3) \u2212 (t7 \u2212 t6) \u2212 (sizeof(pkt 6)\/bandwidth)."]}]}}}}},"RTT is used in computing the send window and is also used in estimating the retransmission timeout (explained later). The client transport, which initiated the connection (real), can get RTT at connection setup with REQ_CONN and REQ_CONN+ACK packets. The server can deduce its RTT to the client if it gets the client's ACK packet. If the client's ACK packet is dropped, the server has to derive RTT using above equation from the first SACK from the receiver. This requires the sender to time stamp each packet sent. The SACK packet should carry time difference from its last data packet to this SACK.","Send Window Close Timeout (WTO)","As mentioned earlier, the sender should stop after sending the last data packet that it got from the application layer or after it sends a full window's worth of bytes. It is up to the sender to guarantee that each and every byte sent by the application layer is delivered to the receiver in sequence and without any error. The receiver sends feedback about the packets it received and packets that are not. If the feedback about received packets is dropped, the sender should have some way to know about the packets received at the receiver. To ensure that the receiver is getting the packets it is sending, after sending the last packet it should start a timer that expires in some time. This timeout is called last packet ACK timeout (LTO). If the sender does not get any feedback within LTO time, it sends a \u201crequesting sack\u201d packet to make the receiver send a feedback (when to send feedback is explained in SACK). The LTO timer should be set such that it does not expire too early or too late. It should not expire too early for two reasons: Feedback may already be on the way to the sender; Too early timeouts cause too many retransmits. It should not expire too late for the reason that the pipe is not carrying any packets from this connection anymore. The LTO equation is given below:\n\n5*(RTT+bytes_sent\/bandwidth)\n\nwhere:\n\n","When the sender has sent a full send window's worth of bytes, it has to stop sending any new packets. The transport layer should make sure that this never happens when it has more data to send in virtual connection queues. The fact that the send window is closed and the sender is not sending any packets implies that the sender is not using the pipe to its fullest. The SACKs, acknowledging the packets received enable the sender to release ACKed bytes from its send window, thereby providing room for new bytes to be sent.","The sender starts \u201csend window close timer\u201d whenever it has to stop after sending full send window. The send window close timer (WTO) is given as:\n\n2Const*RTT\n\nwhere:\n\n","When WTO expires, the sender should send a new packet called SEND_SACK requesting the receiver to send its SACK. The sender tries sending these SEND_SACK packets up to some configured number of times (M). If it does not get any feedback after the last SEND_SACK packet, the sender should close all the virtual connections on that real connection, discard any packets in real connection out bound queue, and release the real connection.","If the network does not drop any packet, there might never be a timeout on the WTO timer.","Bandwidth","Bandwidth of a path is the time it takes to transmit some number of bytes from the sender to the receiver. This time includes transmission time of the device plus propagation time of the link(s) in between. A link is the medium, wire or wireless, between two hosts. VTP measures the bandwidth of the path by sending two packets, one after another, with no time difference at the sender. Depending on the bandwidth of the links they traverse, they both arrive with some time difference at the receiver. The arrival time is the time when the receiver gets the packet(s) out of UDP socket buffers via recvfrom( ) system call. Note that on high speed links, e.g. 4 Mbps, two or more packets can arrive with zero time difference. The following shows how one can get the bandwidth by sending two packets of size 1 KB each on a 4 KB\/s link.","c11 is packet 1 from connection 1, c12 is packet 2 from connection 1 and c21 is packet from connection 2.\n\nbandwidth=(12arrivaltime\u221211arrival time)\/12 packet size\n","Ignoring propagation delays, it takes 0.25 seconds for a 1 KB packet to traverse a 4 KB\/s link.",{"@attributes":{"id":"p-0096","num":"0114"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"91pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["CASE1:",{},{},{}]},{"entry":[{},"---------"]},{"entry":["sender","\u2003\u2002|c12|c11|","receiver","bw = (0.5 \u2212 0.25)\/1 KB = 4"]},{"entry":[{},"---------"]},{"entry":"CASE2:"},{"entry":[{},"---------"]},{"entry":["sender","|c21|c12|c11|","receiver","bw = (0.5 \u2212 0.25)\/1 KB = 4"]},{"entry":[{},"---------"]},{"entry":"CASE3:"},{"entry":[{},"---------"]},{"entry":["sender","|c12|c21|c11|","receiver","bw = (0.75 \u2212 0.25)\/1 KB = 2"]},{"entry":[{},"---------"]},{"entry":"CASE4:"},{"entry":[{},"------------"]},{"entry":["sender","|c12|c22|c21|c11|","receiver","bw = (1 \u2212 0.25)\/1 KB = 1.33"]},{"entry":[{},"------------"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"In CASE1, connection1 is the only connection using the link, so it gets complete bandwidth, and that is what the transport sees. In CASES 2, 3, and 4, a new connection c2 is also using the same link. At this time, ideally, receiving transport for connection1 should detect a bandwidth of 2 KB\/s. But, as shown above, this can fluctuate anywhere from 1.33 KB\/s to 4 KB\/s depending upon how the packets of connection 1 gets spaced. VTP arrives closely at 2 KB\/s by averaging the bandwidth continuously. The receiving transport should intimate its current receive rate via SACK.","If the time difference between two packets in sequence is zero, VTP measures that as default maximum bandwidth.","Selective Acknowledgment (SACK)","SACK is the feedback from the receiver. A receiver should send feedback about the data it received as frequently as it can for several reasons:\n\n","A SACK should be sent only when necessary.","Processing ACKnowledgement","The receiver sends an acknowledgement in the following cases:\n\n","The first three ACKs contain information about lost\/received data packets; the last two could be sent even if no new data packets are received by the receiver. Upon receiving an ACK that has lost\/received information, the sender should immediately free up the VBufs that are ACKed. If the incoming ACK positively acknowledges everything in out_queue, i.e. sent-but-unacked, and if sender had something to send, it should clear the \u2018next transmit timer\u2019 and send the new data because the pipe is clearly empty.","(Re)Transmission Policy","The sender can send a new packet if it fits in the current send window. Otherwise, the sender should leave the packet in the virtual connection's out bound queue and transmit them when send window is opened by the next SACK. Whenever the sender transmits a new packet, it should start a fresh timer that should expire at LTO time. LTO time includes the transmit time plus trip time. When this timer expires, the sender sends a REQUEST_SACK packet and restarts the timer. If the sender does not get any reply from the receiver after sending N (configurable) number of REQUEST_SACK packets, the sender must close the connection with the receiver. The sender should never retransmit until it thinks the packet it sent should be out of network based on current bandwidth and latency. If a retransmit request is received within this flight time, the sender ignores the retransmit request.","The sender should never send its full send window worth of bytes at once. This might lead to a burst of packets at the next or intermediate router and may cause packet drops if there are insufficient buffers. To avoid this, the sender must always control the flow of packets by time, spacing them according to the bandwidth and delay of the path.","Connection Termination","The application layer may terminate a virtual connection at any time. The transport layer should send a connection close packet with the type of close, i.e. abort or graceful close. transport layer should drop any packets going from this virtual connection towards other end and send a new packet (just the header is sufficient) of type TP_ABORT if the application is aborting its connection. Otherwise, it should send all the packets and then close the VC. In the latter case, it sets the TP_CLOSE bit in the last outgoing packet of VC to convey that VC at this is closed. Once a virtual connection is closed, no data are sent or received on that connection. The receiving transport layer informs the application layer that the other side has requested connection closure. Note that the real connection is never closed. A real connection is closed only when one end of the connection dies.","Checksum Computation","The transport should guarantee that data are delivered to the other end without any errors. To detect bit errors in transmission, a checksum is computed over the entire packet before delivering the datagram to the receiver. The receiver should recompute the checksum for the packet arrived and compare it the checksum in the packet. If the checksum differs, consider that as a corrupted packet and discard it. The checksum field in the header must be taken as zero before computing the checksum. To compute the checksum, divide all the data into 16-bit quantities and compute the one's complement of their one's complement sum. This is similar to checksum computation in the Internet.","Authentication","Authenticity of the client and\/or server can be verified by authentication module once the real connection is established at the transport layer, but before any data are transmitted between each end. Note that a real connection may not be established depending upon authentication parameters. For example, a real connection is denied at transport level if the server desires to authenticate a client but the client has authentication disabled or client cannot support authentication.","Security","Security is provided in the transport to avoid any malicious hacker sending a packet that looks like a packet that is sent by the system. One way one could disrupt the real connection is by sending a bogus packet that is in sequence with an authentic packet sent by the client\/server. The goal of the security in VTP is not to leave any holes for such man in the middle attacks. To avoid this, each end sends a pseudo-random sequence number (PRSN) that can be decoded only by the peer entities involved.","A client can enable security at the transport level from UI. If the transport is not configured to be secure, it uses serial sequence numbers for data transmission and the ACK process.","Although the invention is described herein with reference to the preferred embodiment, one skilled in the art will readily appreciate that other applications may be substituted for those set forth herein without departing from the spirit and scope of the present invention. For example, the pre-fetch mechanism could perform a selective pre-fetch of any selected objects, not just those that are sequentially loaded. The pre-fetch mechanism could apply various heuristics, rules, or adaptive behavior to determine which objects are to be pre-fetched selectively. Further, Web pages could include metatags that are interpreted by the pre-fetch mechanism and that determine which objects are to be selectively pre-fetched.","Accordingly, the invention should only be limited by the Claims included below."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
