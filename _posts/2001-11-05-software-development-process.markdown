---
title: Software development process
abstract: A flexible component-based software system is developed by generating a UML model () in a specification phase (). Components are generated in an implementation phase (). The UML model () is transformed to a meta model. A runtime architecture service (RAS, ) dynamically assembles a system in runtime according to the meta model. A modelling tool () modifies the meta model via an API () and a meta modeller (). This allows dynamic re-configuration of the system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07000219&OS=07000219&RS=07000219
owner: Wilde Technologies Limited
number: 07000219
owner_city: Dublin
owner_country: IE
publication_date: 20011105
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","PRIOR ART DISCUSSION","OBJECTIVES OF THE INVENTION","SUMMARY OF THE INVENTION","DESCRIPTION OF THE EMBODIMENTS"],"p":["The invention relates to a process for development of a flexible component-based software system, and to a system developed by such a process.","A software system is generally regarded as \u201cflexible\u201d if it can undergo modification with relative ease in order to accommodate new requirements. This change may be effected via a restructuring of the interactions of its functional elements and\/or the replacement of existing elements with alternates or via the addition or removal of elements.","Flexibility is of benefit in a system which is required to operate in an environment which undergoes change. Not all systems are required to be flexible. However, in general, flexibility and the reduction of the cost of providing flexibility are often considered to be of benefit.","The principal difficulty in delivering flexible software has long been known: strong couplings or bindings between code modules act to limit their viable independent usage, and lock the modules together in ways that are difficult to manipulate. Object oriented technologies are based on strong couplings between objects based on the references. That these references are created and destroyed empirically, within functional code, in an intermingled fashion, further hardens the linkage. This is exacerbated by the fact that it is a compile-time linkage. This leads to high costs when restructuring interactions between tightly coupled modules. Reuse and perhaps more importantly, changing a system's behaviour is not possible without inspection and modification of code, an expensive process.","PCT Patent Specification No. WO00\/14629 describes a method for generating a system, in which a meta model is initially developed. This is transformed into an application model, which is in turn transformed to code. Code for client\/server interfaces is also generated. The structure of the meta model reflects that of the end-product system and it is used as a starting point, providing structure for the overall production process.","Attempts have been made to improve flexibility in software. An example is a message-based technologies in which systems are constructed as anonymous peers which exchange messages via an intermediary. Another approach is to use a naming service which allows services to be named abstractly. However, these approaches provide limited flexibility because the components have a flat peer-to-peer structure which it is difficult to implement realistic system architectures.","Another approach has been the development of Service Oriented Architecture (SOA). SOA models provide a component-oriented paradigm which views enterprise level software components as providers and consumers of business services. This is an example of component technology. However, the extent of flexibility is limited because this technology does not allow modification of interactions between components, without re-engineering at the code level.","The invention is described towards providing a development process which produces a software system having improved flexibility.","According to the invention, there is provided a process for development of a software system, the process comprising the steps of defining a meta model and using the metal model to generate executable code, characterised in that,\n\n","In one embodiment, the meta model is generated from a design model arising from a specification phase, the design model specifying the system in terms of components and their interactions.","In another embodiment, the design model is represented as a markup language file.","In a further embodiment, the meta model is saved to storage by transforming it back to an associated design model in said markup language.","In one embodiment, the design model models the system declaratively as a graph of instances of component types and allowed interactions between them.","In another embodiment, the design model models a component type as an abstraction that specifies interfaces supported by a component and interfaces that a component requires.","In a further embodiment, a component type is specified as a specialisation of another component type.","In one embodiment, a component type specifies how a plurality of component types may be aggregated to form a composite component type, and in which the composite component type is modelled as a template.","In another embodiment, channels between component instances are templated such that they can be bound to specific interface types on subsequent reuse of the templated component type.","In a further embodiment, the meta model is generated by parsing the design model to generate a hierarchical graph of connected objects.","In one embodiment, the parsing generates a token stream arising from lexical analysis, the token stream representing markup language elements and attributes.","In another embodiment, the token stream is parsed in a plurality of passes comprising:\n\n","In one embodiment, the stereotypes include:\n\n","In one embodiment, the meta model comprises:\n\n","In one embodiment, the type model specifies component types in terms of interfaces and in terms of services implemented by components, and in which the interfaces are those supported by a component and those of services that component requires.","In another embodiment, the invention comprises the further step of maintaining the meta model and dynamically modifying the system by modifying the meta model, and re-instantiating the components according to the modified meta model.","In one embodiment, the meta model is modified by a modelling tool and an API, the tool having a model view pattern on the meta model.","In another embodiment, the dynamic modification of the meta model comprises dynamically changing the number and identity of component instances, component types, and their interactions.","In one embodiment, the meta model is dynamically modified by generating a fresh or modified design model, transforming the design model to a meta model, and re-assembling the system according to the new meta model.","In another embodiment, the meta model automatically performs self type-checking before assembly of the system.","In one embodiment, the system assembly is performed by a technology-independent activation manager and at least one technology-specific activator, in which the activation manager directs at least one activator to:\n\n","In one embodiment, the activation manager is an object which presents public methods for instantiating components, for binding components, and for unbinding components, and in which the activation manager instantiates technology-specific components by:\n\n","According to another aspect, the invention provides a process for development of a software system, the process comprising the steps of defining a meta model and using the metal model to generate executable code, characterised in that,\n\n","According to a still further aspect, the invention provides a software system comprising components having executable code, characterised in that the system further comprises:\n\n","In one embodiment, the system further comprises a modelling tool comprising means for interacting with the meta modeller to modify the meta model, and the activation sub-system comprises means for re-instantiating the components for dynamic modification of the system.","In another embodiment, the meta modeller comprises means for maintaining the meta model with:\n\n","In one embodiment, the activation sub-system comprises a technology-independent activation manager and at least one technology-specific activator, in which the activation manager comprises mean for directing at least one activator to:\n\n",{"@attributes":{"id":"p-0045","num":"0075"},"figref":"FIG. 1","b":["1","2","3","4","5","6","7","2","5"]},{"@attributes":{"id":"p-0046","num":"0076"},"figref":"FIG. 2","b":["3","8","4","3","10","9","10","5","3","3"]},"Referring to , the RAS  loads and saves UML models  as XMI files. As stated above, the RAS  generates a meta model from each UML model . Each meta model is a hierarchical structure, and may be edited\/manipulated by a UML tool  via an API. This is performed in a user-friendly manner as the tool  provides a view on the meta model, and provides methods for opening, closing, and type correct manipulation. When the RAS  saves a meta model it takes the form of the corresponding UML model  in an XMI file. The meta model may thus be regarded as an object representation of the UML model .","During execution of a system, the RAS  maintains the meta-model associated with the executing system. During this phase, the meta model remains accessible to the UML tool. Changes made to the meta model have immediate effect on the executing system by addition, removal and\/or replacement of components, and changes to the structure of the bindings between instances according to changes to the meta model.","In the following, the invention is described in more detail.","UML Model ","In the requirements and specification phases  and  the system design is modelled. In the preferred embodiment, this model comprises a series of UML diagrams. The model is developed by the UML tool  and recorded in a file in an XMI\/XML form. A number of different UML model diagrams are used to record different aspects of the desired system. The UML model  primarily comprises UML class diagrams and object instance diagrams. Class diagrams define component types in terms of interfaces a particular component provides, and interfaces a component uses (as illustrated in ). The former details services implemented by the component. The latter details services not implemented by the component, but required for its correct execution. A component type is modelled abstractly, and independent of any particular implementation. An interface is modelled in UML as a set of parameterized methods and attributes. Interfaces and component types are both modelled as stereotyped classifiers in the preferred embodiment. The concepts can be modelled in a declarative textual language in an alternative embodiment.","Component types can be defined as a specialisation of other component types, with object-oriented inheritance rules applying. A child component type is defined by the declaration of provided and required interfaces of the parent or parents in addition to those defined in the child component type itself. Interfaces can be defined as a specialisation of other interfaces with object-oriented rules applying.","What results from the UML Class diagrams is a model of the types of components and how these depend on a set of interfaces. These type descriptions are used in a further set of UML Object Instance diagrams that describe how component objects which realise these types are to be connected to each other in the running system on each other, as illustrated in ).","A component represents one or more than one (if annotated with cardinality other than one) instance of a component at runtime. This modelling does not imply a particular realisation of the component object by a particular implementation. Unless further annotated, a component is understood to represent an instance of any implementation that realises its type. This annotation is a necessary part of completing the modelling necessary in the invention and is described below. Note also that more than one component instance can be typed with the same component type, and that this implies nothing more than type equivalence between possible realisations of these component objects. The connections allowed between instances on an object instance diagram are constrained to typed interfaces that match a service provision by one component to a service requirement by the other component. This connection can be associated with a single interface, a subset of all allowed interfaces, or all allowed interfaces.","The component type is also used in the modelling of \u201cComplex Component Type,\u201d which is a model of how a set of instances of component types can be bound together to behave as a single component (). Such a complex component will behave as if it were a single component. The Complex component type modelling describes the required and provided interfaces of the type, the types of sub-components that will go to make up the aggregate, and a modelling of how the interface requirements and provisions of these sub-components map to the requirements and provisions of the composite whole. The purpose of this is to support the modelling of a typed subsystem as an assembly of other subsystems. As shown in , any component object's type may itself be modelled as a complex component type, and so on, so that what results is a hierarchical graph of relationships between typed object instances, terminating at the leaf nodes of this hierarchy with component objects typed by immutable, simple component types that describe service provision and requirement only. An equivalent extended object instance modelling (see ) is necessary to detail the aggregate.","Aspects of a component type may in addition be modelled as templated features. In a complex component type, specific types may be bound to the component type's graph on subsequent reuse of the templated component type. This allows component objects to be specified initially as untyped. The identity of component objects may be likewise templated and subsequently bound on specialisation, so that a particular instance in a child component type can be associated with the templated instance in the parent. Required and provided services associated with a component type may be likewise templated, and bound subsequently on reuse of the type.","The UML model  is used to model a component architecture that is abstract, and independent of any particular implementation of the component objects specified in the model. This model is augmented with further modelling (typically packaged as a separate set of diagrams) that associate component instances in the UML model  with component implementations, developed in phase . Any type-compatible complex component type can be likewise associated, in which case the complex component type is treated as a component implementation and is instantiated at runtime. A component implementation may be associated with more than one component instance in a single component type. A component instance marked as a set may also be associated with a plurality of component implementations.","Components implemented in phase  are implemented with an interface-based component technology, which is capable of implementing a type that is compatible with the component type of a component instance, in terms of provided and required services. The component technology must provide the runtime system with configuration capability with respect to the identity of providers of service requirements. In one embodiment, Microsoft's COM\u2122 technology is provided as an example of a technology that employs a connection point model, supported by COM interface definition language, which provides the necessary capability. An embodiment based on .Net is also described in detail in the discussion of runtime support.","Runtime Architecture Service ",{"@attributes":{"id":"p-0058","num":"0088"},"figref":"FIG. 7","b":["10","30","31","32","33","34"]},"XMI Adapter ","The XMI adapter  creates a hierarchy of objects from an XMI file, and allows modifications, and the generation of an XMI file. This object set forms a hierarchical graph of connected objects, called the meta model. The XMI objects irrelevant to the execution of the software system are retained and saved back to the file. The meta model is maintained by the meta modeller , which allows it to be subsequently modified via the API  as described below.",{"@attributes":{"id":"p-0060","num":"0090"},"figref":"FIG. 8","b":["30","30","30"],"ul":{"@attributes":{"id":"ul0021","list-style":"none"},"li":{"@attributes":{"id":"ul0021-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0022","list-style":"none"},"li":["Attributes. The parser maps these to member variables.","Associations. Multiplicity of \u201csingle\u201d generates a pointer to another object, \u201cmany\u201d generates an array of pointers.","Compositions. Multiplicity of \u201csingle\u201d generates a pointer to another object, \u201cmany\u201d generates an array of pointers.","A pointer back to a document object model (DOM). The principal types of the DOM are shown in . The DOM is generated initially from the XMI file and is used as the basis for further development of the meta model.\n\nParsing\n"]}}}},"Parsing of a UML model begins with lexical analysis, which generates a token stream. The token stream is then processed by the parser language, implemented as a hierarchy of XMIObject child classes. A component of the Adapter called a tokenizer operates on the DOM tree that is created by processing an XMI file. The tokens are defined by the class XMLToken. The XMLTokenizer class is iterated using the XMLTokenIt class.","In order to build a graph of UML meta-model objects, the parsing of the token stream is performed in four passes as described below. The description refers to the following XMI model:",{"@attributes":{"id":"p-0063","num":"0097"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"<UML:Model xmi.id = \u2018G.0\u2019 >"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<UML:Namespace.ownedElement>"]},{"entry":[{},"<UML:Interface xmi.id = \u2018S.1\u2019 name = \u2018Foobar\u2019 >"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<UML:ModelElement.supplierDependency>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<UML:Abstraction xmi.idref = \u2018G.3\u2019 \/>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/UML:ModelElement.supplierDependency>"]},{"entry":[{},"<UML:Namespace.ownedElement>"]},{"entry":[{},"<UML:Generalization xmi.id = \u2018S.10\u2019 child = \u2018S.1\u2019"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"parent = \u2018S.2\u2019 >"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<UML:ModelElement.isSpecification>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"true"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<\/UML:ModelElement.isSpecification>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/UML:Generalization>"]},{"entry":[{},"<\/UML:Namespace.ownedElement>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<\/UML:Interface>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<\/UML:Namespace.ownedElement>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<\/UML:Model>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0064","num":"0098"},"figref":["FIG. 9","FIG. 10","FIG. 10"]},{"@attributes":{"id":"p-0065","num":"0099"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["{","{ XMLELEMSTART, \u201cUML:Model\u201d, NULL, 0x???? },"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ XMLATTR, \u201cxmi.id\u201d, \u201cG. 0\u201d, 0x???? },"]},{"entry":[{},"{ XMLELEMSTART, \u201cUML:Namespace.ownedElement\u201d, NULL, 0x???? },"]},{"entry":[{},"{ XMLELEMSTART, \u201cUML:Interface\u201d, NULL, 0x???? },"]},{"entry":[{},"{ XMLATTR, \u201cxmi.id\u201d, \u201cS.1\u201d, 0x???? },"]},{"entry":[{},"{ XMLATTR, \u201cname\u201d, \u201cFoobar\u201d, NULL, 0x???? },"]},{"entry":[{},"{ XMLELEMSTART, \u201cUML:ModelElement.supplierDependency\u201d, NULL, 0x????"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"},"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ XMLELEMSTART, \u201cUML:Abstraction\u201d, NULL, 0x???? },"]},{"entry":[{},"{ XMLATTR, \u201cxmi.idref\u201d, \u201cG.3\u201d, 0x???? },"]},{"entry":[{},"{ XMLELEMEND, \u201cUML:Abstraction\u201d, NULL, 0x???? },"]},{"entry":[{},"{ XMLELEMEND, \u201cUML:ModelElement.supplierDependency\u201d, NULL, 0x????"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"},"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ XMLELEMSTART, \u201cUML:Namespace.ownedElement\u201d, NULL, 0x???? },"]},{"entry":[{},"{ XMLELEMSTART, \u201cUML:Generalization\u201d, NULL, 0x???? },"]},{"entry":[{},"{ XMLATTR, \u201cxmi.id\u201d, \u201cS.10\u201d, 0x???? },"]},{"entry":[{},"{ XMLATTR, \u201cchild\u201d, \u201cS.1\u201d, 0x???? },"]},{"entry":[{},"{ XMLATTR, \u201cparent\u201d, \u201cS.2\u201d, 0x???? },"]},{"entry":[{},"{ XMLELEMSTART, \u201cUML:ModelElement.isSpecification\u201d, NULL, 0x???? },"]},{"entry":[{},"{ XMLVALUE, NULL, \u201ctrue\u201d, 0x???? },"]},{"entry":[{},"{ XMLELEMEND, \u201cUML:ModelElement.isSpecification\u201d, NULL, 0x???? },"]},{"entry":[{},"{ XMLELEMEND, \u201cUML:Generalization\u201d, NULL, 0x???? },"]},{"entry":[{},"{ XMLELEMEND, \u201cUML:Namespace.ownedElement\u201d, NULL, 0x???? },"]},{"entry":[{},"{ XMLELEMEND, \u201cUML:Interface\u201d, NULL, 0x???? }"]},{"entry":[{},"{ XMLELEMEND, \u201cUML:Namespace.ownedElement\u201d, NULL, 0x???? },"]},{"entry":[{},"{ XMLELEMEND, \u201cUML:Model\u201d, NULL, 0x???? }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"Pass 1 does syntactic parsing of the token system to create the meta model objects. XMI stores a UML model in a hierarchical form, and the parser language is also hierarchical. The objective of this language is for each level to define valid attributes, associations, and compositions. Compositions are nested elements and define the next level in the hierarchy. A parser language class inherits from XMIObject and implements the ProcessXMI( ) function. The ProcessXMI( ) function uses a number of Exchange functions to determine what elements will be parsed and generated at this level. The pseudo-code below illustrates how the parse process works, in which \u201cProcessXMI\u201d is a method called to start processing or saving, and \u201cExchangeComposite\u201d is a method to create composite objects.",{"@attributes":{"id":"p-0067","num":"0101"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Main()"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"domTree = DomThatSucker()"]},{"entry":[{},"rootObject = new Root"]},{"entry":[{},"xmiContext = new XMIContext(domTree)"]},{"entry":[{},"while not xmiContext.tokenIt.AtEnd()"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"rootObject\u2212>ProcessXMI (xmiContext)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"Root::ProcessXMI(XMIContext ctx)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ExchangeComposite (ctx, \u201cUML:Model\u201d, single, mmodel,"]},{"entry":[{},"typeid(Model), \u201cUNL:Root\u201d)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"Model::ProcessXMI (XMIContext ctx)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ExchangeComposite (ctx, \u201cUML:Namespace.ownedElement\u201d,"]},{"entry":[{},"\u201cUML: Interface\u201d, multiple,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"mclass, typeid(Class), \u201cUML:Model\u201d)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"Interface::ProcessXMI (XMIContext ctx)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ExchangeAttribute (ctx, \u201cname\u201d, \u201cUML:ModelElement.name\u201d, mname)"]},{"entry":[{},"ExchangeAssociation (ctx, \u201csupplierDependency\u201d,"]},{"entry":[{},"\u201cUML:ModelElement.supplierDependency\u201d,"]},{"entry":[{},"single, msupplierDependency, typeid(Abstraction),"]},{"entry":[{},"\u201cUML:Dependency.supplier\u201d)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"Pass 2 creates the links between objects based on the defined associations. Associations are XMI references that are resolved to the actual objects. All associations in the meta model are bidirectional and instantiation of the model uses bi-directional links. Both ends of an association are not necessarily provided in XMI so the first end that is encountered ensures that the other end is setup also.","Pass 3","Pass 3 creates refined meta model specific objects. The meta model uses a number of stereotypes to extend the meta-model. In order to be able to represent the meta-model objects the meta model classes are logically inherited from an existing meta-model class and don't add any attributes or associations that need to be stored persistently. Pass 3 iterates the relevant stereotypes and creates the meta model objects. The following stereotypes are relevant:\n\n","Pass 4 performs semantic model validation on meta model objects. The stereotypes imply a certain behaviour that is impossible to enforce in another tool. Pass 4 verifies that the correct behaviour has been modelled. The following parser helper methods are used by the XMIAdapter.","Method: ExchangeAttribute","This function maps an XMI attribute to a variable.\n\n","This function maps an XMI association to a variable.\n\n","This function creates composite objects.\n\n","The meta-model maintains an object-oriented representation of the UML model. All semantic checking and execution is driven by this meta-model and it maintains a live monitoring role for the executing system. The meta-model consists of a set of discrete model sets described below.","Type Model",{"@attributes":{"id":"p-0075","num":"0117"},"figref":"FIG. 11"},"An instance of the type model cannot be executed: This is because of two limitations:\n\n","A component type provides a specification of certain aspects of the structure of a component. As a type it provides information that is common to its instances. A component type knows about the interfaces it must provide, the interfaces it may use and the interfaces it must use. If a component type has a \u201cpreferred provider\u201d for the interfaces it uses, it records that information. The Interface describes an abstract set of services provided by a component and required by another. A particular interface may be required by many components and provided by many. There is nothing to prevent a component from both requiring and providing the same interface. An interface may have many realisations. This is implemented with the standard UML realisation dependency.","Realisation captures the requirement from a component for an interface. If there is a preferred provider for the interface, RequiresFrom class is used, otherwise the Requires class is used. FreeRequirement is a requires association encapsulates the situation whereby a component type has a requirement for an interface. The ConstrainedRequirement (PreferredProvider) records the fact that the designer forces a component type to get a set of interfaces from another component type. The purpose of this class is to capture the two component types involved and the interface(s) referred to. It is like a 3-way association, but it is implemented as a 2-way association between the two relevant component types. The third part of the relationship (the interface) is captured by the standard UML Interface Specifier part of the association end.","Instance Model",{"@attributes":{"id":"p-0079","num":"0123"},"figref":"FIG. 12"},"InstanceModel is a container with UML ownership relationships with instances and links. ComponentObject encapsulates the run-time behaviour of a component. Every application component that is statically declared is represented by one component instance. A ComponentObject is involved in relationships with other ComponentObject objects. It provides some interfaces to other component instances. It also obtains interfaces from other component instances. A ComponentObject is an instance of exactly one ComponentType. This provides the rules that govern its behaviour, i.e. which interfaces it provides and which it can use and must use. A ComponentObject is (indirectly) an instance of zero or more interfaces. This is because it is an instance of ComponentType, which realises Interface. In practice a component instance cannot have executable interfaces unless it is executable itself, but the design does allow this.","An InterfaceLink is instantiated when a three-way relationship is formed between two component instances and an interface. It is instantiated as a UML link element. The link element must connect two objects, (which are the component types) and must refer to an association (which is the interface requirement object).","Objects and links may optionally be part of a subsystem instance. The instance corresponds to the subsystem that their type information belongs to.","Activation Layer ","The meta-model is technology-neutral, in that it models UML entities that are not tied to particular component technologies such as COM, CORBA, or EJB, allowing technology-specific activation information to be associated with technology neutral component instance modelling. In contrast, the activation layer provides technology-specific modules capable of instantiating and configuring components implemented with specific component technologies. The overall structure of the activation layer is shown in .","The activation layer  comprises an Activation Manager and one or more Activators. The Activation Manager exposes a technology neutral interface that, with the meta-modeler , instantiates a software system and maintains runtime information about executing components. The Activators are used to instantiate and bind together technology-specific components. The components, their interfaces and the bindings between them are represented independently of their native technologies so that design can be manipulated without concern for the technologies involved.","The Activator Manager has four public methods (a) to (d):","(a) getActivatorManager ( ):","Returns a static instance of the Activator Manager. This ensures that the returned Activator Manager is a singleton.","(b) instantiateComponent (CComponent*):","Instantiates the component described in the CComponent argument passed to it. The argument will not actually be a CComponent*, it will be a pointer to a class derived from CComponent. Once the ActivatorManager has instantiated the component, a CInstance pointer held by CComponent will be initialised. The CInstance class represents the instantiated component and is needed for future operations such as binding.","(c) bind (CInstance*, CInstance*, CInterface*):","Used to establish connections\/bindings between components' interfaces. In any binding between components there will be an instantiated component that uses a service and an instantiated component that provides that service. Both \u201cbind\u201d and \u201cunbind\u201d require that the user CInstance* should be passed as the first argument and that the provider CInstance* is passed as the second argument.","unbind (CInstance*,","(d) CInstance*, CInterface*)","Technology-independence is achieved by representing the fundamental building-blocks of component-based design as generic class types passed as parameters in the methods above. The fundamental types are components, interfaces and bindings between components' interfaces. Technology-specific classes inherit from these classes. The parent types include pure virtual methods, which must be implemented by the children, which allow the Activation Manager to interrogate and extract technology specific detail from them. Child classes also implement further methods which are needed in a technology specific context, such as \u201cgetCLSID\u201d for DCOM. A similar relationship exists between CInterface and CDCOMInterface, and CBinding and CDCOMtoDCOMBinding. This is illustrated in .","When instantiateComponent( . . . ) is called, the following process takes place:\n\n","Bindings occur when one component uses the functionality provided on the interface of another component. Bindings are performed between two component instances, and are qualified by an interface, all of which are provided as parameters. Technology specific bindings may require further information in order to manipulate them. These include, in the case of DCOM, a pointer to the ConnectionPoint object on the user-component and a DWORD cookie that is needed in order to destroy a binding.","To bind one component to another, the method bind( . . . ) is used. The user-component's CInstance* should be passed as the first argument and the provider-component's CInstance* as the second argument. Finally the interface that the user-component will use is passed as the third argument.","When CActivatorManager::bind is called the following process takes place:\n\n","The activation layer  allows bindings to be destroyed. This means that one component will no longer use the provided interface of the other component. A binding can be destroyed dynamically by calling unbind( . . . ) and passing in the user instance and the provider instance along with the provided interface in the correct order.","Consider the component-based system shown in . The bindings between components are stored in lists in the CInstance classes for each instantiated component.","The internal Activator process involved in unbinding is as follows.\n\n","In the above example if it were desired to change the binding from Component B to Component A on interface \u201c$\u201d to be from Component B to Component C on interface \u201c$\u201d, the calls shown in  would be made.","A component implementation should not be allowed to die before it has done any necessary cleaning-up. This \u2018cleaning-up\u2019 involves destroying any bindings it holds with other components. To kill a component that has been instantiated by instantiateComponent ( . . . ) the activation layer  component object should be deleted.","The process involved is as follows:\n\n","If the example shown previously were to be shut down in the following order,\n\n","the system would shut down as shown in , , and .","The system has now been shut-down cleanly. The order that the components are killed in does not matter to the Activators, however it may matter to the system itself.","Activators","The detailed actions of the activation layer are, as mentioned above, technology specific. In the preferred embodiment, an activator is included in the activation layer for each supported technology. The activation layer provides generic activation functionality and directs the detailed activation task to the appropriate activator, as determined by the information obtained from the meta-model objects passed to it.","COM Activator","The COM activator assumes components are implemented using a connection point model. This means that each component provides a standard COM interface set that provides access to connection points, which are essentially a list structure capable of storing the typed identity of external components that implement services the component requires. A COM component implementation will have been written to use these connection points when external services are required.","The activator instantiates COM components via the standard CoCreateInstanceEx( . . . ) COM call. Then, once the components are instantiated, they are configured via the component's connection point API, advising it of service providers. The meta-model objects representing connections between component objects provide the necessary information to drive this configuration process. In this way, all component objects and connections represented in the meta-model cause an equivalent runtime instantiation and configuration in the running software system, so that what results is an executing software system accurately represented by the UML model.",".Net Activator","As a contrasting example to COM, the .Net activator operates in a different manner. .Net does not naturally support connection points (there is a connection point equivalent, called events, but this is considered an advanced topic, and so not anticipated to be in widespread use) and so components in .Net are assumed to be written using traditional object-oriented techniques. This implies that external components are imported as .Net assemblies and instances are created and methods of these invoked in an equivalent manner to objects in object-orientation. This presents a more dynamic model in which dependencies between component instances are created in the process of method execution in addition to being statically defined dependencies. The .Net activator thus is required to operate in a very different reactive manner when enforcing connections between components. It intercedes in the loading of external assemblies as and when this occurs as a result of the execution of .Net code. This intercession allows it to manipulate the dependency creation in order that the dependency mandated by the UML model is achieved.","The .Net assembly is the fundamental unit of system composition. An assembly exists as either a single DLL or EXE, or as a set of DLLs and\/or EXEs. Assemblies carry metadata that describes the types provided by the assembly, and the assemblies on which this assembly depends. Other metadata exists also which is not immediately relevant to this discussion.","An advantage that the .Net metadata model provides is to allow information regarding interface provision and requirement to be extracted from compiled code. With the metadata available and disassembly of the code to Intermediate Language (IL) form, a full component type can be inferred.","The execution and binding model described herein relies on the hosting and configuration of the Microsoft Common Language Runtime and on the dynamic rewriting of binding information in Assemblies as they are loaded. It makes use of standard .Net APIs and tools, which will be detailed as necessary below.","To instantiate a .Net component, the appropriate UML model elements detailing the .Net component is passed to the execution layer as before. This Activation Layer delegates the instantiation of the .Net component to the .Net activator, which is a CLR (Microsoft's Common Language Runtime) Host. A CLR host can load and configure the CLR before passing control to it for the execution of a .Net system. Importantly, the hosting program can obtain quite fine grained control of what code is loaded, and what should occur should the CLR be unable to find assemblies\u2014the CLR host program can override standard binding between assemblies.","The .Net execution architecture for this invention comprises a CLR Host that consists of two elements:\n\n","The CLR Host receives two things from the activation layer :\n\n","The .Net activator must perform two tasks:\n\n","The .Net component binding relies on the metadata included in .Net assemblies that details external assembly referencing. To bind an assembly to components mandated by the UML model, this metadata is accessed and if necessary, changed. In addition, the assembly containing the component to be instantiated is disassembled to IL (intermediate language). In conjunction with the UML model for this component and connections between it and other components, the metadata and IL is then manipulated to produce a variant of the original code which is bound to the appropriate assemblies and types as mandated by the UML model. This variant is then assembled and loaded into the CLR. It is important to note that only binding details are changed\u2014the functional code in the assembly remains untouched in every other respect. The CLR performs the actual binding as required during the execution of the .Net system. The diagram below illustrates a sample modification of IL, to change a dependency on System.Console.Writeline( . . . ) to Other.Text.WriteStuff( . . . ).",{"@attributes":{"id":"p-0115","num":"0189"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Original","ExampleModified"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["IL0015: call \u2003void","IL0015: call \u2003void [otherlib]"]},{"entry":["[mscorlib]System.Console::WriteLin","Other.Text::WriteStuff(string)"]},{"entry":"e(string)"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The modified assemblies can be saved for later executions of the system. The execution model thus proceeds as follows:\n\n","The CLR Host must configure the Common Language Runtime in order that the CLR defers to the CLR host when attempting to load assemblies which it cannot find. This is achieved by attaching an event handler to an event supported by the CLR. The following code sample demonstrates this.",{"@attributes":{"id":"p-0118","num":"0198"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"try"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"ResolveEventHandler trl = new ResolveEventHandler"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"(this.assemblyResolveHandler);"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"appDomain.AssemblyResolve += trl;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"catch (Exception exe)"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Console.WriteLine (\u201cException when registering AssemblyLoad event"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Handler\u201d);"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Console.WriteLine (exe.ToString ());"]},{"entry":[{},"throw exe;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"As described above, the RAS  is responsible for executing a system, and performs this task via a maintained meta-model of the UML architecture that is used to instantiate and configure component implementations at boot time. As the software system executes, this meta-model is maintained such that, for example, the API  can be used to stop a system executing, which results in the meta-model causing the system to be shut down in cooperation with the activation layer .","The API  allows specific parts of the meta model to be shut down, with corresponding effect on the component implementations that form the software system. The meta-model in conjunction with the API  and the meta-model API  thus provides a means of manipulating the content and structure of a live system.","The RAS  thus supports dynamic change of the meta-model on a piecemeal basis and thus of the executing system, by direct manipulation of the meta-model. In addition, the RAS supports the transformation of a UML model  from one form to another, wherein that transformed form includes a series of one or more differences in terms of the number, type, identity, and\/or connections between component objects. This is achieved by specialising a UML model  to include the differences and by instructing the RAS  to load and apply the new model to the running system. Following appropriate type checking, the executing system is attached to the new model, those implementations no longer required are removed, those implementations newly required are instantiated, and the connections between implementations are reconfigured to reflect the alternate design. This process can be reversed, involving a transformation from a specialised design back to the original design, and indeed from a design in a hierarchy of designs to any other in that hierarchy, related by howsoever many intermediate designs.","It will be appreciated that the invention allows excellent flexibility because the system may be dynamically modified by simply modifying the meta model. The activation layer then performs the instantiation in an automated manner.","The invention is not limited to the embodiments described but may be varied in construction and detail."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":["DETAILED DESCRIPTION OF THE INVENTION","Brief Description of the Drawings"],"p":["The invention will be more clearly understood from the following description of some embodiments thereof, given by way of example only with reference to the accompanying drawings in which:",{"@attributes":{"id":"p-0038","num":"0068"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0039","num":"0069"},"figref":"FIGS. 2 and 3"},{"@attributes":{"id":"p-0040","num":"0070"},"figref":"FIGS. 4","b":["5","6"]},{"@attributes":{"id":"p-0041","num":"0071"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0042","num":"0072"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0043","num":"0073"},"figref":"FIGS. 9 to 14"},{"@attributes":{"id":"p-0044","num":"0074"},"figref":"FIGS. 15 to 20"}]},"DETDESC":[{},{}]}
