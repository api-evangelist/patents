---
title: Systems and methods for transforming data in buffer memory without unnecessarily copying data to additional memory locations
abstract: Various embodiments of the present invention are directed to a unique memory management scheme utilized by the DTP whereby data extracted from an external source is placed in a memory buffer and is then manipulated by the components without the need for copying the data to any other location in memory. While logically the data moves from component to component in the DFE for the various embodiments described herein, the data does not in fact change locations but, instead, the data resides in the buffer and is operated upon by a series of components that, in turn, access the data in the buffer via pointers and manipulate same.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07860916&OS=07860916&RS=07860916
owner: Microsoft Corporation
number: 07860916
owner_city: Redmond
owner_country: US
publication_date: 20031008
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE","TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","Overview","CONCLUSION"],"p":["This application is a continuation-in-part of application Ser. No. 10\/391,726, filed Mar. 18, 2003 and entitled \u201cSYSTEMS AND METHODS FOR SCHEDULING DATA FLOW EXECUTION BASED ON AN ARBITRARY GRAPH DESCRIBING THE DESIRED DATA FLOW\u201d, the contents of which are herein incorporated by reference.","The present invention relates generally to database systems and, more particularly, to systems and methods for transforming data in a single buffer location without unnecessarily copying said data to additional memory locations.","A relational database is a collection of related data that can be represented by two-dimensional tables of columns and rows wherein information can be derived by performing set operations on the tables, such as join, sort, merge, and so on. The data stored in a relational database is typically accessed by way of a user-defined query that is constructed in a query language such as Structured Query Language (SQL).","Often it is useful to extract data from one or more sources, transform the data into some more useful form, and then load the results to a separate destination. A data warehouse, for example, is a central repository for all or significant parts of the data that an entity's various business systems collect and store (often in separate databases), the purpose of the data warehouse being to support data mining, decision support systems (DSS), and other data actions. Data from various sources is selectively extracted and organized on the data warehouse database for use by analytical applications and user queries. Data warehousing emphasizes the capture of data from diverse sources for useful analysis and access.","In the context of a data warehousing, and more generally for managing databases, extract-transform-load (ETL) refers to three separate functions of obtaining, processing, and storing data. The extract function reads data from a specified source database and extracts a desired subset of data. The transform function works with the acquired data\u2014using rules or lookup tables, or creating combinations with other data\u2014to convert it to the desired state as defined by the specific ETL tool. The load function is used to write the resulting data (either all of the subset or just the changes) to a destination database. Various and diverse ETL tools can be used for many purposes, including populating a data warehouse, converting a database of a specific type into a database of another type, or migrating data from one database to another. However, when transforming data, a copy of the data extracted from the source and resident in memory (the primary copy) is again copied to a separate memory location, manipulated, and then copied back to the primary copy location. This unnecessary copying is both inefficient and can lead to data inconsistencies. What is needed in the art is a means for directly transforming a single buffered copy of data in memory without further copying of said data.","Various embodiments of the present invention are directed to a unique memory management scheme utilized by the data transformation pipeline (DTP) whereby data extracted from an external source is placed in a memory buffer and is then manipulated by the components without the need for copying the data to any other location in memory. While logically the data moves from component to component in the data flow executions (DFE) for the various embodiments described herein, the data does not in fact change locations. Instead, the data resides in the buffer and is operated upon by a series of components that, in turn, access the data in the buffer via pointers and manipulate same.","The following discussion is directed to a system and method for scheduling data flow execution based on an arbitrary graph describing the desired flow of data from at least one source to at least one destination. The subject matter is described with specificity to meet statutory requirements. However, the description itself is not intended to limit the scope of this patent. Rather, the inventors have contemplated that the claimed subject matter might also be embodied in other ways, to include different elements or combinations of elements similar to the ones described in this document, in conjunction with other present or future technologies. Moreover, where the embodiments described herein describe the invention in connection with row-level access and processing, it should be noted that the invention is by no means limited to row-level access and processing. For example, the invention could be applied on a column basis or a table basis as well.","Computer Environment",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 1"},"With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a conventional personal computer  or the like, including a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. The system memory includes read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within the personal computer , such as during start up, is stored in ROM . The personal computer  may further include a hard disk drive  for reading from and writing to a hard disk, not shown, a magnetic disk drive  for reading from or writing to a removable magnetic disk , and an optical disk drive  for reading from or writing to a removable optical disk  such as a CD ROM or other optical media. The hard disk drive , magnetic disk drive , and optical disk drive  are connected to the system bus  by a hard disk drive interface , a magnetic disk drive interface , and an optical drive interface , respectively. The drives and their associated computer readable media provide non-volatile storage of computer readable instructions, data structures, program modules and other data for the personal computer . Although the exemplary environment described herein employs a hard disk, a removable magnetic disk  and a removable optical disk , it should be appreciated by those skilled in the art that other types of computer readable media which can store data that is accessible by a computer\u2014such as magnetic cassettes, flash memory cards, digital video disks, Bernoulli cartridges, random access memories (RAMs), read only memories (ROMs) and the like\u2014may also be used in the exemplary operating environment. Further, as used herein, the term computer readable medium includes one or more instances of a media type (e.g., one or more floppy disks, one or more CD-ROMs, etc.).","A number of program modules may be stored on the hard disk, magnetic disk , optical disk , ROM  or RAM , including an operating system , one or more application programs , other program modules  and program data . A user may enter commands and information into the personal computer  through input devices such as a keyboard  and pointing device . Other input devices (not shown) may include a microphone, joystick, game pad, satellite disk, scanner or the like. These and other input devices are often connected to the processing unit  through a serial port interface  that is coupled to the system bus, but may be connected by other interfaces, such as a parallel port, game port or universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video adapter . In addition to the monitor , personal computers typically include other peripheral output devices (not shown), such as speakers and printers.","The personal computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be another personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the personal computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) . Such networking environments are commonplace in offices, enterprise wide computer networks, Intranets and the Internet.","When used in a LAN networking environment, the personal computer  is connected to the local network  through a network interface or adapter . When used in a WAN networking environment, the personal computer  typically includes a modem  or other means for establishing communications over the wide area network , such as the Internet. The modem , which may be internal or external, is connected to the system bus  via the serial port interface . In a networked environment, program modules depicted relative to the personal computer , or portions thereof, may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Network Environment",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 2A"},"The network may include client computers , a server computer , data source computers , and databases , , and . The client computers and the data source computers are in electronic communication with the server computer via communications network , e.g., an Intranet. Client computers and data source computers are connected to the communications network by way of communications interfaces . Communications interfaces  can be any one of the well-known communications interfaces such as Ethernet connections, modem connections, and so on.","Server computer provides management of database  by way of database server system software, described more fully below. As such, server acts as a storehouse of data from a variety of data sources and provides that data to a variety of data consumers.","In the example of , data sources are provided by data source computers . Data source computers communicate data to server computer via communications network , which may be a LAN, WAN, Intranet, Internet, or the like. Data source computers store data locally in databases , , which may be relational database servers, excel spreadsheets, files, or the like. For example, database shows data stored in tables , , and . The data provided by data sources is combined and stored in a large database such as a data warehouse maintained by server ","Client computers that desire to use the data stored by server computer can access the database  via communications network . Client computers request the data by way of SQL queries (e.g., update, insert, and delete) on the data stored in database .","Database Architecture","A database is a collection of related data. In one type of database, a relational database, data is organized in a two-dimensional column and row form called a table.  illustrates tables such as tables , , and  that are stored in database . A relational database typically includes multiple tables. A table may contain zero or more records and at least one field within each record. A record is a row in the table that is identified by a unique numeric called a record identifier. A field is a subdivision of a record to the extent that a column of data in the table represents the same field for each record in the table.","A database typically will also include associative structures. An example of an associative structure is an index, typically, but not necessarily, in a form of B-tree or hash index. An index provides for seeking to a specific row in a table with a near constant access time regardless of the size of the table. Associative structures are transparent to users of a database but are important to efficient operation and control of the database management system. A database management system (DBMS), and in particular a relational database management system (RDBMS) is a control system that supports database features including, but not limited to, storing data on a memory medium, retrieving data from the memory medium and updating data on the memory medium.","As shown in , the exemplary database comprises employee table , department table , and sysindexes table . Each table comprises columns  and rows  with fields  formed at the intersections. Exemplary employee table  comprises multiple columns  including empl_id, empl_name, empl_salary, and dept_id. Columns  in department table  include dept_id, dept_name, and dept_location. Sysindexes table  contains information regarding each table in the database.","Generally, data stored in a relational database is accessed by way of a user-defined query that is constructed in a query language such as SQL. Typically, for any given SQL query there are numerous procedural operations that need be performed on the data in order to carry out the objectives of the SQL query. For example, there may be numerous joins and table scans that need to be performed so as to accomplish the desired objective.","As noted, control and management of the tables is maintained by a DBMS, e.g., a RDBMS. An exemplary SQL Server RDBMS architecture  is graphically depicted in . The architecture comprises essentially three layers. Layer one provides for three classes of integration with the SQL Server, comprising: (1) a SQL Server Enterprise Manager  that provides a common environment for managing several types of server software in a network and provides a primary interface for users who are administering copies of SQL Server on the network; (2) an Applications Interface  that allows integration of a server interface into user applications such as Distributed Component Object Modules (DCOM); and (3) a Tools Interface  that provides an interface for integration of administration and configuration tools developed by Independent Software Vendors (ISV).","Layer two opens the functionality of the SQL server to other applications by providing three application programming interfaces (API): SQL Namespace , SQL Distributed Management Objects , and Data Transformation Services . A user interface  is provided by Wizards, HTML, and so on. SQL Namespace API  exposes the user interface (UI) elements of SQL Server Enterprise Manager . This allows applications to include SQL Server Enterprise Manager UI elements such as dialog boxes and wizards.","SQL Distributed Management Objects API  abstracts the use of DDL, system stored procedures, registry information, and operating system resources, providing an API to all administration and configuration tasks for the SQL Server.","Distributed Transformation Services API  exposes the services provided by SQL Server to aid in building data warehouses and data marts. As described more fully below, these services provide the ability to transfer and transform data between heterogeneous OLE DB and ODBC data sources. Data from objects or the result sets of queries can be transferred at regularly scheduled times or intervals, or on an ad hoc basis.","Layer three provides the heart of the SQL server. This layer comprises an SQL Server Engine  and a SQL Server Agent  that monitors and controls SQL Server Engine  based on Events  that inform SQL Server Agent of the status of the SQL Server Engine .","The Server Engine processes SQL statements, forms and optimizes query execution plans, and so on.","Logical Database Application","The above description focused on physical attributes of an exemplary database environment in which the present invention operates.  logically illustrates the manner in which data moves among a number of database servers, which may simultaneously be data sources for other database servers, to the destination database. Here, database server provides management of database . Data for database  is provided by data sources and , which are managed by database servers \u2032 and , respectively. Significantly, database \u2032 gathers data from databases and , which are managed by servers . Thus, database  is fed directly with data from databases and and indirectly with data from databases and ","In the exemplary system of this figure, data from database moves through database and then on to database . Along the way, the data may also undergo transformation. This example illustrates the general concept how data movement may comprise several hops in order for such data to actually reach the database server of interest. Those skilled in the art will recognize that many other combinations of movement and transformation of data is possible.",{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 5","b":["150","72","149","72","151","70"],"i":["a ","b"]},"Although both tables ,  contain similar information, it is not in an identical format. As a result, the data must be transformed by separate ETL tools into the format of table . For example, table  maintains a column empl_name that contains employee names as first name followed by last name; whereas, table  maintains a column name that contains employee names as last name followed by first name. Table  contains employee names in the form of table . In order for the name columns of table  to be inserted into the emplname column of table , the name must be converted to the proper form. Similarly, table  does not contain dept_id information.","The above example illustrates that data moving between databases may need to be transformed in some manner before insertion into the target database. However, using separate ETL tools to achieve each transformation is inefficient. In , for example, transformation application  (one ETL tool) transforms the data of table  into proper form for table  and transformation application  (a separate ETL tool) transforms the data of table  into proper form for table .","Data Transfer Service and Data Transfer Pipeline","A data transformation system (DTS)\u2014various embodiments of which are described in, and are the central subject matter of, parent application Ser. No. 10\/391,726, filed Mar. 18, 2003 and entitled \u201cSYSTEMS AND METHODS FOR SCHEDULING DATA FLOW EXECUTION BASED ON AN ARBITRARY GRAPH DESCRIBING THE DESIRED DATA FLOW\u201d\u2014comprises a capability to receive data from a data source (such as a data retrieval system that receives data from a source), a data destination and a capability to store transformed and or non-transformed data therein (a destination data storage system to store data), and a data transformation pipeline (DTP) that constructs complex end-to-end data transformation functionality (data flow executions or DFEs) by pipelining data flowing from one or more sources to one or more destinations through various interconnected nodes (that, when instantiated, become components in the pipeline) for transforming the data as it flows by (where the term transforming is used herein to broadly describe the universe of interactions that can be conducted to, with, by, or on data). Each component in the pipeline possesses specific predefined data transformation functionality, and the logical connections between components define the data flow pathway in an operational sense.","One solution to the efficiency problem of traditional ETL-based transformations is the use of the data transformation pipeline (DTP), the functional structure of an exemplary one of which is illustrated in . In this particular embodiment, the DTP  comprises a graphical user interface (GUI)  that enables a user  (represented here as a PC client computer) to develop a complex end-to-end data transformation function (a data flow execution or DFE) by graphically describing and representing a desired data flow from one or more sources to one or more destinations through various interconnected nodes (a graph). Each node in the graph represents specific predefined data transformation functionality that is offered by uninstantiated component objects  residing in a component library , and connections between the nodes as drawn by the user  represent the data flow pathway between the components for the graph.","After the user  inputs graph data  via the GUI , the DTP  utilizes a translator  to traverse the graph data  and to translate the graph into an DFE plan (not shown). Moreover, in this example, the translator  works in conjunction with an optimizer subsystem  to optimize the simple graph developed by the user  into a maximally efficient execution structure by eliminating redundancies, simplifying and enhancing the DFE plan and possibly performing a plethora of other optimizations that are known and appreciated by those of skill in the art. Based on the DFE plan, the scheduler  uses its pipeline engine  to build the actual DFE  by instantiating appropriate components objects  from the component library  (as detailed in ). The translator  also produces work lists  for the scheduler  where each work list  contains specific work items for the scheduler  to control the operation of the DFE ; moreover, it is important to note that the actual interconnectivity between the various component objects is in effect reflect in the work lists as parameters associated with each work item in each work list. Of particular note, the DTP  also comprises a buffer  which is utilized by the DFE  (described more fully later herein).","Notwithstanding the name, the scheduler  does not schedule work items according to time, but instead the scheduler  manages the work lists  and the execution of the work items in the lists by the DFE . Each work item in a work list is one of five operations that the scheduler  uses to control the operation of the DFE , the five operations comprising:\n\n","Referring to both , the latter of which is a detailed view of the DFE , the first operation, extracting data from a data source, is a work item that causes the scheduler  to thread\/task\/program\/schedule\/etc. (hereinafter, simply to thread) a specific extraction component\u2014for example, extraction component \u2014to extract certain data from a certain data source\u2014for example, data source \u2014and for the extraction component  to logically hold that data to be passed to another component although, in reality, the data is actually stored in a buffer . The second operation, providing data to a component, causes the scheduler  to thread a specific component\u2014for example, transformation component \u2014to transform the data according to the input\/output functionality of the component . (As described more fully below, in operation the scheduler  actually passes a first set of pointers (primary pointers) for the buffer data to the component so that the component can directly access the data in the buffer  and transform it without having to copy it.) The third operation, enabling the split of data along two or more paths, is a work item that causes the scheduler  to thread a specialized component\u2014for example, split component \u2014to analyze each row of data and, based on a specified criteria, group the data into one of two groups, alpha (first path) or omega (second path), each of which will thereafter logically travel along separate paths of the pipeline during continuing execution of the DFE . Moreover, from this point forward, the scheduler  treats alpha and omega as distinct and separate data groups. The fourth operation, enabling the merger of data from two or more paths into a single path, is the logical converse of a split that causes the scheduler  to thread another specialized component\u2014for example, merge component \u2014to merge two distinct and separate data groups into a single data group that travels along a common path in the pipeline during continuing execution of the DFE , and from this point forward the scheduler  treats the merged data as a single group. The fifth operation, loading data to a data destination, is a work item that causes the scheduler  to thread a specific loading component\u2014for example, loading component \u2014to load certain data onto a certain data destination\u2014for example, data destination . These five operations comprise the general functionality of the scheduler , although it is the specific input\/output functionality of the uninstantiated component objects  that are available to the DTP  (and which are threaded to by the five operational elements) that enable the development of complex data transforms.","As previously alluded to herein above, the DTP  has a multitude of uninstantiated component objects categorized in a component library , each of which has defined inputs and outputs from which the user can graphically construct complex data transformations (via the pipeline engine ) by combining the functionality of the components into an DFE  in order to achieve a desired end results. The transformation components are similar to a plurality of ETL tools but individually lack the individual functionality of ETL tools to extract and load data (as these tasks are handled by the scheduler in the DTP system through special, non-transformation components such as the extract components  and the load components ). Moreover, all of the components provide black box transformation functionality\u2014that is, components can be developed on a variety of platforms (Java, ActiveX, etc.) because the development platform is irrelevant to the DTP  as it (and the user ) are only concerned about the inputs and outputs for the component\u2014that is, the functional information necessary to use the component as a black box object.","Referring again to , after the DFE  is formed by the pipeline engine  as described earlier herein, the scheduler begins executing the individual work items in one of the work lists , the individual work items of which are textually depicted . For example, in executing a work list , the scheduler might individually thread the extraction components  and  to extract data from three data sources , , and  to create two data groups (which are stored as two distinct data groups, A and B respectively, in the buffer ). Upon each completed extraction, the scheduler then threads the appropriate transformation component  or  to begin transforming the data corresponding to each path (A and B respectively). When component  is complete, and presuming that component  is complete before component , the scheduler recognizes that the next step for data group A (hereinafter A) is to merge with data from a split process  and, since that data is not yet available, the scheduler may not yet initiate the thread for the merger component . Meanwhile, component  completes its transformation of data group B (hereinafter B) and the scheduler  then threads the split component  to split B according to input parameters specified by the work item. Consequently, B is logically split into B and B, each data group being the output of component  along separate paths in the DFE . Once the split is complete the scheduler  then threads the merger component  to merge A and B. Also, recognizing that the remaining execution of B is independent from the continuing execution of A and B, the scheduler  also threads component  to transform B.","Without further regard to each remaining pathway, and to summarize the rest of the dataflow in the DFE  (without explicitly referring to the scheduler , the operation of which can be easily implied), A and B are merged by component  to form AB, which is then transformed by component  and thereafter loaded to an external data destination  by loading component . Meanwhile, B, having been transformed by component , is then transformed by components  and  in order, and thereafter B is loaded to two external data destinations  and  by loading component .","This exemplary scheduler, including the important translator\/optimizer functionality that has been separate in the figures for clarity but which may in fact be scheduler subsystems, performs a critically important role in the DTP. Not only does the scheduler enable a user to describe complex data transformations in a simple graph easily drawn via the GUI interface, and not only does the scheduler (via the translator) map the graph to an DFE plan and task lists, but it also controls the actual execution of the data flows throughout the actual DFE to ensure consistent functionality for situations such as: pipelining data through a DFE comprising both synchronous and asynchronous components (where the latter requires all data to be inputted before any data can be outputted); keeping data in sequence when necessary while employing parallel processing techniques; load balancing; enabling parallel processing despite the data residing in a single location in memory (as discussed below); and so forth. Consequently, an important consideration for such an exemplary system is the care given to ensuring that the relationship between elements in a graph and the DTPs capabilities are clearly defined and entirely consistent.","Memory Management Scheme","Various embodiments of the present invention are directed to a unique memory management scheme utilized by the DTP whereby data extracted from an external source is placed in a memory buffer and is then manipulated by the components without the need for copying the data to any other location in memory. While logically the data moves from component to component in the DFE for the various embodiments described herein, the data does not in fact change locations but, instead, the data resides in the buffer and is operated upon by a series of components that, in turn, access the data in the buffer via pointers and manipulate same.","Consider , B, C, D, and E which collectively illustrate how data is (a) extracted by an extraction component and stored in buffer memory, (b) transformed by a component, and then (c) loaded to a destination from the buffer memory by a loading component.  (with references to other prior figures) illustrates a sample graph  for a data transformation specified by a user  via the GUI . The user  for this example has described that data regarding his subordinates employees should be extracted from the corporate database , divided into two groups based on sex (male or female) , each group then sorted by name  and  and, finally, each group loaded to the two separate databases  and .",{"@attributes":{"id":"p-0065","num":"0069"},"figref":"FIG. 7B","b":["308","310","314","318","314","312","420","424","422","426","428","434","436","430","432","308","310"]},{"@attributes":{"id":"p-0066","num":"0070"},"figref":"FIGS. 7C and 7D","b":["380","320","440","442","444","380","446","400","448","450","426","446","426","446","426"]},{"@attributes":{"id":"p-0067","num":"0071"},"figref":"FIG. 7E","b":["380","320","426","428","446","428","448","450","308","448","450","446","314","446","430","432","434","436","320"]},"Various embodiments of the present invention are directed to a memory management scheme\u2014that is, a buffer system\u2014comprising a plurality of buffer objects, services by which ETL objects can manipulate the data in the buffers, and a buffer manager for managing the buffer objects and services. The buffer manager further comprises a central repository of type information which describes the format of data stored in each possible buffer type. Once a buffer type is registered, the buffer manager can be asked to create an instance of that type of buffer for use by the pipeline and its transforms.","In certain embodiments, the buffer manager may be written with the memory usage patterns of the pipeline in mind such that, when buffers of a certain type are used within a subset of the pipeline's transformation graph to repeatedly access and release memory, the buffer manager, in order to make memory available rapidly, sets aside unused buffers instead of destroying them since it is likely the memory and its buffer structure will be used again. This approach can avoid problems with fragmentation in the operating system's own heaps.","Moreover, instead of simply providing ETL objects the ability to manipulate data by calling individual rows\u2014which requires significant overhead in making call after call for each individual row, and where the cost of setting up and cleaning up after each call is very large\u2014various embodiments of the present invention instead provide ETL objects with a buffer of rows for processing, and arranges each row in such a way that all columns within the row are in close proximity within buffer memory to maximize the efficient utilization of the processor's cache.","In addition, while the memory manager does allow ETL objects to access data using a simple call-by-cell mechanism, this buffer approach also makes it possible for an ETL object to access buffer data an entire row at a time because the data manager loads the entire row even for a single cell call. In other words, efficiently accessing one row of data with a single function call\u2014regardless of how many columns are in that row, or how wide the total data in the row is\u2014gives a gain in efficiency over making repeated calls for different columns in a single row.","Since the buffer object itself is offered to each transform (via the passing of pointers), the buffer does not need to be moved throughout memory to be accessed by each object operating in its data\u2014that is, whenever data is requested by an ETL object, a reference (pointer) to the data is provided. The calling ETL object manipulates data through the reference and, when completed, leaves the data residing in the buffer. This approach avoids copying data to another memory location, revising the data, and then copying the data back to the buffer. Likewise, no copying is necessary when loading data into the buffer from a data source, nor is copying required when reading data from the buffer for writing to a data destination, since the memory manager maintains full rows of data for each call, and the data is bound directly into the buffer without first storing it elsewhere in memory for such operations.","Buffer Types and Initialization","A buffer type is defined by declaring a set of columns that are characteristic for each row of data. Each such column, common to each row, is assigned a data type, a maximum data width (which is important for data types that do not have a fixed or predefined width), and supplemental info corresponding to the specific data type\u2014for example, the maximum stored precision for a decimal number type. Using this typing schema, a buffer type inherently possesses a known (or at least determinable) row \u201cwidth\u201d which is the sum of the widths of all the individual columns in the row. For example, consider a phone book which has the data structure shown in ; in this example, the maximum width of each row is 170 characters which, in turn, is the sum of the widths of the three columns that comprise each row (80+10+80=170).","To create a buffer of this type, the buffer manager allocates the highest number of complete rows that fit into the buffer's default memory size. In one embodiment, the default memory size is nominally ten megabytes (10,485,760 bytes), although other sizes are available for other embodiments, and in certain embodiments this size is adjustable either automatically or manually. Referring again to the structure of , the buffer manager would allocate a buffer with 61,680 rows\u2014totaling 10,485,600 bytes\u2014for the present data structure. However, if the row size is so great that it's larger than the default memory size, in various embodiments the buffer type will be allocated enough memory for one full row. While moving a single row of data through the pipeline in a buffer is logically expensive, this solution is still preferable to not being able to handle an arbitrary row width of a size greater than the default memory size. An alternative to this single-row method is to consume more memory such that the memory manager allocates sufficient memory from among the total memory available to provide a buffer of multiple rows.","In any event, the memory allocated for the buffer may then be allocated by the operating system in a single large one-dimensional arrangement. For use in a database-oriented application, this memory is then logically divided into an irregular two dimensional array where the address for any row can initially be determined using simple math\u2014that is, where the start of a row is given by the row's index multiplied by the row size to determine the correct offset for that data row. Then, for a specific data cell within said row, an additional offset, illustrated in , can then be added to this sum. Therefore, to find the location of a particular cell at row n, column m, the buffer manager can determine the address using the following algorithm:\n\nCellAddress()=ColumnOffset[]+RowStart[\n","However, in regard to this basic buffer layout in memory, and for certain alternative embodiments of the prevent invention, the buffer manager may have two freedoms in planning the layout of rows in the buffer; first, the offset of an individual column might not parallel its relative position in the declaration of the type; and, second, dead space might exist between the end of one cell in a row and the beginning of the next. These two freedoms will enable the buffer manager to tune the exact placement of the cells in memory for any of a variety of reasons known and appreciated by those of skill in the art, such as, for example, making maximum utility of the processor's cache.","Reorganizing Rows in a Buffer","While an initial reference to a row can be found using simple multiplication (as described above), it is often advantageous to logically reorder rows within a buffer. For example, if a buffer is sorted by customer name, the order of rows must necessarily change to reflect the order provided by the sort. However, it is undesirable to copy data for each involved row to a new memory location to reflect the sort results.","Therefore, for various embodiments of the present invention, the buffer maintains a pointer to each row's initial starting location (the row start array, \u201cprimary pointers\u201d, or first set of pointers), and these pointers are initialized mathematically for each row n using the following algorithm:\n\nRowStart()=BufferStart+RowSize*\n","Thereafter, when an ETL object requests the buffer manager to swap any rows (such as in the context of reordering the data in a sort), the buffer manager simply exchanges the pointers corresponding to the starts of subject rows in the row start array. For various embodiments of the present invention, the array of pointers to each row's start (the primary pointers) are maintained in the buffer's instance data, the array using one entry for each possible row in the buffer.","Of course, while the buffer allocates enough memory for several thousand rows upon initialization, the buffer does not actually not use any of the rows immediately but, instead, the memory is allocated to each row as follows: As rows are added to an empty buffer, they fill space at row indexes starting with zero and working their way upward towards the number of rows in the buffer. This total is the active count of rows in the buffer and is maintained in the buffer's instance data. The current number of rows in use is very different than the maximum number of rows in use, which is also stored in the buffer object instance data.",{"@attributes":{"id":"p-0081","num":"0085"},"figref":"FIG. 9"},"Many embodiments of the present invention used in pipeline applications will need to split data which starts at a single source but is then divided for separate processing based on some attribute of the data. The buffer manager plays a critical role in efficiently supporting these scenarios by providing additional \u201cvirtual buffers\u201d such that, when the pipeline determines how each is to be split (that is, which group it is to belong to), the buffer manager allocates additional space within the buffer for additional pointer arrays (\u201csubsets\u201d) to support the split without copying any of the rows. For example, if a split transform, such as the one shown in , picks \u201cwinners\u201d and \u201closers\u201d from among rows pertaining to popular culture celebrities, the desired result would be to split the source input into the corresponding two outputs illustrated by  for a hypothetical group of such celebrities. However, instead of copying each row to a separate buffer destination corresponding with each of the two possible outputs, the buffer manager instead uses the aforementioned subsets built into the buffer and each subset is implemented in the buffer by using a new active row count and a new row starts array as shown in . Although not shown, both the Winners Subset and the Losers Subset arrays are big enough for ten full rows (since, in the extreme case, all ten rows could all be winners or all be losers); however, for convenience, the unused portion of these arrays are not shown. Moreover, while the subsets in this example are mutually exclusive (that is, each row is either a Winner or a Loser but not both nor neither), other embodiments of split functionality may allow a row to belong to both resultant arrays and\/or neither resultant array.","The various techniques described herein may be implemented with hardware or software or, where appropriate, with a combination of both. Thus, the methods and apparatus of the present invention, or certain aspects or portions thereof, may take the form of program code (i.e., instructions) embodied in tangible media, such as floppy diskettes, CD-ROMs, hard drives, or any other machine-readable storage medium, wherein, when the program code is loaded into and executed by a machine, such as a computer, the machine becomes an apparatus for practicing the invention. In the case of program code execution on programmable computers, the computer will generally include a processor, a storage medium readable by the processor (including volatile and non-volatile memory and\/or storage elements), at least one input device, and at least one output device. One or more programs are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However, the program(s) can be implemented in assembly or machine language, if desired. In any case, the language may be a compiled or interpreted language, and combined with hardware implementations.","The methods and apparatus of the present invention may also take the form of program code that is transmitted over some transmission medium, such as over electrical wiring or cabling, through fiber optics, or via any other form of transmission, wherein, when the program code is received and loaded into and executed by a machine, such as an EPROM, a gate array, a programmable logic device (PLD), a client computer, a video recorder or the like, the machine becomes an apparatus for practicing the invention. When implemented on a general-purpose processor, the program code combines with the processor to provide a unique apparatus that operates to perform the indexing functionality of the present invention.","While the present invention has been described in connection with the preferred embodiments of the various figures, it is to be understood that other similar embodiments may be used or modifications and additions may be made to the described embodiment for performing the same function of the present invention without deviating there from. For example, while exemplary embodiments of the invention are described in the context of digital devices emulating the functionality of personal computers and PDAs, one skilled in the art will recognize that the present invention is not limited to such digital devices, as described in the present application may apply to any number of existing or emerging computing devices or environments, such as a gaming console, handheld computer, portable computer, etc. whether wired or wireless, and may be applied to any number of such computing devices connected via a communications network, and interacting across the network. Furthermore, it should be emphasized that a variety of computer platforms, including handheld device operating systems and other application specific operating systems, are herein contemplated, especially as the number of wireless networked devices continues to proliferate. Therefore, the present invention should not be limited to any single embodiment, but rather construed in breadth and scope in accordance with the appended claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing summary, as well as the following detailed description of preferred embodiments, is better understood when read in conjunction with the appended drawings. For the purpose of illustrating the invention, there is shown in the drawings exemplary constructions of the invention; however, the invention is not limited to the specific methods and instrumentalities disclosed. In the drawings:",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 6A"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 6B","FIG. 6A"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 7A"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 7B","FIG. 7A"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 7C"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 7D"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 7E"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 8A"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 8B","FIG. 8A"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 10A"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 10B","FIG. 10A"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 10C","FIG. 10B","FIG. 10A"]}]},"DETDESC":[{},{}]}
