---
title: System in which a first program written in one programming language can interact and access a second program written in a different programming language
abstract: A system accesses, from a first computer program written in a first computer language, functionality available through a second computer program written in a second computer language. The system has an interface intermediate the first and second programs for enabling access between the first program and the second program. The interface includes (a) a first handler in the second computer language for receiving messages from the functionality and (b) a second handler for retrieving messages, via the interface, that the first handler receives. The second handler is part of the first program.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07296272&OS=07296272&RS=07296272
owner: Hewlett-Packard Development, L.P.
number: 07296272
owner_city: Houston
owner_country: US
publication_date: 20030523
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF INVENTION","BACKGROUND ART","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE DRAWINGS"],"p":["The present invention relates generally to the field of computer programs, and more particularly to improvements in the architecture of a system in which a first computer program written in one programming language can interact with and access a second computer program written in a different programming language.","Java is a popular and widely used high-level programming language. A computer program written in Java source code is compiled into Java byte code, hereinafter referred to as a Java application, and is interpreted upon execution by a so-called Java virtual machine (JVM). The JVM transforms the byte code into executable instructions specific to the platform on which the Java application and the Java virtual machine are run. In this way, providing that only functionality within the JVM is used by the Java application, Java developers can write Java applications that are largely portable and executable on any platform having an appropriate JVM. Such an arrangement thereby removes the need for Java developers to have specific knowledge about individual execution platforms and is one of the reasons why the Java programming language has become so popular over recent years.","In many circumstances Java applications are less efficient than applications written in generally non-portable languages such as C, C++ and assembly language. The lower efficiency is mainly due to the fact that, for portability reasons, much low-level platform specific functionality which is easily accessible from C and C++ is not available directly through Java. However, where Java applications are required because they have platform independence, efficiency is not usually of primary concern and the advantages brought by portability generally outweigh any disadvantages regarding performance.","In the field of telecommunications there is an increasing desire to write telecommunication applications in Java, due in part to its relative ease of use. However, one of the problems posed with writing applications in Java, particularly in the telecommunications field, is that the much of underlying telecommunications systems are controlled by legacy applications written in languages other than Java. This is largely for historical reasons and partly because Java is not generally a good choice of language especially where high performance low-level functionality is required. Accordingly, a Java application written for a telecommunications system is generally required to access existing legacy applications or programs written in other languages, especially where access to low-level functionality, such as interacting with a communicating module, such as a communication stack, is required.","In order for a Java application to access an application or program written in a language other than Java (hereinafter referred to as a \u2018native application\u2019) the Java native interface (JNI) can be used. The Java Native Interface (JNI) is a documented and supported specification that allows native applications, for example written in C, C++ or assembly language, to be called from a Java application. The JNI can also enable native applications, under certain circumstances, to call a Java application. The JNI may be considered as an additional library that can map Java methods to corresponding native functions.","Not surprisingly, use of the JNI generally introduces some performance overhead, especially where data is transferred between a Java application and a native application. Where such data transfers are required it may be necessary to perform a translation from, for example, a Java data object to a C structure, or vice-versa. In many situations, for example where a Java application is required to access or schedule an asynchronous communication stack, the Java application may be required to make considerable use of the JNI and hence may incur considerable performance overhead. Such situations are common, for example in telecommunications systems","One aim of the present invention is to mitigate at least some of the aforementioned problems.","According to a first aspect of the present invention there is provided a system for accessing, from a first computer program written in a first computer language, functionality available through a second computer program written in a second computer language. The system comprises an interface intermediate the first and second programs for enabling access between the first program and the second program. The system further comprises a first handler in the second computer language for receiving messages from the functionality. A second handler, that is part of the first program, retrieves messages, via the interface, received by the first handler.","Advantageously, overall performance is improved by reducing the required usage of the intermediate interface, e.g. the JNI, when accessing or scheduling an asynchronous event\/message module, such as a communication stack. Furthermore, if it is necessary to later migrate to a message-based communication framework, such a change can be made with relative ease.","The functionality available through the second computer program enables messages to be received from a communicating module which, in a preferred embodiment is a communications stack.","The first handler may be implemented as a thread of the second program.","Preferably the first handler is interposed between the functionality and the interface in a separate thread in the second language and the second handler is interposed between the first program and the interface.","The first handler may access the communication stack by calling the provided functionality.","In a preferred embodiment the first handler filters the received messages to remove messages not relevant to the first program.","The first handler may also comprise a message queue for receiving messages from the functionality.","The second handler may be incorporated into the first computer program, preferably as a thread in the first language.","In a preferred embodiment the first computer language is Java and thus the system preferably further comprises a Java virtual machine.","The second computer language is preferably any one of C, C++, or assembly language.","Where the first computer language is Java it is preferred that the interface is the Java Native Interface (JNI).","Typically the functionality is provided in the form of an Application programming interface (API).","According to a further aspect, there is provided a method of accessing, from a first computer application written in a first computer language, functionality available through a second computer application written in a second computer language. The method is performed with a system comprising an interface intermediate the two applications for allowing access between the first and second applications. The method comprises receiving messages from the functionality using a handler provided as part of the second computer language. Messages not relevant to the first application are removed from the received messages, preferably by filtering. The filtered messages are retrieved, via the interface, by the first application.","According to a still further aspect, there is provided a computer system comprising a plurality of computer programs written in different computer languages wherein a first computer program, written in a first computer language, accesses functionality accessible via a second computer program written in a second computer language. An interface intermediate the computer programs written in the different languages is required to allow such access. The interface includes (1) a first handler intermediate the interface and the functionality for receiving messages from the functionality and for removing messages not relevant to the first program; and (2) a second handler for retrieving messages from the first handler for use by the first computer program.","According to yet a further aspect, there is provided a component for a computer system. The computer system has a plurality of computer programs written in different computer languages. A first computer program, written in a first computer program, receives messages from functionality accessible via a second computer program written in a second computer language. The messages are received via an interface intermediate the two programs enabling such access. The component comprises a program for removing messages not relevant to the first computer program from the received messages.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 1"},"When a Java application  is executed, the Java byte code which describes the application is interpreted by the Java virtual machine  and is transformed into executable instructions specific to the operating system . In this way, the Java application may function as intended on the particular platform running the operating system . If the Java application only uses functionality supported by the JVM , the Java application may also be executed on different platforms having the same or different operating systems as is widely known.","In order for a Java application to use functionality outside of that provided by the JVM, for example that provided by an application written in a language such as C, C++ or assembly language, the Java native interface (JNI) may be used, as shown in . This may be particularly desirable when low-level functionality is required, for example, to be written in a lower-level language for performance reasons, or to take advantage of already existing legacy applications written in native languages.  is a block diagram of the general architecture of a Java application using the JNI according to the prior art. For functionality provided by the JVM  the Java application  functions in the manner described above. Where functionality outside of that provided by the JVM is required, the JNI  can be used as follows. The Java application calls a Java method, mapped to a corresponding native function, through use of the JNI  and the mapping layer . The JNI and the mapping layer translate payloads from the Java domain to the native domain, and vice versa. The mapping layer can be thought of as comprising additional program code that performs, amongst other tasks, payload translation. The JNI and the mapping layer translate any payloads from the Java domain to the native domain (and vice versa) and call the corresponding native code function.","Not surprisingly, use of the JNI inevitably introduces some performance overhead due to the additional function calls and mapping functions that may be required. The processes involved in using the JNI are well known by those skilled in the art and are not described in detail herein.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 3","b":["302","308","310","302","320","320","318"]},"In order for the Java application to access the communication stack  via the API  the Java application uses the JNI . The Java application  has a main Java application thread , for controlling the main flow of the Java application, and a secondary thread for controlling the message queues  and . The Java application accesses the functionality of the JVM  and hence the operating system  as described previously. The thread is responsible for (1) sending any messages placed in the out-bound queue , for example by the main Java application thread , to the communication stack , (2) retrieving messages from the communication stack  and (3) placing the retrieved messages in the inbound queue  for use, for example, by the main Java application thread ","The way the thread accesses the communication stack  is described below with reference to  which is a sequence diagram outlining the operation of the system  of . Each event is designated by a letter a to i, shown at the right-hand side of the Figure.  shows, as vertical lines, representations of the different elements of the system , namely the main Java application thread , the Java in-bound queue , the Java out-bound queue , the Java thread for controlling the queues, the JNI , the C API  and the communication stack .","The operations involved in retrieving a message from the communication stack  are now described. In the following description, functions and methods are referred to in the format \u2018Type MethodName\u2019, where Type is indicative of the language domain of the function\/method and where MethodName is indicative of the generic functionality provided by the function\/method. In keeping with the spirit of established naming conventions, Java methods are herein separated by a \u2018.\u2019 and C functions by a \u2018_\u2019. For example, reference to \u2018Java.Select\u2019 refers to a Java method that performs a general \u2018Select\u2019-type method. Similarly, \u2018C_Receive\u2019 refers to a C function that performs a general \u2018Receive\u2019-type function. Such references do not necessarily refer to existing or available Java or C functions\/methods or libraries, and are used herein merely to indicate the general intended purpose of such a function\/method as will be clearly understood by those skilled in the field.","The Java thread calls a \u2018Java.Select\u2019 method, line a, which is used to determine the presence of a message on the communication stack . The \u2018Java.Select\u2019 method is mapped to a \u2018JNI.Select\u2019 method in the mapping layer . As will be understood by those skilled in the art, each function mapping can also perform any required payload mapping or translation. The \u2018JNI.Select\u2019 method calls a C API function \u2018C_Select\u2019 as indicated by the mapping layer . The mapping from one method to another can also provide additional functionality, other than just pure mapping; for example registers or flags may need setting and other functions may need calling.","The \u2018C_Select\u2019 function results in a blocking operation. While the blocking operation occurs, the \u2018C_Select\u2019 function waits for a new message to arrive from the communication stack , which has the effect of blocking the Java thread . When a new message or event arrives (line b) the Java thread is unblocked and calls a \u2018Java.Receive\u2019 method (line c) which, in the manner described above, is mapped through the JNI to call a corresponding \u2018C_Receive\u2019 function provided by the C API . The \u2018Java.Receive\u2019 method retrieves the message from the communication stack  where the message is either placed in the in-bound queue  using a \u2018Java.PutMessage\u2019 method (line d) if the message is determined as being relevant to the Java application, or the message otherwise is discarded. This process is outlined in lines a to d of . If a received message is placed in the in-bound queue , the main application thread may subsequently retrieve the message using a \u2018Java.GetMessage\u2019 method, line e.","A similar process sends messages from the main Java application thread to the communication stack . To send a message to the communication stack  the main Java application thread first places the message to be sent in the outgoing queue , using, for example, a \u2018Java.PutMessage\u2019 method (line f). The thread removes the message from the queue by using a \u2018Java.GetMessage\u2019 method (line j). The thread then sends the message, across the JNI (line h) to the communication stack  (line i).","Due to the real-time and asynchronous nature of the communication stack  is the Java application preferably frequently checks the communication stack for new messages. In telecommunications systems it is generally required that messages be timely processed, especially when such messages relate to call establishment, billing and so on. In telecommunications systems a multitude of messages and events may be present or may arrive at the communication stack , although not all of these will be relevant to the Java application . For example, many events may be of use for the internal use of the communication stack .","One of the main problems with retrieving messages in this way is that the scheduling of the communications stack is carried out by the Java application. In practice this means that every \u2018Java.Select\u2019 and every \u2018Java.Receive\u2019 method makes use of the JNI and hence incurs some performance overhead. This also means that even messages\/events that are not relevant to the application traverse the JNI, even though they may be later discarded by the application.","Despite the above-mentioned problems, the above architecture is widely used since, as far as Java developers are concerned, the solution is easy to implement since no access or modifications are required to the native source code. However, as performance becomes ever more critical, an improved solution is sought.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 5","FIG. 6"],"b":["502","520"]},"In the system according to the first embodiment, the thread controlling the in-bound and out-bound message queues,  and  respectively, is a C thread  which may reside on top of the C API  or may be an independent program thread running in the C space. The C thread controls the message queues by receiving messages from the communication stack  through the C API . Preferably the thread  is written in the same language as the native application. Messages placed in the out-bound queue are transmitted to the communication stack, and messages received from the communication stack  are placed in the in-bound queue for subsequent retrieval by the Java application , via the JNI.","The Java application  shown in  comprises two threads; a main application thread for controlling the main application function; and a secondary thread responsible for general message handling associated with reading messages from the in-bound queue  and for sending messages to the out-bound queue . Those skilled in the art will appreciate, however, that other architectures or designs can also be used, for example using a single thread or multiple threads as appropriate.","The Java thread performs a blocking operation, subject to any timeout period, until a message is placed in the in-bound queue , at which point the Java thread wakes up and retrieves the message via the JNI. Once the message has been retrieved it may be, for example, passed to the main Java application thread for further processing.","Referring now to , the Java application  calls a \u2018Java.Select\u2019 method (line a), which performs a blocking operation while waiting for a new message to arrive in the C in-bound message queue . The C thread , which is independent of the Java thread and performs general message handling functions, calls a \u2018C_Select\u2019 function (line b). The \u2018C_Select\u2019 function performs a blocking operation while waiting for new messages to arrive from the communication stack . When a message arrives on the communication stack (line c) the C thread  wakes up and calls a \u2018C_Receive\u2019 function which preferably determines whether the message is of relevance to the Java application  (line d). This process occurs whenever a message or an event is received on the communication stack, as illustrated in lines a to g. If application  determines that the message or event is not relevant, application  discards or ignores the messages, and the C thread  waits for the next message to arrive. Application  preferably bases its decision as to the relevance of a message on a set of predetermined conditions incorporated into the C thread.","When a message of relevance arrives on the communication stack, line i, the \u2018C_Select\u2019 function retrieves the message and calls the \u2018C_Receive\u2019 function to retrieve the message from the communication stack  (lines h to j). The C thread , upon receipt of a relevant message, places the message in the in-bound queue  through use of a \u2018C_PutMessage\u2019 function (line k). The Java thread unblocks when a message arrives in the C in-bound queue, thereby enabling the thread to retrieve the message, via the JNI.","In this example the JNI is only used twice to retrieve a relevant message from the communications stack ; the JNI is used once to call the \u2018Java.Select\u2019 method, and once to retrieve a relevant message from the C in-bound queue . The architecture of  typically provides considerable performance improvements over the architecture described above with reference to , where the JNI is used for each and every message (whether relevant or not).","An advantage of the system of  over the prior art system described above arises largely from the fact that control of the in-bound and out-bound queues is moved, relative to the prior art, from the Java application to the other side of the JNI boundary and into the same code space through which the communication stack is accessed. By doing so, the number of method\/function calls that are required to traverse the JNI may be significantly reduced. Since the only messages that are sent across the JNI are those that are relevant to the Java application, the system of  helps to prevent messages that are not relevant from using up valuable processor resources incurred as a result of traversing the JNI. In telecommunications systems even small performance improvements can provide significant benefits.","In all of the above-described examples it is should be noted that the Java application, C API and communication stack are preferably all running on the same hardware platform, as is currently common in the telecommunications field.","In some instances, the operations preferably operate on a more distributed model, for example taking advantage of new message-based technologies, such as that outlined in . The system shown in  utilizes a communication framework server  running on an independent message server for communicating messages between other distributed systems, such as a Java application  and a telecommunications system . Such a message framework  can, for example, be based on the Java messaging server (JMS) or other suitable technology. In the model illustrated in  each of the main elements; the Java application , the communications framework server  and the telecommunications system  can all run on independent and geographically remote systems, with each of the elements in the system being at least remotely connectable as will be appreciated by those skilled in the field.","An additional, advantage of the system of  lies in its future-proof design and the fact that migration to a message-based communication framework requires relatively minor changes to the system.","By contrast however, to make the transition in a single step from, for example, the prior art system described with reference to  above, to a message framework based architecture requires significant large-scale changes.","As is well known in the field of software development, modifications to software systems always carry an inherent risk of introducing errors or bugs into the program code, and it is almost always preferable to limit the exposure to such risks. Providing a solution in accordance with the systems of  not only provides an efficient architecture for current requirements, but also enables future migrations to such message-based systems to be undertaken with relative ease.","In this way, should an eventual migration to a message-based system be required, the systems of  can be easily modified. Such an approach has the advantages of providing a future-proof current solution, in which the costs of any eventual migration can be either delayed or minimized.","The examples given above are merely illustrative to highlight the general inventive concepts of the present invention. Those skilled in the art will appreciate that the present invention is in no way limited to use with the Java or any other particular programming language. The inventive concepts outlined above can be carried out with any system requiring an intermediate interface between applications written in different languages. Use of the term communication stack is also not intended to be limiting; indeed the invention may be equally used with any kind of system that requires the scheduling of a communicating module or the like. It will be similarly appreciated that the present invention can be used in fields other than telecommunications."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["An embodiment of the invention will now be described, by way of example only, with reference to the accompanying drawings, in which:",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 6","FIG. 5"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
