---
title: Support vector machine using iterative chunking and violators
abstract: An implementation of SVM functionality improves efficiency, time consumption, and data security, reduces the parameter tuning challenges presented to the inexperienced user, and reduces the computational costs of building SVM models. A computer program product for support vector machine processing in a computer system comprises computer program instructions for storing data, providing an interface to client software, building a support vector machine model on at least a portion of the stored data, based on a plurality of model-building parameters, estimating values for at least some of the model-building parameters, and applying the support vector machine model using the stored data to generate a data mining output.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07937351&OS=07937351&RS=07937351
owner: Oracle International Corporation
number: 07937351
owner_city: Redwood Shores
owner_country: US
publication_date: 20090119
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["This application is a continuation of U.S. application Ser. No. 10\/927,111, filed Aug. 27, 2004, now U.S. Pat. No. 7,490,071, issued Feb. 10, 2009, which claims the benefit under 35 U.S.C. 5 119(e) of provisional application 60\/498,699, filed Aug. 29, 2003.","1. Field of the Invention","The present invention relates to providing an implementation of Support Vector Machines functionality integrated into a relational database management system","2. Description of the Related Art","Support Vector Machines (SVM) is a state-of-the-art data mining algorithm which has been used with great success in challenging domains such as text mining and life sciences. However, there are a number of problems with conventional implementations of SVM. For example, in conventional implementations, users have to export their data outside of the database and then use stand-alone packages to build and score SVM models. This approach is inefficient, time consuming, and compromises data security.","Another problem with conventional implementations is that building SVM models represents a significant challenge to the inexperienced user. Often, in order to produce a reasonable model, extensive parameter tuning is required. The users have to search the parameter space\u2014usually via a grid search\u2014for a combination of values that produces satisfactory accuracy and\/or scoring performance. This is a time consuming and laborious process exacerbated by the fact that these parameters interact. In addition, building SVM models requires considerable system resources (memory and CPU). This problem is typically solved by learning on subsets (chunks) of the data. These chunks are updated at every iteration and the model build continues until the convergence conditions on the entire dataset are met. Usually chunks are composed from the examples that violate convergence conditions to the greatest extent. Finding the worst violators is computationally expensive. Additionally, this approach can result in oscillations that slow down the build process significantly.","A need arises for a technique by which SVM may be implemented that improves efficiency, time consumption, and data security, which reduces the parameter tuning challenges presented to the inexperienced user, and which reduces the computational costs of building SVM models.","The present invention provides an improved SVM processing functionality. This improves efficiency, time consumption, and data security, reduces the parameter tuning challenges presented to the inexperienced user, and reduces the computational costs of building SVM models. Preferably, the SVM functionality is implemented as a table function (trusted C callout) that is directly accessible via SQL statements. This greatly enhances the usability of the SVM functionality, improves efficiency, and reduces data movement and storage requirements. During scoring, the algorithm may employ the framework of the database and thus achieve better performance\/scalability by fully utilizing the existing system resources. Alternatively, SVM functionality may be implemented using code implemented in the database kernel.","The SVM implementation of the present invention includes a computationally inexpensive method for automatic parameter estimation to simplify the building of high quality, well-performing SVM models. This allows the user to build an accurate, high performance model without parameter tuning.","The present invention provides a method for partial random chunk selection. When SVM models are trained via chunking, oscillations can sometimes occur when chunks are selected entirely on the convergence condition ranking. Additionally, computing the ranks for the entire dataset, after each iteration, is expensive. In the present invention, the chunks are composed from two different groups of vectors: current violators and members of the previous chunk. This results in a smoother, less oscillating build process. This smoothing strategy results in considerable decrease of oscillations and faster SVM builds.","In one embodiment of the present invention, a system for support vector machine processing comprises data stored in the system a client application programming interface operable to provide an interface to client software, a build unit operable to build a support vector machine model on at least a portion of the data stored in the system, based on a plurality of model-building parameters, a parameter estimation unit operable to estimate values for at least some of the model-building parameters, and an apply unit operable to apply the support vector machine model using the data stored in the system.","In one aspect of the present invention, the parameter estimation unit may be further operable to select a kernel type method. The kernel type method may be selected from a linear kernel function and a non-linear kernel function based on an effective dimensionality of training data.","In one aspect of the present invention, the parameter estimation unit may be further operable to select a complexity parameter C method. The complexity parameter C method may be selected for a classification method. The classification method may be a binary classification method or a multi-class classification method. The parameter estimation unit may be further operable to select the complexity parameter C method for a linear kernel method. The complexity parameter C method may be selected for a linear kernel method by selecting a random sample comprising k pairs of training vectors of opposite class, one member of each pair being of positive class and one member of each pair being of negative class, for each pair, assigning C to have a value such that a margin for the positive class is 1 and a margin for the negative class is \u22121, ordering the assigned values of C, and selecting as C a k-th highest assigned value of C.","In one aspect of the present invention, the parameter estimation unit may be further operable to select the complexity parameter C method for a Gaussian kernel method. The complexity parameter C method may be selected for a Gaussian kernel method by selecting a random group comprising k examples of positive class and k examples of negative class, predicting a class for each member of the random group, wherein the examples are support vectors with a constant value of alpha, removing examples that predict a wrong class, for each remaining example, estimating C as a value required to separate the example from all other group members with a margin of 1, ordering the estimated values of C, and selecting as C a k-th highest estimated value of C. The parameter estimation unit may be further operable to select the complexity parameter C method for a regression method. The complexity parameter C method may be selected for a regression method by selecting a value of C that is a multiple of a target class standard deviation.","In one aspect of the present invention, the parameter estimation unit may be further operable to select the complexity parameter C method for a one-class support vector machine method. The complexity parameter C method is selected for a one-class support vector machine method by selecting an initial value of C, increasing the value of C, while an outlier rate with the initial value of C is above a user-specified value, setting C to an average of a current value of C and a previous value of C, once the value of C is above the user-specified value, until a target outlier rate is substantially achieved or a maximum number of iterations is reached.","In one aspect of the present invention, the parameter estimation unit may be further operable to select a standard deviation \u03c3 for a Gaussian kernel method. The parameter estimation unit may be further operable to select a standard deviation \u03c3 for a Gaussian kernel method for a classification method. The standard deviation \u03c3 for a Gaussian kernel method for a classification method may be selected by selecting k pairs of training vectors of opposite class, one member of each pair being of positive class and one member of each pair being of negative class, for each pair, computing an estimate of \u03c3 based on a distance between members of the pair, and selecting as \u03c3 a k-th highest estimated \u03c3. The parameter estimation unit may be further operable to select a standard deviation \u03c3 for a Gaussian kernel method for a regression method. The standard deviation \u03c3 for a Gaussian kernel method for a regression method may be selected by selecting pairs of random points from the data, for each pair, determining distances between members of the pair, ranking the determined distances, and selecting as \u03c3 a k-th highest distance percentile of the ranked distances.","In one aspect of the present invention, the parameter estimation unit may be further operable to select a standard deviation \u03c3 for a Gaussian kernel method for a one-class support vector machine method. The standard deviation \u03c3 for a Gaussian kernel method for a one-class support vector machine method may be selected by selecting pairs of random points from the data, both members of each pair being of the one class, for each pair, determining distances between members of the pair, ranking the determined distances, and selecting as \u03c3 a k-th highest distance percentile of the ranked distances.","In one aspect of the present invention, the parameter estimation unit may be further operable to select an \u03b5 parameter for a regression method. The \u03b5 parameter for a regression method is selected by selecting an initial value of \u03b5, selecting a random sample of data, converging on the random sample of data, estimating prediction noise using a held-aside data set, repeatedly adjusting \u03b5 to be a function of the residuals computed on held-aside data, selecting as \u03b5 an adjusted value of \u03b5 that produces a lowest residual on the held-aside data set.","In some problem domains, the data available for model building may consist of members of a single class. Examples include outlier detection, in which the goal is to identify \u201ctypical\u201d members of a multi-dimensional distribution; fraud detection, where only instances of the non-fraud are available or where only non-fraud cases are assumed to be similar to each other; diagnosis assistance, for which only instances of the disease are available and assumed to have similar character. For such domains, the support vector machine model may be a \u201cone-class classifier\u201d support vector machine algorithm.","In one aspect of the present invention, the build unit may be further operable to build a support vector machine model on at least a portion of the data stored in the database management system using stratified random sampling.","In one aspect of the present invention, the processing unit may further comprise an incremental update unit. The incremental update unit may be operable to incorporate additional data into an existing model without rebuilding the entire model. The incremental update unit may be operable to adapt an existing model to a stream of data wherein an underlying distribution changes over time. The incremental update unit may be operable to perform incremental learning.","In one aspect of the present invention, the build unit may comprise a table function. The apply unit may comprise a table function.","In one aspect of the present invention, the build unit may be operable to use a pivot method to filter transactional data and to use a reverse pivot method to process non-transactional data. The apply unit may be operable to use a pivot method to filter and split transactional data and to use a reverse pivot method to process non-transactional data. The build unit may comprise a table function. The apply unit may comprise a table function.","In one aspect of the present invention, the build unit may be operable to use a pivot method to filter transactional data and to use a reverse pivot method to process non-transactional data. The apply unit may be operable to use a pivot method to filter and split transactional data and to use a reverse pivot method to process non-transactional data.","The present invention provides an implementation of SVM functionality integrated into a relational database management system (RDBMS). This improves efficiency, time consumption, and data security, reduces the parameter tuning challenges presented to the inexperienced user, and reduces the computational costs of building SVM models. The implementation of the present invention integrates SVM functionality with data mining functionality in an RDBMS. Preferably, the SVM functionality is implemented as a table function (trusted C callout) that is directly accessible via SQL. This table function is an internal API that can be directly invoked by internal users (e.g., currently used by text processing functions). The external API wraps the table function call in a PL\/SQL procedure (or Java). The table function implementation facilitates integration with the core database functionality. The data source is a cursor and the original data can undergo a variety of transformations without materialization before being supplied to the SVM algorithm. This greatly enhances the usability of the algorithm, improves efficiency, and reduces data movement and storage requirements. During scoring, the algorithm can employ the parallel framework of the database and thus achieve better performance\/scalability by fully utilizing the existing system resources.","The SVM implementation of the present invention includes a computationally inexpensive method for automatic parameter estimation to simplify the building of high quality, well-performing SVM models. The methodology used has a number of factors.\n\n","In addition, the present invention provides a method for efficient decomposition. When SVM models are trained via chunking, oscillations can sometimes occur when chunks are selected entirely on the convergence condition ranking. Additionally, computing the ranks for the entire dataset, after each iteration, is expensive. In this approach, the chunk is composed from two different groups of vectors: current violators and members of the previous chunk. This results in a smoother, less oscillating build process. There are two stages in the violator selection process. First, the mean violation across all violators is computed, the violators are scanned starting at a random point in the violator list, and only the ones above the mean are chosen. Second, if not enough examples were selected during this first pass, additional violators are randomly selected to fill up the chunk. From the members of the previous chunk, the non-bounded support vectors (up to 50% of the chunk capacity) are retained and if there are not enough non-bounded support vectors, other members of the previous chunk are added to achieve smoothing. This smoothing strategy results in considerable decrease of oscillations and faster SVM builds.","The present invention uses stratified sampling methods with respect to the target distribution. SVM model build times scale quadratically to cubically with the number of training data records. To achieve reasonable build durations, often only a sample of the available data is used. Random sampling has been shown to produce inadequate models in cases where the target distribution is skewed. In classification, often some target classes dominate while some other classes are under-represented. In the case of regression, the continuous target may be concentrated in certain ranges while the coverage in other areas is poor. A small random sample will fail to provide the SVM algorithm with adequate information about the classes\/ranges that are under-represented.","We introduce a stratified sampling approach that aims at creating a balanced sample with respect to the target distribution. This usefulness of this approach is not restricted to SVM but extends also to any type of data mining algorithm that requires data sampling. For SVM classification, the balancing can be accomplished in two stages: 1) initial data read and 2) pool creation. During the initial data read the goal is to create a stratified sample using a single scan of the dataset. The task is non-trivial since the nature of the data is completely unknown\u2014there is no information available in advance regarding the total number of records, target cardinality, and target distribution. For the sake of efficiency and to reduce complexity, several simplifying assumptions need to be made: 1) the data cursor is randomized with respect to sequence id order of presentation; 2) regardless of the nature of the data mining classification problem, an individual target value can be adequately represented by a pre-defined number of examples (e.g., 50K); and 3) given a stratified sample across target values, a multi-class classification problem can be adequately modeled by a predefined number of records (e.g., 500K) across all target values. The last assumption implies that for problems of high cardinality fewer than the pre-specified number of records per target class (e.g., 50K) may be used.","During the data read, an example is retained if it belongs to a target that has not met its quota. If the quota for a given target has been reached, the new example is ignored. The quota for individual targets may be adjusted once the upper bound on the total number of examples (e.g., 500K) is reached. Retaining a new record would require replacing an existing row. Such a situation arises, for example, when the new record belongs to a class that has fewer cases than its allowed quota and is under-represented compared to other target classes. A record must be also retained when a new target value is encountered. The new record replaces the last record in the currently most popular class. If several target values are tied on the maximum count, one of these targets is randomly selected. The quotas per target are subsequently adjusted to the number of examples in the most popular class \u22121.","The second stage of balancing occurs during pool selection for multi-class classification. Multi-class classification is modeled as a collection of binary models. The individual binary models learn to distinguish a given target class from the rest of the data. For active learning, we make use of a pool (subsample of the loaded data). In order to build a good-quality binary model, it is desirable to create a pool stratified with respect to the other target classes. We employ a sampling strategy where target quotas are adjusted dynamically. Ideally, the pool will contain 50% positive cases, 50% negative cases, and the negative cases will be balanced across target values. If this perfect balancing is not possible, the quotas are adjusted such that the pool is always filled to capacity. As a first step the relative percentages of positive vs. negative examples are determined. The second step requires computing the quotas of the negative classes. If some of the negative classes are under-represented, the quotas for the other ones are increased.","Target stratification for regression requires building a target histogram. This is feasible only at the pool creation stage. The initial data read loads a large random sample of the data (e.g., 500K). During pool selection, the target histogram counts govern the quotas for specific target ranges. Ideally, each bin (target range) should be equally represented, however, in order to fill the pool to capacity, the large bins may have higher representation. The individual bin counts are ordered in ascending order then the corresponding quotas are computed adaptively by redistributing the unused data slots among the bins with higher counts.","The technique of the present invention provides a number of significant benefits. For example, implementing SVM as a table function and fully integrating it within the database infrastructure has tremendous benefits over using a standalone tool. The benefits are: no data movement, use of pipelining (no materialization), use of SQL-based transformations in the query, and increased security. The parameter tuning approach of the present invention significantly increases usability, speeds up model build, and produces results comparable to the best grid search approaches that are the current standard in the field. The chunking methodology of the present invention has considerable computational efficiency advantages over the standard chunking methods in the field.","The primary concepts behind the SVM approach and strategies for solving the SVM optimization problem are described below.","Logical rows associated with analysis entities are viewed as patterns in SVM terminology. Each pattern is a vector of predictor values and a target value. SVM uses patterns to predict target values. In SVM binary classification, for example, where the target takes on two values, SVM seeks a boundary separating the two classes. The boundary is a function of the predictor values associated with one or more patterns. The insight is that the points or patterns lying closest to the boundary define the boundary. The other data points are not relevant. The relevant points are called support vectors. The goal of the SVM optimization is to identify the support vectors and assign to them weights that would produce an optimal solution.","Support vector machines belong to a class of algorithms known as kernel methods. Kernel methods rely on applying kernel functions to the input data.","The following kernel functions have been used in SVM applications:","Linear:",{"@attributes":{"id":"p-0051","num":"0055"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"K","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":["x","i"]},{"mi":["x","j"]}],"mo":","}}},{"mrow":[{"mo":["\u2062","\u2062"],"mrow":{"msub":[{"mi":["x","i"]},{"mi":["x","j"]}],"mo":"\u00b7"}},{"munder":{"mo":"\u2211","mi":"k"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msub":[{"mi":["x","ik"]},{"mi":["x","jk"]}],"mo":"\u2062"}}],"mo":"="}],"mo":"="}}}},"Polynomial: K(x,x)=(axx+c), for a dth order polynomial","Gaussian: K(x,x)=exp(\u2212\u2225x\u2212x\u2225\/2\u03c3)","Sigmoid: K(x,x)=tan h(axx+c)","The linear kernel is appropriate for data sets that can be treated accurately as a linear model. In general, data sets with a large number of columns and few rows can be modeled with linear kernels. In low-dimensional datasets, non-linear kernel functions are used to transform the input data into a high dimensional feature space. This high dimensional feature space gives the model flexibility to fit complex non-linear surfaces accurately. High-dimensional feature spaces are sufficient to provide good fits to most training data. In the transformed high-dimensional feature space, the boundary is a hyperplane. In the original input space, the boundary is a complex non-linear partitioning of the multidimensional input space.","SVM kernel functions must conform to Mercer conditions and are called Mercer kernels. Mercer kernels map to inner product feature spaces. They have the following convenient properties:\n\n","Note that some of the Kernels have user parameter settings:\n\n","SVM attempts to find the optimal hyperplane that would provide good generalization when presented with novel data. In the linearly separable case, the optimal hyperplane would be the one with largest \u201cmargin\u201d, that is, the one that will provide the widest and most robust separation between targets. In the linearly inseparable case, SVM balances the flexibility to fit complex non-linear surfaces (capacity of the model) with margin maximization. The margin size counterbalances the richness of the hypotheses sets and prevents over-fit. Increasing the margin, creates a series of hypothesis sets with monotonically decreasing complexity (richness). SVM bounds the generalization error by trading off the training set error for hypothesis set complexity.","There are two types of SVM optimization:\n\n","The choice of norm of the misclassification penalty term leads to different types of soft margin. The L and L norms result in 1-Norm soft margin and 2-Norm soft margin optimization, respectively. The approach that performs better in practice will depend on at least a portion of the data and may be influenced by the type of noise.","The user may specify misclassification costs to alter the optimization performed by the SVM classification build operation. In the primal formulation of SVM, the cost, C, is a weighting factor on the errors made by the model. Differentially weighting the two classes will cause the model to allow more errors, when predicting the class with the higher value of C. Specifying a higher cost for a given class will cause the model to predict that class more often, both correctly and incorrectly. From the user viewpoint it may be that not all misclassifications are equal. In a medical problem, predicting no reaction, when death occurs is a much more serious error, than predicting a mild reaction when no reaction occurs. Or, in a marketing application that is intended to promote sale of a product, given the cost of the promotion and the potential revenue from a sale, it may be 10 times worse to misclassify a potential positive respondent than to misclassify a non-respondent.","SVM can encode the different costs associated with different target classes by using a different scale for the misclassification penalty term in the soft margin optimization.","Class priors are appropriate to classification targets only. Class priors are the prior probabilities assigned to each target class. They act as a weight assigned to each entity based on the value of the target. Methods for incorporating priors use different scales for the misclassification penalty term in the soft margin optimization as described above in the section on misclassification costs. When the data is highly unbalanced SVM often cannot find a good separating plane in the feature space. This is due to the focus of the optimization on the dominant class. Priors can often be used to overcome this deficiency by assigning higher weight to the rare class.","Support Vector Machines evolve a very simple classification concept into a powerful state-of-the-art classifier. Imagine separating two target classes via a predictor hyper-plane. For example, with two predictors, the hyper-plane is just a line. Instances of class 1 are on one side of the line. Instances of class 2 are on the other side. However, straight lines and hyper-planes are rather rigid structures and may often be poor classifiers. To increase the richness of the candidate classifiers, a non-linear transformation is applied to the predictor inputs. In the transformed predictor space, the classifier still appears as a simple hyper-plane or line. In the original input space, similar to Neural Networks, non-linear functions of original inputs span the multidimensional predictor surface.","One SVM optimization problem relates to the hard margin. The simplest SVM model is the so-called maximum\/hard margin classifier. It can be applied to linearly separable data. The goal is to find the largest margin hyperplane that classifies all data points correctly. That is, find\n\nmin, subject to (+)\u22671,\n\nwhere w is the weight vector, xis an input vector, yis the corresponding target, and b is the bias term.\n","It can be shown that the maximal margin hyperplane has a margin 1\/\u2225w\u2225. That is, by minimizing the weights, one maximizes the margin. The SVM optimization problem is a convex quadratic function with linear constraints. Problems of this type are traditionally solved using a Lagrangian function. The primal Lagrangian for the hard margin SVM is given by:",{"@attributes":{"id":"p-0067","num":"0078"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mrow":[{"mi":"L","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["w","b","\u03b1"],"mo":[",",","]}}},{"mrow":[{"mrow":[{"mn":["1","2"],"mo":"\/"},{"mi":["w","w"],"mo":"\u00b7"}],"mo":["\u2062","\u2062","\u2062"]},{"munder":{"mo":"\u2211","mi":"i"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msub":{"mi":["\u03b1","i"]},"mo":"\u2061","mrow":{"mo":["[","]"],"mrow":{"mrow":{"msub":{"mi":["y","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mo":["\u2062","\u2062"],"mrow":{"mi":"w","mo":"\u00b7","msub":{"mi":["x","i"]}}},"mo":"+","mi":"b"}}},"mo":"-","mn":"1"}}}}],"mo":"-"}],"mo":"="},"mo":","}}},"br":[{},{}],"sub":["i ","i"]},{"@attributes":{"id":"p-0068","num":"0079"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mrow":[{"mi":"W","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"\u03b1"}},{"mrow":[{"munder":{"mo":"\u2211","mi":"i"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mi":["\u03b1","i"]}},{"mrow":[{"mn":["1","2"],"mo":"\/"},{"munder":{"mo":"\u2211","mrow":{"mi":["i","j"],"mo":","}},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msub":[{"mi":["y","i"]},{"mi":["y","j"]},{"mi":["\u03b1","i"]},{"mi":["\u03b1","j"]}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mrow":{"msub":[{"mi":["x","i"]},{"mi":["x","j"]}],"mo":"\u00b7"}}}],"mo":"\u2062"}],"mo":"-"}],"mo":"="},{"mrow":[{"mi":["subject","to"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mrow":{"munder":{"mo":"\u2211","mi":"i"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msub":[{"mi":["y","i"]},{"mi":["\u03b1","i"]}],"mo":"\u2062"}}},{"mrow":{"mn":"0","mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":"and","msub":{"mi":["\u03b1","i"]}},"mo":"\u2265","mn":"0."}],"mo":"="}],"mo":[",","\u2062"],"mstyle":{"mtext":{}}}}},"br":{},"sub":"i "},"An alternative SVM optimization problem relates to the soft margin. In this situation, in order to allow for errors in the training data, it is necessary to introduce slack variables in the margin constraints, that is, find",{"@attributes":{"id":"p-0070","num":"0081"},"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":{"mrow":{"mi":{},"mo":"\u2062","mrow":{"mrow":[{"mrow":[{"msub":{"mi":"min","mrow":{"mi":["\u03b6","w","b"],"mo":[",",","]}},"mo":"\u2062","mrow":{"mo":["\u2062","\u2062"],"mrow":{"mi":["w","w"],"mo":"\u00b7"}}},{"mi":"C","mo":"\u2062","mrow":{"munder":{"mo":"\u2211","mi":"i"},"mo":"\u2062","mrow":{"mo":["\uf605","\uf606"],"msub":{"mi":["\u03be","i"]}}}}],"mo":"+"},{"mi":["subject","to"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}],"mo":[",","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}}}},{"mtd":{"mrow":{"mrow":[{"msub":{"mi":["y","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mo":["\u2062","\u2062"],"mrow":{"mi":"w","mo":"\u00b7","msub":{"mi":["x","i"]}}},"mo":"+","mi":"b"}}},{"mn":"1","mo":"-","msub":{"mi":["\u03be","i"]}}],"mo":"\u2265"}}},{"mtd":{"mrow":{"mrow":{"msub":{"mi":["\u03be","i"]},"mo":"\u2265","mn":"0"},"mo":","}}}]}}},"br":{},"sub":["i ","i "],"sup":"th "},"The parameter C controls the trade-off between margin (model complexity) and accuracy on the training data. In practice, C needs to be varied through a wide range of values and the generalization performance needs to be assessed on a separate validation set using cross-validation. An alternative method is where C and kernel parameter are optimized via gradient descent on the estimate of the generalization error bound. Note that the norm of the slack variable term can be either L or L. Using L leads to 1-Norm soft margin optimization (Box Constraints) with the following dual Lagrangian problem:",{"@attributes":{"id":"p-0072","num":"0083"},"maths":{"@attributes":{"id":"MATH-US-00005","num":"00005"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mrow":[{"mi":"max","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mi":"W","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"\u03b1"}}},{"mrow":[{"munder":{"mo":"\u2211","mi":"i"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mi":["\u03b1","i"]}},{"mrow":[{"mn":["1","2"],"mo":"\/"},{"munder":{"mo":"\u2211","mrow":{"mi":["i","j"],"mo":","}},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msub":[{"mi":["y","i"]},{"mi":["y","j"]},{"mi":["\u03b1","i"]},{"mi":["\u03b1","j"]}],"mo":["\u2062","\u2062","\u2062","\u2062"],"mrow":{"mi":"K","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":["x","i"]},{"mi":["x","j"]}],"mo":","}}}}}],"mo":"\u2062"}],"mo":"-"}],"mo":"="},{"mrow":[{"mi":["subject","to"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mrow":{"munder":{"mo":"\u2211","mi":"i"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msub":[{"mi":["y","i"]},{"mi":["\u03b1","i"]}],"mo":"\u2062"}}},{"mrow":{"mn":"0","mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":["and","C"]},"mo":["\u2265","\u2265"],"msub":{"mi":["\u03b1","i"]},"mn":"0."}],"mo":"="}],"mo":[",","\u2062"],"mstyle":{"mtext":{}}}}}},"The 1-Norm soft margin is reduced to the hard margin case by setting C to infinity. Using L norm in the slack variable term leads to 2-Norm soft margin optimization (Weighting the Diagonal) with the following dual Lagrangian problem:",{"@attributes":{"id":"p-0074","num":"0085"},"maths":{"@attributes":{"id":"MATH-US-00006","num":"00006"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mrow":[{"mi":"max","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mi":"W","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"\u03b1"}}},{"mrow":[{"munder":{"mo":"\u2211","mi":"i"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mi":["\u03b1","i"]}},{"mrow":[{"mn":["1","2"],"mo":"\/"},{"munder":{"mo":"\u2211","mrow":{"mi":["i","j"],"mo":","}},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msub":[{"mi":["y","i"]},{"mi":["y","j"]},{"mi":["\u03b1","i"]}],"mo":["\u2062","\u2062","\u2062"],"mrow":{"msub":{"mi":["\u03b1","j"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":[{"mi":"K","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":["x","i"]},{"mi":["x","j"]}],"mo":","}}},{"msub":{"mi":["\u03b4","ij"]},"mo":"\u2062","mrow":{"mn":"1","mo":"\/","mi":"C"}}],"mo":"+"}}}}}],"mo":"\u2062"}],"mo":"-"}],"mo":"="},{"mrow":[{"mi":["subject","to"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mrow":{"munder":{"mo":"\u2211","mi":"i"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msub":[{"mi":["y","i"]},{"mi":["\u03b1","i"]}],"mo":"\u2062"}}},{"mrow":{"mn":"0","mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":"and","msub":{"mi":["\u03b1","i"]}},"mo":"\u2265","mn":"0"}],"mo":"="}],"mo":[",","\u2062",","],"mstyle":{"mtext":{}}}}},"br":{},"sub":"ij "},"In 2-Norm soft margin, the Lagrange multipliers are not bounded from above.","The SVM formulation discussed so far addresses a binary target classification problem. In classification problems with multiple classes, there are two common approaches:\n\n","The second approach is considered more accurate, however, it involves building more SVM models. On the other hand, each model is build on a small amount of data and build times are short. If there is a limited amount of data and a large number of classes, one-vs.-all is the only possible strategy.","SVM predictions in such composite models require ranking of the individual model predictions in the one-vs.-all case. Usually, such rankings are based on the prediction margin or some margin-derived probability. In the one-vs.-one case, the target class that wins most of the pair comparisons is used as a prediction.","When the target has a continuous range, the SVM model learns a non-linear regression function in a kernel-induced linear feature space. As in the classification case, the learning algorithm minimizes a convex functional and its solution is sparse.","SVM regression uses a \u03b5-insensitive loss function, that is, the loss function ignores values that are within a certain distance from the true value. SVM regression attempts to find a function that has at most \u03b5 deviation from the actual target values. This becomes analogous to the classification case, because the algorithm seeks a maximal margin from the line separating over-estimates and under-estimates to the boundaries of the \u03b5-tube wherein the \u201ccorrectly\u201d predicted training data lies. This is achieved via minimization of the weight vector w. Formally, the problem can be stated as:\n\nmin \u00bd, subject to \u2266\u03b5 and \u2266\u03b5.\n","If no feasible solution exists, it becomes necessary to introduce a soft margin function for the regression case that uses slack variables to satisfy the otherwise infeasible constraints of the optimization problem. Analogously to the classification case, 1-Norm and 2-Norm soft margins can be considered. The primal optimization problem for 1-Norm soft margin can be stated as:",{"@attributes":{"id":"p-0082","num":"0095"},"maths":{"@attributes":{"id":"MATH-US-00007","num":"00007"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mrow":[{"mi":"min","mo":["\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},"mrow":{"mn":["1","2"],"mo":"\/"},"msup":{"mrow":{"mo":["\uf605","\uf606"],"mi":"w"},"mn":"2"}},{"mi":"C","mo":"\u2062","mrow":{"munder":{"mo":"\u2211","mi":"i"},"mo":"\u2062","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["\u03be","i"]},"mo":"+","msubsup":{"mi":["\u03be","i"],"mo":"*"}}}}}],"mo":"+"},{"mrow":[{"mrow":[{"mi":["subject","to"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"msub":{"mi":["y","i"]}},{"mo":["\u2062","\u2062"],"mrow":{"mi":"w","mo":"\u00b7","msub":{"mi":["x","i"]}}}],"mo":["-","-"],"mi":"b"},{"mi":"\u025b","mo":"+","msubsup":{"mi":["\u03be","i"],"mo":"*"}}],"mo":"\u2264"},{"mrow":[{"mrow":{"mo":["\u2062","\u2062"],"mrow":{"mi":"w","mo":"\u00b7","msub":{"mi":["x","i"]}}},"mo":["+","-"],"mi":"b","msub":{"mi":["y","i"]}},{"mi":"\u025b","mo":"+","msub":{"mi":["\u03be","i"]}}],"mo":"\u2264"},{"mi":"and","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"msub":{"mi":["\u03be","i"]}},{"msubsup":{"mi":["\u03be","i"],"mo":"*"},"mo":"\u2265","mn":"0."}],"mo":[",","\u2062",",","\u2062",",","\u2062",","],"mstyle":[{"mtext":{}},{"mtext":{}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}}}},"There are two slack variables, one for exceeding the target value by more than \u03b5, the other for being more than \u03b5 below target. Only one of these slack variables can be non-zero at a time. The 2-Norm soft margin requires squaring the slack variables in the cost function and is subject to the same constraints.","The above formulation can be extended to the non-linear kernel case. It can be shown that the dual Langrangian problem for SVM regression can be stated as:","1-Norm soft margin\u2014",{"@attributes":{"id":"p-0085","num":"0098"},"maths":{"@attributes":{"id":"MATH-US-00008","num":"00008"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":{"mrow":[{"mi":"max","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mi":"W","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"\u03b1"}}},{"mrow":[{"munder":{"mo":"\u2211","mi":"i"},"mo":"\u2062","mrow":{"msub":[{"mi":["y","i"]},{"mi":["\u03b1","i"]}],"mo":"\u2062"}},{"mi":"\u025b","mo":"\u2062","mrow":{"munder":{"mo":"\u2211","mi":"i"},"mo":"\u2062","mrow":{"mo":["\uf603","\uf604"],"msub":{"mi":["\u03b1","i"]}}}},{"mrow":[{"mn":["1","2"],"mo":"\/"},{"munder":{"mo":"\u2211","mrow":{"mi":["i","j"],"mo":","}},"mo":"\u2062","mrow":{"msub":[{"mi":["\u03b1","i"]},{"mi":["\u03b1","j"]}],"mo":["\u2062","\u2062"],"mrow":{"mi":"K","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":["x","i"]},{"mi":["x","j"]}],"mo":","}}}}}],"mo":"\u2062"}],"mo":["-","-"]}],"mo":"="},"mo":","}}},{"mtd":{"mrow":{"mi":{},"mo":"\u2062","mrow":{"mrow":[{"mi":["subject","to"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mrow":{"munder":{"mo":"\u2211","mi":"i"},"mo":"\u2062","msub":{"mi":["\u03b1","i"]}}},{"mrow":[{"mrow":{"mn":"0","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mi":"and"},"mo":["\u2062","-"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mi":"C"},{"mi":"C","mo":"."}],"mo":["\u2264","\u2264"],"msub":{"mi":["\u03b1","i"]}}],"mo":"="}}}}]}}},"br":[{},{}]},{"@attributes":{"id":"p-0086","num":"0099"},"maths":{"@attributes":{"id":"MATH-US-00009","num":"00009"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mrow":[{"mi":"max","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mi":"W","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"\u03b1"}}},{"mrow":[{"munder":{"mo":"\u2211","mi":"i"},"mo":"\u2062","mrow":{"msub":[{"mi":["y","i"]},{"mi":["\u03b1","i"]}],"mo":"\u2062"}},{"mi":"\u025b","mo":"\u2062","mrow":{"munder":{"mo":"\u2211","mi":"i"},"mo":"\u2062","mrow":{"mo":["\uf603","\uf604"],"msub":{"mi":["\u03b1","i"]}}}},{"mrow":[{"mn":["1","2"],"mo":"\/"},{"munder":{"mo":"\u2211","mrow":{"mi":["i","j"],"mo":","}},"mo":"\u2062","mrow":{"msub":{"mi":["\u03b1","i"]},"mo":"\u2062","mrow":{"msub":{"mi":["\u03b1","j"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":[{"mi":"K","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":["x","i"]},{"mi":["x","j"]}],"mo":","}}},{"msub":{"mi":["\u03b4","ij"]},"mo":"\u2062","mrow":{"mn":"1","mo":"\/","mi":"C"}}],"mo":"+"}}}}}],"mo":"\u2062"}],"mo":["-","-"]}],"mo":"="},{"mrow":{"mi":["subject","to"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mrow":{"munder":{"mo":"\u2211","mi":"i"},"mo":"\u2062","msub":{"mi":["\u03b1","i"]}}},"mo":"=","mn":"0."}],"mo":[",","\u2062"],"mstyle":{"mtext":{}}}}},"br":{}},"Typically SVM requires the solution of a quadratic programming (QP) problem. The size of the optimization problem depends on the number of training examples. General purpose QP algorithms, such as quasi-Newton and interior point methods, require computation of the covariance matrix (Q=yyK(x, x)).","This computation is quadratic in the number of training examples. For larger learning tasks, it becomes impossible to store the covariance matrix in memory. The literature indicates that SVM is practical in the range of up to several thousands of rows. Techniques for dealing with large data include optimizing the objective functional with respect to subsets of the data\u2014\u201cchunking\u201d and \u201cdecomposition\u201d. This, however, is currently an area of active research and there are many alternatives, for example, incremental learning methods.","The so-called \u201cchunking\u201d approaches start by optimizing the dual QP problem on an initial arbitrary set of data. The algorithm then retains the support vectors found in the chunk of data and uses the hypothesis to test the remainder of the data and find the points that most seriously violate the optimality conditions (KKT conditions). The worst violators are added to the support vectors and this new chunk of data is re-optimized. This procedure is iterated, initializing a for each new sub-problem with the values output from the previous stage, finally halting when the stopping optimality criteria are satisfied.","A potential problem with chunking is that the optimization problem can become too large with the growing number of support vectors.","The decomposition methods also work on a subset of the data set. However, unlike chunking where the subset size grows, decomposition uses a fixed-size subset. A decomposition method updates only a fixed subset of Langrangian multipliers, while the others are kept constant. To add new points to the working subset, the same number of points in the working subset needs to be removed. The major advantage of decomposition is that the QP problem is fixed in size. The nature of the QP optimization make the solution of many small problems more efficient than the solution of one massive problem.","Sequential Minimal Optimization (SMO) can be viewed as the limiting case of decomposition where the working set is reduced to two, that is, only two Lagrange multipliers are optimized at a time. In this case it is possible to derive an analytical solution. This eliminates the need for a QP solver for the sub-problem.","SMO uses a set of heuristics to identify a pair of parameters to optimize. Once the two points are chosen, the analytic optimization follows the procedure described in the next function.","A Two Point Analytic Solution to SMO included the following:","Calculate box constraints:\n\nU\u2266\u03b1\u2266V,\n\n",{"@attributes":{"id":"p-0096","num":"0112"},"maths":{"@attributes":{"id":"MATH-US-00010","num":"00010"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":["E","i"]},"mo":"=","mrow":{"mrow":{"mo":["(",")"],"mrow":{"mrow":{"munder":{"mo":"\u2211","mi":"j"},"mo":"\u2062","mrow":{"msub":[{"mi":["\u03b1","j"]},{"mi":["y","j"]}],"mo":["\u2062","\u2062"],"mrow":{"mi":"K","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":["x","j"]},{"mi":["x","i"]}],"mo":","}}}}},"mo":"+","mi":"b"}},"mo":"-","msub":{"mi":["y","i"]}}}}},"ul":{"@attributes":{"id":"ul0013","list-style":"none"},"li":{"@attributes":{"id":"ul0013-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0014","list-style":"none"},"li":["Update Lagrange multipliers:\n\n\u03b1=\u03b1()\/\u03ba\n","Clip it to enforce box constraints:","if \u03b1<U then \u03b1=U","else if \u03b1>V then \u03b1=V","\u03b1=\u03b1+yy(\u03b1\u2212a)\n\nIf \u03ba is equal to 0, then the objective function needs to be evaluated at both ends of the interval (U and V) and the point that optimizes the objective function is chosen.\n"]}}}},"The optimization described above is a solution to the 1-Norm soft margin case. However, by setting C to infinity, the solution is applicable to the hard margin case as well. 2-Norm soft margin can be solved as a hard margin case when the capacity parameter C is treated as kernel parameter.","The two-point analytical optimization was originally derived for SVM classification but this algorithm is easily adapted to regression cases.","The choice of the pair of examples for optimization is an important consideration. Traditional SMO uses a set of heuristics to identify two candidates whose optimization would produce progress in the overall objective function. An alternative to this approach is where the strategy is to find a pair of examples that will provide the steepest feasible direction of descent. The method relies on a first-order approximation of the target function.","A variety of optimization stopping criteria have been considered:\n\n","SVM classification scores records using the following function:",{"@attributes":{"id":"p-0102","num":"0135"},"maths":{"@attributes":{"id":"MATH-US-00011","num":"00011"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mrow":[{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["x","i"]}}},{"mrow":{"munder":{"mo":"\u2211","mi":"j"},"mo":"\u2062","mrow":{"msub":[{"mi":["y","j"]},{"mi":["\u03b1","j"]}],"mo":["\u2062","\u2062"],"mrow":{"mi":"K","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":["x","i"]},{"mi":["x","j"]}],"mo":","}}}}},"mo":"+","mi":"b"}],"mo":"="},"mo":","}}},"br":[{},{}],"sub":["i","i","i"]},{"@attributes":{"id":"p-0103","num":"0136"},"maths":{"@attributes":{"id":"MATH-US-00012","num":"00012"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["x","i"]}}},{"mrow":[{"munder":{"mo":"\u2211","mi":"j"},"mo":"\u2062","mrow":{"msub":{"mi":["\u03b1","j"]},"mo":"\u2062","mrow":{"mi":"K","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":["x","i"]},{"mi":["x","j"]}],"mo":","}}}}},{"mi":"b","mo":"."}],"mo":"+"}],"mo":"="}}}},"The scalability of the \u201capply\u201d operation is governed by the model complexity. SVM complexity is related to the number of support vectors. The number of support vectors may scale linearly with the number of rows, which implies a practical limit on the training set size. One method, Relevance Vector Machine (RVM), uses a Gaussian prior on the Kernel weights that results in a sparser model and therefore faster scoring. The number of support vectors in RVM is not dependent on the number of training rows. However, RVM has poor scalability.","It is often desirable to be able to estimate the confidence associated with model's prediction. Such estimates allow users to rank the predictions, select decision thresholds, compute lift, etc. Standard SVM were designed as classifiers producing hard class assignments. However, there have been efforts to post-process SVM outputs and recalibrate them into probabilities. SVM's predictions can be ranked on the basis of the margin to the decision surface. That is, the larger the margin, the more confident the prediction. Different recalibration procedures can be considered to translate the margin into probability (e.g., estimating an empirical pdf, fitting a sigmoid, Parzen windows). Using the training set for recalibration can be potentially dangerous because the resulting estimate would be biased. Alternative approaches for computing prediction rank\/probability include using a validation data set, performing cross-validation, perturbing the training data with Gaussian noise.","Additional enhancements may be made that further improve the flexibility and performance of the SVM implementation of the present invention. For example, model size for non-linear models may be reduced and build scalability may be improved. In addition, usability may be increased by introducing model maintenance features. The model maintenance features include incremental learning, adding of targets, and deleting of targets from an existing multi-target model. These features are useful, for example, for text processing.","The additional enhancements may include:\n\n","One of the major problems with the classical SVM approach is that the number of support vectors increases linearly with the size of the training data. This is a very serious problem for models with non-linear kernels where the size of the model depends on the number of support vectors. Increased model size makes building non-linear SVM models impractical. Scoring performance becomes very slow and there are high disk and memory requirements. Models with linear kernels are not as severely affected, since they can be stored as an array of linear coefficients instead of storing the original support vectors. However, some types of incremental training require storing the actual support vectors instead of, or in addition to, the linear coefficients. In such cases, model size for linear kernel SVM would be also dependent on the training data size.","The SVM techniques of the present invention produce small non-linear SVM models by default. This requirement is essential to make non-linear SVM online scoring feasible. Model scoring is expected to improve by several orders of magnitude. Non-linear SVM models should be sufficiently small (\u02dc1 Mb) to be loaded in shared memory, therefore allowing fast apply operation and efficient multi-user support.","The model size reduction will be accomplished via an active learning mechanism that will produce an approximate solution to the SVM optimization problem. Active learning forces the SVM algorithm to restrict learning to the most informative training examples and thus not attempt to converge on the entire body of data.","Sufficient model size reduction would make SVM models a feasible choice for applications that require not only high accuracy but also fast, possibly online, scoring. There are several approaches for model size reduction that may provide improvement.","One approach is the reduced set methods. The idea behind reduced set SVM is to represent the support vectors of an already trained SVM model by a smaller set of support vectors. The reduced set consists of either some of the original support vectors or of newly estimated support vector points that would provide a good approximation to the model. The problem can be formalized as follows:","An SVM model is defined by a set of support vectors and corresponding coefficients. Scoring such a model requires computing the expansion:\n\n=\u03a3\u03b1(),\n\nwhere xis the example being scored, N is the number of support vectors, xare the support vectors, \u03b1 are the support vector coefficients, and K are the kernels. The goal is to make the support vector expansion more compact (with fewer support vectors) and thus reduce storage requirements and make scoring faster. The reduced set expansion can be then defined as:\n\n\u2032=\u03a3\u03b2(),\n\nwhere M is the number of the support vectors in the reduced set, zare the reduced set support vectors, and \u03b2 are the corresponding support vector coefficients. The new support vectors and their coefficients are found by minimizing the error of the new expansion:\n\nmin\u2225y\u2212y\u2032\u2225.\n","The main problem with the reduced set methods is that the approaches are computationally expensive. They require training a full SVM model and subsequently computing a model approximation. Both steps are computationally intensive and place high demands on system resources. Additionally, since this approach is based on post-processing an existing SVM model, scalability with large amounts of data remains unaddressed.","Another approach to reducing model size is Active Sampling Methods. As noted, the number of support vectors in an SVM model scales up with the size of the training data. This property limits SVM's applicability to small and medium size data (<100K training points). A number of recently developed methods decrease model size by using a fraction of the entire dataset. Since random sampling is very inefficient and produces models of poor quality, the central idea of active sampling is to select a set of informative data points and thus maximize performance subject to model size constraints.","The active learning paradigm can be described as follows:","construct a model on a small random sample;","test the entire training dataset against this model;","select additional data points by analyzing the predictions;","retrain\/adapt the model to the new augmented training sample.","The procedure iterates until a stopping criterion is met. In active learning, stopping criteria are usually related to limiting the model size. The build terminates when the upper bound on the number of support vectors is reached. Alternatively, some other qualitative criterion can be used (e.g., there is no significant improvement in model accuracy on a held aside sample).","The objective of prediction analysis is to identify data points that would maximally improve model quality during the next iteration.","Another approach to reducing model size is Data Summarization Driven Methods, such as clustering-based SVM (CB-SVM). CB-SVM is closely related to the active sampling methods and is a clustering-based method for scaling SVM to large datasets. The well-known BIRCH algorithm, a highly scalable clustering algorithm, may be used to decrease the number of training data points presented to SVM. Summarizing the data can be very efficient computationally, however, it may result in loss of resolution and poor accuracy. To overcome this problem, CB-SVM allows finer resolution in regions near the decision boundary. The algorithm constructs two Clustering Feature (CF) trees following BIRCH methodology. One tree summarizes the positive cases, while the other tree summarizes the negative cases. The initial SVM model is trained on the root entries for both trees. The subclusters closest to the margin are \u2018declustered\u2019 thus increasing resolution near the decision boundary. Subclusters far from the boundary would not produce additional support vectors and they are left intact. A new SVM is trained on the augmented data, new candidates for declustering are identified and the process iterates until the clusters near the boundary cannot be further declustered. This technique only works for linear kernels, because the clusters are non-isotropic in the feature space for non-linear kernels.","Another approach to reducing model size is Optimized Random Sampling, which may be well suited to solving SVM optimization problems. Reduced SVM (RSVM) involves a training vector subset being selected from the original body of data and an SVM model being built on the sample. The training patterns are selected at random with the constraint that a point is added to the sample only if it is sufficiently different (measured in terms of Euclidean distance) from the points already selected.","An alternative sampling approach makes use of random sampling techniques developed for combinatorial optimization problems. The initial SVM model is built on a small random sample. Then the points that are identified as violators are given increased weights. They are effectively duplicated in the data to increase their chances of being selected. Another small random sample is subsequently selected (favoring the over-represented violators) and a new model is trained. There is an upper limit on the number of iterations required to train the final SVM. This bound is quasi-linear with the number of training examples.","If a larger dataset is presented, one approach is to sub-sample down to the maximum practical dataset size. Purely random sampling can often be suboptimal for unbalanced data since some of the targets may be under-represented or even unobserved. There are also practical restrictions on the dataset size that can be processed within a reasonable time. For example, SVM models with non-linear kernels scale quadratically or even cubically with the number of records and are impractical for datasets with more than 100K records. SVM models with linear kernels are not immune to the problem. SVM linear regression models may scale extremely poorly with increased number of records when the underlying function is non-linear in nature.","The active learning approach, discussed previously in the context of reducing model size, improves build scalability (both for linear and non-linear kernels) on medium to large datasets. An active learning algorithm will be performant on large amounts of data only if it includes an efficient sampling method. If an algorithm requires repeated scans of the entire dataset, scalability with increasing number of records will be poor. However, at most one full scan through the data is required to select a sufficiently large pool of informative examples. Active learning works against this pool of examples. The SVM build via active learning is able to efficiently process very large datasets which are deemed infeasible for standard SVM.","Another approach to improving scalability is incremental learning. Incremental learning is usually considered from two different perspectives where 1) the goal is to incorporate additional information into an existing model without incurring the cost of rebuilding the model from scratch; or 2) the goal is to adapt the model to a stream of data where the underlying distribution may change over time. The first scenario assumes that the data distribution does not change significantly and there is no need to unlearn previously seen records. The second scenario requires a model to track a continuously evolving data distribution. The influence of older records diminishes over time and the model has to forget or unlearn obsolete data.","Both scenarios can be addressed with exact or approximate solutions. The exact approaches guarantee solutions identical (allowing for machine precision and convergence tolerance) to the solutions that would have been achieved if the dataset were presented to the SVM algorithm in its entirety. An example of an exact solution involves an incremental and decremental SVM algorithm that analytically satisfies all KKT (Karush-Kuhn-Tucker) convergence conditions by maintaining an \u201cadiabatic equilibrium\u201d. As an example, consider the incremental update mechanism. The SVM model constraints can be expressed as:\n\n\u0394\u0394\u03b1+\u03a3\u0394\u03b1and \u0394\u03b1+\u03a3\u0394\u03b1=0,\n\nwhere gis the derivative of the Lagrangian functional with respect to \u03b1, \u0394gis the change required for inclusion of a new example, i is the index of an individual training example, c is the index of the new candidate example added to the model, Q is the kernel convolution of two examples, y is the target value for classification, \u03b1 are the support vector coefficients, and b is the bias term.\n","The changes of SVM parameters maintain equilibrium if:","\u0394b=\u03b2\u0394\u03b1and \u0394\u03b1=\u03b2\u0394\u03b1, where",{"@attributes":{"id":"p-0131","num":"0172"},"maths":{"@attributes":{"id":"MATH-US-00013","num":"00013"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mrow":[{"mo":["[","]"],"mtable":{"mtr":[{"mtd":{"mi":"\u03b2"}},{"mtd":{"msub":{"mi":"\u03b2","msub":{"mi":"k","mn":"1"}}}},{"mtd":{"mi":"\u22ee"}},{"mtd":{"msub":{"mi":"\u03b2","msub":{"mi":["k","s"]}}}}]}},{"mo":"-","mrow":{"msup":{"mi":"Q","mrow":{"mo":"-","mn":"1"}},"mo":"\u2061","mrow":{"mo":["[","]"],"mtable":{"mtr":[{"mtd":{"msub":{"mi":["y","c"]}}},{"mtd":{"msub":{"mi":"Q","mrow":{"msub":{"mi":"k","mn":"1"},"mo":"\u2062","mi":"c"}}}},{"mtd":{"mi":"\u22ee"}},{"mtd":{"msub":{"mi":"Q","mrow":{"msub":{"mi":["k","s"]},"mo":"\u2062","mi":"c"}}}}]}}}}],"mo":"="},"mo":","}}},"br":{}},"If the changes introduced by the new example are small enough not to cause non-bounded support vectors to become bounded and vice versa, the method is conceptually easy to implement. If that is not the case, however, it is necessary to introduce a bookkeeping system that tracks the conversions of the support vectors.","Standard SVM algorithms attempt to maximize the margin between the two classes of examples. The non-bounded support vectors lie on planes where the margin equals 1. In Proximal SVM (PSVM), the standard SVM problem is simplified by replacing the inequality constraints in SVM's formulation with equality constraints. That is, SVM's optimization is traditionally defined as:\n\nmin(\u2225\u03be\u2225), subject to ()\u22671\u2212\u03be,\n\nwhere \u03be are the non-zero slack variables.\n","In PSVM, the constraints are modified to:\n\n()=1\u2212\u03be\n\nThe effect of the change is that the SVM problem can be solved as a system of linear equations instead of as a quadratic optimization problem. This restatement of the problem results in non-sparse SVM models\u2014all examples have non-zero coefficients. The training examples are clustered around the planes where the margin equals 1. PSVM attempts to minimize the distance of the points from each class to the plane around which they are clustered and, at the same time, it attempts to maximize the distance between the two planes. This approach is equivalent to regularized least-squares regression.\n","For linear models, the lack of sparsity does not necessarily pose a serious problem\u2014the model can be stored as an array of linear coefficients and therefore the model size remains constant. However, for non-linear kernels, it is necessary to keep the number of support vectors reasonably small and pre-selection of a sample following RSVM's methodology is recommended.","Apart from simplifying the SVM learning task, Proximal SVM is amenable to incremental\/decremental as well as distributed learning. This is easily illustrated by the form of PSVM's solution:",{"@attributes":{"id":"p-0137","num":"0178"},"maths":{"@attributes":{"id":"MATH-US-00014","num":"00014"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mrow":[{"mo":["[","]"],"mtable":{"mtr":[{"mtd":{"mi":"w"}},{"mtd":{"mi":"b"}}]}},{"msup":{"mrow":[{"mo":["(",")"],"mrow":{"mfrac":{"mi":["I","C"]},"mo":["+","+","-"],"mrow":[{"msup":{"mi":["E","\u2032"]},"mo":"\u2062","mi":"E"},{"mrow":{"mo":["(",")"],"msup":{"mi":["E","i"]}},"mo":"\u2062","msup":{"mi":["E","i"]}},{"mrow":{"mo":["(",")"],"msup":{"mi":["E","d"]}},"mo":"\u2062","msup":{"mi":["E","d"]}}]}},{"mo":"-","mn":"1"}]},"mo":"\u2062","mrow":{"mo":["(",")"],"mrow":{"mrow":[{"msup":{"mi":["E","\u2032"]},"mo":"\u2062","mi":"y"},{"mrow":{"mo":["(",")"],"msup":{"mi":["E","i"]}},"mo":"\u2062","msup":{"mi":["y","i"]}},{"mrow":{"mo":["(",")"],"msup":{"mi":["E","d"]}},"mo":"\u2062","msup":{"mi":["y","d"]}}],"mo":["+","-"]}}}],"mo":"="},"mo":","}}},"br":[{},{},{}],"in-line-formulae":[{},{}],"i":"E=[A\u2212e], "},"Approximate approaches do not always produce results that are as accurate as those from a standard SVM model. Still, approximate methods have the advantage of speed and simplicity, and the quality of results is generally acceptable for the majority of the applications. A simple alternative to the standard chunking mechanism in SVM is where, after learning a chunk, only the support vectors are retained and learning continues on the unseen examples. As a result, the final model does not converge on the entire dataset but only on a fraction of the examples. The approach is similar in spirit to shrinking without verification of convergence on the shrunk examples at the end of learning. This paradigm can be applied to incremental learning by treating the new data as a new chunk. The method is sensitive to the order of presentation of the training examples.","All incremental methods described thus far deal with batch learning. Alternatively, one can assume that there is a (possibly infinite) stream of data that needs to be processed. It is computationally infeasible to keep growing the model over time, so the stream methods do not attempt to find a global solution over time. Instead, they age out old records and produce an approximate solution that reflects the most recent examples. One approach is an online method that performs a stochastic gradient optimization with a weight decay type of regularization. At each iteration, the kernel expansion can grow by one term and its kernel coefficient minimizes the empirical error estimate. The other (older) coefficients decrease monotonically at a predetermined decay rate. The update rules are given by:\n\n\u03b1\u2032(()) and \u03b1=(1\u2212\u03bb\u039b)\u03b1,\n\nwhere t is the index of the current record, i is index of the previously seen records, \u039b is the learning rate, c is an empirical error estimate, f(x) is the model prediction, y is the target value, and \u03bb is the complexity parameter. The support vector coefficients are truncated when they become sufficiently small. There is an upper error bound for this type of algorithm.\n","Another approach is a gradient-based online regression algorithm. The idea is to add new support vectors only if the new example cannot be expressed as a linear combination of the already existing support vectors. Tests of linear independence were previously used to reduce SVM model size as a post-processing step after build. The algorithm uses an online procedure where each new example is tested for \u201capproximate linear independence\u201d. The approximate linear independence condition can be expressed as:\n\n\u03b4=\u2225\u03a3\u03b1\u03c6()\u2212\u03c6()\u2225\n\nwhere t is the index of the current example and \u03b1 are the weighting coefficients for the linear combination of basis vectors. If the current example can be approximated to within a squared error of v, then the record is not considered a support-vector candidate.\n","Only examples that do not pass the independence test can be incorporated as support vectors. Efficient representations of the kernel matrix can be used and the data vector activations (model scoring results) that require storage of matrices with dimension equal to the number of support vectors currently in the model. A potential problem with the approach is that the model will continue growing over time and there is no unlearning mechanism available.","Another extension to RSVM involves, instead of randomly preselecting the candidate support vectors, incrementally increasing the pool of candidates using an information criterion. Essentially, they check for linear independence in the new examples by solving a least-squares problem. The algorithm can operate sequentially (adding one example at a time) or in batch mode. While the proposal can be considered an improvement over the standard RSVM algorithm, many of the basic problems with PSVM\/RSVM remain unaddressed\u2014unbalanced data handling, outlier sensitivity, and multi-class models.","The incremental learning paradigm allows for model refinement and model correction under the assumption that the underlying data distribution for a given target does not change dramatically. Under the assumption of stationary, new data does not negate the information presented on previous training sessions. The model is able to extract additional information from new data and incorporate it by refining the boundary between classes. Such refinements are expected to improve the generalization performance. On the other hand, if the underlying process is quasi-stationary, the model will become biased towards recent data. The reason for this bias is that the existing SVM model will be relying only on support vectors to encode previously seen data. Records that were not selected as support vectors during previous builds will not affect subsequent training sessions. Such records will effectively be forgotten by the model. Thus there is an inherent bias towards recent records and small shifts in the distribution will be incorporated into the model.","The paradigm described here does not have an explicit forgetting mechanism. That is, support vectors in the model will not be retired on the bases of their timestamp. As a result, SVM, even in incremental mode, will not be able to track a constantly evolving distribution. Thus, for non-stationary data, rebuilding the model is recommended. For multi-target models, if the non-stationary behavior is restricted to individual targets, these targets could be deleted or added, as appropriate, through the incremental mechanism while leaving the rest of the model intact.","SVM incremental model update will be appropriate under several scenarios:\n\n","Incremental learning uses the new examples and the existing support vectors to create a training dataset. The algorithm gives equal weight to each new data point and each support vector from the original model. If the user chooses to provide corrective feedback information in order to improve model performance, there is no guarantee that incremental learning will ensure correct prediction of the examples provided by user feedback in the updated model. If an example is a strong outlier with respect to the model internal representation, the prediction of the updated model may not change. In order to achieve good generalization performance and avoid learning noisy data, the SVM algorithm allows for errors on the training data. Repeated presentation of the same examples will result in model bias and increase the likelihood that these cases will be predicted correctly increases. However, creating such bias may also cause other, previously correctly classified, examples to be misclassified by the updated model.","Incremental model update for SVM can be used for multi-target binary models. In multi-target binary problems, a single training example may be assigned to multiple targets. SVM builds an independent binary model for each target. A training example is considered a positive instance for each of the targets with which it is associated and a negative instance for all other targets. The negative instances are also referred to as counterexamples. Thus each training example is considered as either a positive case or a counterexample during the model builds for each target.","Following the same line of reasoning, incremental learning for multi-target binary problems also assumes that a training case is a positive instance for the targets with which it is labeled and a counterexample for every other target. A new training case, presented during incremental learning, will be used as either a positive or negative instance for all existing binary models. That is, each binary model will be updated to incorporate the new example. This behavior is consistent with SVM's training case treatment within the multi-target non-incremental framework.","Incremental model update works seamlessly with the active learning approach. Reducing the number of support vectors has a great impact in the context of incremental model updates. Active learning considerably speeds up model updates with negligible or small loss of accuracy. In general, scoring performance for linear models is affected by reduced model size since it depends on the number of non-zero attribute coefficients and not on the number of support vectors. An exception to this occurs with sparse data (e.g., text mining) where fewer support vectors are likely to produce fewer non-zero attribute coefficients per binary target and therefore faster models.","Standard supervised binary classification algorithms require the presence of both positive and negative examples of a target class. The negative examples are often referred to as counterexamples. In some domains, it is a challenge to provide a useful and representative set of counterexamples. The problem exists mostly in cases where the target of interest is easily identifiable but the counterexamples are either hard to specify or expensive to collect. A typical case is text document classification. It is easy to classify a document under a given topic. However, the universe of documents not belonging to this topic can be very large and it may not be feasible to provide informative counterexamples.","One-class SVM was initially used as an estimator of the support of a distribution. The goal is to estimate a function that will be positive if an example belongs to a set and negative if the example belongs to the complement of the set. Regularization is achieved by controlling the length of weight vector in the associated feature space. The method does not attempt to estimate the distribution density. Instead, it computes a binary function that identifies regions in the input space where the majority of the data lives.","The data points are mapped into the feature space via kernel transformations. The strategy is to separate the data from the origin in dual space with maximal margin. Different types of kernel functions result in a variety of nonlinear estimators in the input space. Then standard SVM methodology can be applied. For certain domains, the input vectors are scaled to a unit length (e.g., text mining). In such cases, it is possible to use linear kernel SVM models to discriminate against the origin following methodology. This linear approach would be practical only for data of high-dimensionality.","An alternative formulation of the problem Support Vector Data Descriptions (SVDD) is where the data is described by spheres in feature space. The SVM functional is given by:",{"@attributes":{"id":"p-0154","num":"0198"},"maths":{"@attributes":{"id":"MATH-US-00015","num":"00015"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mrow":[{"munder":{"mi":"min","mrow":{"mi":["R","\u03be"],"mo":","}},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msup":{"mi":"R","mn":"2"}},{"mi":"C","mo":"\u2062","mrow":{"munder":{"mo":"\u2211","mi":"i"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mi":["\u03be","i"]}}}],"mo":"+"},{"mrow":[{"mi":["subject","to"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"msup":{"mrow":{"mo":["\uf605","\uf606"],"mrow":{"mrow":{"mi":"\u03a6","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["x","i"]}}},"mo":"-","mi":"c"}},"mn":"2"}},{"msup":{"mi":"R","mn":"2"},"mo":"+","msub":{"mi":["\u03be","i"]}}],"mo":"\u2264"}],"mo":[",","\u2062",","],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}}},"br":[{},{},{}],"in-line-formulae":[{},{}],"i":["f","x","R","K","x",",x","K","x",",x","K","x,x"],"sup":"2","sub":["i,j","i","j","i","j","i","i","i"]},"One-class SVM models will be built under two scenarios: 1) all training examples belong to a single class; and 2) a novel target is presented to a multi-target model during incremental model update with all records in the new data being instances of the new target.","At apply time, the model produces a prediction and an associated probability whether the new example is a typical representative of the class of interest or not. A prediction value of 1 indicates that the example can be considered typical while a prediction value of 0 classifies the example as an outlier. Similarly to standard binary classification, it is possible to choose a probability decision threshold different from 0.5 thereby changing the outlier cutoff point. Alternatively, it is possible to consider the ordered list of class 1 predictions (ordered by probability) and examine the most typical cases (TopN predictions) or largest outliers (BottomN predictions).","The rate of negative predictions can be controlled via two parameters: outlier rate and complexity factor. The outlier rate sets the desired rate of negative predictions on the training data. The SVM algorithm will attempt to achieve the desired rate within certain degree of precision. Once the model is built, the outlier rate on unseen data from the same distribution is expected to be similar to that on the training data. If the distribution of the apply data changes (e.g., the distribution is augmented with counterexamples), the outlier rate is the expected to reflect the false negative rate\u2014the number of positive cases that will be incorrectly classified as negative. Often a domain expert can provide a good estimate of the typical false negative rate. Such rate will produce a one-class SVM model with a good operating point.","The complexity factor parameter controls the capacity of the model and also has a direct effect on the rate of negative predictions. Increasing the complexity factor creates models with lower rate of negative predictions. The complexity factor mechanism allows for a finer and more controlled grid search than specifying the outlier rate parameter directly.","It should also be noted that the geometry of one-class optimization places certain requirements on the input training data. One-class models with a linear kernel require that the data records be normalized to unit length. While such data is common for certain types of applications (e.g., text mining), in other cases the unit length normalization will have to be performed internally. In order to perform meaningful internal unit length normalization, the individual attributes need to be on a similar scale.","The behavior is the following: if one-class learning is required and the kernel is linear, the algorithm will internally perform unit-length normalization unless a flag is passed to the table function indicating that the data is already unit length normalized. Non-linear kernels would not require special data preparation. Linear kernel models are expected to be useful in one-class context only when the dimensionality of the input space is sufficiently high. If that is not the case, non-linear kernels must be the preferred option.","Using unit-length normalization with linear kernels will make SVM's linear coefficients less intuitive and harder to interpret in terms of attribute units and scale. However, even if this is not a typical linear model, the coefficients would still be useful for analysis in terms of the size of attribute relative impact and the sign of that impact (either positive or negative).","A new, previously unseen, target can be added to an existing multi-target model using the incremental model update mechanism. Novel targets and additional data for old targets would be handled appropriately from the algorithm point of view and transparently from the user perspective. The user would be allowed to provide all newly available data (records for new and\/or pre-existing targets) for model update in one single incremental session.","Adding a new target to an existing model requires special handling from algorithm point of view. It would be unreasonable to assume that all previously existing support vectors in an SVM model represent counterexamples to the new target since this target did not exist at the time these records were labeled. Ideally, the old records should be re-labeled with respect to the new target and the model should be rebuilt. However, re-labeling old records with the new target and rebuilding the model from scratch would place an unreasonable burden on the user. To address this problem, a one-class approach is adopted\u2014if all new training examples in an incremental batch belong to a novel target, a one-class SVM model will be built for the new target and added to the collection of binary models for the other targets. The one-class model would estimate a function that predicts membership in the new target if the example belongs to a set and non-membership if the example belongs to the complement of the set. The support vectors already in the SVM model will not be used as counterexamples.","Building a one-class model does not require the presence of counterexamples. It has been shown, however, that one-class models are generally inferior to models built with counterexamples. Therefore one-class models would only be built if every example in the incremental batch belongs to the same previously unseen target. If some of the records in the incremental batch are associated with different targets, they will be used as counterexamples. For instance, if besides the new target examples, the incremental batch contains additional records for other older targets, these records will be used as counterexamples for the new target. The approach also allows for more than one novel target to be introduced simultaneously\u2014the records associated with one of the new targets will be treated as counterexamples for the other new targets. The presence of counterexamples would make building one-class models for the new targets unnecessary.","Introducing a novel target as a one-class model can be considered a bootstrapping mechanism when counterexamples are not readily available. Even if a given target starts as a one-class model, subsequent incremental learning sessions are likely to provide counterexamples and the model for this target will evolve into a standard binary classification model. It should be noted that the binary models for already existing targets will always be updated during incremental learning even if the incremental batch contains no positive instances of a given target. That is, all pre-existing binary models will be updated using the new cases as either positive examples or counterexamples. The new cases from the incremental batch would be used together with the support vectors of a target to produce a refined model.","To improve usability and avoid frequent model rebuilds, the user can remove a target from an existing SVM multi-target classification model. Even if a target is of no interest, the user incurs the cost of scoring this target and filtering it subsequently. Deleting a selected target reduces the size of the model. It speeds up scoring and eliminate prediction filtering for obsolete targets. The delete target capability can be used as a standalone feature or in conjunction with incremental learning.","A fraction of the Lagrangian coefficients need to be initialized appropriately to meet this condition. The coefficients initialized with non-random values are selected at random.","Error bars are the standard means of estimating the uncertainty associated with the predictions of a regression model. Error bars are generally computed at user-specified level of confidence. For example, in least-mean-squares linear regression, the error bar estimation represents an integral part of the process.","The SVM regression model uses an \u03b5-insensitive loss function during optimization. Any points that fall within the \u03b5-tube are not considered errors and do not become support vectors. A weakness of the SVM regression framework is that is does not allow for error bar estimation. SVM regression may be cast as a Gaussian process and may employ Bayesian methods to derive error bar approximations. The prediction error has two components\u20141) variance inherent to the SVM model, and 2) variance due to the intrinsic noise in the data. The second component can be expressed using \u03b5 and the complexity parameter:\n\n\u03c3=2\/+\u03b5(\u03b5+3)\/(3(\u03b5+1)).\n\nIf \u03b5 and complexity were appropriately selected, they already capture the intrinsic noise in the data. The variance in prediction due to model uncertainty can be expressed as:\n\n\u03c3,\n\nwhere z is the scored record, M is the number of support vectors, and K is the kernel function. The computation requires storage of the model support vectors. If the number of support vectors is large, the inversion of the kernel matrix may become a computationally expensive operation with high demands on memory. Therefore, error bars estimation for SVM models will be feasible only for models of moderate size. Restricting the SVM model size is a prerequisite for enabling error bar computations.\n","SVM non-linear kernels allow mapping the input data into a high-dimensional feature space. The high-dimensional space allows the problem to be treated as linearly separable. A common non-linear kernel type is Gaussian kernel functions. Gaussian kernels are often preferred over other non-linear kernels since they capture the local behavior of the data well. In addition, Gaussian kernels have a single tunable parameter and they have desirable numerical properties\u2014they are bounded and there are no overflows. However, Gaussian kernels rely on Euclidian distances and this can be problematic in high dimensional input spaces. Other popular kernel types are also available, such as polynomial and sigmoid kernels.","SVM kernel functions need to satisfy Mercer's conditions to be considered admissible kernels. Admissible kernels must have positive semi-definite kernel matrices. The SVM optimization in the dual space is guaranteed to find the global minimum in the primal space only for admissible kernels. Examples of such kernels are Gaussian and polynomial. Polynomial kernels have been shown to produce better models than Gaussian kernels on certain types of data. However, to incorporate polynomial kernels in the SVM product, one has to address the potential numerical instabilities and devise strategies for tuning three kernel parameters. The sigmoid kernel matrix is positive semi-definite only for certain kernel parameter choices. As a practical matter, any method estimating the two sigmoid kernel parameters must take into account the admissibility constraints. This is a non-trivial task.","The present invention provides automatic selection of appropriate kernel type based on a simple property of the data: the effective dimensionality. High dimensional data is likely to be linearly separable, because of the inherent degrees of freedom. Hence linear kernels are often an appropriate choice. Low dimensional data, with fewer degrees of freedom, may require more powerful kernels to achieve an accurate fit.","The following sections will outline several usage scenarios.","Active learning case\u2014a typical business problem has a moderate number of attributes and a large number of records. The low dimensionality requires the usage of a non-linear kernel. A non-linear SVM model build on a dataset of large size has typically many support vectors. Such a model would be too slow to use for scoring large amounts of data or in an online scoring application. Building an SVM model with active learning enabled, would produce a smaller model (possibly at the cost of somewhat poorer accuracy). The new model will have significantly better scoring performance.","One-class models can be used to rank data points on the basis of how typical they are with respect to the training data distribution. This ranking can be then used to identify the N largest outliers\u2014the examples with lowest probability for prediction=1 (for all examples, we consider their probability of being positive). In this scenario, the key requirement is that the model provides a reliable ranking. Looking for a probability decision threshold to act as an outlier cutoff point is not strictly necessary. Often, only the strongest N outliers need to be identified\u2014for example, due to limited resources, only a small number of outlier cases can be investigated.","The outlier detection methodology relies on building a model that identifies correctly the large body of the data. The probability ranking reflects the relative distance of the outlier points from the bulk of the distribution. To process a predetermined number of outliers (e.g., 1% of the data), the user can either set the desired outlier rate during build or can use the probability ranking of the apply output and select the desired number of cases from the ranked list. The latter approach is, in most cases, the preferred option.","Anomaly detection has a different objective from outlier detection\u2014it tries to discriminate between cases that belong to the distribution of the training data and examples from a novel unseen distribution. For example, a network intrusion detection model can be built on data points capturing normal patterns of behavior. Such a model should be able to detect previously unknown deviations from the normal behavior (e.g., new types of attack) and trigger alarms. Under this scenario, the user is expected to specify during the model build an acceptable outlier rate (rate of incorrect negative predictions). Essentially, the model trades the two types of errors\u2014incorrect negative predictions (false negatives) and false alarms (false positives). Setting a very low outlier rate may results in a high number of false alarms which require investigation. A domain expert can often provide a good estimate of an appropriate false negative rate. Once the outlier rate is specified the one-class SVM model optimizes the decision boundary that will achieve good discrimination between the training data distribution and the unknown set of counterexamples.","It should be noted that for one-class models in general (both types of kernels), it is recommended that the user transform individual data attributes to a similar scale (e.g., by using min_max normalization). If attributes are on a different scale, the kernel computation will be dominated by the attributes on higher scales. This effect is usually undesirable.","A multi-target SVM model is built to classify a collection of documents. Over time more data may become available. The model will be updated periodically via the incremental learning mechanism without incurring the expense of building it from scratch. User feedback will be also incorporated into the model via the corrective learning option. As the document collection evolves, some of the targets may become obsolete and they will be removed from the model via the delete target API. When a new target emerges, it will be added to the model using incremental learning. This will allow the maintenance of a powerful and flexible SVM model.","An exemplary software block diagram of a database management system  incorporating the present invention is shown in . The SVM algorithm is part of the data mining functionality  of the database management system. The data mining functionality  represents a collection of PL\/SQL procedures, C table functions, and C kernel code. The layering of the individual components is shown in .","The dbms_data_mining package  provides public interfaces for model creation, scoring, deletion, renaming, export\/import, and other test utility functions. These operations are invoked through a dbms_data_mining_internal wrapper . The SVM algorithm module is implemented as a trusted C table function and C kernel code . The adaptors  are internal modules that transform the input data into an appropriate format for the internal table function API. For SVM, the adaptor code performs remapping of attribute names to attribute ids, remaps target values in classification, and explodes categorical attributes into a collection of binary numeric attributes. The public PL\/SQL API accepts 2D tables or views which can have nested table columns. In addition to mapping, the adaptor also un-nests nested table columns.","The dictionary  consists of tables that maintain metadata about models. Models behave like schema objects through this dictionary even though they are not schema objects in the RDBMS.","An example of an implementation  of SVM, according to the present invention, is shown in . Exemplary implementation  includes a PL\/SQL server Application Programming Interface (API) , PL\/SQL packages , and SVM table functions  and . The server API  for SVM may be composed of several PL\/SQL procedures that allow the user to construct a specification for an SVM model as the result of a build task and to score models already stored in the RDBMS. The outputs from server API  are passed to the PLS\/SQL procedures .","The PL\/SQL procedures  includes two main functions\u2014procedures for build  and procedures for apply . The procedures  for the build process acts as a wrapper to the Table Function routines  for SVM model build and basically performs preprocessing of input data The build PL\/SQL procedures may be invoked with parameters such as the table name for build input data, the name of the mining function the build function is to use to build the SVM model, the name to be given to the model when persisting the model, and the name of a table with the function settings and algorithm settings.","The PL\/SQL procedures  for build may perform processing  such as that shown in . Processing  begins with step , in which input parameters, such as mining function settings and algorithm settings are read. In step , the input data table is prepared by un-nesting nested columns, mapping attributes, and exploding categorical attributes. In step , a Table Function build routine is called to build an SVM model. In step , the metadata resulting from the model build is saved to in the RDBMS. In step , the temporary tables used by the adaptor module  are dropped.","The PL\/SQL procedures for the apply process acts as a wrapper to the SVM Apply Table Function.","The PL\/SQL procedure  for apply may perform processing  such as that shown in . Processing  begins with step , in which input parameters, such as the table name for apply input data, the name of the model upon which the apply function is to be performed and the name of the output table are read. In step , the input table data categories are exploded into a set of binary columns, nested table columns are un-nested, and the attributes are mapped to numbers if necessary. In step , the apply table function routine is called to apply the SVM model. In step , the temporary tables created by the adaptor module are dropped.","The processing performed by the Table Function build routine to build an SVM model in step  of  is shown in more detail in . There are two inputs to the build function\u2014training data  and settings . For SVM, preferably the numerical columns are appropriately normalized\/scaled in order to 1) avoid biasing the model toward attributes with larger original scale and 2) avoid numerical instabilities within the algorithm. The adaptor module  performs additional internal data manipulations that include exploding categorical attributes into binary numeric attributes, remapping all attributes (including the ones resulting from explosion) to attribute ids, and remapping the target values for classification. If the input table\/view has nested columns, the adaptor performs un-nesting, categorical explosion, and remapping.","The second source of user input is a setting . The settings allow the user to customize the model build. If the user does not provide settings, internal default values are used. The module  creates and validates an internal settings table based on user provided and\/or default setting values.","The transformed data and settings cursors are used as inputs to the SVM internal table function . Information passed to the table function includes the model name, a mining function parameter that specifies whether a classification or regression model should be built, and other information. The table function  creates model data tables and makes metadata entries in the data mining dictionary. The actual output of the build\u2014the data mining model\u2014is created and persisted to the database. The table function  creates and persist the model data and then registers the model in the metadata.","Once the build completes successfully, the build procedure performs model metadata updates  (e.g., total build duration, target column name, case id column name, data table name). Finally, the internal mapping transformations carried out by the adaptor is added to the model data.","The process flow  for building standard SVM models in the table function  is shown in . The standard approach may be used for models where active learning is turned off. The standard approach may also be used for the entire range of SVM models, including binary, multi-class, multi-target classification, and regression. A similar process may be performed for SVM models built using kernel code.","Process  begins with step , in which the training data is read into memory. If the data set is large, only a fraction of the data will be retained. The data that is retained will be treated as the \u2018entire\u2019 dataset from algorithm's point of view due to the expense of multiple reads of the data from disk. In step , an initial chunk of data is selected. The chunk of data on which the algorithm operates is often referred to as working set. Preferably, the initial chunk is a random sample of the data and, in the case of classification, stratified with respect to the target distribution.","In step , SVM optimization is performed on the selected chunk. For non-linear kernels, the size of the chunk is such that the kernel cache can be stored in memory. The size of the kernel cache is an algorithm setting. Once the SVM algorithm converges on the selected chunk, then in step , the convergence conditions are checked on the entire data set. If some of the data outside the chunk violates the convergence criteria, then the process continues with step , in which the chunk is updated by including some of the violators. Thus, the updated chunk includes the members of the previous chunk and some of the violators. Then the algorithm converges on the new chunk and checks for violators. The process iterates until the convergence criteria are met on the entire data.","If the convergence criteria are met on the entire data, then the process continues with step , in which the model is persisted and the algorithm exits. Model persistence consists of storing the model data into IOTs and creating model metadata. The model data is preferably persisted as IOTs in order to ensure fast model load during scoring.","The process flow  for building SVM models in the table function  using active learning classification is shown in . The active learning method addresses the inherent scalability problems of the standard SVM optimization approach. Instead of trying to converge on a large body of data, active learning attempts to restrict optimization to the most informative examples. These examples are selected from a larger pool. Under active learning, the build is significantly faster and the resulting model is significantly smaller.  illustrates the active learning process flow .","In active learning classification, the basic idea is that the working set\/chunk is increased by one example at a time (standard SVM models use a fixed chunk size). Among the examples that violate convergence conditions, the one that is closest to the decision boundary is added to the chunk. The assumption is that the model built on the initial chunk is of reasonable quality and only need to be further refined rather than dramatically altered.","Process  begins with step , in which the training data is read into memory. If the data set is large, only a fraction of the data will be retained. The data that is retained will be treated as the \u2018entire\u2019 dataset from algorithm's point of view due to the expense of multiple reads of the data from disk. In step , the process identifies a data pool of limited size that is used as a source of examples for the active learning. The pool represents a subset of the reservoir of all data, stratified with respect to the target. In step , an initial chunk of data is selected. The chunk of data on which the algorithm operates is often referred to as working set. This chunk should be a random sample of the data in the selected pool which is stratified with respect to the target distribution. This applies to both regression (stratified via a target histogram) and classification.","In step , SVM optimization is performed on the selected chunk. For non-linear kernels, the size of the chunk is such that the kernel cache can be stored in memory. The size of the kernel cache is an algorithm setting. Once the SVM algorithm converges on the selected chunk, then in step , the convergence conditions are checked on the entire data pool. If some of the data in the pool that is outside the chunk violates the convergence criteria, then the process continues with step , in which it is determined whether the maximum allowed number of support vectors, SV, has been reached. If the maximum allowed number of support vectors, SV, has not been reached, then the process continues with step , in which the chunk is updated by including the example closest to the separating plane that violates the convergence condition. Then the algorithm converges on the new chunk and checks for violators. The process iterates until the convergence criteria are met on the entire selected data pool.","If the convergence criteria are met on the entire selected data pool, then the process continues with step , in which the model is persisted and the algorithm exits. Model persistence consists of storing the model data into IOTs and creating model metadata. The model data is preferably persisted as IOTs in order to ensure fast model load during scoring.","The active learning approach for classification does not directly translate to regression. The geometry of the \u03b5-tube solution requires a modified method of example selection. One possibility is to add the worst violator in the pool to the working set until the upper bound on the number of support vectors is reached. This method is equivalent to finding the \u03b5 value that would produce the required number of support vectors. Unfortunately, adding the largest violators to the working set introduces significant instabilities in the convergence algorithm\u2014the new point added to the chunk can lead to dramatic differences between models across chunks. Such oscillations decrease the active learning efficiency.","An alternative method is to pre-select a pool of candidates that are likely to become support vectors. SVM's regression optimization chooses as support vectors points that have poor fit with the function approximation. Points belonging to areas with poor coverage (point density) in the input space are likely to become support vectors. The pre-selected pool is used to train a model. The size of the pool acts as an upper bound on the number of support vectors. Ideally, estimating the density in the primal space and balancing the sample with respect to this density (low density areas have higher sampling rates than high density areas) would produce the desired result. Unfortunately, with increasing number of dimensions, such a strategy becomes prohibitively expensive.","Instead, the sampling method of one embodiment of the present invention attempts to identify examples that would have large residuals by performing stratified sampling with respect to target values. If an SVM model were trained on the entire data, the under-represented target ranges are likely to have a higher proportion of support vectors. Using a stratified sample with respect to the target values has another advantage\u2014if it is assumed that the target distribution is non-uniform along its range, a random sample is likely to strongly bias a model towards target values from areas of high density. Ensuring reasonable target representation along the entire target range is likely to produce a more useful function approximation.",{"@attributes":{"id":"p-0204","num":"0248"},"figref":"FIG. 8","b":"800"},"Process  begins with step , in which the training data is read into memory. If the data set is large, only a fraction of the data will be retained. The data that is retained will be treated as the \u2018entire\u2019 dataset from algorithm's point of view due to the expense of multiple reads of the data from disk. In step , the process identifies a data pool of limited size that is used as a source of examples for the active learning. The pool represents a subset of the reservoir of all data. In step , the \u03b5 parameter is estimated, as described below. In step , SVM optimization is performed on the selected data pool or chunk thereof. Once the SVM algorithm converges on the selected data pool or chunk, then in step , the model is persisted and the algorithm exits. Model persistence consists of storing the model data into IOTs and creating model metadata. The model data is preferably persisted as IOTs in order to ensure fast model load during scoring.","An example of a process  for selecting a value of the \u03b5 parameter is shown in . Finding an adequate value for the \u03b5 parameter is important for SVM regression model quality. The \u03b5 parameter reflects the noise level in the data and it controls the size of the model and the smoothness of the approximation. Preferably, \u03b5 is adapted in the course of algorithm convergence. Process  begins with step , in which an initial value of the \u03b5 parameter is selected. Preferably, the initial chunk uses a small \u03b5 equal to, for example, 1% of the mean absolute value of the target. This relates the initial \u03b5 value to the scale of the target. In step , a model is built with the initial estimate and the residuals on a held-aside sample of the data are computed. In step , the next chunk uses an updated \u03b5 value that is given by: \u03b5=(\u03b5+\u03bc)\/2, where \u03bc=\u221a{square root over (\u03a3resid\/N)}\/(2*dim). The new value of \u03b5 is the average of the previous value and the square root of the average squared residuals. The latter quantity is scale with respect to the effective dimensionality of the problem.","The \u03b5 parameter is adapted over several successive iterations. In step , the algorithm runs on the entire pool (including the held-aside sample) with fixed \u03b5 until convergence. The described approach produces reasonable \u03b5 estimates over a large range of problems.","An exemplary block diagram of a database management DBMS  is shown in . DBMS  is typically a programmed general-purpose computer system, such as a personal computer, workstation, server system, and minicomputer or mainframe computer. DBMS  includes one or more processors (CPUs) A-N, input\/output circuitry , network adapter , and memory . CPUs A-N execute program instructions in order to carry out the functions of the present invention. Typically, CPUs A-N are one or more microprocessors, such as an INTEL PENTIUM\u00ae processor.  illustrates an embodiment in which DBMS  is implemented as a single multi-processor computer system, in which multiple processors A-N share system resources, such as memory , input\/output circuitry , and network adapter . However, the present invention also contemplates embodiments in which DBMS  is implemented as a plurality of networked computer systems, which may be single-processor computer systems, multi-processor computer systems, or a mix thereof.","Input\/output circuitry  provides the capability to input data to, or output data from, database\/DBMS . For example, input\/output circuitry may include input devices, such as keyboards, mice, touchpads, trackballs, scanners, etc., output devices, such as video adapters, monitors, printers, etc., and input\/output devices, such as, modems, etc. Network adapter  interfaces database\/DBMS  with Internet\/intranet . Internet\/intranet  may include one or more standard local area network (LAN) or wide area network (WAN), such as Ethernet, Token Ring, the Internet, or a private or proprietary LAN\/WAN.","Memory  stores program instructions that are executed by, and data that are used and processed by, CPU  to perform the functions of DBMS . Memory  may include electronic memory devices, such as random-access memory (RAM), read-only memory (ROM), programmable read-only memory (PROM), electrically erasable programmable read-only memory (EEPROM), flash memory, etc., and electro-mechanical memory, such as magnetic disk drives, tape drives, optical disk drives, etc., which may use an integrated drive electronics (IDE) interface, or a variation or enhancement thereof, such as enhanced IDE (EIDE) or ultra direct memory access (UDMA), or a small computer system interface (SCSI) based interface, or a variation or enhancement thereof, such as fast-SCSI, wide-SCSI, fast and wide-SCSI, etc, or a fiber channel-arbitrated loop (FC-AL) interface.","The contents of memory  varies depending upon the functions that DBMS  is programmed to perform. One of skill in the art would recognize that these functions, along with the memory contents related to those functions, may be included on one system, or may be distributed among a plurality of systems, based on well-known engineering considerations. The present invention contemplates any and all such arrangements.","In the example shown in , memory  includes server API , PL\/SQL procedures , PLS\/SQL for build , PL\/SQL procedures for apply , SVM build table functions , SVM apply table functions , database access routines , database , database kernel , and operating system . Client API  provides a programming interface to client software and may also perform processing in the client side. PL\/SQL procedures  includes two main functions\u2014PL\/SQL procedures for build  and PL\/SQL procedures for apply . PL\/SQL procedures for build  acts as a wrapper to the Table Function routines  for SVM model build and basically performs preprocessing of input data. The PL\/SQL procedures for apply acts as a wrapper to the SVM Apply Table Functions . Database access routines  provide the capability to access one or more databases, such as those included in database , in order to retrieve information for display. Database  provides the capability to store, organize, modify, and extract information from one or more data tables included in database . Database kernel  provides overall DBMS functionality. Operating system  provides overall system functionality.","From a technical standpoint, databases can differ widely. The terms relational, network, flat, and hierarchical all refer to the way a database organizes information internally. The internal organization can affect how quickly and flexibly you can extract information.","Each database includes a collection of information organized in such a way that computer software can select and retrieve desired pieces of data. Traditional databases are organized by fields, records, and files. A field is a single piece of information; a record is one complete set of fields; and a file is a collection of records. An alternative concept in database design is known as Hypertext. In a Hypertext database, any object, whether it be a piece of text, a picture, or a film, can be linked to any other object. Hypertext databases are particularly useful for organizing large amounts of disparate information, but they are not designed for numerical analysis.","Typically, a database includes not only data, but also low-level database management functions, which perform accesses to the database and store or retrieve data from the database. Such functions are often termed queries and are performed by using a database query language, such as Structured Query Language (SQL). SQL is a standardized query language for requesting information from a database. Historically, SQL has been a popular query language for database management systems running on minicomputers and mainframes. Increasingly, however, SQL is being supported by personal computer database systems because it supports distributed databases (databases that are spread out over several computer systems). This enables several users on a local-area network to access the same database simultaneously.","Most full-scale database systems are relational database systems. Small database systems, however, use other designs that provide less flexibility in posing queries. Relational databases are powerful because they require few assumptions about how data is related or how it will be extracted from the database. As a result, the same database can be viewed in many different ways. An important feature of relational systems is that a single database can be spread across several tables. This differs from flat-file databases, in which each database is self-contained in a single table.","Typically, a database application, includes data entry functions and data reporting functions. Data entry functions provide the capability to enter data into a database. Data entry may be performed manually, by data entry personnel, automatically, by data entry processing software that receives data from connected sources of data, or by a combination of manual and automated data entry techniques. Data reporting functions provide the capability to select and retrieve data from a database and to process and format that data for other uses. Typically, retrieved data is used to display information to a user, but retrieved data may also be used for other functions, such as account settlement, automated ordering, numerical machine control, etc.","As shown in , the present invention contemplates implementation on a system or systems that provide multi-processor, multi-tasking, multi-process, and\/or multi-thread computing, as well as implementation on systems that provide only single processor, single thread computing. Multi-processor computing involves performing computing using more than one processor. Multi-tasking computing involves performing computing using more than one operating system task. A task is an operating system concept that refers to the combination of a program being executed and bookkeeping information used by the operating system. Whenever a program is executed, the operating system creates a new task for it. The task is like an envelope for the program in that it identifies the program with a task number and attaches other bookkeeping information to it. Many operating systems, including UNIX\u00ae, OS\/2\u00ae, and WINDOWS\u00ae, are capable of running many tasks at the same time and are called multitasking operating systems. Multi-tasking is the ability of an operating system to execute more than one executable at the same time. Each executable is running in its own address space, meaning that the executables have no way to share any of their memory. This has advantages, because it is impossible for any program to damage the execution of any of the other programs running on the system. However, the programs have no way to exchange any information except through the operating system (or by reading files stored on the file system). Multi-process computing is similar to multi-tasking computing, as the terms task and process are often used interchangeably, although some operating systems make a distinction between the two.","It is important to note that while the present invention has been described in the context of a fully functioning data processing system, those of ordinary skill in the art will appreciate that the processes of the present invention are capable of being distributed in the form of a computer readable medium of instructions and a variety of forms and that the present invention applies equally regardless of the particular type of signal bearing media actually used to carry out the distribution. Examples of computer readable media include recordable-type media such as floppy disc, a hard disk drive, RAM, and CD-ROM's, as well as transmission-type media, such as digital and analog communications links.","Although specific embodiments of the present invention have been described, it will be understood by those of skill in the art that there are other embodiments that are equivalent to the described embodiments. Accordingly, it is to be understood that the invention is not to be limited by the specific illustrated embodiments, but only by the scope of the appended claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Further features and advantages of the invention can be ascertained from the following detailed description that is provided in connection with the drawings described below:",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1","b":"100"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
