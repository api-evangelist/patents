---
title: Data compressor using hints
abstract: An invention is disclosed for compressing data. In embodiments of the invention, input data is processed to determine one or more hints, or meta-data about how to compress the data. These hints may be produced based on the contents of the data itself, or by the process which generated the data. A hint may comprise an indication that a portion of the data matches another portion of the data, an indication that the portion of the data should not be compressed by an associated compressor, or an indication that the portion of the data should be compressed normally by the associated compressor. The source data and these hints may then be sent to a compressor, which traverses both the source data and the hints, and encodes the source data accordingly to produce an encoded data output stream.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09344528&OS=09344528&RS=09344528
owner: Microsoft Technology Licensing, LLC
number: 09344528
owner_city: Redmond
owner_country: US
publication_date: 20110831
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENTS"],"p":["In a remote presentation session, a client computer and a server computer communicate across a communications network. The client sends the server locally-received input, such as mouse cursor movements and keyboard presses. In turn, the server receives this input and performs processing associated with it, such as executing an application in a user session. When the server performs processing that produces output, such as graphical output or sound, the server sends this output to the client for presentation. In this manner, applications appear to a user of the client to execute locally on the client when they, in fact, execute on the server.","In a remote presentation session, the amount of graphical data generated by a server commonly exceeds the amount of communications network bandwidth between the server and the client. In view of this restriction of bandwidth, it is common for the server to compress the graphical data before transmitting it to the client. Sometimes the server will generate a byte stream to send to the client and then compress the byte stream before sending it to the client. This compression of the byte stream is frequently referred to as \u201cbulk compression.\u201d There are many problems with current implementations of bulk compressors, some of which are well known.","One problem with current implementations of bulk compressors is that they are limited in the amount of compression that they can perform. A frequent restriction for bulk compression in a remote presentation session is a restriction on the amount of available time with which to perform the compression. In a remote presentation session, it is generally desirable to reduce the amount of time between when a user at the client provides input and when that user is displayed graphical output corresponding to that input being performed. Given this restriction on time, it is generally advantageous for a remote presentation session bulk compressor to compress data well while still performing that compression in a limited amount of time.","The present invention offers improved data compression. In embodiments of the present invention, the amount of compression performed under the constraints of available processing resources and\/or time is improved. In embodiments, data to be compressed is evaluated and portions thereof are classified with \u201chints,\u201d or techniques for compressing that portion of data\u2014meta-data generated from the data, or by the process which assembled the data, that describes a characteristic about the compressibility of the source data. For example, a given input data may be classified in three separate portions, such that one portion is to be compressed normally, one portion is to be literally copied or transferred to an output stream rather than being compressed (or compressed further), and one portion is recognized as a match of another portion, and is to be encoded in the output stream as a reference to the first match.","Hints may be determined in a variety of ways. In embodiments of the invention, hints for matches are determined using rolling hashes. A rolling hash may be performed on source data, and those hash values that match a characteristic of a subset of the possible hash values (e.g. those hash values that are below a threshold) are identified, along with their corresponding data. These qualifying hash values are then compared to determine which of them are equal to each other. Where two qualifying hash values are equal, their corresponding data (and the data that neighbors that corresponding data) are compared to determine how large of a contiguous region matches. These matched areas are then compressed by encoding the redundant second matching area as a reference to the first matching area. By encoding large matches this way, time is saved by not finding and encoding these matches via a more-exhaustive search.","In addition to matches, hints may be generated for portions of the data that are not to be compressed. For instance, a hint may be generated to not compress a portion of the data where the data has already been compressed, such as image data encoded with an image codec, like JPEG (Joint Photographic Experts Group) format. It may be that attempting to further compress this portion of the data consumes too many computing resources relative to the additional compression gained, or that this \u201cnot to be compressed\u201d data may be sent to a compressor along with the hint that it should be encoded as literals into an output compressed data. The compressor may still perform non-compression-related encoding, such as where the output compressed data has a different format than the input data.","The remainder of the data may be compressed by the compressor normally\u2014either as a result of an indication that the data should be compressed normally, or as a default operation of the encoder. This compressed data assembled in three different ways\u2014as a match, as data not to be compressed, and as normally compressed data\u2014may be collected as a compressed output data that may be sent to a client in a remote presentation session.","Certain specific details are set forth in the following description and figures to provide a thorough understanding of various embodiments of the disclosure. Certain well-known details often associated with computing and software technology are not set forth in the following disclosure to avoid unnecessarily obscuring the various embodiments of the disclosure. Further, those of ordinary skill in the relevant art will understand that they can practice other embodiments of the disclosure without one or more of the details described below. Finally, while various methods are described with reference to steps and sequences in the following disclosure, the description as such is for providing a clear implementation of embodiments of the disclosure, and the steps and sequences of steps should not be taken as required to practice this disclosure.","It should be understood that the various techniques described herein may be implemented in connection with hardware or software or, where appropriate, with a combination of both. Thus, the methods and apparatus of the disclosure, or certain aspects or portions thereof, may take the form of program code (i.e., instructions) embodied in tangible media, such as floppy diskettes, CD-ROMs, hard drives, or any other machine-readable storage medium wherein, when the program code is loaded into and executed by a machine, such as a computer, the machine becomes an apparatus for practicing the disclosure. In the case of program code execution on programmable computers, the computing device generally includes a processor, a storage medium readable by the processor (including volatile and non-volatile memory and\/or storage elements), at least one input device, and at least one output device. One or more programs that may implement or utilize the processes described in connection with the disclosure, e.g., through the use of an application programming interface (API), reusable controls, or the like. Such programs are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However, the program(s) can be implemented in assembly or machine language, if desired. In any case, the language may be a compiled or interpreted language, and combined with hardware implementations.","The term circuitry used throughout the disclosure can include hardware components such as hardware interrupt controllers, hard drives, network adaptors, graphics processors, hardware based video\/audio codecs, and the firmware\/software used to operate such hardware. The term circuitry can also include microprocessors configured to perform function(s) by firmware or by switches set in a certain way or one or more logical processors, e.g., one or more cores of a multi-core general processing unit. The logical processor(s) in this example can be configured by software instructions embodying logic operable to perform function(s) that are loaded from memory, e.g., RAM, ROM, firmware, and\/or virtual memory. In example embodiments where circuitry includes a combination of hardware and software an implementer may write source code embodying logic that is subsequently compiled into machine readable code that can be executed by a logical processor. Since one skilled in the art can appreciate that the state of the art has evolved to a point where there is little difference between hardware, software, or a combination of hardware\/software, the selection of hardware versus software to effectuate functions is merely a design choice. Thus, since one of skill in the art can appreciate that a software process can be transformed into an equivalent hardware structure, and a hardware structure can itself be transformed into an equivalent software process, the selection of a hardware implementation versus a software implementation is left to an implementer.","Embodiments of the invention may execute on one or more computer systems.  and the following discussion are intended to provide a brief general description of a suitable computing environment in which embodiments of the invention may be implemented.",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1","b":["20","21","21"]},"Computer  may also comprise graphics processing unit (GPU) . GPU  is a microprocessor optimized to manipulate computer graphics. Processing unit  may offload work to GPU . GPU  may have its own graphics memory, and\/or may have access to a portion of system memory . As with processing unit , GPU  may comprise one or more processing units, each having one or more cores.","Computer  may also comprise a system memory , and a system bus  that communicative couples various system components including the system memory  to the processing unit  when the system is in an operational state. The system memory  can include read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within the computer , such as during start up, is stored in ROM . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, or a local bus, which implements any of a variety of bus architectures. Coupled to system bus  may be a direct memory access (DMA) controller  that is configured to read from and\/or write to memory independently of processing unit . Additionally, devices connected to system bus , such as storage drive I\/F  or magnetic disk drive I\/F  may be configured to also read from and\/or write to memory independently of processing unit , without the use of DMA controller .","The computer  may further include a storage drive  for reading from and writing to a hard disk (not shown) or a solid-state disk (SSD) (not shown), a magnetic disk drive  for reading from or writing to a removable magnetic disk , and an optical disk drive  for reading from or writing to a removable optical disk  such as a CD ROM or other optical media. The hard disk drive , magnetic disk drive , and optical disk drive  are shown as connected to the system bus  by a hard disk drive interface , a magnetic disk drive interface , and an optical drive interface , respectively. The drives and their associated computer-readable storage media provide non-volatile storage of computer readable instructions, data structures, program modules and other data for the computer .","Although the example environment described herein employs a hard disk, a removable magnetic disk  and a removable optical disk , it should be appreciated by those skilled in the art that other types of computer readable media which can store data that is accessible by a computer, such as flash memory cards, digital video discs or digital versatile discs (DVDs), random access memories (RAMs), read only memories (ROMs) and the like may also be used in the example operating environment. Generally, such computer readable storage media can be used in some embodiments to store processor executable instructions embodying aspects of the present disclosure. Computer  may also comprise a host adapter  that connects to a storage device  via a small computer system interface (SCSI) bus .","A number of program modules comprising computer-readable instructions may be stored on computer-readable media such as the hard disk, magnetic disk , optical disk , ROM  or RAM , including an operating system , one or more application programs , other program modules , and program data . Upon execution by the processing unit, the computer-readable instructions cause actions described in more detail below to be carried out or cause the various program modules to be instantiated. A user may enter commands and information into the computer  through input devices such as a keyboard  and pointing device . Other input devices (not shown) may include a microphone, joystick, game pad, satellite disk, scanner or the like. These and other input devices are often connected to the processing unit  through a serial port interface  that is coupled to the system bus, but may be connected by other interfaces, such as a parallel port, game port or universal serial bus (USB). A display  or other type of display device can also be connected to the system bus  via an interface, such as a video adapter . In addition to the display , computers typically include other peripheral output devices (not shown), such as speakers and printers.","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be another computer, a server, a router, a network PC, a peer device or other common network node, and typically can include many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  can include a local area network (LAN)  and a wide area network (WAN) . Such networking environments are commonplace in offices, enterprise wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  can be connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  can typically include a modem  or other means for establishing communications over the wide area network , such as the INTERNET. The modem , which may be internal or external, can be connected to the system bus  via the serial port interface . In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","In an embodiment where computer  is configured to operate in a networked environment, OS  is stored remotely on a network, and computer  may netboot this remotely-stored OS rather than booting from a locally-stored OS. In an embodiment, computer  comprises a thin client where OS  is less than a full OS, but rather a kernel that is configured to handle networking and display output, such as on monitor .",{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 2","FIG. 3 or 4","FIG. 2"],"b":"204"},"Depicted in  is server , which may include circuitry configured to effectuate a remote presentation session server, or in other embodiments the server  can include circuitry configured to support remote desktop connections. In the depicted example, the server  can be configured to generate one or more sessions for connecting clients such as sessions  through N (where N is an integer greater than 2). Briefly, a session in example embodiments of the present invention can generally include an operational environment that is effectuated by a plurality of subsystems, e.g., software code, that are configured to interact with a kernel  of server . For example, a session can include a process that instantiates a user interface such as a desktop window, the subsystems that track mouse movement within the window, the subsystems that translate a mouse click on an icon into commands that effectuate an instance of a program, etc. A session can be generated by the server  on a user by user basis by the server  when, for example, the server  receives a connection request over a network connection from a client . Generally, a connection request can first be handled by the transport logic  that can, for example, be effectuated by circuitry of the server . The transport logic  can in some embodiments include a network adaptor; firmware, and software that can be configured to receive connection messages and forward them to the engine . As illustrated by , the transport logic  can in some embodiments include protocol stack instances for each session. Generally, each protocol stack instance can be configured to route user interface output to a client and route user input received from the client to the session core  associated with its session.","Continuing with the general description of , the engine  in some example embodiments of the present invention can be configured to process requests for sessions; determine the functionality for each session; generate sessions by allocating a set of physical resources for the session; and instantiating a protocol stack instance for the session. In some embodiments the engine  can be effectuated by specialized circuitry components that can implement some of the above mentioned operational procedures. For example, the circuitry in some example embodiments can include memory and a processor that is configured to execute code that effectuates the engine . As depicted by , in some instances the engine  can receive connection requests and determine that, for example, a license is available and a session can be generated for the request. In the situation where the server  is a remote computer that includes remote desktop capabilities, the engine  can be configured to generate a session in response to a connection request without checking for a license. As illustrated by , a session manager  can be configured to receive a message from an engine  and in response to the message the session manager  can add a session identifier to a table; assign memory to the session identifier; and generate system environment variables and instances of subsystem processes in memory assigned to the session identifier.","As illustrated by , the session manager  can instantiate environment subsystems such as a runtime subsystem  that can include a kernel mode part such as the session core . For example, the environment subsystems in an embodiment are configured to expose some subset of services to application programs and provide an access point to the kernel of the operating system . In example embodiments the runtime subsystem  can control the execution of processes and threads and the session core  can send requests to the executive of the kernel  to allocate memory for the threads and schedule time for them to be executed. In an embodiment the session core  can include a graphics display interface  (GDI), a security subsystem , and an input subsystem . The input subsystem  can in these embodiments be configured to receive user input from a client  via the protocol stack instance associated with the session and transmit the input to the session core  for the appropriate session. The user input can in some embodiments include signals indicative of absolute and\/or relative mouse movement commands, mouse coordinates, mouse clicks, keyboard signals, joystick movement signals, etc. User input, for example, a mouse double-click on an icon, can be received by the session core  and the input subsystem  can be configured to determine that an icon is located at the coordinates associated with the double-click. The input subsystem  can then be configured to send a notification to the runtime subsystem  that can execute a process for the application associated with the icon.","In addition to receiving input from a client , draw commands can be received from applications and\/or a desktop and be processed by the GDI . The GDI  in general can include a process that can generate graphical object draw commands. The GDI  in this example embodiment can be configured to pass its output to the remote display subsystem  where the commands are formatted for the display driver that is attached to the session. In certain example embodiments one or more physical displays can be attached to the server , e.g., in a remote desktop situation. In these example embodiments the remote display subsystem  can be configured to mirror the draw commands that are rendered by the display driver(s) of the remote computer system and transmit the mirrored information to the client  via a stack instance associated with the session. In another example embodiment, where the server  is a remote presentation session server, the remote display subsystem  can be configured to include virtual display driver(s) that may not be associated with displays physically attacked to the server , e.g., the server  could be running headless. The remote display subsystem  in this embodiment can be configured to receive draw commands for one or more virtual displays and transmit them to the client  via a stack instance associated with the session. In an embodiment of the present invention, the remote display subsystem  can be configured to determine the display resolution for each display driver, e.g., determine the display resolution of the virtual display driver(s) associated with virtual displays or the display resolution of the display drivers associated with physical displays; and route the packets to the client  via the associated protocol stack instance.","In some example embodiments the session manager  can additionally instantiate an instance of a logon process associated with the session identifier of the session that can be configured to handle logon and logoff for the session. In these example embodiments drawing commands indicative of the graphical user interface associated with the logon process can be transmitted to the client  where a user of the client  can input an account identifier, e.g., a username\/password combination, a smart card identifier, and\/or biometric information into a logon screen. The information can be transmitted to server  and routed to the engine  and the security subsystem  of the session core . For example, in certain example embodiments the engine  can be configured to determine whether the user account is associated with a license; and the security subsystem  can be configured to generate a security token for the session.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 3","FIG. 3","FIG. 2","FIG. 2","FIG. 3"],"b":["204","201","340","350","340","350","340"]},"The data compressor of  has a process flow that begins at . After , the process flow moves to decision , which determines whether any hints remain that have not been processed by hint processor  relative to the present data. A hint may comprise an indication that (1) the a portion of the data matches another portion and is to be encoded as a reference to that other portion; (2) that a portion of the data is not to be further compressed by compressor  (note: compressor  may be considered an encoder, such as where data is sent to compressor  along with a hint that it is not to be compressed, and compressor  does not compress this portion of the data that it processes); or (3) that a portion of the data is to be compressed normally. Where there is a hint that has not been processed by hint processor  relative to the present data, the process flow moves to decision , which determines whether the current part of data of the data to be encoded corresponds to the start point for a hint. For example, if the data to be compressed is 1,000 bytes long, and there is one hint that starts with a portion of the data beginning at byte , where the data compressor is at byte , then the answer to decision  is yes, and if the data compressor is at any one of bytes - or -,, the answer to decision  is no.","Where the answer to decision  is, yes, the current character is the start of the hint, then the process flow moves to decision . Decision  determines whether the hint indicates that the current character begins a segment of the data that matches another segment of the data. Where the answer to decision  is yes, the process flow moves to operation .","At operation , the match is encoded, and the position within the data to be compressed is advanced by the length of the match. For instance, where the current character is #500 and the hint indicates a match of 100 characters, the match of characters #500-599 is encoded (such as with a reference to the prior match), and the process advances to character #600 of the data for further processing. After operation , the process flow moves to operation . In operation , the enumeration of hints is advanced to the next hint (such as advancing one position in a list where the hints are stored in a list). The process flow moves back to decision , which determines whether there are additional hints to process.","If at decision  it is determined that the hint is not indicative of there being a match, but that a region should not be compressed by compressor , the process flow moves to operation . At operation , the portion of the data to be compressed indicated by the current hint is encoded as literals (i.e., not compressed), and the current position in the data to be compressed is advanced by the length of these characters that are encoded as literals. In embodiments, rather than this data that is not to be compressed being encoded by process , the data is sent to compressor  along with a hint indicating that the data is not to be compressed, and compressor  encodes the data as literals. After operation , the process flow then moves again to operation , which advances to the next hint in the enumeration of hints.","Returning to decision , previously, the process flow was described where it is determined that there are hints remaining. Where there are no hints remaining, the process flow moves to operation , where an indication of the last character of a region to be compressed by compressor  is marked as the last character of the data to be compressed. Then, the process flow moves to decision , which is the entry point to compressor .","Returning to decision , a similar process occurs here as with decision . Previously, the process flow was described where the current character of the data to be compressed is the start of a hint. Where, instead, the current character of the data to be compressed is not the start of a hint, the process flow moves to operation . At operation , the indication of the last character of a region to be compressed by compressor  is set to be one character before the start of the character at which the hint begins. For example, if the current character is #500, and the current hint starts at character #600, then at operation , the last character of a region to be compressed by compressor  is set to character #599, so that compressor  will compress the region from characters #500-#599, inclusive. After operation  has been carried out, the process flow moves to decision , which is the entry point to compressor .","Compressor  begins with decision . Decision  determines whether the current character of the portion of data to be compressed is near the limit character. In embodiments of the invention, it may be determined that matches of a certain size (e.g. two or fewer characters) will not be compressed. These small matches may not be compressed, for instance, because it is determined that there is not a compression benefit available in small matches, or because it is determined that the time or processing resources cost associated with compressing small matches outweighs the compression benefits from compressing small matches.","Where at decision  it is determined that the current character is not near the limit, the process flow moves to operation . At operation , the compressor finds the best match for the current character. In embodiments, this best match may be the longest match (with a previous part of the data to be compressed) that starts with the present character. In embodiments, this best match may be the longest match that starts with the present character that may be found within some restriction of time or processing resources. In embodiments, this best match may be the best match that occurs within a sliding window\u2014i.e. a specified number of characters preceding the present character. In embodiments, the length of the best match does not run so long that it exceeds the number of characters sent from hint processor  to compressor  for compression. For example, where hint processor  sends 100 characters to compressor, from characters #500-#599, compressor  may not find a match in excess of 100 characters, or a match that goes past character #599. The process flow then moves from operation  to decision  after the best match is found in operation .","In decision , it is determined whether the best match of operation  (if one was found) is usable. In embodiments, it may be determined that only a match of at least a certain length is usable. This may be, for instance, because matches that are below a certain length are too short to compress. The process flow moves to operation  where a usable match is determined in operation . At operation , the usable match is encoded, and the current character is advanced by the length of the match. For instance, if the current character is #500, and a match of 50 characters is found, the current character will be advanced by 50 characters, to be set at character #550. The process flow will then return to decision .","If, at decision , it is instead determined that a usable match has not been found, the process flow moves to operation . In operation , the current character is encoded, and the current character is advanced one position (e.g., from character #500 to character #501). The process flow then returns to decision .","Returning to decision , previously, the process flow where the result of decision  is no was described. If, instead, the result of decision  is yes (indicating that the current character is near the limit of characters to be compressed indicated by hint processor ), the process flow moves to operation . In operation , any remaining characters up to the limit are encoded as literals, and the process flow moves to decision . In decision , it is determined whether the end of the data to be compressed has been reached. If the end has been reached, the process flow moves to operation , where the process flow concludes. If, instead, the end has not been reached, the process flow returns to operation  of hint processor , where it is determined if the current character is the start of another hint.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":["FIG. 4","FIG. 3"],"b":["400","400","350","400","400","400"]},"In embodiments, hint generator takes the data to be compressed, and calculates a rolling hash for a portion of the data starting with each bit or byte in the data. This rolling hash (a hash function where a window is used to traverse the data to be hashed; with each new element, that new element is added, and the oldest element from the window is dropped) may comprise, for example, a CRC hash (a cyclic redundancy check). The rolling hash may be used to produce a 32-bit number for each hashed portion of the data.","This rolling hash may be used to divide the data into portions. It may be too computationally complex (based on available computing resources) to compare each portion of data to each other portion of data to determine whether a match exists. In embodiments of the invention, this rolling hash is taken, and each such rolling hash value that is below a threshold value is identified. For example, where the hash produces a 32-bit result (approximately a 4-billion-value address space), the threshold may be set to 2^18 (approximately 256,000), so that, on average, one in every 2^14 bits (approximately 16,000) will be below the threshold value. Since rolling hashes typically produce a result that greatly differs from the input value, these hash values below the threshold value may be thought to be roughly evenly distributed, and the data may be divided into approximately 16 k-sized chunks.","Where hint generator  finds values below the threshold value, it may then compare matching values to determine whether they match. Where two values to match, hint generator may then search the surrounding areas of the matches to determine the size of the match for larger matching regions. Hint generator  may search both matches before the match for a continuous area of matches, and\/or both matches after the match for a continuous area of matches. Where this matched area has been identified, hint generator  may mark the start and end of the match, and store a hint that tells hint processor  that this matched area is a match, and may be encoded, for instance, by writing a reference to the prior match.","Hint generator  may also determine that a portion of the data should not be compressed by compressor  and store a hint that indicates this. Hint generator  may determine that a portion of the data should not be compressed by compressor  such as where the data has already been compressed, or it is determined that an amount of computing resources required to compress the portion of the data outweighs an associated compression benefit. The portion of the data may have already been compressed such as where the portion of the data is image data in a compressed format, such as JPEG.","Hint generator  may also determine that a portion of the data is to be compressed normally, and store a hint that indicates this. In embodiments of the invention, a hint is produced for data indicating that the data should be compressed normally where it is neither data for which hint generator  found a match, nor is it data for which hint generator  determined that should not be compressed by compressor . Thus no explicit hint is needed for data which is to be compressed normally.","In embodiments of the invention two portions of the data may be encountered that are the same, or similarly situated (e.g. they are both image data, or hint generator  would determine the same hint for each given the same amount of available computing resources), and hint generator  may determine different hints for each. For example, hint generator  may determine that a first portion of the data is to be encoded normally. Hint generator  may then encounter a second portion of the data that is the same or similarly situated to the first portion of the data. However, where the available computing resources have decreased, hint generator  may determine that there are not enough available computing resources to encode the second portion normally, and may produce a hint for the second portion of the data that it is to be encoded into the output stream as literals and not compressed.","Hint processor may send hints and data to compressor  via communication link , where the data is compressed according to the hint, or hint processor may encode the data into the output stream itself via communication link . For example, in embodiments, where a portion of the data is to be compressed normally, the data to be compressed normally may be sent to compressor , and other data (such as data that is not to be compressed) may be encoded by hint processor  as literals in the output stream of encoded data. In other embodiments, hint processor  may send all data to compressor , even data that compressor  is to encode as literals into the encoded data output stream without compressing.",{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIG. 5","FIG. 3"],"b":["500","500","1","502","2","504","1","502","2","504","1","502","2","504","1","502","2","504"]},"In a ring buffer, a pointer is kept to a start point or current point of the data. In embodiments, a pointer is also kept to an end point of the data. When the end of the ring buffer is reached, the next element of the ring buffer addressed is the first element of the ring buffer. In some ring buffers, where an amount of data is accessed that extends beyond the end of the ring buffer, data from the front of the buffer is accessed\u2014the arithmetic for accessing data from the ring buffer is modulo based on the size of the ring buffer.","In ring buffer , this modulo arithmetic need not occur, increasing the speed at which data may be accessed (for example, because performing a data access does not require checking to see whether the end of the ring buffer has been reached). The modulo arithmetic need not occur because ring buffer  comprises two copies of the data that is being stored\u2014ring buffer-  and ring buffer- . Accesses of data are made beginning in ring buffer- . When the data access extends beyond the end of ring buffer- , rather than wrapping back to the start of the ring buffer, the data access may continue into ring buffer- , which contains the same data as ring buffer- .",{"@attributes":{"id":"p-0059","num":"0058"},"figref":["FIG. 6","FIG. 4"],"b":["400","610"]},"The data that is duplicated between ring buffer-  and ring buffer-  may be duplicated through a single memory write operation by using virtual memory. The data may be duplicated by associating both a page for ring buffer-  and a page for ring buffer-  to the same page in physical memory. For instance, page of ring buffer-  and page of ring buffer-  are both mapped to the same physical page\u2014page  of physical memory . Likewise, page of ring buffer-  and page of ring buffer-  are both mapped to the same physical page\u2014page  of physical memory . In doing so, one operation to modify a physical page is then reflected in both of its corresponding virtual pages. For instance, a modification to physical page  is reflected in virtual page and virtual page because they are both mapped to physical page .","Similarly, a modification to the data at one virtual address affects the corresponding physical memory, so it instantaneously appears at the corresponding virtual address in the other half of the buffer.",{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 7","b":["700","702","704","702","700","702","702","704"]},"Decompression of compressed data  may likewise be achieved through a two-step process. The smaller runs of matching characters found in intermediate data  may be expanded to produce a representation of intermediate data \u2014comprising the identified matches and the unique data. This representation of intermediate data  may then be expanded by reproducing the matched data at each location identified by the table of matches to produce a representation of decompressed data .",{"@attributes":{"id":"p-0064","num":"0063"},"figref":["FIG. 8","FIG. 8","FIG. 7","FIG. 8","FIG. 7"],"b":"702"},"As depicted, the source data of  is the same as the source data of \u2014it is source data . Source data  may be processed to determine metadata table . In embodiments of the invention, hint generator  of  may process source data  to produce metadata table , where metadata table  identifies the matches (or hints thereof) determined by hint generator .","Source data  and metadata table  may then be used to determine compressed data . In embodiments of the invention, hint processor  of  of  receives source data  and metadata table  from hint generator  of , and hint processor  works with compressor  of  to compress the data based on these hints of matches, producing compressed data .","In contrast to the decompression described with respect to compressed data  of , which involves two passes, compressed data  of  may be decompressed in a single pass to produce a representation of source data . During decompression, each identified encoded position refers to a preceding part of the compressed data. When an identified encoded position is encountered, it may be immediately decompressed. When the data has been traversed once, each such encoded position may be decompressed, producing a representation of source data .","While the present invention has been described in connection with the preferred aspects, as illustrated in the various figures, it is understood that other similar aspects may be used or modifications and additions may be made to the described aspects for performing the same function of the present disclosure without deviating there from. Therefore, the present disclosure should not be limited to any single aspect, but rather construed in breadth and scope in accordance with the appended claims. For example, the various procedures described herein may be implemented with hardware or software, or a combination of both. The invention may be implemented with computer-readable storage media and\/or computer-readable communication media. Thus, the invention, or certain aspects or portions thereof, may take the form of program code (i.e., instructions) embodied in tangible media, such as floppy diskettes, CD-ROMs, hard drives, or any other machine-readable storage medium. Likewise, the invention, or certain aspects or portions thereof, may be embodied in propagated signals, or any other machine-readable communications medium. Where the program code is loaded into and executed by a machine, such as a computer, the machine becomes an apparatus configured for practicing the disclosed embodiments. In addition to the specific implementations explicitly set forth herein, other aspects and implementations will be apparent to those skilled in the art from consideration of the specification disclosed herein. It is intended that the specification and illustrated implementations be considered as examples only."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 5","FIG. 3"]},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 6","FIG. 4"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
