---
title: Systems and methods for application reuse
abstract: System and methods are provided. In one embodiment, a system includes a master data archiver configured to store a data related to a turbomachine system and a first data collector service system configured to collect the data from the master data archiver. The system also includes a second data collector service system communicatively coupled to the first data collector system and configured to pull or to push the data from the first data collector system and a first data archiver configured to receive at least some of the data from the second data collector system. The system further includes an asset model database storing a plurality of turbomachine tags, wherein the turbomachine tags are configured to categorize the data and a data access system (DAS) configured to provide data access to the first data archiver, the asset model database, or a combination thereof.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09032424&OS=09032424&RS=09032424
owner: General Electric Company
number: 09032424
owner_city: Schenectady
owner_country: US
publication_date: 20111116
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","BRIEF DESCRIPTION OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["The subject matter disclosed herein relates to reuse of systems, and more specifically, to reuse of software systems.","Certain systems, such as an industrial control system, may provide for capabilities that enable the control and analysis of the industrial control system. For example, the industrial control system may include controllers, field devices, and sensors storing data for subsequent analysis. Software systems may be used to store and analyze the data. It would be beneficial to improve reuse of the software systems.","Certain embodiments commensurate in scope with the originally claimed invention are summarized below. These embodiments are not intended to limit the scope of the claimed invention, but rather these embodiments are intended only to provide a brief summary of possible forms of the invention. Indeed, the invention may encompass a variety of forms that may be similar to or different from the embodiments set forth below.","In a first embodiment, a system includes a master data archiver configured to store a data related to a turbomachine system and a first data collector service system configured to collect the data from the master data archiver. The system also includes a second data collector service system communicatively coupled to the first data collector system and configured to pull or to push the data from the first data collector system and a first data archiver configured to receive at least some of the data from the second data collector system. The system further includes an asset model database storing a plurality of turbomachine tags, wherein the turbomachine tags are configured to categorize the data and a data access system (DAS) configured to provide data access to the first data archiver, the asset model database, or a combination thereof. The system additionally includes an application programming interface (API) comprising an object-oriented language and configured to provide a communicative interface to at least one of the DAS, the first data archiver, or the asset model database and an API wrapper configured to use the API to communicate with an event-driven client application and at least one of the DAS, the first data archiver, or the asset model database.","In a second embodiment, a method includes storing a data related to a turbomachine system in a master data archiver and collecting the data from the master data archiver using a first data collector service system. The method also includes pushing or pulling the data from the first data collector system to a second data collector system and storing at least some of the data from the second data collector system in a first data archiver. The method further includes storing a plurality of turbomachine tags in an asset model database, wherein the turbomachine tags are configured to categorize the data and providing data access to the first data archiver, the asset model database, or a combination thereof, by using a data access system (DAS). The method additionally includes communicating with the DAS, the first data archiver, the asset model database, or a combination thereof by using an application programming interface (API) comprising an object-oriented language and providing an API wrapper configured to use the API to communicate with an event-driven client application and at least one of the DAS, the first data archiver, or the asset model database.","In a third embodiment, a non-transitory tangible computer-readable medium includes executable code. The code includes instructions for storing a data related to a turbomachine system in a master data archiver and collecting the data from the master data archiver using a first data collector service system. The code also includes instructions for pushing or pulling the data from the first data collector system to a second data collector system and storing at least some of the data from the second data collector system in a first data archiver. The code further includes instructions for storing a plurality of turbomachine tags in an asset model database, wherein the turbomachine tags are configured to categorize the data and providing data access to the first data archiver, the asset model database, or a combination thereof, by using a data access system (DAS). The code additionally includes instructions for communicating with the DAS, the first data archiver, the asset model database, or a combination thereof by using an application programming interface (API) comprising an object-oriented language and providing an API wrapper configured to use the API to communicate with an event-driven client application and at least one of the DAS, the first data archiver, or the asset model database.","One or more specific embodiments of the present invention will be described below. In an effort to provide a concise description of these embodiments, all features of an actual implementation may not be described in the specification. It should be appreciated that in the development of any such actual implementation, as in any engineering or design project, numerous implementation-specific decisions must be made to achieve the developers' specific goals, such as compliance with system-related and business-related constraints, which may vary from one implementation to another. Moreover, it should be appreciated that such a development effort might be complex and time consuming, but would nevertheless be a routine undertaking of design, fabrication, and manufacture for those of ordinary skill having the benefit of this disclosure.","When introducing elements of various embodiments of the present invention, the articles \u201ca,\u201d \u201can,\u201d \u201cthe,\u201d and \u201csaid\u201d are intended to mean that there are one or more of the elements. The terms \u201ccomprising,\u201d \u201cincluding,\u201d and \u201chaving\u201d are intended to be inclusive and mean that there may be additional elements other than the listed elements.","Industrial automation systems may include controller systems suitable for interfacing with a variety of field devices, such as sensors, pumps, valves, and the like. For example, sensors may provide inputs to the controller system, and the controller system may then derive certain actions in response to the inputs, such as actuating the valves, driving the pumps, and so on. In certain controller systems, such as the Mark\u2122 VIe controller system, available from General Electric Co., of Schenectady, N.Y., data from components of the industrial automation system may be stored in a database system for subsequent analysis and processing. For example, temperature, pressure, flow rate, clearance (e.g., distance between two components) and vibration data of turbomachinery (e.g., gas turbine, steam turbine, compressor, pump) may be used to derive trends, activate alarms, and more generally, to provide for indications of performance of the turbomachine.","In certain embodiments, the industrial control system may include an application programming interface (API) including instructions written in an object-oriented language, such as C++. The API may be used to communicatively interface with the database system. For example, the API may include multiple C++ objects and functions suitable for connecting to the database system, disconnecting from the database system, as well as inserting, updating and retrieving data from the database system. By using the API, a client software written in C++ may more efficiently communicate with the database system. However, because the API is coded in an object-oriented language, reuse in other languages, such as an event-driven language (e.g., Visual Basic), may be difficult. Accordingly, the systems and methods disclosed herein improve reuse of previously written API code by providing for an API wrapper suitable for use in the event-driven language. In one embodiment, the API wrapper may include some or all of the functionality provided by the API, and expose the functionality for reuse by client software written in the event-driven language. Additional functionality may also be provided by the API wrapper, for example, to improve data access to the database system when using the event-driven language. By using the API and the API wrapper, client software written in multiple languages may more easily and efficiently communicate with the database system. Indeed, multiple client software each written in a different language (e.g., object-oriented language, event-driven language) may reuse the API.","With the foregoing in mind, it may be useful to describe an embodiment of an industrial control system incorporating techniques disclosed herein, such as a gas turbine control system  illustrated in . As depicted, the turbine system  may include a combustor . The combustor  may receive fuel that has been mixed with air, for combustion in a chamber within combustor . This combustion creates hot pressurized exhaust gases. The combustor  directs the exhaust gases through a turbine  toward an exhaust outlet . The turbine  may be part of a rotor. As the exhaust gases pass through the turbine , the gases force turbine blades to rotate a drive shaft  along an axis of the turbine system . As illustrated, the drive shaft  is connected to various components of the turbine system , including a compressor .","The drive shaft  may include one or more shafts that may be, for example, concentrically aligned. The drive shaft  may include a shaft connecting the turbine  to the compressor  to form a rotor. The compressor  may include blades coupled to the drive shaft . Thus, rotation of turbine blades in the turbine  causes the shaft connecting the turbine  to the compressor  to rotate blades within the compressor . This compresses air in the compressor . The rotation of blades in the compressor  compresses air that is received via an air intake . The compressed air is fed to the combustor  and mixed with fuel to allow for higher efficiency combustion. The shaft  may also be connected to a load , which may be a vehicle or a stationary load, such as an electrical generator in a power plant or a propeller on an aircraft. When the load  is an electrical generator, the electrical generator may be coupled to a power grid  for distribution of electric power to, for example, residential and commercial electricity users.","The turbine system  may also include a plurality of sensors and field devices configured to monitor a plurality of engine parameters related to the operation and performance of the turbine system . The sensors and field devices may include, for example, inlet sensors and field devices  and outlet sensors and field devices  positioned adjacent to, for example, the inlet and outlet portions of the turbine , and the compressor , respectively. The inlet sensors and field devices  and outlet sensors and field devices  may measure, for example, environmental conditions, such as ambient temperature and ambient pressure, as well as a plurality of engine parameters related to the operation and performance of the turbine system , such as, exhaust gas temperature, rotor speed, engine temperature, engine pressure, gas temperature, engine fuel flow, exhaust flow, vibration, clearance between rotating and stationary components, compressor discharge pressure, pollution (e.g., nitrogen oxides, sulfur oxides, carbon oxides and\/or particulate count), and turbine exhaust pressure. Further, the sensors and field devices  and  may also measure actuator information such as valve position, and a geometry position of variable geometry components (e.g., air inlet).","The plurality of sensors and field devices  and  may also be configured to monitor engine parameters related to various operational phases of the turbine system . Measurements taken by the plurality of sensors and field devices  and  may be transmitted via module lines  and , which may be communicatively coupled to a controller . The controller  may use the measurements to actively control the turbine system . Further, the controller  and\/or the sensors and field devices  and  may store the measurements in a database system, as described in more detail below with respect to . For example, module line  may be utilized to transmit measurements from the compressor , while module line  may be utilized to transmit measurements from the turbine . It is to be understood that other sensors may be used, including combustor  sensors, exhaust  sensors, intake  sensors, and load  sensors. Likewise, any type of field devices may be used, including \u201csmart\u201d field devices such as Fieldbus Foundation, Profibus, and\/or Hart field devices. It is also to be understood that the gas turbine system  is only an example embodiment of turbomachinery, and that other gas turbine systems may include, for example, multiple turbines, multiple shafts, and other arrangement of system  components. Alternatively, the turbomachine may not be a gas turbine system , but may be a steam turbine, a hydroturbine, or a wind turbine.","As mentioned above, the industrial control system  may use a database system, such as an embodiment of a database system  having a data collection system  and a data analysis system , suitable for storing and analyzing turbomachine data, as depicted in . In the depicted embodiment, the data collection system  receives data from the turbine system  such as temperature, pressure, flow rate, vibration, and clearance data, and provides the data to the data analysis system  for further analysis. In one embodiment, the data is collected through sensors and field devices  and , as mentioned above with respect to , by using the controller . An open process control (OPC) system  may then be used to communicatively couple with the controller  and transmit data from the controller  into a master data archiver . The master data archiver  may include a database storage system. For example, the master data archiver  may include a relational database (e.g., Oracle, Microsoft SQL Server, MySQL, PostgreSQL), a network database (e.g., CODASYL, TurboIMAGE), a file, a noSQL database (e.g., BaseX, Apache CouchDB, SimpleDB), or any other type of data storage.","The data gathered by the OPC system  may include data captured at a variety of time frames or resolutions. For example, the data may be captured at every millisecond, every 500 milliseconds, every second, every 10 seconds, every hour, and\/or every day. Further, the master data archiver  may store data from any number of turbine systems . Indeed, the master data archiver  may be communicatively coupled to a plurality of turbine systems , and be used as the data repository for the plurality of turbine systems . By aggregating data from one or more turbine systems , the master data archiver  may be used to analyze individual turbine systems  as well as a fleet of turbine systems .","A first data collector service  included in the data collection system  may be communicatively coupled to a second data collector service  included in the data analysis system  to distribute data from the data collection system  into the data analysis system . In one embodiment, the data collector service  may use a data \u201cpush\u201d technique to move data from the data collection system  into the data analysis system . For example, the \u201cpush\u201d technique may schedule a data transmission of the master data archiver  data into the data analysis system  at a scheduled time, such as every millisecond, every second, every hour, and\/or every day. In certain embodiments, the data \u201cpush\u201d technique may send the most recently updated data rather than the entire data set found in the master data archiver  to more efficiently transmit the recently updated data. In other embodiments, the data collector service  may use a data \u201cpull\u201d technique to retrieve data from the master data archiver  into the data analysis system . For example, the data \u201cpull\u201d technique may schedule the creation of a computer-executable process at certain times (every millisecond, every second, every hour, and\/or every day) to retrieve data from the master data archiver  into the data analysis system .","Regardless of the technique used (e.g., \u201cpush\u201d and\/or \u201cpull\u201d), the data collector service  may then allocate or otherwise partition the data and store the data in a data archiver  referred to by element number , a data archiver  referred to by element number , and\/or a data archiver N referred to by element number . The use of multiple data archivers , ,  enables a more scalable and robust data analysis system . Additional data archivers may be provided as data loads increase, and various load balancing database algorithms may be used to more efficiently distribute queries and\/or data updates among the data archivers , , and .","In one embodiment, each of the data archivers , , and  may include a proper subset of data stored by the master data archiver . That is, the entire master data archiver information may be reconstructed by combining the data stored in the data archiver , , and . In another embodiment, each of the data archivers , , and  may include a full set of the data stored by the master data archiver . An asset model database  may also be included and used to categorize the data found in the data archiver , , and . In one example, the categorization of the data provided by the asset model database  may include the use of a tag data structure. The tag data structure may encapsulate raw measurement data captured by the sensors and field devices  and , and provide for metadata (e.g., data about data and data content) suitable for more efficiently retrieving, inserting, updating, and analyzing the measurement data, as described in more detail below with respect to . A data access system (DAS)  may also be included in the data analysis system . The DAS  may provide for efficient data access to the data archivers , , , the asset model database , or a combination thereof. For example, the DAS  may enable an insert, an update, or a delete of any of the data found in the data archivers , , , and\/or the asset model database . The DAS  may further include a central calculation engine (CCE)  and a central calculation analytical process (CCAP) . By using the CCE  and\/or CCAP , the DAS  may provide for a number of analytics from the data received from the master data archiver . For example, the DAS  may provide for trends in the operational performance of the turbine system .","In one example, temperatures trends, pressures trends, flow rate trends, vibration trends, and\/or clearance trends may be provided by the DAS  (e.g., CCE , CCAP ). A rule trigger workflow  may be communicatively coupled to the DAS  to enable certain downstream processing. For example, conditions or trends provided by the DAS  may trigger certain alarms through the rule trigger workflow . A service oriented architecture (SOA)  be communicatively coupled to the rule trigger workflow , and provide for a loosely coupled or tightly coupled set of software services that enable a set of data access functionality. For example, the SOA  may include web-based services suitable for informing the user of certain conditions or limits that may have been exceeded in the turbine system , as well as providing web access to the analytics provided by the rule trigger workflow .","In the depicted embodiment, an API  is also provided. The API  may be coded or written in an object-oriented language, such as C++, Eiffel, Objective-C, Smalltalk, and the like. The API  provides for objects and functions suitable for interfacing an object-oriented client application  with the DAS , the data archivers , , , and the asset data model . Indeed, the API  may expose all of the functionality provided by the DAS  to reuse the code and functionality included in the DAS . That is, the API  may enable the object-oriented client application  to reuse the objects and functions included in the DAS . Indeed, the API  may be used as a programmatic interface to the DAS  to provide some or all of the functionality provided by the DAS , including the analytics provided by the CCE  and\/or the CCAP . By reusing the API , a control engineer or programmer may more efficiently and rapidly create the object-oriented client application .","However, other languages, such as event-driven languages including Visual Basic, .NET languages (e.g., Visual Basic .NET, C#, Windows PowerShell, ASP .NET) and procedural languages such as PERL, Ruby, Python, and Fortran, may not be able to reuse the API  because the API  may not expose the appropriate programmatic structures suitable for use by languages other than the language used to write the API . For example, the API  may be included in a dynamic link library (.dll) and\/or a static library file (.lib) stored using a file format incompatible with the file format(s) used by an event-driven language client . Additionally, data structures designed in a first language (e.g., object-oriented language) may be incompatible with data structures used in a second language (e.g., event-driven language). Further, data types may also be incompatible. For example, an integer data type may include a big Endian byte ordering (i.e., the most significant byte is the first byte) in the first language, and a little Endian byte ordering in a second language (i.e., the most significant byte is the last byte), or vice versa.","The systems and methods described herein provide for an event-driven language wrapper  suitable for interfacing with the API  with the event-driven client application . For example, the API wrapper  may be included in a .dll and\/or .lib file having a file format compatible with usage by the event-driven client application . Indeed, by providing for the wrapper , the systems and methods disclosed herein enable more efficient reuse of certain components of the database system , including the data archivers , , , the asset model , the DAS , the rule trigger workflow , and the SOA .","In one embodiment, a process  may be used, as further illustrated in , to interface the event-driven client application  with the API . The process  may include code or computer instructions executable in a computing device such as a workstation, laptop, server, tablet, or cell phone. In the depicted embodiment, the event-driven client application  may issue a programmatic request (block ). For example, the event-driven client application  may desire to connect to the database system  shown in , and subsequently request information, insert information, update information, and\/or delete information stored in the database system . Programmatic requests from the event-driven client application  that involve the API  may be processed by the API wrapper . That is, because the API  may not be suitable for direct communication with the event-driven client application , the event-driven client application  may communicate with the API wrapper , and the API wrapper  may then communicate with the API . Accordingly, the API wrapper  may process the request issued by the event-driven client application  and communicate the request to the API  (block ). By providing for an interface to the API , the API wrapper  may enable the reuse of a subset or all of the API . The API  may then process the request (block ). For example, the API  may read or write data stored by the database system , including data stored in the data archivers , , , the asset model database , and data manipulated by the DAS , rule trigger workflow , and SOA .","Some client  requests may result in data output. For example, a read request may produce one or more operational measurements produced by the turbine system . The results of the request, including any errors that may have occurred during processing, may then be communicated (block ) to the API wrapper  by the API . The API wrapper  may then process any results and communicate the results to the event-driven client application  (block ). For example, data types may be converted from the object-oriented data types into the event-driven language data type. In one embodiment, type casting may be used to convert the data types. In this embodiment, an explicit type cast computer instruction, such as \u201cint result=(int) API_result\u201d may be used. It is to be understood that various data types may be similarly type casted, including but not limited to int, float, double, short, long, signed, unsigned, and char. Objects may also be translated into other structures usable by the client application . In this manner, the client application  may receive the results of the request in a desired format and data type, and perform further processing. For example, the results may include one or more tags, as described below with respect to , that may be used by the client application .",{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 4","FIG. 1"],"b":["92","94","96","94","10","98","100","102","104","106","92","94","98","100","102","104","102","100","92","104","94","98","94","94","30","32"]},{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 5","FIG. 2"],"b":["110","110","110","76","112","114","116","118","120","122","124","126","78","76","114","116","118","120","122","124","126","76","114","116","118","120","122","124","78","126","114","116","118","120","122","124","126","128","130","132","134","136","138","140","76","114","116","118","120","122","124","126","128","130","132","134","136","138","140","78","128","130","132","134","136","138","140","128","130","132","134","136","138","140"]},"The API wrapper  may then programmatically call an equivalent programmatic function , , , , , , and  included in the API . In one embodiment, the functions , , , , , , and  may include computer code or instructions written in an objected-oriented language (e.g., C++, Eiffel, Objective-C, Smalltalk). The API  may then process the function call , , , , , , and\/or  and interact with the data analysis system  (e.g., data archivers , , , the asset model database , and data manipulated by the DAS , rule trigger workflow , and SOA ) to service the requests , , , , , , and . For example, the request  may result in the API  establishing a database connection (block ). The request  may result in the API  retrieving a current value (block ). The request  may result in the API  retrieving multiple tag raw data (block ). The request  may result in the API  retrieving raw data (block ). The request  may result in the API  retrieving interpolated data (block ). The request  may result in the API  writing data (block ). The request  may result in the API  ending the dataset connection (block ). The API wrapper  may then process any results obtained through the API  functions , , , , , , and , and return any results to the client application . In this manner, the event-driven client application  may reuse the API . In one embodiment, the programmatic functions , , , , , , and  may be described using C-style terminology similar to Unix manual pages (e.g., \u201cman\u201d pages), presented below in the following seven (7) paragraphs.","HistorianConnect function  establishes a client  connection to the data analysis system . More specifically, the function  attempts to connect to the data analysis system  based on input parameters and returns a status and a server handle for the resulting connection. PARAMETERS (input): Char * username\u2014The user name used to connect. Char * password\u2014The password used to connect. Char * servername\u2014The machine or server name of the data analysis system  to connect to. Long maxRetry\u2014The number of attempts to connect to the data analysis system . Long minSleep\u2014The minimum sleep time (in seconds) used to calculate a wait time for retry attempts. This setting may be initially used to pause\/sleep for the first retry attempt. For subsequent retry attempts, sleep duration may be set to previous sleep time+random (0 to minSleep*1000). Long maxSleep\u2014A maximum sleep time used to set maximum wait time between retry attempts. The setting may be used to pause or sleep during subsequent retry attempts if the calculated sleep time exceeds this maximum value. Long apiTimeout\u2014An amount of time to attempt to connect. Long &serverhandle\u2014A place holder for the server handle (e.g., connection ID) to be returned to the caller. RETURN (output): Long lRet\u2014A code that reflects the status of the connection, including any connection errors. Long serverhandle\u2014A unique ID to assign the connection.","HistorianDisconnect function \u2014Disconnects the client  from the data analysis system . More specifically, the function  attempts to disconnect the client  from the data analysis system  and returns a status of the disconnection. PARAMETERS (input): Long serverhandle\u2014The server handle denoting a specific data analysis system  to disconnect. RETURN (output): Long lRet\u2014The code that reflects the status of the disconnection.","IHWriteFloatData function \u2014Writes data to the data analysis system . More specifically, the function  attempts to write and\/or overwrite data into the data analysis system  based on an input array of tags . PARAMETERS (input): Long serverhandle\u2014The unique connection ID provided by the HistorianConnect . Array tagnameArray\u2014An array of tag names use to write into the data analysis system . Array valueArray\u2014An array of values associated with the tagnameArray and used to write into the data analysis system . Array timestampArray\u2014An array of timestamps associated with the tagnameArray and used to write into the data analysis system . Array qualityArray\u2014An array of quality flags (e.g., good quality, excellent quality) associated with the tagnameArray and used to write into the data analysis system . Long lSize\u2014A number of samples to attempt to write into the data analysis system . Long maxRetry\u2014The maximum number of attempts to retry writing into the data analysis system . RETURN (output): Long lRet\u2014The code that reflects the status of the connection.","IHReadCurrentValue function \u2014Reads the value of a single tag  from the data analysis system . More specifically, the function  attempts to read a value of a specific tag  and to return the value of the tag , along with a timestamp and a quality associated with the tag . PARAMETERS (input): Long serverhandle\u2014The unique connection ID provided by the HistorianConnect function . Char * tagname\u2014A name identifying the tag . Long maxRetry\u2014The maximum number of times to attempt to read the tag . Double & retValue\u2014A placeholder for the value of the tag  that is to be read. Long & utc\u2014A placeholder for the timestamp of the returned data sample. Long & retQuality\u2014A placeholder for the quality of the returned data sample. RETURN (output): Double & retValue\u2014The value read for the tag . Long & utc\u2014The timestamp of the value read for the tag . ihuQualityStatus & retQuality\u2014The quality of the read value. Long lRet\u2014The code that reflects the status of the read operation.","IHReadRawDataByTime function \u2014Retrieves a range of data for a single tag . More specifically, the function  attempts to read the value of a single tag  over a range of time and returns arrays of values, timestamps and qualities, along with the number of samples retrieved. PARAMETERS (input): Long serverhandle\u2014The unique connection ID provided by the HistorianConnect function . Char * tagname\u2014The name of the tag . Long startDT\u2014The start date for retrieving values. Long endDT\u2014The end date for retrieving values. Long maxRetry\u2014The maximum number of times to attempt to read the values. VARIANT &retValueArry\u2014A placeholder for the array of values to read. VARIANT &retTimeArry\u2014A placeholder for the array of timestamps associated with the values to be read. VARIANT &retQualArry\u2014A placeholder for the array of quality for each of the values to be read. Long &retSamples\u2014A placeholder for the total number of raw samples read. RETURN (output): VARIANT &retValueArry\u2014The array of values that was read. VARIANT &retTimeArry\u2014The array of timestamps associated with each of the read values. VARIANT &retQualArry\u2014The array of quality for each of the read values. Long &retSamples\u2014The number of raw samples read. Long lRet\u2014The code that reflects the status of the read operation.","IHReadMultiTagRawDataByTime function \u2014Retrieves a range of data for multiple tags . More specifically, the function  attempts to read the value of a multiple tags  over a range of time and returns arrays of sample size, value, timestamp and quality associated with the tags  that may have been read. PARAMETERS (input): Long serverhandle\u2014The unique connection ID provided by the HistorianConnect function . LPSAFEARRAY * tagnameArray\u2014An array of the plurality of tags  to be read. Long numberOfTags\u2014The number of tags  in the array tagnameArray. Long startDT\u2014The start date for retrieving values. Long endDT\u2014The end date for retrieving values. Long maxRetry\u2014The maximum number of times to attempt to read the values. VARIANT &retSizeArry\u2014A placeholder for the array containing the number of samples returned for each of the plurality of tags . VARIANT &retValueArry\u2014A placeholder for the array of values to be read. VARIANT &retTimeArry\u2014A placeholder for the array of timestamps for each of the values to be read. VARIANT &retQualArry\u2014A placeholder for the array of qualities for each of the values to be read. RETURN (output): VARIANT &retSizeArry\u2014The array of sample sizes retrieved for each of the plurality of tags  that has been read. VARIANT &retValueArry\u2014The array of values read. VARIANT &retTimeArry\u2014The array of timestamps for each of the values read. VARIANT &retQualArry\u2014The array of quality for each of the values read. Long lRet\u2014The code that reflects the status of the read operation.","IHReadMultiTagInterpDataByTime function \u2014Retrieves a range of data for multiple tags on a specified interval. More specifically, the function  attempts to read the value of a plurality of tags  over an interpolated range of time and then returns various arrays, including arrays of sample size, value, timestamp and quality associated with the tags . PARAMETERS (input): Long serverhandle\u2014The unique connection ID provided by the HistorianConnect function . LPSAFEARRAY * tagnameArray\u2014An array including the name of each of the plurality of tags  to be read. Long numberOfTags\u2014The number of tags  in the tagnameArray array. Long startDT\u2014The start date for retrieval of the values. Long endDT\u2014The end date for retrieval of the values. Long interval_sec\u2014An interval (e.g., seconds) of the data to be read. Bool bInterpQueryBySingle\u2014A flag that may be used to determine whether to attempt to query each point individually (True), or in a single batched read (False). Bool bUse1MinuteInterval\u2014If the interval is divisible by 60 seconds and the interval is greater than 1 minute, then this flag is set for better data analysis system  performance. ihuSamplingMode\u2014A sampling mode to use in retrieving the data. Long maxRetry\u2014The maximum number of times to attempt to read the values. VARIANT &retSizeArry\u2014A placeholder for the array containing the number of samples returned for each of the plurality of tags . VARIANT &retValueArry\u2014A placeholder for the array of values to be read. VARIANT &retTimeArry\u2014A placeholder for the array of timestamps of for each of the values to be read. VARIANT &retQualArry\u2014a placeholder for the array of quality for each of the values to be read. RETURN (output): VARIANT &retSizeArry\u2014The array of sample sizes retrieved for each of the tags . VARIANT &retValueArry\u2014The array of values that were read. VARIANT &retTimeArry\u2014The array of timestamps for each of the values read. VARIANT &retQualArry\u2014The array of quality for each of the values read. Long lRet\u2014The code that reflects the status of the read operation. By providing for the functions , , , , , , and , the systems and methods described herein enable a more efficient reuse of the various components of the data analysis system , including the data archivers , , , the asset model database , and data manipulated by the DAS , rule trigger workflow , and SOA .",{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 6","b":["170","78","134","76","72","44","170","170","172","134","174","172","176","134","178","172","72","180","148","180","182","148","182","182","184","170","174"]},"If the \u201cTry\u201d API call to the function  encounters no processing exceptions, then the process  may check to see if the function  returned successfully and resulted in data (e.g., samples greater than zero) (decision ). If the function  returned successfully and resulted in data (e.g., samples greater than zero) (decision ), then safe arrays may be created (block ). Otherwise the process  may increment the current retry value (block ) and iterate to decision . The safe arrays may include arrays having data structures suitable for preventing, for example, data overflow. The safe arrays may include arrays for storing values, times, and quality associated with one or more tags .","The process  may then query the data type for each sample data returned by the function  (block ). In certain embodiments, the function  may provide for a determination of the data types for the data being read (e.g., int, float, double, short, long, signed, unsigned, and\/or char). In one embodiment, the process  may data cast the values read (block ). For example, a C-style \u201c(int)\u201d cast may be used to data cast values into integers. In this same manner, float, double, short, long, signed, unsigned, and\/or char data types may be casted. Data casting may more efficiently and quickly convert the read values into an appropriate data type. In another embodiment, the read value may be stored, for example, as a string (e.g., an array of characters) regardless of the originating data type. In this embodiment, the string may then be converted to a desired data type, for example, by the event-driven client application .","The values provided by the API  may then be stored in the safe arrays (block ) for subsequent processing by the event-driven client application . The process  may then perform the data cleanup (block ), and subsequently exit the function  (circle ). By providing an interface between the event-driven client  and the API , the process  may enable the reuse of functionality included in the API  in a language (e.g., event-driven language) different than originally intended.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 7","b":["196","78","138","76","72","44","196","196","198","138","196","200","200","72","202","72","204"]},"The process  may then compare a current retry value (e.g., curRetry) to a maximum retry value (e.g., maxRetry) (decision ). If the current retry value is greater than the maximum retry value, then the process  may perform a data cleanup (block ) and exit the function  (circle ). The data cleanup may, for example, initialize any error flags with values appropriate for informing of errors, exceptions, and the like. If the current retry value is less than or equal to the maximum retry value, then the process  may use a \u201cTry\u201d function call to call (block ) an API  function, such as the API function ihuWriteData . In the depicted example, the \u201cTry\u201d function call (block ) has an equivalent \u201cCatch\u201d exception handler (block ). The \u201cCatch\u201d exception handler may take over processing if processing exceptions were to occur during execution of the \u201cTry\u201d function call (block ). For example, the \u201cCatch\u201d exception handler (block ) may clean up or release memory resources and then increment the current retry value (block ). The process  may then iterate back to decision .","If the \u201cTry\u201d API call (block ) to the API function  encounters no exceptions, then the process  may check to see if the write of the values was successful (decision ). If the write operation was successful (decision ), then the process  may perform the data cleanup (block ) and exit the function  (circle ). Otherwise, the process  may increment the current retry value (block ) and iterate to decision . By providing for an interface suitable for writing data using the API , the process  may enable the event-driven language client application  to write data into the data analysis system , even though the API  may be written using object-oriented language features.","Technical effects of the invention include enabling the reuse of existing system by providing for a wrapper suitable for interfacing between an application programming interface (API) written in a first object-oriented language and a client application written in a second language, such as an event-driven language. The wrapper may provide for a mapping between data structures in the first language and data structures in the second language. The wrapper may also provide for data type conversion between data types in the first language and data types in the second language. A tag data structure may be used to enable a more efficient retrieval of turbomachinery measurement data. A data collection system and a data analysis system are also described, which may reside in separate computing devices. The data collection system and the data analysis system may be communicatively coupled to each other, enabling a load balancing of large data sets, and a more efficient analysis of the turbomachinery data.","This written description uses examples to disclose the invention, including the best mode, and also to enable any person skilled in the art to practice the invention, including making and using any devices or systems and performing any incorporated methods. The patentable scope of the invention is defined by the claims, and may include other examples that occur to those skilled in the art. Such other examples are intended to be within the scope of the claims if they have structural elements that do not differ from the literal language of the claims, or if they include equivalent structural elements with insubstantial differences from the literal language of the claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["These and other features, aspects, and advantages of the present invention will become better understood when the following detailed description is read with reference to the accompanying drawings in which like characters represent like parts throughout the drawings, wherein:",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
