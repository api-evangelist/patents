---
title: Multi-operational transactional access of in-memory data grids in a client-server environment
abstract: A client computing system identifies a start of a multi-operational transaction pertaining to access of data stored in caches being managed by nodes residing in Java Virtual Machines in an in-memory data grid. The client computing system stores transaction context data indicating the start of the multi-operational transaction and identifies an application request to perform an operation pertaining to the multi-operational transaction. The application request is from an application that resides outside of the Java Virtual Machines of the nodes. The client computing system determines the transaction context of the operation based on the transaction context data and sends an operation request over a network to a managing node in the in-memory data grid to manage the multi-operational transaction. The operation request includes header data based on the transaction context data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08805984&OS=08805984&RS=08805984
owner: Red Hat, Inc.
number: 08805984
owner_city: Raleigh
owner_country: US
publication_date: 20110714
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","DETAILED DESCRIPTION"],"p":["Embodiments of the present invention relate to accessing in-memory data grids. Specifically, the embodiments of the present invention relate to multi-operational transactional access of an in-memory data grid in a client-server environment.","Cloud computing is a model for enabling on-demand network access to a shared pool of configurable computing resources (e.g., networks, servers, storage, applications, and services) that can be rapidly provisioned and released with minimal management effort or service provider interaction. Cloud computing providers currently offer infrastructure as a service (IaaS) and platform as a service (PaaS). IaaS is a provision model in which equipment such as storage equipment, computing equipment, networking equipment, etc. is provided on a per use basis. PaaS is a provision model in which a computing platform and solution stack are delivered to clients as a service on a per use basis. Each of these services has the properties of elasticity (ability to deal with new nodes being added and existing nodes being removed dynamically), high availability, scalability, and linear response times.","One service that has not been successfully moved to the cloud computing model is managed data storage, which is conventionally performed by databases. Data storage is stateful, which makes data as a service (DaaS) much more challenging than any of the other categories of cloud computing. Traditional data storage uses databases such as structured query language (SQL) and not only SQL (NoSQL) databases. Databases do not scale, so they tend to run on a single machine or a few machines running in a fixed cluster. Therefore, databases are not distributed by nature. This becomes a problem in the cloud because in clouds there is no guarantee that a particular server will be available at any given time. The lack of distribution for databases hampers elasticity and high availability, two of the requirements for cloud computing services. Therefore traditional database data storage does not work for DaaS.","Distributed databases, also known as data grids and in-memory data grids, have since become a better alternative to databases in clouds. Examples of data grid platforms include, for example, JBoss\u00ae Infinispan\u00ae, Oracle\u00ae Coherence\u00ae or Hadoop\u2122. Data grids can scale up to thousands of nodes. Data grid platforms also improve the scalability of non-cloud applications by removing database bottlenecks and single points of failure. Traditionally, clients have interacted with a data grid platform, such as Infinispan\u00ae, in a peer-to-peer (P2P) manner, where the data grid platform and the client code that accesses the data grid platform reside within the same virtual memory. In a P2P environment, clients can perform XA transactions. In the XA (X\/Open XA) architecture, an XA transaction is a distributed transaction that consists of multiple operations that access resources, such as an in-memory data grid. For example, a banking application wishes to conduct an XA transaction that consists of two operations (1) deduct money from a first bank account and (2) add the deducted money to a second bank account. Either both of the operations relating to the XA transaction will be permanent, if successful, or none of them will occur, and the data in an in-memory data grid relating to the bank accounts can be rolled back to a previous state as if the transaction never occurred. Traditionally, XA transactions of an in-memory data grid are limited to a P2P environment. However, there are situations when accessing a data grid platform in a client-server mode makes more sense than accessing it via P2P. Conventional client-server access to a data grid, however, is limited to simple, non-transactional access.","Embodiments of the invention are directed to a method and system for providing multi-operational transactional access of an in-memory data grid in a client-server environment. A client computing system identifies a start of a multi-operational transaction pertaining to access of data stored in caches being managed by nodes residing in Java Virtual Machines in an in-memory data grid. The client computing system stores transaction context data indicating the start of the multi-operational transaction and identifies an application request to perform an operation pertaining to the multi-operational transaction. The application request is from an application that resides outside of the Java Virtual Machines of the nodes. The client computing system determines the transaction context of the operation based on the transaction context data and sends an operation request over a network to a managing node in the in-memory data grid to manage the multi-operational transaction. The operation request includes header data based on the transaction context data.","Embodiments of the present invention allow multi-operational transactional access to an in-memory data grid in a client-server environment. Multiple operations pertaining to a transaction that access an in-memory data grid can either all occur or not. In addition, embodiments of the invention utilize a binary language-neutral protocol to provide support for heterogeneous client and server systems. Use of the language-neutral protocol can allow applications that are written in different programming languages that are different from the programming language of a data grid to access the data grid.",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1","b":["100","100","103","105","110","115","120","122","124"]},"Machines , , , , , ,  may be hardware machines such as desktop computers, laptop computers, servers, or other computing devices. Each of the machines , , , , , ,  may include an operating system that manages an allocation of resources of the computing device (e.g., by allocating memory, prioritizing system requests, controlling input and output devices, managing file systems, facilitating networking, etc.). In one embodiment, one or more of the machines , , , , , ,  is a virtual machine. For example, one or more of the machines may be a virtual machine provided by Amazon\u00ae Elastic Compute Cloud (Amazon EC2), a VMWare\u00ae virtual machine, etc. In some instances, some machines may be virtual machines running on the same computing device (e.g., sharing the same underlying hardware resources). In one embodiment, one or more of the machines , , ,  is a Java Virtual Machine (JVM), which may run on a hardware machine or on another virtual machine.","Machines , , ,  each include a data grid node A-D that runs on the machine. The data grid node A-D is a data grid application, such as an instance of JBoss\u00ae Infinispan\u00ae, Oracle\u00ae Coherence\u00ae or Hadoop\u2122. Each data grid node A-D may act as a server for data to clients and as a peer to other data grid nodes A-D. Data grid nodes A-D are discussed in greater detail below with reference to .","The data grid nodes A-D may communicate via the network to form an in-memory data grid . This may include using peer-to-peer protocols to establish and manage membership of the in-memory data grid . The peer-to-peer protocols may include functionality for group creation and deletion, peer discovery, peer communication, and so on. In one embodiment, JGroups is used as an underlying peer-to-peer communication mechanism. Alternatively, other peer-to-peer protocols may be used.","The in-memory data grid  is a data store that spans multiple machines , , ,  that are joined in a dynamic cluster. In one embodiment, the in-memory data grid  is a NoSQL based data store. The in-memory data grid  can be provided to clients using a DaaS model.","In one embodiment, the in-memory data grid  operates in a client-server mode, in which the in-memory data grid  serves resources (e.g., a stateful data store such as a cache) to client applications . In one embodiment, the in-memory data grid  acts as a shared storage tier for client applications . A separate memory space may be generated for each client application . A client application  can be any type of application including, for example, a web application, a desktop application, a database management application, a browser application, etc.","The in-memory data grid  may include a volatile in-memory data structure such as a distributed cache. A data grid may also provide a persistent data structure (e.g., a data structure stored in non-volatile disk storage). In one embodiment, the in-memory data grid  provides a distributed cache with write through or write behind to persistent storage. In one embodiment, Amazon Simple Storage (S3) platform hosts the data for the in-memory data grid  as part of a cache store. Other key value based storage systems may also be used to host the data grid's  data. An in-memory data grid  primarily relies on main memory for data storage. In-memory data grids  are faster than disk-optimized data grids since they execute fewer CPU instructions. For brevity and simplicity, an in-memory data grid  is used as an example of a data grid throughout this document.","In client-server mode, instances of the data grid nodes A-D each start up in a Java Virtual Machine, and a client application  can reside outside of the Java Virtual Machines of the data grid nodes A-D. In client-server mode, a client application  may not be a Java-based application and may not reside in a Java Virtual Machine. In one embodiment, the in-memory data grid  is indistinguishable from a database to users and client applications . Therefore, client applications  may use conventional database formats, protocols and semantics for communicating with the in-memory data grid . For example, client applications  may communicate with the in-memory data grid  using the Hot Rod protocol, the memcached protocol, the REST protocol, the OData protocol, the Websockets protocol, SQL, etc.","However, unlike a database, the in-memory data grid  actually distributes stored data across multiple machines , , , . The in-memory data grid  is elastic (can deal with new nodes being added and nodes being removed), scalable and highly available. The in-memory data grid  may also perform load balancing and failover of individual data grid nodes A-D. Therefore, the in-memory data grid  performs the functions normally provided by databases, but can provide these functions using a DaaS model.","In one embodiment, the data grid nodes A-D form a distributed cluster, which causes the in-memory data grid  to be a distributed data grid. This enables the in-memory data grid  to scale linearly as more data grid nodes A-D are added to the cluster. In one embodiment, distribution makes use of a consistent hash algorithm to determine where in the cluster entries should be stored. The hashing algorithm may be configured to maintain a specified number of copies of each entry in the in-memory data grid . In one embodiment, the hashing algorithm is deterministic in locating entries without resorting to multicasting requests or maintaining expensive metadata.","In one embodiment, the in-memory data grid  provides a rich and powerful application programming interface (API) that looks and feels like a database. A client may communicate with any data grid node A-D of the in-memory data grid  to access data stored in the in-memory data grid . A data grid node A-D may receive database commands, such as commands to store objects, to retrieve objects, to perform searches, etc. When a data grid node A-D receives a command to store an object, the data grid node A-D divides the object into a collection of linked key value pairs. The data grid node A-D then stores some or all of these key value pairs. Additional data grid nodes A-D may also store some or all of the key value pairs. One embodiment of linking key value pairs is described in greater detail below in conjunction with . When any of the data grid nodes A-D receives a request for the stored object, that data grid node A-D gathers up all of the key value pairs for that object, and reconstructs the object from the key value pairs. This may involve requesting the key value pairs from one or more other data grid nodes A-D. Once the object is reconstructed, the data grid node A-D returns the object to the client from which the request was received.","The data grid nodes A-D are each configured to operate using a specific protocol. Therefore, the data grid nodes A-D expect to receive objects having a specific type and commands having a specific format. The data grid nodes A-D operate on objects having a predefined type. In one embodiment, the data grid nodes A-D operate on Java objects and\/or on Javascript object notation (JSON) objects. Client applications  may communicate with the in-memory data grid  using the specific protocol that the in-memory data grid  uses to manage data. In one embodiment, the data grid nodes A-D are configured to respond to commands formatted in a key value based NoSQL database format. Alternatively, clients may communicate with the in-memory data grid  using additional protocols.","To enable clients configured for different protocols to access the in-memory data grid , the in-memory data grid  may include one or more proxy servers , , . Each proxy server , ,  may be used to translate objects and requests into the specific formats used by the data grid nodes A-D. Each proxy server , ,  includes internal rules on how to translate an incoming protocol into a protocol used by the in-memory data grid , and how to translate responses going out from the protocol used by the in-memory data grid  into the protocol used by the client application  or by a specific component , ,  of the client application .","In one embodiment, one or more of the data grid nodes A-D is collocated with a proxy server , , . Additionally, a data grid node A-D may be collocated with multiple proxy servers , , . The proxy servers , ,  provide a layer of indirection for the in-memory data grid . Each proxy server , ,  is configured to translate objects and requests between the specific protocol supported by the data grid nodes A-D and an external protocol. Examples of proxy servers include a REST proxy server , a memcached proxy server  and a Hot Rod proxy server . Other examples of proxy servers include a web socket proxy server, an OData proxy server, etc.","Each proxy server , ,  may be an endpoint that appears to client applications  as a backend storage server. Client applications  may communicate with the proxy servers , ,  as though the proxy servers are full backend storage servers. Each proxy server , ,  may be configured to listen to a specific port or ports, and act on messages sent to those ports.","To use the in-memory data grid , a client application  acquires a session from the in-memory data grid , and sends commands to the in-memory data grid  via the session. Client application  may be a standalone application running on a single machine. Alternatively, client application  may be a system with multiple clients , , , each of which may run in a separate machine , , . The clients , ,  may each run on a different system, use a different protocol, be written in a different language, operate on a different platform, etc. For example, a web application may have a Java middleware component that serves up web applications, and another component that is a part of one of the web applications. For example, if a web application uses Ajax and client side Javascript in a user's browser, the user's browser may communicate directly to the in-memory data grid  to populate the browser's screen. A third component of the client application  may be a python script that monitors all data and processes orders as and when they are placed in the in-memory data grid .","In one example embodiment, the client application  includes a memcached client , a REST client , and a Hot Rod client . Each of these clients , ,  may communicate with the distributed in-memory data grid  using their specific protocols. In one embodiment, each client is configured to communicate with a particular proxy server (e.g., is configured with a network address of the particular proxy server). Each client may also be configured with network addresses of multiple proxy servers, and may be able to fail over across the proxy servers. For example, each client may be configured with a network address or addresses for a cluster of proxy servers, wherein each proxy server in the cluster handles communications formatted according to the protocol used by the client. In one embodiment, a load balancer (e.g., an HTTP load balancer for a REST proxy server ) manages load for the cluster. Examples of HTTP load balancers include Apache\u00ae mod_cluster, Jboss\u00ae mode_cluster, Big-IP\u00ae, etc. Other load balancers may be used for the REST proxy servers and\/or for other proxy servers.","In an example, the Hot Rod client  may send an object and a request that are formatted according to the Hot Rod protocol to the distributed in-memory data grid . Hot Rod is a general purpose protocol for accessing in-memory data grids in a client-server environment. Hot Rod is a binary protocol to ensure platform neutral behavior. The request and object may be received by the Hot Rod proxy server  and translated into the backend protocol used by data grid nodes A-D. The data grid nodes A-D may then perform one or more operations in response to the request.","A number of operations can be performed on the in-memory data grid . Conventional operations include simple operations, such as, get, put, remove, and replace. Getting and updating data in the in-memory data grid  may be performed by calling get, put, remove and\/or replace functions on an instance of the in-memory data grid . Traditional access to an in-memory data grid  in a client-server environment has been limited to simple operations and does not include multi-operational transactions. A multi-operational transaction can be an XA transaction. In the XA (X\/Open XA) architecture, an XA transaction is a distributed transaction that consists of multiple operations that access one or more resources.","Unlike a client-server environment to access an in-memory data grid , a client, such as a Hot Rod client , can include a transaction manager adapter  and a transaction operator  to add support for multi-operational transactional access of the data grid nodes A-D in the in-memory data grid  in a client-server environment. The transaction manager adapter  can track the current context with regard to whether operations being requested by a client application  are in the context of a transaction or not. The transaction operator  can add new operations, for example, start, prepare, commit, rollback, and recover operations, to perform multi-operational transactional access on the in-memory data grid  in a client-server environment. Performing operations that pertain to multi-operational transactional access on data in the in-memory data grid  may be performed by calling the get, put, remove, replace, start, prepare, commit, rollback, and recover functions on an instance of the in-memory data grid .","A proxy server, such as a Hot Rot proxy server , can include a transaction context decoder , that can receive requests pertaining to a multi-operational transaction from a transaction operator  and can decode and translate the request in a protocol that is compliant with a resource manager  in a data grid node, such as node C. A data grid node A-D can include a resource manager  to store data for tracking all operation requests associated with a transaction identifier. A data grid node C-D that includes a resource manager  can be a resource manager data grid node to manage the operations pertaining to a transaction. The resource manager  can be an XA compliant resource manager. The resource manager  can pass along an operation request to a data grid node A-D.","The operations that pertain to a transaction are considered to be within the scope of a transaction. Some multi-operational transactional standards, such as the XA standard, use a two-phase commit protocol to ensure that all resources enlisted within a transaction either commit or rollback any particular transaction consistently (all of the resources do the same). A transaction must succeed or fail as a complete unit. If any of the operations within the scope of a transaction are not successful, none of the operations within the scope of the transaction are committed to an in-memory data grid .","For example, a banking application  wishes to conduct a transaction that consists of two access operations: (1) deduct money from a first bank account and (2) add the deducted money to a second bank account. The bank accounts can have data in one or more data grid nodes A-D in the in-memory data grid . For example, the data for the first bank account is stored in data grid node A and the data for the second bank account in stored in data grid node B. The operations may be requests to change the dollar amount in each bank account. The banking application  can make requests for transactional access of the in-memory data grids  via the transaction manager , transaction manager adapter , transaction operator , transaction context decoder , and resource manager . Before the operation that deducts money from the first bank account is committed to data grid node A in the in-memory data grid , the resource manager  can first ensure that the operation made to add money to the second bank account in data grid node B is successful. The resource manager  can make sure that either all of the operations within the scope of transaction successfully happen or none of them occur. For instance, there may be a system failure or an operation failure pertaining to one of the data grid node A-D with regard to deducting money from the first bank account and\/or adding money to the second bank account. In such a case, the banking application  may wish that the operations that deducted money from the first bank account and adding money to the second account, as well as any other operations performed within the scope of the transaction, rollback to a previous state.","In one embodiment, communications may be routed to an appropriate proxy server , , , which may then translate the communications into the protocol used by the data grid nodes A-D on the back end (e.g., into a key value based NoSQL database format). In one embodiment, each data grid node A-D includes a request router (not shown). Additionally, or in the alternative, each proxy server may include a request router. The request router may determine, based on a format of a received communication, the protocol in which the communication was formatted. For example, the request router may include different communication categorization rules. If a received communication satisfies, for example, a Hot Rod protocol communication categorization rule, the data grid node A-D may determine that the communication is formatted according to the Hot Rod protocol. The request router may forward the communication to an appropriate proxy server that is configured to handle communications having the determined protocol. In one embodiment, the request router includes a table of proxy servers, each entry in the table including one or more addresses for proxy servers and an associated protocol. The table may be used to determine a proxy server to forward a communication to.",{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 2A","FIG. 1","FIG. 1"],"b":["200","200","151","155","160","200","160","261","263","261","263"]},"The transaction manager adapter  can identify a start of a multi-operational transaction to access data in an in-memory data grid. The multi-operational transaction can be an X\/Open XA transaction. An application can send an XA compliant transaction manager notification of the start of the multi-operational transaction and the XA compliant transaction manager can notify the transaction manager adapter  of the start of the transaction. The XA compliant transaction manager can generate and provide a transaction identifier for the transaction to the transaction manager adapter . The multi-operational transaction can pertain to access of data stored in caches being managed by a nodes residing in Java Virtual Machines in an in-memory data grid. The transaction manager adapter  can store transaction context data  in a data store that is coupled to the transaction manager adapter . The transaction context data  can indicate that the client is in a multi-operational transaction mode for a particular transaction. The transaction context data  can include a transaction identifier. The transaction identifier can be a XA compliant transaction identifier.","A data store  can be a persistent storage unit. A persistent storage unit can be a local storage unit or a remote storage unit. Persistent storage units can be a magnetic storage unit, optical storage unit, solid state storage unit, electronic storage units (main memory), or similar storage unit. Persistent storage units can be a monolithic device or a distributed set of devices. A \u2018set\u2019, as used herein, refers to any positive whole number of items.","The transaction operator  can identify an application request to perform an operation for the transaction. For example, the application request is to put a value of $0 in bank account 5552191234. The transaction operator  can receive a method call via an API from an application requesting an operation to be performed on the data stored in the caches in the in-memory data grid. The application resides outside of the Java Virtual Machines of the nodes in the in-memory data grid. The transaction operator  can query the transaction manager adapter  to determine what state the transaction manager adapter is in . The transaction manager adapter  can examine the transaction context data  and respond to the query. For example, the transaction manager adapter  sends a query response to the transaction operator  that the state is in a multi-operational transaction state.","When the transaction context data  reflects a multi-operational transaction state, the transaction operator  can add transaction context data to a header for a request to send to a node in the in-memory data grid to perform the operation requested by the application. A request header can contain a transaction type field and a transaction identifier field. Table 1 below illustrates a portion of an exemplary request header.",{"@attributes":{"id":"p-0050","num":"0049"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[TX_TYPE] [TX_ID]"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The transaction identifier can include a field, such as [TX_TYPE], to represent a transaction type. The transaction type field can be a one byte field and can contain a value that represents whether a request is associated with a transaction. Table 2 below illustrates exemplary field values and type descriptions. The transaction type field can be extended to include other transaction types. The transaction operator  can set the value in the transaction type field.",{"@attributes":{"id":"p-0052","num":"0051"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["TX_TYPE",{}]},{"entry":["Value","Type Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","Non-transactional call, or client does not support"]},{"entry":[{},"transactions. The subsequent TX_ID field can be omitted."]},{"entry":["1","Multi-operational transaction identifier (XID). The XID can"]},{"entry":[{},"be an a fixed-size format."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The request header can also include a field, such as [TX_ID], to represent a transaction identifier. The transaction identifier field can be a fixed-length byte array containing a transaction ID (identifier). The length and format of the transaction identifier can be associated with the value of the transaction type field. For example, TX_TYPE of 0 can mean a O-length TX_ID. The client can generate and include a transaction identifier in the request header.","The transaction operator  can identify a resource manager data grid node in the in-memory data grid to manage the transaction. For example, the transaction operator  can randomly select one of the machines in the in-memory data grid that includes a transaction context decoder and a resource manager. In another example, a client application may specify in an application request which machine in the data grid should manage the transaction. The transaction operator  can store resource management node tracking data  in a data store to track which node is the resource manager data grid node to manage the particular transaction. The resource management node tracking data can include, for example, a transaction identifier and a corresponding machine identifier and\/or node identifier. Any subsequent requests to be sent to the in-memory data grid for a particular transaction identifier can be sent to the same resource manager data grid node that has been assigned to the particular transaction identifier as specified by the resource management node tracking data .","The transaction operator  can send an operation request over a network to the resource manager data grid node in the in-memory data grid. The transaction operator  can generate and send an operation request for prepare, rollback, commit, and recover operations. The operation request can include a request header that contains a transaction type field and transaction identifier field. For example, the operation request has a transaction type field value of \u20181\u2019 to indicate that the operation is associated with a transaction. The header data can also include an operation code for the operation to be performed and a cache name of the cache that stores the data for the operation.","The transaction operator  can identify a next application request to perform an operation relating to a multi-operational transaction. For example, the next application request is for an operation to PUT a value of $1000 in bank account 5558675309. The transaction operator  can determine which node in the data grid is the resource manager data grid node for this particular transaction by comparing the transaction identifier in the next application request to the resource management node tracking data . The transaction operator  can send a next operation request over a network to the resource manager data grid node in the in-memory data grid. The next operation request can include the transaction type and transaction identifier in a header.","A request for a prepare operation is a request for a resource manager data grid node to cause any operations that were performed for a particular transaction to be prepared for commitment. A prepare operation request can cause data grid nodes that have performed operations relating to a particular transaction to take the necessary steps for ensuring that a future commit request will succeed. A request for a commit operation is a request for a resource manager data grid node to cause any operations that were performed for a particular transaction to be committed. A commit operation request is a request for a resource manager data grid node to make a set of changes that were made to a cache permanent. A request for a rollback operation is a request for a resource manager data grid node to cause any operation that were performed for a particular transaction to be returned to a previous state. A request for a recover operation is a request receive a list of all prepared or heuristically finished transactions to confirm whether or not a particular transaction was successfully committed. A transaction that is listed in a prepared state can be an indication that the transaction is not yet committed.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":["FIG. 2B","FIG. 1"],"b":["250","250","140","130","135","250","250","205","250","250"]},"Each proxy server  listens on a specified port or ports. Clients connect to a port, send commands to the proxy server, read responses, and eventually close the connection. Each proxy server  provides a distinct mechanism (e.g., an application programming interface (API)) for connecting to the same data grid, and operates as a distinct endpoint for the data grid. For example, the REST proxy server includes a REST API that enables a REST client to interact with the data grid using standard hypertext transport protocol (HTTP) commands. By providing multiple protocols for communicating with the data grid, multiple different clients written in different languages, running on different platforms, and performing different actions can all use the same data.","In one embodiment, each proxy server  includes a client side translator , a data grid side translator  and a message forwarder . Proxy server  receives a message  from a client that is formatted according to a first protocol. In one embodiment, a proxy server , such as one using the Hot Rod protocol (e.g., proxy server  in ), includes a transaction context decoder  as another server-side component. A transaction context decoder  supports transactional client-server access to the data grid. The received message  may include an object (data) to be stored. Transaction context decoder  reads any transaction identifier that may be included in a header in the message  and translates the message  and\/or the object into a second format that is compliant with a protocol used by a resource manager in a data grid node to handle the multi-operational transaction aspects of the message . For example, the transaction context decoder  can translate the message  to be XA compliant. In one embodiment, client side translator  also translates the message  and\/or the object into a format that is compliant with a protocol used by a data grid node. In one embodiment, the object is translated into a Java object or a JSON object. Message forwarder  then forwards the translated message  and object to the resource manager on the data grid node.","The data grid node generates a response message  having a format compliant with the protocol of the data grid node, and sends this response to proxy server . The response  may include an object (e.g., if the message was a request for an object). Data grid side translator  translates the response message  and\/or the object from the second protocol to a format compliant with the protocol used by the resource manager in the data grid node to handle the multi-operational transaction aspects of the message . In one embodiment, data grid side translator  also translates the message  and\/or the object into a format that is compliant with a protocol used by the client. For example, data grid side translator  may translate a JSON object into a binary array or base  encoded binary data. Message forwarder  then forwards the translated response  and\/or object to the client. Therefore, each proxy server  is able to encode and decode data so that it is able to communicate with clients in a manner compliant to a first protocol and is able to communicate with data grid nodes in a manner compliant to a second protocol.","In one embodiment, the proxy server  is clustered with other proxy servers of the same type. This can enable the proxy server  to perform load balancing and failover. Clients wanting to load balance or failover between Hot Rod proxy servers can do so with the Hot Rod proxy server replicating or distributing data using, for example, consistent hash algorithms.","In one embodiment, the proxy server  is a Hot Rod proxy server. The Hot Rod proxy server translates messages and data between a format compliant with the Hot Rod protocol and a format compliant with another protocol used by the data grid. This allows clients using protocols that are different from the protocol used by the data grid to be able to communicate with the data grid. The Hot Rod protocol is a binary client-server protocol that transmits keys and values as bytes to ensure platform neutral behavior. Hot Rod clients communicate with the Hot Rod proxy server through transmission control protocol (TCP) connections. In one embodiment, the implementation of the protocol uses the Java programming language. Hot Rod allows for dynamic load balancing and failure. A Hot Rod client can dynamically detect changes in the topology of Hot Rod servers when they are clustered. When new data grid nodes are added or removed, Hot Rod clients can update a topology view of a Hot Rod server topology. When Hot Rod server are configured with distribution, Hot Rod clients can detect where a particular key resides and can route request intelligently.","Hot Rod includes several operations, such as get, remove, put, replace, remove, and is extended to include operations to support multi-operational transactions, such as start transaction, prepare, commit, rollback, and recover. An operation can ask the Hot Rod proxy server to perform an operation on some data identified by a key. One embodiment of linking key value pairs is described in greater detail below in conjunction with .",{"@attributes":{"id":"p-0065","num":"0064"},"figref":["FIG. 2C","FIG. 1","FIG. 1"],"b":["205","205","125","205","125","205","250","205","205"]},"The data grid node  operates in a cluster with other data grid nodes to form a data grid. Each data grid node  may act as a server for the data grid. Therefore, a client may access any of the data grid nodes  to gain access to the entire data grid. New data grid nodes can be started and connected to the other data grid nodes without performing rehashing or state transfer. Therefore, startup times for new data grid nodes can be predictable and relatively short.","In one embodiment, the data grid node  includes a client interaction module , a resource manager , an operation manager , and a key value store engine . The client interaction module  receives requests from clients and sends responses to clients. Requests may include requests to store objects, to retrieve objects, to search for objects, to retrieve information about objects, and so on. Responses may include objects, information about objects, confirmation messages, error messages, etc. The requests and responses are configured in a specific format understandable to the data grid node . Received requests may have been translated into the specific format by a proxy server. In one embodiment, the requests and responses have a key value based NoSQL database format. For example, the requests, responses and\/or objects (payloads) may have a simple format of keys mapped to values.","Requests may include requests to perform operations. A number of operations can be performed on the data grid such as get, put, remove, notify and unnotify. Getting and updating data in the data grid may be performed by calling the get, put and remove functions on an instance of the data grid. A transaction made up of multiple operations can be performed on the data grid. The multi-operational transaction can be an XA transaction. Additional operations can be performed on the data grid to support multi-operational transactions, such as start, prepare, rollback, commit, and recover. Starting a transaction, preparing data, rolling back data, committing data, and recovering data in the data grid may be performed by calling start, prepare, rollback, commit, and rollback functions on an instance of the data grid. These operations could be triggered by user interaction with a web form, for example.","When the client interaction module  receives a request to perform an operation, the resource manager  can examine transaction context data in a header in the operation request to determine whether the operation is associated with a multi-operational transaction. The transaction context data can include a transaction type and a transaction identifier. The resource manager  can store operation tracking data  in a data store that is coupled to the resource manager  to track which operations are associated with particular transaction identifiers.","An operation request can include a key-value pair indicating the data that is to be operated on and a value for the operation and the data. For example, the operation request is to put a value of $0 in bank account 5552191234. The operation request can include a key that represents the account number, such as \u2018552191234\u2019, and a value, such as \u20180\u2019. The key value store engine  can obtain a key-value pair from an operation request and can store the key-value pair  in an in-memory container. The key value pairs  can be distributed across the data grid. That way the stored object is fault tolerant and highly available.","The key value store engine  can use a cache name and a key that is specified in an operation request to identify which nodes have cache data associated with cache name and the key. The resource manager  can store node tracking data  in a data store that is coupled to the resource manager  to associate the node with the transaction identifier. The node tracking data  can include the transaction identifier and a node identifier. The resource manager  can send the operation request to the identified node to perform the operation.","A data grid node  which is identified by a key value store engine  to have cache data that is associated with cache name and the key in an operation request can include an operation manager  to perform the requested operation (e.g., put, replace, prepare, rollback, commit) on the cache data that is coupled to the operation manager . The operation manager  can receive an operation request from a resource manager  to perform an operation on a local cache. The request may be to perform a get, put, remove, replace, prepare, rollback, commit, or recover. The operation manager  can examine a field in the header of the operation request to determine whether the operation request is associated with a multi-operational transaction. The operation manager  can identify a transaction identifier for the transaction from a field in the header of the operation request and store operation tracking data  in a data store that is coupled to the operation manager  to associate the operation to be performed with the transaction identifier. The operation tracking data  can include the transaction identifier and an operation identifier. The operation manager  can perform the operation (e.g., put, replace, prepare, rollback, commit) on the cache using the key and value that is included in the request. One embodiment of an operation manager performing prepare, rollback, and commit operations is described in greater detail below in conjunction with .","When an operation request is for a prepare, commit, rollback, or recover operation, the resource manager  examine the node tracking data  to identify which nodes have performed operations that are associated with the transaction identifier. The resource manager  can send an operation request to each identified node to perform the operation. Each data grid node that is associated with the transaction identifier can receive the operation request, perform operation (e.g., prepare, rollback, commit), and send a status response to the resource manager data grid node. The resource manager  can receive a status response from each node can send out another operation request based on the received status responses. For example, a status response can indicate that the operations that were performed were successfully prepared for commitment or that the operations were not successfully prepared. If the resource manager  node receives successful status responses from each of the node, the resource manager  can send an operation request to the nodes that performed the prepare operations to now commit the operations.",{"@attributes":{"id":"p-0074","num":"0073"},"figref":["FIG. 3","FIG. 1"],"b":["300","300","300","160","301","303","305","307","309"]},"At block , the client identifies a resource manager data grid node in the data grid to manage the transaction and stores resource management node tracking data to track which node is the resource manager data grid node to manage the transaction at block . The resource management node tracking data can include, for example, a transaction identifier and a corresponding machine identifier and\/or node identifier. Any subsequent requests to be sent to the a node in the in-memory data grid for a particular transaction identifier can be sent to the same resource manager data grid node that has been assigned to the particular transaction identifier as specified by the resource management node tracking data.","At block , the client sends an operation request over a network to the managing node in the in-memory data grid to manage the multi-operational transaction of accessing the caches being managed by the nodes in the in-memory data grid. The operation request can include a request header that contains a transaction type field and transaction identifier field. For example, the operation request has a transaction type field value of \u20181\u2019 to indicate that the operation is associated with a transaction. At block , the client identifies a next application request to perform an operation relating to a multi-operational transaction. For example, the operation is to put a value of $1000 in bank account 5558675309. At block , the client determines which node in the data grid is the resource manager data grid node for this particular transaction. The client locates the transaction identifier the header data in the next application request and searches the management node tracking data for a match and the node that is assigned to managed this particular transaction. At block , the client sends a next operation request over a network to the resource manager data grid node in the in-memory data grid. Method  can be a recursive method, such that the client can receive additional application requests to perform operations, determine which node is the resource manager data grid node that is managing the transaction, and send the requests to the resource manager data grid node.",{"@attributes":{"id":"p-0077","num":"0076"},"figref":["FIG. 4","FIG. 1"],"b":["400","400","400","125"]},"At block , the resource manager data grid node receives an operation request to perform an operation to access data in an in-memory data grid. For example, the operation is to put a value of $0 in bank account number 5552191234. The request can include a cache name. For example, the cache name may be \u201cbank account\u201d and can store a bank account object.  illustrates an object  and a collection of key value pairs  generated from the object , in accordance with one embodiment of the present invention. As shown, the object  includes the following fields: owner name , account balance , owner social security number (SSN)  and contact information . Fields , ,  have primitive types. However, the contact information field  is a complex field for an internal object. The internal object has a primary contact field  and a secondary contact field , both of which are themselves complex fields for further internal objects. Primary contact field  includes an address field , and a street name field . Similarly, secondary contact field  includes an address field  and a street name field .","The collection of key value pairs  includes a primary key value pair . The primary key value pair  has a key of \u201c5552191234\u201d that represents an account number, which a data grid node can use to retrieve the primary key value pair . The primary key value pair's values are pointers to key value pairs , , , . Key value pairs , ,  were generated from fields having primitive types. Therefore, the values of these key value pairs , ,  are the contents of those fields.","Key value pair  was generated for an internal object (complex field ). Therefore, key value pair  is a primary key value pair for the internal object. Key value pair  includes pointers to key value pairs , . Each of key value pairs ,  is a primary key value pair for an additional nested object. Key value pair  includes pointers to key value pairs , . Key value pair  includes pointers to key value pairs , . Due to the pointers linking the key value pairs, a data grid node can retrieve all of the key value pairs and use them to reconstruct the object based on the unique identifier \u201c5552191234.\u201d","Returning to , at block , the resource manager data grid node examines a field in the header of the operation request describing whether the request is associated with a transaction. If the operation request is not associated with a multi-operational transaction (block ), the resource manager data grid node determines which node in the data grid to send the operation request to and sends an operation request to the node at block . The nodes store mapping data of which caches reside in which nodes. The request can specify a cache name and key and the resource manager data grid node can use the mapping data to send the request to a node in the data grid that contains a cache having the cache name and key.","If the operation request is associated with a multi-operational transaction (block ), the resource manager data grid node identifies a node having cache data associated with a cache name (e.g., bank account) in the header of the operation request at block . At block , the resource manager data grid node identifies a transaction identifier for the transaction from a field in the header and stores node tracking data to associate the node with the transaction identifier. The node tracking data can include the transaction identifier and a node identifier. At block , the resource manager data grid node sends the request to the identified node to perform the operation. Method  can be a recursive method, such that the resource manager data grid node can receive additional operation requests, determine whether a request is associated with a transaction, update the node tracking data, and send the requests to the appropriate nodes to perform the operations. For example, an additional operation request is to put a value of $1000 in bank account 5558675309.",{"@attributes":{"id":"p-0083","num":"0082"},"figref":["FIG. 6","FIG. 1","FIG. 7"],"b":["600","600","600","125","601","603","605","611","605","611","600"]},{"@attributes":{"id":"p-0084","num":"0083"},"figref":["FIG. 7","FIG. 1"],"b":["700","700","700","125","701","703","705","707"]},{"@attributes":{"id":"p-0085","num":"0084"},"figref":["FIG. 8","FIG. 1"],"b":["800","800","800","125","801","803","805","807"]},{"@attributes":{"id":"p-0086","num":"0085"},"figref":["FIG. 9","FIG. 1","FIG. 1","FIG. 2C"],"b":["905","905","125","905","125","905","205"]},"In one embodiment, the data grid node  includes a client interaction module , a resource manager , an operation manager , a node interactor , an object relational mapper , a query module , an object reconstructer , and an event listener . The node interactor  makes use of internet protocol (IP) based networking (e.g., transmission control protocol (TCP), user datagram protocol (UDP), etc.) to communicate with other data grid nodes. In one embodiment, the node interactor  issues remote procedure calls (RPCs) to neighbor nodes. The neighbor nodes invoke the RPCs, generate a response, and return the response to the data grid node that generated the RPCs. In one embodiment, the node interactor  uses JGroups Transport to communicate with other data grid nodes. Node interactor  performs peer discovery and manages membership of the data grid. In one embodiment, node interactor  maintains a grid membership data structure  that includes entries for each data grid node in the data grid. Each entry may include an address and\/or a port of a data grid node. This membership data structure  may be used to determine which neighbor nodes to communicate with.","The client interaction module  receives requests from clients and sends responses to clients. Requests may include requests to store objects, to retrieve objects, to search for objects, to retrieve information about objects, and so on. Responses may include objects, information about objects, confirmation messages, error messages, etc.","Requests to store objects include the objects that are to be stored. These objects may be objects of a specific type that the data grid node  is configured to operate on. Object relational mapper  performs object relational mapping for data grids on received objects. In one embodiment, the object relational mapper  operates on Java objects such as plain old Java objects (POJOS). In one embodiment, the object relational mapper  operates on extensible JavaScript Object Notation (JSON) objects and\/or JSON arrays. Alternatively, the object relational mapper  may operate on objects that are in the form of extensible markup language (XML) data.","A JSON object is an unordered collection of name value pairs. The values can be of the following types: Boolean, JSONArray, JSONObject, Number, String, or JSONObject.null. The external form of a JSON object is a string wrapped in curly braces with colons between the names and the values, and commas separating name value pairs. The internal form is an object having get and opt methods for accessing values by name, and put methods for adding or replacing values by name. For multi-operational transaction support, the internal form is an object having prepare, rollback, and commit methods for processing (e.g., preparing, rolling back, committing) operations based on an associated with a transaction identifier. A JSON object constructor can convert a JSON object from the external form to the internal form.","The object relational mapper  is able to handle complex objects. A complex object is an object that has at least one complex field (a field that has a type other than a primitive type) or a relationship to another object or array. A complex field represents an internal or nested object. An object may include multiple layers of nested objects. For example, an object may include a complex field, which in turn may include another complex field, which may include another complex field, and so on. An additional layer of indirection may be introduced by each layer.","For a complex object, each internal object may be assigned its own primary key and its own unique identifier. Relationships between objects may be handled by using references (e.g., pointers) between primary key value pairs. Consider an example in which one object has a relationship to another object. The object that has the relationship to the other object would store in its primary key a reference to the unique identifier of that other object. The reference may be a pointer that resembles an in memory pointer except that instead of storing a memory reference, a UUID is stored.","In one embodiment, it is the responsibility of clients to designate unique identifiers for objects. The unique identifier designation may be included in the request to store the object. Alternatively, the data grid node  may generate unique identifiers for received objects and\/or for internal objects of received objects. For example, a first field in the object may be used to generate a unique identifier for the object. A client may later retrieve an object based on that object's unique identifier. Note that the client does not need to remember the unique identifier for the object in one embodiment. Instead, the client may perform a query to determine the unique identifier for the object.","Object reconstructor  reconstructs objects from key value pairs . When a client needs to retrieve a stored object, the client sends the data grid node  a message  that includes the unique identifier for that object. The unique identifier may be a primary key in a primary key value pair that was generated for the object. The object reconstructor  gathers up all of the key value pairs  associated with that object, and puts them back together to reform the object.","In one embodiment, the object reconstructor  retrieves the primary key value pair that was generated for the object using the unique identifier. That primary key value pair includes references to key value pairs for each of the fields of that object. The primary key value pair and\/or additional key value pairs may be stored on the data grid node  or on other data grid nodes. If any of the key value pairs are not stored on the data grid node , node interactor  communicates with other data grid nodes to retrieve those key value pairs .","If the object included an internal object (a complex field), then the primary key value pair includes a reference to another primary key value pair of the internal object. That internal object may have its own unique identifier, and may also have been divided into key value pairs. On retrieving the primary key value pair for the internal object (complex field), the object reconstructor  uses references included in that primary key value pair to retrieve additional key value pairs. This process continues until all key value pairs for the object and all internal objects have been retrieved.","Once all key value pairs are retrieved, the object reconstructor  uses those key value pairs to reconstruct the original object. The object can be reconstructed with all internal objects, references, types, values, etc. that the object originally had before it was stored.","In one embodiment, the data grid node  supports multi-tenancy. Therefore, data from different applications can be isolated in the same data store. Having multi-tenancy enabled allows different applications to store data having the same name or same primary key without any of this data being overwritten. Therefore, changes made to objects in a first application do not cause any modifications to objects of a second application, even if those objects share the same name and unique identifier. Thus, multi-tenancy provides a way to isolate data while still sharing the same data store. Data associated with different applications may be distinguished by using name spacing, in which the application's unique identifier as attached to the object's unique identifier in each primary key. Therefore, the unique identifier for an object may be a combination of the application's unique identifier and the object's unique identifier.","In one embodiment, data grid node  adds annotations to objects for indexing. For example, object relational mapper  may add annotations to key value pairs as they are generated. In one embodiment, data grid node  includes a query module . The query module  indexes objects stored in the data grid based on the annotations, and enables clients to perform searches on the objects. This enables clients to obtain objects within the data grid without needing to know the unique identifiers (primary keys) to each object that the client wants to obtain. For example, a user may search for the field name, and the name john. The query module  may then search the key value pairs for the value \u201cjohn\u201d in a key for the name field. For every match, the query module  may identify the object associated with that key value pair and the unique identifier for that object. This information may be returned to the client. In one embodiment, queries are expressed in Drools query language. Alternatively, other query languages may be used. For example, queries may be defined in XML, or may be Apache\u00ae Lucene\u00ae queries.","In one embodiment, the query module  provides fault tolerant queries. If the data grid node  crashes while executing a query, another data grid node will continue performing the query.","In one embodiment, data manager  keeps track of the number of references that are made to each object. If a reference count for an object is zero, then data manager  may enable that object to be deleted. This enables garbage collection.",{"@attributes":{"id":"p-0102","num":"0101"},"figref":"FIG. 10","b":"1000"},"The machine may be a personal computer (PC), a tablet PC, a set-top box (STB), a Personal Digital Assistant (PDA), a cellular telephone, a web appliance, a server, a network router, a switch or bridge, or any machine capable of executing a set of instructions (sequential or otherwise) that specify actions to be taken by that machine. Further, while only a single machine is illustrated, the term \u201cmachine\u201d shall also be taken to include any collection of machines that individually or jointly execute a set (or multiple sets) of instructions to perform any one or more of the methodologies discussed herein.","The exemplary computer system  includes a processing device , a main memory  (e.g., read-only memory (ROM), flash memory, dynamic random access memory (DRAM) such as synchronous DRAM (SDRAM) or DRAM (RDRAM), etc.), a static memory  (e.g., flash memory, static random access memory (SRAM), etc.), and a data storage device , which communicate with each other via a bus .","Processing device  represents one or more general-purpose processing devices such as a microprocessor, a central processing unit, or the like. More particularly, the processing device may be complex instruction set computing (CISC) microprocessor, reduced instruction set computing (RISC) microprocessor, very long instruction word (VLIW) microprocessor, or processor implementing other instruction sets, or processors implementing a combination of instruction sets. Processing device  may also be one or more special-purpose processing devices such as an application specific integrated circuit (ASIC), a field programmable gate array (FPGA), a digital signal processor (DSP), network processor, or the like. The processing device  is configured to execute instructions  for performing the operations and steps discussed herein.","The computer system  may further include a network interface device . The computer system  also may include a video display unit  (e.g., a liquid crystal display (LCD) or a cathode ray tube (CRT)), an alphanumeric input device  (e.g., a keyboard), a cursor control device  (e.g., a mouse), and a signal generation device  (e.g., a speaker).","The data storage device  may include a machine-readable storage medium  (also known as a computer-readable medium) on which is stored one or more sets of instructions or software  embodying any one or more of the methodologies or functions described herein. The instructions  may also reside, completely or at least partially, within the main memory  and\/or within the processing device  during execution thereof by the computer system , the main memory  and the processing device  also constituting machine-readable storage media.","In one embodiment, the instructions  include instructions for a data grid node and\/or for a proxy server (e.g., client , data grid node , and proxy server  of  and ) and\/or a software library containing methods that call a data grid node and\/or a proxy server. While the machine-readable storage medium  is shown in an exemplary embodiment to be a single medium, the term \u201cmachine-readable storage medium\u201d should be taken to include a single medium or multiple media (e.g., a centralized or distributed database, and\/or associated caches and servers) that store the one or more sets of instructions. The term \u201cmachine-readable storage medium\u201d shall also be taken to include any medium that is capable of storing or encoding a set of instructions for execution by the machine and that cause the machine to perform any one or more of the methodologies of the present invention. The term \u201cmachine-readable storage medium\u201d shall accordingly be taken to include, but not be limited to, solid-state memories, optical media and magnetic media.","Thus, techniques for using a shared data store for peer discovery in a peer-to-peer system are described herein. Some portions of the preceding detailed descriptions have been presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the ways used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here, and generally, conceived to be a self-consistent sequence of operations leading to a desired result. The operations are those requiring physical manipulations of physical quantities. Usually, though not necessarily, these quantities take the form of electrical or magnetic signals capable of being stored, combined, compared, and otherwise manipulated. It has proven convenient at times, principally for reasons of common usage, to refer to these signals as bits, values, elements, symbols, characters, terms, numbers, or the like.","It should be borne in mind, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussion, it is appreciated that throughout the description, discussions utilizing terms such as \u201cidentifying\u201d or \u201cstoring\u201d or \u201cdetermining\u201d or \u201csending\u201d or \u201creceiving\u201d or \u201cupdating\u201d or the like, refer to the action and processes of a computer system, or similar electronic computing device, that manipulates and transforms data represented as physical (electronic) quantities within the computer system's registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage devices.","The present invention also relates to an apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes, or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium, such as, but not limited to, any type of disk including floppy disks, optical disks, CD-ROMs, and magnetic-optical disks, read-only memories (ROMs), random access memories (RAMs), EPROMs, EEPROMs, magnetic or optical cards, or any type of media suitable for storing electronic instructions, each coupled to a computer system bus.","The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein, or it may prove convenient to construct a more specialized apparatus to perform the required method steps. The required structure for a variety of these systems will appear as set forth in the description below. In addition, the present invention is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the invention as described herein.","The present invention may be provided as a computer program product, or software, that may include a machine-readable medium having stored thereon instructions, which may be used to program a computer system (or other electronic devices) to perform a process according to the present invention. A machine-readable medium includes any mechanism for storing information in a form readable by a machine (e.g., a computer). For example, a machine-readable (e.g., computer-readable) medium includes a machine (e.g., a computer) readable storage medium such as a read only memory (\u201cROM\u201d), random access memory (\u201cRAM\u201d), magnetic disk storage media, optical storage media, flash memory devices, etc.","In the foregoing specification, embodiments of the invention have been described with reference to specific exemplary embodiments thereof. It will be evident that various modifications may be made thereto without departing from the broader spirit and scope of embodiments of the invention as set forth in the following claims. The specification and drawings are, accordingly, to be regarded in an illustrative sense rather than a restrictive sense."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention is illustrated by way of example, and not by way of limitation, in the figures of the accompanying drawings in which like references indicate similar elements. It should be noted that different references to \u201can\u201d or \u201cone\u201d embodiment in this disclosure are not necessarily to the same embodiment, and such references mean at least one.",{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2C"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
