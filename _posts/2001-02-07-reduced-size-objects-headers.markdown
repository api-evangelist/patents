---
title: Reduced size objects headers
abstract: A method and apparatus for reducing memory requirements in a computing environment. The method includes reducing the size of a header for a data structure by creating a header consisting of index information. Alternatively, the header may also include garbage collection information. The invention also provides a data structure for an object-oriented programming environment. The data structure includes: 1) a header consisting of index information and 2) one or more fields. Unlike prior data structures the header does not include information regarding the data structure's size; where it references are; it dispatch table; hash code information; or monitor information.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06944637&OS=06944637&RS=06944637
owner: Esmertec AG
number: 06944637
owner_city: Dubendorf
owner_country: CH
publication_date: 20010207
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application claims the benefit of Provisional application Ser. No. 60\/180,553, filed Feb. 7, 2000.","The present invention relates to reducing memory requirements or overhead in a computing environment. More specifically, the invention relates to reducing the size of object headers, thereby reducing the amount of memory required to store the objects of a program.","Object-oriented programming involves defining objects or, more broadly, abstractions of items that need to be manipulated or processed in order to solve the problem or meet the objective addressed by the program. Objects are a type of data structure that include defined information or attributes. Objects can also be manipulated in a manner similar to variables (such as integer, Boolean, and floating point variables) in procedural programming languages. However, the types of operations (functions or methods) that may be performed on an object are defined by the programmer. In addition, programmers can create relationships between one object and another. For example, objects can inherit characteristics from other objects.","An object is an instance of a class. A class is a specification or template that defines the characteristics (attributes and methods) for all objects of that class type. One of the principal advantages of object-oriented programming techniques over procedural programming techniques is that they enable programmers to create modules that do not need to be changed when a new type of object is added. A programmer can simply create a new object that inherits many of its features from existing objects. This makes object-oriented programs easier to modify.","There are several object-oriented programming languages including C++ and Java. Before it is executed, Java source code is usually translated or compiled into byte code by a Java compiler. The byte code is then interpreted or converted to machine language at run time. Java can be implemented as an interpreted language, meaning programs written in Java can be run using an interpreter. An interpreter decodes and runs a program at the same time. Specifically, the interpreter decodes one line of programming, executes that line of code, and then proceeds to the next line of code.","The Java Virtual Machine (\u201cVM\u201d) carries out the task of interpreting or otherwise executing the Java byte code. Java VMs are present in most browsers and widely licensed for use in a variety of computing devices. With most other programming languages, different versions of a program must be developed for different computer environments. Further, Java programs can be stored in relatively small files, which is important in applications where memory is limited (e.g., when running software on cell phones, personal digital assistants, and the like) and makes transmitting the programs over networks easier and faster.","While it is possible to create a computing environment specifically designed for Java (e.g., by using a Java chip), most Java platforms are deployed on top of a non-Java host environment that employs a standard processor with a Java VM installed in memory. A Java platform is a programming environment that includes the Java VM and the Java application programming interface (\u201cAPI\u201d). The Java API consists of a set of predefined classes.","Most Java VMs use two 32-bit words at the front of each object as a \u201cheader.\u201d The header is used to provide the VM and the garbage collector (a routine that reclaims memory occupied by program segments that are no longer active) certain information about every object in the program being executed. This information includes the object's class, size, and dispatch table (used to call virtual methods). The header also provides information regarding the object's references, the bits (indicating color) used by the garbage collector, hash code information, and monitor information (thread synchronization activity).","In Java and other object-oriented programming languages even the most trivial programs can have thousands of objects. As noted, each object is assigned a header, typically of 64-bits or more. Thus, even a small program can require many tens of Kbytes of memory to run, and a significant portion of this may be object headers. While on many computing platforms memory requirements are not of concern, devices such as personal digital assistants, cell phones, and the like have relatively small memory footprints, which limit their ability to run many programs. Accordingly, it would be beneficial to reduce the size of object headers to reduce memory demands so that programs could run on a variety of platforms, including those with limited memory.","In one embodiment, the invention provides a method of reducing memory requirements in a computer environment. The method includes creating an object header for an object consisting of index information and garbage collection information. The index information references, at least indirectly, class information for the object. In one form of the invention, the method involves creating a global index of dispatch tables, and creating a dispatch table that is referenced by the global index. In this form, the index information references class information through the global index and the dispatch table.","The header has a finite number of bits. In one embodiment, the garbage collection information is stored in a predefined number of the bottom most bits of the header, and the index information is stored in the remaining bits of the header. Alternatively, a predefined number of the bottom bits are masked and the garbage collector is instructed to use the masked bits for garbage collection.","The invention may be implemented in a computing environment that includes a data structure having a header. The header consists of index information and garbage collection information. The computing environment also includes a global index of dispatch tables referenced by the data structure, a dispatch table referenced by the global index, and class data referenced by the dispatch table. Preferably, the header has a size and the size is equal to or less than one 32-bit word. When so sized, the garbage collection information is stored in a predefined number of the lower most bits of the 32-bit word and the index information is stored in the remaining bits. As noted above, storage of information for the garbage collector may also be implemented using masking.","The invention also provides a data structure for an object-oriented programming environment. The data structure includes 1) a header consisting of index information and 2) one or more fields. Unlike prior data structures the header does not include information regarding the data structure's size; where its references are; its dispatch table (except for one embodiment of the invention where the header does contain a dispatch table pointer); garbage collection information; hash code information; or monitor information.","As is apparent from the above, it is an advantage of the invention to provide a method for reducing and an apparatus with reduced data structure header size. Other features and advantages of the present invention will become apparent by consideration of the detailed description and accompanying drawings.","Before embodiments of the invention are explained, it is to be understood that the invention is not limited in its application to the details of the construction and the arrangements of the components set forth in the following description or illustrated in the drawings. The invention is capable of other embodiments and of being practiced or being carried out in various ways. Also, it is to be understood that the phraseology and terminology used herein is for the purpose of description and should not be regarded as limiting. The following description assumes that the reader is familiar with computer science and has a working knowledge of object-oriented and multi-threaded programming languages, as one of ordinary skill in the art would possess.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIGS. 1 and 2","FIG. 1","FIG. 2"],"b":["10","10","12","14","16","18","25","25","27","29","31","33","35"]},"The object  and array  (generically, data structures) have information words. As noted above, a header or information word provides the VM and the garbage collector certain information about the object or array, as the case may be. For purposes of brevity, the description that follows will focus on objects, but it should be understood that the principles set forth herein could be applied to arrays and other data structures. In most known implementations, the header (information word  and dispatch field ) is at least 64 bits in size and allows the following information to be derived:","A. the object's class;","B. the object's size;","C. where the object's references are;","D. the object's dispatch table (for calling virtual methods);","E. garbage collection information (usually color);","F. hash code information; and","G. monitor information.","As noted above the overhead associated with the information words for each class and array in a program can be substantial. The inventor has found that the size of the information word  can be reduced by combining information regarding the object's class, size, references, and dispatch table, because these information elements change on a class-by-class basis rather than on a per-object basis. Garbage collection information is needed on a per-object basis. Although this information can be stored separately from the object in order to reduce the size of the information word , in one embodiment of the invention, garbage collection information is maintained with its subject object. This is done because, in most cases, moving the garbage collection information to separate storage merely shifts the memory burden to another location.","The inventor has also found that hash code information can be removed from the information word , because in most instances the hash code can be derived from the object's address in memory. However, if the address of the object  is changed then the object's derived hash code changes. Thus, in one embodiment of the invention, hash code information is removed from the information word  only in those cases where the object's address remains unchanged. Alternatively, the hashing algorithm is modified so that is generates the same hash value regardless of whether the algorithm uses a new address or a previous address for the object.","The inventor has also found that monitor information (information concerning thread synchronization) is needed infrequently (i.e., relatively few objects are ever used for synchronization and even fewer objects are synchronized concurrently). Thus, the size of the object header (information word  and dispatch field ) is reduced further by moving the monitor information into an independent data structure indexed by the object's address.","When the optimizations explained above are implemented, only two data items need to be stored in the information word : 1) a class specific pointer\/index and 2) garbage collection information. With only two items to store in the information word , its size can be reduced to single 32-bit word. Preferably, the bottom n-bits in the information word  are used for the garbage collection information and the remaining bits are used for class information.","Additional details regarding how to obtain the optimizations noted above are best explained by reference to , , and .  illustrates an element  (a data structure such as an object or an array) having an element reference , an information word , and a dispatch pointer . The dispatch pointer  references a dispatch table  having a plurality of slots . The plurality of slots  includes a zero slot , a first slot , a second slot , and a third slot . The slot  contains a class pointer and the slots - contain method data. The dispatch pointer  provides a mechanism for determining the class of the element . The dispatch pointer refers to the class pointer in slot  of the dispatch table . The class pointer refers to a class element . The dispatch table  provides a mechanism to implement virtual methods for different classes of objects, such as a class and one or more of its subclasses. The method data in the dispatch table can be modified to support additional or modified methods needed in objects of a subclass without the need to modify the basic structure of the objects themselves. In this way, objects of a class and objects of a subclass of that class retain a similar architecture.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 4","FIG. 4"],"b":["75","77","77","79","81","79","85","85","85","90","90","92","92","75","94"]},"For the embodiment shown in , the bit size of the index information  is limited to the entire bit size of the header  and reduced by the number of bits used to store the garbage collection information . As noted above, a reduced size header could have a size of 32 bits. If garbage collection information uses two or three bits of the header only 29 or 30 bits are available for the index information . By having the index information  reference a global index with references of full size (in this case 32 bits), dispatch tables can be accessed easily.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 5","b":["100","100","81","77","100","100"]},{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 6","FIG. 6"],"b":["110","112","114","116","116","118","120","120","122","124","126","128","122","124","128","130","116"]},"The bottom bits of the dispatch pointer  are masked in such a way to provide garbage collection information to the garbage collector. As is known, garbage collection (\u201cGC\u201d) can be implemented in a variety of ways. Concurrent GC occurs while the program executes. Pausing GC causes the execution of the program to stop while garbage collection occurs. Whether GC occurs concurrently or not, various methods may be used to carry out the task of reclaiming memory. One common method is known as \u201cmark and sweep\u201d GC. The general principles of mark and sweep GC are well known and are not discussed herein. However, for the masking embodiment of the invention, it is assumed that GC is carried out with a pausing garbage collector using a mark and sweep methodology.","As noted, the bottom bits of the dispatch pointer are masked and aligned to the addresses in the dispatch table . During pausing GC, all the threads (or execution paths) of the program at hand are stopped. The garbage collector examines the objects in the program, such as the element , and while the garbage collector is carrying out its tasks no other elements access the objects. Because no other elements need to or can access the dispatch pointer  during GC, the garbage collector may use the bottom bits of the dispatch pointer  for marking purposes. When the garbage collector completes its tasks, it returns those bits to zero before restarting the other threads of the program.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 7","FIG. 7"],"b":["145","150","152","154","154","156","158","158","160","162","162","164","158","145","170","172","174","170","174","150"]},"The garbage collector analyzes each object in a tracing process and sets one of the bottom bits to indicate that the object has been visited by the garbage collector. In other words, the garbage collector marks the object (in a three three-color marking system the object is colored gray or black). The objects  and  can not be reached and, therefore, are not marked (they remain white). Once the garbage collector has traced through all of the objects, it sweeps the heap removing those objects that are unmarked (white). During the sweeping phase, the garbage collector changes the bottom bits of the dispatch pointer  back to zeroes so that execution of the program can continue normally once garbage collection is complete. All that is required to accomplish this is to add an extra assignment instruction to the garbage collector per object.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":["FIG. 8","FIG. 8"],"b":["200","202","204","202","210","210","210","212","225","9","225"]},"Although the use of a table or array of linked lists to store hash code and monitor information impacts memory overhead, in many instances hash code and monitor information is not needed. Accordingly, hash code and monitor information is maintained only for those objects where it useful or needed. Thus, the memory overhead associated with the hash table or array of linked lists is relatively small.","One way of optimizing the use of a hash table or linked list for hash code and monitor information is to use local thread cache to store the relevant information. This helps maintain data integrity in a multi-threaded environment.","The use of one-word headers (when implemented in accordance to the embodiment shown in ) impacts the performance of various operations. In particular, sweeping the heap requires more indirection to determine the size of each object, and where its references are. Thus, sweeping is slower. Acquiring or releasing monitors is generally slower than having the monitor information in the object header. Accessing class information is also slower because of added indirection. Finally, the invocation of virtual and interface methods requires more indirection to de-reference the dispatch table, and therefore, is slower. The inventor has found that the invocation of virtual and interface methods has the biggest impact on performance. Accessing the dispatch table pointer, when the class-field is a table offset, requires additional instructions to be executed. For example, in x86 assembly language code, to acquire the dispatch table pointer for an invoke is no longer a single move, rather the invocation is:\n\nMOV EAX, [ECX]\/\/Get header word\n\nAND EAX, CLASS_FIELD_MASK\n\nMOV EAX, [EAX+DISPATCH_TABLE_BASE]\n\nNevertheless, the savings in memory, in some environments, offsets any performance degradation.\n","As can be seen from the above, the invention provides, among other things, a method and apparatus that reduce object header size. Various features and advantages of the invention are set forth in the following claims."],"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
