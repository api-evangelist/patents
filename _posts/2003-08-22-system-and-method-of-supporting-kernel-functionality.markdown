---
title: System and method of supporting kernel functionality
abstract: Embodiments of the present invention provide an advantage over prior art software architectures by allowing a kernel to send requests to and receive corresponding results from user space applications. Because the kernel can utilize user space applications, the kernel can use the results of complex calculations without requiring a significantly larger kernel. This provides advantages because programming and debugging of complex algorithms can occur at the user space level rather than the kernel space level.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07448049&OS=07448049&RS=07448049
owner: Crossroads Systems, Inc.
number: 07448049
owner_city: Austin
owner_country: US
publication_date: 20030822
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","TECHNICAL FIELD OF THE INVENTION","BACKGROUND","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["This Application claims priority under 35 U.S.C. 119(e) to U.S. Provisional Patent Application No. 60\/419,479, entitled \u201cA Method For Extending Kernel Functionality By Transitioning to User Space,\u201d by Lisheng Xing, filed Oct. 18, 2002, which is hereby incorporated in its entirety herein.","Embodiments of the present invention are related to the interaction between the kernel layer and user space. More particularly, embodiments of the present invention are related to supporting kernel layer functionality with processes occurring in user space.","Many operating systems are divided into modules that have direct access or privilege to hardware, known as kernels, and programs that must request access to hardware from the kernels, known as user space applications. Kernels are typically the central modules of an operating system, having direct access to a computer's memory, disk drives, network adaptors and other resources, and are typically stored in the computer's main memory. User space applications, on the other hand, have only limited access to a computer's resources and normally have to request access to memory, drives and other hardware from the kernels. As an example, if a user space application, such as a word processing program, has to access a disk drive, the user space application will request that the kernel perform the tasks necessary to carry out the disk access operation. Thus, the kernel acts as an interface between the hardware and user space applications. The interaction between kernels and user space applications, in the prior art, is typically limited to the servicing of hardware calls by the kernel.","Two basic kernel architectures have arisen in modern operating systems, monolithic and micro-kernel. In a monolithic system, a single piece of code has privileges to the resources of the computer and has access to all the data structures and routines of the kernel. The open-source operating system Linux uses a monolithic kernel architecture. In a micro-kernel architecture, conversely, access to hardware, data structures and routines is distributed among multiple specialized kernels. In this architecture, each device may be controlled by its own kernel (or device driver) that has access to only that device. The micro-kernel architecture is employed by the popular Windows Operating system produced by Redmond, Wash. based Microsoft Corporation. In either system, the kernels allow the operating system to centralize access control to the hardware of a computer. Because a kernel can balance service requests from multiple user space applications without conflict, the operating system can more effectively multitask. Moreover, because kernels are generally implemented at a lower level (i.e., closer to the hardware), they allow for more efficient hardware management than if hardware access was managed at the user space level.","Kernels are typically designed to be very light weight. This is done because the kernels stay in the main memory of the computer and light weight code minimizes memory usage. In order to keep the kernels small, each kernel is generally provided with only the limited amount of code required to carry out simple mathematics and hardware access functions, but not additional code to carry out more complicated functions. However, the gradual importation of more complex processing to kernel space can be seen in the evolution of the Microsoft Windows operating system. With each new version of Windows, the device drivers that operate in kernel space have become increasingly more complex. This has allowed more complicated operations to be performed at the kernel level where processing is generally more efficient. Even these kernels, however, do not typically carry out complex mathematical operations.","Placing operations at the kernel level can have the advantage of increased efficiency, but can also have several substantial disadvantages. As an initial problem, kernels are generally more difficult to program than user space applications, leading to increased programming time. Moreover, because kernels stay in main memory, larger kernels require more memory to be permanently employed during the operation of a computer. Also, as the code size of the kernel grows, the likelihood of device mismanagement or a bug in the kernel increases. This is a particular problem as kernels are notoriously difficult to debug and failure of a kernel to run properly can lead to catastrophic failure in a computer (e.g., a \u201cblue screen\u201d crash in the case of memory manager failure).","Because of these difficulties, complex calculations in prior art systems typically take place in user space. For example, authentication routines that require complex mathematical operations have not typically been implemented in the kernel layer. The difficulty in implementing authentication at the kernel layer, particularly for protocols such as iSCSI, results, at least in part, from the fact that authentication protocols generally need the support of a complex multi-precision math library to process authentication challenges and keys, and to handle other complex processes involving large numbers. In prior art systems, this required that authentication be carried out in user space because a kernel that could fully support authentication routines would be too large and unstable to be practicably implemented. The kernel's only involvement in the authentication routine was to service hardware calls, thus maintaining the strict functional boundary between the kernels and user space applications.","Embodiments of the present invention provide an advantage over prior art software architectures by allowing a kernel to send requests to and receive corresponding results from user space applications. Because the kernel can utilize user space applications, the kernel can use the results of complex calculations without requiring a significantly larger kernel. This provides advantages because programming and debugging of complex algorithms can occur at the user space level rather than the kernel space level.","Embodiments of the present invention provide another advantage over prior art software architectures by allowing the results calculated by user space applications to be passed to kernel space. Because kernel space normally runs more efficiently than user space, further processing in kernel space of the results generated in user space will typically be more efficient than further processing of the same results in user space. Thus, the present invention can increase the efficiency of a system over prior art systems in which the entire process, other than hardware calls, was implemented in user space.","Embodiments of the present invention provide yet another advantage over prior art systems by allowing authentication routines that require complex calculations to occur, at least in part, in kernel space while maintaining relatively light weight kernels.","Embodiments of the present invention provide yet another advantage over prior art systems by requiring less main memory than systems that use heavy weight kernels to perform complex processes.","Embodiments of the present invention provide yet another advantage by increasing the stability of systems over systems that use larger kernels to perform processes at the kernel layer.","Preferred embodiments of the invention are illustrated in the FIGURES, like numerals being used to refer to like and corresponding parts of the various drawings.","Embodiments of the present invention provide a system and method for extending the functionality of the kernel layer through user space applications. One embodiment can include a kernel that can pass a request for a process to a user space application. The user space application can carry out the request and send the result of the process to the kernel in a format usable by the kernel for further processing. In this manner, user space applications can be leveraged for performing complex calculations or other processes, while the remainder of the processing can occur at the typically more efficient kernel level.","In one embodiment of the present invention, each kernel capable of passing requests can include a kernel driver application that is capable of initiating requests and a bridge driver that is capable of communicating the requests with a user space application. The kernel driver application can perform any amount of processing capable of being implemented at the kernel layer. By way of example, but not limitation, kernel driver applications can include kernels associated with specific hardware (e.g., a video driver) or kernels designed to carry out a specific task (e.g., an authentication kernel). The bridge driver, which can also be implemented at the kernel layer, can optionally queue requests from the kernel driver application for forwarding to user space, perform any preprocessing that may be required by a given implementation, establish a communications channel with a user space application and forward a request to the user space application.","In user space, a job queue manager and processor can receive the request from the kernel layer and optionally queue the request. The job queue manger and processor can also take a request from the queues or directly from the kernel, translate the request into a format usable by a supporting user space library and forward the request to the supporting library. In addition, the job queue processor and manager can receive results returned by the supporting library in response to the request and can, after optional response queuing, send the results back to the kernel layer in a format usable by the kernel layer. The bridge driver can receive this response and perform any necessary post processing and queuing and return the result to the kernel driver application, which can, in turn, use the result in further kernel layer operations.","Because requests and responses can be passed between the kernel layer and user space layer, embodiments of the present invention can leverage user space libraries to perform complex calculations while performing other processes at the kernel layer. This can allow processes that require complex calculations to be implemented at the kernel layer without requiring that the calculations be performed there. Consequently, sophisticated kernels can be implemented that require significantly less memory space and that are substantially more stable than kernels in which complex calculations occur at the kernel layer.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1","b":["100","100"]},"System  can include a kernel layer  (alternatively, kernel space ) and a user layer  (alternatively, user space ). Kernel layer  can be implemented as multiple kernels or as a monolithic kernel with all the functionality of kernel layer  implemented as a single program. In the preferred embodiment of the present invention, kernel layer  can be loaded into the main memory of the computer in which it is implemented when the computer is booted up and can be maintained there until the computer is shut off.","In the embodiment of , kernel layer  comprises a kernel driver application  and a bridge driver . In the case of the Linux operating system, kernel layer  can be the Linux kernel, with kernel driver application  and bridge driver  representing portions of the Linux kernel code. Kernel driver application  and bridge driver , however, can be implemented in any other suitable manner as would be understood to those of ordinary skill in the art, including as separate kernels. Moreover, while only one bridge driver and one kernel driver application are shown, bridge driver  can optionally service requests from multiple kernel driver applications and each kernel driver application can optionally send requests and receive responses through multiple bridge drivers.","Bridge driver  can, in one embodiment of the present invention, include a request queue  to buffer requests from kernel driver application , response queue  to buffer responses from user space  and a kernel space queue management and processing portion  (\u201cbridge manager \u201d) to establish a communications channel with user space and manage request queue  and response queue . Queuing of requests and responses may be necessary as kernel space is not always synchronized with user space and because the kernel driver application, as it is implemented on a lower level (i.e., closer to the hardware layer), can, in some embodiments, generate requests faster than the user space layer can receive them.","User space  can comprise a user space application , having a job manager and processing portion  (\u201cjob manager \u201d), a user space request queue , a user space response queue  and a supporting library . User space request queue  and user space response queue  can respectively queue requests and responses in user space. It should be noted that the response queues and request queues for user space and kernel space can be the same such that request queue  and request queue  are the same while response queue  and response queue  are also the same. It should be further noted that while user space application  is shown as a single application in , user space application  can comprise several applications or programs, can be part of a larger program or can be implemented in any other suitable programming manner known in the art.","In one embodiment of the present invention, kernel driver application  can perform any processing capable of being implemented at the kernel level, including acting as a hardware driver or performing other functionality. As one example, kernel driver application  can act as an authentication driver to authenticate devices according to the secure remote password (\u201cSRP\u201d) protocol, which, as would be understood by one of ordinary skill in the art, can require complex mathematics. In order to perform these calculations without requiring that the complex mathematics be programmed at kernel layer , embodiments of the present invention can leverage mathematics libraries in user space .","Kernel driver application  can be programmed such that whenever kernel driver application  needs support of user space application  (e.g., to carry out complex calculations or other processes not programmed in kernel layer ), kernel driver application  can send a request to user space . The request can include any information used for processing the request including, but not limited to, an identification indicating the request number (e.g., Request One, Request Two, etc.), a request type indicating the type of request being made if user space application  supports multiple request types, and one or more arguments containing the information to be processed.","Bridge driver  can establish a communications channel with user space application  and forward the request from kernel driver application . Additionally, because kernel space is often not synchronized with user space, bridge manager  of bridge driver  can buffer requests at request queue . Bridge manager  can manage request queue  using any technique known in the art, including on a LIFO basis, a FIFO basis, a priority basis or according to any other queue management technique known in the art. In addition, bridge driver  can perform any preprocessing that may be required by a particular implementation to send a particular request to user space application . For example, bridge manager  can organize requests into queues according to the priority of each request.","In user space, job manager  can receive the request from bridge driver  and optionally queue the request in request queue . Job manager  can also read requests from request queue  according to any queue management technique known in the art (e.g., FIFO, LIFO, a priority system), perform any translation necessary to put the request in a format understandable by supporting library  and forward the requests to a supporting library  for processing. Supporting library  can comprise any user space program capable of processing requests received from job manager , including complex math programs, word processing programs, graphics programs or any other program known in the art.","Based on the request, supporting library  can generate a corresponding response. Job manager  can receive the result from supporting library , perform any translation necessary to put the response in a format understandable by kernel layer , optionally queue the response in response queue  and send the response to bridge driver . In one embodiment of the present invention, bridge driver  can receive the response, perform any post processing required by a particular implementation, queue the received response in response queue  and send the response to kernel driver application . Kernel driver application  can then use the response for further processing.","As can understood from the foregoing, kernel driver application  can require the results of an operation, such as a complex math operation, to complete a process at the kernel layer. However, kernel driver application  does not have to include the programming necessary to carry out the complex math operation itself. Instead, kernel driver application  can be configured to send requests to user space to carry out a process and receive the results of the process. In this manner, operations not programmed at the kernel layer can be carried out in user space. This can provide several advantages over prior art systems and methods. More particularly, because kernel application driver  can use the results of complex calculations without being programmed to perform the calculations, kernel application driver  can perform more complex processes than traditional kernels. Moreover, a kernel that can leverage user space applications to carry out process can remain smaller, more stable, and easier to debug than a kernel that includes the programming necessary to carry out the more complex processes.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 2","b":["205","115","210","215","220"]},"At step , a job manager in user space can receive the request via the established communications channel and, at step , can optionally queue the request in user space. The job manger can then forward the request to a supporting user space library for processing. The supporting user space library can be part of the same user space application as the job manager or can be part of a different application. Based on the request, the supporting user space library can perform processing in user space and generate a response (step ). The processing can include any processing that can be implemented in user space including complex mathematics. At step , the job manager can optionally queue the response and, at step , send the response to the kernel layer over the same communications channel upon which the request was received or via a different communications channel.","At the kernel layer, the response can be received (step ) and optionally queued (step ). In one embodiment of the present invention, receipt and queuing of the response can be carried out by a bridge driver that may be the same as or separate from the kernel driver application that generated the request. At step , the kernel that generated the request can use the corresponding response for further processing at the kernel layer. Each time additional support from user space is required, the kernel can generate a new request and steps - can be repeated (step ).","In summary, a kernel can generate a request that can be communicated to user space for processing. A user space application can process the request, generate a result, and communicate the result back to the kernel layer. In this manner, the kernel can leverage user space applications to carry out operations that are not programmed in the kernel layer. This can allow a relatively light weight kernel to utilize the results of complex calculations or other processes carried out in user space, thereby extending the functionality of the kernel.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 3","b":["305","310","315","318","310","315","318","315","320","325","330","325","335","320","335","340","345"]},"In one embodiment of the present invention, each server  can act as an iSCSI initiator, sending requests to router , which acts as an iSCSI target, to store data on one or more of storage devices . Before allowing data to be transferred to a storage device , router  can require that a particular iSCSI initiator authenticate. In other words, router  can require an iSCSI initiator to establish that it has permission to store data on storage devices . The authentication process can include any authentication process known in the art, such as SRP. Router  can receive a login request from a server  (e.g., via a network interface device ) and implement a process to authenticate the server . In one embodiment of the present invention, computer instructions  can be executable by processor  to carry out a portion of the authentication process at kernel layer  and carry out another portion of the authentication process at user space layer . The portion of the authentication process carried out in user space layer  can be based, at least in part, on requests generated from kernel layer  and the portion carried out in kernel layer  can be based, at least in part, on replies received from user space layer  in response to the requests. If the server  authenticates, router  can route data from the server  to one or more storage devices .",{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 4","FIG. 4","FIG. 3","FIG. 3"],"b":["400","6","400","400","405","310","410","405","415","420","405","415"],"i":"f "},"Kernel layer  can include an iSCSI layer driver application  that further comprises configuration database , authentication engine  (i.e., a kernel layer driver), which includes authentication logic, and iSCSI login logics . Authentication engine  can utilize any authentication method known in the art to authenticate iSCSI initiator . A portion of the authentication information used by authentication engine  can be stored in configuration database , which can further include a user ID database and control fields portion .","The user ID database, in one embodiment of the present invention, can contain user-related information, such as a triplet of the form {<username>,<password verifier>,<salt>}, or other user-related information known in the art. The control fields can contain authentication configurations, such as authentication methods supported by iSCSI target .","iSCSI Login Logics , which can be part of the iSCSI layer, can interact with iSCSI initiator  to handle login\/logout procedures and with authentication engine  to process authentication requests. While configuration database , authentication engine  and iSCSI login logics  are each shown as separate modules of iSCSI layer driver application , they can be implemented using any suitable programming architecture known in the art.","In addition to iSCSI layer driver application , kernel layer  can include bridge driver . In one embodiment of the present invention, bridge driver  can be a separate kernel from iSCSI layer driver application  and can comprise a bridge manger  and queues  for queuing requests and responses. Bridge driver  can provide a communications channel between iSCSI layer driver application  and user space , pass authentication requests from iSCSI layer driver application  and receive the results of processes occurring in user space  in response to the authentication requests.","User space  can include an authentication math function provider application  that can further comprise job manger , one or more supporting libraries  (e.g., complex math library ) and user space queues . Authentication math function provider application  can provide iSCSI layer driver application  with complex math functionality based on requests from kernel layer . Job manager  can receive a request from bridge driver , queue the request in user space queues  and process the request using complex math function library . Job manager  can then queue the results of the processing and return the results to bridge drive . It should be noted that while authentication math function provider application  is shown as a single application in user space , its functionality can be distributed among several applications.","In operation, iSCSI initiator  can establish a connection, such as a TCP connection, with iSCSI target . Once a connection is established, iSCSI initiator  can send a login request that includes the iSCSI protocol version supported by iSCSI initiator , an initiator name and the authentication methods supported by iSCSI initiator . The login and authentication information can be contained in the header of a protocol data unit (PDU). Examples of authentication methods include kerberos, simple public-key, generic security service application programming interface (SPKM), SRP, Challenge Handshake Authentication Protocol (CHAP) or any other authentication protocol known in the art.","iSCSI login logistics  of kernel layer  can extract header information from the PDU and forward the information to authentication engine  according to methods known in the art. Authentication engine  can compare the received authentication methods to a set of authentication methods stored in configuration database . If iSCSI target  and iSCSI initiator  support multiple authentication methods, negotiation between iSCSI target  and iSCSI initiator  can occur to determine a common authentication method for a session. iSCSI target  and iSCSI initiator  can employ any method of negotiation known in the art, such as least common denominator, to choose a method of authentication.","For the purposes of explanation, iSCSI target , in one embodiment of the present invention, only supports SRP. In accordance with the SRP process, iSCSI target  can communicate to iSCSI initiator  that authentication must occur using SRP. iSCSI initiator  can then send a user name to iSCSI target  in accordance with the SRP method. Authentication engine  can compare the received user name to a user name in configuration database . If the user name is contained in configuration database , authentication engine  can return to iSCSI initiator  values for n, g an s. As would be understood by those of ordinary skill in the art, the value n (i.e., the prime modulus) is typically a very large prime number, the value of g is the primitive root modulus of n and s is the salt value associated with the user name in configuration database .","iSCSI initiator  can generate a public ephemeral key \u201cA\u201d based on the value of g and a random number \u201ca\u201d and pass the value of a to iSCSI target , which can verify A. If A is verified, iSCSI target  can generate its ephemeral public key \u201cB\u201d based on the value of g, a random number \u201cb\u201d, and a password verifier \u201cv\u201d stored in configuration database  and communicate B to iSCSI initiator . Verification of A and generation of ephemeral public key B, as would be understood by those of ordinary skill in the art, typically require complex math. If these processes are programmed at the kernel layer, the resulting kernel layer would be very large. To help maintain a smaller kernel layer, complex math processes, such as the verification of A or the generation of B can be delegated to user space. Accordingly, to verify A and\/or generate ephemeral public key B, authentication engine  can generate one or more requests prompting these processes to occur in user space . On example of a request structure can be:\n\n","In this request, \u201cunsigned int id\u201d can identify the request as the first request, the second request and so on, \u201cint request_type\u201d can identify the type of request, for example a request to verify A or a request to calculate B, and the arguments can include any information to be passed to user space  for processing. For example, in a request to verify A the arguments can contain the value of A, while in a request to calculate B the arguments can include values of g, b and v. The request structure given above is provided by way of example only and, as would be understood by one of ordinary skill in the art, any request structure can be used.","Bridge manager  of bridge driver  can queue the request at kernel layer queues  and can establish a communications channel with user space . Additionally, bridge manager  can perform any preprocessing of a request that is required by a particular implementation. Requests can be read from queues  according to any request management technique (e.g., LIFO, FIFO, a priority schedule or other technique known in the art) and can be forwarded to user space  by bridge manager .","Job manager  can receive requests from bridge manager  and queue the requests in user space queues . Job manager  can then read a request from user space queues  and forward the request to complex math library , which can carry out various processes and generate results based on the request. For example, if the request is to verify A, complex math library  can verify A based on SRP methods known in the art and generate a response as to whether or not A is verified. If, on the other hand, the request is to calculate B, complex math library  can calculate B using g, v and b and generate a response containing B. As with requests, job manger  can queue the response before sending the response back to kernel layer . At kernel layer , bridge manager  of bridge driver  can receive the response and queue the response at queues . Bridge manager  can also perform any postprocessing required by a particular implementation and forward the response back to authentication engine . Assuming A is verified and B generated, authentication engine  can then send B to iSCSI initiator .","When iSCSI initiator  receives B, iSCSI initiator  can generate a value S based on the salt s, public ephemeral key B, a long-term private key x and random a. Additionally, iSCSI initiator  can hash S to generate M and send M to iSCSI target . iSCSI target  can authenticate M and calculate a value for HM based on public ephemeral key A, the password verifier v and b. If M is verified, iSCSI initiator  is verified and iSCSI target  can communicate HM to iSCSI initiator . If iSCSI initiator  verifies the value of HM, target  will be verified and the communication of non-authentication data from iSCSI initiator  to target  can begin. The verification of M and calculation of HM, as with the verification of A and calculation of B, can require complex mathematical processes and, therefore, can occur in user space  based on requests from authentication engine .","In the embodiment shown in , a portion of the SRP authentication method at iSCSI target  can occur in kernel layer  while another portion can occur in user space . Determining which processes occur at which layer, in one embodiment of the present invention, can be based on the overall efficiency of the system with simpler processes occurring in kernel layer  and more complex processes occurring in user space layer . This can provide the advantage of allowing a portion of the processing to occur at the typically more efficient kernel level without requiring that the kernel become too large, and potentially unstable, with programming for complex operations. In a system that receives a large number of authentication requests, such as an iSCSI router, implementing a portion of the programming at the kernel layer can result in substantial efficiency gains over systems that implement the entire authentication process (other than servicing of hardware access calls) in user space.","Although only one iSCSI initiator  is shown in , iSCSI target  can service requests from multiple iSCSI initiators. In the embodiment of the , the basic authentication information can be stored in configuration database  as, for example, an entry containing a user name, a password verifier and a salt value. Information associated with new iSCSI initiators that can be authenticated by iSCSI target  can be added to configuration database , in one embodiment of the present invention, by an administrator. As shown in , for example, this can be done by sending information from an administrator database  to configuration database  over the iSCSI protocol layer (iSCSI PL) using an Intelligent Input\/Output (\u201cIO\u201d) channel. IO, as would be understood by those of ordinary skill in the art, is a standard mechanism for passing messages between a host processor and an intelligent I\/O processor. In one embodiment, data can be passed from administrator database  to configuration database  each time iSCSI target  is rebooted. Administrator database  can be updated, in one embodiment of the present invention, directly (e.g., via serial interface ) or remotely (e.g., via HTTP interface ).",{"@attributes":{"id":"p-0059","num":"0061"},"figref":"FIG. 5","b":["415","430","432","435","440","435","505","505","430","440","510","515"]},"As described earlier, a portion of the authentication information used by authentication engine  can be stored in configuration database  can include a user ID database and control fields portion . The user ID database, in one embodiment of the present invention, can contain user-related information, such as a triplet of the form {<username>,<password verifier>,<salt>}, or other user-related information known in the art. The control fields can contain authentication configurations, such as authentication methods supported by iSCSI target . Authentication can occur in response to a connection established with an iSCSI initiator. iSCSI Login Logics , which can be part of the iSCSI layer, can interact with the iSCSI initiator to handle login\/logout procedures and with authentication engine  to process authentication requests. While configuration database , authentication engine  and iSCSI login logics  are each shown as separate modules of iSCSI layer driver application , they can be implemented using any suitable programming architecture known in the art.","Authentication core  can further include authentication logics portion , secure remote password-secure hash algorithm (\u201cSRP-SHA\u201d) portion  and state tracer portion . Authentication logics portion  can contain the logic necessary to process authentication information received from iSCSI initiator , generate requests to user space  to carry out tasks (e.g., verify A or generate B), and use results received from user space. SRP-SHA portion  can include hashing algorithms to, for example, hash a value received from user space to generate HM. State tracer portion  can include rules for generating error results when, for example, authentication fails, a connection is dropped or another error occurs.","As illustrated in , authentication engine  can use various parameters  in the authentication process. Parameters  for the SRP method can include, by way of example but not limitation, private ephemeral keys, public ephemeral keys, random scrambling parameters, usernames, password verifiers, salt values, generator values and prime modulus values. Authentication engine  can receive parameters , in one embodiment of the present invention, from configuration database , an iSCSI initiator via iSCSI login interface  and\/or from user space applications. Keys and parameters  can be used in the SRP method as described in conjunction with .","It should be noted that parts of authentication engine  shown in  can be implemented in user space rather than in kernel layer . For example, hashing can occur in authentication math function provider application  based on a request generated by authentication engine . Therefore, it should be understood that implementation authentication engine  and delegation of tasks between the kernel layer and user layer can occur in any suitable programming manner, as would be understood by those of ordinary skill in the art.",{"@attributes":{"id":"p-0064","num":"0066"},"figref":["FIGS. 6A and 6B","FIG. 6"],"b":["602","405","604"]},"At step , an iSCSI initiator (e.g., iSCSI initiator  of ) can send an initiator name, target name and list of supported authentication methods to the iSCSI target. The next stage parameter (\u201cNSG\u201d), CSG and T included in the transmission from the iSCSI initiator to the iSCSI target can be used, as would be understood by those of ordinary skill in the art, to coordinate the authentication session. It should be noted that the parameters CSG, NSG and T, along with additional parameters such as A, B, M, HM, g, n, v and s (discussed below) are commonly used for SRP and would be known to those of ordinary skill in the art.","The iSCSI target, at step , can determine if it supports any of the received authentication methods by, for example, comparing the authentication methods received from the iSCSI initiator to a list of authentication methods in a configuration database (e.g., configuration database  of ). At step , the iSCSI target can send back to the iSCSI initiator a list of supported authentication methods. The iSCSI target and the iSCSI initiator can select a common authentication method based on any negotiation scheme known in the art. In the example of , the iSCSI initiator and target can select SRP as a common authentication method, though any other authentication method known in the art can be used.","Once an authentication method is agreed upon, the iSCSI initiator can send parameters associated with the authentication method to the iSCSI target. Because, in the example of , SRP is being used as the authentication method, the iSCSI initiator, at step , can send a user name and whether the iSCSI initiator also requires the iSCSI target to authenticate (i.e., whether the iSCSI initiator requires bi-directional authentication). The iSCSI target can search the configuration database for the user name (step ) and, if the user name is found (step ), the iSCSI target can, at step , return values for N, g and s specified by the SRP protocol (i.e., a large prime number, a prime root and the salt value associated with the user name). Based on the values of N, g and s, the iSCSI initiator can send to the iSCSI target a public ephemeral key A (step ).","In one embodiment of the present invention, each of the steps performed thus far at the iSCSI target can occur at the kernel layer. However, because programming of complex mathematics at the kernel layer could result in a large kernel, the iSCSI target can leverage user space applications for verification of the value of A in steps -. When the iSCSI target receives A from the iSCSI initiator, the kernel layer can format a request to a user space authentication math function provider application to verify A. The kernel layer can optionally queue the request, establish a communications channel with the math function provider application and forward the request to the math function provider application. A job manager can receive the request, optionally queue the request and forward the request to a supporting complex math library for further processing. The supporting complex math library, in turn, can process the request (e.g., verify A according to SRP processes known in the art) and generate a result as to whether or not A is verified. The job manager can optionally queue the result and send the result back to the kernel layer.","If, at step , the value of A is verified, the iSCSI target can generate public ephemeral key B and return it to the iSCSI initiator. As with the verification of A, generation of B can require the use of large numbers and complex mathematical processes. Therefore, based on a request from the kernel layer, the iSCSI target can generate B in user space (step ) and pass B back to the kernel layer. At step , the iSCSI target can communicate B to the iSCSI initiator. In response, the iSCSI initiator can generate M and send M to the iSCSI target (step ). At step , the iSCSI target can verify M, a process that can also require the use of large numbers and complex mathematics. The kernel layer of the iSCSI target can send a request to an authentication math function provider application to verify M in user space. The authentication math function provider application can carry out the process of verifying M and send the results back to the kernel layer.","If M is verified (step ), the iSCSI target can determine if the iSCSI initiator requires bi-directional authorization (step ). The iSCSI target can do this by, for example, checking the parameters received from the iSCSI initiator at step  (i.e., by checking if the \u201cTargetAuth\u201d parameter is set to yes or no as would be understood by those of ordinary skill in the art). If the iSCSI initiator does not require the iSCSI target to authenticate, control can pass to step  and operational parameter negotiation can begin. If, on the other hand, the iSCSI initiator does require the iSCSI target to authenticate, the kernel layer of the iSCSI target can send a request to the authentication math function provider application to generate a value for HM (step ). The authentication math function provider application, in response to the request, can generate HM and send HM from user space to the kernel layer. The iSCSI target can then send HM to the iSCSI initiator (step ). If the iSCSI target is properly authenticated at the iSCSI initiator, the iSCSI initiator will begin operational parameter negotiation and will send operational parameters in the next PDU (steps -).","In summary, the SRP method, as would be understood by those of ordinary skill in the art, involves verifying and generating various authentication parameters. An iSCSI initiator can generate and an iSCSI target can verify authentication parameters A and M (steps  and , respectively). If the parameters are verified the authentication process can continue as described above. If, however, the parameters can not be verified, the iSCSI target can send an authorization failure message to the iSCSI initiator (step ) and close the connection (step ). The authentication process can be repeated (step ) for each new authentication request from an iSCSI initiator.","The verification of A and M and the generation of B and HM require the use of complex mathematical processes and large numbers. To avoid programming this at the kernel layer and the attendant problems associated with complex kernels, these processes can occur in user space based on requests from the kernel layer, while the remainder of the authentication process can occur in the kernel layer. This allows embodiments of the present invention to utilize existing or new support libraries to provide support to processes occurring in the typically more efficient kernel layer. In a system that receives a large number of authentication requests, such as an iSCSI router, implementing a portion of the programming at the kernel layer can result in substantial efficiency gains over systems that implement the entire authentication process (other than hardware access calls) in user space.",{"@attributes":{"id":"p-0073","num":"0075"},"figref":"FIGS. 3-6"},"Furthermore, embodiments of the present invention can carry out any process in which a user space application can support a kernel layer process. For example, embodiments of the present invention can authenticate for various protocols (SCSI, IP\/TCP, fibre channel, or other protocols known in the art) using SRP or other authentication methods known in the art. Other embodiments can act as hardware drivers using the support of user space applications to carry out part of the driver process (e.g., to carry out complex calculations) or can carry out any other process known in the art that can be at least partially implemented in the kernel layer.","In the examples given previously, the kernel layer process carried out simpler tasks while the user space application carried out tasks that would be difficult to program at the kernel layer. However, tasks can be delegated between the layers in any manner, with simple tasks being carried out in user space and\/or more complex tasks being carried out at the kernel layer or in any other manner as would be understood by those of ordinary skill in the art.","The present invention provides a system of extending the functionality of the kernel layer by allowing portions of a process to occur at the kernel layer, while leveraging the complexity and stability of user space to carry out other portions of the process. Embodiments of the present invention provide a system and method for passing the results of processes performed in user space to kernel space. One embodiment can include a kernel that can pass a request for a process to a user space application. The user space application can carry out the request and send the result of the process to the kernel in a format usable by the kernel for further processing. In this manner, user space applications can be leveraged for performing complex calculations or to carry out other processes, while the remainder of the processing can occur at the typically more efficient kernel level.","Because the kernel can send requests to and receive response from user space applications, the kernel can utilize the results of complex calculations without requiring a significantly larger kernel. This provides additional advantages because programming and debugging of complex algorithms can occur at the user space level rather than the kernel space level. Moreover, because kernel space normally runs more efficiently than user space, further processing in kernel space of the results generated in user space will typically be more efficient than further processing of the same results in user space.","Although the present invention has been described in detail herein with reference to the illustrative embodiments, it should be understood that the description is by way of example only and is not to be construed in a limiting sense. It is to be further understood, therefore, that numerous changes in the details of the embodiments of this invention and additional embodiments of this invention will be apparent to, and may be made by, persons of ordinary skill in the art having reference to this description. It is contemplated that all such changes and additional embodiments are within the spirit and true scope of this invention as claimed below."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE FIGURES","p":["A more complete understanding of the present invention and the advantages thereof may be acquired by referring to the following description, taken in conjunction with the accompanying drawings in which like reference numbers indicate like features and wherein:",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIGS. 6A and 6B"}]},"DETDESC":[{},{}]}
