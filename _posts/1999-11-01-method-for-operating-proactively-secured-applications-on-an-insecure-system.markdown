---
title: Method for operating proactively secured applications on an insecure system
abstract: A method for providing a proactive security in proactive operating environment. The proactive operating environment includes a group of proactive servers communicating over a network. Each proactive server (PS) includes a storage that includes a non erasable part that stores a public, non proactive related, key V. The storage further includes an erasable part for storing private and public data. The proactive server has a discardable one-time private key Sthat corresponds to the public key V. The proactive server further has configuration data C. There is further provided a processor for providing a proactive services to applications. The proactive server has a group public proactive key Vcommon to the group of proactive servers and a share Sof a corresponding private proactive key S. The method further includes the steps of invoking initialization procedure for generating restore related information, and invoking a restore procedure for utilizing the public, non proactive related, key Vand the restore related information for restoring the public proactive key V.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07003677&OS=07003677&RS=07003677
owner: International Business Machines Corporation
number: 07003677
owner_city: Armonk
owner_country: US
publication_date: 19991101
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","REFERENCES","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF SPECIFIC EMBODIMENTS"],"p":["The present invention is in the general field of proactive security system and related applications.","Traditional security systems assume that one or more systems are always secure, i.e. are never controlled by the attackers. The model of Proactive Security does not make this assumption. Instead, it considers cases where all components of the system may be broken-into and controlled by an attacker, with restrictions on the number of components broken-into during the same time periods (day, week, . . . ).","Proactive security shows how to maintain the overall security of a system even under such conditions. In particular, it provides automated recovery of the security of individual components, avoiding the use of expensive and inconvenient manual processes (except for some \u201caggressive\u201d attacks, which cannot be prevented\u2014but are definitely and clearly detected). The technique combines two well-known approaches to enhance the security of the system: distributed (or threshold) cryptograph, which ensures security as long as a threshold (say half) of the servers are not corrupted and periodic, refresh (or update) of the sensitive data (e.g. keys) held by the servers. In short,\n\nProactive=distributed+refresh \n","This way, the proactive approach guarantees uninterrupted security as long as not too many servers are broken at the same time. Furthermore, it does not require identification when a system is broken into, or after the attacker loses control; instead, the system proactively invokes recovery procedures every so often, hoping to restore security to components over which the attacker lost control.","Proactive security is highly desirable in many realistic settings, in particular:\n\n",{"@attributes":{"id":"p-0007","num":"0000"},"ul":{"@attributes":{"id":"ul0003","list-style":"none"},"li":["1. D. Boneh and M. Franklin, In Proc. Crypto '97, pp. 425-539.","2. R. Canetti, R. Gennaro, A. Herzberg and D. Naor, --CryptoBytes: the technical newsletter of RSA Labs, Vol. 3, number 1\u2014Spring, 1997.","3. R. Canetti, S. Halevi and A. Herzberg, \u201c-. To be published in Journal of Cryptography, 1999. An extended abstract of this paper appeared in the Proceedings of the 16ACM Symp. On Principles of Distributed Computation. 1997","4. C. S. Chow and A. Herzberg. -Appears in Proc. 5USENIX UNIX Security Symposium, Salt Lake City, Utah, June 1995, pp. 55-63.","5. V. Hamilton, G. Istrail\u2014Sandia National Labs, -Proceedings of the 1998 RSA Data Security Conference.","6. A. Herzberg, M. Jakobsson, S. Jarecki, H. Krawczyk and M. Yung, ACM Security '97."]}},"There are a few implementation efforts of proactive algorithms. Specifically, the Network Randomization Protocol (NRP) of [4], which provides a proactive pseudo-random generator, has been implemented at IBM. In the latter it is assumed that there is no global information common to the proactive servers and therefore, obviously, there is no need to restore it after loss or corruption. This assumption poses undue constraint insofar as some commercial applications are concerned.","Another effort, the implementation of proactive threshold key protocols, has been reported in [5].","Whilst there have been efforts to deal with applications where global information is restored in response to loss or corruption they all require to store in a protected environment (e.g. ROM) information that is related to the group of proactive servers. Obviously, this information is not available when the server is manufactured and sold, but only much later\u2014when it is integrated into a specific proactive environment. Accordingly, incorporation of such information requires a relatively sophisticated hardware and is of static nature, meaning that after having incorporated the group related global information in the ROM (or equivalent hardware), the information cannot be altered, if, say, the group members change.","Overview of the Proactive Model and Algorithms","Model","The proactive model described below assumes typically (although not necessarily) the following. A set of n servers (P, P . . . Pn) that are interconnected by complete point-to-point communication channels. Time is divided into periods (like days, weeks . . . ) which are determined by some global clock. An adversary may (temporarily) attach up to t of the n servers at any given time period\u2014but at different time periods, different sets of t servers can be attacked. As a result, all servers engage in a refreshment stage at the beginning of each time period, so that any server which has been attacked during past periods may automatically recover from possible undetected break-ins. Corruption is assumed to be either static (for example, disconnect a server from the rest of the network, eavesdrop, read secret data) or active\/malicious (for example, deviate from the protocol, corrupt local data, etc.). Therefore, after the attacker loses control over a server, the attacker may still know secret information of that server (e.g. passwords or secret keys). Furthermore, before losing control, the attacker may have corrupted (modified) some of the server's data (e.g. public keys of certificate authorities). The refreshment stage deals with both aspects, i.e. recovers any corrupted data and invalidates any old secret data (by choosing new secrets or splitting global secrets into a new set of shares). This brings the server back to a running stage, and guarantees that any information that was gathered by the adversary becomes worthless after recovery.","The fact that the attacker is limited to t corruptions, out of n servers, is similar to the distributed (or threshold) security model used many works in distributed computing and cryptography. However, in the proactive security model, the attacker is allowed to corrupt every server\u2014as long as it does not corrupt more than t servers at the same period. The adversary in the proactive model is mobile, namely attacked components may be released at some point due to some security measure or other change in the system or the adversary causing loss of control, often as a result of an attempt by the adversary to avoid detection or the attack). Furthermore, in contrast to other approaches, proactively secure systems do not necessarily wait until a break-in is detected. Accordingly, a proactively secure system may invoke the refreshment protocol periodically (and proactively) in order to maintain uninterrupted security, or force detection. For more discussion on the motivation behind this model, see [2, 3]","Some attacks on the system cannot be prevented. The \u2018classical\u2019 example is if the attacker is breaking into a server, thereby finding all its secret keys; it then pretends to be that server while keeping this server disconnected from the other servers (when the attacker lost control over that server). However, in such cases, the attack can be detected and raise an alert\u2014inform the operator about the attack. Operators will normally respond to such an alert by invoking special emergency security resources and procedures, which are very likely to remove the attacker\u2014and possibly catch her as well. Therefore, it is highly unlikely that (smart) attacker will use such \u2018visible\u2019 attacks.","The proactive security model assumes that even during attack, some specific data cannot be corrupted. The obvious example for data that is assumed not to be corrupted is the program itself; if it could be changed, recovery is clearly impossible. Clearly, the program is not any different than any constant value used by the program; It is assumed that each computer proactive server comes with a read only memory which can specify its contents. Specifically, it is assumed that each computer (proactive server) comes with such a non-erasable storage, e.g., a read only memory (ROM) containing a fixed public key, and the corresponding secret key is known only at initialization as will be explained in greater detail below. This assumption is not too difficult to implement in practice. The characteristics of the specified model are described for clarity of explanation and accordingly those versed in the art will readily appreciate that various alterations and modifications may be applied, all as required and appropriate depending upon the particular application.","There is accordingly a need in the art to provide for an operating environment of a network of servers which are set up once (designated group of protective servers). Each server is instantiated preferably at boot time by the operating system and is checked periodically, also by the operating system. Servers can recover data (both public and private data) from self or other servers in the proactive network, if such data is corrupted or lost. There is a specific need in the art to provide for an initialization and recovery procedures for a proactive operating environment of the kind specified.","The invention provides for a proactive operating environment that includes a group of proactive servers communicating over a network; each proactive server (PS) comprising:\n\n","The invention further provides for a method for providing a proactive security in proactive operating environment; the proactive operating environment includes a group of proactive servers communicating over a network; each proactive server (PS) comprising:\n\n","Still further, the invention provides for a storage medium storing computer implemented program for providing a proactive security in proactive operating environment; the proactive operating environment includes a group of proactive servers communicating over a network; each proactive server (PS) comprising:\n\n","There follows a description of the basic architecture and functional operation of a proactive operation environment in accordance with one embodiment of the invention.","Thus, the proactive operating environment includes a network of servers () which is set up once\u2014this network is referred to as the Proactive Network, or group of proactive servers (see FIG. ). Obviously, the network may include other servers which may form part of other proactive group or groups, all as required and appropriate. It should be noted that a server may be a member of two or more groups. Server should not be construed as bound to any specific platform or architecture.","Each node in the network runs a proactive server (Pserver), of which only 5 are shown ( to ). The basic, non limiting, architecture of Pserver () (in accordance with one embodiment) is depicted in FIG. . Thus, a Pserver communicates with other Pservers via the proactive network (), and provides proactive services to applications (designated generally as ()) by means of, say, Application Programming Interface (API). A server is initiated at boot time () and checked periodically by the operating system ().","Modules of the Pserver","By a non-limiting embodiment, the internal design of Pserver () is composed of the following modules:",{"@attributes":{"id":"p-0027","num":"0000"},"ul":{"@attributes":{"id":"ul0012","list-style":"none"},"li":{"@attributes":{"id":"ul0012-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0013","list-style":"none"},"li":["The Controller: This is the main \u201cengine\u201d of the program. It manages the Pserver data, dispatches incoming messages to appropriate protocols in the protocols tree, keeps the status of the proactive network (namely, which nodes are active and running).","Communication Module: This module is responsible for the secure transmission and receipt of messages across the proactive network and with the various applications that use the Pserver services.","Library of Proactive Utilities: This library is built upon a standard cryptographic library and is a collection of utilities (objects) that are needed for implementation of proactive algorithms and protocols. It includes, for example, Shamir's secret sharing SS0, Feldman's Verifiable Secret Sharing, Joint Secret Sharing and error-correcting polynomial interpolation. Note that this library concerns preferably functionalities that are needed locally in order to perform the protocols.","Library of Proactive Protocols: A proactive protocol (in contrast to a proactive utility) is a thread of code that is executed at one server and performs the logical flow of communication steps required by a certain protocol, using the proactive utilities library for its local computations. The implementation is based e.g. on a collection of protocols that are executed by the Pservers (either for its proper operation or as a proactive service to other applications). Examples of protocols are all variants of Secret Sharing protocols, as well as the Initialization and Recover Procedures, according to the invention which will be described in greater detail below.","The API Module: A module that provides interface to applications that run over the proactive operating environment.\n\nThe Pserver Data\n"]}}}},"The Pserver, maintains some key internal data. However, the maintenance of these data raises a few algorithmic problems, as the server must be able to refresh and recover itself periodically, and this includes recovering its data or at least verifying that it has not been corrupted. The server's data is one of three types. The specified data are stored in various modules designated generally as storage () in , as follows:\n\n","In accordance with the invention, a proactive operating environment must maintain proactively secure communication among the servers, as well as a proactive internal signature key for the entire lifetime of the system. For that, these two protocols must be initiated and undergo refresh at every period, where a refresh may actually involve recovering in any server if that server had detected that some of its data was corrupted or lost. Publication [3] provides the design of the integrated proactive protocols of signatures and secure communication, and [5, 6] for the specific proactive signature mechanism. However, [3] requires every server to keep in read-only memory (ROM) a copy of the public non-proactive related key Vcert (whose corresponding secret key Scert) is shared between all the proactive servers, and these shares S(t) are refreshed at every period t. This assumption is not very practical, as the public key Vcert (common to the group of proactive servers) is not available when the computer is manufactured and sold, but only much later\u2014when it is integrated into a specific proactive environment. In accordance with the preferred embodiment of the invention, it is shown how to provide the requirements of [3] while requiring only that each computer comes with pre-installed, machine-unique pair of secret key S(e.g. on erasable disk), serving as the one-time private key and public key V(on ROM). It is accordingly appreciated that unlike Vcert, Vstart is unique and not group related.","Another practical aspect which has to be dealt with is that the proactive server needs some constants configuration information such as IP addresses of other servers, cryptographic parameters used in the cyrptographic algorithms, and so on. The set of these (public) constants are denoted by C. The proposed protocols include mechanisms to recover C periodically (if the adversary corrupted C when breaking onto the server at the previous period). Let Mi=[S(V,C)] be the signature of server I on (V,C) using its initial key S. M denotes the concatenation of all Mi's, that is M=(M,M. . . M). Hence, M is the Invariant Information of the system.","Publication [3] provides a review of the periodical refresh protocol, which assumes the availability of an unmodified Vcert at every proactive server. Typically, although not necessarily, the recover procedure of the invention is invoked when the refresh procedure has encountered loss or corruption of data that needs to be recovered.","The initialization protocol is executed, preferably, at the setup of the system and is described with reference to FIG. . The goal is to bring the servers to a state from which they can safely perform the recover module at the refresh stage, if necessary, and accomplish proper operation of the system. To this end, the initialize procedure generate a so called restore related information.","The input to the protocol (i.e. the initialize procedure () is the configuration (designated generally as C and (S, V), where Vis the public non proactive related part of the key stored in the ROM module of the proactive data (). Vis considered non-proactive as it is not group related. Put differently, the same Vkey may be used for the Pserver #i regardless of the group of proactive servers to which it belongs. Vstands, for example, for the PS unique identification code embedded in the ROM during manufacture. Sis the corresponding private key which is used once and must be discarded afterwards.","At first (-), a set of keys S(), V(), E(), D() are generated, and all except D() are broadcast over the network channel to the rest of the servers (1 . . . i\u22121, i+1, . . . n), so as to authenticate and encrypt the channel, all as known per se. As is well known the E(), D() are optional whereas S(), V() are, as a rule (albeit not always), used.","Next, a pair of keys are generated, i.e. group public proactive key is generated Vand a share of the corresponding private key S() by a well known procedure (e.g. see [1]) () giving rise to Vpublic key common to the group of the proactive servers. Sis the private secret share of SP (i).","Any message signed by Vis assumed to be truly signed by the members of the group.","In the next steps a joint signature (S(M),M) is generated, standing, preferably, for the invariant information to help recovering servers (as will be explained in greater detail below).","To this end, the Vpublic key and the configuration C are signed using the one-time private key Sso as to constitute Mmessage (). In this connection, it should be noted that the configuration C is not bound to any specific contents and may vary, depending upon the particular application. Having generated M, the one-time private key Sis discarded (), such that it can no longer be accessed and used by any other node.","Mis now broadcasted to all, and Mis received from all respective SP(). Now the InvariantInfo is constructed by concatenating M. . . M() and is signed () so as to generate the joint signature (S(M), M).","The information generated by the initialize procedure, and which will later be used by the restore procedure, constitutes one form of restore related information (e.g., (S(M),M); S(VC).","It should be noted that the restore related information includes a \u201cself\u201d part serving for restoring at least the V(and possibly other) info (e.g. the specified M) of the specified Pserver, and optionally also \u201cothers\u201d part (e.g. the S(M),M)) which will assist other servers in the group to recover their respective V(and possibly other) info. It should be noted that in the specific example described herein, each server generated \u201cothers\u201d info (i.e. M and signed M) which enable any other server in the group to restore its Vinfo solely relying on the \u201cothers\u201d info of that particular server, since, M is a concatenation of the Mparts of each one of the other members in the group. Thus, any server which is subject to corrupted or loss of Vinfo, will be able on the basis of the verified M received from the specified \u201cother\u201d server to extract its respective Mand using the Vkey stored in its ROM, to construct V(and possibly other lost data).","Those versed in the art will readily appreciate that this is not necessarily always the case. Thus, for example, by another embodiment a given Pserver can recover the Vinfo on the basis of \u201cothers\u201d info received from two or more of the specified group members. In this connection it should be noted, generally, that the unlike the \u201cself\u201d info that is always generated, the \u201cothers\u201d info is generated only when required, depending upon the particular application.","Having completed the initialization procedure, the SP is ready for the recovery procedure which may be invoked by the refresh procedure, as described above. The recover procedure utilizes the restore related data generated by the initialization procedure.","At the beginning of every recover, Vcert is regenerated and the constant C is restored for any server which lost these data. As a result, it brings a recovering server to a state from which it can participate in the Refresh protocol described above. It is assumed that any operational server has a valid copy of a signature on M, the Invariant Information of the system, signed by the distributed signature key Scert\u2014an assumption that is supported by the initialization module described above.","Essentially, this protocol allows any recovering server to gather M, the Invariant Information of the system, from other operational servers as long as there are enough of them. Note that M needs to be \u2018pushed\u2019 around the system since a recovering server may not known who its partners are (recall that C, the program constants, contains information such as IP addresses). The protocol is executed by all servers, and by the end of it, a server detects whether it is \u2018operational\u2019 or \u2018recovering\u2019.","Turning to , at first, Vis extracted from the ROM (). In order to validate the joint signature (S(M), M) () the following procedure is invoked. To this end, the Vshould first be extracted which necessitates to extract Mfrom M(). This can be easily accomplished considering that M is a concatenation of M. . . M. Having obtained M, Vis constructed by applying V(that is available to the recovering SP as it is stored in the ROM) to M. It is recalled in this connection that Mconsists of S(V, C), and accordingly applying Vthereto will give rise to V(and the configuration C).","Those versed in the art will readily appreciate that by using a unique key a-priori stored in the ROM, the recovering SP is able to restore the Vkey, which is group dependent (non-proactive related). It is recalled in this connection that according to hitherto known techniques, it was required to maintain the group dependent key for the recovery procedure. This requirement according to the prior are posed undue constraint as it was required to embed during manufacture (or afterwards using dedicated expensive hardware) a group dependent key in each SP, whereas according to the present invention, it is sufficient to embed a unique key V(say the SP identification code) and therefrom to reconstruct the group dependent key V.","Having constructed V, () the latter is used to validate M by applying Vto the joint signature part (S(M)) (). If the result matches M (which is explicitly included in the joint signature) (), then the server becomes operational (). In other words, by validating M, the recovering server has confirmed the validity of all Mof the respective SPs and consequently has confirmed that each corresponding SPis a member in the group. M and S(M) are then sent to all the members () allowing each one of them to exploit M for recovering its self V.","If, on the other hand, M is invalid (i.e. the application of Vin step () did not result in M, then the SP await the receipt of another joint signature ( and ) and in response repeats steps () and onwards until M is validated.","In the claims below, alphabetical letters and roman symbols are used for convenience only and do not necessarily imply any order of the method steps.","The present invention has been described with a certain degree of particularity, but various alterations and modifications may be carried out without departing from the scope of the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["In order to understand the invention and to see how it may be carried out in practice, a preferred embodiment will now be described, by way of non-limiting example only, with reference to the accompanying drawings, in which:",{"@attributes":{"id":"p-0020","num":"0051"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0021","num":"0052"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0022","num":"0053"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0023","num":"0054"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
