---
title: Automated business software application integration
abstract: Automatic business software application is provided. Aspects of business, including objects and activities are classified and described in a comprehensive, standard manner. When a business software component is installed, a discovery manager identifies capabilities and requirements of the software based upon information describing the software in accordance with the standardized classification. The software component is selectively bound to one or more roles of a model-driven bus. In some aspects, a standardized software adapter is able to facilitate use of embodiments of the present invention with prior art software systems. Additional software layers and overhead facilitate the management and operation of multiple software components.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07395540&OS=07395540&RS=07395540
owner: Microsoft Corporation
number: 07395540
owner_city: Redmond
owner_country: US
publication_date: 20031203
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE OF CO-PENDING APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENTS","EXAMPLE","EXAMPLE","EXAMPLE","EXAMPLE","EXAMPLE"],"p":["The present application claims priority to previously filed now abandoned provisional application Ser. No. 60\/454,537, filed Mar. 12, 2003, entitled Application Integration by Applying Automated Configuration of Process and Work-flows by Applying Prescriptive Taxonomies, Data Models and Schemas to Adaptive Control Fabric.","The present invention relates to business software solutions. More specifically, the present invention relates to integrating business software applications automatically by applying prescriptive taxonomies, data models and schemas.","Integrated business software solutions typically include multiple functional products that support business segments and interact with enterprise hub and spoke networks. Such products include software applications related to financial information, human resource management, customer relationship management, professional services automation, distribution, supply chain management, and more.","Individual business software solutions have typically been provided by software vendors that generally provide an application development environment to allow the software to be customized for individual business applications. Traditionally, these business software solutions were designed as relatively stand-alone offerings in that they were complete in their database, data model, automation interface, screen technology, screens, and customization tools. Thus, a user of such solutions would purchase a given solution from a vendor; customize the solution for the specific business requirement; and provide the customized solution to an end user. Examples of business solutions include software systems sold under the trade designations: Solomon, Axapta, and Navision all of which are available from Microsoft Corporation of Redmond, Wash.","As a given customer's needs change, the customer may wish to add additional functionality to their business solution. This was typically done by either buying a new business solution that was capable of providing such features, or buying an add-on business solution that could be configured to cooperate with the legacy business solution. Difficulties generally arise whenever two discrete software systems are used in conjunction with one another, which software systems had not been designed for interoperation together. This problem gave rise to an industry that could generate customized interface adapter software to allow one software system to communicate with another software system. Generally, such adapters are one example of software known as middleware. The necessity of middleware and the degree to which it is focused upon individual combinations of software systems and business environments generally caused a significant increase in the overall system implementation cost because relatively large amounts of highly skilled software development engineer time was required. The design and implementation of middleware can include any number of known methods and techniques for interacting with business software systems. These can include techniques as simple as keystroke injection, screen shot analysis, interaction with the individual databases of the software systems, modification of the source code of the various software systems, or simply the provision of an adapter application that receives an output from one application, transforms the output into suitable input for the second application and feeds the input to the second application.","Another way that businesses adapt their application to changing business needs involves making customizations to the applications they have. Customizations are often applied at the time a new application is sourced, whether as a new purchase or as an adjunct purchase to meet the need described above. The challenge that business software vendors face is supporting this end customer requirement for customizable applications. There are a number of different techniques which have been conventionally used in order to enable a given system to be customized. These include source code customization approaches as well as integrated tool based approaches that allow end customers to add fields to tables and forms themselves. Each of the techniques listed above generally increases overall system cost, either by increasing the cost of developing the application in the first place, or passing the customization development burden on to the end customer. One example, source code modification, entails providing customers with copies of the source code for the product. It thus allows a well-trained practitioner to change significant portions of an application. Those changes can be made to look as if they are part of the product because, in effect, they are part of the modified source code product.","However, source code modification carries with it significant drawbacks. For example, source code modification costs a significant amount of money prior to using the product, because the user or customer must often hire expensive consultants and developers who have been specifically trained in the nuances of how the product is built. The user must then endure the risk of estimating a problem, which is a very difficult and imprecise task. Even if these problems can be overcome and persevered, the result is modified source code. When the manufacturer of the original source code for the modified application ships additional software, such as bug fixes, updates, and new versions, the customer is either forced to again hire talented engineers or developers (and hopefully the same ones who made the original modifications), in order to merge those modifications into the new source code shipped by the manufacturer, and to resolve issues, one-by-one, as they arise in the newly modified source code. Alternatively, the user can simply go without the bug fixes and new features that may benefit the user's business.","All of the above problems set forth with respect to source code modification are equally present with respect to the creation of individual software adapters that act in conjunction with middleware to go between discrete business software solutions. An adapter is generally configured to transform the given output from a first software system, for example, a customer ID number to a usable input for a second system. For example, the customer ID field in one system may need to be changed from a character string to a long integer to import the data into a second system. A change to the first system as simple as padding the customer ID number string with a letter prefix can cause the application integration adapter to fail because the prefix cannot be converted.","Most forms of middleware and\/or adapters that are based on data transformation result in a relatively brittle set of code and\/or cooperative software components. The fragile nature of adapter based integration approaches complicates the decision to apply important software updates to any of the components of an integrated set of software. Integration strategies based on middleware and adapters break down due to inherent fragility as well as the expense of reintegrating the entire system whenever an update to any of the individual systems is performed.","A new system for automatically integrating discrete stand-alone business solutions in a manner that is extensible, stable, and automatic is needed. Such a system would allow competing (and cooperating) software vendors to design and provide components that could easily be integrated into a business solution with minimal customization cost while similarly not adversely affecting system stability. Finally, such a system would be easily amenable to patches and updates such that individual product improvements could be easily applied to address concerns, shortcomings, and\/or vulnerabilities that may be discovered in the future.","Automatic business software application is provided. Aspects of business, including objects and activities are classified and described in a comprehensive, standard manner. When a business software component is installed, a discovery manager identifies capabilities and requirements of the software based upon information describing the software in accordance with the standardized classification. The software component is selectively bound to one or more roles of a model-aware bus. In some aspects, a standardized software adapter is able to facilitate use of embodiments of the present invention with prior art software systems. Additional software layers and overhead facilitate the management and operation of multiple software components.","The present invention involves a framework for supporting business applications. However, prior to describing the present invention in greater detail, one exemplary computing environment in which the present invention can exist is described.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1","b":["100","100","100","100"]},"The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers, server computers, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like.","The invention may be described in the general context of computer-executable instructions, such as program modules, being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, etc. that each perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.","With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus also known as Mezzanine bus.","Computer  typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer  and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer  may also include other removable\/non-removable volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk  such as a CD ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in , provide storage of computer readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies.","A user may enter commands and information into the computer  through input devices such as a keyboard , a microphone , and a pointing device , such as a mouse, trackball or touch pad. Other input devices (not shown) may include a joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . In addition to the monitor, computers may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a hand-held device, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user-input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on remote computer . It will be appreciated that the network connections shown are exemplary and other-means of establishing a communications link between the computers may be used.",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 2","b":["200","202","204","200","206","208","210","212","210","212","210","212","210","212"]},"In , an entity knowing that a business that it wishes to communicate with is running System A, sends an Add.Order request to System A through System A API  as indicated on line . The order went through System A controller  and was written to database . The order, apparent on screen , was then transmitted to System B as a Sales.Order via adapter . The order status output of System B in response to the Sales.Order request is transformed by adapter  to enter System A as Order.Status as indicated at line . The operation described with respect to  is a classic example of middleware (specifically adapters , ) acting to allow two discrete business software solution systems to communicate and interoperate with one another. If, in the future, System B is replaced with System C, or even upgraded to a version of System B\u2032, adapters  and  will need to be rewritten.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 3","FIG. 3","FIG. 3"],"b":["200","206","204","216","218","220","222","224","226","228","230"]},{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 4","FIG. 4","FIG. 4"],"b":["200","232","234","236","238","240","236","238","242","244","246","248"]},"These adapters are standardized in the sense that they represent an acknowledgement of the comprehensive taxonomy embodied in API's  and . Specifically, each of the standardized adapters may include at least a notation, or stub for business objects and\/or processes that are not supported by the stand-alone business software system. When such items are not supported, the standardized adapter will simply indicate such. Accordingly, as used herein, standardized adapter is intended to mean a software adapter to couple a stand-alone business software system to an over-arching business software solution wherein the standardized adapter is designed in accordance with a comprehensive business taxonomy. For illustration purposes, adaptations in each of adapters , , and  of non-supported items are shown as vertical stripes , standardized adapters , , , and  may also be referred to herein as gap-tooth adapters. The embodiment illustrated in  allows independent software vendors the ability to interact with a standardized, durable interface (via API's  and ). This interface is considered durable in that it will be considered an interface contract in the sense that functions and objects designed to interact with the interface will always function. Accordingly, the interface comprising API's  and  will never get smaller; it will only grow thereby insuring backward compatibility. This will allow independent software providers to focus more of their resources on designing their own products, rather than spending considerable resources to generate interfaces from their product to the various API's and\/or adapters in existence today.","It is preferred that the multiple systems , , and  interact with the model aware bus in the form of publisher\/subscriber models. Thus, when a stand-alone business software application is installed, it will subscribe to the business actions or events to which it is able to process, and will indicate that it is a publisher of certain types of data and\/or events based upon its own capabilities. As an example,  illustrates each of systems  and  connected to ISV App  via connection  and coarse-grain API . Each of systems  and  is able to respond to a type of event (for example book an order) and thus have subscribed to the Book.Order event. This event may be encoded numerically, for example, as business event .... Application  acts as a source of information for the event; sending the event via the coarse-grain API on the bus, which receives the event and determines if any of the stand-alone systems to which it is coupled are subscribers of the event. In this case, both system  and  are subscribers and thus the event is passed to them by the bus. Separately, once the order is filled, system  needs to send an update order status event while system  requests order details via standardized adapter  and API  and then sends a ship notice (an event encoded as ...). Coarse-grain API  is used to send the ship notice from System B and sends an appropriate notification as indicated at arrow . Additionally, assuming that System D has been installed and configured as a source of order line details, API  is used to send the request order detail message to System D () which will reply via fine-grain API .","While a pair of application programming interfaces  and  is illustrated in , it is expressly contemplated that a single API could be provided that would include both such interfaces. Additionally, while standardized adapters will be designed to facilitate interaction between known stand-alone business software applications, development of such standardized adapters is simplified in that at least half of the adapter, for example, half  of adapter  is generated to interact with the standardized comprehensive interface. Only the half, , of adapter  will vary based upon the stand-alone software application. Further, as software providers began to adopt the comprehensive interface and other aspects of the present invention, stand-alone software systems will be provided that automatically interact with API's  and  without using standardized adapters. System D () is one such example.","In order to facilitate inter-system communication, fine-grain API  is also adapted to function as a replication interface. Essentially, interface  will receive, generally via software triggers, events from each of the stand-alone software systems. API  will then provide the requisite instructions and\/or messages to the appropriate system based upon the publisher\/subscriber model described above.","The comprehensive interface comprised of API's  and  also may include the functions of an administrative API which allows the selection and\/or administration of software roles where two or more of the installed software applications overlap in their roles. Thus, one application may be instructed to not perform such role while the other is instructed to have that role enabled.","Thus, the interface created in accordance with an embodiment of the present invention provides one or more common APIs that provides the basis for a uniform automation capability. The interface is based on a shared, logical data model. Further, the interface provides support for adding a field or additional capabilities in a version-stable manner. Additionally, the stable interface is constructed in a way that it maintains stability as versions of the interface change. Additionally, the data models, API's and taxonomies are contemplated as being installable, so that the underlying software bus can be used to support more than one application domain model, enabling the bus to support one or more different, but standardized, business taxonomies, while providing a stable administrative and management toolset. Different application domain models can drive different domain-specific taxonomies. For example, a domain-specific comprehensive business taxonomy may be provided for the banking industry, while a different domain-specific comprehensive business taxonomy may be provided for the health care industry. Embodiments of the present invention include allowing the model-aware bus to be configurable to accommodate different versions or instances of comprehensive business taxonomies.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 5","b":"300"},"Embodiments of the present invention will generally employ six and optionally seven different forms of taxonomy. These taxonomies include module function; process function; process role; reference data; dependency; event data; and optionally key performance indicators.","An example of module function taxonomy essentially describes the grouping of business module functionality. An example of this description is describing a module as, for example, part or all of a Human Resources system, or all or part of a Customer Relationship Management system.","Process function taxonomy is used to describe the processes that can be performed by a given software application module. An example of this description is an indication that a module can participate in, for example, the lead qualification process illustrated with respect to .","Process role taxonomy is a description of the role played by the module in the business process. Extending the earlier lead qualification example, a particular application module would play the role of a submitter, or an approver.","Reference data taxonomy describes types of reference data made available to or required by an application.","Dependency taxonomy describes the intersection between the application or process and a given reference data or event data source. This also describes whether an intersection is a source or a sink for the described relationship. Examples of this dependency taxonomy include indications that the given application or process depends on, for example, customer data, and is used to determine whether the parts of a module that depend on there being an available source of customer data will function. If there is no source for customer data, the portions of embodiments of the invention that manage enabling or disabling parts of an installed application will prevent those dependent parts of the application from working. If a given module is totally dependent on a given process, data type, or other items from the business taxonomy, and those items are not present, the application will be disabled until those dependencies are satisfied. An example of this more restrictive dependency behavior includes an indication that the application or process requires a chart of accounts before it can operate.","Event data taxonomy describes types of events possible for consumption or production by a given application. An example of event data taxonomy, for example, is an indication that the application requires a copy of the change customer data event whenever changes are made to customer data via this event.","Finally, optional key performance indicators (KPI) taxonomy describes the type of key performance indicators available to a system. Examples of key performance indicators include items such as overall elapsed time to complete order fulfillment, on time deliveries, et cetera. These types of KPI's would not readily be visible to individual modules within an integrated suite of application components.","Several of these taxonomies are modeled in a module map.  is a diagrammatic view of a portion of a module map in accordance with embodiments of the present invention. Module map  simply contains an exhaustive list of all possible items in the business.  illustrates a pair of business software applications, , , which each fulfill different portions of the overall module map . Specifically, application  is designed to fulfill functions of order management, sales management, pricing, contract management, and lead qualification. During installation, or any other suitable discovery process, application  is queried to determine its capabilities. These capabilities are then bound to appropriate destinations by the embodiments of the invention based on being configured with taxonomies based on the module map in a manner that facilitates proper arbitration.  also illustrates application  fulfilling a different portion of module map . Specifically, application  is designed to provide demand planning and supply planning. This technique of managing business software capabilities also provides a way in which software of an entire business can be quickly and efficiently analyzed, for example by using an appropriate administrative tool designed to operate in conjunction with module map , to allow independent software vendors to identify and address opportunities to provide the business with additional or more appropriate business software.",{"@attributes":{"id":"p-0055","num":"0054"},"figref":["FIG. 7","FIG. 7"],"b":["320","322","324","320","322","324","326","322","324","328","330","320","324"]},"In one sense, the model-aware bus used with embodiments of the present invention provides advantageous features on a number of layers. One layer is used to manage message routing. The routing layer is responsible for routing requests from callers to configured providers. Requests can take the form of asynchronous or synchronous (call\/response or one-way call). The routing layer delivers requests based on the configured business process description defined in the model. Callers do not know destinations, nor are they directly linked with service providers. The routing layer serves as the final proxy\/agent that arbitrates the delivery of requests between components and modules.","The pattern fitness layer is responsible for checking that the meta-data description provided by components at install time matches the requirements defined in the active model. The fitness check is invoked based on properties of the process description in the active model. A meticulously detailed process description will prevent the routing of requests from deviating from the flows dictated by the active model.","Another layer is the operations and administration layer. This layer provides the end customer premise operations staff with the means to manage a running plug-and-play application. This layer provides visibility into application health, independent of the geographic dispersal of application parts. Operators performing installations are notified when conflicts arise\u2014whether between installed and to-be installed components, or between new components being installed and the process\/role\/message descriptions that are defined in the active model. Another example of a function provided by the operation management layer is checkpointing when significant changes are to be made to the business software system.","Another layer is the replication and mastering layer. This layer manages bulk flows of data during provisioning steps (set-up of a new replica, etc), bulk import, and the ongoing flows that are required to manage a distributed set of data stores that share common view of synchronized information.","Another layer is the tracking and auditing layer. This layer allows flows to be audited, traced, and debugged. Each module or component needs to eventually be capable of being placed into test or trace mode, and test result and trace data is written through this layer to a centralized tracking and auditing facility.","Finally, another layer can provide key performance indicators. This layer serves as a data observation and inference ability that allows flows between application components to be monitored as a source of information that is important to capturing the business health and other KPI data. Since the model defines the process interactions between models, the timing of events that are flowing between modules represents important business level performance data. This layer allows KPI's to be defined at the process black-box and white-box levels, and provides capture and reporting access across application modules.",{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 8","b":["400","402","404"]},"When software application  is installed, it provides metadata indicating that it can participate in a role of, for example, lead qualification, as indicated in . Due to this ability, an appropriate port of software application  will be bound to the suitable process role (process role A in ). The metadata essentially identifies the business software application as a module. The metadata further identifies ports available for binding and the appropriate business processes with which those available ports may participate. For example, the port of business software application  that is bound to the lead qualification process may provide sourcing responsibility for role A, indicating that it can provide the required information to begin the process identified as .... The metadata of application  may also indicate that it can source information for business process ... as well as sink information for business processes .... and .... Those skilled in the art will recognize that ports of software application  are binding on roles of the routing layer versus binding on ports. When system  is installed, the metadata provided by system  indicates to the model-aware bus that system  is suitable to bind to role B on process ... The metadata might indicate that application  can sink information for ..., source information for ..., sink information for ..., and source information for .... When application  is installed, its metadata indicates that it is also suitable for binding to a role (role C) in the process illustrated in . Once these bindings have occurred, the process may potentially be activated. For example, application  wishing to submit a lead, may query the model-aware bus to see if the lead qualification process is enabled. Bus  can reply to the inquiry indicating that the destination exists for the lead submission. In response, application  can submit the lead to bus . Application  does not need to know the final destination of the lead submission information because that routing information is stored within the routing layer of the model-aware bus.",{"@attributes":{"id":"p-0064","num":"0063"},"figref":["FIG. 9","FIG. 8"],"b":["406","410","410","410","410","410","406","410","410"]},"The operations and administration layer generally uses the metadata of the previous two layers (illustrated and described with respect to ) to provide high level functions such as whether the entire software solution is ready for an operation. Additionally, this layer can be used to enumerate defined and installed process definitions. Additionally, this layer can be used to flag or otherwise identify processes that are not completely fulfilled. These identified processes can then be brought to the attention of an administrative user who can then determine, manually, whether to attempt to enable such processes in their current state, or take remedial action to complete the process.","The operations layer facilitates configuration, provisioning, testing, checkpointing, and potentially even rolling-back of software. This also allows an administrator to install, patch, upgrade, replace, repair, retire, and\/or restore software relatively easy.","The \u2018model-aware bus\u2019 is a set of cooperating run-time services that enforce the system behaviors defined in a specific active model. The model-aware bus provides a generic mechanism for controlling the run-time behaviors defined in a model. Once a specific model is installed and marked as the active model instance, application modules, and individual components and services can be installed.","During installation, the meta-data provided by a given component is compared with the model. Depending on the settings of a local administrator, deviations from the model can be allowed or marked as deviations and disabled until further administrative action is taken.","At run time, flows between components take place based on the flow that the model describes. Senders, e.g. applications that have established role-based bindings to the bus, make requests to the bus, and based on the binding associated with a given component the information flows take place on the planned paths. Unplanned flows can be enabled administratively, or prevented altogether.","The design specification of the model-aware bus described above provides the technical interactions that bind a software component to the model-aware bus at runtime. By so binding, a component can begin interacting with other components, the bus itself, administrators and data services. Once a component is bound, the module interface design governs the business process and data interactions that are allowed.","The module interface, as defined by the taxonomies used to configure an instance of the bus, provides the convention that all components adhere to in order to achieve essentially plug-and-play interactions with other modules, as well as to allow the system itself to interact with any given module. The module interfaces themselves also expose a module specific set of capabilities in the form of services, user interface elements, and process interaction capabilities. Each of these reflects the expected behaviors that are defined by the domain specific model designer.","The following section focuses on the design elements that are generally common to all modules in order to facilitate plug-and-play capabilities.","One important aspect of embodiments of the present invention is the discovery process and initial setup interactions. This includes the way a component or module engages with the model-aware bus when the component or module is installed, configured, activated or de-activated. The primary interaction occurs when a new module, consisting of one or more components, is introduced to the run-time environment. During setup, the metadata that describes each component's business purpose, abilities, dependencies, roles, etc. is read from the each component being installed, and then compared against the manifest of installed items that are being managed by the model-aware bus, as well as the model information that is present within the bus model store.","During setup, the runtime aspects of the model-aware bus determine whether the components being installed are known to the model. Several cases are possible and a brief description of each follows. One situation occurs when a new module is being installed, and that module's meta-data corresponds with the meta-data of the model that is controlling the target runtime environment. In this situation, the module and its components are placed into a \u201cwaiting activation\u201d state. From this state, the module and its components can be promoted to an active state by administrative action.","Another situation occurs when the new module does not match expectations for a modeled element. When a new module is being installed, and that module's meta-data does not meet the requirements laid out in the current model, the module and its components are placed into a \u201cDisabled-Mismatch\u201d state. From the mismatch state, administrative action is required to either uninstall the unsuitable component, or to authorize a deviation from the planned mode (thereby creating an ad-hoc extension ability). The degree to which the module is out of alignment with the overall model will play a role in how successful a deviation authorization will be. The runtime architecture should accommodate a certain degree of deviation; as well as provide the model designer and the administrator some control over how closely elements need to match the runtime description.","Another situation occurs when the new module describes an un-modeled capability. When a new module is being installed, and that module's meta-data defines an extension to a specific target model that is controlling the run-time, the module is placed into an \u201cApproval waiting\u201d state. An administrative action can allow the new module to be moved to the \u201cwaiting activation state\u201d after a model extension is added to the runtime environment.","Process binding and inspection play an important role in embodiments of the present invention. One of the tenets of a set of software modules that are automatically configurable is that the components that make up a specific module will interact with other components via well defined, or modeled, business process interactions. In the simple case, one component interacts with another in a one to one relationship, with each component playing a role (e.g. caller and called) on a specific service request.","In another case, two components wind up interacting in a complex sequence of request\/response actions as part of a long running transaction sequence, or process. Note that each interacting component binds to a specific role on the process as described above. This binding requirement is communicated to the bus as part of the meta-data that each component provides during set-up. When the pair of components are placed into an active state, the process description from the model plays a role in the activation step. Assuming that the meta-data describing the expectations of each model matches the meta-data that defines the process in the active model, the activation can succeed, and the two modules can communicate as planned.","The benefits of this approach, binding to roles on processes instead of remote components, include uncoupling and better run-time management.","Uncoupling is achieved because the caller no longer maintains information about the location or route to partner components. A module only cares that a specific interaction is available or not. Since the process itself knows what roles are active (by tracking this via the runtime) a caller can determine if a service request can be made before blindly making the request.","Better runtime management is achieved because components are bound to process roles. If a component that is bound to a specific process role is placed into a disabled state at runtime, or perhaps uninstalled, the process may also be placed into a disabled state, depending on the description of the role in the process. Optional roles can be activated and deactivated without processes being affected.","Embodiments of the present invention also facilitate process monitoring. By going through an intermediate routing layer that actively governs a process flow, individual flows are able to be instrumented, monitored and measured without having to put monitoring and measurement logic into the individual modules. A more consistent operation monitoring environment results from this approach.","Embodiments of the present invention also increase process flexibility because individual components only know about the role they play in a process. Accordingly, the process itself can be modified (if allowed by the administrative settings on the active model) and extended with new roles without introducing breaking conditions or code-change requirements into the individual components. The approach extends itself readily to more complex processes involving more than one role, as well as other response patterns (one way, notifications, subscriptions, broadcast, asynchronous request\/response, and n-way return routes).","As described above, embodiments of the present invention generally use metadata to describe module capabilities and requirements. One of the pieces of metadata that a module or component should signal for essentially plug-and-play functionality is a list of capabilities that must be present or are optional for a given module to function. Another piece of metadata is an indication of the abilities being offered by a given component or module. Metadata also includes dependency metadata, which outlines the types of dependency metadata that needs to be provided by modules during installation. This data should be discoverable, either by a query-interface-for-dependency type interface, or by examining a shared discovery capability that reflects the various configuration states in the run-time. Embodiments of the present invention include both approaches to discovery. Types of dependency metadata that should be considered regarding this interface include document sources\/data dependencies; model version target; process presence in the active model; process role presence; process role interdependencies; and component or service presence.","Document, event and data dependencies define the types of data and document sources that must be present in order for the module or component to function properly. Whether a dependency is required or optional should also be indicated.","Another aspect of embodiments of the invention is the presumption that individual modules will be built to a specific model target\u2014that is for a given application domain model that can be used to configure embodiments of the invention, the developer of a given module will pre-build the software to an assumption that a specific version of a model must be present at run-time for the software to properly function. Model version target metadata specifies the \u201cdesired\u201d model version target for a software application or module, and should be able to specify secondary choices and preference order for binding purposes. If a particular model version is required, this should be indicated.","Process presence is the ability for a module to be developed so that during installation or at run time, it can query the model-aware bus for the status of a specific process, as defined by an identifier found in the process taxonomy. This metadata controls whether a module is able to bind to one or more process definitions. When a module or component is activated, this information is used to guide the system configuration steps. If a process presence is required or optional should be indicated.","Process-Role presence metadata specifies the process roles that the module is willing and able to take on.","Process role interdependencies metadata specifies the relationship between binding role assignments. This information allows for specifying \u201call-or-nothing\u201d binding relationships so that individual plug-and-play components are not intermixed in ways that do not make sense.","Component or service presence metadata specifies whether specific component implementations or service presence is required. This data is preferably expressed in terms of logical abilities based on contract definitions.","Metadata descriptions are one way that generic descriptions of module capabilities and requirements are provided in embodiments of the present invention. Another important function that helps facilitate generic communication between each module and the bus, as well as between different modules is the messaging layer. In order to meet the goals of essentially plug and play operation, model driven applications should work together with a common signaling approach that covers module and component communications, error management, two-phase-commit transaction management, and operations control. The message structures themselves should follow a prescriptive design so that different development teams in different geographies can develop model driven application components that behave consistently.","The following description is an illustrative example of a messaging specification in accordance with an embodiment of the present invention. The design of a message set for plug-and-play application modules connected by a model-aware bus relies on a stable core data model for the application domain and control structures. The core data model provides the common, cross-domain definition of individual application data types. The requirement for data model stability addresses the diverse nature of business applications. Individual applications are specialized, and it is usual for each application to be installed on its own set of servers. Sales offices, factories and headquarters rarely are co-located and wind up cities away.","These geographically dispersed installations not only introduce synchronization latencies and the need to continue operating when networks or servers are down, but they also introduce separate budget cycles that assure that entire systems are rarely ever updated with new versions of software at the same time.","Model designers express the core data model in a standardized manner, such as XML, by defining schema element definitions for each core concept in the application domain. These schema definitions are later used as the basis for the message domain model.","The message domain model defines the message structures that are shared between the components that make up the model-defined modules in a specific model domain. The message domain model is a collection of individual message definitions that are each preferably expressed in XML schema. Each of these schemas inherits from the model construct called moduleMessage. The moduleMessage definition provides the framework that defines the structure that is common to all domain messages. The moduleMessage definition provides the following common message abilities: control header, fidelity layering, post deployment message extension, and multipart message handling. Control header defines the elements of a message that manage identity, idempotent behavior, concurrency, data versioning, correlation, n-way conversations, and transaction involvement. Fidelity layering addresses the need to layer in area specific extensions to core elements defined for a given message or document type. This defines the approach for identifying a layered extension to a core document, identifying the core being extended, and versioning. Post deployment message extension defines how a message will support \u201cadd-a-field\u201d scenarios. Finally, multipart messages section defines how a message will be marked to signify that a specific message instance is part n of m related messages. Message parts of this type are managed by the application.","The following description provides additional details regarding messaging features that should be supported in the control elements that are present in each message. For illustration, suggested designs are represented as XML. Message control elements are grouped into a logical notion of a \u201ccontrol header\u201d. Preferably this is an XML element that is contained in the payload that is transmitted in accordance with a standard protocol such as Simple Object Access Protocol (SOAP). The reason this is in the payload rather than in a SOAP:Header is to prevent application-level control elements from being stripped from the SOAP message as most SOAP processing instances do today.","The elements defined below are preferably all contained in a common control header element named controlHeader.","<ch:controlHeader xmlns:ch=\u201curn:schemas_microsoft_com:controlHeader:vl\u201d\/>","The controlHeader has the following message elements: messageType and messageInstanceIdentity. In order to expedite the routing of messages, the control header has an overt indicator of the message type. Message type is used by the model-driven bus to identify and route the message itself. Message type information is placed in the mandatory attribute named messageType.",{"@attributes":{"id":"p-0099","num":"0098"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"329pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<ch:controlHeader xmlns:ch=\u201curn:schemas_microsoft_com:controlHeader:vl\u201d messageType=\u201cmessageURI\u201d>"},{"entry":"\u2003\u2003\u2003\u2003. . ."},{"entry":"\u2003\u2003<\/ch:controlHeader>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"MessageInstanceIdentity defines the instance of a unique \u201csend\u201d on the part of the application, and does not represent an individual transmission attempt. The application layer is responsible for assigning a unique identifier to each message. Message instance is defined in the element named messageID.",{"@attributes":{"id":"p-0101","num":"0100"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"329pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<ch:controlHeader xmlns:ch=\u201curn:schemas_microsoft_com:controlHeader:vl\u201d messageType=\u201cmessageURI\u201d>"},{"entry":"\u2003\u2003<ch:messageID"},{"entry":"\u2003\u2003context=\u201csenderContextlD\u201d>uniqueID<\/ch:MessageID"},{"entry":"\u2003\u2003>"},{"entry":"\u2003\u2003\u2003\u2003. . ."},{"entry":"\u2003\u2003<\/ch:controlHeader>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The mandatory attribute named senderContext is used to specify the sending application and\/or module context. The value in the context field should be one of the registered sender contexts known to the model-aware bus at run-time. This will normally be the module instance identifier created when a module is installed. The value in this attribute, plus the unique identifier value in the messageID element together make up a unique message instance identity.","Idempotent transmission across two partnering modules or components is enabled by the information passed in the message instance identity. At run-time, it is the responsibility of the receiving partner to be aware of the possibility of message replay so as to prevent a replay situation from causing double processing of a given message.","In order to facilitate tracing, sorting and ordering of threads of messages, it is necessary to establish some sort of ordering mechanism. The preferred mechanism is the transmission time of the original request. Transmission time stamping is a function done by the sender. The timestamp element is used to express transmission time. The granularity is preferably down to the second.",{"@attributes":{"id":"p-0105","num":"0104"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<ch:controlHeader"]},{"entry":[{},"xmlns:ch=\u201curn:schemas_microsoft_com:controlHeader:v1\u201d"]},{"entry":[{},"messageType"]},{"entry":[{},"\u2003\u2003=\u201cmessageURI\u201d>"]},{"entry":[{},"<ch:messageID"]},{"entry":[{},"context=\u201csenderContextID\u201d>uniqueID<\/ch:MessageID>"]},{"entry":[{},"<ch:timestamp instant=\u201c2003-06-13T14:21:OOZ\/>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"Reconciliation of request and response semantics is a common business activity. In order to mark a message as the direct logical descendent, the optional element named pertainsToID is provided for matching requests with responses.",{"@attributes":{"id":"p-0107","num":"0106"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<ch:controlHeader"]},{"entry":[{},"xmlns:ch=\u201curn:schemas_microsoft_com:controlHeader:v1\u201d"]},{"entry":[{},"messageType"]},{"entry":[{},"\u2003\u2003=\u201cmessageURI\u201d>"]},{"entry":[{},"\u2003\u2003<ch:messageID"]},{"entry":[{},"\u2003\u2003\u2003\u2003context=\u201cresponderContextID\u201d>uniqueID<\/ch:M"]},{"entry":[{},"\u2003\u2003essageID> <ch:timestamp instant=\u201c2003-06-"]},{"entry":[{},"\u2003\u200313T14:21:30Z\/>"]},{"entry":[{},"\u2003\u2003<ch:pertainsToID"]},{"entry":[{},"\u2003\u2003\u2003\u2003context=\u201coriginalContextID\u201d>uniqueID<\/ch:pa"]},{"entry":[{},"\u2003\u2003rentID>"]},{"entry":[{},"\u2003\u2003\u2003\u2003. . ."]},{"entry":[{},"\u2003\u2003<\/ch:controlHeader>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The example shows the control-header content of a response to an earlier request. A response message is still a message, so it has its own unique message instance identifier. Because this is a direct response, a parentID element is added to the control header. This parentID element is populated with the values originally passed in the messageID field in the request message. If a message being sent by a module is not a direct response, based on the requirements defined in the domain model, then the parentID element is not present.","Embodiments of the present invention allow entire stand-alone business software systems and\/or components thereof to be installed and managed automatically. In this sense, the installation and operation of these pieces of software can be thought of as plug-and-play. The ease of integration and operation provided by embodiments of the present invention will facilitate the acquisition and deployment of new and improved business software as such software becomes available.","Although the present invention has been described with reference to particular embodiments, workers skilled in the art will recognize that changes may be made in form and detail without departing from the spirit and scope of the invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1","b":"100"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 9","FIG. 8"],"b":["406","410"]}]},"DETDESC":[{},{}]}
