---
title: Application server platform for telecom-based applications using an actor container
abstract: In accordance with various embodiments, a set of features are described for enabling an application server platform for telecom based applications. A system for providing an application server for telecom-based applications can include a computer, including a computer readable medium and processor. The system can also include an application server, executing on the computer. The application server can include an actor container that manages and provides lifecycle and runtime properties for application classes that are executed as actors in the application server. The actor container can manages a set of event transactions, wherein all storage operations are performed as part of the event transaction that spans each event handler invocation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09553944&OS=09553944&RS=09553944
owner: ORACLE INTERNATIONAL CORPORATION
number: 09553944
owner_city: Redwood Shores
owner_country: US
publication_date: 20111228
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CLAIM OF PRIORITY","CROSS REFERENCE TO RELATED APPLICATIONS","COPYRIGHT NOTICE","FIELD OF INVENTION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","GLOSSARY"],"p":["This application claims the benefit of priority to U.S. Provisional Patent Application No. 61\/428,129, titled \u201cIMPROVED APPLICATION SERVER PLATFORM FOR TELECOM-BASED APPLICATIONS\u201d, filed on Dec. 29, 2010; and U.S. Provisional Patent Application No. 61\/432,554, titled \u201cAPPLICATION SERVER PLATFORM HAVING A DEPLOYMENT MANAGEMENT SERVICE, CONFIGURATION SERVICE, TCAP ADAPTER, SIP ADAPTER AND A JAVA MEDIA SERVER CONTROLLER\u201d, filed on Jan. 13, 2011; each of which applications are herein incorporated by reference.","The present application is related to U.S. patent application Ser. No. 13\/339,287, titled \u201cAN EVENT BROKER FOR AN IMPROVED APPLICATION SERVER PLATFORM FOR TELECOM-BASED APPLICATIONS\u201d, filed on Dec. 28, 2011, and now U.S. Pat. No. 8,788,580; and U.S. patent application Ser. No. 13\/339,300, titled \u201cIMPROVED APPLICATION SERVER PLATFORM FOR TELECOM-BASED APPLICATIONS HAVING A TCAP ADAPTER, SIP ADAPTER AND ACTOR PROTOCOL CONTEXT\u201d, filed on Dec. 28, 2011; each of which applications are herein incorporated by reference.","A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.","The current invention relates to mobile communications and in particular to providing application server platform for applications that utilize telecom-based functionality.","In today's world of telecommunications, more and more devices and functionalities are being integrated with one another in order to create new features and capabilities for the everyday user, as well as for large organizations and enterprises. Numerous examples of this can be seen in the realms of mobile devices, cellular phones and computers. Everything from electronic mail, internet access, text messaging, video and digital photography to video games, social networking and other forms entertainment, are becoming available for a wide variety of mobile devices. Countless web applications now provide services that can access or be accessed via mobile phone to enable a particular feature.","Given all of this pervasiveness, the management of software applications must expand in order to accommodate a multitude of mediums and modes of operation previously unconsidered by most developers. As a simple illustration, in order to allow an internet user of a web application to set up a conference telephone call between several end subscribers, the application must be able to interact in some meaningful way with multiple and substantially different protocols and networks. This is the general environment within which embodiments of the invention are intended to be used.","In accordance with various embodiments, a set of features are described for enabling an application server platform for telecom based applications. A system for providing an application server for telecom-based applications can include a computer, including a computer readable medium and processor. The system can also include an application server, executing on the computer. The application server can include an actor container that manages and provides lifecycle and runtime properties for application classes that are executed as actors in the application server. The actor container can manages a set of event transactions, wherein all storage operations are performed as part of the event transaction that spans each event handler invocation.","In the following description, the invention will be illustrated by way of example and not by way of limitation in the figures of the accompanying drawings. References to various embodiments in this disclosure are not necessarily to the same embodiment, and such references mean at least one. While specific implementations are discussed, it is understood that this is provided for illustrative purposes only. A person skilled in the relevant art will recognize that other components and configurations may be used without departing from the scope and spirit of the invention.","Furthermore, in certain instances, numerous specific details will be set forth to provide a thorough description of the invention. However, it will be apparent to those skilled in the art that the invention may be practiced without these specific details. In other instances, well-known features have not been described in as much detail so as not to obscure the invention.","In accordance with various embodiments, a set of features are described for enabling an application server platform for telecom based applications. The application server provides a protocol-neutral programming model for application developers. Rather than having to account for specific protocol entry points into the server, all interactions in the server are abstracted as asynchronous events through the event broker layer. State management and concurrency are implemented as an actor-based model, where each actor owns its own segment of state and other actors wishing to update that state send asynchronous events to the owner. This architecture allows multiple protocols to be consumed in one process, allow applications sessions to span multiple environments and protocols, and allows the programming model to be decoupled from any particular protocol entry point.","In accordance with an embodiment, the following terms as used herein are defined below:\n\n",{"@attributes":{"id":"p-0020","num":"0041"},"figref":["FIG. 1","FIG. 1"]},"As illustrated in , in accordance with an embodiment, the application server  can include an OSGI kernel , an application component environment , an event framework layer , an actor container , an adapter container , and a selection of server services .","The OSGI kernel provides lifecycle management, class loading, dependency resolution and deployment features for the application components on the server. In accordance with an embodiment, the application components, such as applications , , , can be basic OSGI bundles deployed on the server.","The event framework layer provides an event-based communication model between the application component environment and the adapter container. In particular, the framework layer provides an event broker that maps all protocol-specific communications exposed by the various protocol adapters , , ,  into asynchronous events, which can be consumed by the application components. Additionally, the application components can produce asynchronous events for propagation to the protocol adapters via the event broker.","The protocol adapters , , ,  enable the application server to support multiple protocols. In accordance with an embodiment, each of a plurality of various protocols, such as a session initiation protocol (SIP) , an intelligent network application part (INAP) of the SS7 protocol , a hypertext transfer protocol (HTTP) , or many other protocols , can have their own adapter. These protocol adapters then interface with the adapter container, the event framework, the actor container and the server services. The adapter container can expose a service provider interface, for use in building new protocol adapters as new protocols emerge or become more widely used.","In accordance with an embodiment, the event framework layer is used to communicate with application components. With respect to the event model, the protocol adapters are consumers and producers of asynchronous events. The SPI interfaces implemented by protocol adapters reflect the complexity relative to application components. Primarily, adapters implement efficient input and output operations (I\/O) towards a specific protocol. In addition, protocol-specific security, error handling, and abstraction can be encapsulated in adapters. The adapter container is designed to support a contract in which it cooperates with the adapters to provide connectivity to the network by the application components.","The server services act as basic building blocks for the rest of the functionality implemented on the application server. In accordance with an embodiment, these services are protocol neutral, reusable, and shared by the other layers of the stack. The set of services illustrated in  is not intended to be limiting or exhaustive, and is instead being provided for purposes of illustration. In accordance with an embodiment, various server services can be implemented as needed to address the particular needs of an application developer. For example, a clustering service can be used to maintain cluster membership\/replication, while an SLA management service can be used to keep track of service level agreement (SLA) enforcement.","Actor Container","In accordance with various embodiments, the application server platform includes an actor container that manages and provides lifecycle and runtime properties for the actors in the actor model environment of the application server. The actor container exports a number of application programming interfaces (APIs), which enable applications to have classes run as actors in this environment.","In accordance with an embodiment, the Actor Container runs as an OSGI bundle and provides a plurality of aspects to applications that are written and deployed as actors, including single-threaded event processing, isolated storage views, event transactions and store collocation.","For single threaded event processing, the Actor Container ensures that at most one thread invokes an actor's methods at any time. This means that the actor code can be simplified to assume single threading. Note that threads can be pooled, and that there need not be one thread dedicated for each actor.","The actor container provides and manages event transactions. All storage operations can be performed as part of a transaction that spans each event handler invocation. The entire transaction commits or rolls back only after the event processing completes or fails.","The actor container also implements store collocation and actor isolation. For example, the actor instance can be collocated on the same server as its store data. This reduces the amount of network traffic required to manage the store data while still being distributed and redundant. The actors can also be isolated, meaning that only the owning actor can access the actor's store data. This also means that, in some instances, at most one thread can access the actor's stores at any time.","In accordance with an embodiment, the actor container provides the ability to migrate programmable units (actors), including timer migration. While generally, actors execute on a single server in the cluster at any given time, the actor container also provides the ability to migrate actors to another machine (e.g. if a server crashes or an additional server joins the cluster). The actor store data is still available to the actor even in the event that it migrates to another cluster server.","In accordance with an embodiment, the actor container can also enable linked actors. This can be used to provide distributed environment optimization of closely related and\/or communicating actors. Actors can be created programmatically using an interface such as ActorFactory. The actor can be created anywhere in the cluster, or a hint can be provided that the container should attempt to link this actor with the actor that requests it to be created. This hint can be given when an application knows that the creating actor and the created actor are closely related, will communicate frequently with each other and would benefit greatly from optimizations on these communications.",{"@attributes":{"id":"p-0034","num":"0055"},"figref":["FIG. 2","FIG. 2"],"b":["200","202","204","206","208","212","210","212","214","216"]},"Actor Management","As noted above, the runtime management of actors is provided by the actor container. In accordance with an embodiment, the actor container can include a plurality of OSGi bundles that register an actor container service that can be used by applications to create actors running within this container.","Application Boundary","As shown in , and as viewed from the actor container, an application is defined as an OSGi bundle that implements actor classes and request creation of such actors instances using the actor container. If such an OSGi bundle imports classes from other bundles, the imported classes are considered to belong to the importing application, from the containers point of view.","Additionally, the actor container can maintain separate runtime environments for different applications. The container can define the application boundaries by using the name of the bundle that requests initial actor(s) to be created, and maintaining separate actor manager instances for each such bundle. This way the actor container can provide isolation between different applications, and recognize when the same application is starting on another server in the cluster.",{"@attributes":{"id":"p-0038","num":"0059"},"figref":["FIG. 3","FIG. 3","FIG. 3"],"b":["300","302","304"]},"As shown in , where there are two application bundles, one of these applications can import one or more classes from the second bundle, and these imported classes can be used to declare an actor to be created in both of these application bundles. For example, Actor4, corresponding to Class4, is created by both BundleA and BundleB. In this case, the actor container will see these as two applications, even though the second bundle uses the same classes as the first bundle.",{"@attributes":{"id":"p-0040","num":"0061"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Listing 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"BundleA 302 is one application bundle"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"BundleA includes Class 1 306 and Class 2 308"]},{"entry":[{},"BundleA imports 310 Class 3 312 and Class 4 314 from BundleB"]},{"entry":[{},"BundleA creates two actors Actor1 316 (of Class 1) and Actor4 318"]},{"entry":[{},"(of Class 4)"]},{"entry":[{},"BundleA actors are managed by actor manager \u201cBundleA\u201d 320"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"BundleB 304 is another application bundle"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"BundleB includes Class 3 and Class 4"]},{"entry":[{},"BundleB creates two actors ActorS 322 (of Class 3) and Actor4 324"]},{"entry":[{},"(of Class 4)"]},{"entry":[{},"BundleB actors are managed by actor manager \u201cBundleB\u201d 326"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"In accordance with an embodiment, the actor container provides a runtime environment and API interfaces for application code, that gives application classes and the services exposed through the APIs in its context runtime properties associated with the actor model.","The runtime properties defined as actor model properties by the OCCAS actor container can include, but are not limited to, one or more properties, as described herein. For example, the runtime properties can include that any code classified as actor code is executed by at most one thread at a time (single-threaded), and that any method invoked on actor code (lifecycle and event handlers), which is bracketed in a transaction. Additionally, the actor can run on one server in the cluster at any time, but may move between servers during its life, e.g. if a server crashes (failover) or an additional server joins the cluster (migration). Further, the actor can have its own isolated view of the storage service, i.e. it can not access other actors store data, and the actor code is collocated on the same server as all actor store data it reads and writes. The actor store data can be made available to the actor even if it fails over or migrates to another cluster server.","In accordance with an embodiment, in order for the application classes to be classified as actor classes, and thereby gain the above-mentioned actor runtime properties, they must satisfy at least one condition. These conditions can include that the class implements the Actor interface and is instantiated by the actor container and only referenced by the container; that the class implements the EventHandler interface and referenced only by the actor or event registrations done by the actor that instantiated the handler; and\/or that the class is instantiated AND referenced only by the instantiating actor.","In accordance with an embodiment, in order to break the above rules, a class must either have an explicit staticcode, or register its object reference in a staticfield shared between classes. No such references are exposed through the actor container.","In accordance with an embodiment, communication between different actors and protocol adapters can be performed using events (using ActorEventBroker for timers and protocol events or EventChannel for actor-to-actor events). Although there is no protection from actors invoking Java methods on classes outside of the actor, this approach should be avoided since it would introduce multi threading in that class, and potentially introduce concurrent access errors and deadlock risks to the actor code.","As long as the actor rules are satisfied, all actor code paths, including life-cycle methods and event handlers participate in the single threaded guarantee of the actor. Therefore, all methods of the Actor interface and EventHandlers that the actor registers through interfaces from the ActorContext are called from a single threaded actor scheduler. However, if the actor rules are broken (i.e., not satisfied), then the single-threading guarantee may not apply. For example if an actor class invokes methods on other actors by obtaining references to them through singleton or other registry references, the referenced code could get executed in different threads.","Although it is highly recommended to avoid sharing objects between different actors, this can be done as long as the shared object classes are guaranteed to be thread-safe, and it is guaranteed that no deadlocks can happen.","Declaring Initial Actors","In accordance with an embodiment, to bootstrap into the actor container, an application can declare that it expects the container to create its initial actor(s). This can be done by adding an actor.xml file in the application's bundle jar.","The application can define a set of statically declared initial actors that the application needs to bootstrap into the actor container. Note that the declared actors are instantiated once per application throughout the cluster, i.e. there will not be one copy of the actor per server. The first application instance to start in the cluster will have the declared initial actors created. If additional servers start, there will be no new instances created, since they already exist. Once the initial actors have started, these initial actors are responsible for programmatic creation of any dynamically allocated actors the application uses to operate. The initial actors will in most cases register for a subset of protocol events that in some way or another leads to programmatic creation of other actors, as described in the following sections.","Programmatic Actor Creation","In accordance with an embodiment, once the application has bootstrapped into the actor container, it can perform programmatic creation of new actors. Actors can be created programmatically created using the ActorFactory interface. The actor can be requested to be created anywhere in the cluster, or a hint can be given that the container should attempt to link this actor with the actor that requests it to be created. This hint is given when an application knows that the creating actor and the created actor are closely related, will communicate frequently with each other, and\/or would benefit greatly from optimizations on this communication.","In accordance with an embodiment, all actors are assigned a container-internal unique actor identifier that is used to e.g. isolate store state, collocation of state and\/or linked actors and correlating log entries relating to actor instances. The identifier is generated at the time of creation, and can be generated using java.util.UUID. This identifier is not known by the actor itself, it is only used by the container.","Life Cycle","As described above, lifecycle transitions are requested through the actor container, and controlled by the container. The startup lifecycle path is requested by creating an actor as described above, and shutdown is either requested by the actor itself, or originated by the container as part of default failure handling, the application owning a set of actors being undeployed or the last server in the cluster being shut down.","In accordance with an embodiment, Actor initiated shutdown of an actor is requested by the actor itself by invoking shutdown on its ActorControl interface. The actor will be able to process all events currently on the queue before being shut down, unless it times out while doing so, in which case it will be force suspended and stopped. No new events will be accepted on the queue after the actor has transitioned into the suspended state.","An important aspect of the actor life-cycle is that the actor can be instantiated and started on any server in the cluster, regardless of on which server the actor creation request was performed. Additionally the container can, after actor activation, decide to migrate the actor to another member in the cluster, normally as a reaction to a server leaving or joining the cluster, in which case the migration life-cycle path will take effect.","In accordance with an embodiment, actors are not allowed to perform actions to the outside world (e.g. publish events, register\/unregister handlers, schedule\/cancel timers or create child actors) until it reaches starting state (i.e. after start method begins to execute) or after stopping state (i.e. after returning from the stop method). The actor may have a choice to defer suspend unless the suspend is forced by the container. This can be done by invoking defer( ) on the Suspend Request parameter passed to the suspend method, and if the defer method returns true, the Actors suspend method will be invoked at a later point. If the container is force suspending the actor, e.g. after timing out doing deferred suspends, it will not allow further deferral, in which case an attempt to call the defer method will return false, and the container will continue with invoking stop( ) once the suspend method returns. If the actor returns from the suspend method without calling the defer( ) method, the container will proceed to stopping the actor.","In accordance with an embodiment, the actor will never receive events before the actor enters Running state (after actor returns from the resume method) or after entering Suspended state (after actor returns without requesting deferral from the suspend method). Listing 2 shows an exemplary lifecycle. If a lifecycle method or event processing for some reason ends up in an unhandled exception back to the container, it will progress with shutting down the actor starting with the next shutdown sequence state, given the state it was when the exception was caught. Once the stop method returns, the container will remove all state and resources associated with the actor, including actor store data, event registrations, channels and timers.",{"@attributes":{"id":"p-0057","num":"0078"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Listing 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Starting: Cleanup only, no Actor method invoked."},{"entry":"Resuming: Stop \u2212>."},{"entry":"Running (unhandled event processing exception): ForceSuspend? \u2212>"},{"entry":"Stop \u2212>."},{"entry":"Migrating: ForceSuspend? \u2212> Stop \u2212>."},{"entry":"Reviving: ForceSuspend? \u2212> Stop \u2212>."},{"entry":"Suspending: Stop \u2212>."},{"entry":"Suspending: Stop \u2212>."},{"entry":"ForceSuspending?: Stop \u2212>."},{"entry":"Stop: Cleanup only, no additional Actor method invoked."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"In accordance with an embodiment, the lifecycle of an actor follows the following transition sequences shown in Listing 3.",{"@attributes":{"id":"p-0059","num":"0080"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Listing 3"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Creation:. \u2212> (Starting) \u2212> Started \u2212> (Resuming) \u2212> Running"},{"entry":"Shutdown: Running \u2212> (Suspending) \u2212 > [(ForceSuspending?) \u2212>]"},{"entry":"Suspended \u2212> (Stopping) \u2212> Stopped \u2212>."},{"entry":"Migration:"},{"entry":"\u2003Source server: Running \u2212> (Migrating) \u2212> Migrated \u2212>."},{"entry":"\u2003Target server:. \u2212> (Reviving) \u2212> Running"},{"entry":"Failover:"},{"entry":"\u2003Source server: Running \u2212> Server crash"},{"entry":"\u2003Target server:. \u2212> (Reviving) \u2212> Running"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"In accordance with an embodiment, the actor is expected to perform particular actions for each phase shown in Listing 3. In the Starting phase, the actor should prepare for management (register MBeans, read configuration, etc.), optionally register error handler (ActorContext.setErrorHandler( )). Additionally, during this phase, the actor should not register for events and it should not publish events. In the Resuming phase, the actor should prepare to receive events (register event handlers, subscribe to channels, etc.), and the actor may publish events. In the Suspending phase, the actor should stop receiving events (unregister event handlers, cancel timers, shutdown channels, etc.). In the Stopping phase, the actor should stop handling management actions (unregister MBeans, etc.) and clean up any other resources held. In the Migrate phase, which is not invoked on server crash, only when actor moves from live server to another live server, the actor should only clean up any POJO resources it has so they can be garbage collected, and all actor store data should be kept so that it can be revived to the same state on another server in the cluster and continue processing events. Additionally, during this phase the actor should not unregister event handlers, cancel timers, close event channels, or remove its actor store content. In the Revive phase, the actor can optionally re-register error handler (ActorContext.setErrorHandler( )), and the actor should prepare for management (register M Beans, read configuration, etc.). Additionally the actor can associate new handlers with the event registrations (setHandler method), associate new handlers with the event channel ports (setHandler method), and associate new handlers with the timers (setHandler method).","The lifecycle of actors is one example of actor code that can be complicated and\/or repetitive task to implement, and can be simplified for the developer by using utility classes provided with the platform.","Actor Lifecycle Control Java API","In accordance with an embodiment, the Actor Lifecycle control Java API can include one or more features, as described herein. The Actor Lifecycle control API can include an actor interface which is implemented by application classes that marks the class as being an actor. The interface includes a lifecycle method that provides the class with references to the actor context which the actor uses to retrieve actor container services, such as event broker, etc. The Actor Lifecycle control API can also include a SuspendRequest feature, and an ActorContext, which is an actor specific context that provides the actor with instance specific container service references. The actor should use these services rather than looking up server services directly, since only the context services will provide the actor runtime properties such as single-threading, etc. It can also include a CreateActorResult feature, which is a result of a request to create another actor, and an ActorFactory, which is a factory interface for creating other actors.","In accordance with an embodiment, an ActorControl interface is provided and can be used to request the container to shut down the actor. An ActorRegistrationReceipt can provide an event registration receipt, and an ActorTimerReceipt can provide a timer scheduling receipt. A registration state holder interface is provided which can be given to an actor when revived on a new server, so the actor can associate new event handlers with protocol event registrations, timers and event channel session it previously opened.","Additionally, in accordance with an embodiment, an Actor storage interface can be used to provide an actor with access to a reduced interface to the storage service that can be retrieved from the actor store service available from the actor context. The actor stores can exclude parts of the normal Store API (e.g. locking), since they do not provide any added value to the single threaded behavior and isolated view that the actor has.","In accordance with an embodiment, each store retrieved from the actor store service is isolated from other actor's stores. This means that different actors can not exchange data through using the same store, and can not change each others data through the stores. Some of the benefits with this behavior are that actors can not alter with each others' store data. The ownership of store data is clearly defined. Additionally, actor store data can be collocated with its owning actor, without having to collocate all actors of a specific type. Further, each actor does not have to manually \u201cpartition\u201d its store data by tracking its own unique identifiers to avoid confusing other actor data with its own.","In accordance with an embodiment, the container will ensure that an actor's store data is collocated on the same server where the actor is executing, in order to optimize and reduce the number of network trips required for accesses to the actors store data. If actor store data migrates to another server in the cluster, e.g. caused by failover due to a crashed server, or rebalancing caused by a new server joining the cluster, the actor instance should also migrate to the same server. Since the actor could migrate from one server to another at any time, the actor is not pinned to the server where it initially was started. It could move to another server in the cluster at any time. Linked actors would normally move together as part of migration of actors, unless the container decides separating the linked actors is necessary for load protection. In accordance with an embodiment, linked actors are likely to be moved together as a group. Rebalancing migration of actors and their state should not impact in-flight traffic. Minimal latency increase for the duration of the migration is likely impossible to avoid, but this should be the only impact allowed.","Storage Java API","In accordance with an embodiment, the Storage Java API can include a plurality of features, as described herein. The Storage Java API can include an ActorStoreService. This service can be used to retrieve references to named and\/or typed actor stores. Each retrieved store is isolated to the owning actor instance. Additionally, an ActorStore can be provided, which is a named or typed actor store. The store is isolated to the owning actor instance. Changes made to the store are committed only after the actor returns successfully from a method.","In accordance with an embodiment, when an event arrives to an actor, the container can begin a transaction that spans the execution of the event processing in the actor. The container will collect any state changing and external communication in this transaction and commit these as one if the event processing returns successfully, or discard them all when the actor processing results in an exception to roll back the actor the state it was before the event arrived, and ensure that the actor does not cause other actors to transition to other states as a response to events from this actor. The actions that participate in the transaction can include Actor store operations, Event broker actions (which can include Publish events (both outbound and channel events), Schedule\/cancel timers, and Register\/unregister event handlers), and Actor creation\/shutdown.","Generally, there is no support for having transactions spanning execution in multiple actors. Transactions begin before executing code in an actor method, and commit\/abort only the actor's transaction actions after return\/exception from said method.","Event Communication","In accordance with an embodiment, actors communicate with other components (such as other actors or protocol adapters) using events published to the event broker through the Actor Container. Event publishing methods are found on the actor context. An actor can not assume that the destination for an event has successfully processed the event unless it receives an explicit acknowledgment from the receiver for said event. This means that if the sending actor must know the outcome of another entity's processing of the event, it should have an explicit \u201cpending\u201d state while waiting for the response, and not until it received the response transition into either \u201csuccess\u201d or \u201cfailed\u201d state (where a timeout could possibly be a reason for transition into \u201cfailed\u201d state).","Event Scheduler","In accordance with an embodiment, each actor is associated with its own actor scheduler, which is the component responsible for the single threading guarantee of actors. This event scheduler is used for all event handlers that are registered in the event broker, and ensures that all events that arrive to the actor are enqueued and executed in at most one thread at any given time. The same scheduler is used to enqueue any other operations that end up executing code in the actor, e.g. lifecycle methods, etc.","Protocol Events","Protocol events are sent through the Event Broker using a publish method found on the actor context. Receiving protocol events is accomplished by registering an event handler on a specific criteria in the actor event broker found on the actor context. See event broker for a detailed functionality description, since the actor container more or less mirror the event broker functionality.","Application Event Channels","In accordance with an embodiment, application events can be sent between actors by using channels. There are two ways of creating channels using an event factory retrieved from the actor context:\n\n","Both event channel references can be passed to other actors, so that multiple actors can send events to the channel receiver, but there can only be one subscriber to any particular channel. If a port is opened multiple times, each open will lead to different channels being opened. Note that in the case where a child actor opens a port received from a parent, only the first channel opened will be returned to the parent through the holder interface, subsequently opened channels will have to be forwarded manually to any other actor that wants to use it.","In accordance with an embodiment, when an event channel is opened, the open method returns a session object which should be kept so that the actor can close the channel (unsubscribe its handler) when it no longer is interested in events from this channel. Closing the channel will cause any future attempts to publish to the channel to fail. The event channel feature can be considered an abstraction on top of the event broker, which uses application events and application event registrations to register for and publish events.","Timer Events","Timer events are scheduled through the Event Broker using either the one time or recurring schedule method found on the actor context.","Event Java API","In accordance with an embodiment, the Event Java API can include a plurality of features, as described herein. In accordance with an embodiment, the Event Java API can include a PublishEventException, which is an exception indicating that publishing an event failed. The event can be retrieved from the exception.","An ActorEventBroker is provided, which is the actor view of the event broker service. This interface must be used for all protocol events and timers to achieve the single threading guarantee of the actor model.","An EventChannelFactory is also provided, which is a factory that can be used to create event channel ports and open event channels. An EventChannelPort, which represents a template for a channel that will be opened at a later point, typically by another actor as part of the creation process, is also provided. Additionally, an EventChannelSession which represents an open channel subscription can be provided. The event channel session can be used to close and unsubscribe from the channel or associate a new handler with the channel.","In accordance with an embodiment, an event channel is used to publish events to a single subscriber that previously opened the channel using the event channel factory. An event channel holder interface is returned from a create actor request. This interface is used by the creating actor to look up event channels that the created actor has opened, using the port specified by the creating actor as a key.","In accordance with an embodiment, an ActorErrorHandler is provided, which is an error handler that the actor optionally registers with the container in order to receive notifications of errors occurring during the commit phase, i.e. after the actor code has returned. An ActorErrorEvent is an error event optionally received by the actors error handler. The error events can include an ActorEventFailed Event, which is an error event indicating that processing of an event failed. Holds the event that was being processed when the failure occurred. The error events can also include an ActorLifecycleFailedEvent which is an error event indicating that a lifecycle method failed to commit.","In accordance with an embodiment, the Event Java API can also include an Actor Protocol Extension feature. Error handling, via a ProtocolExtension.onActorError, is triggered before any notification to the actor code (if there is a handler registered), and the extension is given a choice to either handle the error and hide it from the actor, or return the same or a new error event to be forwarded to the optional actor error handler. If the extension returns an error and no actor error handler is registered, the default error handling will be performed by the container.","A protocol extension lifecycle similar to the actors lifecycle can be provided, wherein the extensions lifecycle methods are invoked before the actors on starting path and after on stopping path. The suspend method allows the extension to perform processing before giving an asynchronous response back to the container to indicate that it is ready for transition into the suspended state. If the extension does not respond that it completed suspending within a reasonable time, the suspending state will timeout and the extension is invoked to force suspend and then stop.","APE Java API","In accordance with an embodiment, the APE Java API can include a plurality of features, as described herein. The APE API can include a ProtocolExtension base class, which is implemented by a protocol adapter that has to keep state relating to actor events.","In accordance with an embodiment, the actor container does not communicate externally directly. External connectivity can be provided using distributed caches in the storage service, which in turn communicate throughout the cluster, through the use of Oracle Coherence for distributed caching. It also provides mechanisms for actors to send and receive events that may be targeted for other servers in the cluster, by exposing APIs that maps to the Event Broker component. The actor container maintains information about actors and their state in caches. The information kept is used to restore actor instances to the state they were in before a server crash. When the actor container detects a server crash, all the actors that were running on that server are instantiated on other servers in the cluster and brought to running state by invoking the revive lifecycle method with event registrations, timers and event channels that were open before the crash. When the revive method is invoked, the actor must associate new event handlers for these and continue handling traffic. This causes the actor container to re-register the event and timer handlers with the event broker on the local server. This is important because the event broker drops event registrations and timers performed on a JVM when the JVM shuts down or crashes, as they are of no use to the event broker without the event handler.","In accordance with an embodiment, when failover occurs, the actor container re-registers all of its timers with the event broker as the event broker does not inherently support migration of timers. The actor framework stores persistently, among other things, information about timer registrations persistently (in ActorAppTimerReceipt). This information can include delay information, the initial delay from timer was scheduled until it should fire, as passed to ActorEventBroker? API, and period information, set to >0 to indicate a recurring timer. The timer will fire at recurring intervals as per the ActorEventBroker? API. Additionally, schedule information (origTimeSchedule), the time for which the timer was scheduled, can also be stored persistently. When a timer is migrated, the timer is rescheduled. Depending on the circumstances of the migration, different algorithms can be used to compute the reschedule time. For example, an algorithm for computing reschedule time on new node is shown below:","Case 1: One-Shot Timer Scheduled Through ActorEventBroker Method","In this case, it is determined whether the timer has expired, i.e. origTimeScheduled+delay<now. If true, the new timer can be scheduled with delay 0, otherwise it is scheduled for the remaining period (origTimeScheduled+delay)\u2212now. In this case, there is very little risk of \u201cforgetting\u201d to schedule the timer since it is stored persistently. There is also little chance of scheduling it twice, as if the timer was already scheduled, it would have been removed\u2014consistency depends on transaction commit atomicity.","Case 2: Periodic Timers Scheduled Through ActorEventBroker Method","In the case of periodic timers it becomes trickier to figure out whether the correct number of timer event handler invocations has been performed since this cannot be based purely on the existence of the timer. A persistent counter can be updated for the number of timer invocations for each timer invocation to solve this consistently. Alternatively, a more approximate approach can be used in which the time window when migration happens is shortened. If the initial interval has not expired (origTimeScheduled+delay<=now), then the timer can be scheduled with delay=(origTimeScheduled+delay)\u2212now and the specified period. Otherwise, it can be assumed that the timer has already fired before migration (ignoring any time it may have taken to do the failover), and the timer can be scheduled to fire with a delay equal to the next time a periodic timer should occur in absolute terms, using origTimeScheduled, delay, and period for calculation.","Reducing failover window for lost timers can be provided through adjusting interval for cluster heartbeat, through parameter heartbeat-milliseconds, which has an allowed range from 100 ms to 1 minute and a default value of one second. Another improvement to failover time can be provided by adjusting the tcp-ring-listener maximum-socket-closed-exceptions",{"@attributes":{"id":"p-0090","num":"0113"},"figref":["FIG. 4","FIG. 4"],"b":["400","402","404","406","408","410","412","414","416","418","420","422"]},"Error Handling","As described above, error handling is managed by the Actor Container. The following features are provided by the actor container.","Actor Transactions","In accordance with an embodiment, if an actor throws an exception from an event processing or lifecycle method or an actor transaction fails to commit the changes an actor has requested, the actor can either be forced shut down or an attempt can be made to roll back the transaction while keeping the actor alive. The error handling option can be specified per actor class in actor.xml. The default behavior is to roll back for bootstrap actors and to shut down for all other actors, unless explicitly overridden in actor.xml.","Overload Protection","Overload protection in the actor container can include placing limits on queue and thread pool size. Table 1 shows a plurality of limits which can be set by default to protect from overload, in accordance with an embodiment.",{"@attributes":{"id":"p-0094","num":"0117"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Actor event\/lifecycle work","0 . . . 1 threads per actor"]},{"entry":["manager thread pool",{}]},{"entry":["Actor event\/lifecycle work","A maximum of 10 (normal actor) or 100"]},{"entry":["manager queue","(boots trap actor) pending events"]},{"entry":[{},"(configurable per actor class in actor.xml)"]},{"entry":["Actor timer work manager","0 . . . 1 threads per actor"]},{"entry":["thread pool",{}]},{"entry":["Actor timer work manager","A maximum of 10 pending events"]},{"entry":["queue","(configurable per actor class in actor.xml)"]},{"entry":["Shared work manager","Max 100 threads"]},{"entry":["thread pool",{}]},{"entry":["Shared work manager ","Max ~65 k entries"]},{"entry":["queue",{}]},{"entry":["Coherence actor cache","100 threads"]},{"entry":["service",{}]},{"entry":["Coherence task timeout","Default Coherence task timeout (65"]},{"entry":[{},"seconds in production mode)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"Storage service usage: In accordance with an embodiment, the actor container can use internal functions of the storage service, Coherence storage provider and even the Coherence bundle directly. The container can use three groups of stores\/caches, and within each group there can be multiple stores\/caches.\n\n","In accordance with various embodiments, the application server platform provides individual stages organized by start level. In case of failure, a trigger is initiated to roll back to previous stable state.","The administrative piece of the application server cluster is the administration console that is used to manage the cluster (e.g. deploy bundles and managed servers). The administration console can be completely stateless and can be launched from any location at any time. In accordance with an embodiment, only one admin console can perform a configuration change at a time.",{"@attributes":{"id":"p-0098","num":"0126"},"figref":"FIG. 5","b":["500","502","504","506","508"]},"Domain handling is controlled by the Domain Service . The domain service reads and writes information from and to the domain. Information means, in this context, the bundles to be deployed, the configuration and properties for these bundles and any properties for the domain itself. The Domain Service hides the actual structure of the domain on the disk to the services using it. As shown in , this component is available as part of the admin console. In accordance with an embodiment, the domain service provides the ability to read and write data to the domain. The domain service is operable to read, write and\/or remove bundles from the domain. It is further operable to read and\/or write bundle properties and resources to the domain, as well as list available bundles in the domain. As shown in , the domain service is used by the configuration service and the deployment service in the admin console. In accordance with an embodiment, the system can be limited such that the domain service is the only service allowed to read or write to the domain.",{"@attributes":{"id":"p-0100","num":"0128"},"figref":["FIG. 6","FIG. 6"],"b":["600","602","604","606","608"]},"In accordance with an embodiment, the provisioning zip file can be used by the managed servers at startup to determine which bundles to install and\/or start, and in which order those bundles should be installed and\/or started. In addition, the provisioning zip file can include properties for the platform. In accordance with an embodiment, this file is stored in a location accessible by all of the managed servers, such as a shared file system or hosted on a separate server. The provisioning zip file is read only by the Provisioning Service. Additionally, the Admin Console can manipulate the content of this file using the Domain Service. The configuration for each bundle can be stored in the bundle itself (e.g. in a configuration file such as config.xml or config.xsd). Also, properties for each bundle can be stored in the provisioning zip file (e.g. start level, status, etc.).","The admin console can be used to create the provisioning zip file based on the modules available in the domain and a set of default properties. The modules available in the domain can be used to create a list of bundles, and domain properties (e.g. list of managed servers, ADMIN\/RUNNING level) can be determined from the set of default properties. At runtime, the Domain Service can write new bundles to the domain.","The Provisioning Service can perform one or more of the following tasks. The provisioning service can read the content of the initial.zip file. It can store each entry of type \u201ctext\u201d or \u201cbinary\u201d in a Provisioning Dictionary . Additionally, it can install  each entry of type \u201cbundle\u201d or \u201cbundle-ref\u201d in the platform. In accordance with an embodiment, the entry \u201cprovisioning.start.bundle\u201d indicates which bundle should be started (usually, it is the Management Agent).","The Management Agent is responsible for transitioning the framework through the start levels. It is also the contact point for Remote Management (via the admin console). The Management Agent can execute the following operations based on information provided by the Provisioning Dictionary. The management agent can assign a start level to each bundle as specified in the entry \u201cbundles.properties\u201d. The management agent can also transition to ADMIN, shutdown on error (listen for OSGi FW error events), transition to RUNNING, and\/or go to ADMIN on error. In addition, the Management Agent can be used to graceful suspend (ServerLifecycleListener), allow a server to be started in admin, and expose Mbeans for start\/stop\/admin\/running transitions.","Managed Server Startup Sequence",{"@attributes":{"id":"p-0105","num":"0133"},"figref":"FIG. 7","b":["700","702","704","706","708","710"]},"Throughout the various contexts described in this disclosure, the embodiments of the invention further encompass computer apparatus, computing systems and machine-readable media configured to carry out the foregoing systems and methods. In addition to an embodiment consisting of specifically designed integrated circuits or other electronics, the present invention may be conveniently implemented using a conventional general purpose or a specialized digital computer or microprocessor programmed according to the teachings of the present disclosure, as will be apparent to those skilled in the computer art.","Appropriate software coding can readily be prepared by skilled programmers based on the teachings of the present disclosure, as will be apparent to those skilled in the software art. The invention may also be implemented by the preparation of application specific integrated circuits or by interconnecting an appropriate network of conventional component circuits, as will be readily apparent to those skilled in the art.","The various embodiments include a computer program product which is a storage medium (media) having instructions stored thereon\/in which can be used to program a general purpose or specialized computing processor(s)\/device(s) to perform any of the features presented herein. The storage medium can include, but is not limited to, one or more of the following: any type of physical media including floppy disks, optical discs, DVDs, CD-ROMs, microdrives, magneto-optical disks, holographic storage, ROMs, RAMs, PRAMS, EPROMs, EEPROMs, DRAMs, VRAMs, flash memory devices, magnetic or optical cards, nanosystems (including molecular memory ICs); paper or paper-based media; and any type of media or device suitable for storing instructions and\/or information. The computer program product can be transmitted in whole or in parts and over one or more public and\/or private networks wherein the transmission includes instructions which can be used by one or more processors to perform any of the features presented herein. The transmission may include a plurality of separate transmissions. In accordance with certain embodiments, however, the computer storage medium containing the instructions is non-transitory (i.e. not in the process of being transmitted) but rather is persisted on a physical device.","The foregoing description of the preferred embodiments of the present invention has been provided for purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations can be apparent to the practitioner skilled in the art. Embodiments were chosen and described in order to best explain the principles of the invention and its practical application, thereby enabling others skilled in the relevant art to understand the invention. It is intended that the scope of the invention be defined by the following claims and their equivalents."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
