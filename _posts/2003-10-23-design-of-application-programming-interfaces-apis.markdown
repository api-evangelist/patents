---
title: Design of application programming interfaces (APIs)
abstract: A first exemplary method implementation for designing an application programming interface (API) includes: preparing multiple code samples for a core scenario, each respective code sample of the multiple code samples corresponding to a respective programming language of multiple programming languages; and deriving the API from the core scenario responsive to the multiple code samples. A second exemplary method for designing an API includes: selecting a core scenario for a feature area; writing at least one code sample for the core scenario; and deriving an API for the core scenario responsive to the at least one code sample. A third exemplary method for designing an API includes: deriving an API for a scenario responsive to at least one code sample written with regard to the scenario; performing one or more usability studies on the API utilizing multiple developers; and revising the API based on the one or more usability studies.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07430732&OS=07430732&RS=07430732
owner: Microsoft Corporation
number: 07430732
owner_city: Redmond
owner_country: US
publication_date: 20031023
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This disclosure relates in general to application programming interfaces (APIs) and in particular, by way of example but not limitation, to designing APIs that are easy to use while simultaneously providing control and flexibility.","Application programming interfaces (APIs) are used by developers to create a wide variety of applications and programs. Developers range from office workers recording macros to low-level device driver authors. These developers rely on different languages and\/or different frameworks of differing complexities while programming with different skill sets and\/or for different purposes. Traditionally, different APIs have been designed to target different individual levels of skill and different demands for control (e.g., based on different relevant scenarios).","Although this approach can be successful in providing APIs that are optimized for a specific developer, it has significant drawbacks. For example, the multiple framework approach creates situations where developers have difficulty transferring knowledge from one skill level and scenario type to another. When there is a need for them to implement a scenario using a different framework, developers hit a very steep learning curve. And not only is the learning curve very steep, but it generally requires that the code written to a first lower-skill-level framework has to be rewritten from scratch to a second higher-skill-level framework. Moreover, the creation of separate frameworks for different developer skill levels typically results in a situation in which APIs that are targeted for or implemented by one level of developer are unusable by another level of developer.",{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 1","b":"101"},"In this traditional approach, relatively separate and disparate APIs are designed and employed as part of each framework. A steep but relatively short learning curve is traversed to enable API usage for the first framework at the relatively lower skill level and control capability. Because of the separate and disparate nature of the two API frameworks, the experience with the first framework contributes little if any knowledge toward learning the second API of the second framework. Consequently, an equally steep but even taller learning curve is traversed to enable API usage for the second framework.","In other words, learning an API of the first framework does not provide a stepping stone to learning an API of the second framework. The regressive nature of this disjointed set of API frameworks is indicated by the continuity gap. A developer who has learned the API of the first framework is no closer to learning the API of the second framework and must therefore start with the basics of the second framework.","Another problem with traditional frameworks is that they tend to have an overall poor usability in any case. In general, object oriented design\/development (OOD) methodologies (e.g. unified modeling language (UML)) are \u201coptimized\u201d for maintainability of the resulting design and not for usability of the resulting frameworks. OOD methodologies are better suited for internal architecture designs and less suited for designs of an API layer of a large reusable library. For example, poor usability can result from OOD methodologies that focus only on distillation to a lowest fundamental block and\/or that have an unwavering allegiance to a strict inheritance hierarchy throughout an API design.","Accordingly, there is a need for schemes and\/or techniques that can at least ameliorate the regressive continuity gap of a traditional API learning curve and\/or that can deliver better overall API usability.","In a first exemplary method implementation, a method for designing an application programming interface (API) includes: preparing multiple code samples for a core scenario, each respective code sample of the multiple code samples corresponding to a respective programming language of multiple programming languages; and deriving the API from the core scenario responsive to the multiple code samples. In a second exemplary method implementation, a method for designing an API includes: selecting a core scenario for a feature area; writing at least one code sample for the core scenario; and deriving an API for the core scenario responsive to the at least one code sample. In a third exemplary method implementation, a method for designing an API includes: deriving an API for a scenario responsive to at least one code sample written with regard to the scenario; performing one or more usability studies on the API utilizing multiple developers; and revising the API based on the one or more usability studies.","Other method, system, approach, apparatus, device, media, API, procedure, arrangement, etc. implementations are described herein.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 2","b":"200"},"A progressive API learning curve is shown rising from a point of lower required skills and concomitant control capability in a relatively smooth manner through the areas for the high and low levels of abstraction to a point of higher required skills and concomitant control capability. The progressive API learning curve exhibits a continuity zone between the areas of the high level of abstraction and the low level of abstraction. An integrated API framework enables a gradual learning curve. Because of the integrated nature of the API framework, experience with the high level of abstraction contributes to knowledge toward learning API usage for the low level of abstraction as well as for scenarios demanding greater control.","In other words, learning the API for higher levels of abstraction provides a stepping stone to learning and\/or extending the API into lower levels of abstraction. This is indicated by the two-layer (API) framework shape encompassing both the high and the low level of abstraction areas. The progressive nature of certain APIs, as described herein below, enable developers to use simple APIs initially and to gradually (and partially) begin using more complicated API components. Thus, developers who have learned the APIs targeting the higher levels of abstraction can move to using the APIs targeting the lower levels of abstraction as their experience warrants and\/or as the complexity of the scenarios that they are facing demand.","A progressive API can be easily usable (especially during early learning phases) and highly powerful (especially as the API is explored over time). A usable API may include one or more of the following exemplary attributes: a small number of concepts and\/or classes are required to get started, a few lines of code can implement simple scenarios, classes\/methods have intuitive names, a natural and\/or obvious starting point is apparent, and there is a clear (e.g., discoverable) progression to additional required and\/or relevant concepts\/classes.","A progressive API can also enable an incremental advancement from developing at a point of lower difficulty and concomitant control capability to a point of higher difficulty and concomitant control capability. Exemplary paradigms for designing progressive APIs, as well as generally highly usable APIs, are described herein below.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 3","b":["300","300","302","308","302","304","306","308"]},"When designing a given API, the design principles and practices for any one or more of the indicated categories - may be employed. Furthermore, within any given category -, one or more of the illustrated design principles and practices may be implemented. In other words, neither every category nor every design principle and practice thereof need be employed or implemented for a given API design.","Scenario driven design category  illustrates four exemplary design principles and practices. Firstly, core scenarios for selected features or technological areas are defined. Secondly, code samples corresponding to the core scenarios are written first, and the API is designed responsive thereto second. Thirdly, a progressive API, as introduced above and described further herein below, is designed. Fourthly, utilizing the defined core scenarios is made easy while utilizing other scenarios is made possible. Scenario driven design  is described further below in the section entitled \u201cScenario Driven Design\u201d.","Component oriented design category  illustrates three exemplary design principles and practices. Firstly, aggregate components (ACs) are created. Generally, aggregate components are directed toward core scenarios, are relatively simple and easy to use, and are built on top of factored types (FTs). Factored types are more fundamental and are decomposed to lower logical levels. This results in a two-layer API design. Secondly, these aggregate components are interrelated with the factored types. Thirdly, a create-set-call usage pattern is supported, especially for aggregate components. Component oriented design  is described further below in the section entitled \u201cComponent Oriented Design\u201d.","Customizable defaults category  illustrates two exemplary design principles and practices. Firstly, required initializations to use at least aggregate components are reduced. Defaults are used to reduce required initializations. Secondly, defaults are selected that are appropriate for the defined core scenarios. Customizable defaults  is described further below in the section entitled \u201cCustomizable Defaults\u201d.","Self documenting object model category  illustrates four exemplary design principles and practices. Firstly, simple and intuitive names are reserved for core scenarios. Secondly, names are selected based on the intended use or purpose of the component type, instead of a hidebound adherence to the inheritance hierarchy. Thirdly, actionable exceptions are thrown so that a developer receives instructions indicating how to fix an error from the exception message. Fourthly, clean namespaces are produced by placing types that are rarely used into sub-namespaces to avoid cluttering the main namespaces. Self documenting object model  is described further below in the section entitled \u201cSelf Documenting Object Model\u201d.","Scenario Driven Design","In a described implementation, API specifications are driven by scenarios. Accordingly, API designers first write the code that the users of the API will have to write in core (e.g., main) scenarios. API designers then design an object model to support these code samples. This approach contrasts with starting a design of an object model (using various design methodologies) and then writing code samples based on the resulting API.","In other words, especially for public API design, API designers start with a list of scenarios for each feature or technology area and code samples therefor and produce a header-style object model description based thereon. Examples of feature areas include: file I\/O, networking, messaging, console, diagnostics, database access, web pages, graphical user interface (GUI) programming, and so forth.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 4","b":["400","402"]},"At block , code samples for a core scenario are written in multiple (e.g., two or more) languages. For example, code samples associated with a selected core scenario may be written in three different languages. The code samples may implement the current selected core scenario in the three languages. Such languages include, for example, VB, C#, MC++, a markup language, and so forth; however, other languages may also be used. As indicated by the asterisk, it should be understood that a code sample (or even more than one code sample) may be written for the core scenario in a single language when designing a usable and powerful API for a single language.","Writing code samples in multiple languages may be performed because sometimes code written in different languages differs significantly. In a described implementation, the code samples for the current selected core scenario are written using different coding styles that are common among users of the particular language (e.g., using language-specific features or traits, using the practices\/habits of developers, etc.) in which a particular code sample is written. For example, the samples may be written using language-specific casing. For instance, VB is case-insensitive, so code samples written in VB reflect that variability. Code samples written in C#, on the other hand, follow the standard casing therefor.","Another example relates to a statement called \u201cusing\u201d, which C# supports. For instance, the \u201cusing\u201d call encapsulates a try\/finally block. However, VB does not support this feature, and writing code samples can indicate that utilizing this feature in a try\/finally statement is awkward for VB users. Yet another example relates to assignments in a conditional clause, which C# supports. In a file I\/O instance: \u201cif ((text=reader.ReadLine( ) !=null)\u201d works in C#. However, the assignment statement cannot be used within the \u201cif\u201d clause in VB; instead, the code is broken into multiple statements. Still yet another example relates to the tendency of C# developers to utilize parameterized constructors while VB developers usually do not. For instance, a C# coding may be \u201cMyClass x=new MyClass(\u201cvalue\u201d)\u201d while a corresponding VB coding is \u201cDim\u00d7As MyClass\u201d and \u201cx.Property=\u201cvalue\u201d.\u201d","At block , an API is derived from the current core scenario responsive to the code samples written in the multiple languages. For example, factors gleaned from the code samples written in each of the multiple languages may be incorporated into the API. Such factors may include similarities across the different code samples, differences between\/among two or more code samples, and so forth. Such factors, as well as other aspects of blocks  and , are described further below with reference to .","Similarly, when designing an API for a single language, the API is derived from the current core scenario responsive to the code sample(s) written in the single language. Thus, factors gleaned from the code sample(s) written in the single language may be incorporated into the API. As an additional API design factor example for single or multiple language situations, an API design factor may include compatibility with tools that are oriented toward the language or languages for which the code sample(s) are written.","At block , it is determined if the API is too complex. For example, the API may be reviewed by the API designer(s) to determine if the API is or is not too complex. In other words, an initial check may be performed to consider whether the API can be used without significant understanding of multiple other specific APIs, without undue experimentation, and so forth. Such an initial check may also verify that the derived API is actually workable in the current core scenario in every relevant language. If the API is too complex, then the API is refined by the designers with reference to the current core scenario and responsive  to the code samples written in the multiple languages at block .","If, on the other hand, it is determined that the API is not too complex (at block ), then at block  usability studies with typical developers are performed. For example, one or more usability studies may be performed using a development environment akin to that which the typical developer normally uses. Such a normal development environment likely includes intellisense, editors, language, and a documentation set that is most widely used by the targeted developer group.","Usability Studies","Usability studies that target a wide range of developers facilitate scenario-driven design, especially when designing general public APIs. The code samples written by the API designer(s) for the core scenarios probably appear simple to them, but the code samples might not be equally simple to certain groups of developers that are in fact targeted (e.g., especially novice and\/or occasional developers). Additionally, the understanding, which is garnered through usability studies, regarding the manner in which developers approach each core scenario can provide powerful insight into the design of the API and how well it meets the needs of all of the targeted developers.","Generally, usability studies may be conducted early in the product cycle and again after any major redesign of the object model. Although this is a costly design practice, it can actually save resources in the long run. The cost of fixing an unusable or merely defective API without introducing breaking changes is enormous.","At block , it is ascertained whether typical developers are able to use the API without significant problem(s). For example, most subjects should be able to write code for the current selected scenario without major problems. If they cannot, the API is revised (as described below with reference to block ).","The interpretation of significant\/major problems hinges on a desired level of usability for a given targeted developer group. For example, frequent and\/or extensive reference to detailed API documentation for the current core scenario by test subjects may constitute significant problems. Generally, if the majority of test developers cannot implement the current core scenario, or if the approach they take is significantly different from what was expected, the API should be evaluated for possible revisions (up to and including a full redesign).","If it is ascertained that typical developers are unable to use the API without major problems (at block ), then at block  the API is revised based on lessons from the usability studies. For example, a default may be changed, another property may be added, one or more attributes may be exposed instead of encapsulated, and so forth.","If, on the other hand, it is ascertained that typical developers are able to use the API without major problems (at block ), then at block  the process is repeated for each core scenario. For example, another core scenario of the selected core scenarios for the given feature becomes the current core scenario for which code samples are written (at block ). Another exemplary technique for designing APIs, which focuses more on two-layer API design, is described further below in conjunction with .",{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 5","FIG. 4"],"b":["404","406","404","406","502","1","502","2","502","3","502","1","2","3","502","1","2","3","502"]},"In a described implementation, factors  are gleaned from code samples (, , ) that are written in each of the three languages. These factors  are incorporated into the API . Specifically, API  is designed to support the three code samples (, , ) that are written in the three respective corresponding languages. However, it should be understood that factors  may also be applicable to single-language implementations. Some exemplary factors  are described above with reference to blocks  and  of , and other exemplary factors  are indicated in block diagram \/ of . Such factors  include language-specific mandates that are revealed by a review of code samples (, , ). An example of a language-specific constraint is described with regard to the following sample line of code: \u201cFoo f=new Foo( );\u201d. A progressive API that is designed to support this sample line has to include a default constructor; otherwise, the code sample does not compile correctly. Factors  also include developer expectations that are inspired by both language peculiarities and the different skill\/experience levels of typical developers that naturally gravitate toward the different languages. Factors  further include commonalities of code and coding practices across the different languages as discoverable by a review of code samples (, , ).","While considering factors  that directly relate to different languages, other factors , as described herein, continue to be considered. For example, the following factors  are also pertinent to progressive APIs targeted to single-language environments as well as multiple-language environments. First, the number of different component types that are required to complete a scenario is a factor. Generally, the more component types that are required, the harder it is to learn. A second factor is the connection between succeeding lines of code. To the extent that usage of one component type leads a developer towards usage of the next required component type, the easier the API is to use.","Third, consistency in the naming of identifiers is another factor. A fourth factor involves the appropriate usage of properties, methods, and events. A fifth factor relates to possible similarities to one or more existing APIs. Sixth, another factor involves compliance with overall design guidelines for an API. A seventh factor relates to whether the APIs overlap with other component types of the framework. Eighth, compatibility with tools that are oriented toward a particular language is yet another factor. For instance, VB developers typically want parameter-less constructors and property setters. Other factors  may alternatively be considered.","Still other factors  that relate to interrelationships of aggregate components and factored types are described below, especially with reference to . Although the method and scheme of  may be applied to designing APIs in general, they are particularly applicable to designing two-layer APIs. A two-layer API paradigm (e.g., with aggregate components and factored types) is described below with reference to  in the section entitled \u201cComponent Oriented Design\u201d.","Component Oriented Design",{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 6","b":["602","600","600","602","600"]},"Generally, component types  that are illustrated as being relatively larger represent types that are simpler and therefore easier to use. Conversely, component types  that are illustrated as being relatively smaller represent types that are more complex and therefore more difficult to use. Simple and complex in this context refer to how easy or how difficult the particular component types  are to use when implementing a specified scenario.","The component types  that are illustrated as being relatively smaller are generally more difficult to use for a number of exemplary reasons as follows: First, developers have more choices as to which component types  they should use. In the illustrated example, there are 14 \u201cchoices\u201d for the smaller component types  as compared to three \u201cchoices\u201d for the larger component types . More specifically, a developer has to know or discern, from among the various component types (HC), which component type or types to use. This involves understanding each of the (e.g., 14) multiple component types (HC) as well as how they interrelate, which contrasts with starting with a single component type (HU) from among the fewer (e.g., 3) component types (HU). Differences between component types (HU) and component types (HC) are described further below.","By way of an exemplary analogy, the smaller component types  are like the individual components of a stereo system; hence, a user has to know which components are needed and how to hook them together. Without hooking them together, they are generally not useful. The larger component types  are like all-in-one stereos that are easily usable but likely to be less powerful as well as less flexible. A second reason that smaller component types  are harder to use is that there are potentially more \u201cstarting points\u201d. Third, there are generally more concepts to understand. Fourth, a developer has to understand how individual components types  relate to other component types .","In a described implementation, component types  are divided into those with a high usability purpose (HU) and those with a high controllability purpose (HC). High usability component types (HU) are simpler and easier to use, but they tend to be more inflexible, limiting, and\/or constraining. They can generally be used without extensive knowledge of an overall API. High usability component types (HU) are usually capable of implementing a limited number of scenarios or at most a limited number of approaches to each scenario of interest.","High controllability component types (HC), on the other hand, are complex to use, but they provide a greater degree of control to developers. They are relatively powerful and enable developers to effectuate low-level tweaking and tuning. However, developing with high controllability component types (HC) entails a fuller understanding of many component types  to enable the instantiation of multiple high controllability component types (HC) that are correctly interlinked to implement even relatively straight-forward scenarios.","Typically, high usability component types (HU) are present in introductory languages such as VB, and high controllability component types (HC) are present in advanced professional-programmer-type languages such as C++. The potential disparity between high usability component types (HU) and high controllability component types (HC) that is illustrated in  is at least partly ameliorated by component types  of . Specifically, an interrelationship between high usability component types (HU) and high controllability component types (HC) is established by a progressive API.",{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 7","b":["702","700","702","702","702"]},"A key  indicates that a solid line represents a relationship for exposed factored types and that a dashed line represents a relationship for encapsulated factored types. As illustrated, aggregate component (AC)() has a relationship with three factored types (FT). Specifically, factored type (FT)() has an exposed factored type relationship with aggregate component (AC)(), and factored types (FT)() and (FT)() have an encapsulated factored type relationship with aggregate component (AC)().","Although not so illustrated, two or more aggregate components (AC) may have an encapsulated and\/or exposed relationship with the same factored type (FT). Exposed and encapsulated factored types (FT) and aggregate components (AC), as well as relationships therebetween, are described further below, including with reference to .","Component oriented design relates to offering a single object per user concept as opposed to requiring multiple objects per logical concept. Aggregate components therefore usually correspond to a user concept and are simpler from a usability perspective. Aggregate components are layered on top of factored types. By way of an exemplary comparison, aggregate components may model a thing such as a file, and factored types may model a state of a thing such as a view on the file. Together, aggregate components and factored types provide a progressive and gradual learning curve for new developers, especially with respect to a particular given API.","Component Oriented Design for Aggregate Components","Many feature areas may benefit from facade types that act as simplified views over a more complex but well-factored remainder of the feature area APIs. In a described implementation, the facade covers the top 5-10 scenarios in a given feature area and optionally other high-level operations. Aggregate components (AC) can serve as such facade types, and factored types (FT) can provide a remaining well-factored complex API landscape.","Each aggregate component ties multiple lower level factored classes into a higher-level component to support the top core scenarios. For example, a mail aggregate component may tie together SMTP protocol, sockets, encodings, and so forth. Generally, each aggregate component provides a higher abstraction level rather than just a different way of doing things. Providing simplified high-level operations is helpful for those developers who do not want to learn the whole extent of the functionality provided by a feature area and merely wish to accomplish their often very simple tasks without significant study or API exploration.","Generally, component oriented design is a design based on constructors, properties, methods, and events. Using aggregate components is a relatively extreme application of component oriented design. An exemplary set of parameters for component oriented design of aggregate components is provided below:\n\n","Component oriented design entails considering how the API is used instead of focusing on the mere inclusions of the methods, properties, and events in the object model. An exemplary usage model for component oriented design involves a pattern of instantiating a type with a default or relatively simple constructor, setting some properties on the instance, and then calling simple methods. This pattern is termed a Create-Set-Call usage pattern. A general example follows:",{"@attributes":{"id":"p-0070","num":"0075"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2018 VB"]},{"entry":[{},"\u2018 Instantiate"]},{"entry":[{},"Dim T As New T( )"]},{"entry":[{},"\u2018 Set properties\/options."]},{"entry":[{},"T.P1 = V1"]},{"entry":[{},"T.P2 = V2"]},{"entry":[{},"T.P3 = V3"]},{"entry":[{},"\u2018 Call methods; optionally change options between calls."]},{"entry":[{},"T.M1( )"]},{"entry":[{},"T.P3 = V4"]},{"entry":[{},"T.M2( )"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"When aggregate components support this Create-Set-Call usage pattern, the aggregate components comport with the expectations of the main users of aggregate components. Moreover, tools, such as intellisense and designers, are optimized for this usage pattern. A concrete code example showing the Create-Set-Call usage pattern follows:",{"@attributes":{"id":"p-0072","num":"0077"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2018 VB"]},{"entry":[{},"\u2018 Instantiate"]},{"entry":[{},"Dim File As New FileObject( )"]},{"entry":[{},"\u2018 Set properties."]},{"entry":[{},"File.Filename = \u201cc:\\foo.txt\u201d"]},{"entry":[{},"File.Encoding = Encoding.Ascii"]},{"entry":[{},"\u2018 Call methods."]},{"entry":[{},"File.Open(OpenMode.Write)"]},{"entry":[{},"File.WriteLine(\u201cHello World\u201d)"]},{"entry":[{},"File.Close( )"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"An issue with component oriented design is that it results in types that can have modes and invalid states. For example, a default constructor allows users to instantiate a \u201cFileObject\u201d without specifying a \u201cFileName\u201d. Attempting to call Open() without first setting the \u201cFileName\u201d results in an exception because the \u201cFileObject\u201d is in an invalid state with respect to being opened (e.g., no file name has yet been specified). Another issue is that properties, which can be set optionally and independently, do not enforce consistent and atomic changes to the state of the object. Furthermore, such \u201cmodal\u201d properties inhibit sharing of an object instance between consumers because a first user has to check a previously-set value before reusing it in case a second user has changed the value in the interim. However, the usability of aggregate components outweighs these issues for a vast multitude of developers.","When users call methods that are not valid in the current state of the object, an \u201cInvalidOperationException\u201d is thrown. The exception's message can clearly explain what properties need to be changed to get the object into a valid state. These clear exception messages partially overcome the invalid state issue and result in an object model that is more self-documenting.","API designers often try to design types such that objects cannot exist in an invalid state. This is accomplished, for example, by having all required settings as parameters to the constructor, by having get-only properties for settings that cannot be changed after instantiation, and by breaking functionality into separate types so that properties and methods do not overlap. In a described implementation, this approach is employed with factored types but not with aggregate components. For aggregate components, developers are offered clear exceptions that communicate invalid states to them. These clear exceptions can be thrown when an operation is being performed, instead of when the component is initialized (e.g., when a constructor is called or when a property is set), so as to avoid situations where the invalid state is temporary and gets \u201cfixed\u201d in a subsequent line of code.","Factored Types","As described above, aggregate components provide shortcuts for most common high level operations and are usually implemented as a facade over a set of more complex but also richer types, which are called factored types. In a described implementation, factored types do not have modes and do have very clear lifetimes.","An aggregate component may provide access to its internal factored types through some properties and\/or methods. Users access the internal factored types in relatively advanced scenarios or in scenarios where integration with different parts of the system is required. The ability to access factored type(s) that are being used by an aggregate component enables code that has been written using the aggregate component to incrementally add complexity for advanced scenarios, or integrate with other component types, without having to re-write code from the beginning with a focus on using the factored types.","The following example shows an exemplary aggregate component (\u201cFileObject\u201d) exposing its exemplary internal factored type (\u201cStreamWriter\u201d):",{"@attributes":{"id":"p-0079","num":"0084"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2018VB"]},{"entry":[{},"Dim File As New FileObject(\u201cc:\\foo.txt\u201d)"]},{"entry":[{},"File.Open(OpenMode.Write)"]},{"entry":[{},"File.WriteLine(\u201cHello World\u201d)"]},{"entry":[{},"AppendMessageToTheWorld(File.StreamWriter)"]},{"entry":[{},"File.Close( )"]},{"entry":[{},". . ."]},{"entry":[{},"Public Sub AppendMessageToTheWorld(ByVal Writer As"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"StreamWriter)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},". . ."]},{"entry":[{},"End Sub"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"In a described implementation, aggregate components, as the upper or higher level APIs (e.g., from a level of abstraction perspective), are implemented such that they appear to \u201cmagically\u201d work without the user being aware of the sometimes complicated things happening underneath. For example, an \u201cEventLog\u201d aggregate component hides the fact that a log has both a read handle and a write handle, both of which are opened in order to use it. As far as a developer may be concerned, the aggregate component can be instantiated, properties can be set, and log events can be written without concern for the under-the-hood functioning.","In some situations, a bit more transparency may facilitate some task with the developer. An example is an operation in which the user takes an explicit action as a result of the operation. For instance, implicitly opening a file and then requiring the user to explicitly close it is probably taking the principle of \u201cmagically\u201d working too far. Nevertheless, a diligent API designer may often be capable of designing clever solutions that hide even those complexities. For example, reading a file can be implemented as a single operation that opens a file, reads its contents, and closes it; the user is thus shielded from the complexities related to opening and closing the file handles.","Furthermore, using aggregate components does not involve implementing any interfaces, modifying any conFIG.uration files, and so forth. Instead, library designers can ship default implementations for interfaces that are declared. Moreover, conFIG.uration settings are optional and backed by sensible defaults.",{"@attributes":{"id":"p-0083","num":"0088"},"figref":"FIG. 8","b":["702","702","800","702","702"]},"As illustrated, aggregate component (AC) includes multiple aggregate component (AC) members . Specifically, aggregate component members (), (), (P)(), (P)(), (M)(), (M)(), and (M)() are shown. Aggregate component (AC) also includes exposed factored types (FT-Ex) and encapsulated factored types (FT-En). Specifically, exposed factored types (FT-Ex)() and (FT-Ex)() and encapsulated factored types (FT-En)() and (FT-En)() are shown. Factored types (FT) also include factored type (FT) members .","In a described implementation, aggregate component (AC) includes at least one aggregate component member , which may be a method or a property for example. Aggregate component members  can therefore include aggregate component methods (M) and aggregate component properties (P). These aggregate component members , such as aggregate component members () and (), may be specific to the aggregate component (AC). In other words, some aggregate component members  like aggregate component members () and () that are on aggregate component (AC) may not rely on any factored types (FT). Alternatively, some aggregate component members  may be linked to underlying factored types (FT).","Factored types (FT) may be exposed factored types (FT-Ex) or encapsulated factored types (FT-En). Exposed factored types (FT-Ex) are factored types (FT) of a given aggregate component (AC) that may be accessible by or to other general component types (FT or AC) without using or going through individual aggregate component members  of the given aggregate component (AC). If a factored type (FT-Ex\/En) is returned by an aggregate component member  (either a method or a property), then that factored type (FT-Ex) is exposed. Otherwise, that factored type (FT-En) is encapsulated.","In other words, an aggregate component member  can expose a factored type member , or an aggregate component member  can return a factored type instance. The latter can occur with exposed factored types (FT-Ex), and the former can occur with encapsulated factored types (FT-En). Encapsulated factored types (FT-En) are factored types (FT) of a given aggregate component (AC) that are contained within or internal to the given aggregate component (AC). Each factored type (FT) may include one or more members  (some of which are specifically indicated in ) that are methods and\/or properties.","As illustrated, two method members  of encapsulated factored type (FT-En)() are exposed by aggregate component (AC) as method member (M)() and method member (M)(). One method member  of encapsulated factored type (FT-En)() is exposed by aggregate component (AC) as method member (M)().","Exposed factored type (FT-Ex)() is itself exposed as a property member (P)() of aggregate component (AC). Similarly, exposed factored type (FT-Ex)() is also exposed as a property member (P)() of aggregate component (AC). As indicated, a factored type (FT) member  of exposed factored type (FT-Ex)() is exposed so as to be separately accessible (i.e., accessible without directly using an individual member  of aggregate component (AC)). Hence, a factored type member  of an exposed factored type (FT-Ex) can still be accessed even if it is not individually exposed by an aggregate component member  of aggregate component (AC).","Thus, the indicated member  of exposed factored type (FT-Ex)() is exposed so as to be accessible by component types  that are external to aggregate component (AC) without using a member  thereof. As indicated by the dashed lines emanating from exposed factored type (FT-Ex)(), exposed factored types (FT-Ex) may be \u201chanded off\u201d for use by other component types  (especially by other factored types (FT)) that are unable to interact with aggregate components (AC) or that can better achieve their intended purpose using the handed-off exposed factored type (FT-Ex)() alone. It should be noted that the object (exposed factored type (FT-Ex)()) that is \u201chanded off\u201d is not a copy but rather an actual part of the exposing aggregate component (AC). As a result, the operations on the handed off object affect aggregate component (AC).","Generally, if a factored type (FT) is encapsulated, it is not exposed to a consumer; instead, setting properties (P) or calling methods (M) on an aggregate component (AC) may cause factored types (FT) to be created, properties  to be set, or methods  to be called on the underlying factored type (FT). These members  and  may not have a one-to-one correspondence; for example, setting several properties (P) on an aggregate component (AC) may be cached in the aggregate component (AC). Subsequently calling a method (M) on the aggregate component (AC) may cause a factored type (FT) to be created using the previously-specified values of the several properties (P) as constructor arguments for the factored type (FT).","In a described implementation, aggregate components (AC) differ from more-traditional object-oriented components in at least two ways in addition to the exposure of exposed factored types (FT-Ex). First, an aggregate component (AC) does not necessarily expose every member  of all of its factored types (FT). In other words, aggregate components (AC) are not strictly devoted to an inheritance hierarchy. Second, aggregate components (AC) can have modes and thus may periodically have states that result in invalid operations.","As a guideline to component oriented design with respect to factors  (of ), whether a factored type (FT) is exposed or encapsulated within an aggregate component (AC) may be based on one or more of a number of factors. First, a particular factored type (FT) is exposed as a property member (P) of a given aggregate component (AC) if the particular factored type (FT) includes functionality that is not exposed by the given aggregate component (AC). Second, a particular factored type (FT) is exposed as a property member (P) of a given aggregate component (AC) if other general component types  of the framework may benefit from a handoff for direct consumption of the particular factored type (FT). On the other hand, a particular factored type (FT) is not exposed (and is therefore encapsulated) when functionality of the particular factored type (FT) is completely exposed by a given aggregate component (AC) and when the particular factored type (FT) is not useful for handing off to other component types .","A developer can start with aggregate component (AC), especially for implementing simpler and\/or core scenarios. When the developer wishes or needs to implement a more complex scenario, the developer can incrementally and gradually begin to directly access and use exposed factored types (FT-Ex), including low-level attributes thereof, over time. The original code that relied on the simpler aggregate component (AC) does not need to be jettisoned and replaced with more complicated coding that relies solely on factored types (FT). The two-layers of the API framework can be used in varying proportions and can co-exist simultaneously.","Designing a two-layer API framework can be accomplished using the following exemplary technique that is described in ten phases: First, a set of core scenarios for a particular feature area is selected. Second, sample codes showing the preferred lines of code for the selected core scenarios are written. Third, aggregate components are derived with the appropriate methods, defaults, abstractions, naming, etc. to support the code samples from the lines of code.","Fourth, the code samples from the second phase are refined as appropriate according to the derived aggregate components. Fifth, the refined code samples are evaluated for whether or not they are sufficiently simple. If not, the technique continues again at the third phase. If so, then at the sixth phase it is determined whether additional scenarios, usages, interactions with other components, and\/or other requirements exist. Seventh, the API designer decides if any of the additional requirements discovered in the sixth phase can be added to the aggregate components without adding undue complexity to the selected core scenarios.","Eighth, if the additional requirements cannot be added to the aggregate components, an ideal factoring (e.g., based on object-oriented or other analytical methodologies) of a full set of functionality for the factored types is defined based on the seventh phase. Ninth, it is determined how and whether the aggregate components encapsulate or expose the functionality from the factored types that are defined in the eighth phase. Tenth, the factored types are refined as appropriate to support the aggregate components as well as the additional requirements. Using this exemplary technique, a two-layer API framework having aggregate components (AC) and factored types (FT) may be designed.",{"@attributes":{"id":"p-0098","num":"0103"},"figref":"FIG. 9","b":["702","902","802","802","904","902","802","802","904","702","902"]},"Secondly, the developer sets any properties (P) for which the default values are inappropriate and\/or non-preferred for the intended use of the object. Thirdly, desired methods (M) are called by the developer. Callbacks are then implemented in terms of events .","Customizable Defaults","Customizable defaults relates to having defaults whenever practicable for at least aggregate components. When designing an API for example with multiple code samples corresponding to multiple languages, an identical value that is passed in each of the code samples can instead be set as a default for the aggregate component. The customizable defaults may be changed by setting one or more properties on the aggregate component.","Many developers prefer to code by trial and error as opposed to taking the time to read the documentation and fully understand a feature area prior to beginning a project. This is particularly true for novice and occasional developers, such as those that code with VB. These developers often try to experiment with an API to discover what it does and how it works, and then they adjust their code slowly and incrementally until the API implementation achieves their goal. The popularity of the editing and continuing approach to development is a manifestation of this preference.","Some API designs lend themselves to \u201ccoding by experimentation\u201d and some do not. There are multiple aspects that affect the level of success a developer is likely to have when using a coding by experimentation approach. These aspects include: (i) how easy it is to locate the right API for the task at hand; (ii) how easy it is to start using an API, regardless of whether it (initially) does what the developer wants it to do or not; (iii) how easy it is to discover what the points of customization are for an API; (iv) how easy it is to discover the correct customization for a given scenario; and (v) so forth.","In a described implementation, APIs are designed to require little if any initialization (e.g., a minimal amount of initialization). For example, an API can be designed so that a default constructor or a constructor with one simple parameter is sufficient to start working with a type. When initialization is necessary, an exception that results from not performing the initialization clearly explain what needs to be done and\/or changed in order to remove or prevent the exception. For example, an exception may stipulate what or which property needs to be set.","By way of example but not limitation, a rule of thumb is that the simplest constructor has three or fewer parameters (with an upper limit of five). In addition, the simplest constructors should avoid complex types as any of the parameters, where complex types may be other factored types or aggregate components. Another rule of thumb is that the simplest constructors rely on primitive types like, enumerations, strings, integers, and so forth. Types may also implement more complex constructor overloads to support more complex scenarios.","In short, an API's customizability can be simplified by providing properties with good defaults for all customization points. (However, developers should generally be able to add new code to the existing code when customizing their scenarios; rewriting the entire code from scratch using a different API should be optional.) For example, a system messaging queue aggregate component enables the sending of messages after passing a path string to the constructor and calling a send method. Message properties, such as message priority and encryption algorithms, can be customized by adding code to the core scenario.","Self Documenting Object Model","Self documenting object model relates to designing an API framework in which a developer can look at objects and members thereof to learn about them as well as be able to use them. For example, names can be based on how a type is expected to be used instead of devotion to an inheritance hierarchy that many developers do not wish to study. In short, a self documenting object model facilitates discoverability by would-be developers.","As noted above, some developers prefer to code by trial and error and resort to reading documentation only when their intuition fails to implement their intended scenario. Thus, a self documenting object model should avoid requiring that developers read documentation every time they want to perform even simple tasks. An exemplary set of principles and practices to help in producing intuitive APIs that are relatively self documenting for a described implementation are presented below. Any one or more of them may be utilized in a given API and\/or API design implementation.","Naming","A first guiding principle is to reserve simple and intuitive names for types that users need to use (e.g., instantiate) in the most common scenarios. Designers often \u201csquander\u201d the best names for abstractions, with which most users do not have to be concerned. For example, naming an abstract base class \u201cFile\u201d and then providing a concrete type \u201cXYZFile\u201d works well if the expectation is that all users will have to understand the inheritance hierarchy before they can start using the APIs. However, if users do not understand the hierarchy, the first thing they will likely try to use, most often unsuccessfully, is the \u201cFile\u201d type. More specifically, the most common or expected names are reserved for aggregate components targeting the top core scenarios with less common or familiar names being used on concepts and abstractions.","A second guiding principle is to use descriptive identifier names that clearly state what each method does and what each type and parameter represents. For example, API designers should not hesitate to be rather verbose when choosing identifier names. For instance, \u201cEventLog.DeleteEventSource(string source, string machineName)\u201d may be seen as rather verbose, but it arguably has a net positive usability value. Moreover, type and parameter names state what a type or a parameter represents, instead of what it does. Method names state what the method does. Of course, accurate verbose method names are easier for methods that have simple and clear semantics, which is another reason why avoiding complex semantics is a good general design principle to follow.","A guiding design practice is to include a discussion about naming choices as a significant part of API specification reviews and\/or tests. Exemplary considerations and questions include: What are the types most scenarios start with? What are the names most people think of first when trying to implement a given scenario? Are the names of the common types what users think of first? For example, since \u201cFile\u201d is the name most people think of when dealing with file I\/O scenarios, the aggregate component for accessing files can be named \u201cFile\u201d. Additionally, the most commonly used methods of the most commonly used types and their parameters are reviewed and tested. For example, can anybody familiar with the technology, but not the specific API design under consideration, recognize and call those methods quickly, correctly, and easily?","Exceptions","As indicated above, exceptions can facilitate self-documenting APIs. In other words, APIs should lead the user to do the next required thing, and exceptions are capable of and good for communicating what is required next. For example, the following sample code throws an exception with a message \u201cThe \u2018FileName\u2019 property needs to be set before attempting to open the \u2018FileObject\u2019.\u201d:",{"@attributes":{"id":"p-0112","num":"0117"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2018VB"]},{"entry":[{},"\u2018Instantiate"]},{"entry":[{},"Dim File As New FileObject( )"]},{"entry":[{},"\u2018The file name is not set."]},{"entry":[{},"File.Open( )"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"Another guiding principle for facilitating intuitive APIs is strong typing. For example, calling \u201cCustomer.Name\u201d is easier than calling \u201cCustomer.Properties[\u2018Name\u2019]\u201d. Furthermore, having such a \u201cName\u201d property return the name as a string is more usable than if the property returned an object.","There are cases where property bags with a string based accessor, late bind calls, and other not strongly types APIs are desired, but they are relegated to rarity and are not the rule. Moreover, API designers can provide strongly typed helpers for the more common operations that the user performs on the non-strongly typed API layer. For example, a customer type may have a property bag, but it may additionally provide strongly typed APIs for more common properties like \u201cname\u201d, \u201caddress\u201d, and so forth.","Vectoring Toward Simplicity","Yet another guiding principle is to strive for simplicity, especially for core scenarios. Standard design methodologies are aimed at producing designs that are optimized for maintainability, such as by using abstractions. Consequently, modern design methodologies produce a lot of abstractions. An issue is that such design methodologies operate on an assumption that users of the resulting designs will become experts in that design before starting to implement even simple scenarios. However, that is often not the cases in the real world.","In a described implementation, for at least simple scenarios, API designers ensure that object model hierarchies are sufficiently simple so that they can be used without having to understand how the entire feature area fits together or interoperates. A resulting well-designed API may require that the developer understand the core scenario being implemented, but it does not require a full understanding of the design of the library being used to implement it.","Generally, core scenario APIs are directed or correspond to physical or well-known logical parts of the system instead of abstractions. Types that correspond to abstractions are usually difficult to use without understanding how all the parts of the feature area fit together and interoperate; they are therefore more relevant when cross-feature integration is required.","Another guiding practice is to use standard design methodologies (e.g., UML) when designing internal architectures and some of the factored types, but not when designing the APIs for the core or common scenarios (e.g., those with aggregate components). When designing aggregate components for core scenarios, scenario driven design together with prototyping, usability studies, and iteration (as described herein above) is employed instead.","Clean Namespaces","Yet another guiding principle is that types that are (very) rarely used are placed in sub-namespaces to avoid clutter of the main namespaces. For example, the following two groups of types may be separated from their main namespaces: permission types and design types. For instance, permission types can reside in a \u201c.Permissions\u201d sub-namespace, and design-time-only types can reside in a \u201c.Design\u201d sub-namespace.","The actions, aspects, features, components, etc. of  are illustrated in diagrams that are divided into multiple blocks. However, the order, interconnections, interrelationships, layout, etc. in which  are described and\/or shown is not intended to be construed as a limitation, and any number of the blocks can be modified, combined, rearranged, augmented, omitted, etc. in any manner to implement one or more systems, methods, devices, procedures, media, APIs, apparatuses, arrangements, etc. for designing APIs. Furthermore, although the description herein includes references to specific implementations (and the exemplary operating environment of ), the illustrated and\/or described implementations can be implemented in any suitable hardware, software, firmware, or combination thereof and using any suitable software architecture(s), coding language(s), scenario definitions(s), usability study format(s), and so forth.","Exemplary Operating Environment for Computer or Other Device",{"@attributes":{"id":"p-0121","num":"0126"},"figref":"FIG. 10","b":["1000","1000"]},"Exemplary operating environment  is only one example of an environment and is not intended to suggest any limitation as to the scope of use or functionality of the applicable device (including computer, network node, entertainment device, mobile appliance, general electronic device, etc.) architectures. Neither should operating environment  (or the devices thereof) be interpreted as having any dependency or requirement relating to any one or to any combination of components as illustrated in .","Additionally, designing APIs and\/or the APIs resulting therefrom may be implemented with numerous other general purpose or special purpose device (including computing system) environments or conFIG.urations. Examples of well known devices, systems, environments, and\/or conFIG.urations that may be suitable for use include, but are not limited to, personal computers, server computers, thin clients, thick clients, personal digital assistants (PDAs) or mobile telephones, watches, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set-top boxes, programmable consumer electronics, video game machines, game consoles, portable or handheld gaming units, network PCs, minicomputers, mainframe computers, network nodes, distributed or multi-processing computing environments that include any of the above systems or devices, some combination thereof, and so forth.","Implementations for the design of APIs and\/or the APIs resulting therefrom may be described in the general context of processor-executable instructions. Generally, processor-executable instructions include routines, programs, modules, protocols, objects, interfaces, components, data structures, etc. that perform and\/or enable particular tasks and\/or implement particular abstract data types. Designing APIs and\/or the APIs resulting therefrom, as described in certain implementations herein, may also be practiced and\/or present in distributed processing environments where tasks are performed by remotely-linked processing devices that are connected through a communications link and\/or network. Especially but not exclusively in a distributed computing environment, processor-executable instructions may be located in separate storage media, executed by different processors, and\/or propagated over transmission media.","Exemplary operating environment  includes a general-purpose computing device in the form of a computer , which may comprise any (e.g., electronic) device with computing\/processing capabilities. The components of computer  may include, but are not limited to, one or more processors or processing units , a system memory , and a system bus  that couples various system components including processor  to system memory .","Processors  are not limited by the materials from which they are formed or the processing mechanisms employed therein. For example, processors  may be comprised of semiconductor(s) and\/or transistors (e.g., electronic integrated circuits (ICs)). In such a context, processor-executable instructions may be electronically-executable instructions. Alternatively, the mechanisms of or for processors , and thus of or for computer , may include, but are not limited to, quantum computing, optical computing, mechanical computing (e.g., using nanotechnology), and so forth.","System bus  represents one or more of any of many types of wired or wireless bus structures, including a memory bus or memory controller, a point-to-point connection, a switching fabric, a peripheral bus, an accelerated graphics port, and a processor or local bus using any of a variety of bus architectures. By way of example, such architectures may include an Industry Standard Architecture (ISA) bus, a Micro Channel Architecture (MCA) bus, an Enhanced ISA (EISA) bus, a Video Electronics Standards Association (VESA) local bus, a Peripheral Component Interconnects (PCI) bus also known as a Mezzanine bus, some combination thereof, and so forth.","Computer  typically includes a variety of processor-accessible media. Such media may be any available media that is accessible by computer  or another (e.g., electronic) device, and it includes both volatile and non-volatile media, removable and non-removable media, and storage and transmission media.","System memory  includes processor-accessible storage media in the form of volatile memory, such as random access memory (RAM) , and\/or non-volatile memory, such as read only memory (ROM) . A basic input\/output system (BIOS) , containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules\/instructions that are immediately accessible to and\/or being presently operated on by processing unit .","Computer  may also include other removable\/non-removable and\/or volatile\/non-volatile storage media. By way of example,  illustrates a hard disk drive or disk drive array  for reading from and writing to a (typically) non-removable, non-volatile magnetic media (not separately shown); a magnetic disk drive  for reading from and writing to a (typically) removable, non-volatile magnetic disk  (e.g., a \u201cfloppy disk\u201d); and an optical disk drive  for reading from and\/or writing to a (typically) removable, non-volatile optical disk  such as a CD, DVD, or other optical media. Hard disk drive , magnetic disk drive , and optical disk drive  are each connected to system bus  by one or more storage media interfaces . Alternatively, hard disk drive , magnetic disk drive , and optical disk drive  may be connected to system bus  by one or more other separate or combined interfaces (not shown).","The disk drives and their associated processor-accessible media provide non-volatile storage of processor-executable instructions, such as data structures, program modules, and other data for computer . Although exemplary computer  illustrates a hard disk , a removable magnetic disk , and a removable optical disk , it is to be appreciated that other types of processor-accessible media may store instructions that are accessible by a device, such as magnetic cassettes or other magnetic storage devices, flash memory, compact disks (CDs), digital versatile disks (DVDs) or other optical storage, RAM, ROM, electrically-erasable programmable read-only memories (EEPROM), and so forth. Such media may also include so-called special purpose or hard-wired IC chips. In other words, any processor-accessible media may be utilized to realize the storage media of the exemplary operating environment .","Any number of program modules (or other units or sets of instructions\/code, including an API framework and\/or objects based thereon) may be stored on hard disk , magnetic disk , optical disk , ROM , and\/or RAM , including by way of general example, an operating system , one or more application programs , other program modules , and program data .","A user may enter commands and\/or information into computer  via input devices such as a keyboard  and a pointing device  (e.g., a \u201cmouse\u201d). Other input devices  (not shown specifically) may include a microphone, joystick, game pad, satellite dish, serial port, scanner, and\/or the like. These and other input devices are connected to processing unit  via input\/output interfaces  that are coupled to system bus . However, input devices and\/or output devices may instead be connected by other interface and bus structures, such as a parallel port, a game port, a universal serial bus (USB) port, an infrared port, an IEEE 1394 (\u201cFirewire\u00ae\u201d) interface, an IEEE 802.11 wireless interface, a Bluetooth\u00ae wireless interface, and so forth.","A monitor\/view screen  or other type of display device may also be connected to system bus  via an interface, such as a video adapter . Video adapter  (or another component) may be or may include a graphics card for processing graphics-intensive calculations and for handling demanding display requirements. Typically, a graphics card includes a graphics processing unit (GPU), video RAM (VRAM), etc. to facilitate the expeditious display of graphics and performance of graphics operations. In addition to monitor , other output peripheral devices may include components such as speakers (not shown) and a printer , which may be connected to computer  via input\/output interfaces .","Computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computing device . By way of example, remote computing device  may be a personal computer, a portable computer (e.g., laptop computer, tablet computer, PDA, mobile station, etc.), a palm or pocket-sized computer, a watch, a gaming device, a server, a router, a network computer, a peer device, another network node, or another device type as listed above, and so forth. However, remote computing device  is illustrated as a portable computer that may include many or all of the elements and features described herein with respect to computer .","Logical connections between computer  and remote computer  are depicted as a local area network (LAN)  and a general wide area network (WAN) . Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets, the Internet, fixed and mobile telephone networks, ad-hoc and infrastructure wireless networks, other wireless networks, gaming networks, some combination thereof, and so forth. Such networks and communications connections are examples of transmission media.","When implemented in a LAN networking environment, computer  is usually connected to LAN  via a network interface or adapter . When implemented in a WAN networking environment, computer  typically includes a modem  or other component for establishing communications over WAN . Modem , which may be internal or external to computer , may be connected to system bus  via input\/output interfaces  or any other appropriate mechanism(s). It is to be appreciated that the illustrated network connections are exemplary and that other manners for establishing communication link(s) between computers  and  may be employed.","In a networked environment, such as that illustrated with operating environment , program modules or other instructions that are depicted relative to computer , or portions thereof, may be fully or partially stored in a remote media storage device. By way of example, remote application programs  reside on a memory component of remote computer  but may be usable or otherwise accessible via computer . Also, for purposes of illustration, application programs  and other processor-executable instructions such as operating system  are illustrated herein as discrete blocks, but it is recognized that such programs, components, and other instructions reside at various times in different storage components of computing device  (and\/or remote computing device ) and are executed by processor(s)  of computer  (and\/or those of remote computing device ).","Although systems, media, devices, methods, procedures, apparatuses, techniques, APIs, schemes, approaches, procedures, arrangements, and other implementations have been described in language specific to structural, logical, algorithmic, functional, and action-based features and\/or diagrams, it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or diagrams described. Rather, the specific features and diagrams are disclosed as exemplary forms of implementing the claimed invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The same numbers are used throughout the drawings to reference like and\/or corresponding aspects, features, and components.",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
