---
title: Efficient coding of integers in non-power-of-two ranges
abstract: Coding efficiently in non-power-of-two ranges. Coding is performed in an N-bit system, where certain codes are represented with N bits and other codes are represented with (N+1) bits. An example is where the other codes may have an N-bit representation used to represent multiple values, with the additional bit being disambiguation information provided to distinguish the codes having multiple values. Thus, N bits are used to represent most codes, and an extra bit is used to represent other codes. The number of bits per element used for representing a sequence is, on average, close to a theoretical minimum for N-bits.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07773000&OS=07773000&RS=07773000
owner: Red Hat, Inc.
number: 07773000
owner_city: Raleigh
owner_country: US
publication_date: 20090227
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD","COPYRIGHT NOTICE\/PERMISSION","BACKGROUND","DETAILED DESCRIPTION"],"p":["The invention is generally related to implementation of coding, and particular embodiments relate to overlapping codes for particular values and providing disambiguation for the reused code for coding in finite fields.","At least a portion of the disclosure of this patent document contains material that is subject to copyright protection. The copyright owner has no objection to the reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever. The copyright notice applies to all data as described below, and in the accompanying drawings hereto, as well as to any software described below: Copyright\u00a9 2008, Red Hat, Inc., All Rights Reserved.","The coding of integers finds application in many fields of computing systems. Integer coding occurs, for example, in finite field arithmetic. Finite field arithmetic has many uses in computing systems. Finite field arithmetic refers to computations based on a finite field of elements, commonly used for factoring polynomials. Galois Field mathematics is finite field mathematics, and a Galois Field has a finite number of elements, where any power of any element of the field is also an element of the field. An example of the use of finite field mathematics is in the area of cryptography, where data is encrypted for security. The coding and decoding of the data may be based on finite field mathematics, where the codes are determined from the field. Cryptography systems may use a base 2(such as the familiar AES (Advanced Encryption Standard) algorithm) or non-2base, where the use of non-2bases is becoming more common.","Additionally, the storage and transmission of digital data is ubiquitous in computing systems. Receiving a transmission or retrieving stored information may reveal an error in the data, which may be caused by the storage, the transmission, and or the reading. Error correction techniques may be employed to obtain the desired data even in the presence of errors. A common error correction technique includes the use of parity bits or error codes that can help reconstruct data that has errors. Among error correction techniques are techniques implemented in accordance with or based on familiar Reed-Solomon coding.","The implementation of Reed-Solomon coders is based on the application of Galois Field mathematics. Briefly, code symbols in the Reed-Solomon coders are defined in a Galois Field of numbers represented as GF(Q), where Q is a positive integer. Relatively recent advances showed the benefits of using prime numbers as the base for the Galois Fields, rather than a 2base. Common Reed-Solomon implementations use GF(257) and GF(65,537), which are prime numbers that are also 2+1 and 2+1, respectively. These prime bases also have application in the use of cryptography systems. These prime bases have the property of being a single number higher than what can be represented by an 8-bit or a 16-bit representation, respectively, where B- and 16-bits are useful for binary computing systems.","However, where the base field is GF(257) or GF(65,537), certain codes cannot be represented reliably using 8 or 16 bits, since there is one more element than either representation can hold. The extension of that problem is also seen in other fields having a non-2base. Typically, this problem is resolved by either ignoring the problem (which generally cannot be done for values other than 257 or 65,537), using a complex conversion process, which requires additional logic and processing, or using the additional bit to represent the codes, which increases data use in the storage and\/or transmission bandwidth. Thus, these known resolutions are typically limited to the use of primes of the form 2+1, because other primes exacerbate the problem. The primary issue is that for values not of the form 2(with the problem ignored) or 2+1 is that more bits than necessary are used for the codes. Consider a base 53. GF(53) includes the values 0-52, which would likely be represented with 6-bit encoding, because any value 0-63 could be represented with 6 bits. Thus, current coding schemes are often inefficient.","As described herein, coding efficiently for integers in ranges other than a power-of-two is performed. The efficient coding is based on binary coding of values in a range other than one spanned by a power of two, which includes coding with finite fields. Consider a system configured to code in a base of P, where P is a prime number greater than M, where M is a power-of-two number 2, N being a positive integer. For coding in base P, each element of a sequence to code has a numeric integer value within the range 0 through (P\u22121). The coding of the elements is performed with either N or (N+1) bits, depending on a range in which the numeric value of the element lies. For all elements in the sequence having a value within the range of integers (P\u2212M) through (M\u22121), the element is coded to an N-bit representation. For all elements in the sequence having a value within the ranges of integers 0 through (P\u2212M\u22121) or M through (P\u22121), the element is coded to an (N+1)-bit representation. The system generates a coded sequence with the representations.","The following examples are illustrative. As suggested above, the use of prime bases is common for cryptographic system implementation, as well as for Reed-Solomon error correction coding. Examples of the use of prime bases may include the following. For a GF(257) coding implementation, P=257, where N=8 and M=256. Thus, elements of a sequence to be coded are coded with an 8-bit representation for all values in the range of 1-255. The values 0 and 256 are coded with an additional bit (9 bits total) to distinguish them. For a GF(271) implementation, P=271, where N=8 and M=256. Elements of the sequence to be coded are represented in 8 bits for all elements having values in the range 15-255. The elements having values within the ranges 0-14 or 256-270 are coded with an additional bit (9 bits). In one embodiment, 8 bits of the 9-bit representation are the 8-bit representation of the codes modulo N (or modulo 256 in the case of 8 bits). The sequence then has certain codes that represent two different values (e.g., 0 and 256, 1 and 257, 2 and 258, etc.). Thus, certain codes may be used to represent multiple values (0 and 256 in the first example, 0-14 and 256-270 in the second example). The additional bit is then disambiguation information provided to distinguish the codes having multiple values. Thus, N bits are used to represent most codes, and an extra bit (N+1 bits) is used to represent the other codes. The number of bits per element used for representing a sequence is, on average, very close to the theoretical minimum of N-bits.","A similar example to the P=271 case is an example of a non-prime base. For GF(289) (==GF(17), P=289, and N=8 and M=256. Thus, elements within the range 33-255 would be coded with 8 bits, and elements having values within the ranges 0-32 or 256-288 are coded with an additional bit (9 bits). Again, 8 bits of the 9-bit representation can be the 8-bit representation of the codes modulo N (or modulo 256). The sequence then has certain codes that represent two different values (e.g., 0-32 and their corresponding values 256-288). Thus, certain codes may be used to represent multiple values (0 and 256 in the first example, 0-14 and 256-270 in the second example). A disambiguation bit is included to distinguish the representations representing multiple values.","Another example illustrates the use of a range that is not prime, and that does not represent a finite field. If P=18, the range of values is 0-17, and N can be set to 4 (N=4 corresponds to 2=16). Thus, elements having values within the range 2-15 would be coded with 4 bits, and elements having values within the ranges 0-1 and 16-17 would be coded with an additional disambiguation bit for a total of 5 bits per code.","Thus, the problem of ignoring the additional codes or using a conversion process can be overcome by representing the codes as described above. Additionally, many values other than 2N+1 can be used, seeing there is an efficient way to deal with the additional values. The use of P=257 or P=65537 are common for 8 or 16 bit coding. The use of these values is convenient because they can be accomplished with a native format of the computing hardware logic for most codes, because 8 and 16 bit computing logic is common.","As suggested above, the value of P may commonly be selected to be a prime number (such as 257 and 65,537, the practical values of known primes equal to (2^N)+1\u22123, 5, 17, 257, and 65,537), but such a selection is not necessary. However, the use of P=257 or 65537 would integrate well with known cryptographic system implementations or Reed-Solomon error correction coding systems.","Thus, the techniques described herein can be applied to cryptographic systems (which may use finite fields or rings), general data compression (which is not necessarily related to any specific underlying mathematical construct or object), representing enumerated sets (which also is not necessarily related to any specific underlying mathematical construct), and error correction techniques (which uses finite fields) based on Reed-Solomon coding. Such error correction is common in multimedia storage and\/or transmission, such as encryption and decryption used in compact discs (CDs) and digital versatile discs (DVDs, also commonly referred to as digital video discs). The use of the N and (N+1) bits in generating a coding sequence may be used in combination with many types of cryptographic systems, and other derivatives of Reed-Solomon coding.","Assuming a uniform distribution of the coded values, the coding described herein requires an average number of bits very close to a theoretical minimum near N bits to represent a value. For example, in the case where base 257 is used, the minimal entropy theoretical average for coding GF (257) is 8.00562 bits per coded value (assuming uniform distribution of the code values). Using 9 bits is 12.491% larger than this theoretical average (and the coding as outlined uses an average of 8.00778 bits per coded value, assuming uniform distribution of the code values, which is approximately 0.00216 bits (or 0.027%) per code more than the theoretical average.",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1","b":["100","100","102","102","102"]},"Coder  generates a coded sequence as described herein. In one embodiment, coder  is a decoder that is configured for either decoding operations or encoding operations. Coder  is implemented with hardware logic , such as a coding processor. Hardware logic  may include one or more processors, application specific integrated circuits (ASICs), programmable logic devices (PLDs), microcontrollers, or other hardware logic. For example, in a personal computer, a CPU or equivalent processing system executes operations in accordance with code in the computer. When the CPU executes the operations to implement coder , the CPU is the hardware logic or coding processor. Coder  typically also includes memory , such as registers, some form of random access memory (RAM), and\/or flash in which code, results, sequence values, lookup tables, etc., are stored and used by hardware logic  for the implementation of coding.","Coder  is illustrated with various functional components, which may be separate components, or may be combined together. Thus, the illustration should be understood as one example only, and is not limiting. Coder  could be implemented with more or fewer components than what is shown in . Coder  includes sequence receiver , N-bit value generator , disambiguation module , modulo generator , and sequence generator .","Sequence receiver  enables coder  to receive a sequence of elements to be coded. Sequence receiver  can be generically considered a data interface, and may be considered to be part of coder , or a separate component that interfaces coder  to a source of coding sequence . The source may be a hardware component or a software component. Sequence receiver  may include an application programming interface (API) accessible to other hardware and\/or software components of system . Thus, coder  may be invoked from external to coder , and either passed sequence , or passed a reference to a memory location in which sequence  is stored and can be accessed. Sequence receiver  may also include a network interface to receive information transmitted over a network or from another device, and\/or a storage interface to receive information from a storage device for coding.","N-bit value generator  enables coder  to generate an N-bit representation for elements of sequence . As suggested above, for all elements in sequence  having a value within the range of integers (P\u2212M) through (M\u22121), the element is coded to an N-bit representation. N-bit value generator  may include a lookup table or an algorithmic converter that performs the operation to generate the N-bit representation. In one embodiment, the N-bit representation is a basis for the (N+1)-bit representation, such as an N-bit representation plus an additional disambiguation bit.","Disambiguation module  enables coder  to generate a unique or distinguishable representation for elements represented with (N+1) bits. As suggested above, for all elements in the sequence having a value within the ranges of integers 0 through (P\u2212M\u22121) or M through (P\u22121), the element is coded to an (N+1)-bit representation. The (N+1)-bit representation could simply be an (N+1)-bit representation of the value. Alternatively, the representation may be an N-bit representation with a disambiguation bit. Disambiguation information could refer to either an (N+1)-bit representation of the value of the element, or the bit that distinguishes one N-bit representation from another.","In an implementation using a disambiguation bit, the bit can be placed in one of various locations within the stream. The use of a different location would be controlled by configuration. The configuration could be static, in that participating systems would always use the same formatting to identify element value bits and disambiguation bits. Alternatively, each sequence could include a preamble or header to indicate the type of formatting used, which could also identify the structure of the sequence including disambiguation bit location. For example, a disambiguation bit could be placed directly before or directly after the value it disambiguates. For instance, if 0 and 256 were both represented by 00000000b, the addition of the disambiguation bit could make the possible representations 100000000b or 000000000b, or 000000001b or 000000000b. In one embodiment, the additional zero could indicate \u20180\u2019, while the extra one could indicate \u2018256\u2019. However, the use of the disambiguation bit could be reversed.","As an alternative to adding a disambiguation bit directly before or after the code to disambiguate, multiple disambiguation bits could be collected and indicated jointly, for example, with a single value. For example, in an 8-bit implementation, an extra 8-bit byte per 8 elements to disambiguate of the sequence could be added. The extra byte could be added prior to the elements it disambiguates, or added after the elements. The extra byte occur less frequently than once every 8 elements, since it is only needed to disambiguate \u201cambiguous\u201d elements. Thus, any number of elements that do not need disambiguation could be spread throughout the elements to disambiguate (in this example, 8). The disambiguation information can act as a map to indicate the value of the multi-use code. A more specific example is provided below with respect to . Generally, for example, a pattern of \u2018010\u2019 in a disambiguation value could indicate that the first ambiguous element encountered should be its face value, while the second element should be given its value plus N.","In a decoding scenario, sequence receiver  receive a coded sequence . Disambiguation module  determines where in the sequence the disambiguation information is found (e.g., a 9-bit representation of a value, which could be indicated by a bitmap, a disambiguation bit before or after, or a collection of disambiguation bits). Using the disambiguation information, the decoding can correctly interpret the value of each element in the sequence.","Modulo generator  enables coder  to perform a modulo operation in one embodiment of a disambiguation operation. For example, coding elements to an (N+1)-bit representation may include computing a mathematical result of the value modulo N. The result can then be represented by an N-bit representation with N-bit value generator , where the N-bit representation is the representation of the face-value of the result. The modulo may be configured to indicate whether the value was greater than N, in which case a disambiguation bit (either a zero or one) could indicate that N should be added to the result to generate the original value represented.","Sequence generator  enables coder  to generate encoded or decoded (collectively, \u201cprocessed\u201d) elements, as illustrated by processed sequence . The encoded sequence is ready to store and\/or transmit. The decoded sequence is ready to use to perform error correction or data decompression.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIGS. 2A-2C","FIG. 2A","FIG. 2B","FIG. 2C","FIG. 2A"],"b":["202","210","232","220","204","210","234","220","206","210","236","220","210","202","204","206","220","0","43","0","210","232","0"]},"In , coder  can encode the sequence as a sequence of 8-bit values: 0, 43, 0, 0, 43, 0, 0, 43, 0, 0, 43, 0, with a disambiguation value, 85 either directly before or after the 8 elements it disambiguates. It will be seen that the sequence actually contains 12 elements, but four of those 12 elements do not need to be disambiguated, so an 8-bit disambiguation value is only needed every 12 elements. The value 85 corresponds to 01010101b. Thus, the assumption is that the additional zero indicates the zero should be interpreted on its face, to a value of zero. The additional one indicates the zero should be interpreted as zero plus 256, or 256.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 2C","FIG. 2B"],"b":"236"},"As mentioned above, the simple representations shown could easily be extended to a code of 0 through (P\u22121), where P is a value other than a power of two. Thus, if M is the greatest power-of-two number less than P, the values in the range (P\u2212M) through (M\u22121), inclusive, could be represented as usual, and the values 0 through (P\u2212M\u22121) and M through (P\u22121) could be represented as the same bit sequence, with an additional disambiguation bit.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 3"},"A system (e.g., system  of ) is configured for a base of P, which is greater than a power-of-two number 2, but less than 2, . Generally, the system is configured to operate with a the particular value P for the coding operations, and 2is typically given for the system (e.g., 2=256 is convenient for an 8-bit system). A data interface (e.g.,  of ) receives a sequence (e.g.,  of ,  of ) to encode, and passes it to a coder (e.g.,  of ,  of ), . The coder identifies the next element of the sequence to encode, .","For each element, the coder determines if the value of the element is within the range 0:(P\u2212M\u22121) (or 0 through (P\u2212M\u22121)) or M:(P\u22121), . Such a determination can be made through a simple logic test as is understood by those skilled in the art. If the value of the element is within the range 0:(P\u2212M\u22121) or M:(P\u22121), the value is not within an N-bit representation range, , and the coder represents the value with N+1 bits. If the value of the element is within the range (P\u2212M):(M\u22121), the value is within an N-bit representation range, , and the coder represents the value with N bits, as continued at .","In one embodiment, the (N+1)-bit representation may not be a (N+1)-bit face-value representation of the value, but rather an N-bit representation of the value with an additional disambiguation bit. In such an implementation, if the value is not within the N-bit range, the coder may perform a modulo operation to obtain a representation of the value within an N-bit range, . In conjunction with the modulo operation, or complementary to the modulo operation, the coder may also determine whether the value is M or greater, or less than M, to determine what disambiguation bit to use. The coder can then generate the disambiguation bit, .","The coder generates a sequence of codes, with disambiguation information. The coder uses a particular disambiguation information convention, and inserts the disambiguation information in accordance with the disambiguation convention, . The disambiguation convention may be to place a bit directly before or after the element to disambiguate, or to include a disambiguation value in the sequence. Inserting the disambiguation information may further include generating a header or similar indicator information to identify the disambiguation convention to a receiving (decoding) device.","The coder may then encode the element with an N-bit representation, . It will be understood that generating disambiguation information can be performed before, after, or in parallel or substantially simultaneously with generating the N-bit representation. The encoded element is added to the encoded sequence, . If a multi-bit disambiguation value is used, the disambiguation information may not be added until the encoded sequence is generated, or at least a portion of the encoded sequence having the number of elements represented in the disambiguation information. If the element processed is the last element, , the encoding is done. Otherwise, the coder identifies the next element to be encoded, and repeats what is described above, starting at .",{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 4"},"A system (e.g., system  of ) is configured for a base of P, which is greater than a power-of-two number 2, but less than 2, . Generally, the system is configured to operate with a the particular value P for the coding operations, and 2is typically given for the system (e.g., 2=65536 is convenient for a 16-bit system). A data interface (e.g.,  of ) receives a sequence (e.g.,  of ,  of ) to decode, and passes it to a coder (e.g.,  of ,  of ), . The coder may parse the sequence, including identifying disambiguation information, . The disambiguation information may be identified by a disambiguation or sequence structure identifier sent by the encoder. The coder identifies the next element of the sequence to decode, .","For each element, the coder determines if the element has disambiguation information associated with it, . If the value of the element is within the range 0:(P\u2212M\u22121) or M:(P\u22121), it will have disambiguation information, and the coder needs to disambiguate the code, . Elements with values within that range are not represented with N bits, but (N+1) bits. If the value of the element is within the range (P\u2212M):(M\u22121), the value is within an N-bit representation range, and the coder does not need to disambiguate the element, . The coder can continue decoding at  for N-bit values.","For values to be disambiguated, the decoder obtains the disambiguation information associated with the element, , either parsing and obtaining a value to disambiguate multiple elements, or otherwise obtaining a bit from the sequence for a single element. In one embodiment, the decoder looks up the value of the element based on the N-bit value representation and the additional disambiguation bit, . For both disambiguated and non-disambiguated elements, the decoder decodes the element, .","The decoder generates a sequence of values from the processed or decoded elements. The current decoded element is added to a decoded sequence, . If the element processed is the last element, , the decoding is done. Otherwise, the decoder identifies the next element to be decoded, and repeats what is described above, starting at .",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 5","b":["500","500"]},"The exemplary computer system  includes a processing device , a main memory  (e.g., read-only memory (ROM), flash memory, dynamic random access memory (DRAM) such as synchronous DRAM (SDRAM), etc.), a static memory  (e.g., flash memory, static random access memory (SRAM), etc.), and a secondary memory  (e.g., a data storage device in the form of a drive unit, which may include fixed or removable computer-readable storage medium), which communicate with each other via a bus .","Processing device  represents one or more general-purpose processing devices such as a microprocessor, central processing unit, or the like. More particularly, the processing device  may be a complex instruction set computing (CISC) microprocessor, reduced instruction set computing (RISC) microprocessor, very long instruction word (VLIW) microprocessor, processor implementing other instruction sets, or processors implementing a combination of instruction sets. Processing device  may also be one or more special-purpose processing devices such as an application specific integrated circuit (ASIC), a field programmable gate array (FPGA), a digital signal processor (DSP), network processor, or the like. Processing device  is configured to execute the efficient coding system  for performing the operations and steps discussed herein.","The computer system  may further include a network interface device . The computer system  also may include a video display unit  (e.g., a liquid crystal display (LCD) or a cathode ray tube (CRT)) connected to the computer system through a graphics port and graphics chipset, an alphanumeric input device  (e.g., a keyboard), a cursor control device  (e.g., a mouse), and a signal generation device  (e.g., a speaker).","The secondary memory  may include a machine-readable storage medium (or more specifically a computer-readable storage medium)  on which is stored one or more sets of instructions (e.g., the efficient coding system ) embodying any one or more of the methodologies or functions described herein. The efficient coding system  may also reside, completely or at least partially, within the main memory  and\/or within the processing device  during execution thereof by the computer system , the main memory  and the processing device  also constituting machine-readable storage media. The efficient coding system  may further be transmitted or received over a network  via the network interface device .","The computer-readable storage medium  may also be used to store the efficient coding system  persistently. While the computer-readable storage medium  is shown in an exemplary embodiment to be a single medium, the term \u201ccomputer-readable storage medium\u201d should be taken to include a single medium or multiple media (e.g., a centralized or distributed database, and\/or associated caches and servers) that store the one or more sets of instructions. The terms \u201ccomputer-readable storage medium\u201d shall also be taken to include any medium that is capable of storing or encoding a set of instructions for execution by the machine and that cause the machine to perform any one or more of the methodologies of the present invention. The term \u201ccomputer-readable storage medium\u201d shall accordingly be taken to include, but not be limited to, solid-state memories, and optical and magnetic media.","In one embodiment, one or more modules  implement the efficient coding described herein, and modules , components, and other features described herein (for example in relation to ) can be implemented as discrete hardware components or integrated in the functionality of hardware components such as ASICS, FPGAs, DSPs or similar devices. In addition, modules  can be implemented as firmware or functional circuitry within hardware devices. Further, modules  can be implemented in any combination hardware devices and software components.","In the above description, numerous details are set forth. It will be apparent, however, to one skilled in the art, that the present invention may be practiced without these specific details. In some instances, well-known structures and devices are shown in block diagram form, rather than in detail, in order to avoid obscuring the present invention.","Some portions of the detailed descriptions above are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here, and generally, conceived to be a self-consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually, though not necessarily, these quantities take the form of electrical or magnetic signals capable of being stored, transferred, combined, compared and otherwise manipulated. It has proven convenient at times, principally for reasons of common usage, to refer to these signals as bits, values, elements, symbols, characters, terms, numbers or the like.","It should be borne in mind, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussion, it is appreciated that throughout the description, discussions utilizing terms such as \u201creceiving,\u201d \u201cmatching,\u201d \u201cprompting,\u201d \u201cselecting,\u201d \u201csending,\u201d \u201cgenerating,\u201d \u201cdisplaying\u201d or the like, refer to the actions and processes of a computer system, or similar electronic computing device that manipulates and transforms data represented as physical (electronic) quantities within the computer system's registers and memories into other data similarly represented as physical quantities within the computer system memories, registers or other such information storage, transmission or display devices.","The present invention also relates to an apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium, such as, but not limited to, any type of disk including floppy disks, optical disks, CD-ROMs and magnetic-optical disks, read-only memories (ROMs), random access memories (RAMs), EPROMs, EEPROMs, magnetic or optical cards, Flash memory devices including universal serial bus (USB) storage devices (e.g., USB key devices) or any type of media suitable for storing electronic instructions, each of which may be coupled to a computer system bus.","The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct more specialized apparatus to perform the required method steps. The required structure for a variety of these systems will appear from the description below. In addition, the present invention is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the invention as described herein.","A computer-readable storage medium includes any mechanism for storing information in a form readable by a computer. For example, a computer-readable storage medium includes read only memory (\u201cROM\u201d), random access memory (\u201cRAM\u201d), magnetic disk storage media; optical storage media, flash memory devices or other type of machine-accessible storage media.","Various operations or functions are described herein, which may be described or defined as software code, instructions, configuration, and\/or data. The content may be directly executable (\u201cobject\u201d or \u201cexecutable\u201d form), source code, or difference code (\u201cdelta\u201d or \u201cpatch\u201d code). The software content of the embodiments described herein may be provided via an article of manufacture with the content stored thereon, or via a method of operating a communication interface to send data via the communication interface. A machine or computer readable storage medium may cause a machine to perform the functions or operations described, and includes any mechanism that stores information in a form accessible by a machine (e.g., computing device, electronic system, etc.), such as recordable\/non-recordable media (e.g., read only memory (ROM), random access memory (RAM), magnetic disk storage media, optical storage media, flash memory devices, etc.). A communication interface includes any mechanism that interfaces to any of a hardwired, wireless, optical, etc., medium to communicate to another device, such as a memory bus interface, a processor bus interface, an Internet connection, a disk controller, etc. The communication interface can be configured by providing configuration parameters and\/or sending signals to prepare the communication interface to provide a data signal describing the software content. The communication interface can be accessed via one or more commands or signals sent to the communication interface.","Various components described herein may be a means for performing the operations or functions described. Each component described herein includes software, hardware, or a combination of these. The components can be implemented as software modules, hardware modules, special-purpose hardware (e.g., application specific hardware, application specific integrated circuits (ASICs), digital signal processors (DSPs), etc.), embedded controllers, hardwired circuitry, etc.","Besides what is described herein, various modifications may be made to the disclosed embodiments and implementations of the invention without departing from their scope. Therefore, the illustrations and examples herein should be construed in an illustrative, and not a restrictive sense. The scope of the invention should be measured solely by reference to the claims that follow."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The following description includes discussion of figures having illustrations given by way of example of implementations of embodiments of the invention. The drawings should be understood by way of example, and not by way of limitation.",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIGS. 2A-2C"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
