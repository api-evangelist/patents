---
title: Discrete table descriptor for unified table management
abstract: A table descriptor is associated with a table and referenced to provide access to the table. The table descriptor includes a first portion identifying information about the table and a second portion identifying one or more locations of the table in memory.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07710972&OS=07710972&RS=07710972
owner: Intel Corporation
number: 07710972
owner_city: Santa Clara
owner_country: US
publication_date: 20061221
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND INFORMATION","DETAILED DESCRIPTION"],"p":["This disclosure relates generally to table management, and in particular but not exclusively, relates to a table descriptor for lookup table management.","Modem packet switching networks are used to carry a variety of different types of information for a wide variety of users and applications. As the use of packet based networks and the diversity of applications to be supported is increasing, support for advanced networking services such as Service Level Agreement (\u201cSLA\u201d) monitoring, traffic engineering, security, billing and the like, to name a few, is becoming a requirement.","One technique for implementing these advanced network services is to classify packets transported within the network into flows and assign actions to be taken on the packets based on the flow assignment. Based on the flow assignment, the network may ensure all packets of this flow receive the appropriate priority and reserve the necessary bandwidth along the path to the destination. The criteria for classification into flows may be diverse; it may include information from the header of a packet, some part of the packet payload or other information such as the ingress or egress interface associated with the packet. This criteria for classification is specified in the form of classification rules. Any packet matching the criteria specified in a classification rule will be classified into the same flow.","In conventional network processor unit (\u201cNPU\u201d), the diverse set of classification rules may be stored in a number of lookup tables. These lookup tables are indexed into by the classification engine to determine the flow to which an incoming packet should be assigned. Since packet classification is executed in real-time at line rates, these lookup tables are often maintained in expensive, high speed, low latency memory (e.g., SRAM), which is a finite and valuable resource.","Lookup tables may also be used to implement other functionality within a NPU, such as Internet Protocol (\u201cIP\u201d) forwarding to route a packet from its source to its destination. EP forwarding is a layer three operation that uses IP addresses to make forwarding decisions. The NPU indexes into a routing table stored in a lookup table using the destination IP address within the packet (or datagram) as the index key. The IP forwarding decision chooses the next hop IP address as well as an output port of the router through which the next hop may be reached. Conceptually, a routing table contains an entry for each possible destination along with a next hop used to reach the destination.","Conventional lookup tables are established by pre-allocating a contiguous block of memory and populating the memory with entries of the lookup table. The amount of memory pre-allocated is generally determined based on an estimate of the maximum foreseeable number of entries. Even if only a fraction of the maximum number of entries is actually used, the entire block of pre-allocated memory remains reserved, resulting in wasteful consumption of a valuable resource.","Since each lookup table in an NPU may be designed for a unique purpose (e.g., classification, IP forwarding, database access, etc.), each lookup table can have a unique format and its own set of management\/access functions (also referred to as application program interfaces (\u201cAPIs\u201d)) developed by the table designer. Although the various APIs for the lookup tables may execute the same or similar table functions, each lookup table has its own set of APIs due to non-unified formats of the various lookup tables. These redundant APIs are stored in memory and consume valuable memory resources, as well.","Embodiments of a system and method for a discrete table descriptor are described herein. In the following description numerous specific details are set forth to provide a thorough understanding of the embodiments. One skilled in the relevant art will recognize, however, that the techniques described herein can be practiced without one or more of the specific details, or with other methods, components, materials, etc. In other instances, well-known structures, materials, or operations are not shown or described in detail to avoid obscuring certain aspects.","Reference throughout this specification to \u201cone embodiment\u201d or \u201can embodiment\u201d means that a particular feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus, the appearances of the phrases \u201cin one embodiment\u201d or \u201cin an embodiment\u201d in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore, the particular features, structures, or characteristics may be combined in any suitable manner in one or more embodiments.",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1","b":["100","105","100","105","105","105","100","105","110","105","105","105","115","105","115"]},"Classifying packets  into flows can aid hardware and\/or software of network nodes  to implement a number of advanced network services including: service level agreement (\u201cSLA\u201d) monitoring, traffic engineering, security, billing tracking, quality of service (\u201cQoS\u201d), generating and maintaining statistical data, and the like. Forwarding packets  (also referred to as Internet Packet (\u201cIP\u201d) forwarding) effectuates routing packets  from their source node to their destination node. Both of these tasks (classification and IP forwarding) may be implemented with reference to one or more lookup tables.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 2","b":["200","200","105","200","200","205","210","215","220","225","230","235","240","245","250","255","260"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 2","FIG. 2"],"b":"200"},"Receive block  is the initial stage that reads packets  from network , via a MAC or framer, or from a switch fabric. Receive block  temporarily stores packets  into a receive buffer. Often times packets  are segmented prior to transmission over network  into packet segments. Since packets typically are processed as a complete packet, and not segments, re-assembly block  reassembles the packet segments, stores them into memory (e.g., DRAM), and generates a packet descriptor for local processing. Classify block  is the stage where packets  are inspected to determine the action to be taken on the packet by assigning packets  to flows. Classification may be executed by inspecting subfields of packet  (e.g., source address field, destination address field, destination port field, source port field, protocol field, etc.) and using the values of these fields as an index key into classification tables (e.g., lookup tables ) to retrieve a corresponding rule to apply to packet  (e.g., quality of service to apply, etc). After packets  are classified, forwarding block  may inspect the destination address to determine the next hop and corresponding output port through which packets  should be forwarded. In one embodiment, forwarding block  may use the destination address as an index key into routing tables (e.g., lookup tables ) to retrieve a corresponding next hop and output port. Flow manager  may execute a variety of functions on packets  dependent upon the flow to which each packet  was assigned by classify block . For example, flow manager  may perform metering and statistics functions, congestion management, and the like.","During the receive processing stages, a packet is reassembled from several smaller segments, classified, then forwarded. Assuming it passes through the metering and congesting avoidance stages without being dropped, the packet is ready for transmit stage processing. Queue manager  organizes (e.g., enqueues) packets  into queues according to a transmit schedule generated by TX scheduler . When a queued packet  is ready for transmission according to the transmit schedule, queue manager  dequeues the packet and provides the packet descriptor to TX block . TX block  uses the packet descriptor to retrieve buffered packets  from memory and transmit them out of network node .","As previously mentioned, one or both of classify block  and forwarding block  may refer to lookup tables  to perform their respective functions. In one embodiment, table APIs  provide a unified and shared point of access to lookup tables . Tables APIs  publish a unified set of functions that may be shared by classify block , forwarding block , or other entities to access lookup tables . For example, some of these unified functions may include a seek, find, or lookup function, a create function, a modify function, or a delete function. Other more specialized functions may be generated for point-to-point flows, connection orientated flows, and the like.","In order to provide access to a variety of lookup tables  having a possible variety of sizes, formats, and locations in memory, table APIs  refer to DTDs . In one embodiment, each lookup table  has an associated DTD  to describe format, size, location, and other information about itself. Accordingly, in one embodiment there is a one-to-one relationship between lookup tables  and DTDs . DTDs  provide table APIs  with the information to tailor the unified functions to accommodate the differences between lookup tables .","In one embodiment, table APIs  are software functions that may be part of a modularized table management library. This library would provide the user with functionality to operate on different kinds of tables (e.g., lookup tables ) through similar looking unified interfaces. With the help of DTDs , the table management library can be integrated into an operating system or a firmware subsystem running on a control processor of a network processor or other hardware system. With the functionality provided by table APIs  and DTDs , rather than having dedicated table management functions for each lookup table  (whose functions can be more or less similar in a network processing environment), lookup tables  can be used as parameters to these universal table management functions and generic operations (e.g., lookup, classify, modify, add, delete, etc.) can be performed on lookup tables  by interpreting DTDs  for each lookup table . Besides providing management functions for lookup tables , table APIs  may provide interfaces to manage and interpret DTDs  as well.","Conventionally, since lookup tables  may be designed by different developers for a variety of different purposes, the developers of lookup tables would also develop a unique set of functions tailored specifically for accessing each lookup table. However, not only does developing multiple unshared access functions for lookup tables incur redundant development costs, but the memory footprint consumed by these independent functions is wasteful.","Table manager  manages DTDs  and lookup tables . For example, when classify block  or forwarding block  modifies one of lookup tables , table manager  may update its corresponding DTD  to ensure the modification is reflected in the corresponding DTD . When a new lookup table  is created, table manager  is responsible for automatically creating a new corresponding DTD . Similarly, if one of lookup tables  is deleted, table manager  is responsible for deleting its corresponding DTD . In one embodiment, tables APIs  are incorporated within table manager  and classify block , forwarding block , or other entities access lookup tables  via the APIs published from table manager , itself. In this case, one of the important functions implemented by table manager  would be publishing the lookup function for finding entries within lookup tables  to a variety of client processes wishing to access lookup tables .","Although embodiments of the present invention are described primarily in relation to classification and forwarding as they related to network processing, it should be appreciated that implementation of DTDs  for accessing tables in different contexts and environments are contemplated. For example, tables may be used for accessing databases and therefore DTDs  may be generated for unified access to database tables.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIGS. 3A and 3B","FIG. 3A","FIG. 3B"],"b":["300","300"]},"As illustrated, routing table A includes four fields  to  (i.e., destination address, address mask, next-hop address, interface number) and may include any number of entries (i.e., entries  through N) with values populated in each of the fields  to . Routing table A is only one example of an IPv4 routing table. It should be appreciate that other routing tables (e.g., IPv6 routing table) may include more or less fields containing the same or different data with different byte sizes for each field. As previously mentioned, forwarding block  may index into routing table A to determine the next-hop and output interface\/port number to forward packets  to their destinations. For example, forwarding block  may parse the destination address field of packets  and use this value to index into routing table A.","Classification table B illustrates an example 5-tuple classification table for IPv4. The typical quintuple or 5-tuple classification process is performed on TCP\/IP packets using the IP source address, IP destination address, TCP source port number, TCP destination port number, and the protocol ID extracted from packets . Values for these packet fields may be extracted from packets  and used to index into classification table B to determine what flow (e.g., field ) a packet belongs too. Of course, it should be appreciated that classification table B is merely intended for illustration and that other classification tables having different formats, fields, sizes, and numbers of entries may be used for classification purposes.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 4","b":["400","400","250","400","1","9","400","1","9","405","1","9"]},"The illustrated embodiment of DTD  includes the following descriptor fields: a table identifier (\u201cID\u201d) field , a number of fields field , one or more field size fields , a number of distributions field , a number of partitions field , one or more memory type fields , one or more start address fields , one or more number of entries fields , and zero or more number of partitions fields . The descriptor fields can be further logically broken into two portions\u2014portion A and portion B. Portion A includes information describing the format of a lookup table while portion B includes information describing the location or locations of the lookup table and its number of entries.","Descriptor field  includes information to identify and reference the corresponding lookup table of DTD  (e.g., one of lookup tables ). Descriptor field  includes information to identify the number of table fields in the corresponding lookup table. For example, routing table A includes four table fields while classification table B includes six table fields. Descriptor fields  each describe the size (e.g., number of bits or bytes) of a corresponding table field. Accordingly, if descriptor field  identifies that the lookup table contains four table fields, then column  will include four descriptor fields  each identifying the respective size of each table field.","Descriptor field  includes information to identify the number of memory types over which the lookup table is distributed. In this context, the term \u201cmemory type\u201d is used to connote a distinct memory unit. For example, dynamic random access memory (\u201cDRAM\u201d) is one memory type while synchronous DRAM (\u201cSDRAM\u201d) is another memory type. Descriptor field  includes information to identify whether the lookup table is stored in multiple discontinuous memory partitions within a single memory type, and in some cases discloses the actual number of discontinuous memory partitions. Accordingly, descriptor fields  and  enable DTD  to track portions (or entries) of a single lookup table that are distributed across multiple different memory types and even discontinuously stored in multiple partitions within a single memory type. This is illustrated in  where lookup table fragments  of a single lookup table are illustrated as being simultaneously stored in DRAM , SRAM , persistent storage , and scratch memory .","Descriptor fields  identify the actual memory types themselves in which the lookup table is distributed. In one embodiment, if descriptor field  identifies only one distribution, then column  will only include one descriptor field  identifying the single memory type. The number of descriptor fields  present in column  corresponds to the number of distributions identified in descriptor field . Descriptor fields  list the start address of each contiguous portion of the lookup table in the one or more memory types. Accordingly, if descriptor field  identifies multiple discontinuous partitions for the lookup table, while descriptor  identifies that the lookup table is located in only a single memory, then column  will list one start address for each memory partition identified in descriptor field . Descriptor fields  list the number of table entries extending from each start address listed in column .","Finally, descriptor fields  listed in column  are present in a special scenario, and otherwise not included in DTD . In the special scenario where descriptor field  identifies multiple distributions and descriptor field  identifies multiple partitions, then additional descriptor fields , illustrated in column , are added to DTD . Descriptor fields  identify the number of discontinuous memory partitions within each memory type identified in descriptor fields  of column . Accordingly, for each memory type listed in column  there will be a corresponding number of partitions listed in column .",{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIGS. 5A and 5B","b":["500","400"]},"In a process block , a table is generated (e.g., one of lookup tables ) and populated with entries. The table maybe created and the various entries stored in a single memory type as one contiguous block of memory, in a single memory type but located in multiple discontinuous memory partitions of the single memory type, distributed across multiple memory types but stored as a single contiguous memory partition within each memory type, or distributed across multiple memory types and stored in multiple discontinuously memory partitions of one or more of the memory types. Accordingly, embodiments of the invention provide flexibility in where and how the entries of a single table are stored.","In a process block , a new DTD  is created and associated with the new table. The DTD  is associated with the newly created table by populating descriptor field  (column ) with a table ID identifying the newly created table. In a process block , the number of table fields within the newly created table is written into descriptor field  (column ). Referring to  as examples, if DTD  corresponded to routing table A, then descriptor field  would be populated with a value indicating four table fields. If DTD  corresponded to classification table B, then descriptor field  would be populated with a value indicating six table fields.","In a process block , descriptor fields  (column ) are populated with values indicating the size of each table field of the newly created table. Accordingly, if descriptor field  identifies four table fields, then there will be four descriptor fields , each identifying the size of a corresponding table field. The values populated into descriptor fields  may identify the size of the corresponding table field in bits, bytes, words, long words, or some other incremental value.","In a process block , descriptor field  (column ) is populated with a value identifying the number of distributions for the table. As discussed above, DTD  enables a single lookup table to be distributed across multiple different memory types (e.g., SRAM, DRAM, flash, hard disk, etc.). For example, if a single table were partially stored in SRAM and partially stored in DRAM, then descriptor field  would be populated with a value indicating two distributions.","In a process block , descriptor field  (column ) is populated with a value identifying whether the table is currently stored in a single partition or multiple partitions. In some scenarios (described in detail below) the value populated in descriptor , not only identifies whether the table is stored in multiple partitions, but also identifies the number of partitions over which the table is spread.","As illustrated in the embodiment of process , the values populated into descriptor fields  and  can lead to four alternatives. Alternative \u2018A\u2019 includes a table that is neither distributed nor partitioned. In other words, the table is located in a single memory type within a single contiguous partition of memory. Alternative \u2018A\u2019 is identified by (# of distributions; # of partitions)=(1;1). In a process block  (see ), the single memory type in which the table is located is identified in descriptor field  (column ). Since alternative \u2018A\u2019 only includes one memory type, only a single descriptor field  is populated in column . In a process block , the start address of the table is identified in descriptor field  (column ). Since alternative \u2018A\u2019 only include one partition, only a single descriptor field  is populated in column . In a process block , the number of entries in the table is identified in descriptor field . Again, since alternative \u2018A\u2019 only includes one partition, only a single descriptor field  is populated with a number of entries value in column .","Alternative \u2018B\u2019 includes a table that is not distributed over multiple memory types, but is located in multiple, discontinuous partitions within a single memory type. Alternative \u2018B\u2019 is identified by (# of distributions; # of partitions)=(1;>1). In alternative \u2018B\u2019, descriptor field  (column ) identifies the number of partitions in which entries of the table are stored. Accordingly, the number of descriptor fields  and  in columns  and , respectively, will equal the number of partitions identified in descriptor field . In a process block , the single memory type in which the table is located is identified in descriptor field  (column ). In a process block , the start address of each portion of the table located in a different memory partition identified in descriptor field  is identified in corresponding descriptor fields  of column . In a process block , the number of entries in each table portion is identified in descriptor fields  (column ). Accordingly, there is one descriptor field  listing a number of entries for each start address identified in descriptor fields . In alternative \u2018B\u2019, there is a one-to-one correspondence between descriptor fields  in column  and descriptor fields  in column .","Alternative \u2018C\u2019 includes a table that is distributed over multiple memory types, but is located in only a single contiguous partition within each memory type. Alternative \u2018C\u2019 is identified by (# of distributions; # of partitions)=(>1;1). In alternative \u2018C\u2019, descriptor field  (column ) identifies the number of distributions or memory types over which the table is distributed. Accordingly, the number of descriptor fields  in column , will equal the number of distributions identified in descriptor field . In a process block , each of the memory types over which the table is distributed is identified in descriptor fields  (column ). In a process block , the start address of each distribution of the table located in a different memory type is identified in corresponding descriptor fields  of column . In a process block , the number of entries in each table distribution is identified in descriptor fields  (column ). Again, in alternative \u2018C\u2019, there is a one-to-one correspondence between descriptor fields  in column  and descriptor fields  in column .","Alternative \u2018D\u2019 is a special case which includes a table that is distributed over multiple memory types and includes one or more distributions having multiple discontinuous memory partitions. In the special case of alternative \u2018D\u2019, the number of partitions identified in descriptor field  (column ) need not identify the actual total number of partition for the table (though it can). Rather, it can simply list a value greater than one. In alternative \u2018D\u2019, the value listed in descriptor field  may merely be used to interpret and identify existence of the special case of alternative \u2018D\u2019. Alternative \u2018D\u2019 is identified by (# of distributions; # of partitions)=(>1;>1). In alternative \u2018D\u2019, additional descriptor fields  (column ) are used.","In a process block , each of the memory types over which the table is distributed is identified in descriptor fields  (column ). In a process block , the number of partitions within each memory type identified in column , are listed in corresponding descriptor fields . In one embodiment of alternative \u2018D\u2019, there is a one-to-one correspondence between descriptor fields  (column ) and descriptor fields  (column ). Accordingly, a particular memory type identified in column  may only store a single contiguous memory partition, in which case, a corresponding descriptor field  (column ) will list only one partition. However, other memory types identified in column  may include multiple discontinuous memory partitions, in which case, corresponding descriptor fields  (column ) will list the number of memory partitions for each memory type.","In a process block , the start address of each partition of the table identified in descriptor fields  (column ) is identified in a corresponding descriptor field  (column ). Accordingly, if the descriptor field  labeled \u201c# partitions()\u201d identifies three partitions within the memory type identified in descriptor field  labeled \u201cmem type()\u201d, then column  would include three descriptor fields  (e.g., start addr(), start addr(), and start addr ()) each listing a start address for a respective memory partition. Similarly, if descriptor field  labeled \u201c# partitions()\u201d identifies two partitions within the memory type identified in descriptor field  labeled \u201cmem type()\u201d, then column would include two additional descriptor fields  (e.g., start addr() and start addr()) each listing a start address for a respective memory partition.","In a process block , the number of table entries currently stored in each partition having an associated start address identified in column , is identified in descriptor fields  (column ). Again, in alternative \u2018D\u2019, there is a one-to-one correspondence between descriptor fields  in column  and descriptor fields  in column .  illustrates a table that summarizes possible values within the descriptor fields of DTD  and their respective interpretations, according to one embodiment of the invention.","Once the various descriptor fields of DTD  are populated, DTD  can be referenced to gain access to a distributed and partitioned lookup table. Furthermore, as entries are added, deleted, or modified, DTD  may be updated by table manager  to reflect the changes, allocated new memory, release unused memory, or otherwise.",{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIG. 6","FIG. 2"],"b":["600","600","115","600","605","610","615","1","16","620","625","630","635","640","625","645","650","655"]},"The components of NPU interoperate as follows. Multi-interconnect  may include multiple, independent internal buses for interconnecting the various subcomponents of NPU . Microengines  are multithreaded and provide the parallel processing power to process packets  at line rates. In one embodiment, a different one of microengines  may be assigned to execute each of the processing stages illustrated in . Control processor  managers the control plane of NPU  where it processes exception packets, executes chip configuration and control, manages routing tables (e.g., routing table A), and runs signaling stacks. Control processor  may also perform various data plane tasks, such as, terminating TCP\/IP, setting up network address translation, establishing IP Security (\u201cIPSec\u201d) connections, or the like. In one embodiment, control processor  is responsible for executing table manager  to create, update, or modify DTDs .","MSF interface  connects to multi-interconnect  and provides the primary interface for transferring packets  in\/out of NPU . MSF interface  may include one or more interfaces (e.g., industry standard interfaces such as UTOPIA, SPI-3, SPI-4.2, or the like) to connect to network  (e.g., local area network, wide area network, Internet, etc.). MSF interface  may also include one or more interfaces (e.g., SPI, CSIX, or the like) for coupling to a switch fabric . Since MSF interface  is located between the primary packet processing engines, microengiens , and network  and switch fabric , MSF interface  may include memory to buffer inbound and outbound packets .","SRAM controller  couples multi-interconnect  to SRAM . SRAM controller  provides a high speed, low latency connection to SRAM . SRAM  may typically be used for storing lookup tables , DTDs , buffer descriptors, free buffer lists, and the like. DRAM controller  couples multi-interconnect  to DRAM . Since DRAM is typically less expensive and lower speed than SRAM, DRAM  may be used as the bulk storage for buffering packets  while their descriptors are processed by microengines . DRAM  may also be used to store routing tables  and flow descriptors. I\/O controller  may couple multi-interconnect  to a variety of external devices\/media, such as a persistent storage device  (e.g., flash memory, disk drive, network drive, etc.). In one embodiment, I\/O controller  is a peripheral component interconnect (\u201cPCI\u201d) interface.","The illustrated embodiment of SHaC unit  includes scratch memory , a hash unit , and CSRs . In one embodiment, scratch memory  contains 16 kbytes of memory often used for microengine-to-microengine communication and local data storage. Hash unit  may execute 48-bit, 64-bit, or 128-bit hash calculations to support hash table lookup functions. In one embodiment, CSRs  include the bulk of the chip wide control and status registers for NPU .","As illustrated, a lookup table (e.g., one of lookup tables , A, or B) may be split up into fragments , which are stored in one or more memories including SRAM , DRAM , persistent storage , scratch memory , or otherwise. Furthermore, lookup table fragments  may be stored in one or more discontinuous memory partitions within a single memory device. The corresponding DTD  may be stored in a single memory device (e.g., SRAM ) where it may be referenced by table APIs , table manager , classify block , forwarding block , or other entities to gain access to the distributed and partitioned fragments  of the lookup table.","DTD  provides a single reference point in memory to determine the format and location of its corresponding lookup table. DTD  also enables flexibility, not only to store its corresponding lookup table in anyone of the memories listed above, but also to distribute a single lookup table across multiple memory types (e.g., SRAM , DRAM , persistent storage , scratch memory , etc.). Furthermore, since DTD  supports the addition of memory partitions to a lookup table, a minimum base amount of memory can be pre-allocated to a lookup table, and then subsequent memory partitions added to the lookup table as entries are added to the lookup table and additional memory consumed. Since DTD  includes a mechanism to describe the locations of discontinuous memory partitions, the additional memory fragments added to the lookup table need not be contiguous with the initial pre-allocated memory. This ability to allocate and release memory for lookup tables  on an \u201cas needed basis\u201d, enables a memory management technique reducing the need to wastefully pre-allocate large blocks of memory, which may or may not be used.","As entries are added, deleted, or modified within the lookup table, its corresponding DTD  can be updated in real-time to reflect the changes. If lookup table fragments  are moved from one memory type to another during operation of NPU , their movements can be tracked simply by updating DTD  in real-time. This ability to track the movement of lookup table fragments  from one memory type to another enables a sort of high speed caching mechanism where the most commonly access entries within a table are kept in higher speed (bandwidth), lower latency memories (e.g., SRAM  or scratch memory ), while the less frequently accessed entries of the lookup table are pushed out to the slower speed, higher latency memories (e.g., DRAM , persistent storage ).","The processes explained above are described in terms of computer software and hardware. The techniques described may constitute machine-executable instructions embodied within a machine (e.g., computer) readable medium, that when executed by a machine will cause the machine to perform the operations described. Additionally, the processes may be embodied within hardware, such as an application specific integrated circuit (\u201cASIC\u201d) or the like.","A machine-accessible medium includes any mechanism that provides (i.e., stores and\/or transmits) information in a form accessible by a machine (e.g., a computer, network device, personal digital assistant, manufacturing tool, any device with a set of one or more processors, etc.). For example, a machine-accessible medium includes recordable\/non-recordable media (e.g., read only memory (ROM), random access memory (RAM), magnetic disk storage media, optical storage media, flash memory devices, etc.).","The above description of illustrated embodiments of the invention, including what is described in the Abstract, is not intended to be exhaustive or to limit the invention to the precise forms disclosed. While specific embodiments of, and examples for, the invention are described herein for illustrative purposes, various modifications are possible within the scope of the invention, as those skilled in the relevant art will recognize.","These modifications can be made to the invention in light of the above detailed description. The terms used in the following claims should not be construed to limit the invention to the specific embodiments disclosed in the specification. Rather, the scope of the invention is to be determined entirely by the following claims, which are to be construed in accordance with established doctrines of claim interpretation."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Non-limiting and non-exhaustive embodiments of the invention are described with reference to the following figures, wherein like reference numerals refer to like parts throughout the various views unless otherwise specified.",{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5A"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5B"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
