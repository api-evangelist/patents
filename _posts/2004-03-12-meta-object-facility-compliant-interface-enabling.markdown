---
title: Meta Object Facility compliant interface enabling
abstract: Systems and methods for enabling a Meta Object Facility (MOF) compliant service for a metadata resource. The systems and methods employ a connector adapted to receive metadata from the metadata resource via a resource-specific application programming interface, and a metamodel repository storing one or more MOF models. The systems and methods further employ a persistence interface between the connector and metamodel repository. The persistence interface is configured to instantiate at least one MOF compliant service for the connector based on one of the MOF models in the metamodel repository.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07426523&OS=07426523&RS=07426523
owner: SAP AG
number: 07426523
owner_city: Walldorf
owner_country: DE
publication_date: 20040312
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This document relates to the sharing of metadata. More particularly, this document describes systems and methods for metadata integration in a heterogeneous software system landscape.","Metadata, the exchange of metadata and its programmatic access through APIs plays a central role in almost any software product. Metadata defines the structure and meaning of data objects and is used by applications to define, relate and manipulate objects. In order to make software products more interoperable, a general trend in industry is to base the access, exchange, and structure of metadata on common standards, i.e. common access application programming interfaces (APIs), common interchange formats and common metamodels.","The Java Metadata Interface (JMI) provides a common access API for metadata on a Java platform. JMI is based on the OMG's Meta Object Facility (MOF) and defines patterns that translate any MOF-based metamodel into a corresponding set of Java interfaces and thus a common programming model for accessing metadata. JMI defines a JMI Service as any system that provides a JMI-compliant API to its public metadata. The Java rendering of a Java API can be easily automated using the JMI patterns as it is completely generic and applicable to any metamodel that adheres to the MOF standard. However the JMI specification itself does not provide any patterns for implementing a JMI-compliant service.","Only a small percentage of available metadata is typically used by an application, however. As one consequence, not all associations of metadata to other metadata are needed at once. Prior solutions have employed techniques that first instantiate a complete set of JMI metadata objects from the underlying metadata resource, and then exchange this metadata using an XML metadata interchange (XMI)-formatted XML file. However, these techniques required that a large amount of metadata be extracted all at once for transport and manipulation.","This document discloses systems and methods for implementing a MOF-compliant service, such as a JMI service, on any metadata resource such as a relational database management system (RDBMS) or a data warehouse. In particular, these systems and methods support a dynamic exploration of a metadata resource, i.e. on-demand instantiation of JMI objects on an API, and completely generate implementing classes for the API independent of the specific protocol that is used to access the metadata store. This is particularly beneficial with large resources, e.g. a RDBMS that contains vast amount of metadata.","In one aspect, a system for enabling a MOF-compliant service for a metadata resource includes a connector adapted to receive metadata from the metadata resource via a resource-specific API, and a metamodel repository storing one or more MOF models. One exemplary system further includes a persistence interface between the connector and metamodel repository. The persistence interface is configured to instantiate at least one MOF compliant service for the connector based on one of the MOF models in the metamodel repository.","In another aspect, a method of enabling a MOF-compliant service for a metadata resource communicating via a resource-specific API includes the step of providing a connector to the resource-specific API. The connector is adapted to receive metadata from the metadata resource. An exemplary method further includes the steps of registering the connector and resource-specific API with a repository server, and mapping the resource-specific API with one or more MOF models stored in the repository server. Another exemplary method includes the step of instantiating the MOF compliant service according to one of the MOF models mapped to the resource-specific API.","The details of one or more embodiments are set forth in the accompanying drawings and the description below. Other features, objects, and advantages will be apparent from the description and drawings, and from the claims.","Like reference symbols in the various drawings indicate like elements.","This document describes a design pattern for MOF-compliant metadata service, such as a JMI service. Metamodels such as the CWM are loaded into a MOF-compliant MetaModel Repository (MMR). The MMR provides a service that translates the model into a Java API according to JMI code templates. The MMR furthermore generates a complete implementation of this Java API. The generated implementation of the model\/API contains only model-specific parts. Resource-specific parts are completely separated from the model-specific parts and encapsulated into a persistence component. The persistence component implements a callback interface that is called by the MMR during runtime. The implementation of a JMI service is thus reduced to the implementation of this persistence component.","Calls on methods of the generated JMI implementation are forwarded to an instance of the MMR. If those instances are not already contained in the associated MMR instance, the MMR has a callback interface with the persistence component for getting these missing object or association instances. This design pattern supports a dynamic and \u201con demand\u201d exploration of a metadata resource through a JMI service, without the need to instantiate at once the entire contents of the MMR when connecting to the resource.",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1","b":["100","101","101","110","100","110","102","110","106","102","106","102","104","106"]},"The metadata of the metadata resource  is defined by a metamodel, preferably compliant with the MOF. The system  provides a MOF-compliant service  for mapping and rendering of the metamodel via the resource-specific API  to an API (i.e. Java API) used by the application . The system  includes a connector  for integrating the metadata resource  with the application , by interfacing to both the MOF-compliant service  and the resource-specific API . The connector  includes code that implements the MOF-compliant service via consumption of the resource-specific API. In one example, the application server  is a J2EE application server, and the connector  is defined according to the J2EE Connector Architecture (JCA). Other implementations of the connector are possible depending on the software language, format, and\/or protocol employed by the application server .","The system  also includes a metamodel repository (MMR) , linked to the connector  through a persistence interface . The MMR  includes a repository server that stores models of the structure of data stored in the metadata resource, and provides instantiation and persistence of those models.",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 2","b":["1","214","202","210","204","210"]},"The MMR  utilizes a generic metadata layer M persistence layer  for the MOF-compliant models. The persistence depends on the type of models instantiated. For instance, MOF models do not necessarily have inherent a unique-name concept needed to map MOF instances with their metadata counterparts in the underlying datasource. Use of the M persistence layer also simplifies metadata caching with namespaces as associations. This is necessary if the datasource metadata API processing sequence differs considerably from the sequence of metadata access via the model.","The MMR  and datasource utilize a datasource persistence layer  for communication of the models. Through the datasource persistence layer , the datasource  fills a simplified metadata cache in the MMR , to feed the generic M persistence layer . This also provides assertion methods, i.e. to ensure requested metadata is available for the generic M persistence layer.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 3","b":["302","304","306","308"]},"At  the repository server executes a callback to the registered persistence providers. For example, the method selectM() is called. Then, at  the persistence provider selects objects via native resource API. At , the persistence provider instantiates the JMI objects via class proxies. Accordingly, this model-driven technique provides on-the-fly mapping of metadata to an application's requirements, and deferred instantiation of metadata associations. Additionally, the techniques described provide a live, as opposed to cached, metadata connection to the underlying metadata resource.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 4","b":["400","402","1","404","1","406","1","408","1"]},"At () the client application requests, via the client API of the connection, a set of root level objects of the model. In this case, the set of root level objects are tables. At (\u2032) the connector accessess the resource to retrieve the corresponding metadata through the native API provided by the resource. At (\u2033) the connector uses services provided by the repository server to instantiate with the metadata Table objects. At (\u2032\u2033) the repository server instantiates a table object, and at (\u2033\u2033) the connector returns a list of Table objects.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 5","b":["500","502","504","506","508"]},"At  the persistence provider ()connector again accesses the resource to retrieve the required metadata. At  the connector instantiates Column objects using the MMR services. At , the connector returns a List of Column objects to the MMR which in turn returns it to the Table object, that finally passes the list back to the client application.","Although a few embodiments have been described in detail above, other modifications are possible. The logic flows depicted in , or the timing sequences depicted in , do not require the particular sequence or timing shown to achieve desirable results. Other embodiments may be within the scope of the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["These and other aspects will now be described in detail with reference to the following drawings.",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
