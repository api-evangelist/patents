---
title: Method in a gaming machine for providing data recovery
abstract: Disclosed is a gaming machine capable of data restoration.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08631287&OS=08631287&RS=08631287
owner: Bally Gaming, Inc.
number: 08631287
owner_city: Las Vegas
owner_country: US
publication_date: 20130228
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCES TO RELATED APPLICATION(S)","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","EXAMPLE 1","Using NV1 Template Class","EXAMPLE 2","Using NV2Templale class","EXAMPLE 3","Using NV2 Class to Store and Recover Dynamic Structures"],"p":["The present application is a continuation of U.S. patent application Ser. No. 10\/794,430, entitled \u201cMETHOD AND SYSTEM FOR PROVIDING POWER-HIT TOLERANT STATE MACHINES AND DATA STORAGE,\u201d filed on Mar. 5, 2004, which claims the benefit of the filing date of US. Provisional Patent Application Ser. No. 60\/452,327, entitled \u201cGAMING BOARD SET AND GAMING KERNAL FOR GAME CABINETS,\u201d filed on Mar. 5, 2003, both of which are hereby incorporated by reference in their entirety for all purposes.","The present application is also related to U.S. patent application Ser. No. 10\/224,026, entitled \u201cGAMING BOARD SET AND GAMING KERNAL FOR GAME CABINETS,\u201d filed on Aug. 19, 2002, which claims the benefit of the filing date of provisional application 60\/313,743 filed on Aug. 20, 2001, entitled \u201cFORM FITTING UPGRADE BOARD SET FOR EXISTING GAME CABINETS,\u201d both of which are hereby incorporated by reference in their entirety for all purposes.","This invention pertains generally to gaming systems. More particularly, the present invention relates to a method and apparatus for providing high performance, incremental and large upgrades, and a consistent game development API for gaming cabinets, both existing and new.","Gaming industry cabinets are fairly standardized as to general configuration. This is partly due to the needs of the casinos, who want to fit the maximum number of gaming devices into a given amount of floor space. It is also due to the physical needs of players, who need a certain minimum amount of cabinet area in front of them to play the game while not crowding their fellow players on the next gaming machine. It is also due to the requirements of the game components, encompassing both regulated and non-regulated aspects. Game components include a video monitor or reels, input and output devices (buttons, network interface, voucher or ticket printers, and magnetic strip card readers are typical) together with a main processor board. The main processor board has interfaces to the various input and output devices, and has at least a processor and memory which enables gaming software to be installed and run on the processor board. In most gaming machines the processor board, power supply and other related mechanical and electrical elements are typically co-located near the base of the gaming machine. Disposed there above at proximately chest level of the player is the gaming display, such as the rotatable reel displays in a slot machine or a video monitor for video-based games.",{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1","b":["100","108","102","104","106","100","110"]},"The processor board, in addition to have physical mounts such as guides, rails, standoff mounts, board slots, board slides, or board tray, will further have cabinet electronic interfaces, typically at the back of the board (towards the front of the cabinet, from a player's perspective). Processor boards will typically have a set of multi-pin plugs or bus connectors that slide into mating plugs or bus connectors when the processor board is correctly seated in its mounts.",{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2","b":["200","202"]},"If the board needs work, the entire processor board is replaced. In addition to a replacement board from the manufacturer (in this case IGT\u00ae), there are commercially available replacement boards having the same or nearly the same features, speed, memory capacity, etc., from after market manufacturers. No matter where the board originates from, they follow the same configuration, that is, they consist of a single board that replaces the processor board supplied with the game having similar functionality and the same form. In addition to their physical similarity, they employ a monolithic software architecture; that is, the game-cabinet-specific operating system and specific game software are not a modular, layered design using modem software engineering practices. An example of an aftermarket replacement processor board for the IGT\u00ae Game King\u00ae gaming cabinet is or was sold by Happ Controls\u2122, 106 Garlisch Drive, Elk Grove, \/\/ . . . 60007. It has the same basic physical, electronic, and software architecture as the original.","Upgrade processor boards are also available for some games. The reason for considering upgrade boards is that it may be possible to run newer games in a cabinet already owned by a casino if improvements are made to processor speed, memory, graphic support chips, and other components. Game upgrades interface to some degree with the internal busses of the game cabinet, but require cabinet modifications. Currently available upgraded boards do not fit in the slot used by the original processor board; rather, they must be mounted elsewhere in the cabinet. In addition to requiring the accompanying mechanical fabrication and electrical work, the upgrade boards are a fixed upgrade. That is, if the configuration of the upgraded game itself needs to be upgraded a few years later, you have to purchase and install a completely new upgrade kit which requires going through the same installation problems that were encountered with the original upgrade. This is a significant deterrent to upgrading activity.","In addition, each proprietary processor board as well as upgraded game boards typically uses its own interface to the game software, requiring game rewrites each time a hardware upgrade occurs. This makes gradual or incremental game enhancement prohibitively expensive.","Thus, it would be desirable to provide a game processor that is usable in upgrades in existing cabinets, as well as usable for new game cabinets, that is more cost effective, is easier to install, provides for incremental upgrades itself, and provides more standard interfaces to the game development community.","Furthermore, most gaming systems today are embedded systems. Existing gaming systems typically contain limited resources such as processing power, memory, and program storage. Because of these limitations gaming platform programs have generally been implemented as one monolithic program, where all of the code is compiled into one executable program. Monolithic programs which drive the gaming system typically use interrupts to handle all real-time background activities. These interrupts are driven by the hardware components. The interrupts typically process time critical data and place this data or status information into memory variables which are shared by the main line code. Monolithic programs usually have a series of tasks that need to be performed in the main line code. These tasks might include acting on status information from interrupts, and processing player input and other events that drive the gaming application.","The problem with monolithic programs is that the program must be stored in one media device such as an EPROM, series of EPROMs acting as one media device, flash memory devices, or hard drive. Any modification to the monolithic program requires an update to the program storage device. This means that if a bug is found in a particular core feature, such as paying coins from the hopper, then all game programs must be rebuilt and re-released to the regulatory agencies for approval. A core feature modification such as this can require a gaming manufacturer to re-release hundreds of programs. Each program must be retested and approved by the regulatory agencies causing considerable delays and increased costs to the gaming manufacturer.","Another method that gaming manufacturers have performed in the past, is to separate the media that contains the game paytables from the media that contains the monolithic program. The game paytable is typically a table of pay rates that control how the gaming machine program plays and pays out wins. The benefit to this method is that regulatory agencies do not need to retest a paytable if it does not change. By making a modification to the monolithic program, the paytable media stays the same, allowing the regulators to assume the paytable will work as it did before.","While there are some benefits to this method, there are some very constraining drawbacks. First, the paytable media only contains data tables that drive the execution of the game program. The paytable media does not contain executable code. This means the monolithic game program must contain the core gaming system code along with the game code. The program must support all game code and game variations that can be driven by the paytable data media. It is not feasible for a game program to support hundreds of different game variations due to the limited resources of the embedded system. The paytable media can only be changed to effect changes in the game features or payouts that are already in the game program. It is also very difficult to continually maintain the core gaming modules along with all of the hundreds of game modules in the manufacturers library.","Hence, it would also be desirable to provide a gaming system architecture that solves the foregoing issues, as well as others, with respect to separation of operating system and game media.","In accordance with one embodiment of the present invention, a gaming machine includes a processor and a first memory operatively coupled to the processor, the memory equally divided into two memory banks, wherein each memory bank includes a variable that identifies the integrity of gaming data stored in the memory bank. The gaming machine further includes a second memory comprising software operable by the processor to execute an algorithm to recover corrupt gaming data in the first memory upon the variable indicating that data corruption has occurred.","In accordance with another embodiment of the invention, a gaming machine includes a processor and a set of peripherals operatively coupled to the processor by an input-output board. The gaming machine further includes a first memory storing operating software run by the processor to control the set of peripherals, the operating software comprising a non-gaming operating system and gaming-machine specific software. Logic to control the peripherals is primarily implemented by the gaming-machine specific software, not by the non-gaming operating system.","In accordance with another embodiment of the invention, the gaming machine further includes a second memory separate from the first memory, the second memory storing software specific to a game playable on the gaming machine.","In accordance with another embodiment of the invention, the gaming machine also includes a third memory separate from the first and second memories. The third memory is equally divided into two memory banks. Each memory bank includes a variable that indicates the integrity of gaming data stored in the memory bank. The gaming-machine specific software is configured to execute an algorithm to recover corrupt gaming data in the third memory upon the variable indicating that data corruption has occurred.","The third memory may be, for example, battery-backed memory, electrically-erasable programmable read-only memory (EEPROM) or a disk drive such as a hard disk. The critical gaming data stored in the third memory may be game meter or data logs.","Reference to the remaining portions of the specification, including the drawings and claims, will realize other features and advantages of the present invention. Further features and advantages of the present invention, as well as the structure and operation of various embodiments of the present invention, are described in detail below with respect to accompanying drawings, like reference numbers indicate identical or functionally similar elements.","The present invention in the form of one or more exemplary embodiments will now be described. Persons of ordinary skill in the art will realize that the following description of the present invention is illustrative only and not in any way limiting. Other embodiments of the invention will readily suggest themselves to such skilled persons having the benefit of this disclosure.","Referring to the drawings, for illustrative purposes the present invention is shown embodied in  through . It will be appreciated that the apparatus may vary as to configuration and as to details of the parts, and that the method may vary as to details, partitioning, and the order of acts in a process, without departing from the inventive concepts disclosed herein.","The present invention provides a new and dramatically more cost effective way for owners of aging games (hardware and software) to upgrade their existing cabinets to incorporate new hardware features and capabilities, as well manufacturers of new game cabinets to insure anew, novel, and easy to access upgrade paths to help stave off obsolescence in an industry where games often have lives of 6 months or even less.","The present invention provides for easy hardware and game-level software upgrades (user-level or application level software, from the operating system's viewpoint and when in a modular and layered software environment such as that provided by the present invention), not previously available. This includes being able to easily and economically upgrade hardware that incorporates faster CPUs, busses, etc., as well as incorporating new features such as Ethernet connectivity, stereo sound, and high speed high resolution graphics. In addition to the ease of upgrading hardware capabilities, the present invention further provides a game kernel which, by providing a callable, consistent user-interface API to the new hardware, makes game programming changes for the game-level programmers minimal after a hardware upgrade. It also provides for backward compatibility, enabling gaming machine owners to upgrade hardware, install the game kernel supporting the new hardware (described in more detail below, but fundamentally installing the libraries that support the added or new hardware capabilities), but wait to upgrade the game software until any later time.","In addition, the game kernel and two-piece processor board introduced in the present invention allows game-level programmers to design and build games using the same game application interface across multiple manufacturers' cabinets, resulting in a huge development savings when compared to the prior art.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 2","b":["200","204","206"]},"For the purposes of this disclosure, the processor board that came with the game cabinet as first delivered from the manufacturer to a customer will be called the OEM (Original Equipment Manufacturer) processor board. Further, the mounting system for the OEM processor board, in whatever form the game cabinet was delivered, is called the OEM mount, mounts, or mounting system. It is to be understood that the OEM mounts may be any implementation, including but not limited to slides, rack-mount, stand-offs, guides, blocks, rails, trays, etc. Whatever mounting system or mounts were used when the game was first manufactured is included in the definition of OEM mount(s).",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 3","b":["300","306"]},"Board  is an industry standard processor board, such as a Netra AX2200 from Sun Microsystems of California, or the SE440BX-2 or CAI80 from Intel Corporation of California. Both can be purchased in an industry standard form factors, and are configured to support at least one operating system (including embedded operating systems). By \u201cindustry standard form factors\u201d, this disclosure means any board form factor that has been agreed to by more than one board manufacturer. Such form factors typically have publicly available specifications, often using an industry funded organization to keep the specifications. One such organization is the Desktop Form Factors Organization, which may be found at www.formfactors.org. Examples of form factors whose specifications may be found there include the ATX, MicroATX, NLX, and FIexATX. There are other industry standard form factors as well. In addition, there are other specifications that are understood to be a consideration in the industry and in the selection of an industry standard form factor for use in the current invention, but are not explicitly discussed in this disclosure. One such consideration is height. Older rack mounted systems might have been based on 4U or 6U racks, with boards having a larger perimeter measurement than desktop form factors. Now, manufacturers are targeting 2U or even IU racks. Because it is generally the case that height is not an issue in pre-existing game cabinets, height considerations (as well as some other form factors) are not explicitly discussed herein. However, it is to be understood that should such considerations become necessary, all such considerations are included in the description of \u201cform factors\u201d as used herein. Any board having at least a CPU or a CPU socket, having any industry standard form factor, and being designed to be a system in the sense of enabling at least one operating system (including an embedded operating system) to run on it, will be referred to as processor boards for the purposes of the disclosure.","Board  is a unique board created by Sierra Design Group (SDG) for the purposes of creating a form fitting and functionally compatible replacement processor board (when coupled with board ) for the OEM processor board found in game cabinets currently in use. The board set is also intended to be used in new gaming cabinets when new game cabinets are designed from the ground up with the board set of the present invention, with an I\/O adapter board designed specifically for the new cabinet. Existing game cabinets used with the present invention might be from IGT\u00ae, Bally\u00ae, WMS\u00ae, or other preeminent game manufacturers. Further, each of these game manufacturers is typically selling several game cabinets, each with their own processor board, at any given time. Board  is specially designed and manufactured for each targeted game cabinet, with board  and board  configured to form a plug-compatible, functionally compatible and functionally enhanced, and form-fit-compatible replacement processor board. As part of this plug-in compatibility, game cabinet interface connectors  mate directly with the plugs in the game cabinet for which the processor board is designed. Note that it may be the case that a subset of the pre-existing game cabinet's plugs (or pins in a plug) are used, where the unused plugs (or pins) do not mate to a compatible plug on the processor board set of the present invention. The processor board set is still plug compatible, however, because the remaining plugs (or pins) are designed to be functionally compatible with the subset they do interface with, with the unused plugs (or pins) being taken into consideration during the design of the processor board set such that there will be no interference with the other plugs (or pins), fully enabling a swap-fit.","Thus, it is to be understood that swap-fit does not imply identical connector mappings or identical connector configurations; rather, swap-fit means that the processor board set of the present invention replaces the OEM processor board in such a manner that is uses the OEM mounts, and interfaces to such existing plugs\/pins\/opto-isolators\/connectors\/connector-blocksIbus-connectors (collectively: connectors) that enables all player devices to be used in the existing game cabinet to be functionally connected to the processor board set of the present invention.","\u201cPlayer device\u201d and \u201cplayer devices\u201d are defined to mean any and all devices that a player may see, hear, touch, or feel. Some are passive (in the sense that a player only receives information from them, such as a video screen and speakers), while others are active (buttons, handles, levers, touchscreens, etc.). Both types are included when using the words \u201cplayer devises\u201d in general.","Boards such as  are called game cabinet adapter and functional enhancement boards, or I\/O adapter boards, for the purposes of this disclosure. A processor board coupled with an I\/O adapter board is called a two-board processor board set. Note that for certain applications, it may be the case that the applicable I\/O adapter board could be made that is an adapter board without additional functional enhancements, to fit an existing game cabinet. This is not expected to be a preferred embodiment, as the cost to provide enhancements (like addition communications ports) is small enough relative to the cost of the overall two-board set as to make the additional functionality well worth the incremental costs.","The creation of a replacement processor board made up of board  and board , or two-board processor board set, opens many optional upgrading and game enhancement paths for game box manufacturers, game developers, and casino owners. For example,  points to a portion of board  which incorporates stereo sound capabilities, including an amplifier to drive higher wattage speakers than found in a standard game cabinet. This allows the game software that is running on the two-board processor board set of the present invention (coupled with the gaming kernel), without any changes, to make use of stereo audio output. For best results, the standard mono speakers in the game cabinet should then be upgraded to stereo audio speakers; this can be easily done with the present invention by merely replacing the speakers with new ones. Now the game will suddenly have full stereo sound, able to drive speakers having significantly higher wattage ratings. If the speakers are not upgraded, both signals will be send to the standard plug into the existing game cabinet wiring and speakers, allowing the game to function exactly as before. This enables, at a later date as investment capitol becomes available (or if a new game requires stereo audio capabilities, especially helpful for use with sight impaired game players), the cabinet can be upgraded with new speakers and the stereo output is already available\u2014no further changes will be required. This one example shows how the two-board processor board set allows both hardware and software upgrades in a gradual manner, as investment capitol becomes available. This incremental upgrading capability, including the use of both hardware and software incremental upgrades, has heretofore been unavailable.","Returning now to board , a few of its major components are indicated such as processor chip  (a socketted Pentium 266 in one preferred embodiment), memory slot , and compact flash program storage .","Board , the I\/O adapter board, includes the functionality described below. Further, to see how board  looks in more detail and separated from board ,  shows an illustration of the I\/O adapter board  in its unpopulated state. The I\/O adapter board shown in  is designed for use with an industry standard CPU board having an ATX type form factor, and for use in a popular IGT\u00ae game cabinet, forming thereby a swap-fit replacement for the IGT\u00ae processor board that came with the game originally. The I\/O adapter and processor board provide significantly enhanced functional capabilities.","The functionality of the  adapter board may be grouped into two categories. The first category of functionality is that needed to provide, for each particular preexisting game cabinet, the unique optical or electronic interfaces between the game cabinet's existing apparatus and the new processor board. These interfaces will include both basic electronic or optical interfaces, accounting for differences in everything from voltage levels to power needs to basic signal propagation, up to any needed communications protocol translations or interfaces (all this will be very depending on each particular game cabinet and CPU board). In additional to supporting the needed base functionality, in one preferred embodiment each I\/O adapter board provides additional functionality and support not previously found in the game cabinet. A primary example of this added support would be an Ethernet connection, which may be used to provide supplemental network support to the game machines, or may be used to replace the older serial communications ports found in existing gaming cabinets. In addition to all this, of course, is simply the increased processing power available from the new processor board. In the case of the  adapter board for the IGT\u00ae game cabinet illustrated in , functionality includes the following.","Power to the processor board is supplied using voltage and power regulators adapted to use the +BV and +25V power supplies in the game cabinet, to supply regulated power. Four more com ports are supplied (in addition to the four supplied by the industry standard processor board) for a total of eight com ports. One com port is brought to the front of the processor board or tray where it may be used with an optional touchscreen controller.","A VGA port and a keyboard port are supplied in the  adapter board to allow a game independent monitor and input\/output device to be hooked up to the game cabinet for development, troubleshooting, and monitoring purposes. For this application, the VGA port is also used to drive the game cabinet's standard video monitor.","An Ethernet connection is provided that may be used in addition to, and eventually in place of, the standard game cabinet's serial port connection to RGCs or other gaming equipment, or the rest of the casino's networked infrastructure. The Ethernet may be used to provide two-level authentication, which further enables age verification and other capabilities as described in co-pending application Ser. No. 09\/908,878 entitled \u201cEnhanced Player Authentication Using Biometric Identification\u201d, incorporated herein by explicit reference. Further, the Ethernet connection may be used to enable the use of web-based interfaces between machines, both locally and remotely.","The IGT\u00ae game cabinet currently under discussion uses a proprietary serial multi-drop RS485-based communications channel for several devices on the same wire. The I\/O adapter board has been designed to have only the bill validator connected using this particular RS485 channel. Other devices are connected using other serial connectors built into the I\/O adapter board. Since other devices, such as touch-screen controllers, are controlled by other interface means provided by the replacement board, resulting in one device coupled to the original single serial line, there is no need for any type of multi-device communications protocol on the RS485 channel. With only a single device on the channel, any issues surrounding the use of a proprietary serial interface for multiple devices are avoided. The I\/O adapter board further provides an interface for the game cabinet's SENET circuitry (a readily available protocol), which interfaces to the display lights, player buttons, etc.","Further, the I\/O adapter board includes NVRAM with power management and a battery backup to save any needed game device state in the event of a power loss.","Additionally, the I\/O adapter board may be reconfigured in the future, and replaced as an individual item separately from the processor board, to incorporate any additional functionality that is needed by newer games, new markets, or newer player input\/output devices. Examples include but are not limited to better graphics, better sound, interactive web capabilities using a high speed network connection such as 100 MB Ethernet, multiple game support, audio support for players with limited eyesight capabilities, and newer, more interactive player I\/O devices. The same concept holds true of the processor (or CPU) board. The CPU board may be replaced separately from the I\/O adapter board. This allows very economical upgrades of the game cabinet to be carried out in those situations where a new CPU board may be all that is needed to support, for example, games requiring a higher performance CPU but nothing else.","Additionally, if the CPU board ever fails, the replacement is significantly less expensive than the older proprietary boards. Not only that, this avoids the problem of finding replacements for aging electronics. Because the two-board processor board set of the present invention uses an industry standard form and function, if existing CPUs, busses, etc., become unavailable (which can happen quickly, given that many designs have a total life span of less than two years now) the game may be kept in operation by replacing the CPU board, or both the I\/O adapter board and CPU board. This circumvents the problem of finding replacement electronic components of an older board that are no longer being manufactured.","This further addresses the very significant issue of obsolescing OEM boards. In the high tech industry, after a board product has been out a few years, it becomes increasingly likely that at least some, if not most, of the boards components (chips) will gradually become unavailable. When this happens, it sometimes becomes impossible to continue manufacturing the same OEM boards as replacements for failed boards, even if the original game cabinet manufacturer wanted to continue to supply parts (and many do not, after a certain point in time). The OEM is now faced with re-engineering a new replacement CPU board for an older, low-demand game cabinet. That will rarely ever be done. The two-board processor board set addresses this problem by allowing the I\/O adapter board to be produced relatively inexpensively, providing continuing life of older game cabinets through the use of standard form-factor CPU boards with the I\/O adapter board.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 5","b":["500","502"]},"There are three layers: the two-board processor board set (hardware); the Linux operating system; and, the game kernel layer (having the game manager therein). The third layer executes at the user level, and itself contains a major component called the I\/O Board Server. Note the unique architecture of the gaming kernel: ordinarily, the software identified as the I\/O Board Server would be inside the Linux kernel as drivers and controllers. It was decided that as many functions normally found in a UNIX (in this case, Linux) kernel would be brought to the user level as possible. In a multi-user or non-dedicated environment, this would cause performance problems and possibly security problems. It has been discovered that in a gaming machine, those risks are manageable. Performance is maintained due to the control of overall system resource drains in a dedicated environment, coupled with ability to choose a suitably fast processor as part of the two-board processor board set. Additionally, gaming software is highly regulated so the ordinary security concerns one would find in an open user environment (or where uncontrolled applications may be run) does not exist in gaming machines. Game application software is well behaved, creating a benign environment as far as attacks from installed software are concerned. To properly set the bounds of game application software (making integrity checking easier), all game applications interact with the gaming kernel using a single AP\/\/n the game manager. This enables game applications to make use of a well-defined, consistent interface as well as making access points to the gaming kernel controlled, where overall access is controlled using separate processes.","The game manager parses the incoming command stream and, when a command dealing with I\/O comes in, it is sent to the applicable library routine (the actual mechanisms used are the UNIX or Linux IPC capabilities). The library routine decides what it needs from a device, and sends commands to the I\/O Board Server (arrow ). Note that a few specific drivers are still in the UNIX\/Linux kernel, shown as those below line . These are built-in, primitive, or privileged drivers that were (i) general (ii) kept to a minimum and (iii) were easier to leave than extract. In such cases, the low-level communications is handled within UNIX or Linux and the contents passed to the library routines.","Thus, in a few cases library routines will interact with drivers inside the operating system which is why arrow  is shown as having three directions (between library utilities and the I\/O Board Server, or between library utilities and certain drivers in the operating system). No matter which path is taken, the \u201csmarts\u201d needed to work with each device is coded into modules in the user layer of the diagram. The operating system is kept is simple, stripped down, and common across as many platforms as possible. It is the library utilities and user-level drivers that change for each two-board processor board set, as dictated by the game cabinet or game machine in which it will run. Thus, each game cabinet or game machine will have an industry standard processor board connected to a unique, relatively dumb, and as inexpensive as possible I\/O adapter board, plus a gaming kernel which will have the game-machine-unique library routines and I\/O Board Server components needed to enable game applications to interact with the game machine (game cabinet). Note that these differences will be invisible to the game application software with the exception of certain functional differences (i.e., if a box or cabinet has stereo sound, the game application will be able make use of the API to use the capability over that of a cabinet having traditional monaural sound).","Examples of the \u201csmarts\u201d built in to user-level code of the present invention includes the following. One example is using the I\/O library to write data to the gaming machine EEPROM, which is located in the gaming machine cabinet and holds meter storage that must be kept even in the event of power failure. The game manager calls the I\/O library function to write data to the EEPROM. The I\/O Board Server receives the request and starts a low priority thread within the server to write the data. This thread uses a sequence of 8 bit command and data writes to the EEPROM device to write the appropriate data in the proper location within the device. Any errors detected will be sent as IPC messages to the game manager. All of this processing is asynchronous.","Another example is the button module within the I\/O Board Server, which pools (or is sent) the state of buttons every 2 ms. These inputs are debounced by keeping a history of input samples. Certain sequences of samples are required to detect the button was pressed, in which case the I\/O Board Server sends an IPC event to the game manager that a button was pressed or released. For some machines with intelligent distributed I\/O which debounces the buttons, the button module may be able to communicate with the remote intelligent button processor to get the button events and relay them to the game manager via IPC messages.","Another example is the use of the I\/O library for payout requests from the game application. The I\/O Board Server must start the hopper motor, constantly monitor the coin sensing lines of the hopper, debounce them, and send an IPC message to the game manager when each coin is paid.","The I\/O library interface has been designed so that the I\/O Board Server does not require novram data storage. All novram state flow is programmed in the game manager level (using library utilities) so that it is consistent across all platforms. The I\/O Board Server also contains intelligence and a lot of state information. The intelligence needed to interface with each device is found in the combination of I\/O library routines and the I\/O Board Server.","The use of a UNIX-based operating system allows the game developers interfacing to the gaming kernel to use any of a number of standard development tools and environments available for the UNIX or Linux OS. This is a huge win over the prior art in casino game development, which required game developers to use low level, proprietary interfaces for their games. The use of proprietary, low level interfaces in turn requires significant time and engineering investments for each game upgrade, hardware upgrade, or feature upgrade. The present invention is a very significant step in reducing both development costs and enhancement costs as viewed by game developers. In particular, this will enable smaller game developers to reasonably compete with the larger, more established game developers by significantly reducing engineering time using a UNIX or Linux environment. Savings include but are not limited to reduced development time, reduced development costs, and the ability to use the gaming kernel and its two-board processor board set to market a single game for many game cabinets, spanning multiple game machine vendors. This is a remarkable and significant breakthrough for the gaming industry, being an additional breakthrough beyond simply providing a standard Unix-like interface to a game developer.","Some gaming kernel components are next described. The gaming kernel of the present invention is also called the Alpha Game Kit kernel or Alpha Game Kit game kernel, abbreviated AGK game kernel or AGK kernel.","The Game Manager provides the interface into the AGK game kernel, providing consistent, predictable, and backwards compatible calling methods, syntax, and capabilities (game application API). This enables the game developer to be free of dealing directly with the hardware, including the freedom to not have to deal with low-level drivers as well as the freedom to not have to program lower level managers (although lower level managers may be accessible through the Game Manager's interface if a programmer has the need). In addition the freedom derived from not having to deal with the hardware level drivers and the freedom of having consistent, callable, object oriented interfaces to software managers of those components (drivers), the game manager provides access to a set of upper level managers also having the advantages of consistent callable, object oriented interfaces, and further providing the types and kinds of base functionality required in all casino-type games. The game manager, providing all the advantages of its consistent and richly functional interface as support by the rest of the AGK kernel, thus provides the game developer with a multitude of advantages.","The Game Manager has several objects within itself, including an Initialization object. The Initialization object performs the initialization of the entire game machine, including other objects, after the game manager has started its internal objects and servers in appropriated order. In order to carry out this function, the Configuration Manager is amongst the first objects to be started; the Configuration manager has data needed to initialize (correctly configure) other objects or servers.","After the game is brought up (initialized) into a known state, the Game Manager checks the configuration and then brings either a game or a menu object. The game or menu object completes the setup required for the application to function, including but not limited to setting up needed callbacks for events that are handled by the event manager, after which control is passed back to the Game Manager. The Game Manager now calls the game application to start running; the game machine is made available for player use.","While the game application is running (during game play, typically), the application continues to make use of the Game Manager. In addition to making function calls to invoke functionality found in the AGK kernel, the application will receive, using the callbacks set up during initialization and configuration, event notification and related data. Callback functionality is suspending if an internal error occurs (\u201cTilt event\u201d) or if a call attendant mode is entered. When this state is cleared, event flow continues.","In a multi-game or menu-driven environment, the event callbacks set by a game application during its initialization are typically cleared between applications. The next application, as part of its initialization sequence, sets any needed callbacks. This would occur, for example, when a player ends one game, invokes a menu (callbacks cleared and reset), then invokes a different game (callbacks cleared and reset).","The Game Event Log Manager is to provide, at the least, a logging or logger base class, enabling other logging objects to be derived from this base object. The logger (logger object) is a generic logger; that is, it is not aware of the contents of logged messages and events. The Log Manager's job is to log events in NVRAM event log space. The size of the space if fixed, although the size of the logged event is not. When the event space or log space fills up, a preferred embodiment will delete the oldest logged event (each logged event will have a time\/date stamp, as well as other needed information such as length), providing space to record the new event. In this embodiment the latest events will be found in NVRAM log space, regardless of their relative importance. Further provided is the capability to read the stored logs for event review.","The Meter Manager manages the various meters embodied in the AGK kernel. This includes the accounting information for the game machine and game play. There are hard meters (counters) and soft meters; the soft meters are stored in NVRAM to prevent loss. Further, a backup copy of the soft meters is stored in EEPROM. In one preferred embodiment, the Meter Manager receives its initialization data for the meters, during startup, from the Configuration (Config) Manager. While running, the Cash In and Cash Out Managers call the Meter Manager's update functions to update the meters, and the Meter Manager will, on occasion, create backup copies of the soft meters by storing the soft meters readings in EEPROM; this is accomplished by calling and using the EEPROM Manager.","The Progressive Manager manages progressive games playable from the game machine. It receives a list of progressive links and options from the Config Manager on startup; the Progressive Manager further registers progressive event codes (\u201cevents\u201d) and associated callback functions with the Event Manager to enable the proper handling of progressive events during game play, further involving other components such as Com Manager, perhaps the Meters Manager, and any other associated or needed modules, or upper or lower level managers. This enables the game application to make use of a progressives known to the game machine via the network in the casino; the progressives may be local to the casino or may extend beyond the casino (this will be up to the casino and its policies).","The Event Manager object is generic, like the Log Manager. The Event Manager does not have any knowledge of the meaning of events; rather, its purpose is to handle events. The Event Manager is driven by its users; that is, it records events as passed to it by other processes, and then uses its callback lists so that any process known to the Event Manager and having registered a callback event number that matches the event number given to the Event Manager by the event origination process, will be signaled (\u201ccalled\u201d). Each event contains fields as needed for event management, including as needed and designed, a date\/time stamp, length field, an event code, and event contents.","The Focus Manager object correlates which process has control of which focus items. During game play, objects can request a focus event, providing a callback function with the call. This includes the ability to specify lost focus and regained focus events. In one embodiment, the Focus Manager uses a FIFO list when prioritizing which calling process gets their callback functions handled relating to a specific focus item.","The Tilt Manager is an object that receives a list of errors (if any) from the Configuration Manager at initialization, and during play from processes, managers, drivers, etc. that generate errors. The Tilt Manager watches the overall state of the game, and if a condition or set of conditions occur that warrant it, a tilt message is sent to the game application. The game application then suspends play, resumes play, or otherwise responds to the tilt message as needed.","The Random Number Generator Manager is provided to allow easy programming access to a random number generator (RNG), as a RNG is required in virtually all casino-style (gambling) games. The RNG Manager includes the capability of using multiple seeds by reading RNG seeds from NVRAM; this can be updated\/changed as required in those jurisdictions that require periodic seed updates.","The Credit Manager object manages the current state of credits (cash value or cash equivalent) in the game machine. The Cash In and Cash Out objects are the only objects that have read privileges into the Credit Manager; all other objects only have read capability into the public fields of the Credit Manager. The Credit Manager keeps the current state of, the credits available, including any available winnings, and further provides denomination conversion services.","The Cash Out Manager has the responsibility of configuring and managing monetary output devices. During initialization the Cash Out Manager, using data from the Configuration Manager, sets the cash out devices correctly and selects any selectable cash out denominations. During play, a game application may post a cash out event through the Event Manager (the same way all events are handled), and using the callback posted by the Cash Out Manager, the Cash Out Manager is informed of the event. The Cash Out Manager updates the Credit Object, updates its state in NVRAM, and sends an appropriate control message to the device manager that corresponds to the dispensing device. As the device dispenses dispensable media, there will typically be event messages being sent back and forth between the device and the Cash Out Manager until the dispensing finishes, after which the Cash Out Manager, having updated the Credit Manager and any other game state (such as some associated with the Meter Manager) that needs to be updated for this set of actions, sends a cash out completion event to the Event Manager and to the game application thereby.","The Cash In Manager functions similarly to the Cash Out Manager, only controlling, interfacing with, and taking care of actions associated with cashing in events, cash in devices, and associated meters and crediting.","Further details, including disclosure of the lower level fault handling and\/or processing, are included in the provisional from which this utility application receives date precedence, entitled \u201cForm Fitting Upgrade Board Set For Existing Game Cabinets\u201d and having No. 60\/313,743, said provisional being fully incorporated herein by explicit reference.","Various features of the present invention will now be described in further detail. In one exemplary aspect, the present invention provides a system having an inexpensive memory design and file system software that can reliably recover data after abrupt losses of power. Two aspects of this design deserve emphasis. First, the system recovers data sets, not just unrelated entries; second, the system performs this recovery automatically at the file system level, obviating the need for a special application that attempts recovery.","A \u201cdata set\u201d is one or more pieces of data that correspond to one another (database users would use the synonym \u201crecord\u201d to describe a data set). If part of a data set is written when power goes off, traditional, non-volatile memory can retrieve those parts that were written\u2014but cannot reveal that the data set is somehow corrupt. Note that the corruption is not due to a failure of the memory devices. Such corruption is caused by the computer stopping the write operation part way through the set due to the power interruption.","Applications trying to store precious data in non-volatile memory traditionally pre-assign memory locations to the data items that will be stored. For large or general-purpose applications, this approach becomes difficult to manage, even using files to help with the coordination of such assignments (XML, for instance). The system of the present invention uses file system software to provide access to the memory, thus allowing independent concerns to store their data in independent files. For devices that are released in a series of versions, the file system approach is less prone to version-to-version incompatibilities that can generate confusion for developers, users, and support personnel.","The following describes one possible implementation of the new design. In one implementation, the system uses one (1) Megabyte of memory in two (2) memory chips, 64-byte blocks, the ext3 as a model for the file system on a Unix-like computer, and checksums for error detection. The system can accommodate one or more memory chips, other file system designs, non-Unix operating systems, and CRCs etc. for error detection. For the sake of brevity, the overall system is simply referred to as \u2018Nvram\u201d, though its recovery capabilities are much stronger than traditional nvram (non-volatile random access memory).","Nvram is redundant, meaning that the physical memory is divided into two (2) equal-sized \u201cbanks\u201d which keep identical copies of the data. Placed at regular intervals in each bank are special \u201cerror detection numbers\u201d, for example \u201cchecksums\u201d, which are used to tell if its area of the memory contains an error, perhaps caused by the power going out while data was being written. When a data set is written to Nvram, the error detection value is not updated until the entire data set is completely written. This operation is then repeated for the redundant memory bank. If a power outage strikes midway through the write to the first bank, the corrupt state will be detected on power up and the partially written data will be discarded. If the power outage occurs during the writing of the second bank, that bank's data will be discarded and the data set, successfully written to the first bank, will become the system's only copy.","The recovery algorithm is embedded in the driver and is activated whenever a block of memory is read. When power is re-supplied, the startup logic \u201cmounts\u201d all file systems, including the Nvram file system. A part of the mount logic, inside the Nvram driver, causes all of Nvram memory to be read, thus executing the recovery algorithm on all of Nvram memory before any client program starts running. During every subsequent read, the same algorithm checks the integrity of the block being read and performs recovery if necessary.","In one exemplary aspect, the recovery algorithm operates as follows: (1) Determine if the driver was configured (at startup time) to treat physical memory as two (2) redundant banks. This configuration can be run if the applications do not need the extensive recovery protections. If configured for recoverable storage, go to step 3. (2) Using the block number supplied to the algorithm, compute the memory address of the block. Read that block and return it to the caller without any validation.  Using the block number supplied to the algorithm, compute the memory address of the block. This address is valid for either bank. Read that block from the first bank  Using the same address, read the corresponding block from the second bank.  Using the block number supplied to the algorithm, compute the location of the error detection value for this block. Read one error detection value from the first bank  Read the error detection value from the second bank.  For the block read in step (3), compute the error detection value. Compare the computed value to the value read in step (5).  For the block read in step (4), compute the error detection value. Compare to the computed value read in step (6).  If there are no discrepancies found in steps (7) and (8), return to the caller with the data read in step (3).  If there are discrepancies found in steps (7) and (8), return an \u201cunrecoverable memory error\u201d to the operating system\/file system.  If a discrepancy was found only in step (7), representing an error in the first bank, copy the data from the second bank into the memory area for this block in the first bank.  If a discrepancy was found only in step (8), representing an error in the second bank, copy the data from the first bank into the memory area for this block in the second bank.","Internal Structure","In one implementation, the Nvram memory has a total of one (1) Megabyte of memory which is 1048576 bytes. This is also 1024 Kilobytes, so each bank of Nvram is said to be \u201c512 K\u201d in size. Each \u201cK\u201d (kilobyte) is 1024 bytes. Each bank of Nvram can be physically implemented with its own memory chip, adding some protection against simple memory chip failures.","An important internal unit in Nvram is the \u201cBlock\u201d which contains 64 bytes. Any file or directory will have an integral number of such Blocks. Their \u201cBlock Number\u201d, sometimes called a \u201cBlock offset\u201d, within its bank, identifies the Blocks. The numbering convention for all memory-related concerns begins at \u20180\u2019. Thus, the two (2) Nvram banks are numbered \u20180\u2019 and \u20181\u2019 and the third Block in a bank would be called \u201cBlock 2\u201d.","Another important unit in the Nvram design is the \u201cBlock Set\u201d.  is a simplified diagram illustrating the concept of the \u201cBlock Set\u201d according to an exemplary aspect of the present invention. Each set of 32 contiguous blocks, starting at block 0, forms a \u201cBlock Set\u201d. The last block in such a set contains 32 2-byte checksums, each corresponding to one of the blocks within that BlockSet. Thus, when the first block of a BlockSet is (re)written, its checksum is calculated and stored in the first two bytes of block devoted to the checksums for that Block Set. When the second block of that Block Set is changed, its checksum is recalculated and stored in the second 2-byte area of the same checksum block. The checksum block itself theoretically has a pair of bytes allocated for its checksum but Nvram software does not checksum the checksum block. Adding all the bytes within a block forms a checksum. It is stored and compared as a 2-byte value.","File System Structures","The \u201cBlock Set\u201d and checksum structure, previously described, is at a more fundamental level than the file system. A \u201cfree block\u201d in the following will mean one of the 31 blocks of each Block Set which is not charged with storing checksums.","The file system type chosen for this example has immutable assignments for the first 3 blocks of each bank. Block 0 is traditionally the \u201cboot block\u201d of any file system. Since our example does not boot from this file system, the contents of this block are undefined. Block 1 is traditionally the \u201csuper block\u201d which contains an identifier, called \u201cMagic\u201d, which identifies the file system and two (2) other entries describing the free space (the blocks not yet assigned to files or directories). The free space will be described later but the super block entries are: \u201cMagic\u201d which contains the letters \u201cNVFS\u201d, \u201cFree\u201d which contains the Block Number of the free list, and \u201cfreeCount\u201d which represents the number of free Blocks. Block 2 is the start of the directory for the \u201croot\u201d file system (\u201c\/\u201d in Unix parlance). Starting at Block 2, every (non checksum-related) block in Nvram is in a file, a directory, or is free space, available for use in a later file or directory.","Structure of a File","A file starts with a very special block containing all its critical information. This special block's \u201cBlock Number\u201d is measured relative to the start of its bank and is given several names: the file's \u201clocation\u201d, the file's \u201cInode\u201d, and the file's \u201cfirst block\u201d.  is a simplified block diagram illustrating a file structure according to one exemplary aspect of the present invention. The table below illustrates the file contents.",{"@attributes":{"id":"p-0097","num":"0096"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Offset","# of bytes","Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","2","Type","File's type"]},{"entry":["2","2","Mode","File's mode"]},{"entry":["4","2","Uid","User ID. Always 0."]},{"entry":["6","2","Gid","Group ID. Always 0."]},{"entry":["8","4","cTime","Time of file creation"]},{"entry":["12","4","mTime","Time of last modification"]},{"entry":["16","4","Size","Number of bytes in file"]},{"entry":["20","2","blockCount","Number of Blocks assigned to file"]},{"entry":["22","2","Data2","Block Number. See text and diagrams"]},{"entry":["24","2","Data3","Block Number. See text and diagrams"]},{"entry":["26","2","Data4","Block Number. See text and diagrams"]},{"entry":["28","36","Data1","A list of 18 Block Numbers. See text."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"Type\u2014the file types are defined in file nvram.h, with terms beginning with the string \u201cNVRAM_TYPE_\u201d. The useful ones are: \u20180\u2019 means it is unused; \u20181\u2019 means the file is a directory; \u20182\u2019 means the file is a regular file; \u20183\u2019 means the file is a (symbolic) link to another file.","Mode\u2014a number, composed of bits, which define the Read\/Write\/Execute properties of the file for the file's owner, the owner's group, and everyone else. See the Unix manual page for \u201cchmod\u201d. This typically has a value of 666 (octal. In hex this is ID6).","Times are given in the number of seconds elapsed since Jan. 1, 1970.","Data 1,2,3,4 entries contain the Block Numbers for the file's contents. Data1 is at \u201c1 level of indirection, Data2 at 2 levels, and so on. The meaning of \u201cindirection\u201d is best defined in the following diagrams.","Data1's first 2 bytes are the (node number of the Block containing the 1st 64 bytes of the file. Data1's 2nd 2 bytes are the (node for the file's 2nd 64 bytes and so on through the end of Data1. Having Block Numbers referring to contents, rather than the contents themselves, is called \u201cindirection\u201d (1 level).","Data2 has the Block Number of a block that contains 32 Block Numbers of file contents. This is said to be 2 levels of indirection.","Data3 has the BlockNumber of a block containing 32 BlockNumbers. Each of those blocks contains 32 Block Numbers identifying file content.","Data4 uses the same scheme, but with one additional level of indirection.","Files rarely require all the above levels. Data1 can completely describe the content locations for files up to 18*64 (1152) bytes in length. Data1 and Data2 can describe files up to 18*64+32*64 (3200) bytes in length.","Directory Structure","A directory is simply a file with special contents. Each entry is a fixed length and describes a single file; the entries are stored \u201cend-to-end\u201d. An entry has just two components, an (node and the file's name. The (node or, more properly, the \u201cInode Number\u201d for a file is the Block Number of the Inode structure shown above. The file's name is a sequence of Ascii characters terminated with a zero byte; thus, the file's name can be up to 61 bytes in length (64 byte block \u22122 byte Inode Number \u22121 byte for terminator=61).","Free Space","The free space list is rooted in the super block whose \u2018free\u2019 entry points to an Inode which contains the Data1, Data2, Data3, and Data4 values for a \u201cfile\u201d whose blocks are taken whenever a real file needs blocks.","Note that two different directory entries are able to identify the same Inode. This is called a \u201clink\u201d or, sometimes a \u201chard link\u201d. The hard linked files have contents within the Nvram system and are thus protected by the Nvram checksums and redundancy.","Identifying Data Sets","At a higher level than the file system, the software defines two (2) ways of storing information, called \u201cNV1 objects\u201d and \u201cNV2 objects\u201d. When a program writes a 100 byte NV1 object, the result is a file of 100 data bytes. When a program writes a 100 byte NV2 object, the result is a file of 200 data bytes; there are 2 copies of the image in the file. This redundancy, coupled with the bank 0\/1 redundancy means there are 4 copies of the NV2 information. In a file made by NV2 techniques, the second 100 bytes of the example would immediately follow the first 100 bytes; that is, the images are stored \u201cend-to-end\u201d. For someone examining the contents of Nvram, it is important to know whether the file in question is of type NV1 or NV2. The NV2 object contains a header of 24 bytes, followed by the first copy of the data, followed by the second copy of the data. In one implementation, the NV2 object header is declared as follows:",{"@attributes":{"id":"p-0111","num":"0110"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"struct Heir","\/\/ Header structure at beginning of file."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{","\u2003\/\/ Data follows the Heir."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"unsigned char state;","\/\/ State of data."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"unsigned char reserved;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"unsigned long size 1;","\/\/ Size of data chunk1."]},{"entry":[{},"unsigned long size2;","\/\/ Size of data chunk2."]},{"entry":[{},"unsigned long offset2;","\/\/ Offset oData for chunk2."]},{"entry":[{},"unsigned long chksum1;","\/\/ Checksum ofdata1"]},{"entry":[{},"unsigned long chksum2;","\/\/ Checksum of data2"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The system of the present invention utilizes the following design strategy in providing power hit tolerance. Divide the process of saving the data (records and\/or file) into steps or stages, called \u201cstates\u201d. Make and store a variable, typically called a \u201cstate variable\u201d, which identifies the processing step or state at any time. If power is interrupted, and this state variable is also stored in a recoverable manner, then the recovery software knows what condition (state) the file and record data is in. Knowing this, the recovery software can apply state-dependent algorithms to reconstruct the data, records and file. Implicit in this is that the states is chosen such that there is a recovery algorithm for each possible state.","The use of states, as described above, makes this approach a \u201cstate-machine\u201d and it allows the design to work even when power is being quickly removed and re-applied. If, on one short-lived powerup, only a partial recovery is made, then the state variable will only reflect the amount of recovery progress made.","The design also has to watch for catastrophic failure, where the NV storage no longer works, perhaps as a result of a power spike.","The following is terminology used herein:\n\n","The state variable can take on any of the possible meanings, which are generally represented by numbers, not names, in a typical implementation. These names though will make the following exposition easier to understand.\n\n","SetState(state number) is a procedure that writes \u201cstate number\u201d so that the recovery procedure is assured of reading a valid state value.","Algorithm for Saving Data","For the purpose of describing the algorithms, the write process begins when a program requests that a data record (or file) be written. The following is the pseudo code:",{"@attributes":{"id":"p-0119","num":"0132"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Save1 {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Set PowerhitFlag to NotHit"]},{"entry":[{},"Calculate Error Detection Number for the data to be written."]},{"entry":[{},"If the record or file is not increasing in size"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SetState(updating1)"]},{"entry":[{},"Store header (and checksum) in data area I"]},{"entry":[{},"Store the data in data area 1"]},{"entry":[{},"If caller wants to use Save1 and Save2 as an indivisible pair"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Only keep a local copy of state \u2018new1\u2019"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Otherwise record the state in NV storage."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"SetState(new1)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Otherwise if the record or file is increasing in size"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SetState(updating2)"]},{"entry":[{},"Store header (and checksum) in data area 2"]},{"entry":[{},"Store the data in data area 2"]},{"entry":[{},"If caller wants to use Save1 and Save2 as an indivisible pair"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Only keep a local copy of state \u2018new2\u2019"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Otherwise record the state in NV storage."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"SetState(new2)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"Save2{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"If state is new2"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SetState(copy2to1)"]},{"entry":[{},"Copy area 2 to area I on the NV storage"]},{"entry":[{},"SetState(Idle);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"If state is new1"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Set State(copy1to2)"]},{"entry":[{},"Copy area 1 to area 2 on the NV storage"]},{"entry":[{},"Set State(Idle);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"If PowerhitFlag equals Hit"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Run recovery algorithm (below)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"The recovery algorithm can be run at any point after the system has been re-powered and recovered basic functionality. This implementation embedded the recovery in the file Open routine so that the client software using the design did not have to control the recovery process. From the client software's standpoint, the computer starts up and provides files, as always, as though no power interruption occurred. Internally, however, the Open routine looked for and fixed any corruptions before the client software was able to use the data. Shown below is the pseudo code representing the salient parts of the recovery process.",{"@attributes":{"id":"p-0121","num":"0134"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Recover {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"read header from NV storage (checksum and state variable)"]},{"entry":[{},"read the redundant copies of data from NV storage."]},{"entry":[{},"if header contains \u2018impossible values\u2019, declare catastrophic failure"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"(no recovery is possible)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if state was Idle"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"calculate checksums for each copy of data"]},{"entry":[{},"compare the calculated checksums to those retrieved from"]},{"entry":[{},"NV storage."]},{"entry":[{},"If both data areas are bad, declare catastrophic failure (no"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"recovery is possible)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"If only one data area is bad, copy the good one over the bad"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"and return it to NV storage."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"If neither data area is bad and the 2 copies are identical,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"return it to the calling software as \u2018good\u2019"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"If neither data area is bad but the 2 copies are not identical,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"copy #1 over #2 in NV storage and return it to"]},{"entry":[{},"the calling software as \u2018good\u2019."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if state was updating 1 or copy2to1"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SetState(copy2to1)"]},{"entry":[{},"read the 2nd of2 redundant copies from NV storage"]},{"entry":[{},"write that data to the 1of the 2 redundant areas."]},{"entry":[{},"SetState(Idle)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if state was updating2 or copy1to2"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SetState(copy1to2)"]},{"entry":[{},"read the 1st of 2 redundant copies from NV storage"]},{"entry":[{},"write that data to the 2of the 2 redundant areas."]},{"entry":[{},"SetState(Idle)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if state was new1 or new2"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"calculate checksums for each copy of data"]},{"entry":[{},"compare the calculated checksums to those retrieved"]},{"entry":[{},"from NV storage."]},{"entry":[{},"If both data areas are bad, declare catastrophic failure (no"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"recovery is possible)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"If state is new1"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Return the 2area to the caller"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Otherwise"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Return the 1area to the caller"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"SetState(Idle)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Unless an error was reported earlier in this routine, return requested"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"data to caller."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"Non-volatile memory, novram or nvram, is required for maintaining critical data in gaming machines such as credits, meters, data logs, last game played, . . . etc. The following describes the novram library and how the game developer can use it to store critical data.","Architecture","In one implementation, Novram in the present invention is accomplished using a Dallas battery backed memory located on the personality I\/O board. A special Linux device driver has been written to make the battery-backed memory appear as an ordinary file system. Startup scripts mount this file system under the directory \/nvram. Any files or directories created under \/nvram\/* are stored in battery backed memory. Making novram appear as a normal file system makes it convenient for the developer to interrogate and maintain the contents with standard Linux tools without necessitating new proprietary tools to manipulate novram structures.","Writing to a battery-backed file alone does not insure power-hit tolerant code. Therefore, the system of the present invention uses a series of C++ classes to provide a set of rules and structure to facilitate power-hit tolerant code.",{"@attributes":{"id":"p-0125","num":"0138"},"figref":"FIG. 8","ul":{"@attributes":{"id":"ul0004","list-style":"none"},"li":["NV\u2014This class manages novram files. All novram objects use the NV base class for handling basic file I\/O. This class isolates the implementation of files to access novram.","NV1\u2014This class manages novram data structures stored in files. Data in this file is only stored once. Saving the contents of this file will insure recovery after a power hit, unless the power hit occurred in the middle of saving the contents. Use this object if you don't care about power hits during the middle of saving, but want to insure that once saved successfully, the contents will be recovered after power hits.","NV2\u2014Similar to NV1, this object stores data structures in files. However, two copies are stored. One copy is always valid, even if a power hit occurs in the middle of saving the contents. This is the most predictable and secure type of novram. This object is used most commonly to support updates to novram data based on state transition flows.","NVQueue\u2014This object facilitates saving a novram queue of elements of your choosing. For example, a queue of last game played data structures.","NVMeters\u2014This object is used for storing and updating game play and statistical meters. It is based on the NV2 object but allows data elements in the NV2 object to be Meter objects.","State\u2014This object is a non-volatile state transition variable. It records the current state for a state machine. It is very powerful in that it also can save many sub states for each state.","Note: One of the errata with the existing novram file subsystem is that changing the size of files can result in a very small non power-hit tolerant window. This is more of a limitation of the ext2 file system that buffers in RAM new file nodes allocated and does not immediately flush them to disk, even though the file data is immediately written to the disk, making the file seem shorter than it should be if a power hit occurred within this window.","Until this issue is resolved, files should remain fixed in size once created, and changing their size should only be done in rare circumstances understanding that a power hit in the middle of this operation might result in loss of data.\n\nNVCLASS\n"]}},"The NV class provides convenience routines for opening novram files, writing to files, reading, setting the size of files, and other utility functions. Even though the novram system is based upon standard Unix files under the \/nvram\/* directory, the purpose of this class is to isolate all other objects from this. If down the road, Unix files are no longer used to store novram data, then only this class will change and all other objects that use NV can remain the same. Also, there are various details in dealing with the novram file system that are hidden by the NV class. In one implementation, the class structure is as follows:",{"@attributes":{"id":"p-0127","num":"0148"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"class NV"},{"entry":"{"},{"entry":"public:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Construct a new NV object. Does not open the file."]},{"entry":[{},"NV ( );"]},{"entry":[{},"\/\/ Destructor. Closes the file if open."]},{"entry":[{},"virtual \u2212NV ( );"]},{"entry":[{},"\/\/ Open the file for I\/O. Get the existing fileSize prior to opening.."]},{"entry":[{},"virtual void Open (const char * fileName);"]},{"entry":[{},"\/\/ Close the file."]},{"entry":[{},"virtual void Close ( );"]},{"entry":[{},"\/\/ Set the size of the file. Any bytes added are 0'd."]},{"entry":[{},"virtual void SetSize (unsigned long size);"]},{"entry":[{},"\/\/ Get the size of the file as set by SetSize."]},{"entry":[{},"virtual unsigned long Size ( );"]},{"entry":[{},"\/\/ Clear the file and all data. Must have previously set the size."]},{"entry":[{},"virtual void Clear ( );"]},{"entry":[{},"\/\/ Write a file data segment."]},{"entry":[{},"virtual void Write (unsigned long offset,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"const void * buf,"]},{"entry":[{},"unsigned long length);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Read file data into ram."]},{"entry":[{},"virtual void Read (unsigned long offset,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void * buf,"]},{"entry":[{},"unsigned long length) ;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Check for existance of file."]},{"entry":[{},"static bool FileExists (const char * fileName);"]},{"entry":[{},"\/\/ Get size of file. Returns \u22121 if file does not exist."]},{"entry":[{},"static unsigned long FileSize (const char * fileName);"]},{"entry":[{},"\/\/ Delete the file. File must exist."]},{"entry":[{},"static void DeleteFile (const char * fileName);"]},{"entry":[{},"\/\/ Utility routine to perform a checksum over data ,"]},{"entry":[{},"static unsigned long Checksum (const void * data,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"unsigned long Len);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"public:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"in","fad;","\/\/File descriptor of open file. \u22121 = not: open."]},{"entry":[{},"char *","name;","\/\/Name of the open file."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"unsigned long fileSize;","\/\/ Size of the file."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"This class manages novram data structures stored in files. Data in this file is only stored once. Saving the contents of this file will insure recovery after a power hit, unless the power hit occurred in the middle of saving the contents, in which all data would be lost. This object is used if it does not matter that power hits occur during the middle of saving, but data is to be stored for recovery from novram and use at some later time. To use the NV1 class put the following line in a c++ file:\n\n",{"@attributes":{"id":"p-0129","num":"0151"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"class NV1"},{"entry":"{"},{"entry":"public:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Construct a NVI object."]},{"entry":[{},"NV1 ( );"]},{"entry":[{},"\/\/ Construct an NVI object giving ptrs to functions to call for I\/O,"]},{"entry":[{},"\/\/ use this if you don't want to create a class and override the"]},{"entry":[{},"\/\/ ReadData and WriteData functions."]},{"entry":[{},"NV1 (void (*read) (Stream &a), void (*write) (Stream & a));"]},{"entry":[{},"\/\/ Destruct the object. Close file if open. Does not save."]},{"entry":[{},"virtual ~NV1( );"]},{"entry":[{},"\/\/ Load file data into ram. Recover previous data. calls ReadData ( )"]},{"entry":[{},"\/\/ which must be overridden. If file does not exist, then it will be"]},{"entry":[{},"\/\/ created by calling WriteData Which must be overridden."]},{"entry":[{},"\/\/ If a partial update was previously performed, the file will be"]},{"entry":[{},"cleared."]},{"entry":[{},"virtual void Open (const char * filename);"]},{"entry":[{},"\/\/ Close the file if open. Does not save."]},{"entry":[{},"virtual void Close ( );"]},{"entry":[{},"\/\/ Store all data back to the file."]},{"entry":[{},"virtual void Save ( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"protected:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Read user data from the stream into user data storage."]},{"entry":[{},"virtual void ReadData (Stream & a);"]},{"entry":[{},"\/\/ Write user data storage to the stream for storage into novram."]},{"entry":[{},"\/\/ Override this routine so you can write to the stream any amount of"]},{"entry":[{},"\/\/ data you \u201c,ant to store. The file size is automatically adjusted"]},{"entry":[{},"\/\/ to the amount of data you write."]},{"entry":[{},"virtual void WriteData (Stream .. a);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"};"},{"entry":"template<class Type> class NV1Type : public NV1, public Type"},{"entry":"{"},{"entry":"public:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Construct the template object."]},{"entry":[{},"NV1Type ( )"]},{"entry":[{},"{ memset(Type*)this, 0, sizeof(Type)); }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"protected:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Read the objects data."]},{"entry":[{},"virtual void Read Data (Stream & s)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{ s.Read((Type*) this, sizeof(Type)); }"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Write the objects data to novram."]},{"entry":[{},"virtual void WriteData (Stream & s)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{ s.Write((Type*) this, sizeof(Type)); }"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The easiest and most common way to use NV1 class is to use the template NV1Type that allows any data structure to be made non-volatile. The following example shows how to declare a data structure type and then make it non-volatile. This standard template method is used similarly throughout the system of the present invention.",{"@attributes":{"id":"p-0131","num":"0153"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"#include \u2212NV1.h\u2033"]},{"entry":[{},"\/\/ First declare a structure of data to keep in novram."]},{"entry":[{},"\/\/ The only limitation is that the structure can not contain pointers"]},{"entry":[{},"\/\/ to other structures or objects. However, it may contain other"]},{"entry":[{},"structures."]},{"entry":[{},"struct Data"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int a, b;"]},{"entry":[{},"char name (20) ;"]},{"entry":[{},"\/\/char * text; \/\/ A declaration like this would be bad."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},"\/\/ Next declare my novram data typedef."]},{"entry":[{},"typedef NV1Type<Data> NVData;"]},{"entry":[{},"\/\/ Now declare a novram variable of this new type."]},{"entry":[{},"NVData nvData;"]},{"entry":[{},"void main ( )"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Open and recover the previous novram data. If it's the"]},{"entry":[{},"\/\/ first time opening the file, e.g. the file did not exist,"]},{"entry":[{},"then the structure will be all c:\u2009 \u2009."]},{"entry":[{},"nvData.Open(\u201c\/nvram\/my-critical-data\u2033);"]},{"entry":[{},"\/\/ Modify some data in the object. This only modifies the"]},{"entry":[{},"ram value in memory."]},{"entry":[{},"nvData.a += 1;"]},{"entry":[{},"nvData.b = nvData.a * 2;"]},{"entry":[{},"strcpy(nvData.name, \u201cTesting\u2033);"]},{"entry":[{},"\/\/ Now save the ram values in the object to roe file."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"nvData.Save( );","\/\/ A power hit in the middle of this"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"will lose all data."]},{"entry":[{},"\/\/ Close the file only when there are no more changes to save."]},{"entry":[{},"\/\/ The memory contents will remain. This is optional and"]},{"entry":[{},"\/\/ almost never done in practice. Mostly novram objects are"]},{"entry":[{},"kept open W2til destructed."]},{"entry":[{},"nvData.Close( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0132","num":"0000"},"ul":{"@attributes":{"id":"ul0006","list-style":"none"},"li":["Note: One of the standard things that can help readers of your code readily identify which structures typedefs are Nonvolatile objects is if they are prefixed with NV such as NVData in the previous example","Also, declaring variables with the nv prefix such as nvData helps the reader identify that it is a novram variable and a Save( ) needs to be performed for that variable type when it is modified Separating your novram variables from your volatile variables is important for clear and maintainable code."]}},"Another way to use the NV1 class is to inherit it and override the ReadData and WriteData virtual functions to restore and save data respectively. In fact, that is exactly what the template class NV1 Type does. Sometimes overriding these functions can give more flexibility if the format of the data being saved is more dynamic than a static structure declaration. If the NV1 class is to be used directly but inheritance is inconvenient, then the read and write function pointers can be passed to NVI when the basic object is constructed. When it is time to recover and save data, the appropriate functions will be called.","NV2 Class","Similar to NV1, this object stores data structures in files. However, two copies are stored. One copy is always valid, even if a power hit occurs in the middle of saving the contents. This is the most predictable and secure type of novram object. One of the benefits of a NV2 object is that when Save( ) is called, it is an atomic operation. Either the update from RAM to battery-backed data will be performed in full or will not be performed at all if a powerhit occurs in the middle of Save( ) Save1( ) or Save2( ).",{"@attributes":{"id":"p-0135","num":"0158"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"class NV2 ( );"},{"entry":"{"},{"entry":"public:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Constructor."]},{"entry":[{},"NV2 ( );"]},{"entry":[{},"\/\/ Construct an NV2 object giving ptrs to functions to call for I\/O."]},{"entry":[{},"\/\/ Use this if you don't want to create a class and override functions."]},{"entry":[{},"NV2 (void (*read) (Stream &s), void (*write) (Stream & s));"]},{"entry":[{},"\/\/ Destruct the object. Close file if open. Does not save."]},{"entry":[{},"virtual ~NV2 ( );"]},{"entry":[{},"\/\/ Load file data into ram. Recover previous data. Calls ReadData ( )"]},{"entry":[{},"\/\/ which must be overridden. If file does not exist, then it will be"]},{"entry":[{},"\/\/ created by calling WriteData which must be overridden. Any partial"]},{"entry":[{},"\/\/ updates to the secondary copy are replaced by the primary copy."]},{"entry":[{},"\/\/ Any partial updates from the secondary copy to the primary copy will"]},{"entry":[{},"\/\/ be completed upon recovery."]},{"entry":[{},"virtual void open (const char * filename);"]},{"entry":[{},"\/\/ Close the file if open. Does not save."]},{"entry":[{},"virtual void Close ( );"]},{"entry":[{},"\/\/ Calls Save1 and then Save2. Not really power hit tolerant unless you"]},{"entry":[{},"\/\/ don't care whether the data gets updated fully or not at all without really"]},{"entry":[{},"\/\/ knowing which happened after recovery. Use states with Save1 & Save2 if"]},{"entry":[{},"\/\/ you really need better control over the update."]},{"entry":[{},"virtual void Save ( );"]},{"entry":[{},"\/\/ First step to updating. calls WriteData to get the new data and writes"]},{"entry":[{},"\/\/ it to the secondary copy of novram."]},{"entry":[{},"virtual void Save1 ( );"]},{"entry":[{},"\/\/ Last step to updating. Copies secondary copy of novram to primary copy."]},{"entry":[{},"virtual void Save2 ( );"]},{"entry":[{},"\/\/ Validate the data in the novram file"]},{"entry":[{},"virtual void Validate ( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"protected:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Read user data from the stream into user data storage."]},{"entry":[{},"virtual void ReadData (Stream & s);"]},{"entry":[{},"\/\/ Write user data storage to the stream for storage into novram."]},{"entry":[{},"virtual void WriteData (Stream & s);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The functions are almost identical to NV1 except the implementation stores two copies of the data. Two new functions Save1( ) and Save2( ) are added which allow the user to independently save each copy of novrarn data. Sometimes Save1( ) is called to save the changes in the backup copy of the data but the final commitment of data is not performed until Save2( ) is called. NV2 also has a template class that makes it easy to create novram objects.",{"@attributes":{"id":"p-0137","num":"0160"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"template<class Type>"]},{"entry":[{},"class NV2Type : public NV2, public Type"]},{"entry":[{},"{"]},{"entry":[{},"public:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Construct the template object."]},{"entry":[{},"NV2Type ( )"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{ memset((Type*)this, 0, sizeof(Type)); }"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"protected:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Read the objects data."]},{"entry":[{},"virtual void ReadData (Stream & s)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{ s.Read((Type*)this, sizeof(Type)); }"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Write the objects data to novram."]},{"entry":[{},"virtual void WriteData (Stream & s)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{ s.Write((Type*)this, sizeof(Type)); }"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The following is a similar example as the NV1 example except that data is doubly stored.",{"@attributes":{"id":"p-0139","num":"0162"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"#include \u201cNV2. h\u2033"},{"entry":"\/\/ First declare a structure of data to keep in novram."},{"entry":"\/\/ The only limitation is that the structure can not contain pointers to"},{"entry":"\/\/ other structures or objects. However, it may contain other"},{"entry":"structures."},{"entry":"struct Data"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int a, b;"]},{"entry":[{},"char name (20) ;"]},{"entry":[{},"\/\/char * text; \/\/ A declaration like this would be bad."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"};"},{"entry":"\/\/ Next declare the novram data typedef."},{"entry":"typedef NV2Type<Data> NVData;"},{"entry":"\/\/ Now declare a novram variable of this type."},{"entry":"NVData nvData;"},{"entry":"void main ( )"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Open and recover the previous novram data. If it's the first time"]},{"entry":[{},"\/\/ opening the fi1.e, e.g. the file did not exist, then~\u2032 structure will"]},{"entry":[{},"be all O's."]},{"entry":[{},"nvData.Open(\u2033\/nvram\/my-critical-data\u2033);"]},{"entry":[{},"\/\/ Modify some data in the object. This only modifies the ram"]},{"entry":[{},"value in memory."]},{"entry":[{},"nvData.a =1;"]},{"entry":[{},"nvData.b = 2;"]},{"entry":[{},"strcpy(nvData.name, \u2033Testing\u2033);"]},{"entry":[{},"\/\/ Now actually save the ram values in the object to both copies"]},{"entry":[{},"in the file"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"nvData.Save( );","\/\/ A power hit in the middle of this will"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ either save the new values to both copies"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"in novram or not change anything."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Close the file only when there are no more changes to save"]},{"entry":[{},"\/\/ prior to program shutdown. The memory contents will remain."]},{"entry":[{},"nvData.Close( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Like NV1, the NV2 class can also be used directly when more flexibility is needed. In this case either NV2 is inherited and the ReadData and WriteData functions are overridden; or if inheritance is inconvenient, then use a straight NV2 object passing the pointers to the read and write functions in the constructor. The following example shows how to use the NV2 class to support non-volatile storage of data kept in a singly linked list.",{"@attributes":{"id":"p-0141","num":"0164"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"#include \u2033NV2.h\u2033"},{"entry":"\/\/ This is an example data structure kept as an element in a list."},{"entry":"struct Data"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int a, b; \/\/ Some data."]},{"entry":[{},"char name (20) ; \/\/ Some more data."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"};"},{"entry":"\/\/ This is single linked list structure declaration."},{"entry":"struct LinkedData public Data"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Data * next;","\/\/ Next: data structure in the linked list."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"};"},{"entry":"\/\/ List of singly linked Data elements. This is not managed by the NV2 object."},{"entry":"\/\/ Instead it is the application programmers object that is indirectly controled"},{"entry":"\/\/ through the NVReadList ( ) and NVWriteList ( ) functions."},{"entry":"LinkedData * list;"},{"entry":"\/\/ Recovers the list data from novram by reading the data from the stream."},{"entry":"\/\/ This is called at the appropriate time by the NV2 object."},{"entry":"void NVReadList (Stream & stream)"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Delete the current linked list. A new list will be created from the data"]},{"entry":[{},"\/\/ in the stream provided by the NV2 object."]},{"entry":[{},"DeleteList(list);"]},{"entry":[{},"list = NULL;"]},{"entry":[{},"\/\/ Check if the stream is empty. This could be the case if. the file did not"]},{"entry":[{},"\/\/ previously exist."]},{"entry":[{},"if (stream. FileSize( ) == 0)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"return;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Read the number of elements stored previously."]},{"entry":[{},"int totalElements = 0;"]},{"entry":[{},"assert (stream. Read(&totalElements. sizeof(totalElements)));"]},{"entry":[{},"\/\/ For each element. Read the data."]},{"entry":[{},"while (totalElements\u2212\u2212)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"LinkedData * data =new LinkedData:"]},{"entry":[{},"\/\/ Read the structure elements. We only read a Data element as that is"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"what"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ was stored by NVWriteList."]},{"entry":[{},"assert (stream.Read (data. sizeof(Data)));"]},{"entry":[{},"\/\/ Add the data structure to the linked list."]},{"entry":[{},"AddList(list. data);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"void NVWriteList (Stream & stream)"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ First write the total number of elements in the list."]},{"entry":[{},"int totalElements = CountListElements(list);"]},{"entry":[{},"\/\/ Next write the structure contents of each node."]},{"entry":[{},"LinkedData * data = list;"]},{"entry":[{},"while (data)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Write the data structure subclass Data."]},{"entry":[{},"assert (stream.Write(data, sizeof(Data)));"]},{"entry":[{},"\/\/ Go to the next element."]},{"entry":[{},"data = data\u2212>next;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"void main ( )"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ Create an NV2 object and use the passed read and write functions to read"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"and"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ write the data when appropriate."]},{"entry":[{},"NV2 * nvList = new NV2(NVReadList, NVWriteList);"]},{"entry":[{},"\/\/ Open and recover the previous novram data. If it's the first time opening"]},{"entry":[{},"\/\/ the file, e.g. the file did not exist, write will be called to initialize"]},{"entry":[{},"\/\/ the file. Therefore, list should be empty by default. After this call,"]},{"entry":[{},"\/\/ NVReadData may have recovered the list from memory-in any event, list will"]},{"entry":[{},"\/\/ be consistent with the novram data."]},{"entry":[{},"nvList.Open(\u201c\/nvram\/my-critical-data-list\u2033);"]},{"entry":[{},"\/\/ Modify some data in the list. This only modifies the ram values in memory."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"RandomlyShuffleTheList(list);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Now save the list in RAM to novram."]},{"entry":[{},"nvList.Save( ); \/\/ A power hit in the middle of this will either save the"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ new values to both copies in novram or not change anything."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Delete the NV2 object. This does not affect the RAM list variables."]},{"entry":[{},"delete nvList;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"NVMETERS Class","This class is used for storing and updating game play or statistical meters. It is based on the NV2 object where its doubly stored data is an array of Meter objects. This class provides complete power hit tolerance for updating meters when properly used with the State class for state transitions. In one implementation, the NVMeters class is defined as:",{"@attributes":{"id":"p-0143","num":"0166"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"class NVMeters : public NV2"]},{"entry":[{},"{"]},{"entry":[{},"public:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Constructor"]},{"entry":[{},"NVMeters( );"]},{"entry":[{},"\/\/ Destruct the object. Close file if open. Does not save."]},{"entry":[{},"virtual ~NVMeters ( );"]},{"entry":[{},"\/\/ Load file data into ram. Recovers all meter data. If file does"]},{"entry":[{},"\/\/ not exist, then it will be created with 0 value meters. If"]},{"entry":[{},"\/\/ the meter count differs from the file, the .file will be"]},{"entry":[{},"\/\/ updated the next time the file is saved. If meters where in"]},{"entry":[{},"\/\/ the middle of a Save1 ( ) but not completed, then the"]},{"entry":[{},"\/\/ operation will be backed out. If in the middle of a Save2 ( ),"]},{"entry":[{},"then the operation will be completed."]},{"entry":[{},"virtual void Open (const char * filename. unsigned int"]},{"entry":[{},"totalMeters);"]},{"entry":[{},"\/\/ Retrieve a meter value. You can operate on this meter value"]},{"entry":[{},"\/\/ as needed just as if you were indexing into an array of"]},{"entry":[{},"\/\/ longs. call Save1 ( ) to store the new meter values to the"]},{"entry":[{},"\/\/ secondary storage in the file. call Save2 ( ) to finally"]},{"entry":[{},"\/\/ update the meters. Note that after recovery and before"]},{"entry":[{},"\/\/ a Save2 ( ) has been made. all meter values will be"]},{"entry":[{},"recovered with their primary(unchanged) values."]},{"entry":[{},"Meter & operator [ ] (unsigned int meterIndex)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"assert (meters) ;"]},{"entry":[{},"assert (meterIndex < totalMeters);"]},{"entry":[{},"return meters [meterIndex] ;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"const Meter & operator [ ] (unsigned int meterIndex)"]},{"entry":[{},"const"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"assert (meters) ;"]},{"entry":[{},"assert(meterIndex < totalMeters);"]},{"entry":[{},"return meters[meterIndex];"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"To the application programmer, a NVMeters class object appears like an array of long integers. The application programmer can easily use the values by indexing into the array with [ ] and modify their values in a similar manner.","Instead of long integers. however, NVMeters is actually an array of Meter objects. Meter objects are based upon long integers except they enforce rollover values. So adding 1000 to a Meter object may roll it over to a small number if it exceeds its rollover value.",{"@attributes":{"id":"p-0146","num":"0169"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"class Meter"},{"entry":"{"},{"entry":"public:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Meters rollover at this default value unless otherwise specified."]},{"entry":[{},"\/\/ This value is the largest power of 10 that will fit in a long."]},{"entry":[{},"static const unsigned long defaultRollover 1000000000;"]},{"entry":[{},"\/\/ Default constructor sets meter value to 0 with defaultRollover."]},{"entry":[{},"Meter ( );"]},{"entry":[{},"\/\/ Construct from an existing value, and use defaultRollover."]},{"entry":[{},"Meter (long initValue);"]},{"entry":[{},"\/\/ Construct from an existing value and rollover."]},{"entry":[{},"Meter (long initValue, unsigned long initRollover);"]},{"entry":[{},"\/\/ Construct by copying another meter's value and rollover."]},{"entry":[{},"Meter (const Meter & meter);"]},{"entry":[{},"\/\/ Set a new rollover value for the meter. 0= don't rollover meter."]},{"entry":[{},"\/\/ will immediately modifiy the current meter to lie within"]},{"entry":[{},"rollover value."]},{"entry":[{},"void SetRollover (unsigned long newRollover);"]},{"entry":[{},"\/\/ Set value and rollover value."]},{"entry":[{},"void SetRollover (long newValue, unsigned long newRollover) ;"]},{"entry":[{},"\/\/ Copy another meter's value and rollover."]},{"entry":[{},"Meter & operator = (const Meter & meter);"]},{"entry":[{},"\/\/ cast operator. Automatically casts a Meter to a long if"]},{"entry":[{},"\/\/ used by the programmer in the context of along."]},{"entry":[{},"operator long ( ) const;"]},{"entry":[{},"\/\/ Assignment operators modify and return the meter. Result can be"]},{"entry":[{},"\/\/ used in the context of a long or a Meter. Applies the .rollover"]},{"entry":[{},"to new value."]},{"entry":[{},"Meter & operator (long v) ;"]},{"entry":[{},"Meter & operator += (long v) ;"]},{"entry":[{},"Meter & operator (long v);"]},{"entry":[{},"Meter & operator %= (long v) ;"]},{"entry":[{},"Meter & operator 1= (long v);"]},{"entry":[{},"Meter & operator ++ ( );"]},{"entry":[{},"Meter & operator \u2212\u2212( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"The NVQueue class is used to store a queue of non-volatile elements. While the NV2 object can be used to store queue data, it is fairly wasteful for queues of any significant size. While the NV2 object stores two copies of data, the NVQueue object only stores one copy of the queue data. The NVQueue object is also faster at updating specific elements because just the element is written to novram during updates, not the entire queue. The limitation with the NVQueue class is that only one element at a time can be updated and saved to novram as opposed to updating many elements and saving them all at once. In most cases this is desirable.","Just as NV2 objects contain a Save1( ) and Save2( ) function calls to break up state updates, NVQueue objects contain similar functions for normal queue manipulations. The Add1( ) and Add2( ) function calls allow the programmer to break up adding an element to the end of the queue by using two state independent transitions. Similarly, Update1( ) and Update2( ) support modification of a particular element in the queue. And finally, Del1( ) and Del2( ) provide support for removing the head element from the queue.",{"@attributes":{"id":"p-0149","num":"0172"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"class NVQueue"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public:"]},{"entry":[{},"\/\/ Constructor. The constructor sets the values for these variables for"]},{"entry":[{},"\/\/ use when a new novram file is created on an Open( )."]},{"entry":[{},"\/\/ If file does not exist on the Open ( ) call, then it will be created with"]},{"entry":[{},"\/\/ initially no elements with a maximum # of elements of \u201cmaxElements\u201d,"]},{"entry":[{},"\/\/ with each element being fixed in size of \u201celementSize\u201d. wrapAdds will"]},{"entry":[{},"\/\/ cause any Add ( ) calls to purge the old element in the queue to make room"]},{"entry":[{},"\/\/ for the new element if necessary."]},{"entry":[{},"NVQueue (unsigned int maxElements, unsigned int elementSize,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"bool wrapAdds = true);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Destruct the object. Close file if open. Does not complete any operations"]},{"entry":[{},"\/\/ in progress if you did not finish them. Basical.ly the same as a powerhit."]},{"entry":[{},"virtual ~NVQueue ( );"]},{"entry":[{},"\/\/ Load file data into ram. Recovers all queue elements from novram."]},{"entry":[{},"\/\/ Any partial adds or deletes after a powerhit will be completed at this"]},{"entry":[{},"\/\/ time. If the file already exists, any inconsistencies between"]},{"entry":[{},"\/\/ \u201cmaxElements\u201d, \u201celementSize\u201d, and \u201cwrapAdds\u201d, will cause a NVFault."]},{"entry":[{},"virtual void Open (const char * filename);"]},{"entry":[{},"\/\/ Close the file if open. Does not save. Element data is still accessable"]},{"entry":[{},"\/\/ but no modifications can be done."]},{"entry":[{},"virtual void Close( );"]},{"entry":[{},"\/\/ Retrieve a const ptr to a queue element. This element can not be"]},{"entry":[{},"\/\/ changed directly. Index of 0 is the first element at the head of the"]},{"entry":[{},"\/\/ queue, index TotalElements( ) \u2212.1 is the last element in the queue (tail)."]},{"entry":[{},"const void * operator [ ] (unsigned int index);"]},{"entry":[{},"virtual const void * Get (unsigned int index);"]},{"entry":[{},"\/\/ Retrieve the total # of elements in the queue. Note: that the queue may"]},{"entry":[{},"\/\/ be large enough to hold many elements but only the number of elements that"]},{"entry":[{},"\/\/ have actually been added will be returned."]},{"entry":[{},"virtual unsigned int TotalElements ( );"]},{"entry":[{},"\/\/ Return true if queue is empty or full."]},{"entry":[{},"virtual bool Empty ( );"]},{"entry":[{},"virtual bool Full ( );"]},{"entry":[{},"\/\/ Each element is identified by a unique sequence number. These functions"]},{"entry":[{},"\/\/ return the first and last element sequence number in the queue. You can"]},{"entry":[{},"\/\/ get the last sequence number of an event to quickly determine if new"]},{"entry":[{},"\/\/ elements have been added to the queue."]},{"entry":[{},"\/\/ LastSequenceNumber( ) \u2212FirstSequenceNumber == TotalElements ( ) ."]},{"entry":[{},"\/\/ NOTE:: calling these functions if queue is empty will cause assertion."]},{"entry":[{},"virtual unsigned int FirstSequenceNumber ( );"]},{"entry":[{},"virtual unsigned int LastSequenceNumber ( );"]},{"entry":[{},"\/\/ Returns the next sequence number for an element that would be added."]},{"entry":[{},"virtual unsigned int NextSequenceNumber ( );"]},{"entry":[{},"\/\/ Add a new element to the queue. This will first make room in the queue"]},{"entry":[{},"\/\/ if neccessary and \u201cwrapAdds\u201d is true. If \u201cwrapAdds\u201d is false and the"]},{"entry":[{},"\/\/ queue is full, this function does not add the element to the queue."]},{"entry":[{},"\/\/ Function returns true on successful addition of the element."]},{"entry":[{},"\/\/ You must first call Add1( ) to prepare to add the element to the queue,"]},{"entry":[{},"\/\/ and then call Add2( ) to complete the addition. These add calls must be"]},{"entry":[{},"\/\/ broken up between state transitions of your own making to prevent: duplicate"]},{"entry":[{},"\/\/ elements from being added during powerhit."]},{"entry":[{},"virtual bool Add1 (const void \u2022 element);"]},{"entry":[{},"virtual void Add2 ( );"]},{"entry":[{},"\/\/ If you dont care about powerhit tolerance code which prevents duplicate"]},{"entry":[{},"\/\/ elements from being added to the queue should a powerhit occur in this"]},{"entry":[{},"\/\/ function call, then you can just call Add( ). Should a powerhit occur in"]},{"entry":[{},"\/\/ Add( ) , it will either not add anything or all or add r:he element"]},{"entry":[{},"\/\/ completely. Returns true on successful addition of an element."]},{"entry":[{},"virtual bool Add (const void \u2022 element);"]},{"entry":[{},"\/\/ Update an element in the queue. The element index must be 0 to"]},{"entry":[{},"\/\/ Total Elements ( ) \u22121. These update calls must be broken up between state"]},{"entry":[{},"\/\/ transitions of your own making to make clean updates during powerhits."]},{"entry":[{},"virtual void Update (unsigned int index, const void \u2022 element);"]},{"entry":[{},"virtual void Update2 ( );"]},{"entry":[{},"\/\/ Update an element in the queue in one atomic action. If a powerhit:"]},{"entry":[{},"\/\/ occurs in this function call, the only guarantee is that the element"]},{"entry":[{},"\/\/ did not get updated at all or it was completely updated. V"]},{"entry":[{},"virtual void Update (unsigned int index, const void \u2022 element);"]},{"entry":[{},"\/\/ Delete the next element from the head of the queue. RetuZ7ls true if"]},{"entry":[{},"\/\/ an element is prepared for deletion, and false if the queue is empty."]},{"entry":[{},"\/\/ Must be followed by a call to Del2( ) using your own state transitions."]},{"entry":[{},"virtual bool Del1 ( );"]},{"entry":[{},"virtual void Del2 ( );"]},{"entry":[{},"\/\/ Delete the next element from the head of the queue. Returns true if"]},{"entry":[{},"\/\/ an element is successfully deleted. This function either deletes the"]},{"entry":[{},"\/\/ element in its entirety after a powerhit, or may not delete it at all."]},{"entry":[{},"\/\/ call Del1 ( ) and Del2 ( ) if you need perfect power hit tolerancy to be sure"]},{"entry":[{},"\/\/ you delete one and only one element no matter when a powerhit occurs."]},{"entry":[{},"virtual bool Del ( );"]},{"entry":[{},"\/\/ Validate the data in the novram file"]},{"entry":[{},"virtual void Validate ( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"To facilitate the ease of use of the NVQueue class, a template is also declared. By using this template with custom structures, a complete NVQueue type for these custom structures can be easily created and used.",{"@attributes":{"id":"p-0151","num":"0174"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"template<class Type>"]},{"entry":[{},"class NVQueueType public NVQueue"]},{"entry":[{},"{"]},{"entry":[{},"public:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Construct the template object."]},{"entry":[{},"NVQueueType (unsigned int maxElements, bool wrapAdds ="]},{"entry":[{},"true)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},": NVQueue(maxElements. sizeof(Type). wrapAdds)"]},{"entry":[{},"{ }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Retrieve a const reference to a queue element. This element"]},{"entry":[{},"\/\/ can not be changed directly but: only used for reference."]},{"entry":[{},"\/\/ Index of 0 is t:he first element at: the head of the"]},{"entry":[{},"\/\/ queue. index TotalElements ( ) \u22121 is the last element"]},{"entry":[{},"in the queue (tail) ."]},{"entry":[{},"const Type & operator [ ) (unsigned int index)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{ return *(const Type*)Get(index); }"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Same as Add1 for NVQueue but with reference type."]},{"entry":[{},"bool Add1 (const Type & element)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{ return NVQueue: :Add1 (&element) };"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Same as Add for NVQueue but with reference type."]},{"entry":[{},"bool Add (const Type & element)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{ return NVQueue::Add(&element) };"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Same as Update1 for NVQueue but with reference type."]},{"entry":[{},"void Update1 (unsigned int index, const Type & element)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{ NVQueue::Update1(index, &element); }"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Same as Update1 for NVQueue but with reference type."]},{"entry":[{},"void Update (unsigned int index, const Type & element)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{ NVQueue: :Update (index, &element); }"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"An example of declaring an NVQueue using the template follows.",{"@attributes":{"id":"p-0153","num":"0176"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ First declare a typedef structure for elements you want to store."},{"entry":"struct DataElement"},{"entry":"{"},{"entry":"int data1, data2, data3;"},{"entry":"};"},{"entry":"\/\/ Next: typedef the new type of NVQueue using the template."},{"entry":"typedef NVQueueType<DataElement> NVDataQueue;"},{"entry":"void main ( )"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Create a Q with a maximum of 10 elements."]},{"entry":[{},"NVDataQueue * nvDataQueue = new NVDataQueue(10);"]},{"entry":[{},"\/\/ Open file and recover the queue elements from novram."]},{"entry":[{},"nvDataQueue\u2212>Open(\u201c\/nvram\/the-data-queue\u201d) ;"]},{"entry":[{},"\/\/ Initialize a new element structure."]},{"entry":[{},"DataElement data;"]},{"entry":[{},"data.data1 = 1;"]},{"entry":[{},"data.data2 = 2;"]},{"entry":[{},"data.data3 = 3;"]},{"entry":[{},"\/\/ Add it to the queue. This is done as an atomic operation, i.e."]},{"entry":[{},"\/\/ if a power hit occurs in the middle of this operation, then the"]},{"entry":[{},"\/\/ element will either be added completely or not at all."]},{"entry":[{},"NvDataQueue\u2212>Add(data);"]},{"entry":[{},"\/\/ All done."]},{"entry":[{},"delete nvDataQueue;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"The state novram class is used to manage state transitions within a program. The state object stores its current value in novram to facilitate power fail recovery. The state class is a concrete class that acts like an integer. States can be assigned integer values and they can be compared to other integers, enumerations or preprocessor defines. When an integer is assigned to a state variable, the state object immediately stores its new value into novram as an atomic operation. That is, if a power fail occurs during the middle of a state variable update, then the update operation is guaranteed to either complete or not change at all. This automatic operation is different than the other novram objects in that the save ( ) function is not required to be called explicitly. This prevents accidental forgotten updates by the application programmer. In one implementation, the State class definition follows.",{"@attributes":{"id":"p-0155","num":"0178"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"class State"},{"entry":"{"},{"entry":"public:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Construct a state object which can do nothing until opened."]},{"entry":[{},"State ( );"]},{"entry":[{},"\/\/ Construct a state object by copying from another. Clones the state but"]},{"entry":[{},"\/\/ does not create any substrates or change the current state."]},{"entry":[{},"State (const State & the State);"]},{"entry":[{},"\/\/ Destruct our state object. If its the last state object reference to the"]},{"entry":[{},"\/\/ state file that is opened, then the file will be closed. File will."]},{"entry":[{},"\/\/ remain open if other states reference the file."]},{"entry":[{},"~State ( );"]},{"entry":[{},"\/\/ Open the nv file and recover all state information. This state will"]},{"entry":[{},"\/\/ point to the top most state in the nv state stack. calling Open( ) with"]},{"entry":[{},"\/\/ an already open state will be like destroying the old state object and"]},{"entry":[{},"\/\/ creating a new object opening this new file or the same file."]},{"entry":[{},"void Open (const char * File);"]},{"entry":[{},"\/\/ Returns the current state value for the substate this object references"]},{"entry":[{},"\/\/ within the nv state stack. States automatically convert to ints so they"]},{"entry":[{},"\/\/ can be used like integer variabl.es."]},{"entry":[{},"operator int( ) const;"]},{"entry":[{},"\/\/ Copy the current state to another. Does not change any state info."]},{"entry":[{},"State & operator = (const State & theState) ;"]},{"entry":[{},"\/\/ Set this state's current value. This will change the current state value"]},{"entry":[{},"\/\/ for this states position in the nv state stack and will also destroy any"]},{"entry":[{},"\/\/ substates farther down the stack. Changing a state higher up the stack"]},{"entry":[{},"\/\/ essentially destroyes or transitions out of substates."]},{"entry":[{},"int operator = (int newState);"]},{"entry":[{},"\/\/ Create a substate by pushing onto the stack a new state value of zero."]},{"entry":[{},"\/\/ This returns a new state variable which references the new substack within"]},{"entry":[{},"\/\/ the nv state stack. Use this new state returned to use and change the"]},{"entry":[{},"\/\/ substate you have created."]},{"entry":[{},"State NewSubState ( ) const;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"State variables can be declared anywhere in the code where normal variables are declared. When initially created, state variables are not associated with novram files. To be associated with files a state variable must Open ( ) a file. Upon initial creation of the state novram file, the state variable will be initialized to zero. The following examples show various ways a state variable can be declared and recovered.",{"@attributes":{"id":"p-0157","num":"0180"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"State state;"]},{"entry":[{},"void main ( )"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"state.Open(\u201c\/nvram\/state\u201d);"]},{"entry":[{},"switch (state)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},". . ."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"States can also be created.",{"@attributes":{"id":"p-0159","num":"0182"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void main ( )"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"State * state = new State;"]},{"entry":[{},"State\u2212>Open(\u201c\/nvram\/state\u201d);"]},{"entry":[{},"switch (*state)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},". . ."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"States classes are actually references to novram file objects that contain the states value. Therefore, when a state is copied to another state, both state variables reference the same novram file. Any modification to one state variable will also change the other state variables value and the underlying value in novram. Therefore, when a states can be passed as function arguments.",{"@attributes":{"id":"p-0161","num":"0184"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void main ( )"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"State state, statecopy;"]},{"entry":[{},"state.Open(\u201c\/nvram\/state\u201d);"]},{"entry":[{},"state = 5;"]},{"entry":[{},"printf(\u201cstate = %d\\n\u201d, (int)state);"]},{"entry":[{},"stateCopy = state;"]},{"entry":[{},"statecopy = 10;"]},{"entry":[{},"printf(\u201cstate = %d\\n\u201d, (int)state);"]},{"entry":[{},"printf(\u201cstateCopy = %d\\n\u201d, (int)stateCopy);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"This program will produce the following output:",{"@attributes":{"id":"p-0163","num":"0186"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"state = 5"]},{"entry":[{},"state = 10"]},{"entry":[{},"state Copy = 10"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The following program shows how a state variable can be used to increment a non-volatile meter.",{"@attributes":{"id":"p-0165","num":"0188"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"void main ( )"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ This is the programs main state variable and novram meter variable."]},{"entry":[{},"State state;"]},{"entry":[{},"NVMeter meters;"]},{"entry":[{},"#define TOTAL_METERS 10"]},{"entry":[{},"\/\/ Declare some state possibilities."]},{"entry":[{},"enum"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"stateInit,"]},{"entry":[{},"stateIncrement1,"]},{"entry":[{},"stateIncrement2,"]},{"entry":[{},"stateEnd,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},"\/\/ Open the file and recover the previous state."]},{"entry":[{},"state.Open(\u201c\/nvram\/state\u201d);"]},{"entry":[{},"\/\/ Open the meter object to recover the last meter saved."]},{"entry":[{},"meters.Open(\u201c\/nvram\/meters\u201d, TOTAL_METERS);"]},{"entry":[{},"\/\/ Determine what we were doing before the powerfail."]},{"entry":[{},"switch (state)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case stateInit:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Novram cleared powerup. State value is zero, meters"]},{"entry":[{},"are zero."]},{"entry":[{},"state = stateIncrement1;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case stateIncrement1:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Increment the meter and perform the first meter update."]},{"entry":[{},"Meters[0] += 1;"]},{"entry":[{},"meters.Save1( ) ;"]},{"entry":[{},"state = stateIncrement2;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case stateIncrement2:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Complete the meter update."]},{"entry":[{},"meters.Save2( );"]},{"entry":[{},"state = stateEnd;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case stateEnd:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Print our meter value."]},{"entry":[{},"printf (\u201cMeter (0) = %d\\n\u201d, (int) meter[0]);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"This example will increment the meter value only once. Once run after a novram clear state, the meter value will change from zero to one. Subsequent runs will still yield a meter value of one because the state will continue to remain at stateEnd.","Often when programming state machines, it is cumbersome to keep one complete table of all possible states of the program. A proper power hit tolerant program may contain hundreds of possible states. Keeping these in one table is difficult to maintain and precludes information hiding. Likewise, the programmer may want to simply call a function to perform a major task without knowing the details of the state transitions required to perform the task. It might seem obvious to simply create a new state variable within the function to keep track of that functions local states. This will frequently cause problems as demonstrated in the following example.",{"@attributes":{"id":"p-0168","num":"0191"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Define meter table and defines for each meter value."]},{"entry":[{},"NVMeter meters;"]},{"entry":[{},"#define METER CREDITS 0 \/\/ Current credit value."]},{"entry":[{},"#define METER-PAYOUT 1 \/\/ Total win amount to add to credits."]},{"entry":[{},"#define TOTAL::METERS 2"]},{"entry":[{},"void Payout (int winAmount)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ This is our functions local state variable."]},{"entry":[{},"State state;"]},{"entry":[{},"\/\/ Declare some state possibilities."]},{"entry":[{},"enum"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"stateInit,"]},{"entry":[{},"stateIncrement1,"]},{"entry":[{},"stateIncrement2,"]},{"entry":[{},"stateEnd"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},"\/\/ Open the file and recover the previous state."]},{"entry":[{},"state.Open(\u2033\/nvram\/payout-state\u2033);"]},{"entry":[{},"\/\/ Loop forever until stateEnd exits."]},{"entry":[{},"for ( ; ; )"]},{"entry":[{},"switch (state)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case stateInit:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Don't do anything for zero payouts."]},{"entry":[{},"if (winAmount <= 0)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"return;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Save our total amount to payout."]},{"entry":[{},"meters [METER_PAYOUT] = winAmount;"]},{"entry":[{},"meters.Save ( ) ;"]},{"entry":[{},"state = staterncrement1;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case stateIncrement1:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Increment the credit meter and decrement the"]},{"entry":[{},"payout meter."]},{"entry":[{},"meters[METER CREDITS] += 1;"]},{"entry":[{},"meters [METER-WIN] \u2212= 1;"]},{"entry":[{},"meters .Save( ) ;"]},{"entry":[{},"state = stateIncrement2;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case stateIncrement2:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Complete the meter update."]},{"entry":[{},"meters. Save2 ( ) ;"]},{"entry":[{},"if (meters[METER_PAYOUT] > 0)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"state stateIncrement1;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"state stateEnd;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"break;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case stateEnd:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Set meter back to init for next call and exit the"]},{"entry":[{},"function."]},{"entry":[{},"state = stateInit; \/\/ <\u2212 Powerhit window exists here."]},{"entry":[{},"return;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"void main ( )"]},{"entry":[{},"{"]},{"entry":[{},"\/\/ This is the programs main state variable."]},{"entry":[{},"State state;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Declare some state possibilities."]},{"entry":[{},"enum"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"stateInit,"]},{"entry":[{},"stateIncrement1,"]},{"entry":[{},"stateIncrement2,"]},{"entry":[{},"stateEnd,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}:"]},{"entry":[{},"\/\/ Open the file and recover the previous state."]},{"entry":[{},"state.Open(\u2033\/nvram\/state\u201d);"]},{"entry":[{},"\/\/ Open the meter object to recover the last meter saved."]},{"entry":[{},"meters.Open(\u2033\/nvram\/meters\u2033, TOTAL_METERS);"]},{"entry":[{},"\/\/ Determine what we were doing before the powerfail."]},{"entry":[{},"switch (state)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case stateInit:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Novram cleared powerup. State value is zero,"]},{"entry":[{},"meters are zero."]},{"entry":[{},"Payout(100);"]},{"entry":[{},"state = stateEnd;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case stateEnd:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Print our meter value."]},{"entry":[{},"printf(\u2033credits = %d\\n\u2033, (int)meter[METER"]},{"entry":[{},"CREDITS]);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"When this program is run from a novram-cleared state, this program will add 100 credits to a zero credit meter and produce the result.\n\n","Subsequent runs will continue to keep the credit meter at 100. Any power hit in the Payout ( ) function while incrementing the credit meter will continue where it was left off resulting in a credit meter value of 100. However, this program is not entirely power hit tolerant. If a power hit occurs after the payout is performed, and the payout-state novram variable is set to stateInit, and before the programs main state is set to stateEnd, then the credit meter will be incremented twice to get a value of 200.","One method to make this program power hit tolerant is to store the win amount in a global novram variable prior to calling Payout ( ). The problem with this solution is it causes all major functions which require substate transitions to know about global variables that are used as parameters. Likewise, the calling function must know and store the global power hit tolerant variables that the subordinate function requires. This creates unmodular code.","To solve this, the state novram object provides the concept of substates. Novram state variables contain a main state where each state value contains many substates where each substate value can contain many other substates. A total depth of 25 nested states is supported.","A subordinate function can create a substate from a state variable. Creation of a substate creates a new State variable object from an existing State variable object. The new substate variable object can be used as a normal State variable is used. Likewise other subordinate functions can also create substates from the substates to achieve a modular design. This feature allows state values to be localized to the modules or functions that need to know about the states at that particular level. Whatever substates subordinate functions require is determined by those functions and is not required to be known by the calling function. This makes it very easy to add new state flows for new functionality without maintaining a global state table, thus producing modular code.",{"@attributes":{"id":"p-0174","num":"0198"},"figref":"FIG. 9"},"Substates have one rule that accomplishes this power-hit tolerance. When a state value is modified, all of its previous substates are reset to zero automatically. Therefore, if a state value at level 1 is changed from PayoutResults to EndGameDisplay, then substates at Level 2, 3 and above are cleared to zero. That is, changing a states value automatically resets the substates to the init state to prepare for the next time the function is called. It is important for the substates to be reset to the init state only when the higher level state is moved to the next state value. The novram State class provides this support as an atomic operation.","The previous flawed example is reworked here to incorporate the substate functionality for a 100% power hit tolerant program with zero windows for error.",{"@attributes":{"id":"p-0177","num":"0201"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ Define meter cable and defines for each meter value."},{"entry":"NVMeter meters;"},{"entry":"#define METER CREDITS 0 \/\/ Current credit value."},{"entry":"\/\/ Total win amount to add to credits ,"},{"entry":"#define METER_PAYOUT 1"},{"entry":"#define TOTAL_METERS 2"},{"entry":"void Payout (state & parentState, int winAmount)"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ This is our functions local state variable."]},{"entry":[{},"State state = parentState.CreateSubState( );"]},{"entry":[{},"\/\/ Declare same state possibilities."]},{"entry":[{},"enum"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"stateInit,"]},{"entry":[{},"stateIncrement1,"]},{"entry":[{},"stateIncrement2,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},"\/\/ Loop forever until stateEnd exits."]},{"entry":[{},"for ( ; ; )"]},{"entry":[{},"switch (state)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case stateInit:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Don't do anything for zero payouts."]},{"entry":[{},"if (winAmount <= 0)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"return;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Save our total amount to payout."]},{"entry":[{},"meters [METER PAYOUT] = winAmount;"]},{"entry":[{},"meters.Save( );"]},{"entry":[{},"state = stateIncrement1;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case stateIncrement1:\/\/ Increment the credit meter and"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"decrement the payout meter."]},{"entry":[{},"meters[METER CREDITS] += 1;"]},{"entry":[{},"meters [METER-WIN] \u2212= 1;"]},{"entry":[{},"meters.Save1( );"]},{"entry":[{},"state = stateIncrement2;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case stateIncrement2:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Complete the meter update."]},{"entry":[{},"meters. Save2 ( ) ;"]},{"entry":[{},"if (meters [METER_PAYOUT) > 0)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"state = stateIncrement1;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"return;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"void main ( )"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ This is the programs main state variable."]},{"entry":[{},"State state;"]},{"entry":[{},"\/\/ Declare some state possibilities."]},{"entry":[{},"enum"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"stateInit,"]},{"entry":[{},"stateIncrement1,"]},{"entry":[{},"stateIncrement2,"]},{"entry":[{},"stateEnd,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},"\/\/ Open the file and recover the previous state."]},{"entry":[{},"state.Open(\u201c\/nvram\/state\u201d);"]},{"entry":[{},"\/\/ Open the meter object to recover the last meter saved."]},{"entry":[{},"meters.Open(\u201c\/nvram\/meters\u201d, TOTAL_METERS);"]},{"entry":[{},"\/\/ Determine what we were doing before the powerfail."]},{"entry":[{},"switch (state)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case stateInit:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Novram cleared powerup. State value is zero."]},{"entry":[{},"meters are zero."]},{"entry":[{},"Payout (state, 100);"]},{"entry":[{},"state = stateEnd;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case stateEnd:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Print our meter value."]},{"entry":[{},"printf(\u2033credits = %d\\n\u2033 , (int) meter[METER_CREDITS]);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"There are no power-hit windows in the previous program. When the main( ) functions state variable is set to stateEnd, the Payout( ) functions substate variable is reset to stateInit as an atomic operation. If a power fail occurs right before setting the main ( ) state to stateEnd, then the Payout( ) function will repeat its last state of s to at elncrement2 which will do nothing more than it already did previously, which was to finalize the update to the meter table. If a power fail was to occur right after main ( ) set its state to stateEnd, then stateEnd would be recovered and Payout( ) would never be called.","One rule in substates is to separate each subordinate function that uses substates into separate states in the calling function. Another nice feature of the substate functionality is that states can be passed to the subordinate functions as parameters allowing the functions to not care what parent states exist. The program flow for power fail recovery can remain largely identical to normal program flow. Likewise, because the subordinate functions do not care about the parent state values, they are independent from the calling functions.","Power-hit Tolerant Programming","Power-hit tolerant code can be achieved in many ways. Many methods of power-hit programming may contain tiny windows where if a power-hit should occur, the program would either lose data or double process a transaction. The NV class objects are all designed to support one basic methodology where there are no power-hit windows present. This section discusses various examples of how the NV class objects can be used to achieve complete power-hit tolerance.","One common theme in the NV class objects is to break the manipulation functions of a novram class into two basic states.\n\n","To support these state transitions when updating NV objects, the concept of primary data and transaction data is used. Primary data in the NV object is the original data as represented by the non-volatile memory file and in RAM. The programmer can update the primary data in RAM and then call the appropriate function to perform the Update State, e.g. Savelf), The Update State does not simply save the modified RAM to the primary non-volatile memory with the modification. Instead, the modified RAM is written to the transaction non-volatile memory within the novram file. An example of how a state flow might be structured is show below.",{"@attributes":{"id":"p-0183","num":"0209"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void Payout (State & parentState. int winAmount)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"enum"]},{"entry":[{},"{"]},{"entry":[{},"ADD1, ADD2"]},{"entry":[{},"};"]},{"entry":[{},"State state = parentState.CreateSubstate( );"]},{"entry":[{},"switch (state)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case ADD1:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"meters [CREDITS] += winAmount; \/\/ Add the win"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"to credit meter in RAM."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"meters. Save1 ( ) ; \/\/ Save the new meter value to"]},{"entry":[{},"Novram."]},{"entry":[{},"state = ADD2; \/\/ Transition to the second state."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case ADD2:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"meters. Save2 ( ) ;","\/\/ Commit the final changes"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ to the meters in novram."]},{"entry":[{},"RAM is unchanged."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The previous example shows a Payout utility function that takes a parent state variable and the total win amount to add to the credit meter. As discussed previously, substates can be created from a parent state to localize the state transitions required for the function. This function contains two simple states, ADDI and ADD2. The ADD1 state updates the meter value in ram and then stores that value in the transaction novram memory. The ADD2 state commits the transaction by copying the transaction memory in novram.to the primary memory in novram. The second state is always a commit state where modification should never occur and usage of data should not occur before the commit, or Save2( ) function is called. The following example shows power-hit tolerance analysis for the code segment.",{"@attributes":{"id":"p-0185","num":"0211"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"void Payout (State & parentState, int winAmount)"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"enum"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"ADD1, ADD2"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},"State state = parentState.CreateSubstate( );"]},{"entry":[{},"switch (state)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case ADD1 :"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ A power hit occuring here will cause a"]},{"entry":[{},"\/\/ recovery where RAM and primary novram"]},{"entry":[{},"\/\/ will reflect the value prior to any"]},{"entry":[{},"\/\/ changes."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"meters (CREDITS) += winAmount; \/\/ < \u2212A power hit"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ in the middle of this will"]},{"entry":[{},"\/\/ have the same recovery as above."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ \u2190A power hit in the middle of this will"]},{"entry":[{},"\/\/ have the same recovery as above."]},{"entry":[{},"meters.Save1( ); \/\/ \u2190 A power hit in the middle of this"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ will have the same recovery as above except"]},{"entry":[{},"\/\/ that the new meters values mayor may"]},{"entry":[{},"\/\/ not be stored in transactional novram"]},{"entry":[{},"\/\/ memory. This doesn't matter because on"]},{"entry":[{},"\/\/ a powerfail recovery, the primary values"]},{"entry":[{},"\/\/ will be recovered and the meter update"]},{"entry":[{},"\/\/ will be performed exactly the same."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ \u2190 A power hit here will have already saved"]},{"entry":[{},"\/\/ the transactional novram memory; however."]},{"entry":[{},"\/\/ just like above the primary data will"]},{"entry":[{},"\/\/ be recovered and this operation will"]},{"entry":[{},"\/\/ be performed again writing over the"]},{"entry":[{},"\/\/ transactional novram memory with the"]},{"entry":[{},"\/\/ same value."]},{"entry":[{},"state = ADD2; \/\/ \u2190 A powerhit in the middle of this"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ will either cause the atomic state update"]},{"entry":[{},"\/\/ operation to not be completed in which"]},{"entry":[{},"\/\/ case the same scenario as above will"]},{"entry":[{},"\/\/ apply."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ \u2190 A powerhit here means the state is"]},{"entry":[{},"\/\/ updated, and this state will not be"]},{"entry":[{},"\/\/ rentered but the primary novram and"]},{"entry":[{},"\/\/ RAM values will continue to reflect the"]},{"entry":[{},"\/\/ old meter values. Therefore, they should"]},{"entry":[{},"\/\/ never be used in the next state until"]},{"entry":[{},"\/\/ after a Save2 ( ) is performed."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"case ADD2:"]},{"entry":[{},"\/\/ \u2190 A powerhit here is the same as above."]},{"entry":[{},"meters.Save2( ); \/\/ \u2190 A powerhit here will continue this"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ commit state upon recovery. The"]},{"entry":[{},"\/\/ transactional novram memory will be"]},{"entry":[{},"\/\/ copied to the primary novram memory and"]},{"entry":[{},"\/\/ the primary novram memory will be read"]},{"entry":[{},"\/\/ into RAM co reflect the update."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ \u2190 A power hit here will reperform the same"]},{"entry":[{},"\/\/ as the above"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Some of the main rules to remember when writing powerhit tolerant states are as follows.\n\n","5. The last line of the update state should set the state to the commit state.","6. The commit state should never use the novram or RAM values of the object until after the commit is performed. i.e., Save2( ).\n\n","It should be understood that the present invention can be implemented in the form of control logic in either software or hardware or a combination of both.","The present invention has been partially described using flow charts. As will be understood by a person of ordinary skill in the art and with the benefit of the present disclosure, steps described in the flow charts can vary as to order, content, allocation of resources between steps, times repeated, and similar variations while staying fully within the inventive concepts disclosed herein.","Although the description above contains much specificity, the description should not be construed as limiting the scope of the invention; the descriptions given are merely providing an illustration of embodiments of the invention. The scope of this invention is determined by the appended claims and their legal equivalents."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
