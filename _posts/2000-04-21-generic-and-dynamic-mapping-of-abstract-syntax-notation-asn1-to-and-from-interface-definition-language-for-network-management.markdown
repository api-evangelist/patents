---
title: Generic and dynamic mapping of abstract syntax notation (ASN1) to and from interface definition language for network management
abstract: A system and method for generic and dynamic mapping of managed object metadata. The data to be mapped may include type information about an attribute, action, or notification of a managed object. The first data type is entered into the mapping system, and then a corresponding second data type is determined and returned. In this manner, data types related to the attributes, events, or other parameters of managed objects are converted between various data description languages, such as OMG IDL and ASN1. A single interface is defined to describe substantially all data types and all managed objects. Having a single object interface for all TMN managed objects saves significant resources in that there is no need to statically compile and store separate interfaces for the many objects, which may increase the scalability of a network management system dramatically.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06915324&OS=06915324&RS=06915324
owner: Sun Microsystems, Inc.
number: 06915324
owner_city: Santa Clara
owner_country: US
publication_date: 20000421
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF SEVERAL EMBODIMENTS"],"p":["1. Field of the Invention","The present invention relates generally to computer software. More particularly, the present invention relates to network management software.","2. Description of the Relevant Art","The field of network management involves the management of networked devices, often remotely. A computer network is a linked group of two or more computers. Generally, networks may be classified as Local-Area Networks (LANs) or Wide-Area Networks (WANs). In a LAN, the computers or devices are typically connected together within a \u201clocal\u201d area such as a home, office, or group of offices. In a WAN, the computers or devices are typically separated by a greater distance and are often connected via telephone\/communication lines, radio waves, or other suitable means of connection.","Networks are usually classified using three properties: topology, protocol, and architecture. Topology specifies the geometric arrangement of the network. Common topologies are bus, ring, and star configurations. A network's protocol specifies a common set of rules and\/or signals, such as Ethernet or Token Ring, that the networked devices use to communicate with each other. A network's architecture typically specifies one of the two major types of network architecture: peer-to-peer or client\/server. In a peer-to-peer networking configuration, there is no server, and computers simply connect with each other in a workgroup to share files, printers, services, and Internet access. Client\/server networks often include a domain controller to which all of the networked computers log on. This server may provide various services such as centrally routed Internet access, e-mail, file sharing, printer access, and security services.","Many types of devices may be managed over a network, such as printers, scanners, phone systems, copiers, and many other devices and appliances configured for network operation. Managing such devices tends to require that the data types of each device's control parameters and signals be well defined. For example, a networked printer might have a Boolean status parameter that indicates whether the device is currently on or off and a control parameter which turns the printer on or off. The printer may also be capable of generating an alert signal indicating, for example, that the toner level is low. The network management software should be able to read and write these data correctly in order to manage the device. To do this, information about the data is required. Such information is referred to as metadata, or \u201cdata about data.\u201d Metadata may typically describe what type of data (string, integer, Boolean, structure) an object has and how the data are formatted. Metadata is essential for understanding information related to managed devices, as well as information stored in data warehouses. Typically, network management software manages a given device by storing and manipulating a representation of its pertinent data as a software object, herein referred to as a \u201cmanaged object.\u201d This object is the virtual representation of the device on the network.",{"@attributes":{"id":"p-0008","num":"0007"},"figref":["FIG. 1","FIG. 1"],"i":["a ","a","a","a","b","n","b","a","a","b","n"],"b":["156","151","152","153","154","155","108","150","170","160","150","170","171","171","171","160","170","108","150","108","160","161","161","161","160","170","160","150"]},"One TMN approach to managing objects over a network is the Simple Network Management Protocol (SNMP), a set of protocols for managing complex networks. SNMP works by sending messages, called protocol data units (PDUs), to different parts of a network. SNMP-compliant devices, called agents, store data about themselves in Management Information Bases (MIBs) and return this data to the SNMP requesters. The metadata used by SNMP to describe managed object data variables includes the variable title, the data type of the variable (e.g. integer, string), whether the variable is read-only or read-write, and the value of the variable. SNMP works over the TCP\/IP (Transport Control Protocol\/ Internet Protocol) communication stack. SNMP also uses UDP over IP, and also may support TCP over IP. It is widely held, however, that SNMP was developed as a simple \u201cquick fix\u201d and was never intended to be a permanent solution to network management. Consequently, one problem with SNMP is that the information it specifies is neither detailed nor well-organized enough to adequately serve the expanding needs of modern networking.","Another example of a TMN network management protocol is the Common Management Information Protocol (CMIP). In the U.S. the CMIP protocol is primarily run over TCP\/IP, while in Europe it is generally run over the OSI (Open Systems Interconnection) communication stack and was designed to replace SNMP and address SNMP's shortcomings by providing a larger, more detailed network manager. Its basic design is similar to SNMP: Management requests, management responses, and notifications are employed to monitor a network. These correspond to SNMP's PDUs. CMIP, however, contains eleven types of messages, compared to SNMP's five types of PDUs.","In CMIP, variables are seen as complex and sophisticated data structures with many attributes. These include: variable attributes, which represent the variable's characteristics (e.g., its data type, whether it is writable); variable behaviors, or the actions of that variable that can be triggered; and notifications, or event reports generated by the variable whenever a specified event occurs (e.g., a terminal shutdown would cause a variable notification event).","As a comparison, SNMP only employs variable attributes and notifications, but not variable behaviors. One of the strongest features of the CMIP protocol is that its variables not only relay information to and from the terminal (as in SNMP), but they can also be used to perform tasks that would be impossible under SNMP. For instance, if a terminal on a network cannot reach its fileserver for a predetermined number of tries, then CMIP can notify the appropriate personnel of the event. With SNMP, a user would need to explicitly keep track of the number of unsuccessful attempts to reach the fileserver. CMIP thus results in a more efficient network management system, as less work is required by a user to keep updated on the status of the network.","A significant disadvantage of the CMIP protocol is that it requires more system resources than SNMP, often by a factor of ten. Thus, any move to CMIP from SNMP requires a dramatic upgrade in network resources. Another disadvantage with CMIP is that it is very difficult to program; the variable metadata includes so many different components that few programmers are generally able to use the variables to their full potential.","Both of the above protocols have been implemented in a number of programming languages, such as C, C++, and Java\u2122. However, network management software which takes advantage of SNMP or CMIP must be written specifically for the language of the protocol implementation. In other words, SNMP-based and CMIP-based network management software is dependent upon a particular programming language and protocol implementation.","A middleware standard used extensively in network management is the Common Object Request Broker Architecture (CORBA), which is provided by the Object Management Group (OMG). CORBA specifies a system that provides interoperability between objects in a heterogeneous, distributed environment and in a way transparent to the programmer. Its design is based on the OMG Object Model, which defines common object semantics for specifying the externally visible characteristics of objects in a standard and implementation-independent way. In this model, clients request services from objects (which will also be called servers) through a well-defined interface. This interface is specified in the OMG Interface Definition Language (IDL).","In CORBA, a client accesses an object by issuing a request to the object. The request is an event, and it carries information including an operation, the object reference of the service provider, and actual parameters, if any. The object reference is an object name that reliably defines an object.","A central component of CORBA is the Object Request Broker (ORB). The ORB encompasses the communication infrastructure necessary to identify and locate objects, handle connection management, and deliver data. In general, the ORB is not required to be a single component; it is simply defined by its interfaces. The basic functionality provided by the ORB includes passing the requests from clients to the object implementations on which they are invoked. The ORB acts as the middleware between clients and servers. In the CORBA model, a client can request a service without knowing anything about what servers are attached to the network. The various ORBs receive the requests, forward them to the appropriate servers, and then hand the results back to the client.","In CORBA, a client first looks up the object (server) it wants to communicate with. The ORB, as a result of the lookup operation, returns an object reference (a handle) of the server to the client. The client then uses the object reference to invoke operations on the object as a function call in the chosen programming language. The ORB intercepts the client request, collects the information about the operation and the request parameter values, encodes it in IIOP, and sends it to the object (server). The ORB on the object side (server) translates the request into a programming language specific function call on the server object. The server object then processes the request and returns a response, if any. The ORB intercepts the response, encodes the response and its parameters into IIOP, and sends it to the client. The ORB on the client side then returns the response to the client as the return value of the function call originally made as part of issuing the request.","GDMO (Guidelines for Definition of Managed Objects) is a standard for defining objects in a network in a consistent way. With a consistent \u201clanguage\u201d for describing such objects as workstations, LAN servers, and switches, programs can be written to control or sense the status of network elements throughout a network. GDMO prescribes how a network product manufacturer must describe the product formally so that others can write programs that recognize and deal with the product. Using GDMO with ASN1, descriptions may be made of the class or classes of the object, how the object behaves, its attributes, and classes that it may inherit.","GDMO is part of the CMIP and also the guideline for defining network objects under TMN. The object definitions created using GDMO and related tools form a Management Information Base (MIB). GDMO uses Abstract Syntax Notation One (ASN1) as the rules for syntax and attribute encoding when defining the objects. Abstract Syntax Notation One is a language that defines the way data is sent across dissimilar communication systems. ASN1 ensures that the data received is the same as the data transmitted by providing a common syntax for specifying application layer (e.g., program-to-program communications) protocols. Each communications system contains a similar ASN1 encoding\/decoding scheme written in the language used on that particular system. When one system wants to send data to another, the first system encodes the data into ASN1, sends the data, and the second system receives and decodes the data using the decoder written in the language used on that system.","In response to the difficulties presented by SNMP and CMIP, the Object Management Group (OMG) and Joint Inter-Domain Management (JIDM) have defined Interface Definition Language (IDL) for network management, which is used to access object instance data and may be used across a plurality of programming languages and across a plurality of platforms. JIDM IDL allows programmers to write only one set of interfaces for a particular object across multiple programming languages, rather than having to write a new set of interfaces for each programming language. Although the use of IDL as a programming-language-independent and platform-independent interface to define CORBA services and objects greatly improves the ease with which network objects may be managed, there is a significant problem in that for each TMN object to be managed, an IDL interface must be defined and compiled. This problem leads to a great proliferation of object interfaces which must be learned to manage the network effectively. The management of such a large number of compiled object-specific interfaces requires significant memory and disk space resources and degrades the performance and scalability of management applications. Whenever a new object type is to be added to a network, the system must be shut down and recompiled with the new object interface. With the great number of object interfaces involved, compile times may be exceedingly long. Because many network management systems, especially in the field of telecommunications network management, are expected to be operable continuously with no downtime, adding or removing managed object types may become problematic.","Therefore, improved systems and methods for managing network devices are desired.","The problems outlined above are in large part solved by various embodiments of a system and method for generic and dynamic mapping of managed object metadata as disclosed herein. In one embodiment, an IDL type may be mapped to a corresponding ASN1 type. The data to be mapped may include type information about an attribute, action, or notification of a managed object. The first data type may be entered into the mapping system, then the corresponding second data type may be determined. In one embodiment, determining the corresponding second data type may be accomplished via a lookup table. Finally, the second data type may be returned. In this manner, data types related to the attributes, events, or other parameters of managed objects may be converted between various data description languages, such as OMG IDL and ASN1.","In one embodiment, one of the data types may be represented in a generic interface description language which is operable to describe interfaces to managed objects across a plurality of platforms and across a plurality of programming languages, and is class independent. As used herein, the term \u201cclass independent\u201d refers to the property that a single interface may be defined to describe substantially all data types and all managed objects. Given the number of different types of TMN objects one may need to manage on a network, having a single object interface for all of them saves significant resources in that there is no need to statically compile and store separate interfaces for the many objects, which may increase the scalability of a network management system dramatically. This also means that one may add a new object to the system without bringing the system down to compile a new interface, making it much easier to maintain system operations with little or no downtime.","In one embodiment, the first data type may be a complex object data type in GDMO\/ASN1, which may be mapped to a sequence of a generic primitive data type in IDL, such as the <any> data type. As another example, the complex ASN1 object data type may be mapped to a choice structure in IDL, where the choice structure includes a generic value field (<any>), a plurality of data types, and a selector index, whereby the appropriate data type of the generic value may be determined. Alternately, the converse of the above mappings may be performed.","In one embodiment, an IDL-ASN1 converter framework library in conjunction with a converter implementation library may provide a suitable system for managed object data type conversions between various data description languages. In one embodiment, when a CORBA client application invokes a management request on a Request Gateway, the Gateway may convert the request parameter values in IDL data types to PMI's ASN1Values. PMI (Portable Management Interface) is a proprietary C++ API that is used in developing C++ management and agent applications (managers and agents). Similarly, when the Gateway receives a response from an enterprise manager, it may convert the response parameter values in PMI's ASN1Values to values in IDL data types. This conversion facility may be used extensively in both request and event network traffic, and so in one embodiment, common libraries may be used.","In one embodiment, the framework library provides a collection of classes that may be used by the clients of the converter libraries. Most classes in the converter framework library are handle classes (or wrappers) to the real implementation (or body) classes in the converter implementation library. Framework classes hide the details of the real implementation classes and provide a simple, consistent interface to any data type converter.","In one embodiment, an IDLValue class is a data-holder used to hold IDL values in CORBA::Any, the CORBA generic data type. Therefore, only one interface may be used for converting any data type. The use of a single generic primitive data type, along with the simple container types of set and sequence, provides an efficient, simple approach to managing managed object metadata across multiple platforms and multiple programming languages, in addition to providing a generic interface to all managed object classes.","Consider the conversion process for a complex data type, such as the ASN1 SET OF type. To convert an attribute whose ASN1 type is SET OF INTEGER, ASN1 SET OF is mapped to IDL sequence<any>. The \u2018any\u2019 in the sequence contains the IDL integer. When the user wants to convert values from IDL sequence<any> to ASN1 SET OF INTEGER, a generic converter method may be invoked. This method, in turn, may invoke the ASN1 sequence-specific implementation converter method. Since ASN1 SETOF is a constructed type, it may get the contained type. From that type, it may create a generic converter for the contained type. Then the ASN1 sequence-specific implementation converter method may invoke the generic converter method on the contained type. Since the contained type happens to be a simple type INTEGER, this method may eventually invoke the ASN1 integer converter method on the indexed element of the sequence. The integer converter is operable to convert values to ASN1, at which point recursion ends. The other complex types typically use the same pattern as described above, using recursive invocations of convert methods on the contained or referred types until the simple types are reached.","The combination of using IDL and the generic type <any> provides an efficient, generic solution to mapping data types across multiple platforms, multiple programming languages, and multiple object classes.","While the invention is susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood, however, that the drawing and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.",{"@attributes":{"id":"h-0005","num":"0000"},"figref":"FIG. 1","i":"b"},"Turning now to the drawings, is an illustration of a typical, general-purpose computer system  which is suitable for implementing various embodiments of the system and method for network management as disclosed herein. The computer system  includes at least one central processing unit (CPU) or processor . The CPU  is coupled to a memory  and a read-only memory (ROM) . The memory  is representative of various types of possible memory media: for example, hard disk storage, floppy disk storage, removable disk storage, or random access memory (RAM). The terms \u201cmemory,\u201d \u201cmemory medium,\u201d and \u201cstorage medium\u201d may include an installation medium, e.g., a CD-ROM or floppy disk, a computer system memory such as DRAM, SRAM, EDO RAM, etc., or a non-volatile memory such as a magnetic media, e.g., a hard drive or optical storage. The memory medium may include other types of memory as well, or combinations thereof. In addition, the memory medium may be located in a first computer in which the programs are executed, or may be located in a second different computer which connects to the first computer over a network. In the latter instance, the second computer provides the program instructions to the first computer for execution.","As shown in , typically the memory  permits two-way access: it is readable and writable. The ROM , on the other hand, is readable but not writable. The memory  and\/or ROM  may store instructions and\/or data which implement all or part of the system and method described in detail herein, and the memory  and\/or ROM  may be utilized to install the instructions and\/or data. In various embodiments, the computer system  may take various forms, including a personal computer system, desktop computer, laptop computer, palmtop computer, mainframe computer system, workstation, network appliance, network computer, Internet appliance, personal digital assistant (PDA), embedded device, smart phone, television system, or other suitable device. In general, the term \u201ccomputer system\u201d can be broadly defined to encompass any device having a processor which executes instructions from a memory medium.","The CPU  may be coupled to a network . The network  is representative of various types of possible networks: for example, a local area network (LAN), wide area network (WAN), or the Internet. The system and method for network management as disclosed herein may therefore be implemented on a plurality of heterogeneous or homogeneous networked computer systems  through one or more networks . The CPU  may acquire instructions and\/or data for implementing system and method for network management as disclosed herein over the network .","Through an input\/output bus , the CPU  may also coupled to one or more input\/output devices that may include, but are not limited to, video monitors or other displays, track balls, mice, keyboards, microphones, touch-sensitive displays, magnetic or paper tape readers, tablets, styluses, voice recognizers, handwriting recognizers, printers, plotters, scanners, and any other devices for input and\/or output. The CPU  may acquire, instructions and\/or data for implementing the system and method for network management as disclosed herein through the input\/output bus .","The computer system  is operable to execute one or more computer programs. The computer programs may comprise operating system or other system software, application software, utility software, Java\u2122 applets, and\/or any other sequence of instructions. Typically, an operating system performs basic tasks such as recognizing input from the keyboard, sending output to the display screen, keeping track of files and directories on the disk, and controlling peripheral devices such as disk drives and printers. Application software runs on top of the operating system and provides additional functionality. Because applications take advantage of services offered by operating systems, and because operating systems differ in the services they offer and in the way they offer the services, an application must usually be designed to run on a particular operating system. The computer programs are stored in a memory medium or storage medium such as the memory  and\/or ROM , or they may be provided to the CPU  through the network  or I\/O bus .","In one embodiment, the computer programs executable by the computer system  may be implemented in an object-oriented programming language. In an object-oriented programming language, data and related methods can be grouped together or encapsulated to form an entity known as an object. All objects in an object-oriented programming system belong to a class, which can be thought of as a category of like objects which describes the characteristics of those objects. Each object is created as an instance of the class by a program. The objects may therefore be said to have been instantiated from the class. The class sets out variables and methods for objects which belong to that class. The definition of the class does not itself create any objects. The class may define initial values for its variables, and it normally defines the methods associated with the class (i.e., includes the program code which is executed when a method is invoked.) The class may thereby provide all of the program code which will be used by objects in the class, hence maximizing re-use of code which is shared by objects in the class.","FIG. : CORBA Gateway",{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 2","FIG. 2"],"b":["206","206","206","206","202","206","214","216","202","208","202","202","218"],"i":["a ","b"]},"In one embodiment, an enterprise manager  may be coupled to the CORBA gateway  via a proprietary or platform-dependent interface such as Portable Management Interface (PMI)  from Sun Microsystems, Inc. The enterprise manager  may include various enterprise management components such as a Management Information System (MIS), etc. Also coupled to the enterprise manager  via PMI  may be one or more PMI applications . PMI applications may include, for example, applications which provide access to event notification, subscription, and propagation services and access to object instance information. In one embodiment, the enterprise manager  may be Solstice Enterprise Manager (SEM) from Sun Microsystems, Inc., and examples of the one or more PMI applications  that use PMI to communicate with the SEM MIS may include SEM Viewer, SEM Alarm Manager, SEM Discovery, etc. In one embodiment, the CORBA gateway  may translate the CORBA manager requests  from IDL to PMI requests . Similarly, the CORBA gateway  may translate the enterprise manager PMI responses and PMI events  to IDL\/IIOP responses and events  which may be passed on through the CORBA ORB  to the manager applications  in the form of IDL responses and CORBA events .","In one embodiment, manager applications  may request information regarding managed objects on the network via the CORBA Gateway . The managed objects may represent devices such as cell phones, cell phone towers, phone systems, faxes, routers, switches, etc., which may be interconnected via networks. The data related to such objects may exist in a variety of formats, and so must be translated to forms readily understood by the manager applications . This function may be performed by a component of the CORBA Gateway . More specifically, a mapping system may be invoked by the CORBA Gateway  to translate managed object data and metadata between various data formats, such as OMG IDL and ASN1.","FIG. : Mapping From A First Data Type To A Second Data Type","In one embodiment, a converter framework may provide a suitable system for managed object data type conversions between various data description languages in support of communication between the CORBA Gateway  and an enterprise manager . For example, when a manager application  initiates a request on the CORBA Gateway , the Gateway  may convert the request parameter values in IDL data types to PMI's ASN1Values. Similarly, when the Gateway  receives a response from an enterprise manager , it may convert the response parameter values in PMI's ASN1Values to values in IDL data types.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 3","b":["302","304","306"]},"In one embodiment, one of the data types is represented in a generic interface description language which is operable to describe interfaces to managed objects across a plurality of platforms and across a plurality of programming languages, and is class independent. As used herein, the term \u201cclass independent\u201d refers to the property that a single interface may be defined to describe substantially all data types and all managed objects. The benefits of having a generic interface to managed object data types are substantial. Given the number of different types of TMN objects one may need to manage on a network, having a single object interface for all of them saves significant resources in that there is no need to statically compile and store separate interfaces for the many objects, which may increase the scalability of a network management system dramatically. This also means that one may add a new object to the system without bringing the system down to compile a new interface, making it much easier to maintain system operations with little or no downtime.","For example, the first data type may be a complex object data type in GDMO\/ASN1, which may be mapped to a sequence of a generic primitive data type in IDL, such as the <any> data type. As another example, the complex ASN1 object data type may be mapped to a choice structure in IDL, where the choice structure includes a generic value field (<any>), a plurality of data types, and a selector index, whereby the appropriate data type of the generic value may be determined. Alternately, the converse of the above mappings may be performed.","FIG. : IDL-ASN1Converter Framework Object Inheritance Diagram",{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 4","b":["206","208","208","208"]},"Because there is potential for different mappings of IDL data types to ASN1 data types, in one embodiment, two separate libraries may be used: a converter framework library and a converter implementation library. The use of converter implementation libraries may allow various different mappings to be used easily by implementing them as plug-in modules. In one embodiment, the two libraries may include an ASN1 converter framework library  and a C++ IDL-ASN1 converter implementation library . The added benefit of this approach is that the converter framework library  can be reused to support conversion of ASN1 types and values to other formats like TL-1, simply by providing an appropriate converter implementation library corresponding to the IDL-ASN1 converter implementation library .","In one embodiment, the converter framework and converter implementation may be designed as multi-threaded programs. The term \u201cmulti-threaded\u201d means that various processes, or threads, of a program may execute concurrently. In one embodiment, this feature is accommodated by the operating system under which the program runs.","Converter Framework Library","In one embodiment, the framework library  is essentially a collection of classes that may be used by the clients of the converter libraries. Most classes in the converter framework library are handle classes (or wrappers) to the real implementation (or body) classes in the converter implementation library . Framework classes hide the details of the real implementation classes and provide a simple, consistent interface to any data type converter.","Referring to , RCObject  is the base class for all other classes in the system in one embodiment. RCObject  may provide a reference-counting capability, and any real (implementation) converters are preferably inherited from this class. As  shows, the framework classes which inherit directly from RCObject  are the AbstractASN1ConverterImp1  and the GenericASN1ConverterHelper . Note that AbstractASN1ConverterImp1  also inherits from AbstractASN1Converter , as does GenericASN1Converter , which uses GenericASN1ConverterHelper . The AbstractASN1Converter class  is intended to be an interface class and hence is an abstract class, i.e., no concrete instance of this class may exist. Similarly, OpaqueValue  is intended to be an interface class with no concrete instantiations. OpaqueValue  is a data-holder for data of any type.","For example, in one embodiment, C++ IDL<>ASN1 converters may create a class IDLValue , subclass of OpaqueValue , to hold C++ IDL data. In an alternate embodiment, TL1<>ASN1 converters could define their own subclasses to hold data specific to that domain.","In one embodiment, AbstractASN1ConverterImp1  is an abstract base class to be inherited by the real (implementation) converters. GenericASN1Converter  is a concrete class that is used primarily by clients of the converter libraries. Generally, users do not need to know the exact converter they are dealing with. Instead, they may use GenericASN1Converter to convert values to and from ASN1 format through IDL. GenericASN1Converters are typically created per registered attribute or event or action types. GenericASN1Converters may also be created for non-registered types (or types that may not have an Object ID). Primarily, their usage is restricted to the converter library implementation.","GenericASN1Converter  constructors may act like virtual constructors. Based on an Object ID or type, they may use GenericASN1ConverterHelper  to create the real converter. That is, the helper may help the framework create the actual converters (such as Boolean converters, etc.). GenericASN1ConverterHelper  may provide a method to create an appropriate converter based on the ASN1 Type it receives.","Note that GenericASN1ConverterHelper  may be an abstract base class to be implemented by the real converter library. The implementation helper may help create real converters based on the ASN1Type. When one of the GenericASN1Converter  constructors is invoked, GenericASN1Converter  may invoke a type lookup method, if necessary, to get the relevant ASN1Type object. Then, GenericASN1Converter  may invoke a GenericASN1ConverterHelper  method to create the actual converter corresponding to that ASN1Type object. The actual converter is then used to convert the data type.","Converter Implementation Library","Referring to , the converter implementation library  preferably provides the implementation needed by the framework to function properly. In one embodiment, the converter implementation library is operable to convert data types between IDL and ASN1 types. Users of converters typically do not interact directly with the converter implementation library . Instead, as described above, they use the GenericASN1Converter class  of the converter framework. The converter implementation library  may provide various data type converters. The design of each of these converters is similar.","As shown in FIG.  and described above, the IDLValue class  may be derived from the generic type class OpaqueValue , and the GenericASN1ConverterHelperImp1  helper class may be derived from the abstract GenericASN1ConverterHelper  class, according to one embodiment. Furthermore, each of the type converter implementation classes may be derived from the AbstractASN1ConverterImp1  class, as well as from each converter's specific ANS1 type class. For example, ASN1IntegerConverter  may be derived from the AbstractASN1ConverterImp1 class , as well as the ASN1TypeInt class , according to one embodiment.","As mentioned above, IDLValue class  is a data-holder used to hold IDL values in CORBA::Any, the CORBA generic data type. Therefore, only one interface may be used for converting any data type. IDLValue class does not have any significance other than to hold the IDL data and provide a uniform interface. CORBA::Any's copy constructor and assignment operator use deep-copy semantics, thus making it prohibitive to use a non-reference (non-pointer) member. The use of a single generic primitive data type, along with the simple container types of set and sequence, provides an efficient, simple approach to managing managed object metadata across multiple platforms and multiple programming languages.","In one embodiment, GenericASN1ConverterHelperImp1  may provide the implementation of GenericASN1ConverterHelper  abstract base class. GenericASN1ConverterHelperImp1  may generate the particular converters used by the client. For example, in one embodiment, ASN1IntegerConverter  is an actual converter that is capable of converting values between ASN1 INTEGER and IDL INTEGER types. The user typically creates a GenericASN1Converter  for, say, an INTEGER attribute. GenericASN1Converter  will utilize GenericASN1ConverterHelper  to create the ASN1IntegerConverter  object. Then the user may invoke the relevant convert method of GenericASN1Converter . GenericASN1Converter , in turn, may delegate that request to ASN1IntegerConverter . Note that ASN1IntegerConverter  cannot be created on the stack. It must be created on the heap because it is a reference counted object, and therefore, the create method is static.","Consider the conversion process for a complex data type, such as the ASN1 SET OF type. For example, to convert an attribute whose ASN1 type is SET OF INTEGER, the user typically creates the GenericASN1Converter  for this attribute. ASN1 SET OF is mapped to IDL sequence<any>. The \u2018any\u2019 in the sequence contains the IDL integer. When the user wants to convert values from IDL sequence<any> to ASN1 SET OF INTEGER, the GenericASN1Converter  converter method may be invoked. This method, in turn, may invoke the ASN1SeqOfConverter converter method. Since ASN1 SETOF is a constructed type, it may get the contained type. From that type, it may create a GenericASN1Converter  (for the contained type). Then the ASN1SeqOfConverter converter method may invoke the GenericASN1Converter  converter method on the contained type. Since the contained type happens to be a simple type INTEGER, this method may eventually invoke the ASN1IntegerConverter  converter method on the indexed element of the sequence. The integer converter is operable to convert values to ASN1, at which point recursion ends. The other complex types typically use the same pattern as described above, using recursive invocations of convert methods on the contained or referred types until the simple types are reached.","FIG. : Converter Framework with Converter Modules",{"@attributes":{"id":"p-0066","num":"0065"},"figref":["FIG. 5","FIG. 5","FIG. 2"],"b":["508","516","450","460","516","514","514","206","508","214","508","514","514","516","508","212","2","510"],"i":["a","d","a","d "]},"In one embodiment, the converter modules -are plug-in modules which are operable to plug into the converter framework , as discussed with reference to FIG. . The converter modules -may then provide various functional mappings of managed object metadata between the interface definition language and the abstract syntax notation as invoked by the converter framework . In one embodiment, each converter module -may be operable to map managed object metadata types between IDL  and ASN1 , according to that module's particular mapping. In an alternate embodiment, a converter module -may map managed object metadata types between IDL and a transaction language, such as Transaction Language One (TL-1).","The combination of using IDL and the generic type <any> provides an efficient, generic solution to mapping data types across multiple platforms, multiple programming languages, and multiple object classes. The fact that the framework described herein may accommodate a variety of plug-in modules for mapping other data types to and from IDL further enhances the suitability of the system and method for a generic and expandable solution to data and metadata type conversions.","Various embodiments may further include receiving or storing instructions and\/or data implemented in accordance with the foregoing description upon a carrier medium. Suitable carrier media may include storage media or memory media such as magnetic or optical media, e.g., disk or CD-ROM, as well as transmission media or signals such as electrical, electromagnetic, or digital signals, conveyed via a communication medium such as network  and\/or a wireless link.","While the present invention has been described with reference to particular embodiments, it will be understood that the embodiments are illustrated and that the invention scope is not so limited. Any variations, modifications, additions and improvements to the embodiments described are possible. These variations, modifications, additions and improvements may fall within the scope of the invention as detailed within the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Other objects and advantages of the invention will become apparent upon reading the following detailed description and upon reference to the accompanying drawings in which:",{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 1","i":"a "},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 1","i":"b"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
