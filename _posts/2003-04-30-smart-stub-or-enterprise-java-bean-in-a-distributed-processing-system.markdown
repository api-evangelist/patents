---
title: Smart stub or enterprise Javaâ„¢ bean in a distributed processing system
abstract: A clustered enterprise distributed processing system. The distributed processing system includes a first and a second computer coupled to a communication medium. The first computer includes a virtual machine (JVM) and kernel software layer for transferring messages, including a remote virtual machine (RJVM). The second computer includes a JVM and a kernel software layer having a RJVM. Messages are passed from a RJVM to the JVM in one computer to the JVM and RJVM in the second computer. Messages may be forwarded through an intermediate server or rerouted after a network reconfiguration. Each computer includes a Smart stub having a replica handler, including a load balancing software component and a failover software component. Each computer includes a duplicated service naming tree for storing a pool of Smart stubs at a node.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07454755&OS=07454755&RS=07454755
owner: BEA Systems, Inc.
number: 07454755
owner_city: San Jose
owner_country: US
publication_date: 20030430
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CLAIM OF PRIORITY","COPYRIGHT NOTICE","FIELD OF THE INVENTION","CROSS REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["This application is a continuation of application Ser. No. 09\/405,260, filed Sep. 23, 1999 now U.S. Pat. No. 6,581,088, which claims the benefit of U.S. Provisional Application No. 60\/107,167, filed Nov. 5, 1998, and both are incorporated herein by reference.","A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.","The present invention relates to distributed processing systems and, in particular, computer software in distributed processing systems.","The following copending U.S. patent applications are assigned to the assignee of the present application, and their disclosures are incorporated herein by reference:\n\n","There are several types of distributed processing systems. Generally, a distributed processing system includes a plurality of processing devices, such as two computers coupled to a communication medium. Communication mediums may include wired mediums, wireless mediums, or combinations thereof, such as an Ethernet local area network or a cellular network. In a distributed processing system, at least one processing device may transfer information on the communication medium to another processing device.","Client\/server architecture  illustrated in is one type of distributed processing system. Client\/server architecture  includes at least two processing devices, illustrated as client  and application server . Additional clients may also be coupled to communication medium , such as client .","Typically, server  hosts business logic and\/or coordinates transactions in providing a service to another processing device, such as client  and\/or client . Application server  is typically programmed with software for providing a service. The software may be programmed using a variety of programming models, such as Enterprise Java\u2122 Bean (\u201cEJB\u201d) as illustrated in -. The service may include, for example, retrieving and transferring data from a database, providing an image and\/or calculating an equation. For example, server  may retrieve data from database in persistent storage  over communication medium  in response to a request from client . Application server  then may transfer the requested data over communication medium  to client .","A client is a processing device which utilizes a service from a server and may request the service. Often a user  interacts with client  and may cause client  to request service over a communication medium  from application server . A client often handles direct interactions with end users, such as accepting requests and displaying results.","A variety of different types of software may be used to program application server  and\/or client . One programming language is the Java\u2122 programming language. Java\u2122 application object code is loaded into a Java\u2122 virtual machine (\u201cJVM\u201d). A JVM is a program loaded onto a processing device which emulates a particular machine or processing device. More information on the Java\u2122 programming language may be obtained at http:\/\/www.javasoft.com, which is incorporated by reference herein.",{"@attributes":{"id":"p-0011","num":"0014"},"figref":"FIG. 1","i":["b ","a","b","c. "],"b":["100","100","100","100","100"]},"RMI is a distributed programming model often used in peer-to-peer architecture described below. In particular, a set of classes and interfaces enables one Java\u2122 object to call the public method of another Java\u2122 object running on a different JVM.","An instance of EJB is typically used in a client\/server architecture described above. An instance of EJB is a software component or a reusable pre-built piece of encapsulated application code that can be combined with other components. Typically, an instance of EJB contains business logic. An EJB instance stored on server  typically manages persistence, transactions, concurrency, threading, and security.","JNDI provides directory and naming functions to Java\u2122 software applications.","Client\/server architecture  has many disadvantages. First, architecture  does not scale well because server  has to handle many connections. In other words, the number of clients which may be added to server  is limited. In addition, adding twice as many processing devices (clients) does not necessarily provide you with twice as much performance. Second, it is difficult to maintain application code on clients  and . Third, architecture  is susceptible to system failures or a single point of failure. If server  fails and a backup is not available, client  will not be able to obtain the service.",{"@attributes":{"id":"p-0016","num":"0019"},"figref":"FIG. 1","i":"c ","b":["160","151","152","153","154","155"]},"Multi-tier architecture  has similar client\/server architecture  disadvantages described above.",{"@attributes":{"id":"p-0018","num":"0021"},"figref":"FIG. 2","b":["214","216","217","218","213","216","217","218","210","210","210","213"],"i":["a","b","c "]},"In a platform specific distributed processing system, each processing device may run the same operating system. This allows the use of proprietary hardware, such as shared disks, multi-tailed disks, and high speed interconnects, for communicating between processing devices. Examples of platform-specific distributed processing systems include IBM\u00ae Corporation's S\/390\u00ae Parallel Sysplex\u00ae, Compaq's Tandem Division Himalaya servers, Compaq's Digital Equipment Corporation\u2122 (DEC\u2122) Division OpenVMS\u2122 Cluster software, and Microsoft\u00ae Corporation Windows NT\u00ae cluster services (Wolfpack).",{"@attributes":{"id":"p-0020","num":"0023"},"figref":"FIG. 2","i":["b ","a ","a "],"b":["220","220","224","221","222","223","280","281","282","221","222","223","224","225","226","227","283","284","285","225","287","289","286","224","224","221","222","223","225","226","227","224"]},"TP architecture  also has many disadvantages. First, a failure of a single processing device or TP monitor  may render the network inoperable. Second, the scalability or number of processing devices (both servers and clients) coupled to TP monitor  may be limited by TP monitor  hardware and software. Third, flexibility in routing a client request to a server is limited. For example, if communication medium  is inoperable, but communication medium  becomes available, ATM  typically may not request service directly from server  over communication medium  and must access TP monitor . Fourth, a client typically does not know the state of a back-end server or other processing device. Fifth, no industry standard software or APIs are used for load balancing. And sixth, a client typically may not select a particular server even if the client has relevant information which would enable efficient service.","Therefore, it is desirable to provide a distributed processing system and, in particular, distributed processing system software that has the advantages of the prior art distributed processing systems without the inherent disadvantages. The software should allow for industry standard APIs which are typically used in either client\/server, multi-tier, or peer-to-peer distributed processing systems. The software should support a variety of computer programming models. Further, the software should enable (1) enhanced fault tolerance, (2) efficient scalability, (3) effective load balancing, and (4) session concentration control. The improved computer software should allow for rerouting or network reconfiguration. Also, the computer software should allow for the determination of the state of a processing device.","An improved distributed processing system is provided and, in particular, computer software for a distributed processing system is provided. The computer software improves the fault tolerance of the distributed processing system as well as enables efficient scalability. The computer software allows for efficient load balancing and session concentration. The computer software supports rerouting or reconfiguration of a computer network. The computer software supports a variety of computer programming models and allows for the use of industry standard APIs that are used in both client\/server and peer-to-peer distributed processing architectures. The computer software enables a determination of the state of a server or other processing device. The computer software also supports message forwarding under a variety of circumstances, including a security model.","According to one aspect of the present invention, a distributed processing system comprises a communication medium coupled to a first processing device and a second processing device. The first processing device includes a first software program emulating a processing device (\u201cJVM1\u201d) including a first kernel software layer having a data structure (\u201cRJVM1\u201d). The second processing device includes a first software program emulating a processing device (\u201cJVM2\u201d) including a first kernel software layer having a data structure (\u201cRJVM2\u201d). A message from the first processing device is transferred to the second processing device through the first kernel software layer and the first software program in the first processing device to the first kernel software layer and the first software program in the second processing device.","According to another aspect of the present invention, the first software program in the first processing device is a Java\u2122 virtual machine (\u201cJVM\u201d) and the data structure in the first processing device is a remote Java\u2122 virtual machine (\u201cRJVM\u201d). Similarly, the first software program in the second processing device is a JVM and the data structure in the second processing device is a RJVM. The RJVM in the second processing device corresponds to the JVM in the first processing device.","According to another aspect of the present invention, the RJVM in the first processing device includes a socket manager software component, a thread manager software component, a message routing software component, a message compression software component, and\/or a peer-gone detection software component.","According to another aspect of the present invention, the first processing device communicates with the second processing device using a protocol selected from the group consisting of Transmission Control Protocol (\u201cTCP\u201d), Secure Sockets Layer (\u201cSSL\u201d), Hypertext Transport Protocol (\u201cHTTP\u201d) tunneling, and Internet InterORB Protocol (\u201cIIOP\u201d) tunneling.","According to another aspect of the present invention, the first processing device includes memory storage for a Java\u2122 application.","According to another aspect of the present invention, the first processing device is a peer of the second processing device. Also, the first processing device is a server and the second processing device is a client.","According to another aspect of the present invention, a second communication medium is coupled to the second processing device. A third processing device is coupled to the second communication medium. The third processing device includes a first software program emulating a processing device (\u201cJVM3\u201d), including a kernel software layer having a first data structure (\u201cRJVM1\u201d), and a second data structure (\u201cRJVM2\u201d).","According to still another aspect of the present invention, the first processing device includes a stub having a replica-handler software component. The replica-handler software component includes a load balancing software component and a failover software component.","According to another aspect of the present invention, the first processing device includes an Enterprise Java\u2122 Bean object.","According to still another aspect of the present invention, the first processing device includes a naming tree having a pool of stubs stored at a node of the tree and the second processing device includes a duplicate of the naming tree.","According to still another aspect of the present invention, the first processing device includes an application program coded in a stateless program model and the application program includes a stateless session bean.","According to still another aspect of the present invention, the first processing device includes an application program coded in a stateless factory program model and the application program includes a stateful session bean.","According to still another aspect of the present invention, the first processing device includes an application program coded in a stateful program model and the application program includes an entity session bean.","According to still another aspect of the present invention, an article of manufacture including an information storage medium is provided. The article of manufacture comprises a first set of digital information for transferring a message from a RJVM in a first processing device to a RJVM in a second processing device.","According to another aspect of the present invention, the article of manufacture comprises a first set of digital information, including a stub having a load balancing software program for selecting a service provider from a plurality of service providers.","According to another aspect of the present invention, the stub has a failover software component for removing a failed service provider from the plurality of service providers.","According to another aspect of the present invention, the load balancing software component selects a service provider based on an affinity for a particular service provider.","According to another aspect of the present invention, the load balancing software component selects a service provider in a round robin manner.","According to another aspect of the present invention, the load balancing software component randomly selects a service provider.","According to another aspect of the present invention, the load balancing software component selects a service provider from the plurality of service providers based upon the load of each service provider.","According to another aspect of the present invention, the load balancing software component selects a service provider from the plurality of service providers based upon the data type requested.","According to another aspect of the present invention, the load balancing software component selects a service provider from the plurality of service providers based upon the closest physical service provider.","According to another aspect of the present invention, the load balancing software component selects a service provider from the plurality of service providers based upon a time period in which each service provider responds.","According to another aspect of the present invention, the article of manufacture comprises a first set of digital information, including an Enterprise Java\u2122 Bean object for selecting a service provider from a plurality of service providers.","According to another aspect of the present invention, a stub is stored in a processing device in a distributed processing system. The stub includes a method comprising the steps of obtaining a list of service providers and selecting a service provider from the list of service providers.","According to another aspect of the present invention, the method further includes removing a failed service provider from the list of service providers.","According to still another aspect of the present invention, an apparatus comprises a communication medium coupled to a first processing device and a second processing device. The first processing device stores a naming tree including a remote method invocation (\u201cRMI\u201d) stub for accessing a service provider. The second processing device has a duplicate naming tree and the service provider.","According to another aspect of the present invention, the naming tree has a node including a service pool of current service providers.","According to another aspect of the present invention, the service pool includes a stub.","According to another aspect of the present invention, a distributed processing system comprises a first computer coupled to a second computer. The first computer has a naming tree, including a remote invocation stub for accessing a service provider. The second computer has a replicated naming tree and the service provider.","According to another aspect of the present invention, a distributed processing system comprising a first processing device coupled to a second processing device is provided. The first processing device has a JVM and a first kernel software layer including a first RJVM. The second processing device includes a first JVM and a first kernel software layer including a second RJVM. A message may be transferred from the first processing device to the second processing device when there is not a socket available between the first JVM and the second JVM.","According to another aspect of the present invention, the first processing device is running under an applet security model, behind a firewall or is a client, and the second processing device is also a client.","Other aspects and advantages of the present invention can be seen upon review of the figures, the detailed description, and the claims which follow.","The invention will be better understood with reference to the drawings and detailed description below. In the drawings, like reference numerals indicate like components.","I. Clustered Enterprise Java\u2122 Distributed Processing System","A. Clustered Enterprise Java\u2122 Software Architecture",{"@attributes":{"id":"p-0074","num":"0077"},"figref":"FIG. 3","i":"a ","b":["380","351","310","353","352","354","355","356","354","355","357","358","355","358"]},{"@attributes":{"id":"p-0075","num":"0078"},"figref":["FIG. 3","FIG. 3"],"i":["b ","a","c"],"b":["355","355","363","364","356","356","360","361","161","362","356","364","363"]},"B. Distributed Processing System",{"@attributes":{"id":"p-0077","num":"0080"},"figref":"FIG. 3","b":["300","301","301","301","301","301"]},"A variety of different types of processing devices may be coupled to communication medium . In an embodiment, a processing device may be a general purpose computer  as illustrated in  and described below. One of ordinary skill in the art would understand that  and the below description describes one particular type of processing device where multiple other types of processing devices with a different software and hardware configurations could be utilized in accordance with an embodiment of the present invention. In an alternate embodiment, a processing device may be a printer, handheld computer, laptop computer, scanner, cellular telephone, pager, or equivalent thereof.",{"@attributes":{"id":"p-0079","num":"0082"},"figref":["FIG. 3","FIG. 3","FIG. 3"],"i":["c ","c"],"b":["302","303","301","303","305","301","304","305","304","301","302"]},"Server  transfers information over communication medium  to server  by using network software and network software , respectively. In an embodiment, network software ,, and include communication medium software driver , Transmission Control Protocol software , and Internet Protocol software  (\u201cTCP\/IP\u201d). Client  also includes network software for transferring information to server  over communication medium . Network software in server  is also used to transfer information to client  by way of communication medium .","According to an embodiment of the present invention, each processing device in clustered enterprise Java\u2122 architecture  includes a message-passing kernel  that supports both multi-tier and peer-to-peer functionality. A kernel is a software program used to provide fundamental services to other software programs on a processing device.","In particular, server , server , and client  have kernels , , and , respectively. In particular, in order for two JVMs to interact, whether they are clients or servers, each JVM constructs an RJVM representing the other. Messages are sent from the upper layer on one side, through a corresponding RJVM, across the communication medium, through the peer RJVM, and delivered to the upper layer on the other side. In various embodiments, messages can be transferred using a variety of different protocols, including, but not limited to, Transmission Control Protocol\/Internet Protocol (\u201cTCP\/IP\u201d), Secure Sockets Layer (\u201cSSL\u201d), Hypertext Transport Protocol (\u201cHTTP\u201d) tunneling, and Internet InterORB Protocol (\u201cIIOP\u201d) tunneling, and combinations thereof. The RJVMs and socket managers create and maintain the sockets underlying these protocols and share them between all objects in the upper layers. A socket is a logical location representing a terminal between processing devices in a distributed processing system. The kernel maintains a pool of execute threads and thread manager software component  multiplexes the threads between socket reading and request execution. A thread is a sequence of executing program code segments or functions.","For example, server  includes JVM1 and Java\u2122 application . Server  also includes a RJVM2 representing the JVM2 of server . If a message is to be sent from server  to server , the message is sent through RJVM2 in server  to RJVM1 in server .","C. Message Forwarding","Clustered enterprise Java\u2122 network  is able to forward a message through an intermediate server. This functionality is important if a client requests a service from a back-end server through a front-end gateway. For example, a message from server  (client ) and, in particular, JVM1 may be forwarded to client  (back-end server ) or JVM3 through server  (front-end gateway) or JVM2. This functionality is important in controlling session concentration or how many connections are established between a server and various clients.","Further, message forwarding maybe used in circumstances where a socket cannot be created between two JVMs. For example, a sender of a message is running under the applet security model which does not allow for a socket to be created to the original server. A detailed description of the applet security model is provided at http\/\/:www.javasoft.com, which is incorporated herein by reference. Another example includes when the receiver of the message is behind a firewall. Also, as described below, message forwarding is applicable if the sender is a client and the receiver is a client and thus does not accept incoming sockets.","For example, if a message is sent from server  to client , the message would have to be routed through server . In particular, a message handoff, as illustrated by , between RJVM3 (representing client ) would be made to RJVM2 (representing server ) in server . The message would be transferred using sockets between RJVM2 in server  and RJVM1 in server . The message would then be handed off, as illustrated by dashed line , from RJVM1 to RJVM3 in server . The message would then be passed between sockets of RJVM3 in server  and RJVM2 in client . The message then would be passed, as illustrated by the dashed line , from RJVM2 in client  to RJVM1 in client .","D. Rerouting","An RJVM in client\/server is able to switch communication paths or communication mediums to other RJVMs at any time. For example, if client  creates a direct socket to server , server  is able to start using the socket instead of message forwarding through server . This embodiment is illustrated by a dashed line and box representing client . In an embodiment, the use of transferring messages by RJVMs ensures reliable, in-order message delivery after the occurrence of a network reconfiguration. For example, if client  was reconfigured to communication medium  instead of communication medium  as illustrated in . In an alternate embodiment, messages may not be delivered in order.","An RJVM performs several end-to-end operations that are carried through routing. First, an RJVM is responsible for detecting when a respective client\/server has unexpectedly died. In an embodiment, peer-gone selection software component , as illustrated in , is responsible for this function. In an embodiment, an RJVM sends a heartbeat message to other clients\/servers when no other message has been sent in a predetermined time period. If the client\/server does not receive a heartbeat message in the predetermined count time, a failed client\/server which should have sent the heartbeat, is detected. In an embodiment, a failed client\/server is detected by connection timeouts or if no messages have been sent by the failed client\/server in a predetermined amount of time. In still another embodiment, a failed socket indicates a failed server\/client.","Second, during message serialization, RJVMs, in particular, message compression software , abbreviate commonly transmitted data values to reduce message size. To accomplish this, each JVM\/RJVM pair maintains matching abbreviation tables. For example, JVM1 includes an abbreviation table and RJVM1 includes a matching abbreviation table. During message forwarding between an intermediate server, the body of a message is not deserialized on the intermediate server in route.","E. Multi-tier\/Peer-to-Peer Functionality","Clustered enterprise Java\u2122 architecture  allows for multi-tier and peer-to-peer programming.","Clustered enterprise Java\u2122 architecture  supports an explicit syntax for client\/server programming consistent with a multi-tier distributed processing architecture. As an example, the following client-side code fragment writes an informational message to a server's log file:\n\n","The first line establishes a session with the acme server using the t3 protocol. If RJVMs do not already exist, each JVM constructs an RJVM for the other and an underlying TCP socket is established. The client-side representation of this session\u2014the T3Client object\u2014and the server-side representation communicate through these RJVMs. The server-side supports a variety of services, including database access, remote file access, workspaces, events, and logging. The second line obtains a LogServices object and the third line writes the message.","Clustered enterprise Java\u2122 computer architecture  also supports a server-neutral syntax consistent with a peer-to-peer distributed processing architecture. As an example, the following code fragment obtains a stub for an RMI object from the JNDI-compliant naming service on a server and invokes one of its methods.\n\n","In an embodiment, JNDI naming contexts are packaged as RMI objects to implement remote access. Thus, the above code illustrates a kind of RMI bootstrapping. The firstfourlines obtain an RMI stub for the initial context on the acme server. If RJVMs do not already exist, each side constructs an RJVM for the other and an underlying TCP socket for the t3 protocol is established. The caller-side object\u2014the RMI stub\u2014and the callee-side object\u2014an RMI impl\u2014communicate through the RJVMs. The fifth line looks up another RMI object, an Example, at the name acme.eng.example and the sixth line invokes one of the Example methods. In an embodiment, the Example impl is not on the same processing device as the naming service. In another embodiment, the Example impl is on a client. Invocation of the Example object leads to the creation of the appropriate RJVMs if they do not already exist.","II. Replica-Aware or Smart Stubs\/EJB Objects","In , a processing device is able to provide a service to other processing devices in architecture  by replicating RMI and\/or EJB objects. Thus, architecture  is easily scalable and fault tolerant. An additional service may easily be added to architecture  by adding replicated RMI and\/or EJB objects to an existing processing device or newly added processing device. Moreover, because the RMI and\/or EJB objects can be replicated throughout architecture , a single processing device, multiple processing devices, and\/or a communication medium mayfail and still not render architecture  inoperable or significantly degraded.",{"@attributes":{"id":"p-0099","num":"0112"},"figref":["FIG. 5","FIG. 8"],"i":"a ","b":["580","500","500","504","501","502","503","501","509","502","503","560","561","501","560","561","504","502","503","500","504","502","503"]},"RA RMI stub  is a Smart stub which is able to find out about all of the service providers and switch between them based on a load balancing method  and\/or failover method . In an embodiment, an RA stub  includes a replica handler  that selects an appropriate load balancing method  and\/or failover method . In an alternate embodiment, a single load balancing method and\/or single failover method is implemented. In alternate embodiments, replica handler  may include multiple load balancing methods and\/or multiple failover methods and combinations thereof. In an embodiment, a replica handler  implements the following interface:",{"@attributes":{"id":"p-0101","num":"0114"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public interface ReplicaHandler {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Object loadBalance(Object currentProvider) throws"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"RefreshAborted Exception;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Object failOver(Object failedProvider,"]},{"entry":[{},"RemoteException e) throws"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"RemoteException;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Immediately before invoking a method, RA stub  calls load balance method , which takes the current server and returns a replacement. For example, client  may be using server  for retrieving data for database or personal storage device . Load balance method  may switch to server  because server  is overloaded with service requests. Handler  may choose a server replacement entirely on the caller, perhaps using information about server  load, or handler  may request server  for retrieving a particular type of data. For example, handler  may select a particular server for calculating an equation because the server has enhanced calculation capability. In an embodiment, replica handler  need not actually switch providers on every invocation because replica handler  is trying to minimize the number of connections that are created.",{"@attributes":{"id":"p-0103","num":"0116"},"figref":["FIG. 6","FIGS. 5","FIG. 6"],"i":["a ","a","b","a "],"b":["507","507"]},"Load balancing software  begins as indicated by circle . A determination is then made in logic block  as to whether the calling thread established \u201can affinity\u201d for a particular server. A client has an affinity for the server that coordinates its current transaction and a server has an affinity for itself. If an affinity is established, control is passed to logic block , otherwise control is passed to logic block . A determination is made in logic block  whether the affinity server provides the service requested. If so, control is passed to logic block . Otherwise, control is passed to logic block . The provider of the service on the affinity server is returned to the client in logic block . In logic block , a naming service is contacted and an updated list of the current service providers is obtained. A getNextProvider method is called to obtain a service provider in logic block . Various embodiments of the getNextProvider method are illustrated in -and described in detail below. The service is obtained in logic block . Failover method  is then called if service is not provided in logic block  and load balancing method  exits as illustrated by logic block . An embodiment of failover method  is illustrated in  and described in detail below.",{"@attributes":{"id":"p-0105","num":"0118"},"figref":["FIGS. 6","FIG. 6","FIG. 6"],"i":["b","g ","a","b"],"b":["605","620","621","622","623","624","625","620","626"]},{"@attributes":{"id":"p-0106","num":"0119"},"figref":"FIG. 6","i":"c ","b":["630","631","632","633","634","630","635"]},"Still another embodiment of a getNextProvider method is illustrated in which obtains a service provider based upon the load of the service providers. A getNextProvider method  is entered as illustrated by circle . A list of current service providers is obtained in logic block . The load of each service provider is obtained in logic block . The service provider with the least load is then selected in logic block . The new service provider is then returned in logic block  and getNextProvider method  exits as illustrated by circle .","An alternate embodiment of a getNextProvider method is illustrated in which obtains a service provider based upon the type of data obtained from the service provider. A getNextProvider method  is entered as illustrated by circle . A list of current service providers is obtained in logic block . The type of data requested from the service providers is determined in logic block . The service provider is then selected based on the data type in logic block . The service provider is returned in logic block  and getNextProvider method  exits as illustrated by circle .","Still another embodiment of a getNextProvider method is illustrated in which selects a service provider based upon the physical location of the service providers. A getNextProvider method  is entered as illustrated by circle . A list of service providers is obtained as illustrated by logic block . The physical distance to each service provider is determined in logic block  and the service provider which has the closest physical distance to the requesting client is selected in logic block . The new service provider is then returned in logic block  and the getNextProvider method  exits as illustrated by circle .","Still a further embodiment of the getNextProvider method is illustrated in and selects a service provider based on the amount of time taken for the service provider to respond to previous requests. Control of getNextProvider method  is entered as illustrated by circle . A list of current service providers is obtained in logic block . The time period for each service provider to respond to a particular message is determined in logic block . The service provider which responds in the shortest time period is selected in logic block . The new service provider is then returned in logic block  and control from getNextProvider method  exits as illustrated by circle .","If invocation of a service method fails in such a way that a retry is warranted, RA  stub calls failover method , which takes the failed server and an exception indicating what the failure was and returns a new server for the retry. If a new server is unavailable, RA stub  throws an exception.",{"@attributes":{"id":"p-0112","num":"0125"},"figref":["FIG. 7","FIGS. 5"],"b":["508","508","700","701","703","508","704"],"i":["a","b"]},"While  illustrate embodiments of a replica handler , alternate embodiments include the following functions or combinations thereof implemented in a round robin manner.","First, a list of servers or service providers of a service is maintained. Whenever the list needs to be used and the list has not been recently updated, handler  contacts a naming service as described below and obtains an up-to-date list of providers.","Second, if handler  is about to select a provider from the list and there is an existing RJVM-level connection to the hosting server over which no messages have been received during the last heartbeat period, handler  skips that provider. In an embodiment, a server may later recover since death of peer is determined after several such heartbeat periods. Thus, load balancing on the basis of server load is obtained.","Third, when a provider fails, handler  removes the provider from the list. This avoids delays caused by repeated attempts to use non-working service providers.","Fourth, if a service is being invoked from a server that hosts a provider of the service, then that provider is used. This facilitates co-location of providers for chained invokes of services.","Fifth, if a service is being invoked within the scope of a transaction and the server acting as transaction coordinator hosts a provider of the service, then that provider is used. This facilitates co-location of providers within a transaction.","The failures that can occur during a method invocation may be classified as being either (1) application-related, or (2) infrastructure-related. RA stub  will not retry an operation in the event of an application-related failure, since there can be no expectation that matters will improve. In the event of an infrastructure-related failure, RA stub  may or may not be able to safely retry the operation. Some initial non-idempotent operation, such as incrementing the value of a field in a database, might have completed. In an embodiment, RA stub  will retry after an infrastructure failure only if either (1) the user has declared that the service methods are idempotent, or (2) the system can determine that processing of the request never started. As an example of the latter, RA stub  will retry if, as part of load balancing method, stub  switches to a service provider whose host has failed. As another example, a RA stub  will retry if it gets a negative acknowledgment to a transactional operation.","A RMI compiler recognizes a special flag that instructs the compiler to generate an RA stub for an object. An additional flag can be used to specify that the service methods are idempotent. In an embodiment, RA stub  will use the replica handler described above and illustrated in . An additional flag may be used to specify a different handler. In addition, at the point a service is deployed, i.e., bound into a clustered naming service as described below, the handler may be overridden.",{"@attributes":{"id":"p-0121","num":"0134"},"figref":["FIG. 5","FIG. 5"],"i":["b ","a. "],"b":"551"},"III. Replicated JNDI-Compliant Naming Service","As illustrated in , access to service providers in architecture  is obtained through a JNDI-compliant naming service, which is replicated across architecture  so there is no single point of failure. Accordingly, if a processing device which offers a JNDI-compliant naming service fails, another processing device having a replicated naming service is available. To offer an instance of a service, a server advertises a provider of the service at a particular node in a replicated naming tree. In an embodiment, each server adds a RA stub for the provider to a compatible service pool stored at the node in the server's copy of the naming tree. If the type of a new offer is incompatible with the type of offers in an existing pool, the new offer is made pending and a callback is made through a Conflict Handler interface. After either type of offer is retracted, the other will ultimately be installed everywhere. When a client looks up the service, the client obtains a RA stub that contacts the service pool to refresh the client's list of service providers.",{"@attributes":{"id":"p-0123","num":"0136"},"figref":"FIG. 4","b":["400","302","303","1","2","402","403","402","403","402","403","1","2","304","304","304","304"],"i":["a ","a","e ","e ","e "]},"Stubs for the initial context of the naming service are replica-aware or Smart stubs which initially load balance among naming service providers and switch in the event of a failure. Each instance of the naming service tree contains a complete list of the current naming service providers. The stub obtains a fresh list from the instance it is currently using. To bootstrap this process, the system uses Domain Naming Service (\u201cDNS\u201d) to find a (potentially incomplete) initial list of instances and obtains the complete list from one of them. As an example, a stub for the initial context of the naming service can be obtained as follows:\n\n","Some subset of the servers in an architecture have been bound into DNS under the name acme Cluster. Moreover, an application is still able to specify the address of an individual server, but the application will then have a single point of failure when the application first attempts to obtain a stub.","A reliable multicast protocol is desirable. In an embodiment, provider stubs are distributed and replicated naming trees are created by an IP multicast or point-to-point protocol. In an IP multicast embodiment, there are three kinds of messages: Heartbeats, Announcements, and StateDumps. Heartbeats are used to carry information between servers and, by their absence, to identify failed servers. An Announcement contains a set of offers and retractions of services. The Announcements from each server are sequentially numbered. Each receiver processes an Announcement in order to identify lost Announcements. Each server includes in its Heartbeats the sequence number of the last Announcement it has sent. Negative Acknowledgments (\u201cNAKs\u201d) for a lost Announcement are included in subsequent outgoing Heartbeats. To process NAKs, each server keeps a list of the last several Announcements that the server has sent. If a NAK arrives for an Announcement that has been deleted, the server sends a StateDump, which contains a complete list of the server's services and the sequence number of its next Announcement. When a new server joins an existing architecture, the new server NAKs for the first message from each other server, which results in StateDumps being sent. If a server does not receive a Heartbeat from another server after a predetermined period of time, the server retracts all services offered by the server not generating a Heartbeat.","IV. Programming Models","Applications used in the architecture illustrated in  use one of three basic programming models: (1) stateless or direct, (2) stateless factory or indirect, or (3) stateful or targeted, depending on the way the application state is to be treated. In the stateless model, a Smart stub returned by a naming-service lookup directly references service providers.\n\n","In this example, the two calls to example may be handled by different service providers since the Smart stub is able to switch between them in the interests of load balancing. Thus, the Example service object cannot internally store information on behalf of the application. Typically the stateless model is used only if the provider is stateless. As an example, a pure stateless provider might compute some mathematical function of its arguments and return the result. Stateless providers may store information on their own behalf, such as for accounting purposes. More importantly, stateless providers may access, an underlying persistent storage device and load application state into memory on an as-needed basis. For example, in order for example to return the running sum of all values passed to it as arguments, example might read the previous sum from a database, add in its current argument, write the new value out, and then return it. This stateless service model promotes scalability.","In the stateless factory programming model, the Smart stub returned by the lookup is a factory that creates the desired service providers, which are not themselves Smart stubs.\n\n","In this example, the two calls to example are guaranteed to be handled by the same service provider. The service provider maytherefore safely store information on behalf of the application. The stateless factory model should be used when the caller needs to engage in a \u201cconversation\u201d with the provider. For example, the caller and the provider might engage in a back-and-forth negotiation. Replica-aware stubs are generally the same in the stateless and stateless factory models, the only difference is whether the stubs refer to service providers or service provider factories.","A provider factory stub may failover at will in its effort to create a provider, since this operation is idempotent. To further increase the availability of an indirect service, application code must contain an explicit retry loop around the service creation and invocation.",{"@attributes":{"id":"p-0132","num":"0157"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"while (true) {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"try {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Example e = gf.create(\u2009);"]},{"entry":[{},"result1 = e.example(37);"]},{"entry":[{},"result2 = e.example(38);"]},{"entry":[{},"break;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} catch (Exception e) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if (!retryWarranted(e))"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"throw e;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"This would, for example, handle the failure of a provider e that was successfully created by the factory. In this case, application code should determine whether non-idempotent operations completed. To further increase availability, application code might attempt to undo such operations and retry.","In the stateful programming model, a service provider is a long-lived, stateful object identified by some unique system-wide key. Examples of \u201centities\u201d that might be accessed using this model include remote file systems and rows in a database table. A targeted provider may be accessed many times by many clients, unlike the other two models where each provider is used once by one client. Stubs for targeted providers can be obtained either by direct lookup, where the key is simply the naming-service name, or through a factory, where the key includes arguments to the create operation. In either case, the stub will not do load balancing or failover. Retries, if any, must explicitly obtain the stub again.","There are three kinds of beans in EJB, each of which maps to one of the three programming models. Stateless session beans are created on behalf of a particular caller, but maintain no internal state between calls. Stateless session beans map to the stateless model. Stateful session beans are created on behalf of a particular caller and maintain internal state between calls. Stateful session beans map to the stateless factory model. Entity beans are singular, stateful objects identified by a system-wide key. Entity beans map to the stateful model. All three types of beans are created by a factory called an EJB home. In an embodiment, both EJB homes and the beans they create are referenced using RMI. In an architecture as illustrated in , stubs for an EJB home are Smart stubs. Stubs for stateless session beans are Smart stubs, while stubs for stateful session beans and entity beans are not. The replica handler to use for an EJB-based service can be specified in its deployment descriptor.","To create an indirect RMI-based service, which is required if the object is to maintain state on behalf of the caller, the application code must explicitly construct the factory. A targeted RMI-based service can be created by running the RMI compiler without any special flags and then binding the resulting service into the replicated naming tree. A stub for the object will be bound directly into each instance of the naming tree and no service pool will be created. This provides a targeted service where the key is the naming-service name. In an embodiment, this is used to create remote file systems.","V. Hardware and Software Components",{"@attributes":{"id":"p-0137","num":"0162"},"figref":["FIG. 8","FIGS. 3-5","FIG. 8","FIG. 3","FIG. 3"],"b":["800","829","840","880","840","800","841","801","303","880","800","881","881","303","800","880","829","840"]},"Computer  is a personal or office computer that can be, for example, a workstation, personal computer, or other single-user or multi-user computer system; an exemplary embodiment uses a Sun SPARC-20 workstation (Sun Microsystems, Inc., Mountain View, Calif.). For purposes of exposition, computer  can be conveniently divided into hardware components  and software components ; however, persons of ordinary skill in the art will appreciate that this division is conceptual and somewhat arbitrary, and that the line between hardware and software is not a hard and fast one. Further, it will be appreciated that the line between a host computer and its attached peripherals is not a hard and fast one, and that in particular, components that are considered peripherals of some computers are considered integral parts of other computers. Thus, for example, user I\/O  can include a keyboard, a mouse, and a display monitor, each of which can be considered either a peripheral device or part of the computer itself, and can further include a local printer, which is typically considered to be a peripheral. As another example, persistent storage  can include a CD-ROM (compact disc read-only memory) unit, which can be either peripheral or built into the computer.","Hardware components  include a processor (CPU) , memory , persistent storage , user I\/O , and network interface  which are coupled to bus . These components are well understood by those of skill in the art and, accordingly, need be explained only briefly here.","Processor  can be, for example, a microprocessor or a collection of microprocessors configured for multiprocessing.","Memory  can include read-only memory (ROM), random-access memory (RAM), virtual memory, or other memory technologies, singly or in combination. Persistent storage  can include, for example, a magnetic hard disk, a floppy disk, or other persistent read-write data storage technologies, singly or in combination. It can further include mass or archival storage, such as can be provided by CD-ROM or other large-capacity storage technology. (Note that file server  provides additional storage capability that processor  can use.)","User I\/O (input\/output) hardware  typically includes a visual display monitor such as a CRT or flat-panel display, an alphanumeric keyboard, and a mouse or other pointing device, and optionally can further include a printer, an optical scanner, or other devices for user input and output.","Network I\/O hardware  provides an interface between computer  and the outside world. More specifically, network I\/O  lets processor  communicate via connection  with other processors and devices through LAN  and through the Internet .","Software components  include an operating system  and a set of tasks under control of operating system , such as a Java\u2122 application program  and, importantly, JVM software  and kernel . Operating system  also allows processor  to control various devices such as persistent storage , user I\/O , and network interface . Processor  executes the software of operating system , application , JVM  and kernel  in conjunction with memory  and other components of computer system . In an embodiment, software  includes network software , JVM1, RJVM2 and RJVM3, as illustrated in server  of . In an embodiment, Java\u2122 application program  is Java\u2122 application as illustrated in ","Persons of ordinary skill in the art will appreciate that the system of  is intended to be illustrative, not restrictive, and that a wide variety of computational, communications, and information devices can be used in place of or in addition to what is shown in . For example, connections through the Internet  generally involve packet switching by intermediate router computers (not shown), and computer  is likely to access any number of Web servers, including but by no means limited to computer  and Web server , during a typical Web client session.","The foregoing description of the preferred embodiments of the present invention has been provided for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Obviously, many modifications and variations will be apparent to practitioners skilled in the art. The embodiments were chosen and described in order to best explain the principles of the invention and its practical applications, thereby enabling others skilled in the art to understand the invention for various embodiments and with the various modifications as are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the following claims and their equivalents."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE FIGURES","p":[{"@attributes":{"id":"p-0057","num":"0060"},"figref":"FIG. 1","i":"a "},{"@attributes":{"id":"p-0058","num":"0061"},"figref":"FIG. 1","i":"b "},{"@attributes":{"id":"p-0059","num":"0062"},"figref":"FIG. 1","i":"c "},{"@attributes":{"id":"p-0060","num":"0063"},"figref":"FIG. 2","i":"a "},{"@attributes":{"id":"p-0061","num":"0064"},"figref":"FIG. 2","i":"b "},{"@attributes":{"id":"p-0062","num":"0065"},"figref":"FIG. 3","i":"a "},{"@attributes":{"id":"p-0063","num":"0066"},"figref":["FIG. 3","FIG. 3"],"i":["b ","a; "]},{"@attributes":{"id":"p-0064","num":"0067"},"figref":"FIG. 3","i":"c "},{"@attributes":{"id":"p-0065","num":"0068"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0066","num":"0069"},"figref":"FIG. 5","i":"a "},{"@attributes":{"id":"p-0067","num":"0070"},"figref":"FIG. 5","i":"b "},{"@attributes":{"id":"p-0068","num":"0071"},"figref":"FIG. 6","i":"a "},{"@attributes":{"id":"p-0069","num":"0072"},"figref":"FIGS. 6","i":["b","g "]},{"@attributes":{"id":"p-0070","num":"0073"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0071","num":"0074"},"figref":["FIG. 8","FIGS. 3-5"]}]},"DETDESC":[{},{}]}
