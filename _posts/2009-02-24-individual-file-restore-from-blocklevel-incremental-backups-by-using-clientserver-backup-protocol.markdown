---
title: Individual file restore from block-level incremental backups by using client-server backup protocol
abstract: A network storage server restores a selected file or files from a block-level backup of a data set that contains multiple files, by using a client-server backup protocol, without restoring the entire data set. The backup can include at least one incremental backup image, in which case the file can be restored at least partially from the incremental backup image. A particular version of a file can also be restored, from a block-level backup image that includes multiple snapshots, by automatically selecting a particular snapshot associated with that version of the file, from the backup image, and using the selected snapshot to restore the file.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08200638&OS=08200638&RS=08200638
owner: NetApp, Inc.
number: 08200638
owner_city: Sunnyvale
owner_country: US
publication_date: 20090224
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This is a continuation-in-part of U.S. patent application Ser. No. 12\/113,060, filed on Apr. 30, 2008 and entitled, \u201cSingle File Restore from Image Backup by Using an Independent Block List for Each File\u201d of L. Zheng et al., which is incorporated herein by reference.","The invention in general pertains to network storage systems, and more particularly, to a storage server that manages block-level backups and restoration based on a client-server backup protocol.","Conventionally, files and directories in a storage subsystem can be backed up with file-level operations. File-level backups build individual files and directories on backup storage (e.g., tapes) by going through a file system, which typically employs hierarchical storage structures. File-level backup techniques back up data on a file-by-file basis, because a file is the smallest addressable unit of data that the backup software can handle. File-level backup techniques and protocols generally have limited backup performance due to various file system overheads. For example, a backup operation for small files, dense directories, or fragmented file locations generally involves small reads and random disk access, which in turn incur a significant file system overhead.","Further, with file-level backup techniques, the files often have to be backed up in a certain order, such as inode-based ordering and directory tree based ordering. For each file, file-level backup techniques have to backup the data from the beginning to the end. The constraint imposed by the ordering limit the performance. For example, the dump format of Berkeley Software Distribution (BSD), further imposes strict ordering constraints among files, as well as data blocks of a file. A \u201cblock\u201d, in this context, is the smallest amount of contiguous data that can be addressed by a file system.","Additionally, file-level backup techniques are often unable to provide a sufficient data input rate to a tape drive, which causes a shoe-shining effect to occur. The shoe-shining effect occurs during tape reads or writes, when the data transfer rate falls below a minimum threshold at which the tape drive heads are designed to transfer data to a running tape. When the shoe-shining effect occurs, the tape drive stops, rewinds back the tape, accelerates again to a proper speed, and continues writing from the same position. The shoe-shining effect significantly reduces the backup performance.","Other problems with file-level backups also exist. For example, file-level backups do not preserve metadata used by the storage system. Although a restore operation will restore user data, it cannot restore the metadata in the original volume. Loss of the metadata may result in loss of the functionality that users may have on the original volume.","Another type of backup technique is block-level backup, also called image-based backup. Block-level backup techniques generally allow for better performance than file-level backups. A block-level backup creates a backup image in a backup storage facility by using blocks as the smallest addressable unit of the backup software, rather than files (a file typically includes numerous blocks). An example of a product which can perform block-level backup and restore is the SNAPMIRROR\u00ae TO TAPE\u2122 software made by NETAPP\u00ae, Inc. of Sunnyvale, Calif. In general, block-level backup and restore can be performed faster than file-level backup, because a block-based backup operation does not need to go through a file system in order to create or restore a backup. Further, reads at the block-level are performed sequentially in terms of physical blocks on disk, which reduces latency.","A disadvantage of known block-level backup techniques, however, is that they do not provide the ability to restore only a single selected file or selected files from a backup image. This is because the backup software is not aware of the file structure of the data in the backup image. Consequently, with known block-level backup techniques it is necessary to restore the entire backup image (e.g., an entire volume), including all files contained in it, even if the user only wants to restore a single file from that image. This is a very resource intensive process and, depending on the size of the backup image, it can take a long time to complete (hours or even days). In addition, known block-level data techniques do not provide the ability to create and restore from an incremental backup.","Further, known block-level backup techniques, such as associated with network file system (NFS) or common Internet file system (CIFS), are client-side-only (local) backup techniques. On the other hand, client-server backup protocols such as network data management protocol (NDMP) are designed to support file level backup only and thus do not have the ability to perform block-level backups or restores.","The technique introduced here enables a network storage server to restore a selected file or files identified in a client request, from a block-level backup of a data set (e.g., a volume) that contains multiple files, by using a client-server backup protocol, without having to restore the entire data set. The backup includes at least one incremental backup image, and the file can be restored at least partially from one or more such incremental backup images.","As described further below, a backup set can include multiple backup images, any one or more of which may be used to restore a given file. Each backup image represents, and includes data blocks of, one or more point-in-time images (\u201csnapshots\u201d) of the data set. The individual backup images in a backup set have no data blocks in common; that is, aside from the initial snapshot, a given backup image includes only those blocks of subsequent snapshots that are different from the earlier snapshots in the backup set.","The technique introduced here also enables a network storage server to restore a selected version of a selected file identified in a client request, from a block-level backup image of a data set that contains multiple files, where the backup image includes multiple snapshots of the data set, by using a client-server backup protocol. The restore of the selected version of the selected file can be accomplished without having to restore the entire data set. Multiple versions of a selected file can also be restored, according to a client request, by using two or more snapshots or backup images in a backup set.","In addition, when the storage server determines that a different backup image in the backup set is needed to continue restoration of a file (i.e., that a different backup image contains the needed blocks), the storage server can automatically suspend restoration of the file and send a request to the backup client to change from one backup image to another. The storage server then resumes restoration of the file after receiving an indication that the client has switched backup images. The above-described operations can be implemented as extensions to the NDMP direct access recovery (DAR) mechanism, for example.","Other aspects of the technique introduced here will be apparent from the accompanying figures and from the detailed description which follows.","References in this specification to \u201can embodiment\u201d, \u201cone embodiment\u201d, or other similar phrases, mean that the particular feature, structure or characteristic being referred to is included in at least one embodiment of the present invention. However, occurrences of such phrases in this specification do not necessarily all refer to the same embodiment. On the other hand, not all of the described embodiments are necessarily mutually exclusive.","Multiple-Mode Restore","Image-based (block-level) data restoration restores data of a volume from one or more backup images that are created by one or more image-based backup operations. A data block may be a block of a file or a directory. The backup image is designed to support time-efficient backup operations as well as space-efficient backup storage. With respect to time efficiency, the data blocks can be stored without any ordering constraints imposed on the data blocks. With respect to space efficiency, all of the in-use data blocks in a volume (the term \u201cvolume\u201d will be explained in greater detail below) are backed up without duplicating common data blocks. Further, the data blocks and metadata of the data blocks are read and stored with low-level disk I\/O operations that incur minimal overhead, without using file system operations (illustratively, file open, directory read, etc).","Image-based data restoration as described herein can concurrently support several restore modes, as described further below. The restore modes include an image restore mode and a logical restore mode. In one embodiment, the image restore mode supports restoration of an entire image of the volume and is file system version dependent; whereas the logical restore mode allows data to be restored into different file system versions and different file system types and, thus, allows file system independent restoration. The logical restore mode supports restoration of a selected file, or multiple selected files, or entire directories of a volume. With the logical restore mode, selective one or more files can be restored from a backup image without restoring the entire image. Further, one or more files can be restored from a backup image even if some tape blocks are unreadable.","Each backup operation creates a backup image that includes one or more point-in-time images (hereinafter \u201csnapshots\u201d) of a volume in a storage subsystem. Backing up multiple snapshots in one backup operation increases the efficiency of the backup performance. The backup is performed on a block-by-block basis. To reduce storage space, common data blocks of the snapshots are not duplicated in the backup image. In one embodiment, a backup image includes one or more snapshots with all of the data blocks. Alternatively, a backup image may include selective snapshots as determined by a user of the storage system, such as a system administrator.","Before further discussing details of the image-based data restoration, it is useful to define certain terminology. In some conventional storage servers, data is stored in logical containers called volumes and aggregates. An \u201caggregate\u201d is a logical container for a pool of storage, combining one or more physical mass storage devices (e.g., disks) or parts thereof into a single logical storage object, which contains or provides storage for one or more other logical data sets at a higher level of abstraction (e.g., volumes). A \u201cvolume\u201d is a set of stored data associated with a collection of mass storage devices, such as disks, which obtains its storage from (i.e., is contained within) an aggregate, and which is managed as an independent administrative unit. A volume includes one or more file systems, such as an active file system and, optionally, one or more persistent point-in-time images of the active file system captured at various instances in time. A \u201cfile system\u201d is an independently managed, self-contained, hierarchal set of data units (e.g., files, blocks, or logical unit numbers (LUNs)). Although a volume or file system (as those terms are used herein) may store data in the form of files, that is not necessarily the case. That is, a volume or file system may store data in the form of other units of data, such as blocks or LUNs.","To keep track of the organization of blocks stored in an aggregate, a storage server maintains various hierarchical data structures, called buffer trees. A buffer tree can represent a volume defined within an aggregate, or a file or a directory defined within a volume. The root of the buffer tree is known as an \u201cinode\u201d, which is a metadata container that contains metadata about the file or the directory. The metadata in an inode can include information about the type of the file\/directory, the size of the file\/directory, time stamps (e.g., access and\/or modification time), permissions and ownership of the file\/directory. A directory inode contains a list of filenames of the files in the directory and the corresponding inode numbers of those files. A file inode contains a list of volume block numbers (VBNs) that identify data blocks owned by the corresponding file. The use of data blocks and inodes to create a backup image will be described in greater detail with reference to .","A buffer tree typically includes both levels, each including numerous blocks, the root of which is the inode. Some blocks in a buffer tree contain actual user-level data\u2014these are referred to as \u201cdirect blocks\u201d. Other blocks in a buffer tree may simply contain metadata, such as pointers to lower-level blocks\u2014these are referred to as \u201cindirect blocks\u201d. There can be multiple levels of indirect blocks in a buffer tree, however, there is always only one level of direct blocks, which is the lowest level of the buffer tree.","Every inode and indirect block in a buffer tree includes a pointer to each lower-level block that it references; each such pointer is called a volume block number (VBN). Each VBN corresponds to, but is not necessarily the same as, a corresponding disk block number (DBN), which indicates the physical location of the target data block on a disk. In addition, each direct block also has a corresponding file block number (FBN), which represents the logical (sequential) position of the block within a file, relative to other data blocks in the file.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 1","b":["100","100"]},"Referring to , the storage server  includes a backup architecture , which will be described in greater detailed in connection with , for creating and restoring a backup image. The storage server  is coupled to a storage subsystem  which includes an array of mass storage devices (e.g., disks), and to backup storage  (e.g., tapes). The storage server  is also coupled to storage clients  (hereinafter simply \u201cclients\u201d) through a network . The network  may be, for example, a local area network (LAN), a wide area network (WAN), a metropolitan area network (MAN), a global area network (GAN), such as the Internet, a Fibre Channel fabric, or the like, or a combination of any such types of networks. Each of the clients  may be, for example, a conventional personal computer (PC), server-class computer, workstation, or the like.","The storage subsystem  is managed by the storage server . The storage server  receives and responds to various read and write requests from the clients , directed to data stored in or to be stored in the storage subsystem . The mass storage devices in the storage subsystem  may be, for example, conventional magnetic disks, optical disks such as CD-ROM or DVD-based storage, magneto-optical (MO) storage, or any other type of non-volatile storage devices suitable for storing large quantities of data.","Although illustrated as a self-contained element, the storage server  may have a distributed architecture; for example, it may include a separate N-(\u201cnetwork\u201d) module and D-(\u201cdata\u201d) module (not shown). In such an embodiment, the N-module is used to communicate with clients , while the D-module includes the file system functionality and is used to communicate with an associated one of the storage subsystems . The N-module and D-module can communicate with each other using an internal protocol. Alternatively, the storage server  may have an integrated architecture, where the network and data components are all contained in a single box. The storage server  may also be coupled through a switching fabric to other similar storage servers (not shown) which have their own local storage subsystems. In this way, all of the storage subsystems  can form a single storage pool, to which any client of any of the storage servers has access.","Illustratively, the storage server  may be a storage server product of NetApp Inc., Sunnyvale, Calif., that uses the NetApp\u00ae Data ONTAP\u00ae storage operating system. However, it is expressly contemplated that any appropriate storage server and storage operating system may be enhanced for use in accordance with the image-based backup described herein.",{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 2","FIG. 2"],"b":["200","100","100","21","22","23","23","23"]},"The processors  are the central processing units (CPUs) of the storage server  and, thus, control its overall operation. In certain embodiments, the processors  accomplish this by executing software stored in memory . Such processor  may be, or may include, one or more programmable general-purpose or special-purpose microprocessors, digital signal processors (DSPs), programmable controllers, application specific integrated circuits (ASICs), programmable logic devices (PLDs), or the like, or a combination of such devices.","Memory  includes the main memory (i.e., the \u201csystem memory\u201d) of the storage server . Memory  represents any form of random access memory (RAM), read-only memory (ROM), flash memory, or the like, or a combination of such devices. Memory  stores (among other things) a storage operating system , which can implement the image-based backup and restoration described herein.","Also connected to the processors  through the bus system  are a storage adapter , a network adapter  and a cluster access adapter . The storage adapter  allows the storage server  to access the storage subsystem  of , and may be, for example, a Fibre Channel adapter or a SCSI adapter. The network adapter  provides the storage server  with the ability to communicate with remote devices, such as the clients , over a network and may be, for example, an Ethernet adapter, a Fibre Channel adapter, or the like. The cluster access adapter  couples the storage server  to other nodes of the cluster over a cluster switching fabric. In some embodiments, the cluster access adapter  connects to other nodes of the cluster through an InfiniBand connection.","The storage server  also includes non-volatile random access memory (NVRAM)  to provide fault-tolerant backup of data. The NVRAM  is typically a large-volume solid-state memory array having either a backup battery, or other built-in last-state-retention capabilities (e.g. a FLASH memory), that holds the last state of the memory in the event of any power loss to the array. In some embodiments, the NVRAM  and the system memory  may not have a direct connection to the bus system , but may be accessible through other components (e.g., the processor ) to the bus system .",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 3","b":["300","100","300"]},"As shown, the storage operating system  includes several modules, or \u201clayers\u201d. These layers include a file system manager . The file system manager  is software that manages the one or more file systems managed by the storage server . In particular, the file system manager  imposes a hierarchy (e.g., a directory\/file structure) on the data stored in the storage subsystem  and manages client-initiated read and write operations at a high level (while delegating certain functions to lower layers of the storage operation system ).","To allow the storage server  to communicate over the network  (e.g., with clients ), the storage operating system  also includes a network access layer , and a multi-protocol layer  operatively coupled between the file system manager  and the network access layer . The multi-protocol layer  includes a number of higher-level network protocols, such as Network File System (NFS), Common Internet File System (CIFS) and\/or Hypertext Transfer Protocol (HTTP) running over Transmission Control Protocol\/Internet Protocol (TCP\/IP); and\/or Internet SCSI (iSCSI) and\/or Fibre Channel Protocol (FCP). The network access layer  includes one or more drivers which implement one or more lower-level protocols to communicate over the network, such as Ethernet or Fibre Channel.","To enable the storage  to communicate with the storage subsystem , the storage operating system  includes a storage driver layer , and a storage access layer  operatively coupled between the file system manager  and the storage driver layer . The storage access layer  implements a higher-level disk storage protocol, such as RAID-4, RAID-5 or RAID-DP, while the storage driver layer  implements a lower-level storage device access protocol, such as Fibre Channel Protocol (FCP) or SCSI. The storage access layer  is alternatively called the \u201cRAID layer\u201d in this description.","Also shown in  is the path  of data flow, through the storage operating system , associated with a client-initiated read or write request.","The storage operating system  also includes a user interface  to generate a command line interface (CLI) and\/or graphical user interface (GUI), to allow administrative control and configuration of the storage server , from a local or remote terminal.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 4","FIG. 4","FIG. 4"],"b":["400","400","400","100","300","400","411","412","411","100","100","411","300","412","130","34","300"]},"Referring to , a data and tape services module  interfaces with users or client-side backup software  to configure and manage the backup environment. The data and tape services module  may be part of the M-host  or a module separate from the M-host . In one embodiment, the data and tape services module  operates in accordance with NDMP. NDMP is a client-server protocol for backup and restore of heterogeneous network-attached storage, by which backup software on a client machine on a network can manage backup and restore jobs running on a network storage server. Conventional NDMP is designed to support file-level backups only. The backup architecture  can work with and extend NDMP to provide image-based backups through the NDMP, as described in greater detail below. The data and tape services module  provides an interface at the server side to communicate with the client-side backup software . The data and tape services module  also forwards client-side requests to the D-module  to perform requested backup or restore operations.","The D-module  may include a backup engine  for generating image backup data streams, and a restore engine  for restoring the backup data from tapes . A data mover  interfaces with both the backup engine  and the restore engine  to perform tape I\/O operations. The data mover  may interact with the tapes  that are locally connected to the storage server , or remote backup storage via a network. The D-module  may also include a backup manager , which coordinates backup operations of the client , the data and tape services module , the backup engine , the restore engine  and the data mover . Further, the backup manager  can be configured to coordinate backup operations in a cluster environment, where one or more of the components of the backup architecture  reside on separate storage servers.","When a client sends a request to backup a volume, the backup engine  generates a backup image, in one backup operation, that includes all of the point-in-time images (\u201csnapshots\u201d) of a volume that are currently stored (\u201cin use\u201d) in the storage subsystems , or one or more snapshots selected by the client. The backup engine  may retrieve data from disks  through one or more layers of the storage operating system , such as the file system manager  and the storage access layer . In one embodiment, the backup engine  includes a warehouse data structure builder  and a metadata index builder  to construct a backup image for a volume. The warehouse data structure builder  of the backup engine  retrieves data blocks from the disks , and stores the data blocks in a backup image. The metadata index builder  retrieves metadata of the data blocks from the disks  and stores the metadata in the backup image. The metadata provides the logical restore engine  of the restore engine  with the ability to restore the entire image or selectively restore one or more files from the volume, by restoring one file at time. Alternatively, a client may request the restoration of an entire image of the volume. Image restoration is supported by the image restore engine , which uses only the data blocks of the backup image.","In one embodiment, the restore engine  includes an image restore engine  for restoration of an entire image of a volume that is file system version dependent. Thus, the image restore engine  may only restore a backup image on certain file system versions. Illustratively, if a backup is performed on a system with a file system version X, the image restoration may only be performed on a system with the same file system version X. The image restored by the image restore engine  includes all of the blocks in a volume, such as user data and system metadata, and preserves the block layout of the volume. As some system metadata (such as configuration data of the storage operating system , features of the data blocks, etc.) is tied to the block layout, the restored image allows the system metadata to continue to function after restoration. The restore engine  also includes a logical restore engine  for restoration of one, multiple, or entire files and directories of a volume that are file system version independent. Thus, the logical restore engine  can perform restoration on a system with any file system version as long as the system supports image-based backup and restore features. However, the logical restore engine  changes the block layout, and is, therefore, unable to recover some of the system metadata.","In one embodiment, the logical restore engine  saves the restored data in the disks  via a file operation module (FOP) . The FOP module  receives requests from the restore engine , generates actions according to the requests, and transforms the actions into file system messages that restore directories and files and save them into the disks . Operations of the restore engine  and the file operation module  will be described in greater detail below in connection with .",{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIGS. 5A-5C","b":"103"},"Referring to , in one embodiment, a backup image  includes a number of data blocks intermixed with a number of metadata blocks. The data blocks include the data blocks that constitute one or more snapshots of a volume, and the metadata blocks include the corresponding metadata of the data blocks. The data blocks and metadata blocks are stored in any order convenient for a backup operation, without any ordering constraints. Illustratively, a data block (or a metadata block) for a more recent snapshot may be stored before or after another data block (or another metadata block) of an older snapshot. In one embodiment, the data blocks and metadata blocks are stored in the backup image  in the same order as they are retrieved from disks. The order in which the data blocks and metadata blocks are retrieved from the disks can be determined by the backup engine  that is most time efficient.","Referring to , in another embodiment, a backup image  includes a first section, referred to as a warehouse data structure (or simply \u201cdata warehouse\u201d) , for storing data blocks of a volume. The blocks in the warehouse data structure  are saved on tape in VBN order. The backup image  also includes a second section, referred to as a metadata map (or metadata index) , for storing corresponding file system metadata of the data blocks, such as inodes, directory entries, file block VBN list, etc.). Within each of the first and the second sections, the data blocks and the metadata blocks can be stored in any order without any ordering constraints. Alternatively, either or both of the data blocks and the metadata blocks can be stored according to a given order, such as the order of snapshots, VBNs, or the like. In a scenario where the data blocks and\/or the metadata blocks are ordered by snapshots, it is unnecessary to impose any ordering constraints within each of the snapshots. The backup images  and  may include additional sections, such as header and footer, as well as other sections, as discussed below.","In yet another embodiment, shown in , a backup image  includes the warehouse data structure , the metadata map , an offset map , and additional sections -, which will be described in more detailed later. The offset map  contains the block offset, on the physical backup storage media, of every data block in the warehouse data structure , indexed by VBN, to speed up data retrieval at restore time. In one embodiment, the offset map  includes a header containing one or more VBNs, followed by the offsets for those VBNs, in the same order that they appear in the header.","In the embodiments shown in , each data block is identified by a VBN. The VBN is the identifier of the data block in the storage subsystem  (e.g., disks) of . Each data block has a fixed size, e.g., 4 kilobytes. These data blocks collectively represent one or more snapshots of the volume. The snapshots may include all of the snapshots of the volume that are currently stored in the storage subsystem , or one or more specific snapshots selected by a client. In the embodiments of  and  where the data blocks are not ordered by snapshots, each data block may include a snapshot identifier to identify its membership in a snapshot.","The metadata blocks of  provide the necessary metadata to locate and restore individual directories and files. In one embodiment, each metadata block includes an inode, such as a directory inode or a file inode. Each inode has an identification number (an inode number) and associated attributes including the type of inode (such as a directory inode or a file inode). A directory inode contains a list of filenames of files in the directory and the corresponding inode numbers of those files. A file inode contains a list of VBNs that identify the data blocks owned by the corresponding file. The metadata blocks are a logical representation of a file system structure and, therefore, are independent of on-disk file system format. In the embodiments of  and  where the metadata blocks are not ordered by snapshots, each metadata block may include a snapshot identifier to identify its membership in a snapshot. Further, in the embodiments of , the computation of the metadata blocks and the writing of data blocks to a backup image can be executed concurrently to speed up the backup process.","The backup images described above do not include more than one each of any data blocks that are common to any of the snapshots. Only the data blocks that have been changed since an immediate-preceding snapshot are stored in the backup image. Thus, there is no duplication of data blocks in any of the backup images. With respect to metadata blocks, in one embodiment, a backup image contains only the metadata blocks corresponding to the data blocks in that same backup image, and, therefore, there is also no duplication of the metadata blocks in the backup image either. In an alternative embodiment, the metadata blocks for each of the backed up snapshots are stored in their entirety for increased speed during data restoration.","Referring again to , the backup image  also includes a warehouse data structure header , a metadata header  and an offset map header  to mark the beginning of each of the three sections (the warehouse data structure , the metadata map  and the offset map ). The backup image  further includes an image header  and an image footer  to mark the beginning and end of the backup image . In one embodiment, the image header  contains information about the volume backed up in this backup image, such as volume language, density, and the like. The image footer  contains summary information of the backup image , such as the offsets on tape of the warehouse data structure , metadata map  and offset map  within the backup image .","The offset map  of the backup image  records the block offset, on physical storage (e.g., tape ), of every data block in the warehouse data structure , indexed by VBN. For example, the offset map  includes a mapping of the VBN of each data block in the backup image to an offset on tape . This can be used during a single file (or multiple selected file) restore to find the needed blocks by converting VBN to a tape offset. Use of the offset map  can improve the speed of file restoration. During restore time, the restore engine  can take a file inode, identify the list of VBNs belonging to the corresponding file, and use the offset map  to locate those data blocks having the identified VBNs. With the use of the offset map , it becomes unnecessary for the restore engine  to scan the warehouse data structure  to look for specific data blocks.","Backup operations can be performed incrementally. For example, a backup operation can be followed by one or more incremental backup operations. Each incremental backup operation generates an incremental backup image, in which only incremental changes from the previous backup operation are stored. A \u201cbackup set\u201d includes one or more backup images, including at least a baseline backup image (which is also referred to as a \u201clevel-0\u201d backup image), and possibly including one or more incremental backup images. A backup image can span multiple tapes (or other physical backup media). Each backup image (level 0 or incremental) includes data blocks of at least one snapshot of the volume being backed up. A level-0 backup includes all of the data in the volume. An incremental backup includes the changed data since the last backup image was created. Each backup set has a unique identifier. A new backup set is created whenever a level-0 backup is performed.","During a level 0-backup, all of the volume snapshots are captured in the backup image. The earliest snapshot in time is considered the \u201cbaseline\u201d snapshot. The file history generated during this operation includes everything in the baseline snapshot as well as the differences between every pair of snapshots that are created next to the other chronologically.",{"@attributes":{"id":"p-0071","num":"0070"},"figref":["FIGS. 6A and 6B","FIG. 4","FIG. 6A","FIGS. 6A and 6B","FIG. 5C"],"b":["450","600","601","602","601","602","603","601","601","501","502"],"sub":["1","2","3","1","2 ","1","3 ","2"]},"Incremental backup images  and  include the data blocks and metadata blocks of two snapshots SS, SS. In the embodiment of , backup image  is generated by computing the difference between snapshots (SS, SS) and snapshots (SS, SS, SS) with respect to data blocks and metadata blocks in these snapshots. In the embodiment of , backup set B includes backup images  and . Backup image  is generated by computing the difference between snapshots SSand SS, and the difference between SSand SS, with respect to data blocks and metadata blocks. The metadata blocks in the incremental backup images  and  may also include the parent directories of the files and directories that have been updated since a last backup operation to allow reconstruction of the full pathname of the updated files and directories.","This incremental storage of snapshots and metadata greatly reduces backup storage space at the expense of a slight increase in overhead during data restoration time.","In one embodiment, the image-based backup described herein preserves deduplication, compression and encryption properties of the data. That is, if the source data is deduplicated, compressed or encrypted, the backup data on tape will be stored in the same form. For example, a shared block in a deduplicated volume will be backed up only once in the warehouse data structure , therefore making backup efficient for disk reads and tape writes. In addition, the backup image on tape will use less space than it would otherwise, just as with the original volume. Similarly, compressed or encrypted blocks will be read without being decompressed or decrypted when being backed up in the warehouse data structure .",{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIG. 7","b":["700","710","420","715","420","410","720","410","451","452","725","470","450","110","730","470","480","410","420","735"]},{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 8","b":["800","810","420","110","420","110","815","420","410","820","410","460","825","460","470","810","460","830"]},"With respect to restoration of an image, the restore engine  restores the data blocks of a backup image into a destination target volume. After all the data blocks are restored, the restore engine  activates the restored data for use by the storage server . As mentioned above, image restoration does not involve the use of metadata, and is, therefore, faster than restoration of files and directories.","With respect to restoration of file and directories, the logical restore engine  uses the FOP module  to handle directories and files, as well as I\/O operations. The logical restore engine  generates FOP requests for directories and files to be restored, and sends the FOP requests to the FOP module . Each FOP request may have multiple actions, such as create a directory or file, populate data, set attributes, and the like. Each of these actions is executed by the FOP module . The FOP module  transforms the actions into file system messages, and sends the messages to the file system asynchronously. \u201cAsynchronously\u201d means that file operations are not blocked when sending out file system messages. When replies from the file system are received by the FOP module , the FOP module  checks for errors and performs a next action, if any, in the current FOP request until all of the outstanding actions are handled.","When the restore operation completes, the backup manager  notifies the data and tape services module  at block .","When restoring a single file, the logical restore engine  uses the metadata in a backup image to find the inode number of the file from its directory inode, locates the file's inode by the inode number, determines the list of VBNs contained in the inode, and then accesses the backup image to retrieve the data blocks identified by the VBNs. When restoring a single file that was backed up with both level-0 (baseline) and level-1 (incremental) backup operations, the logical restore engine  first constructs a file from a baseline backup image, and then updates the file using one or more incremental backup images. Alternatively, the logical restore engine  first identifies all the data blocks it needs to restore from different backup images based on the metadata map, and then restores the data blocks as necessary. Illustratively, a file with two data blocks (b, b) is backed up in a baseline backup, and then one of the data blocks (b) is modified and backed up in an incremental backup. When restoring the file, the logical restore engine  restores b from the incremental backup image and b from the baseline backup image. In this example, the restore engine  does not need to restore both blocks (b, b) from the baseline backup.","NDMP Based Block-Level Backup and Single-File Restore","As mentioned above, the single-file backup and restore techniques introduced here can be implemented in conjunction with, or by extending, NDMP. In particular, these techniques may be implemented as extensions to NDMP's direct access recovery (DAR) technique, as will now be further described. In NDMP terminology, DAR is generally driven by a \u201cdata management application (DMA)\u201d (or \u201cbackup client\u201d herein, e.g., backup software ), whereas the actual backup and restore operations are executed by a \u201cdata server\u201d (or \u201cstorage server\u201d herein, e.g., storage server ).","One feature of the technique introduced here is that it enables the restoring of a particular selected file (or multiple selected files) in a data set (e.g., a volume), from a block-level backup set, by using a client-server backup protocol such as NDMP, without having to restore the entire data set. This functionality is illustrated conceptually in a simplified form in .","In , a block level backup set  includes multiple files . The files may be contained in one or more backup images (not shown), and each backup image may contain one or more snapshots (not shown), as described above in relation to . To restore a particular file, for example, File i (-), the DMA (client)  sends a restore request  to the data server (e.g., storage server) , identifying the particular file to be restored (other information may also be included in the request, as described below). In response, the data server  selects the appropriate backup image(s) and snapshot(s) which contains the requested file and restores only that file (or files, if multiple files were selected in the request). Since a block-level incremental backup image does not necessarily contain complete file data, a single incremental backup image may not be sufficient to restore a file. To restore a single file, several backup images may be needed to reconstruct the file. Accordingly, the data server  can request the DMA  to switch between different backup images during the restore operation, as necessary to access all of the blocks of the selected file, as described further below.","Because a backup set such as described here can include multiple snapshots, the technique introduced here also enables the restoring of a particular version of a selected file from a block-level backup set, out of multiple backed up versions, by using a client-server backup protocol such as NDMP, without having to restore the entire data set that contains the file. This functionality is illustrated conceptually in a simplified form in .","In , a block level backup set  includes multiple backup images , as described above in relation to . Each backup image  includes one or more snapshots ; in the example of , backup image j (-) includes multiple snapshots . The backup set  further includes multiple files, and each snapshot  corresponds to a different version of at least one file.","To restore a particular version of a particular file, such as version 3.1 of File i, the DMA (client)  sends a restore request  to the data server (e.g., storage server) , identifying the particular file and version to be restored (version can be specified by including a snapshot ID in the restore request, as described further below). In response, the data server  selects the appropriate backup image(s) and snapshot(s) which contains the requested version of the requested file and restores only that particular version of that particular file, as shown.","As noted, the blocks of the selected version of the selected file may be distributed amongst more than one snapshot and more than one backup image. In one embodiment, only the earliest snapshot that contains a given file contains all of the blocks of that file; any subsequent snapshots contain only new or modified blocks of the file. Therefore, to restore a particular version of a file, the data server  would access, in the backup set , the snapshot that corresponds to the requested version and all earlier snapshots in the backup set  that contain blocks of the requested file.","As described above, a backup set includes one or more backup images, including at least a level-0 backup image, and possibly including one or more incremental backup images. A backup set is assigned an identifier (ID) by the data server when a level-0 backup is initiated. The same backup set ID is specified when starting an incremental backup so that the incremental backup can be related to the level-0 backup of the same backup set. The same volume can be backed up by multiple DMA instances in parallel as long as the backup set IDs are different.","Each backup image (i.e., a level-0 or an incremental) in a backup set is assigned a sequence number (image ID). The sequence number uniquely identifies a backup image within a backup set. In one embodiment the sequence number of the level-0 backup image is always \u201c0\u201d. Any incremental backup will be assigned a sequence number which is one greater than the sequence number of the previous backup image within the same backup set. The backup set ID is independent of host name, IP address, and other parameters that can change over time.","In one embodiment the backup set ID is generated by the data server and is included in a reply by the data server to a NDMP_DATA_GET_ENV message from the backup client, before finishing the backup session. The data server ensures that the value of the variable is unique for each level-0 backup. The DMA keeps track of this ID so that it can find the backup image when the data server requests it.","As noted above, each backup image can contain multiple snapshots. Accordingly, each snapshot within a backup set is assigned a unique snapshot sequence number (snapshot ID). The snapshot sequence number uniquely identifies a snapshot within a backup set. In one embodiment the snapshot sequence number of the oldest snapshot within a backup set (first snapshot of the level-0 backup image) is always \u201c0\u201d. Any other snapshot will be assigned a sequence number that is one greater than the snapshot sequence number of its immediately previous snapshot. Thus, any version of a file in a backup set can be associated with a unique snapshot sequence number.","At the completion of each backup image, the data server includes the Backup Set ID and sequence number in the environment variables in the reply to a NDMP_DATA_GET_ENV from the client. To start an incremental backup of a backup set, the same Backup Set ID is passed from the DMA to the data server in an environment variable in a NDMP_DATA_START_BACKUP message. To start a restore of an individual file or files, the Backup Set ID, snapshot sequence number and filename of each file to be restored are passed by the DMA to the data server, to identify the snapshots that contain the selected file(s).","Unlike with conventional NDMP, the file history messages sent by the data server to the DMA in NDMP DAR are only sent for changed files in the second and subsequent snapshots. Nonetheless, the DMA preferably will still present the user with a complete point-in-time file system view (i.e., all files of the backup set) in each snapshot in the DMA catalog.","Since a block-level incremental backup image does not necessarily contain complete file data, a single incremental backup image may not be sufficient to restore a file. To restore a single file, several backup images may be needed to reconstruct the file.","Consequently, the process for single-file restore is different from the whole-volume restore process. The restore process will start from an incremental backup image which contains the metadata of the files and directories to be restored. The restore process recovers the file metadata and builds a list of offsets for data blocks to be recovered. From the metadata in the backup image, the restore process knows which backup image(s) is\/are needed to recover which data blocks.","The restore process recovers the data blocks from the current backup image and then requests the DMA to load other backup images to recover additional data blocks. The data server uses offset information obtained from the metadata in the first backup image to seek to the data blocks without scanning the whole backup image.","The restore process will be done in one restore session. Since multiple backup images may be needed, the data server uses a notification message, NDMP_IB_NOTIFY_CHANGE_BACKUP_IMAGE, to request the DMA to load a different backup image. After loading the new backup image, the DMA issues a continue restore message, NDMP_IB_DATA_CONTINUE_RECOVER, to the data server to continue on to the newly loaded backup image. The data server stays in Active state during this period.","In certain embodiments, each backup image in a backup set has a format according to  and, as more specifically shown, according to . As shown in , the metadata index  includes a separate section for each of the (N) snapshots in the backup image.","In certain embodiments the backup manager  maintains several working files to facilitate backup and restore operations, as described now with reference to . A first working file  is called mm_data. In one embodiment, there is only one mm_data file for each backup set, which can contain multiple sections, one for each snapshot. The mm_data file contains metadata entries of three types: inode entries, directory entries, and file block list entries (also called VBN extent or \u201cVBNX\u201d entries) for the changed files or directories of the snapshot. There is no required order for the entries in the mm_data file. The mm_data file is created or modified on tape, in the metadata index  of the backup image, when a backup image is created or modified, respectively, and then read into memory of the data server upon initiation of a restore operation. The remaining working files described below are all created by the data server upon initiation of a restore operation.","A second working file  is called mm_index. The mm_index file indicates the order of contents in mm_data to allow efficient retrieval of that information. Each snapshot has an mm_index file for mapping an inode number to its inode attributes, directory entries (for directory inode), or file block list (for files). With two other working files, mm_direct_list  and mm_file_block_list , the mm_index file ties all inode related information in mm_data together. Each entry in mm_index includes the inode number, a pointer to the corresponding entry in the mm_data file, and a pointer to the corresponding entry in either the mm_direct_list file (if the inode is for directory) or the mm_file_block_list file (if the inode is for a file).","For example, in , there are two inodes represented, A and B. Inode A has attributes in the mm_data file as Ia, and Inode B has inode attributes in the mm_data file as Ib. Inode A represents a directory which has two directory entries Da and Da. Inode B represents a file which has three data block list entries in mm_data as Fb, Fb, and Fb.","Each file block list (VBNX) entry in mm_data (e.g., Fb, Fb) includes the VBN (location of the data block in the original volume), the FBN of the block in the file, the number of contiguous blocks (VBNs), and a flag indicating whether the block has changed from the previous snapshot. The content of a directory entry in mm_data includes the inode number and directory entry name. The content of an inode entry in mm_data essentially includes the inode itself (an inode is the same size as a data block).","As shown in , mm_dirent_list is a linked list, in which each entry points to an entry in mm_data and the next entry in mm_dirent_list. Similarly, mm_file_block_list is a linked list, in which each entry points to an entry in mm_data and the next entry in mm_file_block_list.","To locate a given data block in a backup set on tape, the data server  starts with the inode of the file or directory to which the block belongs and uses it as an index into mm_index, to locate the appropriate entry in either mm_dirent_list or mm_file_block_list. The identified entry in mm_dirent_list or mm_file_block_list is then used to locate the appropriate entry in mm_data.","Another working file, called mm_offset , is used to build mm_index. For each entry in the mm_data file, the mm_offset file contains the starting offset of the entry in the mm_data file and the type of that entry, i.e., inode, directory or VBNX.","Another working file is the acl_dfile file (not shown). This file stores data blocks of access control lists (ACLs) to be recovered. At the end of a restore process, any ACL data of a recovered inode are read from acl_dfile and set for that inode.","Yet another working file is the vbn_to_fbn_map file . This file is used to make reading blocks from tape more efficient (sequential) as well as to enable determination of where the read blocks should be put. Each entry in this file has the following fields: Tape Offset, VBN, Inode Number and FBN. A data block identified by the VBN field will be read from tape at the offset indicated by Tape Offset, and then written to the inode having Inode Number, at a file offset of FBN. Entries in this file are sorted according to Tape Offset, for read efficiency. As a result of this sorting, when restoring data blocks for one file or multiple versions of one file, it is only necessary to scan the tape once to locate all the relevant data blocks. Furthermore, the same tape read efficiency can be achieved for restoring multiple files in response to a single restore request, by sorting entries from all files in this way.","Finally, a working file called vdisk (not shown) stores metadata about LUNs, such as inode numbers. LUNs are initially restored as regular files, and inode information is written to disk. At the end of the restore process, the vdisk file is processed and entries in it are converted from regular files to LUN files.","The process of single file restore will now be described in greater detail, with further reference to  and reference to .  shows the interaction between DMA and data server to perform single file restore. The shaded boxes in  represent NDMP protocol messages. The unshaded boxes represent comments or actions.","Single file restore starts with the DMA requesting the data server to restore one or more individual files, by sending to the data server a START_RECOVER message () and a list of the files top be recovered, called the \u201cnlist\u201d (). The nlist contains the source file path, destination file path, inode number, and snapshot sequence number of each selected file. The data server sorts the nlist according to snapshot sequence number and stores it on disk. The data server creates all destination files before processing the metadata indexes. All files are empty, and the destination inodes are remembered.","An environment variable, FOOTER_OFFSET, is also passed to the data server in the initial restore request (e.g., START_RECOVER) and in subsequent NDMP_IB_DATA_CONTINUE_RECOVER messages. Each backup image has its own FOOTER_OFFSET. This variable contains the offset on tape of the image footer  of the backup image. The following steps (-) are then performed by the data server to download the Metadata Indexes and Offset Maps from tape onto disk.","First, the data server reads and validates the Image Header  from tape. The data server then sends a tape seek request () to the DMA to seek to FOOTER_OFFSET, which the DMA does () and returns the data stream to the data server (). Next the data server downloads the Image Footer section from tape and saves that information in a convenient storage location (). The Image Footer contains information about tape locations for Metadata Indexes and Offset Map. The data server then sends a request to the DMA () to seek the tape to the first Metadata Map location, which the DMA does () and returns the data stream to the data server (). The data server then downloads all Metadata Indexes and the Offset Map onto disks ().","A Metadata Index  on tape has two sections: a metadata section and a backup records section. Each metadata entry in the Metadata Index  has a corresponding backup record in the backup records section. A metadata entry in the Metadata Index  describes what data has been changed, and the corresponding backup record describes how the metadata entry was changed (e.g., created, deleted, modified) and includes an offset of the metadata entry in the mm_data file . The metadata section is downloaded into the mm_data file  when the backup image is loaded. The backup records section is processed on-the-fly during download, and the mm_index, mm_dirent_list, and mm_file_block_list files are created from it for each snapshot.","With the Metadata Index database retrieved, the data server then processes the metadata Index and offset map (). In particular, the data server finds the information about the files to be recovered from the nlist. The data server uses the snapshot sequence numbers and inode numbers in the nlist to find the inodes in corresponding Matadata Indexes. The searching proceeds from latest snapshot to oldest snapshot. Using the inode attributes (e.g., type, file size, creation time, modified time), the data server can determine whether the inode has associated Windows streams (e.g., additional inode attributes such as an icon file, thumb print, or additional information about the inode). A stream directory will be created for the inode, and empty stream files are created. Inodes of those streams are appended to the nlist for further processing.","Using the inode information, the data server also determines whether each inode has an associated ACL. To recover ACL information, the acl_dfile file is used to recover all the ACL data blocks. An ACL mapping file is used to maintain the knowledge of inode number to ACL inode number. For ACL, data blocks will be written to the acl_dfile. For LUN files, a vdisk file entry will be created.","Using the inode information, the data server also finds the list of data blocks used by a file. The file block list is retrieved and the Offset Map is consulted to build the vbn_to_fbn_map file.","After the vbn_to_fbn_map file is built, the data server sorts the file according to tape offset, and then the data server requests () the DMA to seek to specific tape offsets and read the data blocks from tape (i.e., from the warehouse data structure  of the appropriate backup image). The DMA performs the seek () and returns the data stream to the data server (). When a data block is read from tape (), the data server can associate the data block with the inode specified in the vbn_to_fbn_map entry at the specified FBN location. Since the vbn_to_fbn_map file is sorted according to tape offset, the reading of data from tape is a one-pass operation.","Since the nlist may not be resolved with only one backup image, and the needed file blocks may exist in a previous backup image, the data server may need to ask the DMA to load an additional (older) backup image by sending a CHANGE BACKUP Image message (). The DMA then changes the tape () if necessary, and sends a CONTINUE RECOVER message () to the data server. The data server then performs downloading of Metadata Indexes and Offset Map, processing of Metadata Indexes, and reading of data blocks, in the same manner as described above (-). The process continues in this way until all files in the nlist are resolved and all data blocks for files to be restored are recovered. This should happen when the level-0 backup image is processed.","The last operation of the data server in a restore is to recover ACL and LUN files (). All ACL data written to the acl_dfile are read back and set to the specific inode associated with the ACL data. The vdisk file are processed, and recovered LUN files are converted from regular files to LUN files. When this operation is completed, the data server sends a RESTORE COMPLETED message () to the DMA to indicate completion of the restore process.","To support multiple snapshots, file history messages sent by the data server do not need to follow NDMP_FH_ADD_DIR rules No. 5 and 6 specified in NDMP version 4, which define an ordering in which NDMP_FH_ADD_DIR and NDMP_FH_ADD_NODE entries are to be sent. With the technique introduced here, file history messages for the directories and files instead may be sent in any order, regardless of any directory-file relationships. More specifically, in one embodiment the ordering of file history entries differs from that of the traditional NDMP file history model in the following ways:","1) Entries are generated at any phase of the backup;","2) Directory and node entries are intermixed;","3) Entries from different snapshots are intermixed; and","4) Entries are not in inode order or any other order.","To restore a particular version of file from a multiple-snapshot backup, a way is needed to uniquely identify a version of a file in such a multiple-snapshot backup. One approach to doing so is to use a new file history format to pass snapshot information explicitly, i.e., a new file history format which specifies the snapshot with which the history data is associated.","Another approach is to use the existing NDMP file history format to convey snapshot information implicitly: For example, file history for files in snapshots can be sent under virtual directories. The data server can use a virtual directory, e.g., \u201c\/.snapshot\u201d, as container directory for all snapshots. Under that virtual directory, each snapshot has its own virtual directory, e.g., \u201c<snapshot sequence number>\u201d. The \/.snapshot and snapshot directories have their own inode numbers. The inode numbers of files and directories under the virtual snapshot directories are converted so that they do not conflict with inode numbers of the other files under the same backup image. The following is what can happen for file history under this approach:","At the root of the volume, a file history entry representing the virtual directory called \u201c.snapshot\u201d with its own unique inode number is sent from the data server to the DMA during the backup:\n\n","The advantage of this second approach is that it uses the existing file history mechanism. However, due to the generation of virtual inode numbers to avoid collisions; the restore engine  () in the data server will tend to be more complicated, since it needs to convert the virtual inode number back to the original inode number in each snapshot to retrieve metadata information. Also, it is more difficult for the DMA to construct a full file system view in each snapshot in the DMA catalog. The first approach, one the other hand, explicitly provides the snapshot information as part of the file history. This allows the DMA to intelligently build catalog to present complete file system view for snapshots.","Unlike legacy dump images, an incremental backup image according to the techniques introduced here depends on a previous incremental backup image or a level-0 backup image. Consequently, the DMA's expiration policy for backups should only allow expiration of an entire backup set or expiration from the most recent incremental backup image to the related level-0 backup image in reverse chronological order.","The techniques introduced above can be implemented in software and\/or firmware in conjunction with programmable circuitry, or entirely in special-purpose hardwired circuitry, or in a combination of such embodiments. Special-purpose hardwired circuitry may be in the form of, for example, one or more application-specific integrated circuits (ASICs), programmable logic devices (PLDs), field-programmable gate arrays (FPGAs), etc.","Software or firmware to implement the techniques introduced here may be stored on a machine-readable medium and may be executed by one or more general-purpose or special-purpose programmable microprocessors. A \u201cmachine-readable medium\u201d, as the term is used herein, includes any mechanism that can store information in a form accessible by a machine (a machine may be, for example, a computer, network device, cellular phone, personal digital assistant (PDA), manufacturing tool, any device with one or more processors, etc.). For example, a machine-accessible medium includes recordable\/non-recordable media (e.g., read-only memory (ROM); random access memory (RAM); magnetic disk storage media; optical storage media; flash memory devices; etc.), etc.","The term \u201clogic\u201d, as used herein, can include, for example, special-purpose hardwired circuitry, software and\/or firmware in conjunction with programmable circuitry, or a combination thereof.","Although the present invention has been described with reference to specific exemplary embodiments, it will be recognized that the invention is not limited to the embodiments described, but can be practiced with modification and alteration within the spirit and scope of the appended claims. Accordingly, the specification and drawings are to be regarded in an illustrative sense rather than a restrictive sense."],"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["One or more embodiments of the present invention are illustrated by way of example and not limitation in the figures of the accompanying drawings, in which like references indicate similar elements and in which:",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIGS. 5A-5C"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIGS. 6A and 6B"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 6C"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 6D"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 11"}]},"DETDESC":[{},{}]}
