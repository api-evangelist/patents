---
title: Downloadable smart proxies for performing processing associated with a remote procedure call in a distributed system
abstract: Use of a smart proxy as a wrapper around a stub in a distributed system. Instead of receiving a stub as a result of a remote procedure call, a caller receives a smart proxy including the stub as an embedded object. The smart proxy performs predefined processing associated with a remote procedure call, the processing possibly occurring before, during, or after a response to the call.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09183066&OS=09183066&RS=09183066
owner: Oracle America Inc.
number: 09183066
owner_city: Redwood City
owner_country: US
publication_date: 20020506
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","Overview","Distributed Processing System","Distributed System Infrastructure","Data Flow in a Distributed Processing System","Transmission of Smart Proxies"],"p":["The following identified U.S. patent applications are relied upon and are incorporated by reference in this application as if fully set forth.","Provisional U.S. Patent Application No. 60\/076,048, entitled \u201cDistributed Computing System,\u201d filed on Feb. 26, 1998.","U.S. Pat. No. 6,263,350, entitled \u201cMethod and System for Leasing Storage.\u201d","U.S. Pat. No. 6,247,026, entitled \u201cMethod, Apparatus, and Product for Leasing of Delegation Certificates in a Distributed System.\u201d","U.S. Pat. No. 6,421,704, entitled \u201cMethod, Apparatus and Product for Leasing of Group Membership in a Distributed System,\u201d filed on Mar. 20, 1998.","U.S. Pat. No. 6,016,500, entitled \u201cLeasing for Failure Detection.\u201d","U.S. patent application Ser. No. 09\/144,933, entitled \u201cMethod for Transporting Behavior in Event Based System,\u201d filed on Mar. 20, 1998.","U.S. Pat. No. 6,272,559 entitled \u201cDeferred Reconstruction of Objects and Remote Loading for Event Notification in a Distributed System.\u201d","U.S. Pat. No. 6,487,607, entitled \u201cMethods and Apparatus for Remote Method Invocation,\u201d filed on Mar. 20, 1998.","U.S. Pat. No. 6,134,603, entitled \u201cMethod and System for Deterministic Hashes to Identify Remote Methods.\u201d","U.S. Pat. No. 6,598,094, entitled \u201cMethod and Apparatus for Determining Status of Remote Objects in a Distributed System,\u201d filed on Mar. 20, 1998.","U.S. Pat. No. 6,237,024, entitled \u201cSuspension and Continuation of Remote Methods.\u201d","U.S. Pat. No. 6,182,083, entitled \u201cMethod and System for Multi-Entry and Multi-Template Matching in a Database.\u201d","U.S. patent application Ser. No. 09\/044,839, entitled \u201cMethod and System for In-Place Modifications in a Database,\u201d filed on Mar. 20, 1998.","U.S. Pat. No. 6,578,044, entitled \u201cMethod and System for Typesafe Attribute Matching in a Database,\u201d filed on Mar. 20, 1998.","U.S. Pat. No. 6,185,611, entitled \u201cDynamic Lookup Service in a Distributed System,\u201d filed on Mar. 20, 1998.","U.S. Pat. No. 6,560,656, entitled \u201cApparatus and Method for Providing Downloadable Code for Use in Communicating with a Device in a Distributed System,\u201d filed on Mar. 20, 1998.","U.S. Pat. No. 6,832,223, entitled \u201cMethod and System for Facilitating Access to a Lookup Service,\u201d filed on Mar. 20, 1998.","U.S. Pat. No. 6,466,947, entitled \u201cApparatus and Method for Dynamically Verifying Information in a Distributed System,\u201d filed on Mar. 20, 1998.","U.S. patent application Ser. No. 09\/044,936, entitled \u201cAn Interactive Design Tool for Persistent Shared Memory Spaces,\u201d filed on Mar. 20, 1998.","U.S. Pat. No. 6,438,614, entitled \u201cPolymorphic Token-Based Control,\u201d filed on Mar. 20, 1998.","U.S. Pat. No. 6,138,238, entitled \u201cStack-Based Access Control.\u201d","U.S. Pat. No. 6,226,746, entitled \u201cStack-Based Security Requirements.\u201d","U.S. Pat. No. 6,282,652, entitled \u201cPer-Method Designation of Security Requirements.\u201d","The present invention relates to a system and method for transmitting objects between machines in a distributed system and more particularly relates to transmission of a representation of a remote object including code for local processing.","Distributed programs which concentrate on point-to-point data transmission can often be adequately and efficiently handled using special-purpose protocols for remote terminal access and file transfer. Such protocols are tailored specifically to the one program and do not provide a foundation on which to build a variety of distributed programs (e.g., distributed operating systems, electronic mail systems, computer conferencing systems, etc.).","While conventional transport services can be used as the basis for building distributed programs, these services exhibit many organizational problems, such as the use of different data types in different machines, lack of facilities for synchronization, and no provision for a simple programming paradigm.","Distributed systems usually contain a number of different types of machines interconnected by communications networks. Each machine has its own internal data types, its own address alignment rules, and its own operating system. This heterogeneity causes problems when building distributed systems. As a result, program developers must include in programs developed for such heterogeneous distributed systems the capability of ensuring that information is handled and interpreted consistently in different machines.","However, one simplification is afforded by noting that a large proportion of programs use a request and response interaction between processes where the initiator (i.e. program initiating a communication) is blocked out until the response is returned and is thus idle during this time. This can be modeled by a procedure call mechanism between processes. One such mechanism is referred to as the remote procedure call (RPC).","RPC is a mechanism for providing synchronized communication between two processes (e.g., program, applet, etc.) running on the same machine or different machines. In a simple case, one process, e.g., a client program, sends a message to another process, e.g., a server program. In this case, it is not necessary for the processes to be synchronized either when the message is sent or received. It is possible for the client program to transmit the message and then begin a new activity, or for the server program's environment to buffer the incoming message until the server program is ready to process a new message.","RPC, however, imposes constraints on synchronism because it closely models the local procedure call, which requires passing parameters in one direction, blocking the calling process (i.e., the client program) until the called procedure of the server program is complete, and then returning a response. RPC thus involves two message transfers, and the synchronization of the two processes for the duration of the call.","The RPC mechanism is usually implemented in two processing parts using the local procedure call paradigm, one part being on the client side and the other part being on the server side. Both of these parts will be described below with reference to .",{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 1","FIG. 1"],"b":["100","102","101","103","101","109","104","100","104","101","109"]},"The RPC mechanism  for the server program  (which may be the same RPC mechanism as the RPC mechanism  when the server program  is on the same platform as the client program ) receives the call packet (step ), unpacks the arguments of the call from the call packet (step ), identifies, using the call information, the server program  to which the call was addressed, and provides the call arguments to the server program .","The server program receives the call (step ), processes the call by invoking the appropriate procedure (step ), and returns a response to the RPC mechanism  (step ). The RPC mechanism  then packs the response in a response packet (step ) and transmits it to the client program  (step ).","Receiving the response packet (step ) triggers the RPC mechanism  to exit the wait state and unpack the response from the response packet (step ). RPC  then provides the response to the client program  in response to the call (step ). This is the process flow of the typical RPC mechanism modeled after the local procedure call paradigm. Since the RPC mechanism uses the local procedure call paradigm, the client program  is blocked at the call until a response is received. Thus, the client program  does not continue with its own processing after sending the call; rather, it waits for a response from the server program .","The Java\u2122 programming language is an object-oriented programming language that is typically compiled into a platform-independent format, using a bytecode instruction set, which can be executed on any platform supporting the Java virtual machine (JVM). This language is described, for example, in a text entitled \u201cThe Java Language Specification\u201d by James Gosling, Bill Joy, and Guy Steele, Addison-Wesley, 1996, which is incorporated herein by reference. The JVM is described, for example, in a text entitled \u201cThe Java Virtual Machine Specification,\u201d by Tim Lindholm and Frank Yellin, Addison Wesley, 1996, which is incorporated herein by reference. Java and Java-based trademarks are trademarks or registered trademarks of Sun Microsystems, Inc. in the United States and other countries.","Because the JVM may be implemented on, any type of platform, implementing distributed programs using the JVM significantly reduces the difficulties associated with developing programs for heterogenous distributed systems. Moreover, the JVM uses a Java remote method invocation system (RMI) that enables communication among programs of the system. RMI is explained in, for example, the following document, which is incorporated herein by reference: Remote Method Invocation Specification, Sun Microsystems, Inc. (1997), which is available via universal resource locator (URL) http:\/\/wwwjavasoft.com\/products\/jdk\/1.1\/docs\/guide\/rmi\/spec\/rmiTOC.doc.html.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 2","b":["200","201","202","200","201","205","203","207","201","203","200"]},"Machine  receives the byte stream . Using RMI , machine  automatically converts it into the corresponding object , which is a copy of object  and which makes the object available for use by a program executing on machine . Machine  may also transmit the object to another machine by first converting the object into a byte stream and then sending it to the third machine, which also automatically converts the byte stream into the corresponding object.","The communication between these machines sometimes involves, for example, repeated calls for the same information. These calls are made to a local proxy, which acts as a surrogate for the remote object in the address space of the client. Such a proxy will service the call by making a network request to the server object. Repeated calls to the same server object through a proxy can generate considerable network traffic, increasing the time and expense of obtaining the information. Accordingly, a need exists for a technique that reduces the amount of network communication in, for example, such a case.","A method consistent with the present invention transmits a request for a particular object. A response to the request is received, the response including code used to construct a representation of the requested object, the construction creating an object for processing calls to the object, local to the requesting object, using the representation.","Another method consistent with the present invention receives at a machine a request for a particular object. A response to the request is transmitted, the response including first code for constructing a representation of the object and including an indication of second code for processing, such that the construction creates an object for processing calls to the object, local to the requesting object, using the representation.","An apparatus consistent with the present invention transmits a request for a particular object. The apparatus receives a response to the request, the response including code used to construct a representation of the requested object, the construction creating an object for processing calls to the object, local to the requesting object, using the representation.","Another apparatus consistent with the present invention receives at a machine a request for a particular object. The apparatus transmits a response to the request, the response including first code for constructing a representation of the object and including an indication of second code for processing, such that the construction creates an object for processing calls to the object, local to the requesting object, using the representation.","Instead of receiving a proxy that only makes network requests to the object for which it is a surrogate, a machine in a distributed system receives a smart proxy. Such a proxy can respond to calls on the object for which it is a surrogate without making any network calls to increase program efficiency, or perform processing before making a network call or after the completion of the network call to increase program functionality. The term proxy generally refers to code or other mechanism used to act as a surrogate for a remote object in the address space of a machine,","Systems transferring stubs and associated smart proxies may use a variant of an RPC or RMI, passing arguments and return values from one process to another process each of which may be on different machines. The term \u201cmachine\u201d is used in this context to refer to a physical machine or a virtual machine. Multiple virtual machines may exist on the same physical machine. Examples of RPC systems include distributed computed environment (DCE) RPC and Microsoft distributed common object model (DCOM) RPC. A memory stores the stub and associated smart proxy, and this memory may include secondary sources such as a disk or receiving objects from the Internet.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":["FIG. 3","FIG. 3"],"b":["300","300","301","302","303","319","319","301","302","303"]},"In the implementation of distributed processing system , platforms ,  and  each include a processor , , and  respectively, and a memory, , , and , respectively. Included within each memory , , and , are applications , , and , respectively, operating systems , , and , respectively, and RMI components , , and , respectively.","Applications , , and  can be applications or programs that are either previously written and modified to work with, or that are specially written to take advantage of, the services offered by an implementation consistent with the present invention. Applications , , and  invoke operations to be performed in accordance with an implementation consistent with this invention.","Operating systems , , and  are typically standard operating systems tied to the corresponding processors , , and , respectively. The platforms , , and  can be heterogenous. For example, platform  has an UltraSparc\u00ae microprocessor manufactured by Sun Microsystems, Inc. as processor  and uses a Solaris\u00ae operating system . Platform  has a MIPS microprocessor manufactured by Silicon Graphics Corp. as processor  and uses a Unix operating system . Finally, platform  has a Pentium microprocessor manufactured by Intel Corp. as processor  and uses a Microsoft Windows 95 operating system . An implementation consistent with the present invention is not so limited and could accommodate homogenous platforms as well.","Sun, Sun Microsystems, Solaris, Java, and the Sun Logo are trademarks or registered trademarks of Sun Microsystems, Inc. in the United States and other countries. UltraSparc and all other SPARC trademarks are used under license and are trademarks of SPARC International Inc. in the United States and other countries. Products bearing SPARC trademarks are based upon an architecture developed by Sun Microsystems, Inc.","Memories , , and  serve several functions, such as general storage for the associated platform. Another function is to store applications , , and , RMI components , , and , and operating systems , , and  during execution by the respective processor , , and . In addition, portions of memories , , and  may constitute shared memory available to all of the platforms , , and  in network . Note that RMI components , , and  operate in conjunction with a JVM, which is not shown for the purpose of simplifying the figure.","Systems and methods consistent with the present invention may also operate within a particular distributed system , which will be described with reference to . This distributed system  is comprised of various components, including hardware and software, to (1) allow users of the system to share services and resources over a network of many devices; (2) provide programmers with tools and programming patterns that allow development of robust, secured distributed systems; and (3) simplify the task of administering the distributed system. To accomplish these goals, distributed system  utilizes the Java programming environment to allow both code and data to be moved from device to device in a seamless manner. Accordingly, distributed system  is layered on top of the Java programming environment and exploits the characteristics of this environment, including the security offered by it and the strong typing provided by it.","In distributed system  of , different computers and devices are federated into what appears to the user to be a single system. By appearing as a single system, distributed system  provides the simplicity of access and the power of sharing that can be provided by a single system without giving up the flexibility and personalized response of a personal computer or workstation. Distributed system  may contain thousands of devices operated by users who are geographically disperse, but who agree on basic notions of trust, administration, and policy.","Within an exemplary distributed system are various logical groupings of services provided by one or more devices, and each such logical grouping is known as a Djinn. A \u201cservice\u201d refers to a resource, data, or functionality that can be accessed by a user, program, device, or another service and that can be computational, storage related, communication related, or related to providing access to another user. Examples of services provided as part of a Djinn include devices, such as printers, displays, and disks; software, such as programs or utilities; information, such as databases and files; and users of the system.","Both users and devices may join a Djinn. When joining a Djinn, the user or device adds zero or more services to the Djinn and may access, subject to security constraints, any one of the services it contains. Thus, devices and users federate into a Djinn to share access to its services. The services of the Djinn appear programmatically as objects of the Java programming environment, which may include other objects, software components written in different programming languages, or hardware devices. A service has an interface defining the operations that can be requested of that service, and the type of the service determines the interfaces that make up that service.","Distributed system  is comprised of computer , a computer , and a device  interconnected by a network . Device  may be any of a number of devices, such as a printer, fax machine, storage device, computer, or other devices. Network  may be a local area network, wide area network, or the Internet. Although only two computers and one device are depicted as comprising distributed system , one skilled in the art will appreciate that distributed system  may include additional computers or devices.",{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 5","b":["402","400","404","406","402","502","504","506","508","510","502","512","514","516","516","518","520","504","522"]},"As mentioned above, distributed system  is based on the Java programming environment and thus makes use of the Java runtime system . The Java runtime system  includes the Java API libraries, allowing programs running on top of the Java runtime system to access, in a platform-independent manner, various system functions, including windowing capabilities and networking capabilities of the host operating system. Since the Java API libraries provide a single common API across all operating systems to which the Java runtime system is ported, the programs running on top of a Java runtime system run in a platform-independent manner, regardless of the operating system or hardware configuration of the host platform. The Java runtime system  is provided as part of the Java software development kit available from Sun Microsystems, Inc. of Mountain View, Calif.","JVM  also facilitates platform independence. JVM  acts like an abstract computing machine, receiving instructions from programs in the form of bytecodes and interpreting these bytecodes by dynamically converting them into a form for execution such as object code, and executing them. RMI  facilitates remote method invocation by allowing objects executing on one computer or device to invoke methods of an object on another computer or device. Both RMI and the JVM are also provided as part of the Java software development kit.","Lookup service  defines the services that are available for a particular Djinn. That is, there may be more than one Djinn and, consequently, more than one lookup service within distributed system . Lookup service  contains one object for each service within the Djinn, and each object contains various methods that facilitate access to the corresponding service. Lookup service  is described in U.S. patent application entitled \u201cMethod and System for Facilitating Access to a Lookup Service,\u201d which was previously incorporated herein by reference.","Discovery server  detects when a new device is added to distributed system , during a process known as boot and join (or discovery), and when such a new device is detected, the discovery server passes a reference to lookup service  to the new device so that the new device may register its services with the lookup service and become a member of the Djinn. After registration, the new device becomes a member of the Djinn, and as a result, it may access all the services contained in lookup service . The process of boot and join is described in U.S. patent application entitled \u201cApparatus and Method for providing Downloadable Code for Use in Communicating with a Device in a Distributed System,\u201d which was previously incorporated herein by reference.","A Java space  is an object repository used by programs within distributed system  to store objects. Programs use a Java space  to store objects persistently as well as to make them accessible to other devices within distributed system . Java spaces are described in U.S. patent application Ser. No. 08\/971,529, entitled \u201cDatabase System Employing Polymorphic Entry and Entry Matching,\u201d assigned to a common assignee, and filed on Nov. 17, 1997, which is incorporated herein by reference. One skilled in the art will appreciate that an exemplary distributed system  may contain many lookup services, discovery servers, and Java spaces.",{"@attributes":{"id":"p-0075","num":"0074"},"figref":["FIG. 6","FIGS. 3"],"b":["600","601","606","4","5","600"]},"Another example of smart proxy processing involves use of a serialized object for transmitting data to a data bank storing information. In this example, a call is made to a smart proxy, which receives an object, serializes the object on the client machine into an array of bytes, and transmits the array of bytes to a server. The server only stores the serialized object, avoiding the requirement to download code, and it provides a key for the object to the client machine. When the client machine wants to retrieve the data, the smart proxy transmits the key to the server, receives in response the serialized object, reconstructs the object, and provides it to the user.","Other examples of uses of smart proxies include processing for debugging, call logging, and monitoring system performance. Another example involves the use of a smart proxy for local data verification, as explained in U.S. patent application Ser. No. 09\/044,932, filed on Mar. 20, 1998, assigned to a common assignee, and entitled \u201cApparatus and Method for Dynamically Verifying Information in a Distributed System,\u201d which is incorporated herein by reference. Many other uses for smart proxies are possible for performing processing associated with a call.","Network  includes a client machine  containing RMI  and associated code . A server machine  includes RMI  and remote object . In operation, RMI  transmits a call or request  to RMI , requesting a particular stub object. RMI  returns a response  including requested stub  embedded within a smart proxy . The response may be transmitted as a stream. Streams used in the Java programming language, including input and output streams, are known in the art and an explanation, which is incorporated herein by reference, appears in, for example, a text entitled \u201cThe Java Tutorial: Object-Oriented Programming for the Internet,\u201d pp. 325-53, by Mary Campione and Kathy Walrath, Addison-Wesley, 1996.","The response may include information so that client machine  can reconstruct the stub object in smart proxy . When a set of object types is limited and is the same on machines  and , a receiving machine typically requires the object's state and a description of its type because the object's code is already present on all network machines. Alternatively, machine  uses RMI  to provide more flexibility, allowing code to be moved when necessary along with information or the object's state and type. Additionally, a transmitting machine may include in the object an identification of the type of object transmitted, the data constituting the state of the object, and a network-accessible location in the form of a URL for code that is associated with the object. URLs are known in the art and an explanation, which is incorporated herein by reference, appears in, for example, a text entitled \u201cThe Java Tutorial: Object-Oriented Programming for the Internet,\u201d pp. 494-507, by Mary Campione and Kathy Walrath, Addison-Wesley, 1996.","When client machine  receives response , it identifies the type of transmitted object. Machine  contains its own RMI  and code  for processing of objects, and it may create stub object  using the object type, the state information, and code for the object. If code for the object is not resident or available on machine  and the stub object does not contain the code, RMI  may use a URL from the object to locate the code and transfer a copy of the code to client machine . Because the code is bytecodes and is therefore portable, client machine  can load the code into RMI  to reconstruct the object. Thus, client machine  can reconstruct an object of the appropriate type even if that kind of object has not been present on the machine before.","When creating stub object , RMI  does not necessarily know that the stub is itself a smart proxy . Smart proxy  may perform processing at client machine  before or after response  and may supply all processing without resorting to call  to the object for which the proxy acts. Therefore, smart proxy  may perform all processing locally when client machine  makes a call or request  to invoke a method on smart proxy . These proxies are downloadable by the same methods as disclosed in U.S. patent application Ser. No. 08\/950,756, filed on Oct. 15, 1997, and entitled \u201cDeferred Reconstruction of Objects and Remote Loading in a Distributed System,\u201d which is incorporated herein by reference.",{"@attributes":{"id":"p-0082","num":"0081"},"figref":["FIG. 7","FIG. 6"],"b":["700","701","702","703","704","705","706"]},"The client machine then determines if the method called on the smart proxy may be serviced locally (step ). If so, the client machine performs the local processing for the call (step ). If not, the client machine calls the remote object (step ). The remote processing is performed (step ), and the result of the remote processing is returned to the client machine (step ).","The client machine determines, according to code in the smart proxy, if post-processing as a result of the call is required (step ). If so, it locally performs the post-processing using code in the smart proxy (step ). The smart proxy then returns the method call result (step ) in response to the call on the smart proxy in step .",{"@attributes":{"id":"p-0085","num":"0084"},"figref":"FIG. 8","b":["800","801","802","803","804"]},"Machines implementing the steps shown in  may include computer processors for performing the functions, as shown in , , , and . They may include modules or programs configured to cause the processors to perform the above functions. They may also include computer program products stored in a memory. The computer program products may include a computer-readable medium or media having computer-readable code embodied therein for causing the machines to perform functions described above. The computer readable media may include sequences of instructions which, when executed by a processor, cause the processor to securely address a peripheral device at an absolute address by performing the method described in this specification. The media may also include a data structure for use in performing the method described in this specification.","Although the illustrative embodiments of the systems consistent with the present invention are described with reference to a computer system implementing the Java programming language on the JVM specification, the invention is equally applicable to other computer systems processing code from different programming languages. Specifically, the invention may be implemented with both object-oriented and nonobject-oriented programming systems. In addition, although an embodiment consistent with the present invention has been described as operating in the Java programming environment, one skilled in the art will appreciate that the present invention can be used in other programming environments as well.","While the present invention has been described in connection with an exemplary embodiment, it will be understood that many modifications will be readily apparent to those skilled in the art, and this application is intended to cover any adaptations or variations thereof. For example, different labels or definitions for the smart proxies may be used without departing from the scope of the invention. This invention should be limited only by the claims and equivalents thereof."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The accompanying drawings are incorporated in and constitute a part of this specification and, together with the description, explain the advantages and principles of the invention. In the drawings,",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 7","FIG. 6"]},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
