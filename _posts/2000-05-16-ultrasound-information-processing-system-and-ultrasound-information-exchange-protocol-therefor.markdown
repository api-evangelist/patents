---
title: Ultrasound information processing system and ultrasound information exchange protocol therefor
abstract: An ultrasound information processing system comprises a plurality of ultrasound devices coupled to a high-speed serial ultrasound information bus, wherein each ultrasound device comprises a program for communicating with other ultrasound devices according to an ultrasound information exchange protocol (UIEP). The UIEP is a lightweight, connection-oriented protocol adapted to efficiently transfer ultrasound information among different devices on the ultrasound information bus. Each ultrasound device comprises an application layer program for performing an ultrasound function, as well as a lower protocol layer program for receiving and sending data across the ultrasound information bus according to a high-speed serial bus standard that provides both isochronous and asynchronous data delivery. The ultrasound information exchange protocol (UIEP) program is adapted to receive a communication request from the application layer, open a connection-oriented communication session with the requested ultrasound device, and transfer ultrasound information through the lower protocol layer and across the ultrasound information bus to the requested device. Advantageously, any ultrasound device manufacturer provided with the UIEP program may readily generate application layer code capable of communicating with other manufacturers' ultrasound devices across the ultrasound information bus, without requiring specific knowledge of the internal structure of the other manufacturers' devices or of the specific frame/packet structure of the UIEP/lower layer protocols themselves.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06839762&OS=06839762&RS=06839762
owner: U-Systems, Inc.
number: 06839762
owner_city: Los Altos
owner_country: US
publication_date: 20000516
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","Sample Ultrasound Transport Protocol Layer APIs","Sample Ultrasound Service Protocol Layer APIs"],"p":["This application is a continuation-in-part of U.S. patent application Ser. No. 09\/449,095, entitled \u201cScalable Real-Time Ultrasound Information Processing System,\u201d filed Nov. 24, 1999, which is a continuation-in-part of U.S. patent application Ser. No. 09\/224,635, entitled \u201cUltrasound Information Processing System,\u201d filed Dec. 31, 1998, both assigned to the assignee of the present invention. The above two disclosures are hereby incorporated by reference into the present disclosure.","This patent specification relates to the field of ultrasound information processing systems. In particular, the present invention relates to an architecture for a flexible, high-performance, reduced cost, and upgradable ultrasound information processing system and a standardized protocol for allowing ready interoperability of ultrasound devices within and across such systems.","Ultrasound imaging systems are advantageous for use in medical diagnosis as they are non-invasive, easy-to-use, and do not subject patients to the dangers of electromagnetic radiation. An ultrasound imaging system transmits sound waves of very high frequency (e.g., 2 MHz to 10 MHz) into the patient and processes echoes reflected from structures in the patient's body to form two dimensional or three dimensional images. Many ultrasound information processing algorithms are known in the art, for example, echo mode (\u201cB mode\u201d) processing algorithms, motion mode (\u201cM mode\u201d) processing algorithms, Doppler shift echo processing algorithms, color flow mode processing algorithms, and others.","Present day ultrasound imaging systems typically comprise a host computer or processor that is responsible for user interface control, image display, and overall system control. These systems further typically comprise one or more peripheral devices, such as ultrasound scanner\/probe assemblies and digital signal processors, that perform specific ultrasound information processing functions. As described in Ser. No. 09\/224,635, supra, prior art ultrasound architectures generally use custom, proprietary connections and protocols for transferring information among the different ultrasound system elements. Connections between the ultrasound system elements are typically implemented using hardware parallel busses that, while at least partially conforming to an industrial standard such as the VME standard, are otherwise uniquely adapted for the specific hosts, scanners, digital signal processors, etc. being provided by the specific system manufacturer. Ultrasound algorithms, such as those embodied in the scan sequences of an ultrasound scanner, are typically stored in custom hardware memory maps within that scanner, and can only be changed or upgraded if the specific memory map architecture of that specific scanner is known.","Accordingly, in the case of the prior art architectures supra, it is either impossible or impractical to substitute a first manufacturer's ultrasound component (such as a host, scanner, or digital signal processor) into a second manufacturer's ultrasound processing system. As a result, it is less feasible for the purchaser of an ultrasound processing system to easily upgrade to newer, better, and\/or less expensive ultrasound components that are being continually developed in the industry. It is also less feasible for the purchaser to upgrade to new ultrasound information processing algorithms or scanning strategies as they are developed in the industry.","Accordingly, it would be desirable to provide an ultrasound communication method that, upon being followed by a plurality of ultrasound component manufacturers, would allow for the construction of an ultrasound information processing system that can readily use ultrasound components or algorithms from different manufacturers or different models.","It would be further desirable to provide an ultrasound communication method in which a first ultrasound device may change internal parameters of a second ultrasound device without requiring knowledge of the specific internal memory map of the second ultrasound device.","It would be further desirable to provide an ultrasound communication method that is based on a serial bus architecture for allowing flexibility, scaleability, and plug-and-play simplicity in an ultrasound information processing system.","It would be still further desirable to provide an ultrasound communication method that properly synchronizes ultrasound devices coupled to the serial bus.","It would be even further desirable to provide an ultrasound communication method that permits ready communications between any two devices connected to the serial bus, without requiring their application layer programs to contain detailed serial bus communications instructions.","In accordance with a preferred embodiment, an ultrasound information processing system is provided comprising a plurality of ultrasound devices coupled to a high-speed serial ultrasound information bus, each ultrasound device comprising a program for communicating with other ultrasound devices according to an ultrasound information exchange protocol. The ultrasound information exchange protocol represents a standard, lightweight, connection-oriented protocol adapted for efficient transfer of ultrasound information among different devices on the ultrasound information bus.","Each ultrasound device in the ultrasound information processing system comprises an application layer program for performing an ultrasound function and a lower protocol layer program for receiving and sending data across the ultrasound information bus. The lower protocol layer program is preferably a standard, off-the-shelf program that implements IEEE 1394\/1995, USB, Fibre Channel, or other high-speed serial bus protocol providing both isochronous and asynchronous data delivery. An ultrasound information exchange protocol (UIEP) program is adapted to receive a communication request from the application layer, open a connection-oriented communication session with the requested ultrasound device, and transfer ultrasound information between the devices during the communication session. Advantageously, any ultrasound device manufacturer provided with the UIEP program may readily generate application layer code capable of communicating with other manufacturers' ultrasound devices across the ultrasound information bus, without requiring specific knowledge of the internal structure of the other manufacturers' devices or of the specific frame\/packet structure of the UIEP\/lower layer protocols themselves.","In accordance with a preferred embodiment, the UIEP protocol comprises a ultrasound transport protocol (UTP) layer for providing a reliable, connection-oriented data delivery service between ultrasound ports of different ultrasound devices. The UIEP protocol further comprises an ultrasound service protocol (USP) for providing an interface between the UTP layer and the application layer. The UIEP protocol provides for a bulk image data type whose frames are transmitted isochronously between ultrasound devices, and an asynchronous command data type whose frames are transmitted asynchronously between ultrasound devices. Separate ports are provided on each ultrasound device for handling the bulk image data and the asynchronous command data.","In a preferred embodiment, ultrasound scanning devices conforming to the UIEP protocol comprise at least one memory block that may be loaded and managed by a remote host device, wherein the remote host device is not required to have knowledge of the specific memory architecture of the scanning device. In particular, the UIEP provides for communication and management of memory addresses in a logical address space, wherein physical memory addresses in the scanning device are derived locally by combining (e.g. adding) logical address offsets with a corresponding hardware address.","According to a preferred embodiment, the UIEP compensates for the pipelined nature of serial bus communications by allowing proper inter-device synchronization as bulk image data is transferred and processed. An ultrasound source device, such as a scanner, generates image data in accordance with (a) intrinsic parameters that are included within each bulk data frame, together with (b) extrinsic parameters that are not included within each bulk data frame. However, for each bulk data frame, the host device requires knowledge of both the intrinsic and extrinsic parameters to properly process the frame. According to a preferred embodiment, the scanner attaches an ultrasound state identifier to each bulk image frame, which is then used by the host device to locate the correct set of extrinsic parameters for processing that frame. Sets of extrinsic parameters and their corresponding ultrasound state identifiers are communicated between the scanner and host using their asynchronous command ports or broadcast ports as the extrinsic parameters are varied. Synchronization, i.e. proper matching of the bulk data frames with the proper set of extrinsic parameters, is thereby preserved as the extrinsic parameters are varied.",{"@attributes":{"id":"P-00028","num":"00028"},"figref":"FIG. 1","b":["100","100","102","104","114","102"]},"The ultrasound devices - shown in  may be any of a variety of device combinations for achieving a desired ultrasound information processing functionality. For example, ultrasound device  may be a host computer for providing overall system control, user display, user input, and image processing functions. Ultrasound device  may be a scanner\/probe assembly for generating raw ultrasound image data. Ultrasound devices - may be any of a variety of auxiliary ultrasound devices. By way of example and not by way of limitation, such auxiliary ultrasound devices may include: specialized signal processing devices; ultrasound storage devices; auxiliary displays; hot-swappable backup devices; auxiliary system control devices, or generally any device performing a functionality useful to an ultrasound information processing system.","Although physical coupling between each ultrasound device and the ultrasound information bus  is indicated in , it would be within the scope of the preferred embodiments for one or more of the ultrasound devices to wirelessly communicate with the ultrasound information bus . Additionally, although the ultrasound information bus  of  is shown as a local area network, it would be within the scope of the preferred embodiments for ultrasound information bus  to be implemented as a wide area network coupling a plurality of local area networks using, for example, ATM or frame relay links. Thus, the physical implementations of ultrasound information bus  may take a variety of forms, provided that high-speed isochronous data transfer and asynchronous data transfer is permitted between any two of the ultrasound devices -.","According to a preferred embodiment in which the features and advantages of the architecture and protocol described infra are used, a system purchaser may insert upgraded, additional, or replacement ultrasound devices from any manufacturer into the ultrasound information processing system by simply \u201cplugging them in\u201d to the ultrasound information bus . As an example, a purchaser may have purchased a \u201cbare bones\u201d system comprising only a host and a scanner from a first ultrasound manufacturer a while ago, but may now wish to include a new, specialized, intermediate processing device that has just been released by a second ultrasound manufacturer. According to the preferred embodiments, the user may (a) plug the intermediate processing device into the ultrasound information bus , (b) redirect the output of the scanner to an input of the intermediate processing device, and (c) redirect the input of the host to an output of the intermediate processing device. An entire new layer of ultrasound functionality (e.g., a special kind of real-time filtering or the like) has thus been added to the overall system, without requiring substantial costs in modifying or replacing existing system components.",{"@attributes":{"id":"P-00032","num":"00032"},"figref":"FIG. 2","b":["202","208","202","204","206","206","210","212","214"]},"The lower protocol layer  is adapted to implement communications between ultrasound devices in accordance with one of the high-speed serial bus protocols (e.g., IEEE 1394\/1995, USB, Fibre Channel, etc.) described supra. The lower protocol layer  is preferably implemented using off-the-shelf application programming interfaces (APIs) known in the art. By way of non-limiting example, for a situation in which the ultrasound device  is based on the Microsoft Windows NT\u00ae platform and an IEEE 1394 serial bus is used for ultrasound information bus , the lower protocol layer program may comprise Microsoft's FireWire API for Windows NT\u00ae.","The ultrasound application layer  represents the implementation of any ultrasound application program (e.g., host programs, DSP programs, scanner programs, storage programs, etc.) as appropriate for the ultrasound device in question. More generally, ultrasound application layer  corresponds to any program associated directly or indirectly with devices that detect, process, store, analyze, display, or perform any other activity associated with ultrasound information.","In accordance with a preferred embodiment, the UIEP  lies between the lower protocol layer  and the application layer . The UIEP  is a lightweight protocol that provides a standard communications interface between any two ultrasound applications communicating across any high-speed packetized serial bus capable of supporting asynchronous and isochronous data transfer. In addition to being a standardized protocol for enabling ultrasound device interoperability, the UIEP is specially adapted for efficient transport and processing of ultrasound information by its respective source and destination devices and algorithms. As indicated in , UIEP  comprises an Ultrasound Transport Protocol (UTP) layer  and an Ultrasound Service Protocol (USP) layer .","Ultrasound Transport Protocol (UTP) layer  is adapted to provide a reliable, connection-oriented data delivery service between ultrasound ports of different ultrasound applications. The UTP layer establishes connection-oriented sessions over which data is reliably transmitted during the period that the session is open. The UTP layer establishes connections, negotiates session parameters, manages the transfer of data, and terminates the connection between ultrasound ports. A UTP layer program running on ultrasound device  comprises a set of application program interface routines (APIs) that are accessible by the application layer or the USP layer. A set of exemplary UTP APIs are included infra in a section entitled \u201cSample Ultrasound Transport Protocol Layer APIs.\u201d Using UTP API routines, an ultrasound application layer program may instantiate a virtual connection between predetermined ports of respective ultrasound devices that are created and managed at the UTP layer level. The predetermined ports may be either bidirectional or unidirectional. In accordance with the UIEP protocol, the set of predefined ports includes, by way of example and not by way of limitation: an image data port for receiving or transmitting bulk ultrasound image data; a hardware status port for providing a hardware status; a command\/control port for receiving commands or control parameters from another ultrasound application; and other ports that may be defined in accordance with the UIEP as other needs may arise.","Table 1 shows an exemplary set of UTP ports according to a preferred embodiment. Table 2 shows an exemplary set of port status indicators that may be returned from a UTP API. As will be described infra with respect to the UTP packet structure, 8 bits are reserved for the ultrasound port ID in each UTP segment, and therefore up to 256 UTP ports may be defined.",{"@attributes":{"id":"P-d0e1890","num":"00002"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Ultrasound Transport Layer Ports"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["PORT",{},{}]},{"entry":["NUMBER","PORT NAME","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["0","UTP_RESERVED_PORT","Reserved for UTP"]},{"entry":[{},{},"communication"]},{"entry":["1","UTP_RESET_PORT","Reset device"]},{"entry":["2","UTP_RESET_ACK_PORT","Reset acknowledgment"]},{"entry":["3","UTP_COMMAND_PORT","Send or receive commands"]},{"entry":["4","UTP_ACK_PORT","Send or receive"]},{"entry":[{},{},"acknowledgements"]},{"entry":["5","UTP_STATUS_PORT","Request or receive status"]},{"entry":["6","UTP_BULK_DATA_PORT","Send or receive bulk data"]},{"entry":["7-255","RESERVED"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"P-d0e2149","num":"00002"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Ultrasound Transport Layer Port Status Indicators"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["PORT STATUS","DEFINITION"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["UTP_OK","Operation completed successfully"]},{"entry":["UTP_INVALID_PARAMETER","One or more parameters is invalid"]},{"entry":["UTP_INIT_TIMEOUT","Initialization attempt timed out"]},{"entry":["UTP_ALREADY_INITIALIZED","Initialization attempted more than"]},{"entry":[{},"once"]},{"entry":["UTP_LINK_FAILURE","Link failure detected during"]},{"entry":[{},"operation"]},{"entry":["UTP_INSUFFICIENT_MEMORY","Not enough memory for the"]},{"entry":[{},"operation"]},{"entry":["UTP_UNKNOWN_PORT_ID","Port ID specified is not a"]},{"entry":[{},"UTP_PORT"]},{"entry":["UTP_INVALID_HANDLE","Handle specified was not for an"]},{"entry":[{},"open port"]},{"entry":["UTP_PORT_NOT_OPEN","Port had not yet been opened on"]},{"entry":[{},"the other end"]},{"entry":["UTP_PORT_ALREADY_OPEN","Port already opened for the same"]},{"entry":[{},"direction"]},{"entry":["UTP_INVALID_REQUEST","Wrong port type for requested"]},{"entry":[{},"operation"]},{"entry":["UTP_PORT_BUSY","Attempt to send when previous"]},{"entry":[{},"send still active"]},{"entry":["UTP_NO_BUFFER","No BULK DATA buffer has been"]},{"entry":[{},"allocated"]},{"entry":["UTP_BUFFER_TOO_SMALL","BULK DATA buffer too small for"]},{"entry":[{},"data received"]},{"entry":["UTP_BUFFER_OVERRUN","Some un-received BULK DATA in"]},{"entry":[{},"buffer overwritten"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Ultrasound Service Protocol (USP) layer  is adapted to provide an interface between the ultrasound application layer  and the UTP layer , providing a set of routines that may be invoked in order to transfer ultrasound information between the application layers of any two ultrasound devices coupled to the ultrasound information bus. From ultrasound application programmer's perspective, i.e., from the perspective of an industry device or algorithm manufacturer, the USP defines a set of APIs that may be called by a source ultrasound application in communicating with a destination ultrasound application provided by the same or different manufacturer. The ultrasound information being communicated is passed through the source ultrasound port, across the UTP connection, to the destination ultrasound port at the other end of the UTP connection, and finally to the destination application. Responsive to the ultrasound information communicated, the source ultrasound application may expect the destination ultrasound application at the other end of the UTP connection to properly interpret, act upon, and\/or respond to that ultrasound information.","In accordance with a preferred embodiment, two major types of USP messages are defined in the UIEP specification: a bulk image data type, and an asynchronous message type. The bulk image data type is specially formatted for transferring in an efficient format bulk ultrasound information such as B-mode data, Color Doppler data, M-mode data, Spectral Doppler data, ECG data, or some other ultrasound data type. The asynchronous message type is flexibly formatted for messages other than bulk image data types, such as scan identifications, commands, addresses and address offsets, statuses, timers, hardware identifiers, and the like. A set of exemplary USP APIs is included infra in a section entitled \u201cSample Ultrasound Service Protocol Layer APIs.\u201d",{"@attributes":{"id":"P-00040","num":"00040"},"figref":["FIG. 3","FIG. 3"],"b":["302","304","306","308","102","304","306","308","310","312","314"]},"In the example of  in which the first ultrasound device  is a host computer and the second ultrasound device  is a scanning device, a dotted line  is drawn representing a virtual connection existing between the devices. With reference to Table 1, supra, the UTP layer establishes a connection oriented session between a first asynchronous command port of the host  (Row=Device , Column=Port =UTP_COMMAND_PORT) and a first asynchronous command port of the scanning device  (Row=Device , Column=Port =UTP_COMMAND_PORT). Asynchronous commands between the devices are transferred over the virtual connection represented by dotted line . In accordance with a preferred embodiment, the UTP layer programs send and receive these asynchronous commands over the asynchronous channel of the high-speed serial bus protocol being used at the physical\/data link layer. This is done because the asynchronous commands generally do not require the \u201cguaranteed on time\u201d delivery services of the isochronous channel of the high-speed serial bus protocol, but do generally require the data integrity services of the asynchronous channel of the high-speed serial bus protocol.","In a configuration (not shown) in which only the host and scanning device are used in the system, there would be an additional virtual connection (not shown) between Port  (UTP_BULK_DATA_PORT) of the host and Port  (UTP_BULK_DATA_PORT) of the scanning device. Bulk ultrasound image data between the devices would be transferred over that virtual connection. In accordance with a preferred embodiment, the UTP layer programs would send and\/or receive the bulk image data over the isochronous channel of the high-speed serial bus protocol being used at the physical\/data link layer. This would be done because the bulk image data generally requires the \u201cguaranteed on time\u201d delivery services of the isochronous channel of the high-speed serial bus protocol in order to provide real-time ultrasound information processing capability.","In the more general case of  in which an intermediate processor  is included in the ultrasound information flow pipeline, bulk image data is gathered by the scanning device  and delivered to the intermediate processor  over a virtual connection  established between a bulk image port of the scanning device  (Row=Device N, Column=Port =UTP_BULK_DATA_PORT) and a first bulk image port of the intermediate processor  (Row=Device , Column=Port =UTP_BULK_DATA_PORT). Upon being processed by the intermediate processor , the bulk image data is delivered to the host  over a virtual connection  established between a second bulk image port of the intermediate processor  (Row=Device , Column=Port =UTP_BULK_DATA_PORT) and a bulk image data port of the host  (Row=Device N, Column=Port =UTP_BULK_DATA_PORT).","In the system of , process coordination commands from the host  to the scanning device  and\/or the intermediate processor  are provided over virtual connections established between command ports of the devices. The command ports are selected from the UTP port tables , , and  as necessary (e.g., between the port at Row=Device N, Column=Port =UTP_COMMAND_PORT of host  and the port at Row=Device , Column=Port =UTP_COMMAND_PORT of intermediate processor ). Alternatively, in accordance with another preferred embodiment, process coordination commands may be broadcast to UTP broadcast ports of the different devices, the UTP broadcast ports being shown as the last row in each of the UTP port tables , , and  of FIG. . When command delivery and response is completed, the virtual connections may be torn down, or may alternatively remain in anticipation of future command communications between the devices.",{"@attributes":{"id":"P-00045","num":"00045"},"figref":"FIG. 4","b":["402","402","404","402","406","408","410","412","410"]},"In accordance with a preferred embodiment, there is a predetermined mapping between port ID and the direction (send only, receive only, or bidirectional) of the data being transferred over that port. Furthermore, there is also a predetermined mapping between port ID and the high-speed serial bus protocol channel type (asynchronous or isochronous). For example, for an ultrasound host device, the port UTP_RESET_PORT is a send port, and the data is transferred over an asynchronous channel of the high-speed serial bus. As another example, for an ultrasound scanner, the port UTP_BULK_DATA_PORT is a send port, and the data is transferred over an isochronous channel of the high-speed serial bus. However, in an alternative preferred embodiment that is more generalized and does not require such predetermined mappings, the UTP packet  may also comprise a 1 byte port direction indicator (not shown) for identifying whether the port is in send, receive, or bidirectional mode. UTP packet  may also comprise a 1 byte data mode indicator (not shown) for identifying whether the port is associated with asynchronous or isochronous data transfer.","In accordance with a preferred embodiment, the UTP packet  represents the fundamental unit of data transfer at the UTP layer. However, depending on its size and on the nature of the standard high-speed serial bus protocol that is chosen, the UTP packet  may be broken up into smaller data units at the high-speed serial bus protocol layer for optimal transfer. Thus, for example, if the standard high-speed serial bus protocol has a maximum frame size of 1 Kbyte and the UTP packet  is greater than 1 Kbyte, it will be broken up accordingly before data transfer. Reassembly of the UTP packet data stream is handled at the high-speed serial bus protocol layer at the receiving end.","The payload being carried by the UTP packet , i.e., the USP payload frame , will have different internal structures depending on whether it carries asynchronous command data or isochronous bulk image data. Asynchronous command data generally includes any type of information that needs to be passed among ultrasound devices that is not bulk image data. By way of nonlimiting example, typical commands include open port, load code at logical address, run, status request, status request response, reset, reset acknowledge, stop, and close port. A more thorough yet nonlimiting set of exemplary commands is listed infra in the section entitled \u201cSample Ultrasound Transport Protocol Layer APIs.\u201d","In accordance with a preferred embodiment, the above \u201cload code\u201d command provided in the USP protocol is associated with loading code at a logical address in the destination ultrasound device. For example, where the destination device is a scanner and the source device is a remote host, the scanner has memory blocks that may be loaded and managed by the remote host. Advantageously, the remote host is not required to have knowledge of the specific memory architecture of the scanner. The UIEP of the preferred embodiments provides for communication and management of memory addresses in a logical address space, wherein physical memory addresses in the scanner are derived locally by adding the logical address offset to the corresponding hardware address.",{"@attributes":{"id":"P-00050","num":"00050"},"figref":"FIG. 5","b":["502","502","504","5","502","506","502","1","508","1","510","2","512","2","514","516","518","506","520","522","524","526"]},"The USP frame  may comprise only a single submessage, or may comprise several submessages. Each submessage represents a distinct command, response, acknowledgment, etc., from the source device to the destination device. However, it has been found that several commands often need to be sent consecutively from one ultrasound device to another, and in such case it is convenient to group the commands into a single USP frame.",{"@attributes":{"id":"P-d0e3222","num":"00002"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 3"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Asynchronous Message Header"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["FIELD NAME","SIZE","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Message Type","4 bytes","Specifies source device type and destination"]},{"entry":[{},{},"device type for purposes of interpreting sub-"]},{"entry":[{},{},"messages. Examples include: host to scanner"]},{"entry":[{},{},"command; scanner to host status; scanner to"]},{"entry":[{},{},"host information; scanner acknowledgment."]},{"entry":["Ultrasound State","4 bytes","Indicates the ultrasound state to which this"]},{"entry":["ID",{},"message refers. A change in this parameter"]},{"entry":[{},{},"indicates an alteration of one or more ultra-"]},{"entry":[{},{},"sound scan parameters extrinsic to bulk data"]},{"entry":[{},{},"frame information, as described further infra."]},{"entry":["Number of","4 bytes","Number of sub-messages included with this"]},{"entry":["Sub-Messages",{},"message."]},{"entry":["Message Size","4 bytes","Message size in bytes, including header."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"The submessage header included in asynchronous command frame  may vary in format depending on the nature of the source device, the nature of the destination device, the context of the communication, and the desired action or response. By way of nonlimiting example, Table 4 below shows a submessage header for the case where the sending device is a host and the receiving device is a scanner. Table 5 below shows a submessage header for the case where the sending device is a scanner and the receiving device is a host.",{"@attributes":{"id":"P-d0e3503","num":"00002"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 4"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Host to Scanner Submessage Header"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["FIELD NAME","SIZE","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Submessage Type","4 bytes","Examples include: Init (perform scanner"]},{"entry":[{},{},"initialization); Run (start scanning); Stop"]},{"entry":[{},{},"(stop scanning); Real-time program (change"]},{"entry":[{},{},"hardware parameters without stopping scan);"]},{"entry":[{},{},"Offline Program (program while no"]},{"entry":[{},{},"scanning); Request Probe Status; Request"]},{"entry":[{},{},"Scanner Hardware Status; Request Scanner"]},{"entry":[{},{},"Hardware Information; Request Scanner"]},{"entry":[{},{},"Software Information; Load DSP Code."]},{"entry":["Operation","4 bytes","Examples include: Load Hardware Data"]},{"entry":[{},{},"(load data into hardware RAM, registers, and"]},{"entry":[{},{},"DSP memory where addressing mode is"]},{"entry":[{},{},"specified by logical address); Set bits (set"]},{"entry":[{},{},"bits in location specified by logical address);"]},{"entry":[{},{},"Reset Bits (reset bits in location"]},{"entry":[{},{},"specified by logical address)."]},{"entry":["Logical Address","4 bytes","Logical memory address in scanner from"]},{"entry":[{},{},"which Address Offset is referenced. Logical"]},{"entry":[{},{},"address is defined by host application"]},{"entry":[{},{},"software and translated into actual scanner"]},{"entry":[{},{},"hardware address by destination scanning"]},{"entry":[{},{},"device."]},{"entry":["Address Offset","4 bytes","Logical number that is combined with"]},{"entry":[{},{},"Logical Address to allow scanner"]},{"entry":[{},{},"software to access a portion of hardware"]},{"entry":[{},{},"memory."]},{"entry":["Data Size","4 bytes","Data size in bytes for submessage data"]},{"entry":[{},{},"section."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"P-d0e3953","num":"00002"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 5"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Scanner to Host Submessage Header"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["FIELD NAME","SIZE","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Submessage Type","4 bytes","Examples include: Probe Status Report (i.e.,"]},{"entry":[{},{},"this submessage provides a probe status"]},{"entry":[{},{},"report); Scanner Hardware Status (reporting"]},{"entry":[{},{},"scanner hardware status); Scanner Hardware"]},{"entry":[{},{},"Information (e.g., reporting hardware RAM"]},{"entry":[{},{},"data, DSP software parameters, etc.);"]},{"entry":[{},{},"Scanner Software Status (reporting scanner"]},{"entry":[{},{},"software parameters)."]},{"entry":["Status ID","4 bytes","ID for the reported status."]},{"entry":["Logical Address","4 bytes","Same as for Host to Scanner Submessage"]},{"entry":[{},{},"Header."]},{"entry":["Address Offset","4 bytes","Same as for Host to Scanner Submessage"]},{"entry":[{},{},"Header."]},{"entry":["Data Size","4 bytes","Data size in bytes for submessage data"]},{"entry":[{},{},"section. Set to zero if scanner to host"]},{"entry":[{},{},"submessage has no data section."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"The submessage data format also varies depending on the nature of the source device, the nature of the destination device, the context of the communication, and the desired action or response. By way of nonlimiting example, Table 6 below lists a scanner to host submessage data definition for a probe status report. Table 7 below lists a scanner to host submessage data definition for scanner hardware information. Table 8 below lists a scanner to host submessage data definition for a scanner software status request.",{"@attributes":{"id":"P-d0e4264","num":"00002"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 6"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Scanner to Host Submessage Data Definition: Probe Status Report"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["FIELD NAME","SIZE","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Slot 1 Status","4 bytes","Slot status indicating the state of the probe"]},{"entry":[{},{},"slot, e.g.: Disconnected; Connected but"]},{"entry":[{},{},"not Scanning; Connected and Scanning"]},{"entry":["Slot 1 Probe ID","4 bytes","Unique ID of the Probe type that is"]},{"entry":[{},{},"connected to the slot."]},{"entry":["Slot 2 Status","4 bytes","(see above)"]},{"entry":["Slot 2 Probe ID","4 bytes","(see above)"]},{"entry":["Slot 3 Status","4 bytes","(see above)"]},{"entry":["Slot 3 Probe ID","4 bytes","(see above)"]},{"entry":["Slot 4 Status","4 bytes","(see above)"]},{"entry":["Slot 4 Probe ID","4 bytes","(see above)"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"P-d0e4528","num":"00002"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 7"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Scanner to Host Submessage Data Definition: Scanner Hardware"},{"entry":"Information"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["FIELD NAME","SIZE","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Hardware Raw","\u201cN\u201d","Contains the data in the scanner hardware"]},{"entry":["Data","Bytes","or RAM specified by the logical address and"]},{"entry":[{},{},"offset contained in the Scanner to Host"]},{"entry":[{},{},"Submessage Header. Size \u201cN\u201d is specified in"]},{"entry":[{},{},"the Scanner to Host Submessage Header."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"P-d0e4692","num":"00002"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 8"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Scanner to Host Submessage Data Definition: Scanner Software Status"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["FIELD NAME","SIZE","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["High Voltage","4 bytes","May include the following states: Normal;"]},{"entry":["Status",{},"Overvoltage."]},{"entry":["Watch Dog Timer","4 bytes","May include the following states: Normal;"]},{"entry":[{},{},"Watch Dog timer triggered."]},{"entry":["Other","4 bytes","Other scanner software information"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"P-00054","num":"00054"},"figref":"FIG. 6","b":["602","602","604","6","602","606","608","606","608"]},{"@attributes":{"id":"P-00055","num":"00055"},"figref":["FIG. 7","FIG. 7"],"b":["702","606","6","702","706","708","710","712","714","706","708","710","714"]},"According to a preferred embodiment, the ultrasound state identifier  that is attached to each bulk image frame is an index, usually in a numerical format, used by the host device to locate the correct set of extrinsic parameters for processing that frame. In one embodiment, the ultrasound state ID may progress linearly as extrinsic parameters are changed, whereas in another embodiment, the ultrasound state ID may progress in a random fashion. It is of primary importance that, upon receiving the ultrasound state ID in a bulk image data frame, the host device (and any intermediate ultrasound device) is capable of obtaining the proper corresponding extrinsic parameters to use in processing that bulk image data. As will be described infra, sets of extrinsic parameters and their corresponding ultrasound state identifiers are communicated between the scanner and host (and any intermediate ultrasound device) using their asynchronous command ports or broadcast ports as the extrinsic parameters are varied. Synchronization, i.e. proper matching of the bulk data frames with the proper set of extrinsic parameters, is thereby preserved as the extrinsic parameters are varied.","Although the nature of the intrinsic frame parameters will vary depending on the ultrasound mode, these intrinsic frame parameters will usually include a frame sync ID, frame type, and frame ID. Accordingly, these have been shown as elements , , and  in , while all other intrinsic frame parameters are grouped as element . Tables 9-15 below provide further detail of examples of the header field and data field format used for B-mode (Tables 9-10), Color Doppler Mode (Tables 11-12), M-Mode (Table 13), Spectral Doppler (Table 14), and ECG mode (Table 15).",{"@attributes":{"id":"P-d0e5055","num":"00002"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 9:"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"B-Mode Frame Header"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"FIELD NAME","SIZE"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Frame Sync ID","4 bytes"]},{"entry":[{},"Frame Type (B Mode)","4 bytes"]},{"entry":[{},"Frame Id","4 bytes"]},{"entry":[{},"Ultrasound State ID","4 bytes"]},{"entry":[{},"Starting Vector Number","4 bytes"]},{"entry":[{},"End Vector Number","4 bytes"]},{"entry":[{},"Start of ROI (multiple of 48 MHz)","4 bytes"]},{"entry":[{},"Number of Sample Volumes","4 bytes"]},{"entry":[{},"Number samples per vector (NSPV)","4 bytes"]},{"entry":[{},"X position in mm","4 bytes"]},{"entry":[{},"Y position in mm","4 bytes"]},{"entry":[{},"Z position in mm","4 bytes"]},{"entry":[{},"Rolling in degrees","4 bytes"]},{"entry":[{},"Yawing in degrees","4 bytes"]},{"entry":[{},"Pitching in degrees","4 bytes"]},{"entry":[{},"Packet size in bytes","4 bytes"]},{"entry":[{},"Reserved","to packet size"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"P-d0e5395","num":"00002"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 10"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"B-Mode Vector Data Definition"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"FIELD NAME","SIZE"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Vector line number","4 bytes"]},{"entry":[{},"B vector data samples","NSPV bytes"]},{"entry":[{},"Reserved","to packet size"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"P-d0e5525","num":"00002"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 11"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Color Doppler Frame Header"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"FIELD NAME","SIZE"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Frame Sync ID","4 bytes"]},{"entry":[{},"Frame Type (Color Doppler)","4 bytes"]},{"entry":[{},"Frame Id","4 bytes"]},{"entry":[{},"Ultrasound State ID","4 bytes"]},{"entry":[{},"Starting Vector Number","4 bytes"]},{"entry":[{},"End Vector Number","4 bytes"]},{"entry":[{},"Number samples per vector (NSPV)","4 bytes"]},{"entry":[{},"Packet size in bytes","4 bytes"]},{"entry":[{},"Reserved","to 512 bytes"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"P-d0e5745","num":"00002"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 12"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Color Doppler Data Definition"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"FIELD NAME","SIZE"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Color Doppler sample 1","4 bytes, comprising:"]},{"entry":[{},{},"Velocity (1 byte);"]},{"entry":[{},{},"Variance (1 byte);"]},{"entry":[{},{},"Power (1 byte); and"]},{"entry":[{},{},"Reserved (1 byte)"]},{"entry":[{},"Color Doppler sample 2","4 bytes, comprising:"]},{"entry":[{},{},"Velocity (1 byte);"]},{"entry":[{},{},"Variance (1 byte);"]},{"entry":[{},{},"Power (1 byte); and"]},{"entry":[{},{},"Reserved (1 byte)"]},{"entry":[{},". . .","4 bytes, comprising:"]},{"entry":[{},{},"Velocity (1 byte);"]},{"entry":[{},{},"Variance (1 byte);"]},{"entry":[{},{},"Power (1 byte); and"]},{"entry":[{},{},"Reserved (1 byte)"]},{"entry":[{},"Color Doppler sample 128","4 bytes, comprising:"]},{"entry":[{},{},"Velocity (1 byte);"]},{"entry":[{},{},"Variance (1 byte);"]},{"entry":[{},{},"Power (1 byte); and"]},{"entry":[{},{},"Reserved (1 byte)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"P-d0e6082","num":"00002"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 13"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"M-Mode Header and Data"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"FIELD NAME","SIZE"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Frame Sync ID","4 bytes"]},{"entry":[{},"Frame Type (M)","4 bytes"]},{"entry":[{},"Frame Id","4 bytes"]},{"entry":[{},"Ultrasound State ID","4 bytes"]},{"entry":[{},"M Vector Number","4 bytes"]},{"entry":[{},"Start of ROI (multiple of 48 MHz)","4 bytes"]},{"entry":[{},"Number of Sample Volumes","4 bytes"]},{"entry":[{},"Number of samples per vector (NSPV)","4 bytes"]},{"entry":[{},"Packet size in bytes","4 bytes"]},{"entry":[{},"M samples","NSPV bytes"]},{"entry":[{},"Reserved","to 1K bytes"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"P-d0e6332","num":"00002"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 14"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Spectral Doppler Header and Data"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"FIELD NAME","SIZE"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Frame Sync ID","4 bytes"]},{"entry":[{},"Frame Type (Spectral Doppler)","4 bytes"]},{"entry":[{},"Frame Id","4 bytes"]},{"entry":[{},"Ultrasound State ID","4 bytes"]},{"entry":[{},"Doppler Vector Number","4 bytes"]},{"entry":[{},"Number samples per vector (NSPV)","4 bytes"]},{"entry":[{},"Packet size in bytes","4 bytes"]},{"entry":[{},"Spectral Doppler samples","Total of"]},{"entry":[{},{},"NSPV*4 bytes:"]},{"entry":[{},{},"I sample data"]},{"entry":[{},{},"(2 bytes) and Q"]},{"entry":[{},{},"sample data (2"]},{"entry":[{},{},"bytes) per"]},{"entry":[{},{},"sample"]},{"entry":[{},"Reserved","to 512 bytes"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"P-d0e6624","num":"00002"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 15"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"ECG Header and Data"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"FIELD NAME","SIZE"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Frame Sync ID","4 bytes"]},{"entry":[{},"Frame Type (ECG)","4 Bytes"]},{"entry":[{},"Frame Id","4 bytes"]},{"entry":[{},"Ultrasound State ID","4 bytes"]},{"entry":[{},"Number of samples (NS)","4 bytes"]},{"entry":[{},"Packet size in bytes","4 bytes"]},{"entry":[{},"ECG samples","NS bytes"]},{"entry":[{},"Reserved","to 64 bytes"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"P-00058","num":"00058"},"figref":"FIG. 8","b":["802","804","102"]},"However, when serial bus communications are used between the scanner and the host, it represents a challenge to properly synchronize the parameters being transmitted on the asynchronous channels with the bulk image frames being transmitted on the isochronous channels. One possible solution, of course, is to append to each bulk image frame all possible parameters that may be needed to interpret the bulk image data. Although theoretically possible and within the scope of the preferred embodiments, such a solution would be less desirable. This is because (i) the amount of data being transferred across the isochronous channels would be unnecessarily large, (ii) a protocol for specifying the parameter formats would be unnecessarily complex, and (iii) such protocol would also require modification when new parameters (e.g. as associated with new ultrasound algorithms) are introduced into the art.","In accordance with a preferred embodiment, it has been found that synchronization is better achieved by classifying the above parameters into two classes: (a) intrinsic parameters that are included within each bulk data frame, and (b) extrinsic parameters that are not included within each bulk data frame. For any given bulk data frame, both sets of parameters are needed for proper processing. However, the extrinsic parameters are established and communicated \u201cout of band\u201d between the ultrasound devices using the asynchronous channels, thereby saving isochronous bandwidth and allowing increased simplicity and flexibility in the UIEP protocol. Because extrinsic parameters (such as image magnification) may vary dynamically, the ultrasound state ID is used to properly correlate each bulk image data frame to its respective set of extrinsic parameters.","Accordingly, in the conceptual diagram of , the ultrasound host  is shown asynchronously sending commands  that set or change intrinsic parameters in the scanner, as well as commands  that set or change extrinsic parameters in the scanner. Importantly, these parameter changes can occur before a scan starts or during an ongoing scan. In accordance with a preferred embodiment, whenever an extrinsic parameter (such as image magnification) is set or changed, a new ultrasound state ID is assigned to the new set of extrinsic parameters, and transmitted along with the command  that changes the extrinsic parameter.","The host  comprises an ultrasound state ID table  for keeping track of the specific extrinsic parameter settings that are associated with each ultrasound state ID. The scanner  may, but is not required to, maintain a corresponding list of ultrasound state ID's and extrinsic parameter settings. Rather, it is important only that, when generating a particular bulk image frame using a specific set of extrinsic parameters, the scanner attach the proper ultrasound state ID to the bulk image frame data  when sending it to the host . Of course, the scanner  also includes the corresponding set of intrinsic parameters with each bulk image frame. Upon receiving the bulk image frame , the host  performs a lookup into ultrasound state ID table  using the provided ultrasound state ID, finds the correct extrinsic parameters, and then uses these extrinsic parameters and the provided intrinsic parameters to process the bulk image data.",{"@attributes":{"id":"P-00063","num":"00063"},"figref":"FIG. 9","b":["802","8","902","904","802","804","906","802","804","908","910","918","920","912","912","908"]},"However, if there is a change in the in extrinsic parameters, then at step  a new ultrasound state ID is chosen and loaded along with the new extrinsic parameters into the ultrasound state ID table . The numerical value of the ultrasound state ID may be incremented linearly, in a random fashion, or in any of a variety of manners, provided that it is different than a large number of its previous values. At step , the new extrinsic parameters and ultrasound state ID are sent to the scanner using the asynchronous command channel, and the process continues at step . At step , as each bulk image data frame arrives, the ultrasound state ID is compared to the ultrasound state ID table  for deriving the proper set of extrinsic parameters. Accordingly, after a recent extrinsic parameter change, even if there is \u201cbackup\u201d of pipeline data associated with the old extrinsic parameters, the arriving frames are properly processed using the correct extrinsic parameters, and synchronization is maintained.",{"@attributes":{"id":"P-00065","num":"00065"},"figref":["FIG. 10","FIG. 10","FIG. 8","FIG. 10"],"b":["1002","1004","1006","1008","1002","1010","1002","1016","1004","1018","1004","1006","1008","1012","1014","1002"]},"As bulk data frames  are generated by scanner , they are now transmitted to the first intermediate device . Upon processing each bulk data frame using (i) the provided intrinsic parameters, and (ii) the proper extrinsic parameters as derived from ultrasound state ID table , intermediate device  then proceeds to send the processed frames  to the second intermediate device . In turn, upon processing each incoming data frame using (i) the provided intrinsic parameters, and (ii) the proper extrinsic parameters as derived from ultrasound state ID table , intermediate device  then proceeds to send the processed frames  to the host , including the corresponding intrinsic parameter values and ultrasound state ID. Finally, the host  processes the frames according to provided intrinsic parameters and the proper extrinsic parameters as derived from its ultrasound state ID table .","In accordance with a preferred embodiment, host  may transmit asynchronous commands that set or change the extrinsic parameters directly to the scanner  only. The commands may then be forwarded in a serial fashion to the intermediate processing devices  and  for populating their ultrasound state ID tables. In accordance with another preferred embodiment, host  may transmit the new extrinsic parameter information directly to each of the intermediate processing devices  and . In accordance with still another preferred embodiment, host  may broadcast or multicast the new extrinsic parameter information to the intermediate processing devices  and . The direct transmission, multicast, or broadcast of the extrinsic parameters to the intermediate processing devices  and  is represented by the dotted line  in FIG. .",{"@attributes":{"id":"P-00068","num":"00068"},"figref":"FIG. 11","b":["1002","10","1102","1104","1002","1105","1002","1006","1008","1002","1010","1006","1008","1006","1008"]},"At step , host  commands scanner  to begin execution. At step , host  receives and processes frames using the ultrasound state ID that is indicated by the incoming frames, as well as the intrinsic parameters being provided within each incoming frame. Importantly, as this is happening, each of the intermediate processing devices  and  is doing the same thing, i.e., receiving incoming frames and accessing its respective ultrasound state ID table to determine the proper extrinsic parameters for processing those frames. Each of the intermediate devices  and  transmits the processed frames to the next device in the chain.","If the scan is complete at step , then a stop command is sent to the scanner at step  and the process is done at step . If the scan is not complete, operation continues at step . At step  it is determined whether there are any changes in the extrinsic parameters (such as image magnification). If there are no changes in extrinsic parameters, the algorithm continues at step . However, if there is a change in the in extrinsic parameters, then at step  a new ultrasound state ID is chosen and loaded along with the new extrinsic parameters into the ultrasound state ID table . At step , the new extrinsic parameters and ultrasound state ID are sent to the scanner using the asynchronous command channel. At step , the new ultrasound state ID and extrinsic parameters are directly sent, multicast, or broadcast to the intermediate processing devices  and  (or may alternatively be sent serially around the device chain). The process then continues at step . In the above manner, synchronization is maintained because frames generated before a recent extrinsic parameter change will be properly matched with the correct \u201cold\u201d extrinsic parameters.","The application program interfaces (APIs) for an exemplary implementation of the Ultrasound Transport Protocol Layer (UTP) are now described by way of nonlimiting example. For simplicity and clarity of disclosure, the APIs below presume a master-slave relationship between an ultrasound host node, such as an overall system control and user display unit, and an ultrasound slave or embedded device, such as an ultrasound scanner. Additionally, each UTP port in the APIs below is presumed to be one-way as opposed to bidirectional. However, based on the present disclosure, one skilled in the art could readily implement APIs for implementing the more general Ultrasound Transport Protocol Layer functionality disclosed supra in the present disclosure. Although the data types and API calls described below are based on the C\/C++ programming language, they are readily adaptable to any object-oriented programming language or platform that enables multi-threaded execution flow. Data types such as UTP_STATUS, UOS_STRING, UTP_PORT_HANDLE and the like may be defined as appropriate for holding the requisite amounts of data required for the function indicated by that data type name.\n\n","This API initializes UTP layer communication between two ultrasound devices. The argument ulmAppMode identifies whether the calling application will represent the master or the slave in this UTP layer connection. The calling application must call this initialization routine to configure the UTP layer as either in master or slave mode before making any other API call. An application on only one ultrasound device should initialize the UTP layer as a master. If more than one does so, operation of the UTP layer is undefined. A second attempt to initialize the UTP layer on the same processor will not re-initialize it but will return a status of UTP_ALREADY_INITIALIZED. When this API is called, the UTP layer, after performing the initialization step, will wait until communication is established with the other UTP layer before completing the operation. If the communication is not established within a system configurable amount of time, this operation will fail. This function returns UTP_OK if the function succeeds, otherwise it returns a UTP_STATUS value indicating the cause of failure: UTP_OK; UTP_INVALID_PARAMETER; UTP_INIT_TIMEOUT; UTP_ALREADY_INITIALIZED; or UTP_INSUFFICIENT_MEMORY.\n\n","This API will terminate the operation of the UTP connection. The UTP layer will close all open ports, discard any pending message, disable the communication link, and free up all resources that it has allocated. This function always returns UTP_OK.\n\n","This API may be invoked upon receiving an error message from an ultrasound device, and requests a string value that describes the specified error status. The specified error status is sent via the argument uStat. The returned UOS_STRING value is of a format that may be operating system dependent. In the case of Windows NT, for example, this will be std::string, and in the case of an embedded RTOS could be char*. If the specified uStat is not a valid UTP_STATUS, a string similar to \u201cUTP Unknown Status\u201d will be returned.\n\n","This API establishes a one-way communication mechanism between an application running on the master and the slave processor. An application is required to call this API to obtain a port handle to be used in subsequent calls to UTP_ClosePort( ), UTP_AllocateBulkDataBuffer( ), UTP_FreeBuffer( ), UTP_Send( ), or UTP_Receive( ). In order for communication to occur through a port, the port must be open for SEND on either the master or the slave and for RECEIVE on the other. This call blocks until the port is opened on the other side for the alternate direction. If the port has already been opened for the same direction by some other application, this call will fail with a status of UTP_PORT_ALREADY_OPEN. The argument upPortID is the ID of the requested port (e.g. UTP_HOST_CONTROL_PORT, UTP_EMBEDDED_STATUS_PORT). The argument upmMode is the mode (i.e., SEND or RECEIVE, MESSAGES or BULK_DATA) that this port is being opened for. The argument puphPort is the address of a UTP_PORT_HANDLE into which the assigned port handle will be stored. This API returns a UTP_STATUS value indicating the status of the operation, which may be one of the following: UTP_OK; UTP_INVALID_PARAMETER (upmMode is bad or puphPort is NULL); UTP_LINK_FAILURE; UTP_INSUFFICIENT_MEMORY; UTP_UNKNOWN_PORT_ID; or UTP_PORT_ALREADY_OPEN.\n\n","This API closes the port specified by the handle returned from a previous call to UTP_OpenPort( ). All system resources allocated by the UTP layer for this port will be released. If this port is opened for RECEIVE, all messages or bulk data destined for this port will be discarded. If this port is opened for SEND, all messages that have been sent through this port will be delivered, if possible, prior to the completion of this API (the call will block until this condition is met). After this call is made, the handle is no longer valid. If desired to communicate through the port after it is closed, it must be re-opened by calling UTP_OpenPort( ) again. It is possible for one application to close a port on one end, and the communicating port to leave it open on the other. If a sending application closes a port, the receiving end will act normally as though there are no messages pending for it (after it has received all the messages sent prior to the sender closing the port). If a receiving application closes a port, all send attempts to send through the port by the sending application will fail with a status of UTP_PORT_NOT_OPEN. This API returns a UTP_STATUS value indicating the status of the operation, which may be one of the following: UTP_OK, or UTP_INVALID_HANDLE.\n\n","This API is called by the application to set up a buffer in which to receive bulk data. All bulk data received through that port will be placed into that buffer in a circular manner, i.e., it will wrap around to the beginning of the buffer if it is determined that the bulk data currently being sent will not fit contiguously at the end of the buffer. The argument uphPort is the handle of the port returned from UTP_OpenPort( ). The argument nBufferSizeInBytes is the number of bytes this buffer will be able to hold. This API returns a UTP_STATUS value indicating the status of the operation, which may be one of the following: UTP_OK; UTP_INSUFFICIENT_MEMORY; UTP_INVALID_HANDLE; or UTP_INVALID_REQUEST (port is not open for UTP_BULK_DATA_RECEIVE).\n\n","This API frees the receive data buffer allocated to the port that is specified by the argument uphPort. This buffer could have been either a bulk data receive buffer as allocated by UTP_AllocateBulkDataBuffer( ) or could be the message buffer automatically allocated by the UTP layer in the most recent call to UTP_Receive( ). Note that message receive buffers allocated by the UTP layer and returned in UTP_Receive will automatically be freed upon the subsequent call to UTP_Receive. This API returns a UTP_STATUS value indicating the status of the operation, which may be one of the following: UTP_OK; or UTP_INVALID_HANDLE.\n\n","This API provides the UTP layer with a message queue specified by the argument uqhQueue into which notification messages will be posted indicating that a message or some bulk data has been received on the port specified by the argument uphPort. The argument uqhQueue is the UOS thread queue to which messages received on this port will be placed. The argument umtMsgType is the UOS message type that messages posted to that queue will have. The posted message will be of the message type specified by umtMsgType and contain as a message parameter the UTP_PORT_HANDLE of the port through which that message or bulk data was received. For each message already pending at this port when UTP_SetReceiveNotify( ) is called, a message will be posted to the specified queue as a result of the call. If UTP_SetReceiveNotify( ) had already been called prior to this call, the values of uqhQueue and umtMsgType will override the ones previously set. Specifying uqhQueue as UOS_NULL_QUEUE will disable receive notification on this port. This API returns a UTP_STATUS value indicating the status of the operation, which may be one of the following: UTP_OK; UTP_INVALID_PARAMETER (uqhQueue is not a valid UOS_THREAD_QUEUE); UTP_INSUFFICIENT_MEMORY; UTP_INVALID_HANDLE; or UTP_INVALID_REQUEST (port is not open for RECEIVE).\n\n","This API sends a message or a set of bulk data blocks through the port specified by the argument uphPort. The argument ppubdBufferDesc points to an array of pointers to UTP_BUFFER_DESCs, and the length of that array (in number of such pointers) is specified by the argument nDesc. The message or set of bulk data blocks will be sent in the order specified, and will be received into a contiguous buffer on the receiving end. When all data sent has been placed into that receive buffer, the UTP layer on the receiving end will either post a notification to the queue associated with that port or complete a UTP_Receive( ) operation, whichever is appropriate. This API is a blocking call and will complete when the data is fully contained in the receive buffer (it does not need to be received by the receiving application). The sending application may then call UTP_Send( ) again. If the application on the receiving end does not immediately receive the buffer, it will be held until received by the receiving application, and no messages will be lost. This API returns a UTP_STATUS value indicating the status of the operation, which may be one of the following: UTP_OK; UTP_INVALID_PARAMETER (ppubdBufferDesc is NULL or nDesc is zero); UTP_LINK_FAILURE (link failure detected during send attempt); UTP_INSUFFICIENT_MEMORY (not enough memory for receive buffer); UTP_INVALID_HANDLE; UTP_INVALID_REQUEST (port is not open for SEND); or UTP_PORT_BUSY.\n\n","This API will, if the port specified in the argument uphPort was opened in UTP_MESSAGE_RECEIVE mode, free the UTP layer allocated buffer referred to in the UTP_BUFFER_DESC that was returned in the previous call to this APT, and that buffer may no longer be used. The argument pubdBufferDesc is the port data descriptor as explained supra. The argument pnReceivesPending is a pointer to memory location that is to receive the number of sends still pending in the receive queue for this port after this one is removed. This API then fills in the UTP_BUFFER_DESC specified by pubdBufferDesc with the pointer to and the size, in bytes, of the oldest data buffer (either bulk data or message data) that arrived on the specified port and returns the status of the data received in that buffer. This API will indicate the number of buffers remaining after the one received by storing that information in the location specified by pnReceivesPending. If this value is NULL, that information will not be provided. If the port was opened in UTP_BULK_DATA_RECEIVE mode and either the amount of data sent is larger than the allocated buffer or the buffer had filled up and the oldest buffer segment not yet returned in a call to UTP_Receive had been overwritten, the UTP_BUFFER_DESC will still indicate the correct bufSize that had been transferred. In the former case the buffer contents will not be overwritten, pBuf will be invalid, and a UTP_STATUS of UTP_BUFFER TOO_SMALL will be returned. In the latter case, the oldest buffer segments will be overwritten, the pBuf value will point at overwritten data and a UTP_STATUS of UTP_BUFFER_OVERRUN will be returned. Note that, in the case of UTP_BUFFER_OVERRUN and possibly in the case where no un-received buffer segments at all were overwritten, the buffer segment returned in the most recent call to UTP_Receive( ) may be overwritten while being processed by the client. In order to avoid this potentially hazardous condition, it is recommended that the client monitor the status of the buffer using the information provided through pnReceivesPending to receive and discard all buffer segments that could possibly fall into this category shortly thereafter. If the port is open in UTP_BULK_DATA_RECEIVE mode and the UTP layer has detected an integrity failure in the data transferred, a status of UTP_INTEGRITY_FAILURE will be returned.","This API is a blocking call, waiting till a message or bulk data buffer has been received. If used in conjunction with UTP_SetReceiveNotify( ), this call will not block, since a buffer will always be available if such notification has been made. UTP_Receive( ) will also unblock if the port is closed and will return a status of UTP_PORT_NOT_OPEN. This API returns a UTP_STATUS value indicating the status of the operation, which may be one of the following: UTP_OK; UTP_INVALID_PARAMETER (pubdBufferDesc is NULL); UTP_LINK_FAILURE (link failure detected during receive attempt); UTP_INSUFFICIENT_MEMORY (not enough memory for receive buffer); UTP_PORT_NOT_OPEN (port was closed while receive pending); UTP_INVALID_REQUEST (port is not open for RECEIVE); UTP_BUFFER_OVERRUN (some bulk data overwritten, this not the oldest); UTP_INVALID_HANDLE; UTP_BUFFER_TOO_SMALL; or UTP_INTEGRITY_FAILURE;.","The application program interfaces (APIs) for an exemplary implementation of the Ultrasound Service Protocol Layer (USP) are described herein by way of nonlimiting example. For simplicity and clarity of disclosure, the APIs below presume a simple case of an ultrasound host, such as an overall system control and user display unit, and an ultrasound scanner. However, based on the present disclosure, one skilled in the art could readily implement APIs for implementing the more general Ultrasound Service Protocol Layer functionality disclosed supra in the present disclosure. Although the data types and API calls described below are based on the C\/C++ programming language, they are readily adaptable to any object-oriented programming language or platform that enables multi-threaded execution flow. Table 16 shows USP layer data definitions associated with the USP API's described herein.",{"@attributes":{"id":"P-d0e7759","num":"00002"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 16"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Ultrasound Service Protocol Layer Data Definitions"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"typedef enum {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"kMsgCommand,","\/* host to scanner command"]},{"entry":[{},{},"message *\/"]},{"entry":[{},"kMsgAcknowledge,","\/* acknowledge message *\/"]},{"entry":[{},"kMsgStatus","\/* scanner to host status message *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} USP_MESSAGE_TYPE;"},{"entry":"typedef enum {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"kSMsgInit,","\/* Scanner initialization *\/"]},{"entry":[{},"kSMsgStop,","\/* Stop the scanner"]},{"entry":[{},"kSMsgRun,","\/* Starting run the scanner"]},{"entry":[{},"kSMsgRealTimeProgram,","\/* program scanner HW without"]},{"entry":[{},{},"stop it *\/"]},{"entry":[{},"kSMsgOfflineProgram,","\/* program scanner while scanner"]},{"entry":[{},{},"stopped *\/"]},{"entry":[{},"kSMsgLoadInputComp,","\/* load input compression curve *\/"]},{"entry":[{},"kSMsgLoadDspCode","\/* load dsp binary code *\/"]},{"entry":[{},"kSMsgReqProbeStatus,","\/* request probe connection"]},{"entry":[{},{},"status *\/"]},{"entry":[{},"kSMsgReqestHWStatus,","\/* request scanner HW status *\/"]},{"entry":[{},"kSMsgReqestSWStatus,","\/* request scanner SW status *\/"]},{"entry":[{},"kSMsgReqestHWInfo,","\/* request scanner HW"]},{"entry":[{},{},"information *\/"]},{"entry":[{},"kSMsgReportProbeStatus,","\/* report probe status *\/"]},{"entry":[{},"kSMsgReportHWStatus,","\/* report scanner HW status *\/"]},{"entry":[{},"kSMsgReportSWStatus,","\/* report scanner SW status *\/"]},{"entry":[{},"kSMsgReportHWInfo","\/* report HW information *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} SUB_MESSAGE_TYPE;"},{"entry":"typedef enum {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"kOpLoadHW,"]},{"entry":[{},"kOpReadHW,"]},{"entry":[{},"kOpSetBits,"]},{"entry":[{},"kOpResetBits"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} SUB_MESSAGE_OPERATION;"},{"entry":"typedef struct tagAsyncMsgHeader {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"UI32 uiMsgHeader;","\/* unique Id for asynchronous"]},{"entry":[{},{},"message *\/"]},{"entry":[{},"UI32 ultrasoundStateID;","\/* unique Id for ultrasound state *\/"]},{"entry":[{},"UI32 uiMsgType;","\/* message type *\/"]},{"entry":[{},"UI32 uiNumOfSubMsg;","\/* number of sub messages *\/"]},{"entry":[{},"UI32 uiDataSizeBytes;","\/* message header size in bytes,"]},{"entry":[{},{},"inc header *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} ASYNC_MESSAGE_HEADER;"},{"entry":"typedef struct tagSubMsgHeader {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"UI32 uiSubMsgType;","\/* sub message type in"]},{"entry":[{},{},"SUB_MESSAGE_TYPE *\/"]},{"entry":[{},"UI32 uiSubMsgOp;","\/* sub message operation *\/"]},{"entry":[{},"UI32 uiLogicAddress;","\/* logical address *\/"]},{"entry":[{},"UI32 uiAddressOffset;","\/* offset to the logical address *\/"]},{"entry":[{},"UI32 uiDataSizeBytes;","\/* size in bytes for sub message"]},{"entry":[{},{},"data section *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} HOST_SUB_MESSAGE_HEADER;"},{"entry":"typedef struct tagSubMsgHeader {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"UI32 uiSubMsgType;","\/* sub message type in"]},{"entry":[{},{},"SUB_MESSAGE TYPE *\/"]},{"entry":[{},"UI32 uiStatusId;","\/* status Id *\/"]},{"entry":[{},"UI32 uiLogicAddress;","\/* logical address *\/"]},{"entry":[{},"UI32 uiAddressOffset;","\/* offset to the logical address *\/"]},{"entry":[{},"UI32 uiDataSizeBytes;","\/* size in bytes for sub message"]},{"entry":[{},{},"data section *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} SCANNER SUB_MESSAGE_HEADER;"},{"entry":"typedef enum {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"kUspOk,","\/* operation complete"]},{"entry":[{},{},"successfully *\/"]},{"entry":[{},"kUspMsgExist,","\/* message already created *\/"]},{"entry":[{},"kUspInvalidParameter,","\/* wrong input parameters *\/"]},{"entry":[{},"kUspExceedTotalMsgs,","\/* exceed the total messages *"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} USP_STATUS;"},{"entry":"typedef struct {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"USP_MESSAGE_TYPE msgType,"]},{"entry":[{},"UI32 numberSubMessages,"]},{"entry":[{},"UI32 ultrasoundStateID"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} APPLICATION_MESSAGE_HEADER,"},{"entry":"*PAPPLICATION_MESSAGE_HEADER;"},{"entry":"typedef struct {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void *pBuf;","\/* start address of this"]},{"entry":[{},{},"message buffer *\/"]},{"entry":[{},"UI32 bufSize;","\/* size in bytes of this message"]},{"entry":[{},{},"buffer *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} USP_MESSAGE_DESC * PUSP_MESSAGE _DESC;"},{"entry":"typedef struct {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"UI32 uiFrameType;","\/* received frame type *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["#define B_FRAME","0x0"]},{"entry":["#define COLOR_FRAME","0x1"]},{"entry":["#define M_FRAME","0x2"]},{"entry":["#define DOPPLER_FRAME","0x4"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"UI32 ultrasoundStateID;","\/* current ultrasound state id *\/"]},{"entry":[{},"UI32 uiFrameId;","\/* current frame id *\/"]},{"entry":[{},"US8 pFrameData;","\/ * frame data pointer *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} USP_FRAME_DESC, *PUSP_FRAME_DESC;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The USP APIs described herein represent exemplary functions that provide the services to construct and interpret USP asynchronous messages for both host and scanner software. The USP APIs receive requests from the application layer program to perform functions related to the construction and interpretation of command and bulk data information, such that ultrasound application programmers for both host and scanner device manufacturers do not need to concern themselves with specific USP formatting issues. Rather, the application programmers may simply use the USP APIs provided herein and other USP APIs that may be developed in accordance with the preferred embodiments. It is to be noted in the present examples, however, that the application layer is responsible for allocating memory for message headers and message data, and is also responsible for sending and receiving messages by calling the UTP layer APIs. However, it is within the scope of the preferred embodiments that the USP layer could also provide intelligent APIs capable of performing memory allocation tasks and UTP layer management tasks on behalf of the application program layer.\n\n","This API is called by the ultrasound application program to construct a USP asynchronous message. This routine allocates an array to hold the message header, tail and submessage descriptor pointers. It also allocates memory for asynchronous message header, tail and submessage descriptors. The ultrasound application passes asynchronous message type and ultrasoundStateID to initialize the message header. The total number of submessages is used to allocate memory. The application also passes a pointer to the constructed message descriptor array, which will be valid when the message construction is complete.\n\n","This API is called by the ultrasound application program to add a submessage descriptor list to the asynchronous message body. The application passes the submessage counts and the pointer to the message descriptor array to this routine. If the number of submessages to be added exceeds the total number of sub messages passed by calling StartConstructMessage( ), an error kUstrExceedTotalMsgs will be returned.\n\n","This API is called by the ultrasound application program to signal the end of message construction. The pppubdBufferDesc is initialized with the valid pointer to the message descriptor array. The pointer can be passed to the UTP layer send API, supra, to send an asynchronous message.\n\n","This API is called by the ultrasound application program to free memory, which is allocated during the message construction. The application should call this routine after the message is sent by the UTP layer send API.\n\n","This API is called by the ultrasound application program to retrieve an application message header from a message. The application passes pubdBufferDesc, which is received by calling UTP_Receive( ). The application allocates the memory for the ApplMsg data structure.\n\n","This API is called by the ultrasound application program to retrieve a sub message from asynchronous message body. The message is specified by indexSubMessage and the message is returned through pBufMsg. The pBufSubMsg indicates from which the sub message should be retrieved. The message header and data are in original message buffer so that the application does not need to allocate memory before calling this routine.\n\n","This API is called by the ultrasound application program to retrieve a frame descriptor from a frame of received data. The application passes pubdFrameDesc, which is a data structure allocated by application and a received data frame pointer. The frame descriptor is filled in by fetching parameters from received data frame header.","Whereas many alterations and modifications of the present invention will no doubt become apparent to a person of ordinary skill in the art after having read the foregoing description, it is to be understood that the particular embodiments shown and described by way of illustration are in no way intended to be considered limiting. Therefore, reference to the details of the preferred embodiments are not intended to limit their scope, which is limited only by the scope of the claims set forth below."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"P-00017","num":"00017"},"figref":"FIG. 1"},{"@attributes":{"id":"P-00018","num":"00018"},"figref":"FIG. 2"},{"@attributes":{"id":"P-00019","num":"00019"},"figref":"FIG. 3"},{"@attributes":{"id":"P-00020","num":"00020"},"figref":"FIG. 4"},{"@attributes":{"id":"P-00021","num":"00021"},"figref":"FIG. 5"},{"@attributes":{"id":"P-00022","num":"00022"},"figref":"FIG. 6"},{"@attributes":{"id":"P-00023","num":"00023"},"figref":["FIG. 7","FIG. 6"]},{"@attributes":{"id":"P-00024","num":"00024"},"figref":"FIG. 8"},{"@attributes":{"id":"P-00025","num":"00025"},"figref":"FIG. 9"},{"@attributes":{"id":"P-00026","num":"00026"},"figref":"FIG. 10"},{"@attributes":{"id":"P-00027","num":"00027"},"figref":"FIG. 11"}]},"DETDESC":[{},{}]}
