---
title: Virtual machine extended capabilities using application contexts in a resource-constrained device
abstract: Embodiments of the systems and methods utilize application contexts for extending virtual machines in a resource-constrained device to allow virtual machines to at least exercise scheduling control over platform independent applications and platform dependent native applications. Application contexts can be assigned to each application in the system. An application is represented by one or more data structures and functions. In one embodiment, an “application context” includes an interface to a virtual machine and a container for an execution environment of the application. The interface represents a mapping of services to an execution environment. The application context can isolate control over the execution of the application from the execution environment, thus, allowing the virtual machine to control execution of the application and allowing the application to be executed in a native environment, a virtual machine environment, or any other execution environment.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07895594&OS=07895594&RS=07895594
owner: Freescale Semiconductor, Inc.
number: 07895594
owner_city: Austin
owner_country: US
publication_date: 20050328
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["1. Field of the Invention","The present invention relates in general to the field of information processing, and more specifically to a system and method for extending virtual machines in a resource-constrained device using application contexts that allow virtual machines to exert control over a variety of applications, including native applications, and facilitate extending functionality of the virtual machines.","2. Description of the Related Art","For resource-constrained devices and other computers that employ an operating system, two traditional software layers exist: the operating system and the software programs (or \u201capplications\u201d) that run on the operating system. A resource-constrained device is, for example, a device that has limited resources available for performing computing functions. For example, a resource-constrained device generally has limited memory, limited processing power, and\/or limited graphical capabilities. Mobile phones, pagers, and personal digital assistants represent examples of resource-constrained devices. Software applications are programs used on a computer to accomplish particular desired tasks. An operating system is designed to function on a particular type of computer hardware, and an application is designed to run on a particular operating system (and processor). Such operating systems and applications are thus said to be \u201cplatform-specific\u201d. The platform specific applications are also commonly referred to as \u201cnative applications\u201d.","Platform-specific application programs are first written with a programming language to create a set of instructions called \u201csource code.\u201d When writing source code for a platform-specific application, the developer must be mindful of the underlying operating system, in order to successfully invoke the operating system's application program interfaces (APIs). These API's essentially provide the vocabulary of the language understood by the operating system. If the source code of a platform-specific application is not written to accommodate the particular APIs of a given operating system, then the application will not run on that operating system. Thus, platform-specific applications are dependent on the specific operating system and hardware for which the application was designed and compiled.","Platform-independent applications utilize virtual machine technology, such as Sun Microsystem's Java\u2122 technology, to significantly reduce the difficulty of producing applications for different operating system and hardware platforms. Platform-independent applications developed using the Java technology differ from traditional platform-dependent software in that the platform-independent applications need not interact directly with the specific operating system or hardware of a given computer. Java programs are compiled into an intermediate platform-independent representation called bytecode. At run-time, platform-independent applications typically interact with a Java virtual machine (\u201cJVM\u201d), which is an intermediate software layer that includes a programming language interpreter. The JVM interprets (i.e. translates) the Java-based program for the particular operating system and hardware platform that the Java virtual machine runs on. In essence, the Java-based program views the JVM as an operating system, and the operating system views the JVM as a traditional application.","The Mobile Information Device Profile (MIDP) is a set of Java APIs. The Connected Limited Device Configuration (CLDC) defines the base set of application programming interfaces and a virtual machine for resource-constrained devices such as mobile phones, pagers, and personal digital assistants. The Java virtual machine for resource-constrained devices intended to execute MIDlets is called the kJava Virtual Machine (KVM). Because, the KVM also interprets (i.e. translates) kJava-based programs for the particular operating system and hardware platform that the KVM runs on, the KVM can be considered as a virtual computer and an operating system (OS) from the perspective of kJava based programs. The CLDC combined with a profile such as the Mobile Information Device Profile (MIDP) provides a solid Java platform for developing applications to run on devices with limited memory, limited processing power, and limited graphical capabilities. Thus, the MIDP together with the Connected Limited Device Configuration (CLDC) provides a complete J2ME\u2122 application runtime environment targeted to mobile information devices. A MIDlet is a Java application developed using the MIDP, and intended to be run on a mobile information device.","As processing capabilities, bandwidth, and other technologies improve, mobile information devices become more and more powerful and are capable of performing an increasing number of functions. Concurrently executing multiple applications (referred to as \u201cmulti-tasking\u201d) has become a standard feature of mobile information devices. For example, it is relatively common to concurrently execute a phone-call handling routine, game, and a phone-book application.",{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1","b":["100","102","104","106","108","110","112","114","102","114","102"]},"An \u201cevent\u201d encompasses actions initiated either by a user of a computer or internally generated by the computer. An example of a user event is any mouse movement, mouse click, keystroke, or a spoken word. An example of an internally generated event is a notification based on the time of day. If an event is passed to the KVM , a corresponding Java or native method (handler) is found and invoked. An event handler is generally a software routine that provides processing instructions for various events. For methods that are supposed to be frequently invoked, a mobile information device  can accomplish invoking frequently invoked applications using a special reference table. The applications can be registered in the table during implementation of a KVM .","Current software architectural technologies cannot be efficiently applied to embedded software development. Embedded software represents, for example, software applications that provide various basic services such as menu displays, phone-calling handling, and some standard games. Currently no mechanisms exist to allow a native application to run under control of the KVM. Any native application that should be executed while the KVM is running runs as a parallel process on the OS level. There will not be full resource sharing (or may not be sharing at all) and no control from the KVM side.",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2","b":["200","202","204","100","202","206","208","204","210","212","214","204"]},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3","b":["300","302","304","110","306","308","310","312","300","300"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4","b":["400","402","404","406","408","410","412","400"]},"Java programs can be written to include a portion written in a non-Java programming language to access functionality not yet supported in the Java technology, but which may be available in the underlying (\u201cnative\u201d) operating system or hardware. To do this, the Java technology includes a \u201cJava Native Interface\u201d (JNI). JNI is a standard Java API that acts as a link between the JVM and the platform-specific code included in a JAVA application to perform the particular operating-system function. JNI thus gives programmers a way to use native platform functionality with their Java-based software. However, conventional JAVA technology does not support JVM control over pure native applications.","Adding new OS and virtual machine functionality or choosing or creating a new OS can, thus, be expensive, time-consuming, and difficult to distribute to then-existing resource-constrained devices.","In one embodiment of the present invention, a resource-constrained device includes a processor and a memory, coupled to the processor, wherein the memory includes computer programs executable by the processor. The computer programs include an operating system to provide functions to native applications, a virtual machine, and one or more native applications under scheduling control of the virtual machine. Each native application is associated with an application context, and each application context at least (i) maps one or more services provided by the associated native application to an interface of the virtual machine and (ii) maintains a state of the associated native application.","In another embodiment of the present invention, a method extends capabilities of a virtual machine. The method allows the virtual machine to at least control scheduling of one or more native applications installed in a resource constrained device. An operating system provides function to each native application. The method includes, for each native application, mapping one or more services provided by the native application to an interface of the virtual machine through an application context associated with the native application. The method further includes, for each native application, maintaining a state of the native application in the application context associated with the native application.","In another embodiment of the present invention, a mobile information device includes a processor for processing computer program code and a memory, coupled to the processor. The memory includes computer programs executable by the processor. The computer programs include an operating system to provide functions to native applications and a virtual machine. The computer programs further include for each native application, means for mapping one or more services provided by the native application to an interface of the virtual machine through an application context associated with the native application and for each native application, means for maintaining a state of the native application in the application context associated with the native application.","Despite the number of platform independent applications (e.g. Java applications) available for execution by a mobile information device executing a virtual machine, utilization of platform-dependent, native applications instead of or in conjunction with platform independent applications often remains desirable (e.g. performance (especially for interactive tasks) or security reasons). To increase the potential capability of a virtual machine, such as the Java Virtual Machine and KVM, a new virtual machine extension technology allows a developer or user to extend the functionality of a virtual machine without requiring development of a new virtual machine implementation or requiring subsequent virtual machine architectural changes. The new technology facilitates control by a virtual machine over both platform independent applications and native applications. The new technology utilizes new application contexts that include the ability to store information about a native application and allow a virtual machine to control the native application and the platform-independent application. The new technology is particularly useful for resource-constrained devices. In one embodiment, the new technology extends application program interfaces (APIs) of any native application and allows registration of the native application APIs with the virtual machine. Registration of the native application APIs can occur during run-time, thus, increasing the utility, distribution efficiency, and cost-effectiveness of providing new applications to resource-constrained devices.","Thus, a new approach to extending capabilities of virtual machines, such as KVM, provides an ability to easily extend functionality of virtual machines without internal changes to the virtual machine. This approach allows virtual machine functionality to accomplish new purposes, e.g. a newly introduced phone feature), and decrease development cycle time. This approach provides a way to improve the capabilities of consumer products, thus, making products more attractive for customers. Additionally this approach can be used in any personal mobile device that supports a virtual machine such as Java. More generally, this approach can be used for any platform-dependent and platform-independent applications for portable devices, especially for those that require fast execution. This approach is especially beneficial for resource-constrained devices.","Embodiments of the systems and methods utilize application contexts for extending virtual machines in a resource-constrained device. Application contexts can be assigned to each application in the system. An application is represented by one or more data structures and functions (also sometimes referred to as \u201cmethods\u201d). In one embodiment, an \u201capplication context\u201d includes an interface to a virtual machine and a container for an execution environment of the application. The interface represents a mapping of services to an execution environment. The application context can isolate control over the execution of the application from the execution environment, thus, allowing the virtual machine to control execution of the application and allowing the application to be executed in a native environment, a virtual machine environment, or any other execution environment. However, by maintaining control over the application, the application context allows native applications to be managed with shared resources from platform independent applications, such as Java applications. Thus, the virtual machine can be a service provider of any application regardless of language.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 5","b":["500","502","500","504","506","500","500","506","508","510","506","510","510","510","510","510","510","500","510","510","510","510"]},"By allowing the VM to be a service provider to any application, the VM can track (book keep) and maintain resource utilization across applications, thus the VM can be viewed as a resource itself providing management of resources to applications. By managing resources, the VM enables isolation between applications and, thus, can free resources, allocate, reuse, suspend, network connection sharing, etc. Accordingly, the VM can effectively manage resources in multiple environments.","Additionally, application contexts also facilitate extending the base VM  through extended VM functions . Application contexts simplify extensibility of the base VM  by allowing native and non-native applications to extend the VM through application contexts working within the inherent isolation framework of the VM architecture from execution environments. Thus, application functionality can be extended with new functionality of the VM  contained by application contexts. VM functionality can also be controlled with new functions also contained in application contexts.","The application contexts map entry points of native applications to entry points used by the VM to control an application. Entry points used by a VM are a matter of design choice and are often part of the public domain. For example, MIDP specifies several entry-points via which the VM application can be accessed. The entry points are usually tied to system events such as a key press and a move to foreground event. Any native application that has a corresponding set or subset of entry points can be used by the VM. Entry points are commonly defined in a description of an application's APIs.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 6","FIG. 6"],"b":["601","601","602","604","602","510","510","510","510","602"],"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":["startApp","pauseApp","destroyApp","hideNotify","showNotify"]}}}},"The functions reflect functions defined in MIDP. The Callsback table  interface could also include an implementation-defined function or functions such as the function keyPressed that detects a key press. Application context  also wraps up the MyMIDlet application's methods in Method table :\n\n","Registration mechanism  provides a link between the interface of Callsback table  and the MyMIDlet application functions in method table . The registration mechanism can be referred to as \u201cregistered callbacks\u201d.","Wrapping a MIDlet with an associated application context:\n\n","Similarly, application context  depicts an example of an application context associated with a platform dependent, native application, such as the MyNativeApp application. Application context  includes a Callbacks table  interface and a MyNativeApp method table . The Callbacks table  contains function call names that represent an interface used by VM  to control execution of the MyNativeApp application. The particular interface used by VM  to control application execution is a matter of design choice. In the embodiment of , the Callbacks Table  interface is defined by the same set of self-described functions in Callbacks Table , namely:\n\n","The Callsback table  interface could also include implementation-defined function or functions such as the function keyPressed that detects a key press. Application context  also wraps up the MyMIDlet application's methods in Method table :\n\n","Thus, in the embodiment of , the VM  can exercise control over applications through the Callsback table interfaces by starting the application, pausing the application, killing the application, and moving the application display to the foreground or background.","Registration mechanism  provides a link between the interface of Callsback table  and the MyNativeApp application functions in method table .","Wrapping a native application with an interface accessible to VM :\n\n","Mixing native and platform independent applications into a system controlled by VM :\n\n","In one embodiment, no internal structure of an application associated with (wrapped by) an application context is known outside of the associated application context. Thus, in this embodiment, the VM  has no information about information maintained within application contexts  and . The application contexts  and  maintain the respective application reference, current state, and some \u201cruntime environment\u201d shared resources such as thread identification (ID), display, current font, current displayable (the object to be displayed), and port ID of the associated application.","In run-time, the application contexts  and  decide how to execute the application associated with the respective application context. For a platform independent application, such as a MIDlet, the application context  runs an interpreter to interpret Java byte-code. For a platform dependent, native application the application context  can enter the function of an OS registered native application.",{"@attributes":{"id":"p-0053","num":"0083"},"figref":"FIG. 7","b":["700","700","702","1","2","3","1","2","1","2","3","1","2","3","702"]},"Application contexts provide extensibility to a virtual machine. For example, a VM interface to external applications, as for example represented by Callbacks tables  and , may not comprehensively match the native application abilities. For example, a native application may have entry points such as the self-described entry points: killProcess( ) or closeAll( ), that have no virtual machine external interface counterpart. However, the VM interface can be easily extended to allow registration (linking) of the VM entry points in the application context to entry points of any native application to facilitate incorporation of any native application into the system . Extension of the VM interface can be accomplished through a broadcast update of the VM interface or by hard coding the VM interface for new devices. The application contexts supporting VM control over applications can be created by the VM dynamically. The KVM core  will not be affected by such extensions, and, thus, extending the KVM core  capability to control any native application can be accomplished in a run-time environment. Each application, such as MyMIDlet and MyNativeApp are logically unaware of other applications. Thus, adding a new application to the set of applications in system  or changing behavior of an application does not directly affect other application members of system . In one embodiment, only KVM core  is responsible for controlling applications through state changing\/tracking, task switching, critical resource allocating etc. For example, background\/foreground task switching is a special case of resource granting mechanism: Display (or off-screen buffer) is an example of a \u201ccritical resource\u201d. A \u201cstate machine\u201d concept can be used internally to provide consistent states of the application list and applications themselves.",{"@attributes":{"id":"p-0055","num":"0085"},"figref":"FIG. 8","b":["800","802","804","804","802","806","808","804","806","802","806","804","802","810"]},{"@attributes":{"id":"p-0056","num":"0086"},"figref":"FIG. 9","b":["900","800","902","802","500","904","804","804","906","804","804"]},"In general, from a security standpoint, native applications are more trusted by a system than platform independent applications such as MIDlets. Access by an application to system functions can be limited using access-layers. The access-layer defines function sets that can be accessed by applications. An example of an access-layer is a trusted layer: File System advanced package tool (APT) is available; execution of application program interface (API) push function. Another example of an access-layer is a non-trusted layer: only viewing and picturing functions are available.",{"@attributes":{"id":"p-0058","num":"0088"},"figref":"FIG. 10","b":["1002","1004","1000"]},"The native application is written in the C programming language and is wrapped by an associated application context. Additionally platform independent applications represented by MIDlets, such as MIDlets list applications , are also installed in the system  and wrapped by respective application contexts. In at least one embodiment, dynamic application management provides the ability to add or remove applications from the MIDlets list applications . Native application MIDlet eXplorer  is running under KVM control and shares resources like fonts and display buffer with the platform independent applications (MIDlets) . When MIDlet eXplorer  goes foreground, MIDlet eXplorer  draws the list of applications and returns control to the KVM. When a button on the phone simulator (device) is selected, the KVM invokes a corresponding callback of MIDlet eXplorer  (while MIDlet eXplorer  is in the foreground). When control is returned to the KVM, the KVM interprets the bytecodes of executing platform independent MIDlets. A current view of a running platform independent MIDlet application can be viewed using a command-button presented by the MIDlets list application . A hotkey \u201cM\u201d can be used to return to the display depicted in .",{"@attributes":{"id":"p-0060","num":"0090"},"figref":["FIG. 11","FIG. 12"],"b":["1200","1","2","1102","1102","1","2","1104","1106","1102","1106","1202","1108","1110","1102","1102","1108","1102","1108","1112","1204","1102","1108","1102","1108","1102","1108","1206","1106","2","3","1112","1108","1200"]},"Thus, although traditional technology of a Java Virtual Machine doesn't suppose native application execution inside, the virtual machine extensions facilitated by application contexts extend the functionality of virtual machines, such as the KVM, to the extend desired. Usage of native applications can resolve problems related to execution speed for some critical issues. Application contexts provide a particularly useful solution for resource-constrained devices. No memory or processing overhead required. Some advantages of one or more embodiments of application contexts and virtual machine control over platform independent and native applications are:\n\n","Although the present invention has been described in detail, it should be understood that various changes, substitutions and alterations can be made hereto without departing from the spirit and scope of the invention as defined by the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention may be better understood, and its numerous objects, features and advantages made apparent to those skilled in the art by referencing the accompanying drawings. The use of the same reference number throughout the several figures designates a same or similar element.",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 12"}]},"DETDESC":[{},{}]}
