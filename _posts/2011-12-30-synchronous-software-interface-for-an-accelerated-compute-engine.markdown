---
title: Synchronous software interface for an accelerated compute engine
abstract: Some implementations disclosed herein provide techniques and arrangements for a synchronous software interface for a specialized logic engine. The synchronous software interface may receive, from a first core of a plurality of cores, a control block including a transaction for execution by the specialized logic engine. The synchronous software interface may send the control block to the specialized logic engine and wait to receive a confirmation from the specialized logic engine that the transaction was successfully executed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09053022&OS=09053022&RS=09053022
owner: Intel Corporation
number: 09053022
owner_city: Santa Clara
owner_country: US
publication_date: 20111230
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","TECHNICAL FIELD","BACKGROUND","DETAILED DESCRIPTION"],"p":["This patent application is a U.S. National Phase Application under 35 U.S.C. \u00a7371 of International Application No. PCT\/US2011\/068072, filed Dec. 30, 2011, entitled SYNCHRONOUS SOFTWARE INTERFACE FOR AN ACCELERATED COMPUTE ENGINE.","Some embodiments of the invention generally relate to the operation of processors. More particularly, some embodiments of the invention relate to a synchronous software interface for an accelerated compute engine.","A processor may include a particular unit to perform specialized functions, such as graphics-related functions (e.g., texture mapping, histogram generation, and the like) or multimedia-related functions (e.g., video encoding\/decoding and the like). The particular unit may enable applications to use the particular unit to perform various specialized functions but may not handle certain events, such as page faults. For example, when a page fault occurs, the particular unit may report a page fault error to the application and request the application to address the page fault. However, most applications may be incapable of addressing a page fault as an operating system usually handles page faults.","Enabling Access to a Resource in a Processor","The technologies described herein generally relate to providing a software interface that enables access to a computing resource in a processor. While an accelerated compute engine (ACE) is used herein as an example of a resource, the technologies described herein may be used to enable access to other processor-related resources, such as resources internal to or external to the processor. In addition, while the examples described herein illustrate a single ACE that is shared by multiple cores, in some implementations, a processor may have more than one ACE. For example, a processor may include multiple ACE units, with each ACE being shared by a particular number of cores. To illustrate, if a single ACE is capable of supporting four cores, a processor with eight cores may have two ACE units, a processor with twelve cores may have three ACE units, and so on. Thus, in some cases, the number of ACE units may be proportional to the number of cores, based on how many cores a single ACE is capable of supporting.","As used herein, the term core refers to a processing core, such as a logical processing core or a physical core (e.g., an execution unit and associated caches). To illustrate, a technique such as hyper-threading may be used to provide two (or more) logical cores from the resources of a single physical core. Thus, a processor with two physical cores may provide a total of four logical processors that are capable of simultaneously executing four threads.","An ACE may provide specialized functionality to one or more cores (e.g., general purpose cores) in a processor. For example, the ACE may provide the cores in the processor with fine-grained control over specialized functions, such as graphics functions or arithmetic functions. To illustrate, a conventional graphics processing unit (GPU), when called upon by a core, may perform a function that takes on the order of millions of cycles to complete. In contrast, the ACE may perform functions that take on the order of hundreds of cycles or thousands of cycles to complete. By incorporating specialized resources, such as the ACE, a processor may achieve a significant increase in performance, particular in areas such as graphics processing or multimedia processing, as compared to processors that do not include such specialized resources.","As another example of the fine-grained control, applications (e.g., threads) executing on the multiple cores may directly access the ACE. Direct access means that the applications may access the ACE without using an intermediary, such as a device driver, application programming interface (API), operating system, and the like. Applications may directly access the ACE while the applications are executing in user-mode (e.g., rather than in kernel-mode). In some implementations, an operating system may be aware of the ACE while in other implementations the operating system may be unaware of the ACE. Applications may be allowed direct access to the ACE regardless of whether or not the operating system is aware of the ACE. In additional, in an implementation where the operating is unaware of the ACE, managing the resources (e.g., memory management and the like) of the ACE may be performed by hardware or by software (e.g., software that is different from the operating system). Thus, if an operating system is aware of the ACE, the operating system may manage the ACE resources. If an operating is unaware of the ACE, the operating system may not manage the ACE resources. Instead, the ACE resources may be managed by hardware or by software that is not included in the operating system.","As yet another example of the fine-grained access, virtual addresses associated with the threads may be shared between the multiple cores and the ACE to enable the ACE to directly access the address spaces associated with the threads. However, because the ACE can access virtual memory, the ACE may generate page faults. A page fault may occur when the ACE initiates access to a virtual memory location that has not been loaded into physical memory. The ACE may be unable to handle page faults. Instead, the ACE may return a status indicating that a request was not completed due to a page fault.","The multiple threads may interact with the ACE using an ACE control block (ACB). For example, the ACB may include (1) a header block that includes a status (e.g., new, inside execution pipe, done, page fault, invalid, and the like) associated with execution of instructions in the ACB, (2) an input parameter space identifier that identifies a location of input parameters, (3) an output data space identifier that identifies a location to output the results of processing the input parameters, and (4) an output error space identifier that identifies a location to output error-related data, such as error messages and data dumps (e.g., contents of registers, caches, pipelines, and the like). For example, the output data space identifier may include a virtual address space associated with a thread that sent the ACB to the ACE. The status field may thus indicate whether a particular event, such as a page fault, occurred. Of course, the ACB may include other content in addition to or instead of the previously described content. For example, the content of the ACB may vary depending on the particular function of the ACE that is being called. The ACB may also be referred to herein as a transaction or a request.","The hardware interface associated with the ACE may operate asynchronously. For example, a thread may send an ACB to the ACE and the thread may continue to execute other instructions. The thread may periodically monitor the status of the ACB. If a page fault occurs after the ACE initiates processing the transaction, the ACE may change the status field in the ACB to indicate that a page fault occurred. The ACE may return the ACB to a thread that sent the ACB to indicate to the thread that the transaction was not completed. At a later time, the thread may check the status flag. If the status flag indicates that the transaction is pending, the thread may continue to process other instructions or wait while periodically checking the status of the ACB. If the status flag indicates that unrecoverable errors occurred, the thread may initiate handling the errors and resend the ACB to the ACE. If the status flag indicates that a page fault occurred, the thread may initiate handling the page fault and resend the ACB to the ACE. If the status flag indicates that the transaction was successfully completed, the thread may process a result of the transaction.","Asynchronous operation is efficient, because the thread and the ACE may both execute in parallel, and may achieve higher performance as compared to a synchronous operation. Thus, when an asynchronous interface is used to access the ACE, page-faults may be returned as errors for the thread to handle rather than being treated as an exception condition. However, from the standpoint of the thread, a disadvantage of an asynchronous interface is that events such as page faults are not handled transparently. Instead, a programmer writing an application to access an ACE should include software instructions to handle various events, such as page faults.","However, writing applications that interact asynchronously with the ACE and that are capable of handling various events, such as a page fault, may be burdensome on programmers. In addition, existing applications may need to be rewritten to include page fault handling and to account for the asynchronous operation. Therefore, a synchronous interface may be provided that handles events, such as page faults, in a way that is transparent to a calling thread. Providing transparent handling of events, such as page faults, may enable more efficient application programming and may enable previously written applications to be modified with relatively small changes to access the ACE.","The following pseudo-code examples (\u201c\/\/\u201d indicates a comment) demonstrate the relative complexity of writing applications that can handle asynchronous operation as compared to synchronous operation:",{"@attributes":{"id":"p-0021","num":"0020"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"center"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Asynchronous:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["send_status = ACE_AsynchCall (pACB, ACB_size);","\/\/ pACB is pointer to ACB"]},{"entry":["if (send_status != OK) then <handle_error, exit>;","\/\/ ACB queue full etc."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<execute other instructions including other calls to the ACE>;"},{"entry":"while ((status = ACE_check (pACB)) == ACE_INPROGRESS)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<delay or execute other instructions>;","\/\/ still in progress"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ Assume execution of other instructions stops if the ACE_check (pACB) is not in progress"},{"entry":"if (status == ACE_PF) then"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<handle page fault, call Process_ACB>;","\/\/ handle PF and start over"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["if (status == ACE_ERROR) then <handle_error, exit>;","\/\/ wrong ACB format etc."]},{"entry":["if (status == ACE_DONE) then <continue>;","\/\/ call completed"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Synchronous:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["status = ACE_SynchCall (pACB, ACB_size);","\/\/ Call synchronous interface"]},{"entry":["if (status = ACE_ERROR) then <handle_error, exit>;","\/\/ wrong ACB format etc."]},{"entry":["<continue>;","\/\/ call completed"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"When handling events, such as page faults, a loop may be formed, resulting in a lack of forward progress. For example, when a page fault occurs, a page fault handler module may be called. When handling the page fault, the page fault handler module may cause another page fault, and the page fault handler may be called again, and so on. The synchronous interface may be written to detect and handle the lack of forward progress.","Thus, a resource in a processor (e.g., an ACE) may provide an asynchronous interface to applications. The asynchronous interface may result in applications that call the ACE to include instructions to handle various events, such as page faults, error conditions, and the like. To enable applications to avoid performing event handling, a synchronous software interface to the ACE may provide transparent handling of events, such as page faults and lack of forward progress.","Example Framework",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1","b":["100","100","102","102","104","106","108","110"],"sup":"th "},"Each of the N cores  to  may include one or more registers, one or more execution units, and one or more levels of cache memory. For example, the first core  may include a first set of registers , a first set of execution units , and a first level one (L1) cache . The Ncore  may include an Nset of registers , an Nset of execution units , and an NL1 cache . The N cores  to  may be logical cores or physical cores.","The ACE  may include registers, execution units, memory, and the like. For example, the ACE  may include one or more ACE registers , one or more ACE execution units , a local memory , a first order buffer , and additional order buffers up to and including an Norder buffer  (where N>1). The local memory  may include cache memory, random access memory, other types of computer-readable storage media, or any combination thereof. Each of the N order buffers  to  may correspond to the N cores  to . For example, the first order buffer  may correspond to the first core  and the Norder buffer  may correspond to the Ncore . Each of the N order buffers  to  may be used to keep track of in-flight transactions (e.g., transactions sent for execution to an ACE execution unit) to enable handling page faults and context switches. The ACE  may provide an ACE interface  to enable applications to access the ACE . In some implementations, the ACE interface  may operate asynchronously.","The content in each of the N order buffers  to  may include part of a process state and may be preserved across context switches. The N order buffers  to  may each be implemented as an array, such as a cyclical buffer that is an internal structure of the ACE . For example, the order buffer  may include a pointer (\u201cpACB\u201d) to an ace control block that includes information for a particular transaction.","Each of the N order buffers  to  may include information, such as a size of an ACB and a status field identifying a status of the transaction, such as, whether the transaction is a new transaction, whether the transaction is inside an execution pipe, whether the transaction is done, whether a page fault has occurred, or whether the transaction has been invalidated. Each of the N order buffers  to  may include one or more index registers, such as a first register (\u201chead\u201d) that indexes the first active transaction that is still in flight for a thread executing on a particular core, a second register (\u201ctail\u201d) that indexes a next to last active transaction of the thread, and a third register (\u201cnext\u201d) that indexes the next transaction to be sent for execution.","In operation, the first core  may execute a first thread  and the Ncore  may execute an Nthread . One of the threads  or  may send an ACB  to a synchronous software interface  for execution by the acceleration compute engine . For example, one of the threads  or  may send a pointer to the ACB , referred to as a pACB. The ACB  may include one or more instructions  for execution by the ACE . For example, the ACB  may include a header block that includes a status (e.g., new, inside execution pipe, done, page fault, invalid, and the like) associated with execution of the instructions . The ACB  may include an input parameter space identifier that identifies a location of input parameters to the ACE . The ACB  may include an output data space identifier that identifies a location to output the results of processing the input parameters and\/or the instructions . The ACB  may include an output error space identifier that identifies a location to output error-related data, such as error messages and data dumps (e.g., contents of registers, caches, pipelines, and the like). Of course, the ACB may include other content in addition to or instead of the previously described content. For example, the content of the ACB may vary depending on the particular function of the ACE that is being called.","In response to receiving a pointer to the ACB  from one of the threads  or , the synchronous software interface  may call the ACE interface  with the pointer to the ACB . In the call to the ACE interface , the synchronous software interface  may include parameters, such as a size of the ACB , in addition to the pointer to the ACB . The synchronous software interface  may wait for a predetermined period of time (e.g., ten milliseconds, one hundred milliseconds, and the like) before checking a status field of the ACB .","After checking the status field of the ACB , the synchronous software interface  may perform one or more actions in response to (e.g., based on) a status indicated by the status field. For example, if the status field indicates that a page fault occurred, the synchronous software interface  may handle the page fault by determining that the page fault was caused when the ACE  initiated access to a particular virtual address. The synchronous software interface  may cause a physical address space on a storage device (e.g., a disk drive) to be paged (e.g., loaded) into a main memory (e.g., random access memory). The physical address space may correspond to a virtual address space that includes the particular virtual address. The synchronous software interface  may handle the page fault by instructing an appropriate hardware or software entity, such as a memory controller or an operating system, to page in the physical address space corresponding to the virtual address space. The page fault handling may be implemented at an application-level (e.g., without direct access to system resources). For example, the page fault handler of the synchronous software interface  may generate a page fault to cause the operating system to fetch the physical address space by initiating access to the same virtual address that caused a page fault when the ACE initiated access. In some implementations, the page fault may be generated by the thread that sent the transaction to the ACE. After handling the page fault, the synchronous software interface  may restart processing of the ACB  by calling the ACE interface  and passing along a pointer to the ACB . If appropriate, the synchronous software interface  may also include additional parameters (e.g., ACB size and the like). When the status field of the ACB  indicates that the transaction was successfully completed, the synchronous software interface  may return the pointer to the ACB  to the thread that initiated the transaction.","The synchronous software interface  may keep track (e.g., using a counter or similar mechanism) a number of times that processing of a particular ACB, such as the ACB , has been restarted. If the number of times that execution of the particular ACB has been restarted satisfies a predetermined threshold, the synchronous software interface  may perform an action other than restarting processing of the ACB  after handling the page fault. For example, if the synchronous software interface  determines that processing of the ACB  by the ACE  has been restarted more than a predetermined number of times (e.g., three times), the synchronous software interface  may send the ACB  to a software emulator  corresponding to the ACE . The software emulator  may emulate, using software instructions, the functions of the ACE , and may be executed by one or more of the N threads  to . Though the software emulator  may take a longer time complete execution of a transaction, such as the ACB , as compared to the ACE , situations in which a lack of forward progress occurs are typically infrequent. When the status field of the ACB  indicates that the transaction was successfully completed, the synchronous software interface  may return the pointer to the ACB  to the thread that initiated the transaction.","If the status field of the ACB  indicates that the ACE  was unable to complete the transaction due to an event other than a page fault, or page fault exception that cannot be solved like access violation issue, the synchronous software interface  may indicate to one of the threads  to  (e.g., a particular thread that sent the pointer to the ACB ) that the transaction was not completed. In some cases, the Synchronous Software Interface  may provide additional information regarding the event by writing the additional information to an error output space identified in the ACB . For example, the synchronous software interface  may provide an intermediate result, contents of one or more of the ACE registers , at least some of the information from the associated order buffer, an error message, other information related to the status field of the ACB , or any combination thereof. The intermediate result may be used by the ACE  when recovering from an event, such as a page fault exception is possible. For example, if supported by an operating system, the intermediate result (e.g., page fault exception) may be passed to the operating system. After the operating system has performed one or more actions in response to receiving the intermediate result (e.g., page fault exception), the ACE may continue processing the transaction.","Example Pseudo Code to Implement a Synchronous Software Interface","An example of pseudo code to implement a software layer to provide a synchronous software interface that provides transparent handling of page faults and detects and handles lack of forward progress is provided below. Names starting w\/ \u201ch\u201d (e.g., \u201chNNNN\u201d) refer to entities that the hardware supports directly.","ACE_SCall may be called by a thread to access the ACE . ACE_SCall operates synchronously in that ACE_SCall returns after the ACB  has been processed. The thread that called ACE_SCall may wait until the call to ACE_SCall completes. The ACE_SCall calls ACE_ACall (e.g., the asynchronous ACE interface ). pACB is a pointer to the ACB . Delay-for-a-while is a module that delays for a predetermined amount of time. Status is a module that checks a status field of the ACB .",{"@attributes":{"id":"p-0036","num":"0035"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"status =","ACE_SCall(pACB){"]},{"entry":[{},{},"ACE_ACall(pACB);"]},{"entry":[{},{},"delay-for-a-while;"]},{"entry":[{},{},"return ACE_Check_Wait(pACB);}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"ACE_ACall is the asynchronous ACE interface . ACE_ACall may be an interface provided by the ACE  to call hACE_Call (e.g., a call to the ACE hardware). ACE_ACall(pACB){hACE_Call(pACB); return;}","ACE_Check_Wait returns when the ACE  successfully completes the transaction, including any restarts caused by page faults. ACE_Check_Wait performs both the page fault handling and waiting (e.g., delay) for completion so that the page fault handling and waiting for completion are transparent to the threads. ACE_InProgress is one of the possible statuses that can be indicated by the status field. ACE_InProgress indicates that the ACE  is processing the transaction (e.g., the ACB ).",{"@attributes":{"id":"p-0039","num":"0038"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"status =","ACE_Check_Wait(pACB)){"]},{"entry":[{},{},"while ((status=ACE_Check(pACB)) == ACE_InProgress)"]},{"entry":[{},{},"delay-for-a-while;}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"ACE_Check returns when the ACE hardware completes the transaction (e.g., the ACB ) and after handling any page faults that may have occurred during processing of the transaction. \u201c!=\u201d means \u201cnot equal.\u201d",{"@attributes":{"id":"p-0041","num":"0040"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["status =","ACE_Check(pACB){",{}]},{"entry":[{},"hStatus = pACB -> status;"]},{"entry":[{},"If (hStatus != ACE_PF) return hStatus;","\/\/ not a page fault -"]},{"entry":[{},{},"return hStatus"]},{"entry":[{},"touch(faulting addresses);","\/\/ handle page fault"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ e.g., operating system may handle the page fault"]},{"entry":[{},"hACE_Call(pACB);"]},{"entry":[{},"return ACE_InProgress;}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Thus, the synchronous software interface  may provide synchronous operation and transparent handling of events (e.g., page faults, lack of forward progress, and the like) to threads executing on the N cores  to . The synchronous software interface  may enable application programmers to write smaller and simpler software applications that can take advantage of the functions of the ACE  because the software applications may be written without including event handling modules. The ease of writing applications that call the ACE  to perform specialized functions may result in more applications that use the ACE  being written.",{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 2","FIG. 1"],"b":["200","200","150"]},"At , a pointer to a control block is received from a thread. The control block includes one or more instructions for execution by an accelerated computer engine. For example, in , the synchronous software interface  may receive the ACB  from one of the N threads  to .","At , the pointer to the control block is sent to the accelerated compute engine. For example, in , the synchronous interface  may call a lower-level asynchronous interface, such as the ACE interface , and include a pointer to the ACB .","At , the synchronous software interface waits for a confirmation from the accelerated compute engine that the instructions were successfully executed. For example, in , the synchronous software interface  may repeatedly (e.g., in a loop) perform a wait (e.g., delay) for a particular period of time and check a status field of the ACB . Based on the status field, the synchronous software interface  may perform one or more actions. The one or more actions may include repeatedly performing the wait and checking the status field of the ACB . For example, the synchronous software interface  may repeatedly wait and check the status field while the status field indicates that the ACE  is processing the ACB . The synchronous software interface  may confirm that the instructions  were successfully completed when the status field of the ACB  indicates that the ACB  was successfully processed.","At , while waiting to receive the confirmation from the ACE that the instructions were successfully completed, a determination may be made that a page fault occurred. For example, in , after checking the status field of the ACB , the synchronous software interface  may determine that a page fault occurred based on the status field.","At , in response to determining that the page fault occurred, handling the page fault. For example, in , in response to determining that the status field of the ACB  indicates that a page fault occurred, the synchronous software interface  may handle the page fault using a lower-level software module (e.g., device driver, operating system utility, and the like).","At , the pointer to the control block may be re-sent to the accelerated compute engine to restart execution of the instructions. The control block may be re-sent to the ACE after the exception handler successfully handles the exception. The control block may be re-sent to enable the accelerated compute engine to identify situations where there is a lack of forward progress. For example, in , after handling the page fault, the synchronous software interface  may call the ACE interface  and include the pointer to the ACB  as one of the parameters in the call.","At , a confirmation is received from the accelerated compute engine that the instructions were successfully executed. For example, in , the synchronous software interface  may confirm that the ACE  successfully completed execution of the instructions  based on the status field of the ACB .","At , a result of the accelerated compute engine successfully executing the instructions may be sent to the thread. For example, in , when the status field of the ACB  indicates that the ACE successfully executed the instructions , the synchronous software interface  may return the pointer to the ACB  to the particular thread that initially sent the pointer to the synchronous software interface .","Thus, a synchronous software interface may receive a pointer to an ACB from a thread and call a lower-level asynchronous interface to an ACE. The call to the lower-level asynchronous interface may include the pointer to the ACB and other parameters used by the asynchronous interface. The asynchronous interface may provide the pointer to the ACB to the ACE. The synchronous software interface may handle events, such as page faults and lack of forward progress and return a result of the ACE executing the ACB to the thread. Thus, the synchronous software interface may provide a synchronous operation and transparent handling of events to multiple threads executing on multiple cores in a processor.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 3","FIG. 1"],"b":["300","150"]},"At , instructions are received from a thread executing on a core of a processor. For example, in , the synchronous software interface  may receive the ACB  including the one or more instructions  from one of the N threads  to .","At , the instructions are sent to an accelerated compute engine for execution. For example, in , the synchronous interface  may call a lower-level asynchronous interface, such as the ACE interface , and include a pointer to the ACB .","At , the synchronous software interface may detect whether a page fault occurred during execution of the instructions. For example, in , after checking the status field of the ACB , the synchronous software interface  may determine (e.g., based on the status field of the ACB ) that a page fault occurred. For example, if the ACE  encounters a page fault after initiating execution of the instructions , the ACE may set the status field of the ACB  to indicate that a page fault occurred and return the pointer (to the ACB ) to the synchronous software interface  to enable the synchronous software interface  to handle the page fault.","At , in response to determining that the page fault occurred, handling the page fault. For example, in , in response to determining that the status field of the ACB  indicates that a page fault occurred, the synchronous software interface  may handle the page fault using a lower-level hardware unit (e.g., memory controller) or a lower-level software module (e.g., device driver, operating system utility, and the like).","At , the accelerated compute engine may be instructed to restart execution of the instructions. For example, in , after handling the page fault, the synchronous software interface  may call the ACE interface  with the pointer to the ACB  to restart the execution of the instructions . The control block may be re-sent to the ACE after the exception handler successfully handles the exception. The control block may be re-sent to enable the accelerated compute engine to count how many times a particular control block has been resent, to enable the accelerated compute engine to identify situations where there is a lack of forward progress.","At , a determination is made whether a number of times that execution of the instructions has been restarted satisfy a predetermined threshold. For example, in , the synchronous software interface  may keep track (e.g., via a counter) as to a number of times a particular set of instructions (e.g., the instructions ) have been restarted (e.g., repeatedly sent to the ACE ).","If a determination is made that a number of times that execution of the instructions has been restarted satisfy a predetermined threshold, at , a software emulator may be instructed to execute the instructions, at . For example, in , the synchronous software interface  may sent the pointer to the ACB  to the software emulator  and instruct the software emulator  to execute the instructions .","At , a result of executing the instructions may be received. For example, in , either the ACE  or the software emulator  may complete execution of the instructions  and set the status field of the ACB  to indicate that the instructions  were successfully executed.","At , the results of executing the instructions may be sent to the thread. For example, in , the synchronous software interface  may, based on the status field of the ACB , indicate to one of the N thread  to  that the instructions  were successfully executed.","Thus, a synchronous software interface may receive a pointer to an ACB that includes instructions from a thread. The synchronous software interface may call an asynchronous interface with the pointer to the ACB and any other parameters used by the asynchronous interface. The asynchronous interface may provide the pointer to the ACB to the ACE to enable the ACE to initiate execution of the instructions. The synchronous software interface may handle events, such as page faults and lack of forward progress, transparently from the standpoint of the thread.",{"@attributes":{"id":"p-0064","num":"0063"},"figref":["FIG. 4","FIG. 1"],"b":["400","150"]},"At , a control block including one or more instructions is received by an application programming interface (API) associated with an accelerated compute engine. For example, in , an API of the ACE  may include the synchronous software interface . The synchronous software interface  may receive a pointer to the ACB  from one of the N threads  to .","At , the control block is sent to the accelerated compute engine for execution of the one or more instructions. For example, in , the synchronous interface  may call a lower-level asynchronous interface, such as the ACE interface , and include a pointer to the ACB . The ACE interface  may send the pointer to the ACB  to the ACE  to enable the ACE  initiate execution of the instructions .","At , the synchronous software interface may detect that a page fault occurred. For example, in , the synchronous software interface  may detect (e.g., based on a status field of the ACB ) that the ACE  encountered a page fault after initiating execution of the instructions .","At , in response to determining that the page fault occurred, the page fault is handled and the accelerated compute engine is instructed to restart execution of the instructions. For example, in , in response to determining that the status field of the ACB  indicates that a page fault occurred, the synchronous software interface  may handle the page fault using a lower-level hardware unit (e.g., memory controller) or a lower-level software module (e.g., device driver, operating system utility, and the like). The control block may be re-sent to the ACE after the exception handler successfully handles the exception. The control block may be re-sent to enable the accelerated compute engine to identify situations where there is a lack of forward progress. After handling the page fault, the synchronous software interface  may instruct the ACE  to restart execution of the transaction by calling the ACE interface  and include the pointer to the ACB  as one of the parameters in the call.","At , a result of executing the one or more instructions is received. For example, in , the status field of the ACB  may indicate that the ACE successfully completed executing the instructions . The result may be included in an output address space that is pointed to by a pointer in the ACB . The synchronous software interface  may return the pointer to the ACB  to the particular thread that initially sent the pointer to the synchronous software interface .","System Including Synchronous Software Interface",{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 5","b":["500","500","502"]},"The device  may include one or more processors, such as a processor , a clock generator , a memory  (e.g., random access memory), an input\/output control hub , and a power source  (e.g., a battery or a power supply). The processor  may include multiple cores, such as the first core  and one or more additional cores, up to and including an Ncore , where N is greater than 1. The processor  may include a memory controller  to enable access (e.g., reading from or writing) to the memory .","In addition, the processor  may include the ACE , the ACE interface , the synchronous software interface , and the N order buffers  to . In some implementations, the processor  may include more than one ACE. For example, as illustrated in , the processor  may include M number of ACE units (where M is greater than or equal to one), such as up to and including the MACE . Each of the M ACE units  to  may be accessible to the N cores  to . For example, some of the N cores  to  may simultaneously send transactions to one or more of the M ACE units  to . To illustrate, the Ncore  may send two or more transactions substantially simultaneously to one or more different ACE units. The one or more ACE units may process each of the transactions and send the results back to the cores that sent the transactions. At the same time that the Nth core  sends the two or more tracks action, other cores may simultaneously send transactions to other ACE units in the processor . In some implementations, each of the M ACE units  to  may have a corresponding synchronous software interface while in other implementations multiple (e.g., at least some and possible all) ACE units may use the same synchronous software interface.","Multiple threads may execute on the N cores  to . For example, the first core  may execute the first thread  and the Ncore  may execute the Nthread . The M ACE units  to  may perform specialized functions, such as graphics-related functions, for the N threads  to . The threads  or  may send transactions that include control blocks, such as the ACB , to instruct the ACE  to perform various functions. The ACB  may include the instructions  and a status field  that indicates a status of the ACB . For example, the status field  may indicate whether the transaction is a new transaction, whether the transaction is inside an ACE execution pipeline, whether the transaction include intermediate results, whether the transaction is done, whether a page fault has occurred, whether the transaction has been invalidated, or another status of the ACB . To enable fine-grained control over the operation of the M ACE units  to , the threads may enable the M ACE units  to  to directly access (e.g., read from and write to) the address space associated with each thread. The clock generator  may generate one or more clock signals that are the basis for an operating frequency of one or more of the N cores  and  or the ACE units of the processor . For example, one or more of the N cores  and  may operate at a multiple of one of the clock signals generated by the clock generator . The architecture depicted in  may use a single clock generator or multiple clock generators.","In , the synchronous software interface  is shown as being located in the processor . However, in some implementations, the synchronous software interface  may be located in another location, such as the memory .","The input\/output control hub  may be coupled to a mass storage . The mass storage  may include one or more non-volatile storage devices, such as disk drives, solid state drives, and the like. An operating system  may be stored in the mass storage .","The input\/output control hub  may be coupled to a network port . The network port  may enable the device  to communicate with other devices via a network . The network  may include multiple networks, such as wireline networks (e.g., public switched telephone network and the like), wireless networks (e.g., 802.11, code division multiple access (CDMA), global system for mobile (GSM), Long term Evolution (LTE) and the like), other types of communication networks, or any combination thereof. The input\/output control hub may be coupled to a display device  that is capable of display text, graphics, and the like.","As described herein, the processor  may include multiple computing units or multiple cores. The processor  can be implemented as one or more microprocessors, microcomputers, microcontrollers, digital signal processors, central processing units, state machines, logic circuitries, and\/or any devices that manipulate signals based on operational instructions. Among other capabilities, the processor  can be configured to fetch and execute computer-readable instructions stored in the memory , the mass storage , or other computer-readable media.","The memory  is an example of computer storage media for storing instructions which are executed by the processor  to perform the various functions described above. The memory  may generally include both volatile memory and non-volatile memory (e.g., RAM, ROM, or the like). The memory  may be referred to as memory or computer storage media herein, and may be a non-transitory media capable of storing computer-readable, processor-executable program instructions as computer program code that can be executed by the processor  as a particular machine configured for carrying out the operations and functions described in the implementations herein. The processor  may include components for enabling a resource, such as the ACE , to be efficiently accessed by multiple threads executing on multiple cores according to the implementations herein.","The example systems and computing devices described herein are merely examples suitable for some implementations and are not intended to suggest any limitation as to the scope of use or functionality of the environments, architectures and frameworks that can implement the processes, components and features described herein. Thus, implementations herein are operational with numerous environments or architectures, and may be implemented in general purpose and special-purpose computing systems, or other devices having processing capability. Generally, any of the functions described with reference to the figures can be implemented using software, hardware (e.g., fixed logic circuitry) or a combination of these implementations. The term \u201cmodule,\u201d \u201cmechanism\u201d or \u201ccomponent\u201d as used herein generally represents software, hardware, or a combination of software and hardware that can be configured to implement prescribed functions. For instance, in the case of a software implementation, the term \u201cmodule,\u201d \u201cmechanism\u201d or \u201ccomponent\u201d can represent program code (and\/or declarative-type instructions) that performs specified tasks or operations when executed on a processing device or devices (e.g., CPUs or processors). The program code can be stored in one or more computer-readable memory devices or other computer storage devices. Thus, the processes, components and modules described herein may be implemented by a computer program product.","Furthermore, this disclosure provides various example implementations, as described and as illustrated in the drawings. However, this disclosure is not limited to the implementations described and illustrated herein, but can extend to other implementations, as would be known or as would become known to those skilled in the art. Reference in the specification to \u201cone implementation,\u201d \u201cthis implementation,\u201d \u201cthese implementations\u201d or \u201csome implementations\u201d means that a particular feature, structure, or characteristic described is included in at least one implementation, and the appearances of these phrases in various places in the specification are not necessarily all referring to the same implementation.","Conclusion","Although the subject matter has been described in language specific to structural features and\/or methodological acts, the subject matter defined in the appended claims is not limited to the specific features or acts described above. Rather, the specific features and acts described above are disclosed as example forms of implementing the claims. This disclosure is intended to cover any and all adaptations or variations of the disclosed implementations, and the following claims should not be construed to be limited to the specific implementations disclosed in the specification. Instead, the scope of this document is to be determined entirely by the following claims, along with the full range of equivalents to which such claims are entitled."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The detailed description is set forth with reference to the accompanying drawing figures. In the figures, the left-most digit(s) of a reference number identifies the figure in which the reference number first appears. The use of the same reference numbers in different figures indicates similar or identical items or features.",{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
