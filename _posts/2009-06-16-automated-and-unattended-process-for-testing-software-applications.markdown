---
title: Automated and unattended process for testing software applications
abstract: In one embodiment, a mechanism for business process-managed testing of software applications is disclosed. In one embodiment, a method for business process-managed testing of software applications includes identifying, by a server computing device, all tools and services used to test a software application deployed on the server computing device, and determining, by the server computing device, an order of execution of the identified tools and services in testing the software application. The method further includes designing, by a business process management (BPM) service of the server computing device, a testing management process that integrates the identified tools and services in the determined order of execution for testing the software application in an automated and unattended manner, and deploying, by the server computing device, the testing management process to act as a controlling layer over the identified tools and services in the testing of the software application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08739125&OS=08739125&RS=08739125
owner: Red Hat, Inc.
number: 08739125
owner_city: Raleigh
owner_country: US
publication_date: 20090616
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","DETAILED DESCRIPTION"],"p":["The embodiments of the invention relate generally to application testing and, more specifically, relate to a mechanism for automated and unattended process for testing software applications.","In software development, a test suite is a collection of test cases that are intended to be used to test a software program to show that it has some specified set of behaviors. A test suite often contains detailed instructions or goals for each collection of test cases and information on the system configuration to be used during testing.","Presently, there are many tools that allow application testing to be run on remotes stations in an automated manner. For example, continuous integration (CI) tools allow for the frequent integration of multiple software developers' work to a single application\u2014typically multiple integrations per day. Each integration of the software developers' work is verified by the CI tools, including testing, to detect integration errors as quickly as possible. However, existing application testing suite tools, such as CI tools, are not completely integrated in the respect that excessive human interaction is usually required for attending to the automated tests. For example, human interaction for failure investigation and problem solving is often times needed.","In addition, no tools exist for the automated and unattended management of application testing suites. Such automated and unattended management of application testing suites would include oversight of test suite execution, resource management, error recovery, and test results submission into external tracking systems, for example. Presently, each of these functions of test suite execution, resource management, error recover, and test result submission into external tracking systems is controlled by separate systems and requires significant human interaction to integrate the functions together. As such, a tool for automated and unattended management of application testing suites would be beneficial.","Embodiments of the invention provide for a mechanism for automated and unattended process for testing software applications. In one embodiment, a method of automated and unattended testing of software applications includes identifying, by a server computing device, all tools and services used to test a software application deployed on the server computing device, and determining, by the server computing device, an order of execution of the identified tools and services in testing the software application. The method further includes designing, by a business process management (BPM) service of the server computing device, a testing management process that integrates the identified tools and services in the determined order of execution for testing the software application in an automated and unattended manner, and deploying, by the server computing device, the testing management process to act as a controlling layer over the identified tools and services in the testing of the software application.","In the following description, numerous details are set forth. It will be apparent, however, to one skilled in the art, that the present invention may be practiced without these specific details. In some instances, well-known structures and devices are shown in block diagram form, rather than in detail, in order to avoid obscuring the present invention.","Some portions of the detailed descriptions which follow are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here, and generally, conceived to be a self-consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually, though not necessarily, these quantities take the form of electrical or magnetic signals capable of being stored, transferred, combined, compared, and otherwise manipulated. It has proven convenient at times, principally for reasons of common usage, to refer to these signals as bits, values, elements, symbols, characters, terms, numbers, or the like.","It should be borne in mind, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise, as apparent from the following discussion, it is appreciated that throughout the description, discussions utilizing terms such as \u201csending\u201d, \u201creceiving\u201d, \u201cattaching\u201d, \u201cforwarding\u201d, \u201ccaching\u201d, or the like, refer to the action and processes of a computer system, or similar electronic computing device, that manipulates and transforms data represented as physical (electronic) quantities within the computer system's registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage, transmission or display devices.","The present invention also relates to an apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes, or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium, such as, but not limited to, any type of disk including floppy disks, optical disks, CD-ROMs, and magnetic-optical disks, read-only memories (ROMs), random access memories (RAMs), EPROMs, EEPROMs, magnetic or optical cards, or any type of media suitable for storing electronic instructions, each coupled to a computer system bus.","The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein, or it may prove convenient to construct more specialized apparatus to perform the required method steps. The required structure for a variety of these systems will appear as set forth in the description below. In addition, the present invention is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the invention as described herein.","The present invention may be provided as a computer program product, or software, that may include a machine-readable medium having stored thereon instructions, which may be used to program a computer system (or other electronic devices) to perform a process according to the present invention. A machine-readable medium includes any mechanism for storing or transmitting information in a form readable by a machine (e.g., a computer). For example, a machine-readable (e.g., computer-readable) medium includes a machine (e.g., a computer) readable storage medium (e.g., read only memory (\u201cROM\u201d), random access memory (\u201cRAM\u201d), magnetic disk storage media, optical storage media, flash memory devices, etc.), a machine (e.g., computer) readable transmission medium (non-propagating electrical, optical, or acoustical signals), etc.","Embodiments of the invention provide a mechanism for implementing an automated and unattended process for testing software applications. Embodiments of the invention enable managed automated execution of test suites, result reporting, and a mechanism for automated error recovery, including optional human input. Using the process of embodiments of the invention, which is flexible to modify and extend, users are able to test any application they choose to in an automated and unattended fashion. Furthermore, embodiments of the invention reduce the time needed to attend to automated tests by fixing any failure problems of the testing suite automatically and running the test again without any human interaction.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1","b":["100","100","105","105","110","110","105","120","110"]},"In addition to deployment layer , various other components can also be plugged into MC , including, but not limited to, a Web service , a naming service , a messaging service , and a business process management (BPM) service . All of the plug-in components interact with MC . Although shown as part of application server , MC  may be used standalone outside of application server  and can be plugged into any server environment.","In some embodiments, application server  uses a BPM service  to provide a programmatic structure for designing transactions and executing them using automated decisions, tasks, and sequence flows. In one embodiment, BPM service  provides graphical user interface (GUI) tools to enhance any applications that are run on application server .","In one embodiment, BPM service  is utilized to define a testing management process for a complete test of an application deployed on application server . In one embodiment, testing management process is deployed as testing management module  on application server . In some embodiments, the testing management module  may be deployed on a server (not shown) separate from the application server  hosting the application to be tested.","The testing management process  of embodiments of the invention encompasses many different tasks associated with the testing of applications, including test suite execution, resource management, error recovery, and test results submission into an external tracking system, to name a few examples. The testing management process  is a controlling layer overseeing all of these tasks and ensuring that they run in a specific order. The testing management process  provides to each task any specific instructions, parameters, and resources required by the task in an automated and unattended manner.","In one embodiment, using the tools provided by BPM server , the testing management process  of embodiments of the invention may be defined, designed, and deployed by someone having little technical understanding of problems involved. For example, the GUI tools of BPM service  allow the development of the testing management process  to be presented in an abstract manner to the developer of the testing management process  of embodiments of the invention.","In one embodiment, the testing management process  defined by BPM service  acts as a controlling layer integrating a variety of tools and services used for the overall testing process of an application of application server . Such tools and service may include continuous integration (CI) tools, test reporting tools, graphical designing tools, and resource management tools. Programming code already exists in system  that controls the CI tools, that knows how to report results to a test management\/result tool, that controls the graphical designing tools, and that controls resource management\/allocation. However, this programming code for each of these tools and services is not inter-related and each tool and service operates as a separate entity and process in system .","Embodiments of the invention utilize the tools of BPM service  to automatically create the testing management process  in a manner that defines the order of execution of the programming code of the various tools and services used for testing applications. As a result, these processes are integrated into a single controlling testing management process . The testing management process  provides a set of rules for the various tools and services that dictates what happens and when it happens during the process. The process of embodiments of the invention provides the individual jobs performed by the tools and services for testing applications with various instructions, parameters, and resources defining the execution environment for these jobs.","For instance, in one embodiment, the testing management process  may control a continuous integration (CI) tool  used for testing of the applications deployed in deployment layer  of application server . In one embodiment, the CI tool  is a Hudson\u2122 CI tool. The testing management process  may also control a test reporting tool . The test reporting tool  may be Testopia\u2122. In one embodiment, the CI tool  and test reporting tool  may be located on another server computing device , which may be attached to application server  via a network  or via a direct connection . The testing management process  passes instructions, parameters, and resources for the CI tool  and the test reporting tool  in such a manner that will automate the operation of CI tool  and test reporting tool  so that human interaction will not be required to integrate these tools ,  at run-time.","In one embodiment, BPM service  implements the testing management process  using JAVA Business Process Management (jBPM) tools or JBoss\u2122 Rules. The process can be designed and overlooked visually by the tools that are provided in the JBoss\u2122 Developer Studio (JBDS). In one embodiment, JBDS may be used as a set of plug-ins to a popular Integrated Development Environment called Eclipse\u2122. Using Eclipse\u2122 with embodiments of the invention, the testing management process  can be put designed, deployed (upload to application server ), executed, and managed. However, some embodiments of the invention may utilize any other sort of visualization tool to create the automated and unattended process for testing applications.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 2","FIG. 1","FIG. 1"],"b":["200","200","200","200","105"]},"Method  begins at block  where all tools and services used to test a software application are identified. In one embodiment, these tools and service may include continuous integration (CI) tools, test reporting tools, graphical designing tools, and resource management tools. In one embodiment, a configuration file may exist that specifies which tools and services to use and the server to find them on. If such a configuration file does not exist or the feature of configuration is not even implemented, embodiments of the invention may have the given tools and services hard-coded. The identification of the actual tools and services used depends on the particular business needs of the end user utilizing embodiments of the invention. This end user may pick the tools and services most suited for their needs after conducted research on the market of software application testing tools.","Then, at block , an order of execution of the identified tools and services to perform the test on the software application is determined. In some embodiments, the order of execution is determined by the pre-existing process that is in place in the environment and utilized by the identified tools and services. This pre-existing process may have been previously analyzed and converted to machine-readable form to be specified by the business process. In some embodiments, the order of execution may be designed so that job A must precede job B or that jobs C and D must not run in parallel. In such a case, embodiments of the invention ensure that these preconditions are fulfilled. However, in other embodiments, such preconditions are not defined and every job may be executed and run in parallel.","Subsequently, at block , tools of a BPM service are utilized to design a controlling testing management process to integrate the identified tools and services in the determined order of execution. In one embodiment, the BPM service uses its tools to automatically create the testing management process in a manner that defines the order of execution of the programming code of the various tools and services used for testing applications. The testing management process provides a set of rules for the various tools and services that dictates what happens and when it happens during the process. The process of embodiments of the invention provides the individual jobs performed by the tools and services for testing applications with various instructions, parameters, and resources defining the execution environment for these jobs. As a result, the integrated tools and service can be used together for testing the application in an automated and unattended manner.","Lastly, at block , the testing management process designed in block  is deployed on an application server for use in testing the application. Once deployed, the testing management process operates as a controlling layer over the identified tools and services to perform the testing on the application without requiring human interaction.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 3","FIG. 1"],"b":["300","300","300","165","105"]},"Method  provides an automated and unattended process built via BPM rules to handle dependencies between children processes associated with software application testing. This automated and unattended process is capable of executing some of its child processes before or after other child processes. In one embodiment, the process provided by method  can even execute many of the child processes that are not inter-dependent in parallel, resulting in lessened overall time to test the software application.","Method  begins at block  where a new build of a software application product is provided. The particular application build is a compiled product prepared for release and may also be known as a release candidate. In one embodiment, the build has to be accepted for testing before it can actually have the tests run on it. The accept\/reject sub-process is performed at block . In one embodiment, an internal automated Build Acceptance Smoke Test Launcher (BASTL) tool is used to perform the accept\/reject process of block .","If the accept\/rejection subprocess results in a rejection of the provided application build, a report is sent at block  indicating the reasons for the rejection. In one embodiment, the rejection result may be reported via email or via any reporting tool using an application programming interface (API). If the application build is rejected at block , method  ends at this point because any issues with the application build should be fixed and a new build created for testing.","If the application build is accepted for testing at block , a differences sub-process is performed at block . The differences subprocess finds any differences between the present application build and any previous application builds to determine if there are any unexpected changes between the builds. If unexpected changes are discovered, the application build is rejected and a result report sent out at block .","If no unexpected changes are found at block , then the testing of the application build itself may begin. The application build is provided to testing tools, such as a CI tool, to perform the actual testing. As part of the application build, samples of the application are provided that show individual features of the application product and how to use those feature. These samples, sometimes known as \u201cquickstarts\u201d (QS), typically are provided by developers and come bundled with the product that is being tested.","The samples can be used quickly by the testing tools as a skeleton to emulate the real production-based application. In some embodiments, the samples are converted to tests. In other embodiments, the samples may be created on-the-fly for features that the developers have not written any samples for yet.","Embodiments of the invention test the application build against several platforms (e.g., Linux, Windows, Solaris, HP-UX), databases (e.g., Oracle, PostgreSQL, MySQL, MSSQL, etc.), JAVA Development Kits (JDKs), and processor architectures. In one embodiment, the platforms which the application build is tested against are chosen first. Then, for each platform, criteria (e.g., DBs, JDKs) are configured for the selected platform. As a result, several configurations of the application build for testing are created.","Embodiments of the invention perform testing of each configuration via three test groups. These test groups are integration tests, regression tests, and performance tests. The first group of tests is the regression tests at block . Regressions tests are created from the provided application samples (at least one for every sample). In some embodiments, the testing for bugs in the application may also be part of the regression group tests.","The second group of tests to be run is the integration tests at block . This group of tests provides for testing the integration of other projects related to the application into the present application product. In one embodiment, other such projects may include the integration of web services with a particular application, the integration of a rules engine with the application, or the integration of BPM tools with the application. These are some examples of projects that may be integrated with an application, and embodiments of the invention also envision a variety of other possible projects that can be tested for integration into an application.","The third group of tests to be run is the performance tests at block . The performance tests are used to measure performance of individual product features of the provided application build. In one embodiment, performance tests are also used to compare the present version of the software with a previous version. When all the test groups from blocks  through  are finished and have passed, the application build is passed and is ready for release at block .",{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 4","FIG. 3","FIG. 1"],"b":["400","400","400","340","350","360","400","165","105"]},"In one embodiment, method  may be performing any one of the following tests: a smoke test for accepting\/rejecting a new build; a test to detect differences between a new and previous application build; integration tests to test for integration of other projects into the present application product build being tested (such as web services or jBPM); regression tests to test individual features of product (where the test is created from a sample of application build) for function; bug fix tests for fixing bugs; and performance tests to measure performance of a variety of application product features. However embodiments of the invention are not limited to the above examples and may include any kind of automated test that can be performed on a software application build.","Method  begins at block  where resources needed for the test are allocated. In one embodiment, the resources include database accounts, test machines, data storage, memory, other required machines for testing, and so on. In one embodiment, allocating these resources includes connecting to them and ensuring they are ready to execute. The needed resources are repeatedly allocated at block . If the resources are available, then the process continues. If the resources are not available, then method  automatically waits a predetermined period of time and tries again without requiring any human intervention. This cycle repeats until the resources are available and allocated for the test.","At block , parameters, such as information identifying the allocated resources from block , are then passed to an execution subprocess that handles all the interaction with the testing tool, such as a CI tool. The subprocess contacts the testing tool and tells it which test(s) need to be run using the parameters the testing tool is given. Then, at block , after the test is run by the testing tool, all of the allocated resources are de-allocated and released for use by other tests. In one embodiment, this includes disconnecting from a database resource, and so on.","At this point, a test result is available from running the test in blocks  through . In one embodiment, the test results may include failure, success, or unstable. This test result is forwarded for resolution at block . If, at block , it is determined that the test result indicates failure, the process  is automatically restarted. In one embodiment, a failure test result may indicate a hardware problem or that the test has been stopped, for example. On the other hand, if the result indicates success at block , it is forwarded to reporting at block .","Otherwise, if the test result is unstable at block , then control is forwarded to a human at block . A test result of unstable indicates that the test finished but with some minor issues, such as in the case of application builds that are aborted or contain small problems. The human interaction at block  decides whether to restart the process  or forward the test result to reporting as if it was a successful test. Human intelligence is needed at this point to ascertain whether the failure of the test was an expected or unexpected failure. If the test ran as expected and resulted in the failure, then the test does not need to be run again and the results can be reported at block . However, if the test did not run as expected and resulted in the failure, then a human may determine that the test should be run again.","Lastly, at block , a result report subprocess interacts with various external systems and reports the results of the test. In one embodiment, result reporting includes aggregating all test results into a test report and sending the report to a test management suite. In one embodiment, the test management suite may be Testopia\u2122 or any other reporting tool. The result report subprocess may also send out other kinds of electronic notifications, such as e-mail. In addition, the result report subprocess may also provide an interface to review test results. This may be useful for a person to analyze testing progress and state of the tested application build. In one embodiment, the interface may be provided as a Web-based tool.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 5","b":"500"},"The exemplary computer system  includes a processing device , a main memory  (e.g., read-only memory (ROM), flash memory, dynamic random access memory (DRAM) (such as synchronous DRAM (SDRAM) or Rambus DRAM (RDRAM), etc.), a static memory  (e.g., flash memory, static random access memory (SRAM), etc.), and a data storage device , which communicate with each other via a bus .","Processing device  represents one or more general-purpose processing devices such as a microprocessor, central processing unit, or the like. More particularly, the processing device may be complex instruction set computing (CISC) microprocessor, reduced instruction set computer (RISC) microprocessor, very long instruction word (VLIW) microprocessor, or processor implementing other instruction sets, or processors implementing a combination of instruction sets. Processing device  may also be one or more special-purpose processing devices such as an application specific integrated circuit (ASIC), a field programmable gate array (FPGA), a digital signal processor (DSP), network processor, or the like. The processing device  is configured to execute the processing logic  for performing the operations and steps discussed herein.","The computer system  may further include a network interface device . The computer system  also may include a video display unit  (e.g., a liquid crystal display (LCD) or a cathode ray tube (CRT)), an alphanumeric input device  (e.g., a keyboard), a cursor control device  (e.g., a mouse), and a signal generation device  (e.g., a speaker).","The data storage device  may include a machine-accessible storage medium  on which is stored one or more set of instructions (e.g., software ) embodying any one or more of the methodologies of functions described herein. The software  may also reside, completely or at least partially, within the main memory  and\/or within the processing device  during execution thereof by the computer system ; the main memory  and the processing device  also constituting machine-accessible storage media. The software  may further be transmitted or received over a network  via the network interface device .","The machine-readable storage medium  may also be used to stored instructions to perform method  to provide an automated and unattended process for testing software applications as described with respect to , and\/or a software library containing methods that call the above applications. While the machine-accessible storage medium  is shown in an exemplary embodiment to be a single medium, the term \u201cmachine-accessible storage medium\u201d should be taken to include a single medium or multiple media (e.g., a centralized or distributed database, and\/or associated caches and servers) that store the one or more sets of instructions. The term \u201cmachine-accessible storage medium\u201d shall also be taken to include any medium that is capable of storing, encoding or carrying a set of instruction for execution by the machine and that cause the machine to perform any one or more of the methodologies of the present invention. The term \u201cmachine-accessible storage medium\u201d shall accordingly be taken to include, but not be limited to, solid-state memories, and optical and magnetic media.","Whereas many alterations and modifications of the present invention will no doubt become apparent to a person of ordinary skill in the art after having read the foregoing description, it is to be understood that any particular embodiment shown and described by way of illustration is in no way intended to be considered limiting. Therefore, references to details of various embodiments are not intended to limit the scope of the claims, which in themselves recite only those features regarded as the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The invention will be understood more fully from the detailed description given below and from the accompanying drawings of various embodiments of the invention. The drawings, however, should not be taken to limit the invention to the specific embodiments, but are for explanation and understanding only.",{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
