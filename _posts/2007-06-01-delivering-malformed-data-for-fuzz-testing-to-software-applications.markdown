---
title: Delivering malformed data for fuzz testing to software applications
abstract: Systems and methods to deliver malformed data for software application fuzzing are described. In one aspect, a fuzzing engine receives well-formed valid input data from a test automation tool. The received data is for input into a software application to implement a functional test. Responsive to receiving the well-formed valid input data, the fuzzing engine automatically generates corresponding malformed data based on characteristics of the well-formed valid input data. The application is then automatically fuzzed with the malformed data to notify an end-user of any security vulnerabilities in one or more code paths of the application used to process the malformed data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08336102&OS=08336102&RS=08336102
owner: Microsoft Corporation
number: 08336102
owner_city: Redmond
owner_country: US
publication_date: 20070601
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION","An Exemplary Fuzzing API","Proxy","Modeling Well-Formed (Valid) Input Data for a Software Application","Valid Input Data Generation and Mutation to Generate Malformed Input","Exemplary Data Fuzzing Result Presentation"],"p":["To avoid certain types of security vulnerabilities, computer-program applications should verify that consumed input is well-formed, without making false assumptions about input consistency. Otherwise, security vulnerabilities such as buffer overruns resulting from malformed input and other types of errors may be fatal to proper functioning and results of the application. To locate any such vulnerabilities, software developers often implement \u201cfuzz testing\u201d, or \u201cfuzzing\u201d prior to releasing software. Fuzzing is a software testing technique that typically provides random data (\u201cfuzz\u201d) as computer-program application data inputs to identify access violations and\/or buffer overruns (not functional problems). If the application fails in view of such randomly generated data inputs, for example, by crashing, or by failing built-in code assertions, a software developer generally notes and attempts to address the defects. However, conventional software fuzz testing techniques are typically very time consuming and labor intensive, often requiring iterative manual effort and\/or use of inefficient automated techniques. For instance, existing fuzzing techniques generally only locate very specific and simple faults, often with poor code coverage. For example, if input includes a checksum which is not properly updated to match other random changes, only the checksum validation code will be verified. Every fuzzer is generally designed to find a different set of vulnerabilities, or bugs.","Systems and methods to deliver malformed data for software application fuzzing are described. In one aspect, a fuzzing engine receives well-formed valid input data from a test automation tool. The received data is for input into a software application to implement a functional test. Responsive to receiving the well-formed valid input data, the fuzzing engine automatically generates corresponding malformed data based on characteristics of the well-formed valid input data. The application is then automatically fuzzed with the malformed data to notify an end-user of any security vulnerabilities in one or more code paths of the application used to process the malformed data.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the detailed description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used as an aid in determining the scope of the claimed subject matter.","Overview","Conventional software fuzzing techniques typically deliver malformed inputs to software either by creating a file with malformed content for input into a tested application (e.g., by parsing), or by developing a specific proprietary fuzzing test tool to deliver malformed data at appropriate instances. Providing malformed inputs to software via a file is essentially limited because in certain scenarios not all tested applications are designed to accept input as files. For example to perform fuzzing of a web server fuzzed inputs need to be sent as http requests. Additionally, providing only malformed input via a final may not be sufficient to test all code paths of an application. For example, to reach a particular code path, a software application may need to be brought to one or more required states via configuration operations before the input data can be properly input to the code path for testing. For example to fuzz web server authentication implementation, it should be configured to request authentication. Moreover, developing a specific proprietary fuzzing test tool to input malformed content into software typically requires complex implementation of the application's code to configure tested portions and drive those portions to a target state before the tested portions can be fuzzed. Producing such complex implementations is generally a time consuming and labor intensive task.","Systems and methods to deliver malformed data for fuzz testing software applications are described below. These systems and methods address the described limitations of existing techniques to deliver malformed inputs to a software application to fuzz the software application. Software targeted for fuzzing or being fuzzed is frequently called a \u201ctested application\u201d or \u201ctested software.\u201d To this end, the systems and methods include a fuzzing engine that receives valid (well formed) data for input into a tested software application. Responsive to receiving the valid data, and in one implementation, the fuzzing engine utilizes a fuzzing data schema that describes characteristics of the well-formed input from a test automation tool to generate corresponding malformed data for input into and fuzzing the tested application. In another application, the fuzzing engine is hard-coded to present malformed data to the tested application in response to receiving particular valid input data. That is, the received valid input data is mapped to corresponding malformed data, or the malformed data is automatically generated from the valid input data via one or more well known data fuzzing algorithms. In one implementation, the malformed data is provided to the tested application via a fuzzing API, respective portions of the fuzzing API are implemented by the fuzzing engine and a test automation tool. In one implementation, the tested application is brought to a particular application state before the systems and methods begin fuzzing the tested application. In another implementation, the malformed data is provided to the tested application via a network proxy or a local filter driver that intercepts about input data being input into the tested application. Once intercepted, the valid input data is fuzzed and forwarded to the tested application to identify any security vulnerabilities.","These and other aspects of the systems and methods for Delivering malformed data for fuzz testing software applications are now described in greater detail","An Exemplary System","Although not required, the systems and methods to deliver malformed data for fuzz testing software applications are described in the general context of computer-program instructions being executed by a computing device such as a personal computer. Program modules generally include routines, programs, objects, components, data structures, etc., that perform particular tasks or implement particular abstract data types. While the systems and methods are described in the foregoing context, acts and operations described hereinafter may also be implemented in hardware.",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1","b":["100","100","102","104","106","102","102","106"]},"For example, computing device  includes processor  coupled to a tangible computer-readable data storage medium such as a system memory . System memory  includes, for example, volatile random access memory (e.g., RAM) and non-volatile read-only memory (e.g., ROM, flash memory, etc.). Processor  may be a microprocessor, microcomputer, microcontroller, digital signal processor, etc. System memory  includes program modules . Each program module  is a computer-program application including computer-program instructions executable by processor . System memory  also includes program data  that is generated and\/or used by respective ones of the program modules .","In this implementation, for example, computing device  program modules  include fuzz-testing (\u201cfuzzing\u201d) engine , test automation tool , and \u201cother program modules\u201d  such as an Operating System (OS) to provide a runtime environment, an XML editor, device drivers, etc. Fuzzing engine  generates malformed data  for input into a tested software application . Fuzzing engine  generates one or more permutations of malformed data  from valid (well-formed) input data  for the tested application. Exemplary aspects of fuzzing data schema  are described in greater detail below in the section titled \u201cModeling Well-Formed (Valid) Input Data for Software Application\u201d. In another implementation, fuzzing engine  uses known techniques to malformed data  from valid input data . In the implementation of , tested software application  is shown on remote computing device . However, in another implementation, tested software application  is on a same computing device as fuzzing engine . Such an alternate implementation is described below in the section titled \u201cProxy\u201d, wherein the proxy is a device driver, or \u201cfilter proxy.\u201d","Fuzzing engine  inputs, using one or more of multiple possible data input techniques, the malformed data  into tested application  to fuzz tested application . These techniques include, for example, delivering malformed data  using a fuzzing Application Program Interface (API) , delivering malformed data  as a network proxy, delivering malformed data  via a filter interface, and\/or so on. Each of these respective techniques to deliver malformed data  to tested application to fuzz the tested application and identify any security vulnerabilities are now described.","In one implementation, the fuzzing engine  and test automation tool(s)  (or other applications) expose a respective portion of a fuzzing API  to fuzz a tested application . The particular implementation of a test automation tool  is arbitrary and that it is a function of the particular implementation of the software application being tested (i.e. tested software application ). In one implementation, test automation tool  performs both functional testing (to assess predetermined application functionality responsive to receipt of valid data inputs) and fuzz testing of tested application . We now describe an exemplary implementation and use of fuzzing API .",{"@attributes":{"id":"p-0020","num":"0019"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"AN EXEMPLARY FUZZING API"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["class FuzzingConsumer","\/\/ Exposed by a test automation tool 118"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"{"},{"entry":"\u2003socket _s;"},{"entry":"public:"},{"entry":"\u2003FuzzingConsumer (socket *s): _s (s) { }"},{"entry":"\u2003int Consume (char *input, int len) {return <fuzzed data to tested"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003\u2003\u2003application>;}"]},{"entry":[{},"\u2003\u2003\/\/ E.g., send (s, input, len, 0), or call an"]},{"entry":[{},"\u2003\u2003\/\/ API with input as a parameter, etc.."]},{"entry":"}"},{"entry":["class Fuzzer","\/\/ Exposed by fuzzing engine 116"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"{"},{"entry":"\u2003Initialize (String Schema, String TestCase, FuzzingConsumer"},{"entry":"\u2003Consumer);"},{"entry":"\u2003DoFuzzing (byte Input[ ]); \/\/ Calls Consumer.Consume (...)"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Referring to TABLE 1, class FuzzingConsumer is implemented by test automation tool  to allow fuzzing engine  to fuzz a tested application . For purposes of exemplary illustration, interfaces exposed via the Fuzzing Consumer class are shown as fuzzing consumer API , which is respective portion of fuzzing API . The particular implementation of class FuzzingConsumer is arbitrary, depending on the particular implementation of how the tested application  obtains data inputs (e.g., via pre-specified data input mechanisms such as an API, a socket, a file, etc.). For instance, if software application  is an SMTP application, fuzzing engine  sends fuzzed data to the SMTP application via a socket. In this particular implementation, and for purposes of exemplary description, class FuzzingConsumer is designed to provide input to the tested application via a socket \u201cs\u201d. The socket structure is well known. For example, in one implementation, the socket is an Internet socket (or commonly, a network socket), representing a communication end-point unique to a machine  or  communicating on an Internet Protocol-based network , such as the Internet. An Internet socket indicates, for example, one or more of a protocol (TCP, UDP, raw IP, etc.), a local IP address, a local port, a remote IP address, and a remote port.","The FuzzingConsumer.Consume\u201d interface is called by the fuzzing engine  to deliver fuzzed data (a respective portion of malformed data ) to tested application . The particular implementation of \u201cFuzzingConsumer.Consume\u201d is arbitrary because Consume is designed to work with the particular technique\/methodology implemented by the tested application to receive input data. For example, in one implementation, the fuzzed data is sent to tested application  using a socket over network  to the tested application. In another implementation, for example, or application  is local to computing device , the fuzzed data is passed to tested application  via a call to an exposed API , via a file, and\/or so on. The particular implementation of API  is arbitrary as it is a function of the particular implementation of tested application .","Referring to TABLE 1, class Fuzzer does this implementation, for example, exposes interfaces Fuzzer.Initialize and Fuzzer.DoFuzzing, both of which are called by a test automation tool  to fuzz tested application . For purposes of exemplary illustration, interfaces exposed via class Fuzzer are shown as API , which is respective portion of fuzzing API . Fuzzer.Initialize initializes parameters to enable fuzzing the tested application . In this implementation, such parameters include, for example, \u201cSchema\u201d, \u201cTestCase\u201d, and \u201cConsumer.\u201d \u201cSchema\u201d identifies a fuzzing data schema  for initialization. Exemplary aspects of fuzzing data schema  are described in greater detail below in the section titled \u201cModeling Well-Formed (Valid) Input Data for Software Application\u201d. Interface Fuzzer.Initialize ( . . . ) prepares the specified fuzzing data schema  for fuzzing. Fuzzing Engine would then perform initialization of the engine, such as schema loading and\/or schema  compilation.","The \u201cTestCase\u201d parameter indicates a particular predetermined application state of multiple possible application states where fuzzing of the tested application should begin. The particular execution states of an application are arbitrary, being a function of the particular implementation of the application. For example, please consider a typical two state web application, which (1) performs login, returning a session cookie, and (2) requires this cookie to be provided for all further requests. In this example, a first TestCase will indicate a need to fuzz the login request, and a second TestCase will indicate a need to fuzz regular application request, which will indicate a need for fuzzing engine to place a session cookie in the request. In a scenario where application requests in the 2state are to be fuzzed, fuzzing engine  allows test automation to perform processes to bring the tested application to the target state (e.g., test automation logs-in, obtains session cookie, and\/or so on). In this example, when the session cookie is present, fuzzing engine  performs fuzzing of application request(s).","The \u201cConsumer\u201d parameter of Fuzzer.Initialize identifies a specific instance of class FuzzingConsumer (described above) that has been instantiated by test automation tool . Responsive to receiving this parameter, fuzzing engine  initializes the specific instance by keeping the reference to consumer interfaces, so that it can use it later when producing fuzzing output. Fuzzing.DoFuzzing\u201d interface is called by test automation tool  to fuzz input data specified by \u201cInput[ ].\u201d In this implementation, for example, \u201cDoFuzzing\u201d builds fuzzed data and passes it to Consumer.Consume to send the fuzzed input to tested application .","TABLE 2 shows exemplary functional test automation code before it was modified to utilize fuzzing API  to fuzz a tested application . This non-modified functional test example is shown to compare and contrast a purely functional test to a functional test that has been modified to implement fuzzing via the fuzzing API, as described below with respect to TABLE 3. The functional test of TABLE 2, as do all functional tests, validates that certain functionality in a tested application works as expected. The tested functionality, as well as the particular implementation of the functional test, is clearly arbitrary because it is a function of the particular implementation\/architecture of the tested application.",{"@attributes":{"id":"p-0027","num":"0026"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"AN EXEMPLARY FUNCTIONAL TEST"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void test (socket s, int param)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003char buf [100];"]},{"entry":[{},"\u2003\u2003sprintf (buf, \u201cTest input %d\u201d, param);"]},{"entry":[{},"\u2003\u2003send (s, buf, strlen (buf), 0);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"b":"124"},"TABLE 3 shows the same exemplary functional test automation code as TABLE 2, with the exception that the code of TABLE 2 has been modified (modifications are italicized) to utilize the fuzzing API  (a combination of APIs  and ) to fuzz tested application .",{"@attributes":{"id":"p-0029","num":"0028"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"AN EXEMPLARY MODIFIED FUNCTIONAL TEST FOR FUZZING"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void test (socket s, int param)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003FuzzingConsumer fc (s);"]},{"entry":[{},"\u2003Fuzzer fuzzer = new Fuzzer ( );"]},{"entry":[{},"\u2003Fuzzer.Initialize (\u201cc:\\temp\\schema.fgxml\u201d, \u201chttp-request\u201d, fc);"]},{"entry":[{},"\u2003char buf [100];"]},{"entry":[{},"\u2003sprintf (buf, \u201cTest input %d\u201d, param);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003fuzzer.DoFuzzing (buf);","\/\/ Please note that \u201csend\u201d was replaced"]},{"entry":[{},{},"\/\/ with this fuzzing operation."]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"b":["122","118"]},"In another implementation, fuzzing engine  is implemented in association with proxy such as a network based proxy or a local filter driver to respectively and transparently intercept network  and\/or local communication(s) between test automation tool(s)  and tested application . For purposes of exemplary illustration, such a proxy is shown as a respective portion of \u201cother program modules\u201d . In one implementation, the test automation tool performs functional testing to assess predetermined application functionality responsive to receipt of valid data inputs, not fuzz testing. The intercepting proxy redirects the intercepted communication(s) to fuzzing engine . The fuzzing engine parses the intercepted communication to identify and fuzz at least a subset of the data associated with the intercepted communication(s) to generate fuzzed data (i.e., respective portions of malformed data ). In certain scenarios such as network-based communication, the intercepted communication may be a packet associated with a protocol (e.g., TCP, UDP, DCOM, RPC, etc.). In such scenarios, fuzzing engine  maintains correctness (e.g., header(s), etc.) of the protocol and malforms only data targeted for consumption by tested application  to generate fuzzed packets (please see \u201cother program data\u201d ). The fuzzing engine returns the fuzzed data (possibly representing fuzzed packet(s)) to the proxy, which directly forwards the fuzzed data to the tested application for consumption.","For example, fuzzing engine  parses well formed data received from test automation . In one implementation, for example, fuzzing engine  attempts to match the parsed data to characteristics in fuzzing data schema  (or a hardwired malformed version) and a current state (test case). If the input was not matched, it is assumed to belong to a different state and is passed as is to the tested application (local in the scenario of a local filter driver proxy, or remote in the case of a network proxy). If the input matches the schema and testcase, fuzzing engine  applies fuzzing transformations and produces fuzzed data, which is then sent to tested application.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 2","FIG. 2","FIG. 1","FIG. 1"],"b":["202","116","204","118","204","124","118","116","204","204","132"]},"In one implementation, a software developer or other user manually defines fuzzing data schema . For example, a user interfaces with an Extensible Markup Language (XML) editing application to generate fuzzing data schema . Although fuzzing data schema  is shown as local to computing device , in another implementation, fuzzing data schema  is remote from computing device  (e.g., in a database coupled to computing device  over a network , etc.). Fuzzing data schema  describes\/models characteristics (e.g., data types, attributes, relationships, input sequences, etc.) of well-formed valid input data (e.g., input data, message protocol formats, etc.) for a particular software application (e.g., tested application ). This data modeling does not directly provide specific instances of well-formed data for the software application, but rather describes attributes, characteristics, etc. that a specific instance of well-formed data would have. The software application can be any arbitrary application. For instance, valid input data to a web browser software application  includes, for example, HTTP protocol response message to present HTML web pages. In another example, valid input data to a SMTP server software application  include data to present SMTP-based messages. In either of these exemplary scenarios, the user models corresponding protocols (e.g., HTTP, HTML, SMTP, and\/or so on), including each specific form of the protocol. Examples of valid input data modeling for fuzzing data schema  are presented below.","To model valid (well-formed) input data for software application , a user decomposes the input data into atomic groups of groups of elements or primitive elements (strings, numbers, etc.). For each element, the fuzzing data schema  indicates data type, valid values or relationships (e.g., attributes describing legitimate variations of the element such as data length, valid ranges, minimum\/maximum values, and\/or so on). Such relationships\/attributes\/valid formats indicate appropriate value(s) of an element for well-formed (i.e., expected) input into the software application. For variable length fields, fuzzing data schema  indicates how to detect field termination (e.g., by whitespace or carriage return character, etc.). TABLES 4 and 5 respectively show an exemplary set of elements (data fields and attributes) and groups of elements or groups (e.g., a group of groups) to model well-formed input data for software application . Although a certain number of elements and groups are described with respect TABLES 4 and 5, it can be appreciated that system  can use other elements and groups to model well-formed input data for software application .",{"@attributes":{"id":"p-0035","num":"0034"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 4"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"EXEMPLARY ELEMENTS TO DESCRIBE WELL-FORMED INPUT"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Name","Purpose"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Character","String with ASCII or Unicode characters"]},{"entry":[{},"String","of variable length. In this"]},{"entry":[{},{},"implementation, length is fixed or"]},{"entry":[{},{},"determined by specified terminator. In"]},{"entry":[{},{},"one implementation, a valid character set"]},{"entry":[{},{},"is specified."]},{"entry":[{},"Numeric","Number encoded as string. Can be"]},{"entry":[{},"String","signed or unsigned. Can be integer or"]},{"entry":[{},{},"floating type. Valid range(s) and\/or"]},{"entry":[{},{},"floating point precision is specified."]},{"entry":[{},"Integer","Number binary encoded. Can be signed"]},{"entry":[{},{},"or unsigned. Valid ranges are specified."]},{"entry":[{},"Byte","Stream of binary bytes. Length is fixed"]},{"entry":[{},"Array","or determined by specified terminator."]},{"entry":[{},"Bit Array","An array data structure which compactly"]},{"entry":[{},{},"stores individual bits (0 or 1)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"Referring to TABLE 4, and in this implementation, respective ones of well-formed data elements for input into software application  are modeled in fuzzing data schema , for example, as a corresponding character string, numeric string, integer, byte array, or bit array. A character string is a string of ASCII or Unicode characters of variable length. String length is fixed or determined by a specified terminator. In one implementation, a valid character set is specified. A numeric string is a number encoded as a string. Such a number (e.g., integer, binary coded number, floating point) is signed or unsigned. In one implementation, valid range relationships and\/or precision attribute(s) is\/are specified for a number. A byte array element is a stream of bytes. The length of the byte array is fixed or determined by a specified terminator. A bit array element is an array data structure which compactly stores individual bits (0 or 1).",{"@attributes":{"id":"p-0037","num":"0036"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 5"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"EXEMPLARY GROUPS TO DESCRIBE WELL-FORMED INPUT"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Name","Purpose"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Sequential","Multiple elements or groups in a specified"]},{"entry":[{},{},"order are contained in a sequential group (a"]},{"entry":[{},{},"group can encapsulate other groups)."]},{"entry":[{},"Single-","Only one element or group out of specified"]},{"entry":[{},"Choice","list of elements or groups is contained in a"]},{"entry":[{},{},"single-choice group"]},{"entry":[{},"Multi-","Multiple elements or groups in any order are"]},{"entry":[{},"Choice","contained in a multi-choice group"]},{"entry":[{},"Bit Array","A list of binary bits of a certain length is"]},{"entry":[{},"Group","contained in a bit array group"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"Referring to TABLE 5, and in this implementation, groups in fuzzing data schema  include, for example, one or more sequential groups, single-choice groups, multi-choice groups, and bit array groups. A sequential group includes multiple elements or groups of element(s) in a specified order. For example, if software application  expects to receive element (field) \u201cA\u201d, field \u201cB\u201d, and field \u201cC\u201d, in the specified order, schema would contain a sequential group with data fields (elements) A, B and C. A single-choice group represents only one element or group out of possible options. A multi-choice group represents multiple elements or groups in any order contained in the group. A bit array group is a list of bits contained in the group.","For example, and in one implementation, fuzzing data schema  describes a simple HTTP Message in XML as follows:",{"@attributes":{"id":"p-0040","num":"0039"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<SequentialGroup name=\u201cHTTP Message\u201d>"]},{"entry":[{},"\u2003\u2003<SequentialGroup name=\u201cRequest Line\u201d>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<String name=\u201cMethod\u201d TerminatedBy=\u201cSPACE\u201d\/>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<String name=\u201cURI\u201d TerminatedBy=\u201cSPACE\u201d\/>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<String name=\u201cVERSION\u201d TerminatedBy=&#10&#13\/>"]},{"entry":[{},"\u2003\u2003<\/SequentialGroup>"]},{"entry":[{},"\u2003\u2003<MultiChoiceGroup name=\u201cHeaders\u201d>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<SequentialGroup name=\u201cHeader\u201d>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003<String name=\u201cName\u201d TerminatedBy=\u201c:\u201c\/>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003<String name=\u201cValue\u201d TerminatedBy=&#10&#13\/>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<\/SequentialGroup>"]},{"entry":[{},"\u2003\u2003<\/MultiChoiceGroup>"]},{"entry":[{},"\u2003\u2003<ConstString value=&#10&#13\/>"]},{"entry":[{},"\u2003\u2003<ByteArray name=\u201cbody\u201d\/>"]},{"entry":[{},"<\/SequentialGroup>"]},{"entry":[{},"In the above example, \u201cSPACE\u201d = \u201c\u201d."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In one implementation, fuzzing engine  parses fuzzing data schema  to create valid input data . Valid input data  represents data that conforms to respective elements in fuzzing data schema . Since fuzzing application models well-formed data for input into software application , valid input data  represents valid data for input into software application, i.e., data that software application  was designed to consume or process.","In one implementation, for example, fuzzing engine  randomly generates valid input data  by iterating through each group and element combination in fuzzing data schema , generating respective portions of valid input data according to the characteristics of the specific group type (e.g., sequential, single-choice, multiple-choice, etc) and element type (character string, numeric string, integer, length, valid range, etc.). For example, to generate valid input data  associated with a single choice group, one of the specified element(s) is randomly selected and created. In another example, fuzzing engine  generates a string element by iterating between zero (0) and a random length, within an allowed specified maximum indicated by element attributes\/properties (e.g., valid range, minimum\/maximum values, byte array length, etc.). For every character, a random character within an allowed specified set is generated.","After creating valid input data , and in one implementation, fuzzing engine  parses and mutates\/changes valid input data  to generate malformed data  (properly formed invalid data) for input to and fuzz-testing of software application . To this end, fuzzing engine  parses valid input data  to generate a tree of groups and elements  and corresponding attributes (valid ranges, characteristics, etc) to representing valid input data . Tree  isolates valid element data associated with respective individual elements of valid data  so that malformed data  can be generated from respective ones of the isolated elements.","For example an HTTP Message that would correspond to above schema would be:","GET \/dir1\/dir2\/file.htm HTTP\/1.0","HeaderA: valuea","HeaderB: valueb","Body","In this example, \u201cGET\u201d string corresponds to \u201cMethod\u201d token, \u201cHeaderA\u201d and \u201cHeaderB\u201d correspond to \u201cHeader\u201d sequential group and \u201cBody\u201d corresponds to \u201cbody\u201d ByteArray.","Next, and in one implementation, fuzzing engine  applies one or more known fuzzing algorithms to at least a subset of the data elements in tree  to corrupt the data elements according to well-known data type based vulnerability patterns. For instance, one exemplary fuzzing algorithm inserts null values into string element(s). Another exemplary fuzzing algorithm, for example, may sets integer value(s) to a maximum value+1 in a specified allowable range, and\/or so on. Fuzzing engine  further serializes the resulting mutated data tree (i.e., a data tree with fuzzed\/corrupted data inputs), resulting in fuzzed data buffer Q (or mutation template). Serialization is a common computer term for converting a data structure comprised of a few elements into a data buffer. For purposes of exemplary description, a mutation template is a sample of a legitimate data.","Responsive to receiving a piece of malformed data , if software application  crashes (or otherwise performs contrary to target design), the fuzzing operations have identified a security vulnerability in a code portion of software application  corresponding to the received piece of malformed data . In this scenario, an end-user of system  is put on notice by the crashing or contrary operations that the software application  has one or more corresponding code paths are vulnerable with respect to security. In another implementation, such crashing and\/or contrary operations cause system  to automatically notify a user (e.g., via a display device) of information associated with the identified security vulnerability. Otherwise, if no crash (or other unusual behavior) of software application  occurs, no security vulnerability was identified in the corresponding portion of code (i.e., the code portion is validated).","Exemplary Procedures",{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 3","FIG. 3","FIG. 1","FIG. 3"],"b":["300","302","126","118","304","126","122","306","122","124","308","124","306"]},{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 4","FIG. 4","FIG. 1"]},"Referring to , operations at block  issue, by a functional test module (e.g., a test automation tool ), and initialize request to a fuzzing engine. The request is to initialize a set of data in preparation for fuzzing an application . In one implementation, the request is a Fuzzer.Initialize request of a fuzzing API . Operations of block  communicate a fuzzing request to the fuzzing engine  to direct the fuzzing engine to generate and communicate to the application  a set of malformed data . The set of malformed data  is associated with a set of well-formed data . In one implementation, the fuzzing request is a Fuzzer.DoFuzzing request of the fuzzing API . Operations at block  process, by the application being tested, the malformed data  to determine any security vulnerabilities in one or more code paths. The one or more code paths are designed to properly process the well-formed data from which the malformed data was generated. Operations at block  notify an end-user of any security vulnerabilities identified responsive to fuzzing the one or more code paths with the malformed data.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 5","FIG. 5","FIG. 1","FIG. 5"],"b":["502","104","124","504","126","506","122","132","508"]},"Alternate Embodiments","Although system  of  has been described as using valid input data  (generated from fuzzing data schema ) merely to generate structure and content associated with malformed data , in another implementation valid input data  is used for additional purposes. For example, in one implementation, valid input data  is utilized to perform functional testing and\/or results of software application  (this is as compared to utilizing malformed data  to identify code portions of software application  with security vulnerability). For purposes of exemplary illustration, testing tool  also inputs data from valid input data  into software application  to test operations of software application . For example, in one embodiment, valid input data  specifies content of one or more messages for communication to the software application  according to a specific protocol described by the fuzzing data schema . In this embodiment, the testing tool communicates at least a subset of the messages to the software application  to validate whether the software application properly processes the received messages. This is only one arbitrary example of using a particular exemplary aspect of valid input data  to test proper functioning of software application . There are many different scenarios where different types of valid input data  are used to test operations of software application .","Conclusion","Although the above sections describe delivering malformed data for fuzz testing software applications in language specific to structural features and\/or methodological operations or actions, the implementations defined in the appended claims are not necessarily limited to the specific features or actions described. Rather, the specific features and operations to deliver malformed data for software application and fuzzing are disclosed as exemplary forms of implementing the claimed subject matter."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["In the Figures, the left-most digit of a component reference number identifies the particular Figure in which the component first appears.",{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
