---
title: Modern application tracing
abstract: Modern application tracing techniques are described herein that enable dynamic logging of events declared in a static manifest. Various events for logging can be declared in a static manifest. The static manifest may then be compiled to translate the declared events into a library of corresponding functions that can be called by “modern” applications written using dynamic code. Calls made to these functions from dynamic code are converted to corresponding static events and forwarded to existing tracing application programming interfaces (APIs) designed to handle logging of static events for “legacy” applications that use compiled code. In this manner, static functions that are compatible with tracing APIs can be created and called dynamically from dynamic code. This can occur without requiring administrative rights to install the code and while preserving existing features for legacy applications, such that a tracing log can include events from both modern applications and legacy applications.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08621439&OS=08621439&RS=08621439
owner: Microsoft Corporation
number: 08621439
owner_city: Redmond
owner_country: US
publication_date: 20110906
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION","Overview","Example Environment","Example Procedures","Example System","CONCLUSION"],"p":["Developers may employ tracing of events generated in connection with executing applications to debug and troubleshoot the applications. In one traditional approach, function level logging can be employed to measure timing and other performance metrics for particular functions. Function level logging, though, does not provide granular information regarding different execution branches that may result for a particular task. A more sophisticated approach involves logging both start events and end events associated with particular tasks to capture semantics associated with responses to the different actions. Traditionally, however, event based logging of this type is handled separately by individual applications, which creates a proliferation of logs and formats that may be difficult to correlate.","Moreover, existing system wide event based logging infrastructure and techniques are directed to traditional statically complied applications such as C++ and C# applications (e.g., compiled languages and\/or \u201clegacy\u201d applications that may be installed using administrative rights). As such, existing technology for event based logging may be incompatible with \u201cmodern\u201d applications that take advantage of dynamic languages (e.g., non-compiled scripting languages) and\/or corresponding runtime environments.","Modern application tracing techniques are described herein that enable dynamic logging of events declared in a static manifest. Various events for logging can be declared in a static manifest. The static manifest may then be compiled to translate the declared events into a library of corresponding functions that can be called by \u201cmodern\u201d applications written using dynamic code. Calls made to these functions from dynamic code are converted to corresponding static events and forwarded to existing tracing application programming interfaces (APIs) designed to handle logging of static events for \u201clegacy\u201d applications that use compiled code. In this manner, static functions that are compatible with tracing APIs can be created and called dynamically from dynamic code. The logging may occur without requiring administrative rights to install the dynamic code. This can occur while preserving existing features for legacy applications, such that a tracing log can include events from both modern applications and legacy applications.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used as an aid in determining the scope of the claimed subject matter.","Traditionally, event based logging is handled separately by individual applications and\/or is limited to pre-defined events generated by static code (e.g., compiled code). Thus, existing technology for event based logging involves many disjointed application-specific logs and is incompatible with applications written using dynamic languages.","Modern application tracing techniques are described herein that enable dynamic logging of events declared in a static manifest. Various events for logging can be declared in a static manifest. The static manifest may then be compiled to translate the declared events into a library of corresponding functions that can be called by dynamic applications. Instead of logging events from dynamic code, the dynamic code calls a function in the library to handle the logging. The manifest translation produces functions that are compatible with existing technology for event based logging. In particular, the functions provide an intermediate layer between dynamic code and static tracing application programming interfaces (APIs). Calls made to these functions are converted to corresponding static events and forwarded to existing tracing APIs for logging. Accordingly, modern applications can make use of the existing tracing technology by declaring static events in a manifest and converting the manifest to produce corresponding functions that implement the logging of those events. In this manner, static functions that are compatible with tracing APIs may be created and called dynamically from dynamic code. This can occur without having to install the dynamic code using administrative privileges and while preserving existing features for legacy applications.","In the following discussion, an example environment in which modern application tracing may be employed is first described. Example procedures for modern application tracing are then described which may be employed in the example environment as well as other environments. Finally, an example system is described that represents example systems and devices that may be used to implement various embodiments of modern application tracing. Accordingly, performance of the example procedures is not limited to the example environment and the example environment is not limited to performing the example procedures.",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1","b":["100","100","102","104","106","108","110","104","104","110","102","110"]},"The computing device  may be embodied as any suitable computing system and\/or device such as, by way of example and not limitation, a desktop computer, a portable computer, a tablet or slate computer, a handheld computer such as a personal digital assistant (PDA), a cell phone, a set-top box, and the like. One example of a computing system that may represent various systems and\/or devices including the computing device  is shown and described below in .","The computer-readable media may include, by way of example and not limitation, forms of volatile and non-volatile memory and\/or storage media that are typically associated with a computing device. Such media may include ROM, RAM, flash memory, hard disk, removable media and the like. One such configuration of a computer-readable media is signal bearing \u201ccommunication media\u201d that is configured to transmit computer-readable instructions (e.g., as a carrier wave) to the hardware of the computing device, such as via a network. The computer-readable medium may also be configured as \u201ccomputer-readable storage media\u201d that excludes mere signal transmission. Thus, computer-readable media includes both \u201ccomputer-readable storage media\u201d and \u201ccommunication media\u201d further examples of which can be found in the discussion of the example computing system of .","At least some of the applications  may be configured as runtime applications that operate through one or more runtime platforms  of the computing device . These \u201cmodern\u201d applications may be written using dynamic scripting languages that may not be compiled, such as JavaScript. Modern applications may be distinguished in the following discussion from \u201clegacy\u201d applications that may be written using statically compiled languages, such as C++, C#, and so forth. The runtime platforms  are configured to provide respective execution environments for corresponding applications. In other words, runtime platforms  are configured to support the execution of programs written in a compatible computer language. Runtime platforms  provide a common set of features, routines, and functions for compatible applications thereby offloading coding of common tasks from application development. Runtime platforms  also enable portability of applications to different kinds of systems with little or no change to the dynamic script for the applications and\/or without recompiling.","In at least some embodiments, a runtime platform  may be provided with the operating system  as an integrated component available on a computing device  having the operating system  installed thereon. Runtime platforms  may also be provided by third-party providers. Examples of runtime platforms  for a computing device  include JAVA\u2122 runtime environment (JRE), Adobe\u2122 Flash\u2122, Microsoft\u2122.NET framework, and Microsoft Silverlight\u2122 to name a few examples.","The computing device  further includes one or more tracing application programming interfaces (APIs)  and a runtime tracing component  that reside on the computer-readable media and are also executable by the processor(s).","The tracing APIs  represent functionality through which applications  can invoke native operating system functionality designed to facilitate tracing and logging of events. The tracing APIs  represent legacy components associated with the operating system  that are designed for use with legacy applications that use compiled languages. For example, instrumented applications may be configured to provide tracing events that are logged in a tracing log  directly through the tracing APIs . The tracing APIs  may be configured to receive and process events in a pre-defined, expected format directly from statically compiled code of legacy applications. For example, events may be declared in a manifest that specifies the expected format and includes metadata to describe the events. Events may therefore be provided by applications and logged through the tracing APIs  in an expected format. The logged events may thereafter be decoded using the metadata descriptions contained in the manifest.","In accordance with modern application tracing techniques described herein, the runtime tracing component  represents functionality of the computing device  operable to enable logging of events from modern applications using native tracing functionality of the operating system , such as using the example tracing APIs . The runtime tracing component  may be provided as an intermediate layer situated between modern applications and the operating system . In general, the runtime tracing component  is operable to convert statically defined events to dynamically callable functions and expose the functions for use by modern applications to log events in a tracing log . In turn, the functions created and exposed by the runtime tracing component  translate calls from dynamic code to static events in an expected format that can be handled by legacy tracing APIs . The runtime tracing component  may be implemented as a standalone application as illustrated or as a component of another application. For example, the runtime tracing component  may be provided as an integrated component of the operating system .","To further illustrate, consider  which depicts an illustration of an example scenario  showing example operation of a runtime tracing component  of . In particular,  shows a manifest  that may be generated to define events for tracing by an application. In particular, the manifest may define various events  and associate the events with metadata  that describes the events . The events  may be defined in terms of parameters that are passed by applications . The metadata  may be used to decode the raw log data that may be recorded as values for the parameters in an expected format without including descriptive information. For example, the metadata  may designate event names, data parameters associated with the events, an expected format\/sequence for data parameters in log data, and so forth. Log entries may therefore contain strings of parameter values in an expected format\/sequence for an event without including the contextual names, tags, and so forth defined by the metadata . This enables logging transactions and corresponding logs that are lightweight in terms of resource usage, e.g., memory and processing power.","For instance, a login start event may include parameters for a user name, start time, and number of attempts. Thus, an event may simply be logged as values for the name, time, and attempts. The manifest defines the expected format of these parameters, such as the sequence of the parameters. The logged values may be correlated to the event description contained in the manifest to decode the log.","In operation, the runtime tracing component  obtains the manifest  as input and produces a function library  based on the manifest . The function library  includes a function corresponding to each of the events that is callable by dynamic code. For example, an application  is shown in  as being implemented within a runtime platform . The application  has been instrumented with dynamic tracing code  that, upon the occurrence of particular events, make calls into the function library  to cause the runtime tracing component  to log the events. The manifest , dynamic tracing code , and other components to implement the described techniques can be installed using standard privileges (e.g., without requiring administrative privileges), which make it easier for developers to take advantage of tracing functionality. For example, modern application tracing techniques discussed herein may be implemented by applications  and\/or dynamic tracing code  that is installed on a per user basis using standard privileges.","In response, the runtime tracing component  executes appropriate functions when called to translate the calls into static events compatible with tracing APIs . In particular, the functions provided by the function library  convert the calls into events in the expected format designated by the manifest . The runtime tracing component  then interacts with the tracing APIs  on behalf of the application  to log the events in the tracing log .","For instance, the runtime tracing component  calls the tracing APIs  with the events created through the function library . As also shown in , legacy applications  can interact directly with the tracing APIs  to provide compatible events for logging in an expected format. In this way, the tracing APIs  may be implemented to handle event logging calls from both modern and legacy applications. Because the runtime tracing component  converts functions calls from modern applications to an expected format for static events, the tracing APIs  are able to handle calls without awareness of the kind of application providing the call or operation of the runtime tracing component .","In response to event logging calls, the tracing APIs  operate to write the events to the tracing log  as logged events . In at least some embodiments, the runtime tracing component  further operates to locate and\/or obtain descriptive metadata  for events being logged by modern applications. The runtime tracing component  employs this information to include decoding data  along with corresponding events. For example, decoding data  may be embedded in log files along with corresponding logged events . The decoding data  may include actual metadata  for an event, pointers to appropriate metadata , and\/or other data sufficient to enable decoding of corresponding events. In this manner, log files are self-contained and are decodable using decoding data  embedded within the log files themselves. Further details regarding these and other aspects of modern application tracing techniques are provided in relation to the following example procedures.","The following discussion describes modern application tracing techniques that may be implemented utilizing the previously described systems and devices. Aspects of each of the procedures may be implemented in hardware, firmware, or software, or a combination thereof. The procedures are shown as a set of blocks that specify operations performed by one or more devices and are not necessarily limited to the orders shown for performing the operations by the respective blocks. In portions of the following discussion, reference will be made to the environment  of  and the example scenario  of .",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 3","b":["300","302","116","202","102","102","202"]},"The manifest is compiled into a library of functions callable by dynamic runtime applications (block ). For example, the runtime tracing component  may covert the static manifest into functions that are compatible with dynamic runtime applications (e.g., \u201cmodern applications\u201d). This may involve creating individual functions for each of the events defined in the manifest. Thus, the conversion may produce a function library  that includes a plurality of functions that may be called by dynamic runtime applications. In particular, the functions may be called through tracing code  with which applications  are instrumented. In at least some embodiments, the function library  corresponding to the manifest is created as a dynamic link library (dll) that contains the various functions. Unlike the manifest , the created dll does not have headers and metadata describing tracing events. Rather, the dll provides a set of functions corresponding to the events described in the manifest .","A call to a function is received from a dynamic runtime application to log an event (block ). For instance, an instrumented application can include tracing code  that is configured to detect and respond to different events. In particular, the tracing code  can be configured to make calls to functions in the function library  created in the manner described herein. The runtime tracing component  may be configured to expose the dll containing the function library  and handle calls made to the functions.","The called function from the library is executed to cause logging of the event in a tracing log (block ). For instance, the call made to a particular function is received and executed through the runtime tracing component . Here, the dynamic call from dynamic code is translated into an event in a static format that is understandable by existing tracing APIs . The runtime tracing component  may then provide the event to the tracing APIs  on behalf of the application to cause logging of the event in a tracing log . Thus, the runtime tracing component  acts as an intermediary between dynamic code and static tracing APIs that facilities logging of events from the dynamic code using existing tracing components designed for static applications.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 4","b":["400","116","208","202","116","208"]},"In particular, events declared in a manifest for static application tracing are translated into functions callable by dynamic code (block ). For example, each event declared in a manifest  can be translated to a corresponding function. In one approach, the translation is performed by the runtime tracing component  at a computing device . To do so, the runtime tracing component  may parse the manifest file and translate events defined therein one by one. Additionally or alternatively, the runtime tracing component  may include or otherwise make use of a library of functions having at least some pre-translated functions. For instance, the runtime tracing component  may be configured to access and use a function library  available from a remote source, such as from a website of a developer that creates and maintains the function library  for access by clients. In this case, the runtime tracing component  may access the function library  on-demand over a network and\/or download the function library  for storage locally at a computing device .","Event logging calls from dynamic code are converted to a format compatible with native tracing APIs of an operating system using the functions (block ). Native tracing APIs are invoked using the converted event logging calls to log corresponding events in a tracing log (block ). For example, the functions derived from the manifest  are configured to take calls from dynamic code as input and process the calls to produce events in a static form as output. In other words, the functions of the function library  operate to generate appropriate calls to native tracing APIs  based on calls made to the functions by tracing code  placed within dynamic applications. Here, the runtime tracing component  may make calls into the native tracing APIs  on behalf of modern applications using the static events generated through the functions. From the perspective of the native tracing APIs , the calls made by the runtime tracing component  appear the same as calls from static applications and are handled in the same manner. Thus, the native tracing APIs  may handle logging for both modern applications and static applications without being modified and without awareness of modern applications and\/or processing that is performed by the runtime tracing component  on behalf of the modern applications.","Decoding data sufficient to decode the events is selectively provided for inclusion in the tracing log (block ). For instance, the runtime tracing component  may optionally provide decoding data in conjunction with calls made to the native tracing APIs . In general, the decoding data enables interpretation of the log data and events described therein. In traditional techniques, decoding may be dependent upon an external static manifest that defines the events. If the static manifest is not installed or is otherwise unavailable, decoding of the log may be difficult or even impossible. Providing decoding data within the tracing log  itself produces a self-contained log that can be decoded without having to install or rely upon an external manifest. Further, details regarding techniques for selective inclusion of decoding data within a tracing log  are discussed in relation to the following example procedure of .","In particular,  depicts a procedure  in an example implementation in which decoding data sufficient to decode events is selectively embedded with log files. A function call from a dynamic application to log a particular event is detected (block ). For example, a call initiated by tracing code of an application may be received and processed by the runtime tracing component  as discussed previously. A determination is made regarding whether or not the call is a first instance of the particular event (block ). For example, the runtime tracing component  may track different kinds of calls and identify when a first instance of a particular event is received. The identification can be based upon suitable identifiers, such as an event name, event ID, or other identifying data placed in calls made by tracing code .","When the call is a first instance of the particular event, metadata corresponding to the particular event is located that is sufficient to decode the particular event (block ) and the particular event is logged along with decoding data corresponding to the particular event (block ). For example, metadata  defining a corresponding event  may be located from a manifest . The runtime tracing component  may use the metadata  to generate a decoding data item. The decoding data item may be configured as another separate log entry that is entered into the tracing log  each time a first instance of an event is encountered. The decoding data item may also be provided as one or more parameters that are added to and therefore combined with a log entry for a corresponding event. In some embodiments, the decoding data item may be configured to include a link, URL, or other pointer that can be used to locate metadata  for a corresponding event. Resources for the metadata  may be stored in a binary file, such as a dll created for the function library  or another suitable resource file. Additionally or alternatively, the decoding data item may include embedded metadata  that defines the event.","On the other hand, when the call is not a first instance of the particular event, the particular event is logged without additional decoding data (block ). In this case, additional decoding data is not added because the log already contains data sufficient to decode the particular event. In this manner, a self-contained log may be produced without carrying decoding data for each individual log entry\/event. Thus, the decoding data is added to a log file once for each different kind of event, which keeps the log file relatively small in size.","In another approach, the runtime tracing component  can make a determination of whether or not a decoding data item for a particular event already exists within a tracing log . This may occur by examining the log to find decoding data item that matches a particular event when a call is received from an application. Decoding data may then be added to the log if a decoding data item does not already exist. Otherwise, the event may be logged without adding another (e.g., duplicate) decoding data item.",{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 6","b":["600","602","602","102"]},"The example computing device  includes one or more processors  or processing units, one or more computer-readable media  which may include one or more memory and\/or storage components , one or more input\/output (I\/O) interfaces  for input\/output (I\/O) devices, and a bus  that allows the various components and devices to communicate one to another. Computer-readable media  and\/or one or more I\/O devices may be included as part of, or alternatively may be coupled to, the computing device . The bus  represents one or more of several types of bus structures, including a memory bus or memory controller, a peripheral bus, an accelerated graphics port, and a processor or local bus using any of a variety of bus architectures. The bus  may include wired and\/or wireless buses.","The one or more processors  are not limited by the materials from which they are formed or the processing mechanisms employed therein. For example, processors may be comprised of semiconductor(s) and\/or transistors (e.g., electronic integrated circuits (ICs)). In such a context, processor-executable instructions may be electronically-executable instructions. The memory\/storage component  represents memory\/storage capacity associated with one or more computer-readable media. The memory\/storage component  may include volatile media (such as random access memory (RAM)) and\/or nonvolatile media (such as read only memory (ROM), Flash memory, optical disks, magnetic disks, and so forth). The memory\/storage component  may include fixed media (e.g., RAM, ROM, a fixed hard drive, etc.) as well as removable media (e.g., a Flash memory drive, a removable hard drive, an optical disk, and so forth).","Input\/output interface(s)  allow a user to enter commands and information to computing device , and also allow information to be presented to the user and\/or other components or devices using various input\/output devices. Examples of input devices include a keyboard, a touchscreen display, a cursor control device (e.g., a mouse), a microphone, a scanner, and so forth. Examples of output devices include a display device (e.g., a monitor or projector), speakers, a printer, a network card, and so forth.","Various techniques may be described herein in the general context of software, hardware (fixed logic circuitry), or program modules. Generally, such modules include routines, programs, objects, elements, components, data structures, and so forth that perform particular tasks or implement particular abstract data types. An implementation of these modules and techniques may be stored on or transmitted across some form of computer-readable media. The computer-readable media may include a variety of available medium or media that may be accessed by a computing device. By way of example, and not limitation, computer-readable media may include \u201ccomputer-readable storage media\u201d and \u201ccommunication media.\u201d","\u201cComputer-readable storage media\u201d may refer to media and\/or devices that enable persistent and\/or non-transitory storage of information in contrast to mere signal transmission, carrier waves, or signals per se. Thus, computer-readable storage media refers to non-signal bearing media. Computer-readable storage media also includes hardware elements having instructions, modules, and\/or fixed device logic implemented in a hardware form that may be employed in some embodiments to implement aspects of the described techniques.","The computer-readable storage media includes volatile and non-volatile, removable and non-removable media and\/or storage devices implemented in a method or technology suitable for storage of information such as computer readable instructions, data structures, program modules, logic elements\/circuits, or other data. Examples of computer-readable storage media may include, but are not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, hard disks, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, hardware elements (e.g., fixed logic) of an integrated circuit or chip, or other storage device, tangible media, or article of manufacture suitable to store the desired information and which may be accessed by a computer.","\u201cCommunication media\u201d may refer to a signal bearing medium that is configured to transmit instructions to the hardware of the computing device, such as via a network. Communication media typically may embody computer readable instructions, data structures, program modules, or other data in a modulated data signal, such as carrier waves, data signals, or other transport mechanism. Communication media also include any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media include wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared, and other wireless media.","Combinations of any of the above are also included within the scope of computer-readable media. Accordingly, software, hardware, or program modules, including the tracing APIs , runtime tracing component , operating system , applications , and other program modules, may be implemented as one or more instructions and\/or logic embodied on some form of computer-readable media.","Accordingly, particular modules, functionality, components, and techniques described herein may be implemented in software, hardware, firmware and\/or combinations thereof. The computing device  may be configured to implement particular instructions and\/or functions corresponding to the software and\/or hardware modules implemented on computer-readable media. The instructions and\/or functions may be executable\/operable by one or more articles of manufacture (for example, one or more computing devices  and\/or processors ) to implement techniques for modern application tracing, as well as other techniques. Such techniques include, but are not limited to, the example procedures described herein. Thus, computer-readable media may be configured to store or otherwise provide instructions that, when executed by one or more devices described herein, cause various techniques for modern application tracing.","Although the invention has been described in language specific to structural features and\/or methodological acts, it is to be understood that the appended claims are not necessarily limited to the specific features or acts described. Rather, the specific features and acts are disclosed as example forms of implementing the claimed subject matter."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The detailed description is described with reference to the accompanying figures. In the figures, the left-most digit(s) of a reference number identifies the figure in which the reference number first appears. The use of the same reference numbers in different instances in the description and the figures may indicate similar or identical items.",{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
