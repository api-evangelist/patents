---
title: Swarm-based synchronization over a network of object stores
abstract: An object set may be redundantly stored by a set of computers, each configured to store a local representation of corresponding objects. When a computer changes the object set (e.g., by adding or altering an object), the updated object may be synchronized across the computers by iteratively forming and using an ad hoc swarm network from the neighbors of a node storing the updated object. This swarm network may operate cooperatively, where each node distributes object chunks to other nodes as quickly as possible, and may disregard concepts of competitive swarm networks such as fairness and cheating avoidance, which may not apply to cooperative swarming and might otherwise slow the propagation of the object. An alternative “ask” technique may be included to identify and recover missed object updates, and a computing environment host may be included as an authoritative object source and/or as an object store of last resort.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08694578&OS=08694578&RS=08694578
owner: Microsoft Corporation
number: 08694578
owner_city: Redmond
owner_country: US
publication_date: 20090529
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["In the field of computing, many scenarios involve a set of computers or devices configured to store data, sometimes represented as a set of objects, where the computers are connected over a network. In some scenarios, a set of computers or devices may respectively store a local representation of a particular object. It may be desirable to propagate changes to one local representation of the object to the other local representations of the corresponding object stored on the other computers or devices by communicating over the network. In more complex scenarios, the set of shared objects may be large, and changes may be frequent. However, the available network bandwidth of a particular computer or device may be limited, and may serve to limit the rate at which a computer or device may receive data about changed objects and send data about changes to local representations to other computers or devices. Therefore, it may be difficult to establish a reliable mechanism whereby the computers and devices may communicate notifications of changes to such objects and allocate the limited bandwidth of the network to achieve an efficient propagation of changes to such data objects.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key factors or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter.","One mechanism for synchronizing objects involves an arrangement among the nodes of the network that, when a node detects a change to a local representation of an object, such as a writing of a new object or an alteration of an existing object (any such change is referred to herein as an \u201cupdated object\u201d), it notifies a subset of fully interconnected nodes (\u201cneighbors\u201d) of the updated object, and identifies the neighbors that do not have the updated object. It may then arrange to have the object sent to these neighbors in an efficient manner, such as via a peer-to-peer network. In particular, the small set of neighbors may form a \u201cswarm\u201d type of peer-to-peer network, wherein each neighbor may, while receiving portions of the object from the source (i.e., the node that initiated the peer-to-peer network and that has the full updated object), forward received portions of the object to other neighbors, and may concurrently receive other portions of the object from other neighbors. This technique therefore utilizes both the uploading and downloading bandwidth of the nodes comprising the swarm network to achieve a faster distribution of the object than a centralized transfer of the object from the source to each neighbor. Moreover, in contrast with other swarm networks that are configured to promote competitive fairness (e.g., aspects of BitTorrent that promote a \u201cfair\u201d distribution of uploading capacity among the nodes that have significant portions of the data to be exchanged), the swarm network connecting these devices may be configured to utilize more bandwidth from nodes with more uploading capacity in order to achieve a faster distribution of the updated object. Additional features may optionally be incorporated in order to promote economy and robustness in various scenarios (e.g., an \u201cAsk\u201d technique may be included to allow a newly connected or reconnected computer or device to receive changes that were distributed while the computer or device was offline, and communication with a computing environment host may be included to synchronize objects with a centralized and authoritative source for the object set.)","To the accomplishment of the foregoing and related ends, the following description and annexed drawings set forth certain illustrative aspects and implementations. These are indicative of but a few of the various ways in which one or more aspects may be employed. Other aspects, advantages, and novel features of the disclosure will become apparent from the following detailed description when considered in conjunction with the annexed drawings.","The claimed subject matter is now described with reference to the drawings, wherein like reference numerals are used to refer to like elements throughout. In the following description, for purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the claimed subject matter. It may be evident, however, that the claimed subject matter may be practiced without these specific details. In other instances, structures and devices are shown in block diagram form in order to facilitate describing the claimed subject matter.","In the field of computing, many scenarios involve a set of computers (e.g., servers, workstations, notebooks, mobile phones, and other devices) that store various sets of data, and that can communicate over a network. In some of these scenarios, two or more computers may respectively store a representation of a particular set of data, such as one or more objects (e.g., files, database records, tuples, class instances, etc.) For example, an object may be replicated across several computers in order to provide local access to the object, e.g., for local use, for faster access, and\/or for maintaining access to the object in the event of a network partitioning or disconnect. Additionally, the computers may endeavor to synchronize the various representations of the object, such that changes to a local representation of the object on one computer may be propagated to the other representations on other computers.","More generally, respective computers may be connected over one or more networks (e.g., computers A, B, and C may be mutually accessible over a first network, while computer A may connect with computers D and E over a second network), and respective computers may comprise an object store configured to store a set of objects, where particular objects in a first object store of a first computer correspond to particular objects in a second object store of a second computer. Among these computers, changes to an object are to be synchronized with a corresponding object stored in the respective object stores of the other computers. The computers may cooperate to achieve this synchronization over the network. However, respective computers often have a limited upload and\/or download capacity, and in some cases (e.g., mobile devices), limited processing power and\/or battery life. These limitations might restrict the rate of propagation of changes, and may place an inordinate and potentially inefficient burden on some computers in achieving the synchronization.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIGS. 1-4","b":["12","14","14","12","12"]},"In the first example  of , the source  endeavors to send the object  to a set of nodes  over a network , where the source  has a relatively large upload capacity. However, the source  in this first example  sends the object  in full to each of the nodes , thereby magnifying the upload bandwidth involved in sending the object  by a factor of five. Even if the network connection  of the source  features a comparatively large upload capacity, the upload capacity may be quickly exhausted as the number of nodes  scales, leading to slow or failed delivery of the object  to the nodes .","In the second example  of , the source  endeavors to send the object  over the network connection  to a small set of nodes, comprising a first node , a second node , and a third node . However, the first node  and the third node  have already receive the object  (e.g., the source  may have received the object  from an upstream node that has already achieved the sending of the object  to the first node  and the third node  without informing the source .) The sending of the object  to the first node  and the third node  may therefore be redundant and an unproductive use of the upload capacity of the source .","In the third example  of , a source node  may coordinate to send the object  to a first node  over a first network  and a second node  over a second network . Both the first node  and the second node  may also be connected to a third node , to which the object  is also to be sent. The source  may achieve the delivery of the object  to the first node  and the second node  respectively over the first network  and the second network , and these nodes may endeavor to send the object  to the third node . As one example of an inefficiency, both nodes may send the object  to the third node , thereby resulting in a redundant delivery and an unproductive use of bandwidth. As another example of an inefficiency, the first node  and the second node  might communicate to avoid the redundancy, such that whichever node receives the object  first may deliver the object  to the third node  at the exclusion of the other node. While this coordination may avoid redundancy, the decision of which node is to send the object to the third node  may be based on an arbitrary race condition, rather than an evaluation of capacities. For example, if the first node  happens to receive the object  before the second node , the first node  may opt to send the object  to the third node , even if the upload capacity of the first node  over the first network  is much smaller than the upload capacity of the second node  over the second network . An avoidable delay may therefore be incurred in sending the object  to the third node . In addition, the more limited upload capacity of the first node  may be unduly consumed rather than the more plentiful upload capacity of the second node , which e.g., might significantly delay delivery of the object  to an additional node that might be reachable by the first node  over the first network  but not the second node  over the second network .","In the fourth example  of , the source  stores the object  to be delivered to the nodes  of a large network. Even if the delivery of the object  may be coordinated among the nodes  in a more efficient manner than in the examples of , the nodes  might nevertheless request information about the object  from the source . (Alternatively, the source  may be responsible for notifying each node  of the updated object .) Even disregarding the costs of sending the object , the network and processing costs of handling queries about the object  and providing information about the object  might overwhelm the source  and significantly delay the propagation of the object  to the nodes .","The examples of  illustrate network inefficiencies of various types, but many of these deficiencies arise from an excessive dependency on the upload capacity of a source  and the download capacity of the nodes . These bottlenecks may become exacerbated as the network scales, leading to further delays and potentially a breakdown in the capability of delivering the object  to all of the nodes . In view of these network difficulties, alternative synchronization strategies have been devised to promote a more efficient delivery of an object across a set of computers connected by at least one network. Better scaling may be achieved by also utilizing the upload capacities of the nodes  (e.g., to redistribute the object , or portions thereof, to other nodes ) and\/or the download capacity of the source (e.g., for tracking the reception status of the object  among the nodes .) Additionally, the allocation of network bandwidth may be delegated to the respective nodes , thereby distributing the computing power across the nodes  of the network and correlating such allocations with locally detected network capacities. These strategies, following a \u201cswarm network\u201d technique, thereby extend the use of network resources to achieve a faster distribution of the object , and the delegation of allocation may yield significant improvements as the number of nodes  and the number of objects  exchanged thereamong scales.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 5","b":["60","14","14","14","14","14","14","16","14","14","14","14","14"]},"In the simplified example  of a BitTorrent swarm network presented in , an object  is to be distributed from a first seed  and a second seed  (each storing a complete and identical copy of the object ) to a set of leeches comprising a first leech , a second leech , a third leech , and a fourth leech . The object  comprises a first chunk , a second chunk , a third chunk , and a fourth chunk , each of which is stored by the first seed  and the second seed , and which are unevenly and incompletely distributed among the leech nodes (e.g., the first leech  stores the second chunk , and the second leech  stores the first chunk  and the fourth chunk .) In order to promote the rapid dissemination of the chunks of the object , the first seed  is sending the first chunk  to the first leech , and the second seed  is sending the third chunk  to the first leech . While the first seed  might be capable of sending the second seed  or the third seed  to the second leech , it may instead rely on another node (such as the first leech ) to distribute these chunks to the second leech . Similarly, the second seed  may forego sending the second chunk  to the second leech , because it may obtain this second chunk  from the first leech . Concurrently, the first leech  and the second leech  may send some initial chunks to the third leech  and the fourth leech , each of which initially stores no chunks (e.g., having just joined the BitTorrent network.) In this manner, the first seed  and the second seed  cooperate with the leech nodes to distribute the chunks of the object  by sharing the distribution costs with the leech nodes.","BitTorrent networks are adept at synchronizing an object in a peer-to-peer manner among a set of nodes that are comparatively untrusted, and by allocating the distribution in a \u201cfair\u201d manner. As a first example, an operator of a node  typically chooses to join one a BitTorrent swarm network in order to obtain the particular object exchanged thereby, and may choose to leave the BitTorrent swarm network at any time (even before having fully received the object .) It may also be presumed that each operator of a node operates independently, \u201cselfishly,\u201d i.e., participating in the network (and contributing the upload and download capacity of the node to the swarm network) only to the extent that participation benefits the operator. For example, an operator of a node benefits from receiving (downloading) the object but does not directly benefit from sending (uploading) the object to other nodes, especially if such upload capacity is limited and diverted from other uses. An operator of a node may attempt to \u201ccheat\u201d in the cooperative synchronizing by fully utilizing the download capacity of the node to achieve rapid receipt of the object, but limiting or eliminating the upload capacity of the node to preserve upload capacity for more desirable tasks. The BitTorrent swarm network is configured to reduce \u201ccheating\u201d by allocating the delivery of chunks of the object  to a leech at a rate proportional to the rate of redistribution of chunks by the leech . Thus, a leech node that throttles the upload capacity (or simply has little upload capacity to contribute to the swarm network) is provided new chunks of the object  at a low rate. Conversely, BitTorrent swarm networks are configured to promote \u201cfairness\u201d among the distribution of chunks to nodes by recognizing leech nodes that are proficient at redistributing chunks, and by rewarding such redistribution by providing a new chunks of the object  at a high rate, potentially prioritizing such delivery (such as by the seeds) over the delivery of chunks to less well-performing nodes. Additionally, because many objects typically exchanged over BitTorrent networks may be useless to the node operators until all chunks have been received, the network may prioritize the delivery of chunks to a leech that has received nearly all chunks over the delivery of chunks to leeches that are storing fewer chunks. Conversely, the nodes may significantly restrict the rate of delivery of chunks to recently joined leeches that are storing few or no chunks (especially since the operators of such leeches are more likely to disconnect from the swarm network than the operators of leeches that are closer to completion of the object.)","As a second example, BitTorrent swarm networks are designed to detect, report, and mitigate malicious or defective nodes that distribute changed or damaged versions of the object. In many implementations, the chunks comprising an object are fixed at the formation of the swarm network, and an authoritative list of chunks is provided to all nodes by one or more designated seed nodes (identified as \u201ctracker\u201d nodes) that indicates a hashcode for respective chunks. Upon receiving a chunk from a node, the receiving node verifies the contents of the chunk according to the hashcode of the chunk; if the chunk has been changed or damaged (such as by the distributing node), the receiving node may report the sending node to the tracker nodes as potentially defective or malicious, and the tracker nodes may evict such nodes from the swarm network.","These specializations of the BitTorrent swarm network may promote the distribution of a static object among untrusted swarm nodes by reducing cheating, by promoting fairness, and by detecting and evicting malicious or defective nodes. However, in other scenarios, these aspects of swarm networks such as the BitTorrent swarm network may be unhelpful or unnecessary, and may reduce the efficient distribution of the object.  presents an exemplary illustration  of one such scenario, wherein the nodes of the swarm network comprise a set of computers operated by a user . The computers may comprise, e.g., a workstation , a notebook computer , and a cellphone device . The user  may wish to store a local representation of an object  on each of these computers, and, when the computers may communicate over a network, to synchronize the object  among all such computers. Moreover, the user  may utilize a computing environment host  that stores an authoritative version of the computing environment  of the user , comprising the complete set of objects used by the user , such as files, applications, application configuration information, user profiles, security credentials (such as usernames and passwords, certificates, and public and private cryptographic keys), which may be deployed (in whole or in part) by the computing environment host  to each computer. The computing environment host  may also include in the computing environment  a local (and potentially authoritative) representation of the object , and may participate in the synchronization of the object .","The exemplary scenario  differs from the scenario for which the BitTorrent swarm network is customized in several aspects. As a first example, the user  may change the object  using any of the computers or the computing environment host , and such changes are to be propagated among all computers and the computing environment host . This aspect differs from many swarm networks (including BitTorrent) that presume a static object , and that regard changes to the object  by a particular node as evidence of a malicious or defective alteration of the object . As a second example, whereas each node in a BitTorrent swarm network specifically opts to participate in the swarm network, the computers in the exemplary scenario  of  may be \u201cpulled\u201d into a newly formed swarm network in order to receive an update of the object  (especially if the update is spontaneous or unexpected.) As a third example, whereas BitTorrent networks seek to establish \u201cfairness\u201d of network capacity consumption and to reduce cheating by node operators, the user  in  fully trusts the nodes of the swarm network, and may prefer rapid and complete deployment of the object  over the tracking and adjusting for \u201cfairness\u201d and avoiding cheating. For instance, whereas the BitTorrent network seeks to adjust the delivery of chunks to a node proportionally with the rate of chunks redelivered by the node, the user  of this network may prefer to achieve a high rate of delivery of the object  to all nodes, e.g., by as fully as achievable utilizing the upload capacities of the nodes. As a fourth example, whereas each node in a BitTorrent swarm network may operate on a comparatively selfish and individualized basis to achieve the goals of the node operator, the nodes of the swarm network illustrated in  may operate holistically; e.g., a node with high upload capacity may opt to allocate much or all of the upload capacity for the distribution of the object , even if the rate of receiving chunks of the object is slow or nonexistent, in order to promote the distribution of the object  among all of the nodes.","In view of these distinguishing features of a cooperative network, techniques may be devised to synchronize an object set across a set of computers respectively configured to store a local representation of the object set in an efficient manner. In this cooperative network, any node might generate a change to the object, and the changes are to be propagated quickly and reliably throughout the network, without necessarily accounting for competitive aspects such as reducing cheating, promoting \u201cfairness,\u201d balancing, and detecting malicious or defective nodes. Such swarm networks may utilize a \u201ctell\u201d architecture, whereby each node notifies other nodes upon identifying an updated object in its object set, and a \u201cpush\u201d architecture, whereby the node initiates the sending of the updated object to nodes that are not storing the updated object. Thus, the node  controlling the interaction acts as a server that delivers updated objects  (or chunks thereof) to nodes  acting as clients configured to receive the updated objects . Moreover, even if the nodes of the network are fully interconnected and can communicate at equivalent rates, the network propagation of an updated object may occur in small groups of nodes (\u201cneighbor\u201d nodes) in order to reduce scaling difficulties (such as in the fourth example  of .)",{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 7","FIG. 7"],"b":["110","112","114","14","18","16","14","14","14","18","18","16"]},"At the first time point  of the exemplary scenario of , node C receives the object  and endeavors to synchronize the object  with the other nodes . Attempting to synchronize the object  with all of the nodes , or even attempting to notify all of the nodes  of the update to the object , may lead to significant network congestion that restricts the rate of synchronization, such as illustrated in . Rather, node C first selects a subset of nodes  as \u201cneighbors\u201d that are mutually accessible (i.e., where each node is accessible to all of the selected neighbors.) For example, node C may select nodes B, D and H as neighbors. Having selected a set of neighbors, node C then determines which neighbors are not storing the updated object . (For example, node C may notify each neighbor of the update and may offer to send the updated object  to the neighbor, and the neighbor may respond affirmatively or negatively.) If a neighbor is storing the updated object , no further synchronization is involved between node C and the neighbor. However, at the first time point  of , selected neighbors B, D, and H do not store the updated object , and so indicate to node C.","As further illustrated in , after determining which nodes  are not storing the updated object , Node C forms a swarm network , designating as swarm nodes  in the swarm network  each mutually accessible neighbor that is not storing the updated object . (Node C may also participate as a swarm node , but as node C is the originator of the swarm node , it does not have to receive any chunks, and may be regarded as the source of the updated object  within the swarm network .) The node C  notifies the swarm nodes  of the formation of the swarm network , and begins sending the updated object  to the swarm nodes  of the swarm network . For example, and as illustrated at the second time point , node C may segment or \u201cchunk\u201d the object  into a set of chunks, or data units of the object  that may be individually delivered. The object  of  is \u201cchunked\u201d into four chunks, and node C commences with delivering various chunks of the object  to the swarm nodes . Concurrently, each swarm node  (nodes B, D, and H) may receive the chunks and store them in the object store of the swarm node , and may redeliver the chunks to the other swarm nodes . For example, at the second time point , node H is storing the second chunk  and may identify that node B does not have the second chunk , and may therefore redistribute the second chunk  to node B. This swarming delivery of chunks may continue until all of the swarm nodes  have all of the chunks of the object , at which point the swarm network  may be terminated.","However, when the swarm network  is terminated, each of the swarm nodes  of the former swarm network  may now identify the updated object  stored in the respective object stores. Consequently, each of nodes B, D, and H may select a new set of neighbors, and may determine whether each neighbor is storing the updated object . For example, node B may select nodes A, F, and G as neighbors, may determine that none of these nodes are storing the updated object , and may form a swarm network  by designating these nodes  as swarm nodes  for the synchronization of the updated object . Node B may then notify each of the swarm nodes  of the swarm network  and may commence sending chunks to the swarm nodes  for redistribution thereamong. Similarly, node H may select nodes L, M, and N as neighbors and may, after determining that these nodes  are not storing the updated object  and may form a swarm network  designating these nodes  as swarm nodes ; and node D may select nodes E, I, and J as neighbors, determine that these nodes also do not store the updated object , and may form a swarm network  of these nodes. At the third time point , these three swarm networks  operate to distribute the updated object  more broadly across the nodes , and further propagation by ad hoc swarm networks (e.g., to nodes K and O) may complete the synchronization of the object  among all nodes .","A few additional aspects of this technique may be illustrated and\/or appreciated based on the exemplary scenario of . As a first example, a node  may discover that a neighbor is already storing the updated object . This may occur, e.g., if the neighbor is already receiving or has already received the updated object  through another swarm network. In this event, the node  may simply exclude the neighbor from the swarm network. Alternatively, it may be advantageous to include the neighbor in the swarm network as an additional \u201cseed,\u201d especially if the neighbor has spare upload capacity. As a second example, a swarm node  may be configured to contribute much or all of its upload capacity to the swarm network  in order to distribute chunks as quickly as possible, regardless of the rate at which the swarm node  is receiving chunks of the updated object . While this allocation may not be \u201cfair\u201d to the swarm node , the swarm networks  are formed to promote a rapid synchronization of the updated object  to the nodes, and not to promote \u201cfairness\u201d or reduce cheating, as may concern the operators of the independent nodes of the BitTorrent swarm network. As a third example, node C may, upon completing the delivery of the updated object  to the swarm nodes  of the swarm network , end its participation in the exchange of data (e.g., to promote a load balancing of computing power or network utilization among the nodes  of the network .) This variation may be useful, e.g., because neighbor selection may be a computationally difficult and\/or resource-intensive process, especially if the selection of neighbors is designed to cluster the nodes  of the network  in a comparatively uniform manner; each node  may therefore synchronize the updated object  among its neighbors as its contribution to the network-wide synchronization. Alternatively, if a node (such as node C) is permitted to select neighbors ad hoc for the synchronization of a particular object , then the node may, after completing its synchronization with a first neighbor set, endeavor to select a new set of neighbors that do not yet store the updated object , and may form a second swarm network  for the exchange thereamong.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 8","b":["120","14","18","16","120","122","124","126","18","16","128","14","130","14","132","116","118","14","134","118","116","14","136","14","118","116","14","18","116","120","138"]},"While the exemplary method  of  may achieve the delivery by the computer of an updated object  to a set of nodes, additional advantages may be achieved if the computer is also configured to receive an updated object  by participating in a swarm network  formed by another node  operating as the source of the updated object  (i.e., the computer may be configured not only as a server in this synchronization technique, but also as a client.)  illustrates an exemplary method  of receiving an updated object  in the course of a synchronization of objects  in the object store, which may be achieved, e.g., by additionally configuring the instructions executing on the processor. In this exemplary method , the instructions may be further configured, upon being notified  of a formation by a source of a swarm network  comprising the computer for an updated object , to begin at  and to create  a corresponding updated object  in the object store. The instructions may also be configured to, until the swarm nodes  have received the object , participate in the swarm network . This participation may involve, upon receiving the object , storing  the object  in the object store, and sending  the object  to a swarm node  not storing the object . Finally, the instructions may configured to, upon determining that the swarm nodes  have received the object , terminate the swarm network . Having achieved the receiving and redistribution of the object  using the swarm network , the exemplary method  may further promote the synchronization of the object  across the nodes , and so ends at .",{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 10","b":["160","162","164","166","14","162","16","18","16","166","14","162","18","14","166","162","168","168","170","18","172","16","162","172","174","172","14","116","118","14","118","116","14","168","176","14","118","116","116","14","166","118","168","14"]},"Still another embodiment of the techniques discussed herein involves a computer-readable storage medium comprising instructions that, when executed by at least one processor of a computer cause the at least one processor to synchronize objects  of an object set with corresponding objects  stored by nodes  that may be accessible to the computer over a network . An exemplary computer-readable medium that may be devised in these ways is illustrated in , wherein the implementation  comprises a computer-readable medium  (e.g., a CD-R, DVD-R, or a platter of a hard disk drive), on which is encoded computer-readable data . This computer-readable data  in turn comprises a set of computer instructions  configured to operate according to the principles set forth herein. In one such embodiment, the processor-executable instructions  may be configured to perform a method of synchronizing an updated object of an object set stored by a computer with corresponding objects stored by at least one node accessible over a network, such as the exemplary method  of . In another such embodiment, the processor-executable instructions  may be configured to implement a system for synchronizing an updated object of an object set stored by a computer with corresponding objects stored by at least one node accessible over a network, such as the exemplary system  of . Many such computer-readable media may be devised by those of ordinary skill in the art that are configured to operate in accordance with the techniques presented herein.","The techniques discussed herein may be devised with variations in many aspects, and some variations may present additional advantages and\/or reduce disadvantages with respect to other variations of these and other techniques. Moreover, some variations may be implemented in combination, and some combinations may feature additional advantages and\/or reduced disadvantages through synergistic cooperation. The variations may be incorporated in various embodiments (e.g., the exemplary method  of  and the exemplary system  of ) to confer individual and\/or synergistic advantages upon such embodiments.","A first aspect that may vary among embodiments of these techniques relates to the manner of sending updates of an object  to the nodes  by forming and using a swarm network . These variations may apply, e.g., while the computer functions as a server or source in the swarm network , such as according to the exemplary method  of .","A first variation of this first aspect relates to the identification of an updated object , which may trigger the synchronization of the object  with the other nodes . The synchronization may be triggered, e.g., by a creation of a new object  in the object store , or an updating of an object  in the object store . The synchronization might also be triggered by receiving a new object  or an updated version of the object  from another source, such as another device, another node  on the network , or a computing environment host . The synchronization might also be triggered, e.g., by a discovery of an updated object in the object store . For example, when the computer joins a network  and connects to the nodes , it may compare its object store  to the object stores of the other nodes  to discover changes that may have occurred while the computer was offline; and upon discovering such an updated object , the computer may synchronize the updated object  with the other nodes . In one such embodiment, the set of other nodes  consulted to discover changes may be limited, e.g., to a previously selected set of neighbors, in order to avoid a broadcast querying of many nodes  that might saturate the network . Constraining the nodes  contacted to discover updated objects  might therefore promote the scalability of the techniques discussed herein.","A second variation of this first aspect relates to the selection by a node  of the set of neighbors to be considered as swarm nodes  for an updated object . The selection of a neighbor set may help to avoid the problem illustrated in , where the source node  attempts to synchronize the updated object  with an overly large set of interconnected nodes , leading to network congestion and inefficient synchronization. The selection of neighbors may be arbitrary, but arbitrary selection might result in a less than fully interconnected network , where a first node  and a second node  are unable to communicate. The selection of neighbors might therefore be configured to mitigate a selection of neighbors that might lead to a partitioning of the network . The selection of neighbors might also be based on a variety of other factors, such as (e.g.) physical proximity, network topology (e.g., a subset of nodes on the same local area network or within a range of IP addresses), or comparatively low network latencies among the source node  and the neighbors. As a second example of this variation, the source node  may form a neighbor set comprising any number of neighbors, and in any manner. For example, the source node  may begin with an empty neighbor set, may iteratively test nodes  for mutual accessibility of the node with the selected neighbors, and may add any such node  to the neighbor set. The source node  may also designate any particular size of the neighbor set (e.g., neighbors may be added to the neighbor set until the neighbor set reaches an advantageous size, such as log(N) neighbors where N enumerates the nodes accessible over the network .) As a third example of this variation, the source node  may select neighbors upon beginning a synchronization of an updated object , e.g., upon identifying the updated object . This may be desirable, e.g., for permitting the source node  to promote the propagation of an updated object  after terminating a first swarm network , whereupon the source node  may select a new set of neighbors and form a second swarm network  if any such neighbors are not storing the updated object . Alternatively, the selection of neighbors may occur when a node  detects at least one network change event (e.g., when the node  connects to the network , when a new node  comes online, when a selected neighbor goes offline, or when the node  detects a partitioning of the network .) This may be advantageous because the selection of neighbors might be computationally intensive or resource-intensive, particularly if neighbors are selected by testing latency or modeling the capabilities of the network .","In one such embodiment implemented according to this second variation of this first aspect, the nodes  of the network  may be modeled according to a hypercube topology. According to this topology, respective nodes  of the network  may be connected such that each node  selects as neighbors the other nodes  along each edge of the hypercube. A first advantage of a hypercube topology involves an easy selection of neighbors simply by identifying the position of a node  within the hypercube and selecting as neighbors the nodes  connected at various edges. For example, if the nodes  of a fully interconnected network  may be enumerated from 1 to N (representing the number of nodes  in the network ), the neighbors (0 through i) of a particular node (enumerated as n) may be identified and selected according to the formula:\n\nxor2|0<ceiling(log()),xor2\n\nThus, a new node  may identify and select its neighbors simply by identifying its enumeration and by computing the enumerations of the nodes  to which it is connected by edges of the hypercube model.\n","A third variation of this first aspect relates to the manner of identifying whether a neighbor stores the updated object . As a first example, each node  may store a list of objects  stored by other nodes  (particularly neighbors.) When a node  identifies an updated object , it may first notify other nodes  (particularly neighbors), each of which may update its internal list of objects  stored by the node. Subsequently, when a node  is identifying neighbors to add to a swarm network , it may reference its list of objects  stored by its neighbors, which may permit the node  to exclude a neighbor that has already received the updated object  (e.g., from another source or via another swarm network.) As a second example, the node  storing the updated object  may determine whether each neighbor stores the updated object  by polling such neighbors. For example, for each neighbor, the node  may send to the neighbor an identifier of the updated object  (e.g., a name, distinctive location, GUID, or inode number of the object ) and a content indicator of the updated object  (e.g., a hashcode, version number, or latest modification date of the object .) The node  may then receive from the neighbor a notification whether the neighbor is storing the updated object , which the neighbor might generate, e.g., by comparing the identifier and the content indicator with the objects  in its object store .","A fourth variation of this first aspect relates to the relationship between an altered object  and the data exchanged over the swarm network  to achieve an alteration of the object  in the other representations. As a first example, whenever an alteration of an object is detected, the swarm network  may exchange the full contents of the object . As a second example, the swarm network  might exchange only the portions of the object  that have changed between the earlier version and the current version of the object . This example may be particularly advantageous, e.g., where changes to an object are limited to particular chunks, such that the swarm network  may only exchange the altered chunks, which may be written over the previous versions of such chunks in the object stores  of the nodes . Alternatively, the object  may define an internal structure (e.g., an array of records comprising a database), and the nodes  may exchange only the portions of the structure that have changed (e.g., new, updated, or deleted records in the database.) As a third example, the swarm network  might exchange a differential patch that may be applied by each node  to update the object  to the updated version. For example, the differential patch might instruct each node  to insert a data block of the object  at a particular location and delete another data block. Differential patches and partial updates may be advantageous, e.g., where small updates are made to large objects, while redistributing an entire object may be advantageous where the object is small or where the changes are extensive.","One such set of variations relate to the \u201cchunking\u201d of the object  into a set of chunks, each chunk comprising a data unit of the object  that may be individually delivered from one swarm node  to another node . In this variation, a \u201cchunking\u201d algorithm may be applied to segment the object  into chunks. Many such chunking algorithms might be compatible with the techniques discussed herein. For example, a chunking algorithm might choose segments in many ways; e.g., the algorithm might generate fixed-size chunks, or identify an internal structure of the object  and segment the object  according to the internal structure, or generate chunks at arbitrary positions. One such chunking algorithm that might be suitable for these techniques is remote differential compression (RDC), wherein an object  may be scanned to identify local maxima within respective portions of the object , and chunks of the object  may be selected as falling between such local maxima. This chunking algorithm might be particularly suitable, e.g., for reducing the odds of a change in one position of the object  (e.g., an insertion of a byte) incorrectly signaling an alteration of all of the following chunks in the object . Moreover, remote differential compression permits multiple levels of chunks for large objects ; e.g., an object  might be chunked into a series of chunks, and smaller chunks might be identified within each chunk, etc. If only a small portion of the object  changes (e.g., a single byte), it may be more efficient to examine the large chunks to identify the change, to examine the smaller chunks within a changed large chunk to further localize the change, and then to request only the small chunk containing the change from one or more neighbors. Alternatively, if the object  comprises a set of items (e.g., a set of small objects batched together for synchronization as one object), each item may be selected as a chunk. In a particular chunking variation, a distinctive pattern of data may be identified within the object (e.g., a specific set of bytes) and chunking the object  accordingly.","The chunking of objects might be advantageous for several reasons. As a first example, small changes (insertions, alterations, or deletions of data) within the object  might fall within only a few chunks, and a differential comparison of the chunks may indicate that only particular chunks are to be exchanged in order to update the object . A second example involves the potential for re-use of a chunk that has a total bit-for-bit identity with a missing chunk. If a first chunk in an object  is identical to a second chunk in the object  or in another object , then a node  that has the first chunk but not the second chunk might simply duplicate the first chunk to create the second chunk in the object store , therefore avoid transferring the second chunk or over the network .","Additional advantages may be achieved by particular embodiments of these techniques based on these variations.  illustrates an exemplary scenario , featuring a source node  configured to send an object  over a network  to swarm nodes  comprising a swarm network . The source node  may chunk the updated object  into at least one chunk (four such chunks are formed in this exemplary scenario ), and may then initialize an internally stored swarm chunk map , which indicates whether respective swarm nodes  are storing respective chunks of the updated object . The swarm chunk map  may comprise, e.g., a bitmap arranged as a two-dimensional array indicating 1 where a respective chunk is stored by a respective swarm node , and 0 otherwise. The source node  may select a chunk to send to a swarm node  by referring to the swarm chunk map . Moreover, when a swarm node  receives a chunk (either from the source node  or from another swarm node ), the swarm node  may notify the source node  of storing the chunk, and the source node  may accordingly update the swarm chunk map . Finally, the source node  may determine that the swarm nodes  have received the object  by examining the swarm chunk map . It may be additionally advantageous for each swarm node  to store and initialize a swarm chunk map  to be referenced for sending chunks to other swarm nodes , and for each swarm node  to notify all other swarm nodes  upon storing a chunk.","The inclusion of a swarm chunk map  may also permit additional improvements in these techniques. For example, when a swarm node  (including the source node ) selects a chunk to send to another swarm node , it may select a rare chunk stored in its object store, but that is infrequently stored among the swarm nodes  according to the swarm chunk map . This selection may facilitate an even distribution and broad availability of the chunks comprising the object  among the swarm nodes , thereby improving the accessibility of the chunks and the robustness of the swarm network  (e.g., to avoid the scenario where a node that goes offline may be the only source of a particular chunk.) For example, at the time point illustrated in the exemplary scenario  of , the source node  may be ready to send a chunk to another swarm node , and may examine the swarm chunk map  to identify a rare chunk. For example, the source node  may determine that the first chunk  is the least widely distributed chunk, and may therefore select the first chunk  to be sent to a swarm node  that is not storing the first chunk  (e.g., node B, C, D, or E.)","A fifth variation of this first aspect involves the selection of the updated object  to be synchronized with the swarm nodes . As a first example, the object store  may include a set of items that are more efficient to synchronize together with other nodes  than to synchronize individually. For example, the items may be semantically or logically related (e.g., a set of related records in a database or a set of resources that together comprise an application), or may be frequently updated together. The items might also comprise a set of items that individually comprise little data, or small updates that involve little data transfer. Alternatively, the items may comprise a set of items that have recently been updated; e.g., the computer may cache a set of items to be synchronized, and once a certain threshold (e.g., of elapsed time or amount of data to be updated) has been passed, to synchronize all of the items together. In such scenarios, it may be less efficient to generate a swarm network  (including selecting and notifying swarm nodes , chunking the object(s) , initializing swarm chunk maps , and initiating sending of chunks) for individual items than to bundle the items together in an object batch to be synchronized via a swarm network . Therefore, the computer may be configured to, upon identifying an updated object  in the object set, add the updated object  to an updated object batch comprising updated objects  not stored by the neighbors, and to form the swarm network  when the updated object batch exceeds an object batch threshold.","Alternatively or additionally, the computer may be configured to synchronize small updates (e.g., those involving a comparatively small amount of data to be synchronized, such as less than one megabyte; a small number of updated objects , such as fewer than ten; and\/or a small neighbor set, such as fewer than three neighbors) without forming a swarm network , but simply by directly sending the data to be synchronized to the neighbors. Therefore, the computer may be configured to, upon identifying a small data update (e.g., a small number of updated objects ; a small updated object ; or a small neighbor set), send the small updated object set to the neighbors of the small neighbor set. This alternative configuration may permit a source node  to propagate a small data update more promptly, and without incurring unnecessary overhead of a swarm network.","A sixth variation of this first aspect relates to a prioritization of objects  to be synchronized by a source node . As a first example, it may be advantageous to synchronize higher-priority objects  before lower-priority objects , or on a stricter synchronization schedule (e.g., the synchronization of updates to lower-priority objects  may be deferred or batched, while the synchronization of higher-priority objects  may be promptly performed.) As a second example, the objects  may belong to different groups, and it may be desirable to synchronize the objects  belonging to a first group before objects  belonging to a second group. The computer, while operating as a source node , may therefore establish an order of synchronizing particular objects according to priority, and may perform the techniques discussed herein (such as the exemplary method  of ) upon updated objects  in turn according to the priorities thereof.","A seventh variation of this first aspect relates to the configuration of the computer (as a server or source node ) to utilize a centralized object store and\/or a centralized coordination of the swarm networking, such as a computing environment host . In one such variation, the computing environment host  may centrally track which nodes  store which objects , and may participate in the selection of swarm nodes  among neighbors in order to synchronize an updated object . For example, each node  may, upon identifying an updated object , first notify the computing environment host . The computing environment host  may then be queried by any node  as to which neighbors are storing the updated object , and the response may be used to form the swarm network . In another such variation, the computing environment host  may serve as an authoritative source of the object set; e.g., the computing environment host  may provide a latest version of an object  on demand, may resolve versioning conflicts, and\/or may serve as a reliable source of an object  if other nodes  storing the object  are unavailable. Accordingly, where the objects  in the object store  of the computer are also stored as corresponding objects in an object store  of a computing environment host , the computer may be configured to, upon identifying an updated object , determine whether the computing environment host  is storing the updated object , and if not, send the updated object  to the computing environment host . Moreover, it may be advantageous to synchronize the updated object  with the computing environment host  before synchronizing the updated object  with neighbors. Those of ordinary skill in the art may implement additional features in the configuration of a computer (e.g., as a source node  or server) while implementing the techniques discussed herein.","A second aspect that may vary among embodiments of these techniques relates to the manner of configuring the computer to participate in a swarm network  formed for an updated object  stored by another source node . These variations may apply, e.g., while the computer functions as a client or swarm node  in the swarm network , such as in the exemplary method  of .","As a first variation of this second aspect, the computer may be configured to assist in the identification by the source node  of whether the computer stores the updated object . For example, the source node  may send to the computer an identifier (e.g., a name, distinctive location, GUID, or inode number) and a content indicator (e.g., a hashcode, version number, or last modification date of the object .) The computer may be configured to compare this information with the objects  in the object store  (and to a corresponding object  in the object store , if one exists.) The computer may then notify the source node  affirmatively if a matching object is located, if an object with the same identifier is of a later version, etc., or negatively if no such object is found, and the updated object  is to be received by the computer and stored in the object store .","As a second variation of this second aspect, the computer may be configured to participate in a swarm network  by notifying the other swarm nodes  and\/or the source node  upon receiving a chunk of the object . This may be helpful, e.g., for facilitating the distribution of chunks delivered to the computer, such as by enabling the source node  and\/or other swarm nodes  to update a swarm chunk map  to indicate the set of chunks stored by the computer. Additionally, the computer may be configured to participate in a swarm network  by initializing, maintaining, and using a swarm chunk map  indicating which swarm nodes  are storing which chunks of the updated object . This swarm chunk map  may be generated and used in a similar manner as the source node . For example, upon joining the swarm network , the computer may initialize a swarm chunk map , and upon notified that another swarm node  is storing a particular chunk, the computer may update the swarm chunk map  to indicate that the swarm node  is storing the chunk. This swarm chunk map  may be used, e.g., to determine when the swarm nodes  have received the chunks, and to facilitate the selection of chunks to be sent to various swarm nodes  (e.g., by selecting a rare chunk that is stored by the computer, but that is infrequently stored by the other swarm nodes .)","A third variation of this second aspect relates to the manner whereby the computer, while participating in the swarm network , delivers chunks to other swarm nodes . As a first example, the computer may simply send one chunk to one swarm node  at a time, and may select and send a subsequent chunk to a swarm node  upon completing the sending of the current chunk. As a second example, the computer may concurrently send one or more chunks to one or more swarm nodes. In one such embodiment, the computer may enqueue chunks to be sent to various swarm nodes . Upon being notified of the formation of the swarm network comprising the computer, the computer may be configured to generate a send queue for respective swarm nodes . Chunks may then be sent to respective swarm nodes  by enqueuing one or more chunk in the send queue of the swarm node . Upon enqueuing a chunk in an empty send queue of the swarm node , or upon completing sending the chunk to the swarm node (after dequeuing a sent chunk from the send queue), the computer may identify a next enqueued chunk in the send queue for the swarm node , and may initiate sending the next enqueued chunk. This embodiment may promote a steady stream of redistributed chunks to respective swarm nodes , and may also maintain a high utilization of the upload capacity of the computer. As one additional refinement, the computer may, upon identifying a next enqueued chunk, examine the swarm chunk map  to determine whether the swarm node  has already received the next enqueued chunk; if so, the computer may simply dequeue the enqueued chunk without sending it to the swarm node . Those of ordinary skill in the art may devise other improvements and features whereby the computer may be configured to participate as a swarm node  in a swarm network  while implementing the techniques discussed herein.","A third aspect that may vary among embodiments of these techniques relates to an additional configuration of the nodes  to achieve a synchronization of respective object stores  where the swarm network techniques might not succeed. As may be appreciated with regard to , the swarm network techniques discussed herein are likely to succeed in propagating an updated object  to all nodes  within particular conditions, such as an unpartitioned network , a set of neighbor selections that fully cover the nodes , and unbroken network connectivity of all nodes . However, if these conditions fail, the swarm network techniques may fail to propagate the updated object  to one or more nodes . As a first example, the network  may be partitioned into two or more partitions of nodes , where no node of a first partition is accessible to any node of another partition. This partitioning may occur, e.g., through connectivity failures, bridge nodes dropping offline, or an improperly chosen network topology. In this scenario, an updated object  may be propagated among the nodes  of a first partition, but cannot be propagated to any of the nodes  of the second partition. Moreover, the nodes  of the second partition may not even be notified that the object  has been updated. As a second example, an inadequate neighbor selection algorithm that is utilized by the nodes  to form swarm networks  may inadvertently exclude one or more nodes  from any neighbor set (e.g., where a first node is only accessible to a second node that fails to include the first node in its neighbor set.) In this scenario, the excluded node  is not included in any swarm network  and does not receive the updated object , and may not even be notified of the updated object . As a third example, a node  may temporarily go offline when an updated object  is being propagated though the nodes  by swarm networks , and may not receive the updated object  or even a notification that the object  has been updated.","In these and other scenarios, additional techniques may be utilized to promote the synchronization of the object sets stored by various nodes  when the swarm network techniques cannot achieve such synchronization. As one such example, the computer may be configured, upon detecting a synchronization event that might indicate a loss of updates or an opportunity to obtain a missing of updates (e.g., reconnecting to a network , detecting a partitioning or de-partitioning of the network , or choosing a new set of neighbors), endeavor to identify and obtain updated objects . The computer may then ask nodes  (such as neighbors) to identify updated objects , and may ask such nodes  storing any identified updated objects  to send the updated object  to the computer. Thus, in contrast with the \u201ctelling\u2019 and \u201cpushing\u201d architecture of delivering updated objects  to neighbors exhibited by the swarm networks , this supplemental technique exhibits an \u201cask\u201d architecture (whereby the node asks nearby nodes for updated objects ) and a \u201cpull\u201d architecture (whereby the node initiates the request to receive the updated object  from one or more nodes storing the updated object .) Thus, the node  controlling the interaction acts as a client that solicits updated objects  (or chunks thereof) from nodes  acting as servers of the updated objects .",{"@attributes":{"id":"p-0066","num":"0065"},"figref":["FIG. 13","FIG. 8","FIG. 10"],"b":["200","14","166","14","166","18","120","168","200","202","204","206","14","166","208","14","200","210","14","166","212","14","212","12","14","14","200","214","14","166","216","166","166","14","14","200","220"]},"Alternatively or additionally, embodiments may be configured to support the delivery of updated objects  to nodes  that request such updated objects  (e.g., by operating as a server of updated objects , or chunks thereof, that may be requested by client nodes utilizing the exemplary method  of .) For example, a computer may be configured to, upon receiving from a neighbor a request for a chunk of an object  stored in the object store  of the computer, send the chunk of the object  to the neighbor. Additionally, a computer may, while seeking to identify updated objects  stored by other nodes , identify one or more updated objects  stored in its object store  that are to be delivered to the other nodes . For example, the computer may have updated an object  in the object store  while offline, and upon reconnecting with the network , may identify the object  as having been locally updated while inquiring about updated objects  stored by other nodes . In this scenario, the computer may identify the object  as an updated object , thereby invoking the \u201ctell\u201d and \u201cpush\u201d techniques for synchronizing updated objects , such as the exemplary method  of . Those of ordinary skill in the art may devise many ways of synchronizing object sets that may supplement the swarm network synchronization while implementing the techniques discussed herein.","A fourth aspect that may vary among embodiments of these techniques relates to the participation of a computing environment host  in these techniques, and in particular in the \u201cask\u201d and \u201cpull\u201d synchronization techniques. A first variation of this fourth aspect involves an interaction of such embodiments with a computing environment host , which may facilitate the synchronization of the updated objects  from other nodes . The computing environment host  may store a list of updated objects  stored by various nodes , including the computer. When the computer detects a synchronization event, the computer may request from the computing environment host  a record of the objects  that have been updated, but that are not stored in the object store  of the computer. This record may be obtained, e.g., if respective nodes  are configured to notify the computing environment host  upon storing an updated object  in its object store . The computing environment host  may identify and provide such a list, e.g., by comparing its record of the object set  stored by the computer against the object set  stored by other nodes , including by the computing environment host . The result of the comparison may identify the updated objects , and may also identify the nodes  storing such updated objects  that may be provided upon request by the computer. Alternatively, the computing environment host  may maintain a log of updated objects  stored by the nodes , and may send to the computer the portion of the log since the computer was last known to have been synchronized with the other nodes  (e.g., since the last network synchronization event detected by the computer.) The computer may then examine the portion of the log to identify any updated objects  that are not stored in the object store  of the computer. Alternatively, if the object set is not managed by a computing environment host , other techniques may be used to identify updated objects ; e.g., the computer may request from neighbors a list of recently updated objects , or may compare the objects  stored in its object store  with the objects  stored in the object stores  of neighbors.","A second variation of this fourth aspect involves another interaction of the computer with the computing environment host  as an alternative source of updated objects  or chunks thereof. In some scenarios, the computer may more easily obtain an updated object  from the computing environment host  than from any of the nodes . As a first example, the nodes  storing an updated object  may be accessible to the computer over a slower network connection than may be achieved by directly contacting the computing environment host  (e.g., where the uplink from the nodes  has limited upload capacity, as occasionally describes a home network connected through a residential broadband connection.) As a second example, the nodes  storing the updated object  may not be accessible at all to the computer, such as when these nodes  lose network connectivity, or when a network partition isolates these nodes  in a partition apart from the computer. In these cases, the computer may resort to requesting an updated object  or a chunk thereof from the computing environment host . For example, the computer may be configured to, upon failing to receive at least one chunk of an updated object  from its neighbors, request the at least one chunk from the computing environment host  and, upon receiving the at least one chunk from the computing environment host , store the at least one chunk in the object store . It may be advantageous to configure the nodes  to make such requests only as a last resort in order to conserve the network capacity and processing resources of the computing environment host , but configuring the computer to exercise this option may be desirable over a protracted period where the object  stored by the computer is not synchronized with the latest updates to the object .","A third variation of this fourth aspect involves utilizing the computing environment host  to mediate version conflicts. In many scenarios, an object  may have been concurrently and differently updated by two nodes , and it may be difficult to reconcile the updates and to prioritize one version of the object  over the other. For example, a first node  may update its local representation of an object  while the node  is disconnected from the network , during which period a second node  may differently update its local representation of the same object . When the first node  reconnects to the network , it may discover the conflicting updating of the object  by the second node . In such scenarios, the nodes  may refer to the computing environment host  to mediate the version conflict, since the computing environment host  may host the authoritative representation of the object set. The computing environment host  may respond by choosing one version over the other based on various factors (e.g., the version most recently updated, or a version of the object  updated on a higher priority device over a version of the object  updated on a lower priority node device.) Alternatively, the computing environment host  may attempt to reconcile or merge the different updates to the object , and may generate a hybrid object to be distributed to the nodes . As other alternatives, the computing environment host  may indicate that both versions of the object  are to be stored (e.g., by renaming at least one of the versions of the object ), or may ask a user to choose a version. Those of ordinary skill in the art may devise many uses of a computing environment host  relating to the techniques discussed herein.","Although the subject matter has been described in language specific to structural features and\/or methodological acts, it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather, the specific features and acts described above are disclosed as example forms of implementing the claims.","As used in this application, the terms \u201ccomponent,\u201d \u201cmodule,\u201d \u201csystem\u201d, \u201cinterface\u201d, and the like are generally intended to refer to a computer-related entity, either hardware, a combination of hardware and software, software, or software in execution. For example, a component may be, but is not limited to being, a process running on a processor, a processor, an object, an executable, a thread of execution, a program, and\/or a computer. By way of illustration, both an application running on a controller and the controller can be a component. One or more components may reside within a process and\/or thread of execution and a component may be localized on one computer and\/or distributed between two or more computers.","Furthermore, the claimed subject matter may be implemented as a method, apparatus, or article of manufacture using standard programming and\/or engineering techniques to produce software, firmware, hardware, or any combination thereof to control a computer to implement the disclosed subject matter. The term \u201carticle of manufacture\u201d as used herein is intended to encompass a computer program accessible from any computer-readable device, carrier, or media. Of course, those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.",{"@attributes":{"id":"p-0074","num":"0073"},"figref":["FIG. 14","FIG. 14"]},"Although not required, embodiments are described in the general context of \u201ccomputer readable instructions\u201d being executed by one or more computing devices. Computer readable instructions may be distributed via computer readable media (discussed below). Computer readable instructions may be implemented as program modules, such as functions, objects, Application Programming Interfaces (APIs), data structures, and the like, that perform particular tasks or implement particular abstract data types. Typically, the functionality of the computer readable instructions may be combined or distributed as desired in various environments.",{"@attributes":{"id":"p-0076","num":"0075"},"figref":["FIG. 14","FIG. 14"],"b":["230","232","232","236","238","238","234"]},"In other embodiments, device  may include additional features and\/or functionality. For example, device  may also include additional storage (e.g., removable and\/or non-removable) including, but not limited to, magnetic storage, optical storage, and the like. Such additional storage is illustrated in  by storage . In one embodiment, computer readable instructions to implement one or more embodiments provided herein may be in storage . Storage  may also store other computer readable instructions to implement an operating system, an application program, and the like. Computer readable instructions may be loaded in memory  for execution by processing unit , for example.","The term \u201ccomputer readable media\u201d as used herein includes computer storage media. Computer storage media includes volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions or other data. Memory  and storage  are examples of computer storage media. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, Digital Versatile Disks (DVDs) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by device . Any such computer storage media may be part of device .","Device  may also include communication connection(s)  that allows device  to communicate with other devices. Communication connection(s)  may include, but is not limited to, a modem, a Network Interface Card (NIC), an integrated network interface, a radio frequency transmitter\/receiver, an infrared port, a USB connection, or other interfaces for connecting computing device  to other computing devices. Communication connection(s)  may include a wired connection or a wireless connection. Communication connection(s)  may transmit and\/or receive communication media.","The term \u201ccomputer readable media\u201d may include communication media. Communication media typically embodies computer readable instructions or other data in a \u201cmodulated data signal\u201d such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d may include a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal.","Device  may include input device(s)  such as keyboard, mouse, pen, voice input device, touch input device, infrared cameras, video input devices, and\/or any other input device. Output device(s)  such as one or more displays, speakers, printers, and\/or any other output device may also be included in device . Input device(s)  and output device(s)  may be connected to device  via a wired connection, wireless connection, or any combination thereof. In one embodiment, an input device or an output device from another computing device may be used as input device(s)  or output device(s)  for computing device .","Components of computing device  may be connected by various interconnects, such as a bus. Such interconnects may include a Peripheral Component Interconnect (PCI), such as PCI Express, a Universal Serial Bus (USB), firewire (IEEE 1394), an optical bus structure, and the like. In another embodiment, components of computing device  may be interconnected by a network. For example, memory  may be comprised of multiple physical memory units located in different physical locations interconnected by a network.","Those skilled in the art will realize that storage devices utilized to store computer readable instructions may be distributed across a network. For example, a computing device  accessible via network  may store computer readable instructions to implement one or more embodiments provided herein. Computing device  may access computing device  and download a part or all of the computer readable instructions for execution. Alternatively, computing device  may download pieces of the computer readable instructions, as needed, or some instructions may be executed at computing device  and some at computing device .","Various operations of embodiments are provided herein. In one embodiment, one or more of the operations described may constitute computer readable instructions stored on one or more computer readable media, which if executed by a computing device, will cause the computing device to perform the operations described. The order in which some or all of the operations are described should not be construed as to imply that these operations are necessarily order dependent. Alternative ordering will be appreciated by one skilled in the art having the benefit of this description. Further, it will be understood that not all operations are necessarily present in each embodiment provided herein.","Moreover, the word \u201cexemplary\u201d is used herein to mean serving as an example, instance, or illustration. Any aspect or design described herein as \u201cexemplary\u201d is not necessarily to be construed as advantageous over other aspects or designs. Rather, use of the word exemplary is intended to present concepts in a concrete fashion. As used in this application, the term \u201cor\u201d is intended to mean an inclusive \u201cor\u201d rather than an exclusive \u201cor\u201d. That is, unless specified otherwise, or clear from context, \u201cX employs A or B\u201d is intended to mean any of the natural inclusive permutations. That is, if X employs A; X employs B; or X employs both A and B, then \u201cX employs A or B\u201d is satisfied under any of the foregoing instances. In addition, the articles \u201ca\u201d and \u201can\u201d as used in this application and the appended claims may generally be construed to mean \u201cone or more\u201d unless specified otherwise or clear from context to be directed to a singular form.","Also, although the disclosure has been shown and described with respect to one or more implementations, equivalent alterations and modifications will occur to others skilled in the art based upon a reading and understanding of this specification and the annexed drawings. The disclosure includes all such modifications and alterations and is limited only by the scope of the following claims. In particular regard to the various functions performed by the above described components (e.g., elements, resources, etc.), the terms used to describe such components are intended to correspond, unless otherwise indicated, to any component which performs the specified function of the described component (e.g., that is functionally equivalent), even though not structurally equivalent to the disclosed structure which performs the function in the herein illustrated exemplary implementations of the disclosure. In addition, while a particular feature of the disclosure may have been disclosed with respect to only one of several implementations, such feature may be combined with one or more other features of the other implementations as may be desired and advantageous for any given or particular application. Furthermore, to the extent that the terms \u201cincludes\u201d, \u201chaving\u201d, \u201chas\u201d, \u201cwith\u201d, or variants thereof are used in either the detailed description or the claims, such terms are intended to be inclusive in a manner similar to the term \u201ccomprising.\u201d"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 14"}]},"DETDESC":[{},{}]}
