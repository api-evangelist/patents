---
title: Database system providing methodology for extended memory support
abstract: A database system providing methodology for extended memory support is described. In one embodiment, for example, a method is described for extended memory support in a database system having a primary cache, the method comprises steps of: creating a secondary cache in memory available to the database system; mapping a virtual address range to at least a portion of the secondary cache; when the primary cache is full, replacing pages from the primary cache using the secondary cache; in response to a request for a particular page, searching for the particular page in the secondary cache if the particular page is not found in the primary cache; if the particular page is found in the secondary cache, determining a virtual address in the secondary cache where the particular page resides based on the mapping; and swapping the particular page found in the secondary cache with a page in the primary cache, so as to replace a page in the primary cache with the particular page from the secondary cache.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07421562&OS=07421562&RS=07421562
owner: Sybase, Inc.
number: 07421562
owner_city: Dublin
owner_country: US
publication_date: 20040706
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","COPYRIGHT STATEMENT","APPENDIX DATA","BACKGROUND OF INVENTION","SUMMARY OF INVENTION","DETAILED DESCRIPTION"],"p":["The present application is related to and claims the benefit of priority of the following commonly-owned, presently-pending provisional application(s): application Ser. No. 60\/521,158, filed Mar. 1, 2004, entitled \u201cDatabase System Providing Methodology for Extended Memory Support\u201d, of which the present application is a non-provisional application thereof. The disclosure of the foregoing application is hereby incorporated by reference in its entirety, including any appendices or attachments thereof, for all purposes.","A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.","Computer Program Listing Appendix under Sec. 1.52(e): This application includes a transmittal under 37 C.F.R. Sec. 1.52(e) of a Computer Program Listing Appendix. The Appendix, which comprises text file(s) that are IBM-PC machine and Microsoft Windows Operating System compatible, includes the below-listed file(s). All of the material disclosed in the Computer Program Listing Appendix can be found at the U.S. Patent and Trademark Office archives and is hereby incorporated by reference into the present application.","Object Description: SourceCode.txt, size 21 KB, created Mar. 1, 2004 5:43 PM; Object ID: File No. 1; Object Contents: Source Code.","1. Field of the Invention","The present invention relates generally to information processing environments and, more particularly, to a database system providing methodology for extended memory support.","2. Description of the Background Art","Computers are very powerful tools for storing and providing access to vast amounts of information. Computer databases are a common mechanism for storing information on computer systems while providing easy access to users. A typical database is an organized collection of related information stored as \u201crecords\u201d having \u201cfields\u201d of information. As an example, a database of employees may have a record for each employee where each record contains fields designating specifics about the employee, such as name, home address, salary, and the like.","Between the actual physical database itself (i.e., the data actually stored on a storage device) and the users of the system, a database management system or DBMS is typically provided as a software cushion or layer. In essence, the DBMS shields the database user from knowing or even caring about the underlying hardware-level details. Typically, all requests from users for access to the data are processed by the DBMS. For example, information may be added or removed from data files, information retrieved from or updated in such files, and so forth, all without user knowledge of the underlying system implementation. In this manner, the DBMS provides users with a conceptual view of the database that is removed from the hardware level. The general construction and operation of database management systems is well known in the art. See e.g., Date, C., \u201cAn Introduction to Database Systems, Seventh Edition\u201d, Addison Wesley, 2000, the disclosure of which is hereby incorporated by reference.","Database systems are well known and in wide use in a wide range of applications running on a variety of different hardware and operating system platforms. However, the use of database systems on certain platforms is hindered by the limited addressable memory that is available on these platforms. For example, one platform that is in use today is the Linux operating system running on a hardware platform that utilizes 32-bit processors (e.g., Intel 32-bit processors). Using this Linux 32-bit platform can provide a cost effective solution for enterprise level information technology requirements as it can be a less expensive solution than 64-bit architectures. However, applications running on this platform currently have a limitation of only being able to use less than 4 GB (addressable range) of memory on 32-bit architectures. Standard 32-bit addresses can map a maximum of 4 GB of memory. By default, a portion of this memory (e.g., 1 GB or 2 GB) is typically reserved for the operating system, and therefore in practice less than 4 GB is available to an application running on a 32-bit platform. Given that most database server installations are larger than 4 GB, a mechanism for overcoming the memory limitations of these 32-bit platforms is needed in order to facilitate the use of database applications on these platforms.","One current technology that can be used to address this limitation is an Intel \u201cPhysical Address Extension\u201d (PAE) technology which allows more RAM to be used with certain 32-bit systems. Generally, PAE makes 4 extra bits available for the addressing of memory, thereby allowing up to 64 GB of memory to be addressed. With PAE, a system (e.g., an Intel Xeon-based system) can house up to 64 GB of memory on 32-bit platforms as 16 segments of 4 GB per segment. Briefly, PAE is a memory management function that provides more physical memory to a program (e.g., application program) that requests memory. The program (e.g., application) is usually not aware that any of the memory that it uses resides in the range greater than 4 GB. With PAE enabled, the operating system essentially moves from a two-level linear address translation to a three-level address translation. The extra layer of translation is what provides access to physical memory beyond 4 GB. Instead of a linear address being split into three separate fields for indexing into memory tables, it is usually split into four separate fields; a 2-bit field, two 9-bit fields, and a 12-bit field that corresponds to the page size implemented by the Intel architecture (4 KB).","During a context switch a register (e.g., a CR3 register) is set by the operating system to point to a page directory pointer index that is 2-bits wide. The first two bits are used as an index into this table, with the resulting value pointing to a page directory. The first 9-bit field is then used to index into the page directory. The indexed value then points to a page table. The second 9-bit field is an index into the page table. This value points to the actual page in memory where the desired byte is located. Finding this byte is a matter of using the remaining twelve bits of data to index into the page.","PAE allows a processor to address up to 64 GB in theory but, in practice, applications still may not be able to access that much memory without the use of other mechanisms. Currently, an application using the additional memory provided by PAE has to move from segment to segment and keep track of its position. The memory is not mapped by the operating system for the application, so that the application can simply open an address from 0 to 64 GB. Rather, the application itself must generally manage, on its own, the mapping to the extended memory.","Operating system (OS) vendors have provided some mechanisms and application programming interfaces (APIs) to allow applications to address more than 4 GB of memory (RAM) on 32-bit platforms using PAE. For example, on certain Microsoft Windows platforms (e.g., Windows 2000) an \u201cAddress Windowing Extensions\u201d or \u201cAWE\u201d API is available to support larger amounts of physical memory. AWE is a set of extensions to the memory management functions of the Microsoft Win32 API that allow applications to address more memory than the 4 GB that is available through standard 32-bit addressing. AWE lets applications acquire physical memory as non-paged memory, and then dynamically map views of the non-paged memory to the 32-bit address space. Although the 32-bit address space is limited to 4 GB, the non-paged memory can be much larger. This process enables memory-intensive programs, such as large database systems, to reserve large amounts of physical memory for data without having to be paged in and out of a paging file for usage. Instead, the data is swapped in and out of the working set and reserved memory is in excess of the 4 GB range. Although the Address Windowing Extensions enable memory-intensive applications (e.g., large database systems) to address more memory than can be supported in a 32-bit address space, the AWE mechanism is available only certain Windows platforms and is currently not supported on other platforms (e.g., Linux platforms).","Although the above discussion refers to the addressable memory limitations of 32-bit platforms, this is only one example of a more general problem. Memory limitations may also be applicable and may impact the performance of database systems on various other platforms. Given any arbitrary physical memory constraint that may be applicable, what is needed is a solution that enables memory-intensive applications, such as large database systems, to utilize extended memory for overcoming these limitations. For example, one may wish to implement an application in an environment in which a portion of the memory for the application is provided on a first device and another portion of the memory is provided on a second device (e.g., a less expensive device such as a file server or the like). Consider, for instance, an environment including a cluster of machines. It is would be desirable to be able to provide extended memory on various machines in the cluster and have a mechanism that mapped to extended memory located anywhere in the cluster. What is needed is a system and methodology for mapping to extended memory on various devices so that an application can bring data in from various sources without needing to know or be concerned about the underlying location of this data.","In a typical database application, the memory that is required by the database system is mostly used for data caches. For example, all or portion of a table or index is loaded from disk into cache memory to facilitate access to such data and avoid expensive disk reads and writes which can also serve to increase latency. In a typical database server implementation, a major portion of memory utilization (e.g., on the order of 90 percent of memory utilization) relates to data caches, while a much smaller portion (e.g., the remaining 10 percent) relates to connection caches and other miscellaneous purposes. What is needed is a solution providing for caching data in memory which reduces the frequency of read and write operations from disk, thereby reducing the impact of these operations on system performance.","One approach that has been used in an attempt to overcome the memory limitations of certain platforms is to use operating system provided file systems or other such devices to provide extended memory to an application. However, in a transaction processing environment, a mechanism of this type (e.g., an operating system file system) does not support the transaction needs of a database server system. For one thing, using this type of mechanism makes it very difficult to optimize the execution of transactions. Also, this mechanism is not extensible and it usually forces one to choose one particular interface on a particular platform. A more flexible and extensible approach that can be plugged into various implementations in order to provide extended memory support to memory-intensive applications is desired.","What is needed is a solution which enables memory intensive applications, such as large database systems, to address more memory than can be supported in the address space of a given platform (e.g., a 32-bit platform). Ideally, the solution should provide extended memory support without requiring the application using the extended memory to be concerned about the details involved in mapping to or otherwise managing the extended memory. The present invention provides a solution for these and other needs.","A database system providing methodology for extended memory support is described. In one embodiment, for example, a method of the present invention is described for extended memory support in a database system having a primary cache, the method comprises steps of: creating a secondary cache in memory available to the database system; mapping a virtual address range to at least a portion of the secondary cache; when the primary cache is full, replacing pages from the primary cache using the secondary cache; in response to a request for a particular page, searching for the particular page in the secondary cache if the particular page is not found in the primary cache; if the particular page is found in the secondary cache, determining a virtual address in the secondary cache where the particular page resides based on the mapping; and swapping the particular page found in the secondary cache with a page in the primary cache, so as to replace a page in the primary cache with the particular page from the secondary cache.","In another embodiment, for example, a database system of the present invention providing extended memory support is described that comprises: a primary cache for maintaining data pages used by the database system in addressable memory available to the database system; a secondary cache for maintaining data pages replaced from the primary cache in extended memory available to the database system; a search module for receiving a request from a user for a particular data page and determining whether the particular data page is in secondary cache if the particular data page is not in the primary cache; and a module for replacing a data page in the primary cache with the particular data page from the secondary cache if the particular data page is found in the secondary cache.","Glossary","The following definitions are offered for purposes of illustration, not limitation, in order to assist with understanding the discussion that follows.","Relational database: A relational database is a collection of data items organized as a set of formally-described tables from which data can be accessed or reassembled in many different ways without having to reorganize the database tables. The relational database was invented by E. F. Codd at IBM in 1970. A relational database employs a set of tables containing data fitted into predefined categories. Each table (which is sometimes called a relation) contains one or more data categories in columns. A feature of a relational database is that users may define relationships between the tables in order to link data that is contained in multiple tables. The standard user and application program interface to a relational database is the Structured Query Language (SQL), defined below.","Shmfs: Shmfs refers to shared memory file system (also sometimes referred to as virtual memory file system), which is a file system that keeps files in virtual memory. The shared memory file system (shmfs) is included as a component of the 32-bit Linux operating systems, including Red Hat Linux 3.0 and SuSe Linux 8.0. Like tmpfs (defined below), shmfs is a file system type that works directly in the memory management code of the kernel.","SQL: SQL stands for Structured Query Language, which has become the standard for relational database access, see e.g., \u201cInformation Technology\u2014Database languages\u2014SQL\u201d, published by the American National Standards Institute as American National Standard ANSI\/ISO\/IEC 9075: 1992, the disclosure of which is hereby incorporated by reference. For additional information regarding SQL in database systems, see e.g., Date, C., \u201cAn Introduction to Database Systems, Seventh Edition\u201d, Addison Wesley, 2000, the disclosure of which is hereby incorporated by reference.","Thread: A thread refers to a single sequential flow of control within a program. Operating systems that support multi-threading enable programmers to design programs whose threaded parts can execute concurrently. In some systems, there is a one-to-one relationship between the task and the program, but a multi-threaded system allows a program to be divided into multiple tasks. Multi-threaded programs may have several threads running through different code paths simultaneously.","Tmpfs: Tmpfs (tmpfs) stands for temporary file system, which is a file system which keeps all files in virtual memory. This file system is temporary in the sense that no files are created on a system's hard drive and if the system is rebooted the files in tmpfs will be lost. In contrast to RAM disks, which get allocated a fixed amount of physical RAM, tmpfs grows and shrinks to accommodate the files it contains and is able to swap unneeded pages out to swap space. Tmpfs does not use traditional non-volatile media to store file data; instead, tmpfs files exist solely in virtual memory maintained by the operating system kernel (e.g., a UNIX or LINUX operating system kernel). Because tmpfs file systems do not use dedicated physical memory for file data but instead use virtual memory system resources and facilities, they can take advantage of kernel resource management policies. Tmpfs is designed primarily as a performance enhancement to allow short-lived files to be written and accessed without generating disk or network input\/output (I\/O). For further information on tmpfs, see e.g., Synder, P., \u201ctmpfs, A Virtual Memory File System\u201d, available from Sun Microsystems, Inc., the disclosure of which is hereby incorporated by reference.","Introduction","Referring to the figures, exemplary embodiments of the invention will now be described. The following description will focus on the presently preferred embodiment of the present invention, which is implemented in desktop and\/or server software (e.g., driver, application, or the like) operating in an Internet-connected environment running under an operating system, such as the Microsoft Windows operating system. The present invention, however, is not limited to any one particular application or any particular environment. Instead, those skilled in the art will find that the system and methods of the present invention may be advantageously embodied on a variety of different platforms, including Macintosh, Linux, Solaris, UNIX, FreeBSD, and the like. Therefore, the description of the exemplary embodiments that follows is for purposes of illustration and not limitation. The exemplary embodiments are primarily described with reference to block diagrams or flowcharts. As to the flowcharts, each block within the flowcharts represents both a method step and an apparatus element for performing the method step. Depending upon the implementation, the corresponding apparatus element may be configured in hardware, software, firmware, or combinations thereof.","Computer-Based Implementation","Basic System Hardware (e.g., for Desktop and Server Computers)","The present invention may be implemented on a conventional or general-purpose computer system, such as an IBM-compatible personal computer (PC) or server computer.  is a very general block diagram of a computer system (e.g., an IBM-compatible system) in which software-implemented processes of the present invention may be embodied. As shown, system  comprises a central processing unit(s) (CPU) or processor(s)  coupled to a random-access memory (RAM) , a read-only memory (ROM) , a keyboard , a printer , a pointing device , a display or video adapter  connected to a display device , a removable (mass) storage device  (e.g., floppy disk, CD-ROM, CD-R, CD-RW, DVD, or the like), a fixed (mass) storage device  (e.g., hard disk), a communication (COMM) port(s) or interface(s) , a modem , and a network interface card (NIC) or controller  (e.g., Ethernet). Although not shown separately, a real time system clock is included with the system , in a conventional manner.","CPU  comprises a processor of the Intel Pentium family of microprocessors. However, any other suitable processor may be utilized for implementing the present invention. The CPU  communicates with other components of the system via a bi-directional system bus (including any necessary input\/output controller circuitry and other \u201cglue\u201d logic). The bus, which includes address lines for addressing system memory, provides data transfer between and among the various components. Description of Pentium-class microprocessors and their instruction set, bus architecture, and control lines is available from Intel Corporation of Santa Clara, Calif. Random-access memory  serves as the working memory for the CPU . In a typical configuration, RAM of sixty-four megabytes or more is employed. More or less memory may be used without departing from the scope of the present invention. The read-only memory (ROM)  contains the basic input\/output system code (BIOS)\u2014a set of low-level routines in the ROM that application programs and the operating systems can use to interact with the hardware, including reading characters from the keyboard, outputting characters to printers, and so forth.","Mass storage devices ,  provide persistent storage on fixed and removable media, such as magnetic, optical or magnetic-optical storage systems, flash memory, or any other available mass storage technology. The mass storage may be shared on a network, or it may be a dedicated mass storage. As shown in , fixed storage  stores a body of program and data for directing operation of the computer system, including an operating system, user application programs, driver and other support files, as well as other data files of all sorts. Typically, the fixed storage  serves as the main hard disk for the system.","In basic operation, program logic (including that which implements methodology of the present invention described below) is loaded from the removable storage  or fixed storage  into the main (RAM) memory , for execution by the CPU . During operation of the program logic, the system  accepts user input from a keyboard  and pointing device , as well as speech-based input from a voice recognition system (not shown). The keyboard  permits selection of application programs, entry of keyboard-based input or data, and selection and manipulation of individual data objects displayed on the screen or display device . Likewise, the pointing device , such as a mouse, track ball, pen device, or the like, permits selection and manipulation of objects on the display device. In this manner, these input devices support manual user input for any process running on the system.","The computer system  displays text and\/or graphic images and other data on the display device . The video adapter , which is interposed between the display  and the system's bus, drives the display device . The video adapter , which includes video memory accessible to the CPU , provides circuitry that converts pixel data stored in the video memory to a raster signal suitable for use by a cathode ray tube (CRT) raster or liquid crystal display (LCD) monitor. A hard copy of the displayed information, or other information within the system , may be obtained from the printer , or other output device. Printer  may include, for instance, an HP LaserJet printer (available from Hewlett Packard of Palo Alto, Calif.), for creating hard copy images of output of the system.","The system itself communicates with other devices (e.g., other computers) via the network interface card (NIC)  connected to a network (e.g., Ethernet network, Bluetooth wireless network, or the like), and\/or modem  (e.g., 56K baud, ISDN, DSL, or cable modem), examples of which are available from 3Com of Santa Clara, Calif. The system  may also communicate with local occasionally-connected devices (e.g., serial cable-linked devices) via the communication (COMM) interface , which may include a RS-232 serial port, a Universal Serial Bus (USB) interface, or the like. Devices that will be commonly connected locally to the interface  include laptop computers, handheld organizers, digital cameras, and the like.","IBM-compatible personal computers and server computers are available from a variety of vendors. Representative vendors include Dell Computers of Round Rock, Tex., Hewlett-Packard of Palo Alto, Calif., and IBM of Armonk, N.Y. Other suitable computers include Apple-compatible computers (e.g., Macintosh), which are available from Apple Computer of Cupertino, Calif., and Sun Solaris workstations, which are available from Sun Microsystems of Mountain View, Calif.","Basic System Software",{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 2","b":["100","200","100","200","102","116","210","210","201","201","201","201","201","116","102","100","100"],"i":["a","b","c","d"]},"Software system  includes a graphical user interface (GUI) , for receiving user commands and data in a graphical (e.g., \u201cpoint-and-click\u201d) fashion. These inputs, in turn, may be acted upon by the system  in accordance with instructions from operating system , and\/or client application module(s) . The GUI  also serves to display the results of operation from the OS  and application(s) , whereupon the user may supply additional inputs or terminate the session. Typically, the OS  operates in conjunction with device drivers  (e.g., \u201cWinsock\u201d driver\u2014Windows' implementation of a TCP\/IP stack) and the system BIOS microcode  (i.e., ROM-based microcode), particularly when interfacing with peripheral devices. OS  can be provided by a conventional operating system, such as Microsoft Windows 9x, Microsoft Windows NT, Microsoft Windows 2000, or Microsoft Windows XP, all available from Microsoft Corporation of Redmond, Wash. Alternatively, OS  can also be an alternative operating system, such as the previously mentioned operating systems.","Client-server Database Management System","While the present invention may operate within a single (standalone) computer (e.g., system  of ), the present invention is preferably embodied in a multi-user computer system, such as a client\/server system.  illustrates the general structure of a client\/server database system  suitable for implementing the present invention. As shown, the system  comprises one or more client(s)  connected to a server  via a network . Specifically, the client(s)  comprise one or more standalone terminals  connected to a database server system  using a conventional network. In an exemplary embodiment, the terminals  may themselves comprise a plurality of standalone workstations, dumb terminals, or the like, or comprise personal computers (PCs) such as the above-described system . Typically, such units would operate under a client operating system, such as a Microsoft\u00ae Windows client operating system (e.g., Microsoft\u00ae Windows 95\/98, Windows 2000, or Windows XP).","The database server system , which comprises Sybase\u00ae Adaptive Server\u00ae Enterprise (available from Sybase, Inc. of Dublin, Calif.) in an exemplary embodiment, generally operates as an independent process (i.e., independently of the clients), running under a server operating system such as Microsoft\u00ae Windows NT, Windows 2000, or Windows XP (all from Microsoft Corporation of Redmond, Wash.), UNIX (Novell), or Linux (Red Hat). The network  may be any one of a number of conventional network systems, including a Local Area Network (LAN) or Wide Area Network (WAN), as is known in the art (e.g., using Ethernet, IBM Token Ring, or the like). Network  includes functionality for packaging client calls in the well-known SQL (Structured Query Language) together with any parameter information into a format (of one or more packets) suitable for transmission across a cable or wire, for delivery to the database server system .","Client\/server environments, database servers, and networks are well documented in the technical, trade, and patent literature. For a discussion of Sybase\u00ae-branded database servers and client\/server environments generally, see, e.g., Nath, A., \u201cThe Guide to SQL Server\u201d, Second Edition, Addison-Wesley Publishing Company, 1995. For a description of Sybase\u00ae Adaptive Server\u00ae Enterprise, see, e.g., \u201cAdaptive Server Enterprise 12.5 Product Documentation\u201d, available from Sybase, Inc. of Dublin, Calif. This product documentation is available via the Internet (e.g., currently at sybooks.sybase.com\/asg1250e.html). The disclosures of the foregoing are hereby incorporated by reference.","In operation, the client(s)  store data in, or retrieve data from, one or more database tables , as shown at . Typically resident on the server , each table itself comprises one or more rows or \u201crecords\u201d (tuples) (e.g., row ), each storing information arranged by columns or \u201cfields\u201d. A database record includes information which is most conveniently represented as a single unit. A record for an employee, for example, may include information about the employee's ID Number, Last Name and First Initial, Position, Date Hired, Social Security Number, and Salary. Thus, a typical record includes several categories of information about an individual person, place, or thing. Each of these categories, in turn, represents a database field. In the foregoing employee table, for example, Position is one field, Date Hired is another, and so on. With this format, tables are easy for users to understand and use. Moreover, the flexibility of tables permits a user to define relationships between various items of data, as needed.","In operation, the clients  issue one or more SQL commands to the server . SQL commands may specify, for instance, a query for retrieving particular data (i.e., data records meeting the query condition) from the database table(s) . The syntax of SQL (Structured Query Language) is well documented; see, e.g., the above-mentioned \u201cAn Introduction to Database Systems\u201d. In addition to retrieving the data from database server table(s) , the clients  also include the ability to insert new rows of data records into the table. In addition, the clients can also modify and\/or delete existing records in the table(s).","In operation, the SQL statements received from the client(s)  (via network ) are processed by the engine  of the database server system . The engine  itself comprises parser , normalizer , compiler , execution unit , and access methods . Specifically, the SQL statements are passed to the parser  which converts the statements into a query tree\u2014a binary tree data structure which represents the components of the query in a format selected for the convenience of the system. In this regard, the parser  employs conventional parsing methodology (e.g., recursive descent parsing).","The query tree is normalized by the normalizer . Normalization includes, for example, the elimination of redundant data. Additionally, the normalizer  performs error checking, such as confirming that table names and column names which appear in the query are valid (e.g., are available and belong together). Finally, the normalizer  can also look-up any referential integrity constraints which exist and add those to the query.","After normalization, the query tree is passed to the compiler , which includes an optimizer  and a code generator . The optimizer is responsible for optimizing the query tree. The optimizer  performs a cost-based analysis for formulating a query execution plan. The optimizer will, for instance, select the join order of tables (e.g., when working with more than one table); it will select relevant indexes (e.g., when indexes are available). The optimizer, therefore, performs an analysis of the query and selects the best execution plan, which in turn results in particular access methods being invoked during query execution.","For enhancing the storage, retrieval, and processing of data records, the server  maintains one or more database indexes  on the database tables . These database indexes  facilitate quick access to the data records. A database index, typically maintained as a B-Tree data structure, allows the records of a table to be organized in many different ways, depending on a particular user's needs. An index may be constructed as a single disk file storing index key values together with unique record numbers. An index key value is a data quantity composed of one or more fields from a record which are used to arrange (logically) the database file records by some desired order (index expression). The record numbers are unique pointers to the actual storage location of each record in the database file. Both are referred to internally by the system for locating and displaying records in a database file.","The above-described computer hardware and software are presented for purposes of illustrating the basic underlying desktop and server computer components that may be employed for implementing the present invention. For purposes of discussion, the following description will present examples in which it will be assumed that there exists a \u201cserver\u201d (e.g., database server) that communicates with one or more \u201cclients\u201d (e.g., personal computers such as the above-described system ). The present invention, however, is not limited to any particular environment or device configuration. In particular, a client\/server distinction is not necessary to the invention, but is used to provide a framework for discussion. Instead, the present invention may be implemented in any type of system architecture or processing environment capable of supporting the methodologies of the present invention presented in detail below.","Overview of Database System Providing Methodology for Extended Memory Support","Shared Secondary Cache","In operation, a database system needs to be able to allocate memory to hold things such as indexes, tables, and the like. It is advantageous to cache this type of data in memory so that the data does not have to be brought into memory from an external source (e.g., disk) each time an operation on the data is to be performed. However, as described above, hardware platforms have limitations on the memory that is available to database applications for these purposes. For example, on certain 32-bit platforms (e.g., Intel-based 32-bit hardware platforms running the Linux operating system) less than 4 GB of addressable memory is available. The present invention provides extended memory support enabling memory-intensive applications to be used on systems having these types of limitations.","As described above, the primary cache that is available to an application (e.g., a database server) is often limited. To the extent that the data used by the application is not available in the primary cache, it needs to be brought in from another source (e.g., from disk or other external storage). However, disk reads\/writes are expensive and adversely impact performance of the application. The present invention provides extended memory support though the creation of a secondary cache which acts like a swap space for the primary cache. As described below in greater detail, the methodology of the present invention provides for one global secondary cache which is shared by all of the primary cache. This secondary or \u201ce xtended\u201d cache serves a similar role to that of a second level cache (L2 cache) associated with a processor. Pages from the primary data cache spill over to the secondary cache. Data pages are replaced from the primary cache as part of buffer wash operation. In operation, if a page is not found in the primary cache, the secondary (extended cache) is searched for the page. If found, the page is brought into the primary cache from the secondary cache, thereby avoiding the need to read the page in from disk.","In its currently preferred embodiment, the present invention makes use of a shared memory file system feature (\u201cshmfs\u201d) and a memory mapped file feature (\u201cmmap\u201d) available on Linux platforms. A shmfs file is created and the database system maps a virtual address range (window) to the portion of the shmfs file through the mmap interface. This mechanism enables the database system to address a portion of memory mapped shmfs file whose size can be as large as 64 G. This memory mapped file space is used as a secondary cache from which the system replaces the pages from the primary cache. The system can also search the secondary cache to see if a given page is cached in the secondary cache. While searching for a given page, if that page is cached in the secondary cache, the system maps a virtual address window to that portion of the shmfs where the page resides and copies it to the primary cache. By doing so, the system avoids disk reads while making effective use of memory through the shmfs file system interface.","The system and methodology of the present invention is currently commercially embodied as a component of a Sybase\u00ae Adaptive Server\u00ae Enterprise database system (from Sybase, Inc. of Dublin, Calif.) running on the Linux operating system and provides extended memory support while at the same time minimizing the resources required to deliver this functionality. The system of the present invention can also be modularized in its implementation so that it will not affect existing functionalities of the database system in which it is implemented. Before describing the system and methodology of the present invention in more detail, some other alternative approaches will be discussed.","Virtual Address Window for Each Database Engine","One class of solutions for providing extended memory support provides for creating a window of virtual addresses in each database engine. These virtual addresses can either map\/unmap dynamically or map permanently to a physical address in that engine. On Linux systems this is typically implemented by using a \u201cwindow\u201d of virtual address space, which keeps moving over a shared memory file system.","The Sybase\u00ae Adaptive Server\u00ae Enterprise database management system in which the present invention is commercially embodied includes a native thread implementation to serve each database user. In the currently preferred embodiment, each operating system (OS) process is a database server engine and each engine is capable of managing many user threads. Also, threads can move freely from one engine to another because the entire context associated with a thread is in shared memory and shared memory is visible to all of the database server engines. This provides for efficiency in terms of load balancing and resource utilization.","With the above architecture in place one cannot follow the threading model as seen in certain other database engines where each engine can be a thread (i.e., any mapping that happens at the process level can be seen by all the threads). Although this approach of having each engine as a thread is an inexpensive way of addressing more than 4 GB of memory, it requires substantial change in database systems that do not currently implement engines as operating system (OS) threads. The present invention provides for extended memory support in a database system without requiring the database system to be re-written to implement database engines as operating system threads.","Statically Mapped Window","Another possible approach for providing extended memory support is to utilize a statically mapped window. This statically mapped window approach provides for reserving a certain amount of memory (e.g., 500 MB) as a virtual address space. Engines are then spawned to map this 500 MB of virtual address space to a physical address, (e.g., for 16 GB of main memory approximately 28 engines would be spawned\u2014(16\u22122.2)\/0.5=28 engines). Each engine essentially \u201cowns\u201d (i.e., is responsible for) extended memory of 500 MB. A global chain of auxiliary buffers, which are visible on all engines, is also maintained. From this chain each engine knows at which engine a given auxiliary buffer resides. During a buffer replacement (i.e., bufgrab) the following occurs: (1) unhash the grabbed buffer; (2) switch from the current engine to where the target auxiliary buffer resides; and (3) swap the content of the buffer with the auxiliary buffer. The benefits of this statically mapped window approach include that there is no map\/unmap operation required, and no shmfs (shared memory file system) or tmpfs (temporary file system) on the extended memory. The disadvantages include copying (minimum of 2 copies), task context switch to a different engine, and too many engines.","A statically mapped window system incurs a context switch from engine to engine when accessing a targeted page. Additionally, this approach means that the washing mechanism needs to extend to the extended memory, and unnecessary writes should not be issued. Another consideration is that the log cannot use extended memory. A checkpoint needs to be established to take into account flushing extended memory. Resource overhead also is a consideration when using a statically mapped window. The extended cache has to have an engine local LRU\/MRU (least recently used\/most recently used) chain. The solution also requires a global hash function, in the shared memory, to access the auxiliary buffer. In addition, a window of addresses needs to be reserved to access the auxiliary buffers.","Shmfs\/tmpfs on the Extended Memory with Multiple Addresses for a Given Page","Another approach provides for using shmfs\/tmpfs (shared memory file system\/temporary memory file system) on the extended memory with multiple addresses for a given page. In implementing this solution, a memory mapped file system is created, and using a window this system can map or unmap at various offsets on the file. This method has multiple addresses for a given page and each in-memory page has an engine-specific virtual address. The entire buffer cache is in the shmfs (shared memory file system) and pages from the disk are brought into the shmfs.",{"@attributes":{"id":"p-0079","num":"0078"},"figref":["FIG. 4","FIG. 4"]},{"@attributes":{"id":"p-0080","num":"0079"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u20021:","If(bufsearch( ) returns success)"]},{"entry":[{},"\u20022:","{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u20023:","if(buffer is not mapped)"]},{"entry":[{},"\u20024:","{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u20025:","free_addr = grabVirtualAdd( );"]},{"entry":[{},"\u20026:","mmap(addr, boffset, size, fd);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u20027:","}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u20028:","}"]},{"entry":[{},"\u20029:","else"]},{"entry":[{},"10:","{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"11:","bp = bufgrab( );"]},{"entry":[{},"12:","if( buffer is not mapped)"]},{"entry":[{},"13:","{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"14:","free_addr = grabVirtualAdd( );"]},{"entry":[{},"15:","mmap(addr, boffset, size, fd);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"16:","}"]},{"entry":[{},"17:","bufread(bp);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"18:","}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"The advantages of this method of creating shmfs\/tmpfs on the extended memory include that no copying is required, there is no context switch, and the solution provides a predictable performance. However, using shmfs\/tmpfs on the extended memory with multiple addresses for a given page is both overly complex and costly in terms of resource usage, specifically the cost of unmap\/map to shmfs and the large resource overhead. Issues with this method include that when a task switches from one engine to another, it needs to be ensured that there is a valid map before the page is accessed. For example, I\/O completion routines should have access to a mapped address. Also, another consideration is a scenario in which there are no free virtual addresses.","With respect to resource overhead, each buffer pool (bp) needs to have N (number of engines) 32-bit values to store the virtual address, apart from one 64-bit value to store the offset and one N bit word to store the status. For example, with 8 engines, 8*4+8+1=41 bytes would be needed. It should be noted that this method may need N (number of engines) to be equal to the maximum number of engines that are possible, as engines can come offline and online dynamically. Additionally, the number of bps increases substantially and can reduce addressing a window of 2.7 G. For example, to maintain bps for 8 GB memory it may require 700 MB of data. For a 2K page size max it could be increased up to 16 GB, and for a 4K max it would be approximately 32 GB. To avoid this, a hierarchical data structure to maintain bps may be required, as well as maintaining a list of free virtual addresses. This can take 16 bytes per entry\/per virtual address.","Extended Memory Support-shmfs as Secondary Storage (L2 Cache)","The approach of the present invention provides for utilizing a secondary cache as secondary storage (i.e., secondary or L2 cache). In the currently preferred embodiment, the secondary cache is implemented as a shared memory file system (shmfs). This approach of using shmfs as secondary storage strikes a balance between the method of using a statically mapped window, and the alternative method of creating shmfs\/tmpfs on the extended memory with multiple addresses for a given page. The advantages of the methodology of the present invention include not incurring a context switch from engine to engine as with the statically mapped window method. The present invention also consumes less resources than the approach of using shmfs\/tmpfs on the extended memory. Experience indicates that the methodology of the present invention for using shmfs as secondary storage provides improved performance compared to these other approaches. With shmfs as secondary storage the copying process can be optimized by limiting the copy to only 2 buffers. In terms of complexity this solution is also more modular and less complex to implement.","The secondary cache provided in accordance with the system and methodology of the present invention avoid disk input\/output (I\/O) operations when pages are found in the secondary cache. Configuring a large secondary cache is particularly useful in database implementations in which the primary cache is limited. For example, a Linux 32-bit OS platform is generally limited to an addressable range of 2.7 GB from the process (application) perspective. With a cache size of only 2.7 GB, a database application will frequently issue I\/Os (i.e., input\/output operations) on both raw devices and file system devices. However, with the extended cache provided in accordance with the present invention, the number of I\/Os that are required are considerably less, thereby yielding better performance. With a benchmark of an OLTP (on-line transaction processing) workload with 50\/50 read and write ratio, the current implementation of the present invention demonstrates a 200% improvement compared to raw devices, and 30% improvement compared to file system devices.","The advantages of using shmfs as secondary storage includes that it allows for optimal resource usage, that no context switch is required, and that it provides for predictable performance. More particularly, the methodology of the present invention consumes less resources than the approach of creating shmfs\/tmpfs on the extended memory and avoids the context switch of the statically mapped window approach. Disadvantages of the methodology include the unmap\/map operations and the fact that it may require up to three copies. In order to properly implement the methodology of the present invention for using shmfs as secondary storage, washing needs to be extended to the secondary cache, and checkpointing also has to take care of secondary cache. Additionally, writes of the secondary cache can be difficult and somewhat complex. It should be noted that the resource overhead, for an 8 GB segment of shared memory with a 2 k page size, for maintaining the LRU\/MRU list associated with the secondary cache could cost approximately 128 MB. The following discussion will examine the methodology of the present invention in more detail, including how a miss in the primary cache is handled, and how other operations involving the secondary cache are performed.","Detailed Operation","The following description presents method steps that may be implemented using processor-executable instructions, for directing operation of a device under processor control. The computer-executable instructions may be stored on a computer-readable medium, such as CD, DVD, flash memory, or the like. The processor-executable instructions may also be stored as a set of downloadable processor-executable instructions, for example, for downloading and installation from an Internet location (e.g., Web server).","Structure of Secondary Cache","The following discussion describes the currently preferred embodiment of the present invention which provides for utilizing shmfs (shared memory file system) as the secondary cache. However, the present invention can also be implemented in other environments. In an alternative embodiment, for instance, the secondary cache could be supported on external memory (e.g., a file server or the like). For example, the present invention can be implemented in a cluster environment. Portions of the extended memory could be supported on various machines in the cluster with the present invention providing a mapping mechanism so that the extended memory could be located anywhere in the cluster.","The system and methodology of the present invention provides an abstraction layer or API which enables an application to obtain pages from a secondary cache without having to know or be concerned about the actual location of data pages in the secondary cache. This abstraction also enables the secondary cache to be supported on various types of systems and devices. For instance, the abstract API provided by the present invention may enable data to be brought in from various different machines in a cluster. The abstraction layer provides for a maintaining a set of offsets which indicate that a particular page is at a particular offset. The system of the present invention underneath maps where the offset is and so forth, but from the standpoint of an application requesting a particular page this is completely abstracted. The offset to the physical memory of the data implementation is provided by the kernel services which in the currently preferred embodiment uses shared memory (i.e., the shmfs) and the memory mapped file interface to provide such an offset.","In the currently preferred embodiment on a hardware platform running the Linux operating system, shared memory will include the primary cache, and will have a data structure which includes a list pointing to pages in the secondary store (cache). A LRU\/MRU (least recently used\/most recently used) chain of offsets and the corresponding page it is holding is maintained. An example of an entry in this LRU\/MRU list is as follows:",{"@attributes":{"id":"p-0092","num":"0091"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"1:","struct sec_cache_entry"]},{"entry":[{},"2:","{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"3:","LINK ecache_link; \/* to maintain LRU\/MRU chain *\/"]},{"entry":[{},"4:","long offset ; \/* offset in the shmfs *\/"]},{"entry":[{},"5:","short status; \/* Needed for bookkeeping *\/"]},{"entry":[{},"6:","pgid_t pageno; \/* Page num *\/"]},{"entry":[{},"7:","dbid_t dbid; \/* dbid *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"8:","};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"The structure provides translation from the page to the offset. But that offset is not just a translation, it is also a mapping. The offset enables the system to go and find out the actual location of where a particular page where is stored. The abstraction layer provided by the present invention is illustrated as the above structure simply provides that a particular page (identified by page number or pageno at line ) is at a given offset (as provided at line ). The dbid at line  identifies the database. The LRU\/MRU list entry can be around 32 bytes (1 cache line) per page in the secondary cache.","The secondary cache provided by the present invention also supports the specific transactional needs required in a database system. Only certain types of data are stored in the secondary cache provided by the present invention. An operating system cache, in contrast, is a very generic cache that does not have knowledge of the underlying data. The system of the present invention selectively determines the appropriate items to be brought into the cache based on the workload of the system. Generally, the secondary cache serves as a data cache for databases and brings in tables containing data, meta-data, indexes, and page chain information. Other items that are less useful to maintain in cache are excluded. For example, the log is not brought into the secondary cache. System catalogs are also typically not brought into the secondary cache.","In the currently preferred embodiment of the present invention, the criteria (or rules) for placing a page (buffer) in the secondary cache include the following:","The buffer does not contain a log page.","The buffer is not destroyed and is not in writing.","The buffer belongs to the lowest buffer pool (bmass_head=bmass_tail). This means it is of the lowest size of the pool and the pages are ones that get replaced.","The buffer does not have dbid=0. In other words the buffer does belong to a database.","The object id in the buffer is not 0 (i.e, it is a valid object).","The buffer is not a system object.","The buffer is not a SORT buffer.","The above are specific criteria that require knowledge of the workload to determine what to put into the cache (i.e., secondary cache). The system of the present invention uses this knowledge to avoid using secondary cache for objects that are not useful to maintain in cache. Unlike an operating system cache, which generally does not have any useful information on the workload, the present invention uses its knowledge of the workload to an advantage so that the items retained in cache are likely to be useful. The pages in the secondary cache are pages that have spilled over from the primary cache and are maintained in the cache on a MRU\/LRU basis. This approach ensures that the secondary cache is populated with items that are likely to be needed.","Secondary Cache in Operation",{"@attributes":{"id":"p-0105","num":"0104"},"figref":["FIG. 5","FIG. 5"],"b":["520","510","530","1","520","1","2","530"]},"The following example illustrates how the secondary cache may be used in operation. Assume that page P is needed for a transaction that is being performed by the engine . If page P is not found in the primary cache , then methodology of the present invention provides for searching for page P in the secondary cache . This involves a search of an internal data structure that maintains offsets for pages in the secondary cache. If the page P is found during this search, the method proceeds to fetch the page P which is at the offset (i.e., offset O) indicated in the internal data structure. Page P is then swapped with page P in the primary cache. As a result, pages P and P are exchanged, with P going to the secondary cache  and P going to the primary cache . From the standpoint of the application, it does not need to be concerned about whether the requested page (i.e., page P in this example) is in the primary or secondary cache. The application simply requests the desired page (e.g., page P) and the system handles the process of searching for the desired page and making it available.","The following illustrates the operations involved in a swapping the page P found in the secondary cache with page P in the primary cache:\n\n","As shown at line , the offset O is first mapped to the given virtual address V (a free virtual address). The content of V (grabbed buffer) is then moved to a temporary buffer T as illustrated at line . Next, the content of page P is moved to V (i.e., the grabbed buffer) as provided at line . In other words, page P is copied to V in the primary cache. After page P has been moved to the primary cache, page P can be moved to the secondary cache. As shown at line , page P in the temporary buffer T is moved into the secondary cache at offset O. At line , the virtual address is unmapped. At the point the swap is done and page P has been exchanged with page P. It should be noted that the page P can be located anywhere and no assumption is made about the underlying device or location where it is stored. The page can simply be requested and the system of the present invention takes care of the necessary details in locating the page and making it available.","Reading from the Disk","Reading from disk occurs when data is not present in either the primary cache or the secondary cache. There are two types of reads, which are referred to as \u201ccold reads\u201d, and \u201cwarm reads\u201d. Cold reads occur when the primary cache is not full. Warm reads occur when the primary cache is filled with pages. In the case of cold reads, there are free unused buffers in the primary cache. With warm reads there may or may not be a free buffer in the secondary cache, however, all the buffers in the primary cache are used.",{"@attributes":{"id":"p-0111","num":"0115"},"figref":["FIG. 6A","FIG. 6A","FIG. 6A"],"b":["651","620","651","620","629","620","651","630"]},{"@attributes":{"id":"p-0112","num":"0116"},"figref":["FIG. 6B","FIG. 6B"],"b":["653","620","650","620","627","627","620","653","653","627","627","630","630","637"],"i":["a ","a","a","a ","a ","a "]},"In the warm read from disk scenario illustrated at , the following operations occur:\n\n","As shown at (1) at , the above operation involves coping the page Pr from the primary cache to the secondary cache to create space in the primary cache. After this takes place, the offset Os of the new page in the secondary cache (Pr) is added to the MRU end of the list as shown at (2) at . After space is cleared in the primary cache, the page Pd is read into the primary cache (i.e., from the disk) at (3) at . The page Pd is read into the primary cache at the address Vr from which the page Pr was removed.",{"@attributes":{"id":"p-0115","num":"0124"},"figref":"FIG. 7","b":["700","701","702"]},"If primary cache was not full, the page could simply be read from disk to the primary cache (i.e., a \u201ccold read\u201d) as described above. However, in this case the primary cache is full, so before reading in the page Pd from disk, room must be made in the primary cache for the page being pulled in from the disk. Rather than throwing out a page or writing it to disk, the methodology of the present invention provides for creating space in the primary cache by moving a page from the primary cache to the secondary cache.","At step , a least recently used (LRU) list that is maintained to indicate pages that have not be recently used is consulted to determine the page in the primary cache that is to be moved to the secondary cache. In this example, page Pr having an address Vr is selected from the primary cache. As described above, a MRU\/LRU list is also maintained for the secondary cache. At step , a page in the secondary cache is selected from the LRU end of the MRU\/LRU list maintained for the secondary cache. In this case, page Ps at offset Os is selected. This page may be either a free or valid page. For purposes of this example, assume that the page (i.e., page Ps at offset Os using this same example) is free as the secondary cache is not full. However, it should be noted that if the secondary cache is full and page Ps is valid, some additional steps may be necessary to write the page Ps from the secondary cache to disk before it is replaced in the secondary cache.","At step , the page (page Pr) is moved from the primary cache to the secondary cache at the location of the page Ps (i.e., at offset Os). At step , the page at offset Os is added to the MRU end of the MRU\/LRU list maintained for the secondary cache.","After the page Pr has been moved to the secondary cache, page Pd is read in from the disk to the primary cache at step . Page Pd is placed in the location just vacated by page Pr at address Vr. It should be noted that only one copy is incurred in this scenario. Also note that page Ps in the secondary cache might be a valid page. In that case, page Ps gets replaced from the secondary cache. The methodology of the present invention provides that any replacement done at the secondary cache level ensures that the \u201cdirty\u201d (used) pages are written before they get replaced. This may involve some additional steps (not shown at  or at ) which are described below.","Secondary Cache Hit",{"@attributes":{"id":"p-0121","num":"0130"},"figref":["FIG. 8","FIG. 8"],"b":["820","830","835","830","835","830","829","820","830","829","839","830","835","830","829","820","839","830"]},"The following are the operations that occur in moving the targeted page Pt in the secondary cache to the primary cache, corresponding to (1)-(4) illustrated at :\n\n","At (1), a page at the LRU end of the secondary cache is identified. The buffer containing this page is grabbed and the page Vr from the primary cache is moved to this address. Next, at (2), the page Pt is moved to the space in the primary cache vacated by page Pr. At (3), the offset Os is inserted at the MRU end of the secondary cache as the page Pr from the primary cache is now at this offset Os. At (4), the offset Ot (which is now a free buffer) is inserted at the LRU end of the secondary cache.",{"@attributes":{"id":"p-0124","num":"0137"},"figref":"FIGS. 9A-B","b":["900","901","902"]},"At step , a least recently used (LRU) list that is maintained to indicate pages that have not be recently used is consulted to select a page in the primary cache to be moved to the secondary cache. In this example, page Pr having an address Vr is selected from the primary cache. At step , a page in the secondary cache is selected from the LRU end of the MRU\/LRU list maintained for the secondary cache. In this case, page Ps at offset Os is selected. This page may be either a free or valid page.","At step , the page (page Pr) is moved from the primary cache to the secondary cache at the location of the page Ps (i.e., at offset Os). At step , the page at offset Os (page Pr) is added to the MRU end of the MRU\/LRU list maintained for the secondary cache. After the page Pr has been moved to the secondary cache, page Pt is moved from the secondary cache to the primary cache at step . Page Pt is moved to the location just vacated by page Pr at address Vr. At step , the page (buffer) at offset Ot is moved to the LRU end of the secondary cache's MRU\/LRU list as this page has been moved to the primary cache. At (optional) step , this buffer (page) at offset Ot is marked with a \u201cdestroyed\u201d state set to facilitate its reuse.","In this secondary cache hit scenario only two copies are incurred. However, a valid page from the secondary cache may have been thrown. Since this is the page at the LRU end of the secondary cache, it means that page may not have been used for a long time and the likelihood of it being accessed again is relatively low. At the end of the above operation there will be a buffer with the \u201cdestroyed\u201d state set and this can be used in the subsequent replacement. Since every replacement is causing one destroyed buffer, valid pages are not often lost. Generally, a valid page will be lost only when a disk read kicks in and causes a buffer to be replaced from the primary cache to the secondary cache, the secondary cache becomes full, and there is a subsequent cache hit from the secondary cache. Then process for writing \u201cdirty\u201d (used) pages in the secondary cache to disk is described below.","Wash Region in Secondary Cache","The present invention, in its currently preferred embodiment, implements a washing mechanism in the secondary cache. The approach of the present invention is to avoid maintaining the wash region in the primary cache for the following reasons: (1) maintaining a wash region in the primary cache can generate a lot of writes because of the relatively small size of the primary cache; and (2) maintaining a wash region in the primary cache, rather than in the secondary cache, is similar to a file system buffer (i.e., write through and reads benefit from the file system cache). Performance degradation has been observed to result from the excessive writes caused by maintaining a wash in the primary cache. In an OLTP system writes are expensive when data is accessed in a random fashion. Also, the disk subsystem typically has a cache where it puts these write\/read requests so that they can be processed efficiently. If the primary cache is flooded with a lot of writes this may adversely impact the responsiveness of the system.","The approach of the present invention is to delay data page writes as much as possible in the interest of improved system performance. One way in which this is achieved by the present invention is that when a page is moved from the primary cache to the secondary cache, the page is normally not then written out to disk. Data pages are aged to the secondary cache and are not written out to the disk as part of the normal aging. Instead, logs are written for tracking transactions, so that transactions\/data pages can be recovered in the event of a system crash. As a result, the adverse performance impact of writing pages to disk is avoided in many cases. Also, there may be additional changes to the page, sometimes even before the end of a transaction, that can be made while a page is still in cache. Additional operations to read the page back in from disk are therefore also avoided. The approach of the present invention is to defer writes as long as possible (e.g., even after a transaction has been committed) and to maintain log records to guard against data loss. Any modification done to the data pages can be delayed as long as the log record associated with the modification has been written to the disk.","The present invention includes wash mechanisms for writing changes to data pages to disk when the system is at a \u201ccheckpoint\u201d. A checkpoint is a point in time where the changes are written to disk which can be initiated in several ways. The checkpoint can be issued by a user (e.g., system administrator). The checkpoint can also be issued based on certain operations occurring in the database (e.g., operations that require flushing all of the pages to disk). The system includes a checkpoint process which runs internally without the user having to initiate it.",{"@attributes":{"id":"p-0132","num":"0145"},"figref":"FIG. 10","b":["1030","1020","1050","1030"]},"As shown at , page Pd  is going to be read into the shared memory address Vr from the disk . However, before reading the page from disk, a page location needs to be found in the secondary cache for moving the page Pr . As described above, the system of the present invention will grab a page Ps  from the LRU end of the secondary cache . When grabbing the buffer page Pw  will go past the wash marker (WM) and a write needs to be issued on this page Pw . Note that in the case of a cache hit in the secondary cache, it is unlikely that any washing will need to be done because of the fact that the system grabs a buffer from the LRU end and inserts a destroyed buffer at the LRU end. In this fashion the system does not cause any buffers to move past the wash marker.","Dirty Buffers","One concern with maintaining the wash region in the secondary cache is the issue of a heterogeneous dirty buffer list (i.e., a dirty buffer list that contains some buffers that are in the primary cache and some buffers that are in the secondary cache). The system needs to be able to distinguish and manage these buffers together in the same list. With wash regions in the secondary cache, checkpoint performance may also be affected. This is because some of the dirty buffers are in the secondary cache, and to issue writes on these buffers the system has to map the offset and then issue a write. What is needed is a list of virtual addresses to issue the writes, and to wait until all the writes issued are complete so that the system can reuse the virtual addresses. The system of the present invention addresses these and other concerns, as will be discussed below.","There are two approaches to solve the problem of dirty buffers. The first approach provides for maintaining one dirty buffer link at the object level and having the same buffer header for both the primary and the secondary buffers. The following are the consequences of this approach: (1) each secondary buffer header size will be 128 bytes; (2) a status in the header will be required to state whether it is in the primary or secondary cache; and (3) whenever the dirty chain is accessed the system will need to make sure that it is addressable. This approach consumes a lot more resources and makes it complex to access buffers in the dirty chain.","The second and preferred approach is to maintain two different dirty link buffers; one for the buffers in the primary cache and one for the buffers in the secondary cache. This preferred approach used by the system of the present invention consumes less resources and makes it easier to access the primary and secondary buffers. The consequences of this approach include that the dirty buffers are not in the same chain, and checkpoint performance has to work on two different chains to issue writes. Also, inserting into the secondary chain is not as simple as inserting into the primary cache. The insertion operation has to find a proper insertion point based on the dirty sequence number, in case the dirty sequence number needs to be maintained in the ascending order. Otherwise, the checkpoint may have to issue writes on all of the buffers to ensure the recoverability.","Data Structures and Resource Overhead","With the system of the present invention the following information is needed in the server shared memory: a LRU\/MRU chain of pages in the secondary cache, and one or several virtual address block(s) with the size of max buffer size. Currently, each entry in the LRU\/MRU chain includes the following information:",{"@attributes":{"id":"p-0140","num":"0153"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u20021:","struct ecache_buf {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u20022:","LINK buf_link; \/* Link for LRU\/MRU chain *\/"]},{"entry":[{},"\u20023:","LINK hashtab_link; \/* Link Structure for Has table"]},{"entry":[{},"*\/"]},{"entry":[{},"\u20024:","LINK dirty_chain; \/* To maintain dirty chain *\/"]},{"entry":[{},"\u20025:","struct sec_cache_entry bxls_next;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u20026:","\/* next buffer in the pinned chain *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u20027:","dbid_t bdbid; \/* database id *\/"]},{"entry":[{},"\u20028:","pgid_t blpageno; \/* logical page number *\/"]},{"entry":[{},"\u20029:","pgid_t bvirtpg; \/* virtual page number *\/"]},{"entry":[{},"10:","uint32 offset; \/* Offset in the shmfs *\/"]},{"entry":[{},"11:","short status; \/* status of the buffer *\/"]},{"entry":[{},"12:","circ_long dirtyseq; \/* dirty sec for buffer *\/"]},{"entry":[{},"13:","circ_long pinnedseq; \/* pinned seq number *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"14:","}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"Maintaining this chain currently uses a maximum of 64 bytes per buffer in the secondary cache. For example, in an 8 GB memory with 6 GB of shmfs and page size of 4K, 256 MB of shared memory space may be needed to maintain this chain. Note that \u201coffset\u201d is a multiple of MIN(database page size, 2K). For example, if the database page size is 2K, then offset points to location=offset*2 k. If the database page size is 4K then it points to location=offset*4 k. The system thereby only needs a 32-bit integer to store the offsets more than 4 GB. On Linux, offsets have to be a multiple of 4K, which is the page size of the server. When a virtual address is mapped to a given offset, the 4K base for a given offset needs to be determined. This is only true for a 2K-database page size. For database page size >=4K, an offset can be directly used to map it to a virtual address. With the 2K page size the following needs to be done: 2 k_offset=offset<<10; 4 k_offset=offset & 0xfffffeff (which is 10th bit being zeroed).","After mapping the offset to a virtual address an additional 2K may need to be added to the virtual address before accessing it in case it does not align on a 4K boundary. All the information related to a dirty primary buffer is stored in the secondary buffer, so that when a page is read from the secondary buffer the dirty buffer can be reconstructed to maintain the consistency of the semantics.","Configuration","There are two alternative configuration options for implementation of the secondary cache. The first option is to allow each named cache to have an extended secondary cache of a specific size. The second option, which is used in the currently preferred embodiment of the present invention, is to have one global secondary cache which all the named caches share.","In an implementation in which there is a secondary cache for each named cache, a secondary cache of a specific size is allocated for each of the named caches. A typical configuration would look like the following:\n\n","An additional refinement to the above approach is to allow a specific pool to have extended cache configured as shown:\n\n","The advantages of allowing each named cache to have an extended secondary cache of a specific size are that it is in sync with the primary cache configuration and fine-tuning is possible. The disadvantages are that the system will need to maintain multiple LRU\/MRU chains, there are more configuration parameters, and there is additional complexity in the code to allow configuration\/reconfiguration, and to maintain these pools.","The alternative and preferred option provides for using one global secondary cache, with all of the caches using this global secondary cache to replace their primary buffers. A typical configuration would look like the following:\n\n","The advantages of using one global secondary cache are that this approach provides a simple configuration and there is less complexity in the code. Issues that need to be considered include that contention may increase as the memory size increases to cache more data, and there is no fine-tuning. This is the preferred embodiment because of its simplicity and ease of implementation.","Data Page Writes","The present invention provides for reads to directly happen to the pages in the primary cache. Also, bufawrites() or bufwrites() that are initiated by the access level occur as is because at the time these writes are initiated at the access level the page is already in the primary cache. Writes occur at the secondary cache during washing and at checkpointing. To implement the wash in the secondary cache, the wash marker needs to be maintained in the secondary cache. For the checkpointing operation there is a walk through the dirty chain of secondary buffers maintained in the DES. For issuing writes the offset is mapped to a free virtual address and then issues the writes on that engine. Since the write completion gets services on the same engine where the writes were issued, virtual address mapping will still be valid when serving the write completion.","List of Free Virtual Address",{"@attributes":{"id":"p-0153","num":"0188"},"figref":["FIG. 11","FIG. 11"]},"Kernel Services","In the current embodiment of the present invention the buffer manager and kernel services are separated to an extent so that any other alternative to shmfs can be used to provide the extended memory capability. The separation of the buffer manager and the kernel services enables adoption of different platforms without having to rewrite the buffer manager part of the system. There are two specific initialization modules: one module is initialized while the server is booting, and the other module is initialized while the engines come online. The database system kernel (e.g., ASE kernel) provides the following services and operations for extended memory support: (1) creating a new shared memory file; (2) deleting the shared memory file; (3) initializing the newly created shared memory file; (4) initializing the shmfs and server data structures such that initialization occurs during server boot and during engine onlining; (5) creating and maintaining a free list of virtual addresses; (6) writing a given page to a specific offset; and (7) reading from a given offset to a specific page.","There are three new kernel data structures introduced for bookkeeping operations at the kernel level. The first is as follows:","KECACHE_DESC",{"@attributes":{"id":"p-0158","num":"0193"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"1:","struct kecache_desc {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"2:","SHMID shmfsdesc; \/* Shared memory file descriptor"]},{"entry":[{},"*\/"]},{"entry":[{},"3:","size_t ospagesize; \/* shfms page size *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"4:","}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"The above kernel data structure holds global information at the kernel level on the shmfs. SHMID, used in this structure, is an existing structure which contains all the fields necessary to store the filename, name size, flags, and the like. All the engines to open the shared memory file system file will use this structure. The first engine, which creates the shared memory file, will populate this kernel data structure with all the necessary information.","A second kernel data structure is as follows:","KE_ECACHE_DESC",{"@attributes":{"id":"p-0162","num":"0197"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"1:","struct ke_ecache_desc {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"2:","int shfsfd; \/* File descriptor for the shfs file *\/"]},{"entry":[{},"3:","LINK virtaddrlist; \/* List of virtual addresses *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"4:","}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"The second kernel data structure is engine specific. It contains a file descriptor, which was obtained by opening the file on that engine. This structure also points to a list of virtual addresses that are available for mapping on this engine.","The third kernel data structure is as follows:","VIRT_ADDR_DESC",{"@attributes":{"id":"p-0166","num":"0201"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"1:","struct virt_addr_desc {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"2:","LINK virt_next; \/* Next in the list *\/"]},{"entry":[{},"3:","uint32 virt_addr; \/* Virtual address *\/"]},{"entry":[{},"4:","long offset; \/* Offset in the file where this"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"5:","** address is mapped to *\/"]},{"entry":[{},"6:","}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"This third kernel data structure contains the virtual address that is available or mapped to a specific offset to the shmfs file. If the offset is \u201c\u22121\u201d then the virtual address is not mapped to any offset. This will be tracked at the engine level through the linked list. The linked list can be implemented as a single linked list. The system ensures that used virtual addresses are kept at the head of the list and free addresses are kept at the tail of the list.","The following are the kernel structures which are enhanced to keep the secondary cache information structure:","KERNEL",{"@attributes":{"id":"p-0170","num":"0205"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u20021:","{"]},{"entry":[{},"\u20022:","#if defined(linux)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u20023:","int kiruntime_abi; \/* for ABI run-time settings *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u20024:","#endif \/* linux *\/"]},{"entry":[{},"\u20025:","#if LMS"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u20026:","struct kecache_desc *kecache_desc;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u20027:","\/* Secondary Cache descriptor *\/"]},{"entry":[{},"\u20028:","#endif \/* LMS *\/"]},{"entry":[{},"\u20029:"]},{"entry":[{},"10:","}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"The above \u201cKERNEL\u201d structure has a handle to the secondary cache kernel descriptor. It should be noted that it is localized to the platform where the extended memory feature of the present invention is supported.","The following \u201cENGINE\u201d structure is also maintained:","ENGINE",{"@attributes":{"id":"p-0174","num":"0209"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["1:","{"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["2:","THREAD_KEY_T enthrdkey; \/* key for thread local"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["3:","storage *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["4:","#if LMS"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["5:","KE_ECACHE_DESC *e_ecache_desc; \/* handle to secon"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"dary cache"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["6:","descriptor *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["7:","#endif \/* LMS*\/"]},{"entry":["8:","}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The ENGINE structure includes a handle to the secondary cache structure specific to the engine where it stores the file descriptor, the list of virtual addresses, and the like.","Secondary Cache Operations","In the currently preferred embodiment of the present invention, the operations pertaining to the secondary cache are added in the Linux 32-bit platform directory. The two new files added are \u201cecachemgr.c\u201d and \u201cecachemgr.h\u201d. These files are compiled as part of \u201clibsrvmanager.a\u201d. The function calls from the generic code are encapsulated in the form of macros. These macros are defined to be non-operational (no-ops) in other platforms. The changes to the generic code are done in the following functions: (1) cm_init_pool_config: the bsearch_wash and wash_size is setup for extended memory support (LMS); (2) cm_calculate_washvalues: the change is done so that the default wash calculations are not performed for LMS (to affect the lowest sized buffer pool); and (3) cm_wash_mass_lru: instead of calling bufawrite call the macro ECACHE_REPLACE_BUF. The code to set MASS_WET is moved down since it gets reset as a part of bwfinish, which will not be called once the secondary cache is setup.","Wash Region in Primary","When the extended memory support (LMS) feature of the present invention is enabled, the wash region for the lowest buffer pool (which has the same size as the server page size) in all primary data caches is set to the minimum wash size (i.e., WASH_LOW_WATER). The user specified wash region is ignored. This is done as a part of the buffer pool initialization at startup. During run-time, the wash size of a buffer pool can be modified when the stored procedure sp_poolconfig is executed. In such scenarios, the wash size is maintained as required by LMS during the wash size calculations. Currently, when a buffer is grabbed from the LRU-MRU chain, a wash is issued (i.e., moves a mass which is just before the wash marker towards the LRU end after issuing a write). This behavior is altered, and now during a wash the mass is replaced in the secondary cache instead of issuing a write operation from the primary cache.","Replace Operation","The replace operation occurs when the primary cache manager spinlock is held in cm_wash_mass_lru(). When the buffer is to be replaced in the secondary cache, the following sequence of steps needs to be performed to maintain the consistency of the modified page: (1) set MASS_WRITING in the buffer status so that it is not grabbed; (2) grab a secondary buffer header, copy the required fields from the primary buffer to the secondary buffer, hash the buffer in the secondary hashtable, and set MASS_READING in the secondary buffer header; (3) drop all spinlocks and copy the page to the secondary cache; (4) if the page is successfully copied and the buffer is not kept then the buffer can be unhashed from the primary cache and MASS_WRITING reset; and (5) in case of any error, the buffer is unhashed from the secondary cache and will be washed as usual from the primary cache. It is important to note that at any point the buffer is hashed in either the primary cache or the secondary cache. All searchers will search the primary cache first. While the page is in the process of being copied to the secondary cache, the MASS_READING bit in the secondary buffer header will make the searchers wait for the copying operation to be completed. The hashing is done in the secondary cache holding the primary spinlock to ensure that no other copy of the page is brought into memory.",{"@attributes":{"id":"p-0182","num":"0217"},"figref":["FIG. 12","FIG. 12"],"b":["1200","1201","1202"]},"As also shown at , ecache_replacebuf  does the following. First, it grabs a free buffer from the secondary cache by calling ecachegrabmem . Next, it copies the page from the primary cache to the secondary buffer by calling ecache_copy_page . Note that the abstraction provided by the present invention is illustrated by the call made to ecache_copypage  which provides for copying to a location identified by an offset. The location itself can be anywhere (e.g., supported on various devices). The secondary buffer is then hashed for the secondary cache through the call to ecache_bufhash . As the contents of the primary buffer have been copied, the primary buffer is no longer valid and can be removed. The call to ecache_rm_pbuf  erases the identity of the primary buffer from the primary cache. The new buffer is then moved to the MRU side of the LRU\/MRU chain of the secondary cache. This concludes a basic replacement operation.","Secondary Cache Read Operation","A secondary cache read operation is when a page is moved from the secondary cache into the primary cache. Reading from the secondary cache takes place as part of the bufread() call from the buffer manager. The bufread() call, which would normally read from the disk (i.e., in the absence of the secondary cache of the present invention), is intercepted. The secondary cache is checked to see if the requested buffer is present in the secondary cache. If the requested buffer is present in the secondary cache, the content of the secondary buffer is copied into the primary buffer and returned back to the buffer manager, as a disk I\/O is completed. This is done transparently so that the buffer manager does not have to be aware of the extended cache's existence.",{"@attributes":{"id":"p-0186","num":"0221"},"figref":["FIG. 13","FIG. 13"],"b":["1300","1301","1301","1302","1302","1303","1304","1305"]},"Pseudocode","The following pseudocode provides further detail regarding the system and methodology of the present invention for providing extended memory support.","While the invention is described in some detail with specific reference to a single-preferred embodiment and certain alternatives, there is no intent to limit the invention to that particular embodiment or those specific alternatives. For instance, those skilled in the art will appreciate that modifications may be made to the preferred embodiment without departing from the teachings of the present invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 6A"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 6B"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIGS. 9A-B"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 13"}]},"DETDESC":[{},{}]}
