---
title: Lightweight data replication
abstract: A lightweight row transfer protocol is described that can be easily handled by thin clients, such as JAVA™ applications using CORBA. The lightweight row transfer protocol serves to reduce bandwidth requirements by applying compression techniques to reduce the number of column lengths in a “result set” of rows that are transmitted from one computer to another.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06847971&OS=06847971&RS=06847971
owner: Oracle International Corporation
number: 06847971
owner_city: Redwood Shores
owner_country: US
publication_date: 19990528
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DESCRIPTION OF THE PREFERRED EMBODIMENT","Hardware Overview","Architectural Overview","Snapshot Metadata Located at Master Site","Refresh Groups","Refreshing Snapshots","Lightweight Communication","Lightweight Communication in the Refresh Direction","Lightweight Communication in the Push Direction"],"p":["The present application claims the benefit of U.S. Provisional Application No. 60\/086,985 entitled \u201cReplication for Front Office Replication\u201d filed on May 28, 1998 by Benny Souder, Alan Downing, Harry Sun, Alan Demers, James Stamos, John Graham, and Curtis Elsbernd, the contents of which are hereby incorporated by reference herein.","The present application is related to the following commonly-assigned U.S. patent applications, the contents of all of which in their entirety are hereby incorporated by reference herein:\n\n","The present invention relates to distributed database systems and more particularly to lightweight replication of data.","Under certain conditions, it is desirable to maintain copies of a particular body of data, such as a relational database table, at multiple sites. The mechanism for maintaining multiple copies of the same body of data at multiple sites is generally referred to as \u201cdata replication.\u201d In a distributed database system using data replication, multiple replicas of data exist in more than one database in the distributed database system.","One kind of data replication employs snapshots. A snapshot is a body of data constructed of data from one or more \u201cmaster\u201d tables, views, or even other snapshots, any of which can be stored locally or remotely relative to the snapshot. The data contained within the snapshot is defined by a query that references one or more master tables (and\/or other database objects) and reflects the state of its master tables at a particular point in time. To bring the snapshot up-to-date with respect to the master tables, the snapshot is refreshed upon request, e.g. at a user's command or automatically on a periodic, scheduled basis.","There are two basic approaches for refreshing a snapshot. \u201cComplete refreshing\u201d involves reissuing the defining query for the snapshot and replacing the previous snapshot with the results of the reissued query. \u201cIncremental refresh\u201d or \u201cfast refresh\u201d refers to identifying the changes that have happened to the master tables (typically, by examining a log file of the changes) and transferring only the data for the rows in the snapshot that have been affected by the master table changes. An \u201cupdatable snapshot\u201d is a snapshot to which updates may be directly made, which are propagated from the snapshot back to the master table before refreshing.","Traditionally, snapshots have been implemented for high-end computer systems, which are characterized by the use of high performance computers that are interconnected to one another by highly reliable and high bandwidth network links. Typically, highly experienced database administrators manage these high-end systems. Due to the expense of these high-end computers, high-end distributed systems tend to involve a small number of networked sites, whose users can be trusted at least in part because of the physical security of the computers.","Recently, there has been much interest in the marketplace for applications for front office automation. One example is sales force automation, where hundreds, if not thousands, of sales representatives in a company are given laptops to improve their productivity. The laptops are loaded with applications, for example, to help a sales representative sell the company's products to a customer and take the customer's order. Therefore, the laptops include a data store to keep the customer and order information handy for use by a specific sales representative.","Front office automation, however, challenges the operating assumptions behind the high-end snapshot implementations. For example, high-end snapshot replication uses a full relational database system at each site to drive the snapshot refreshes, receive the row data in a SQL format, and apply the changes. Since laptops are computationally constrained, it is desirable to implement thin clients, for example JAVA\u2122 applications, rather than requiring a full relational database system. However, the high-end row transfer mechanism employs a thick, SQL application programming interface (API).","There is a need for an implementation of snapshot replication that is suitable in a front office automation environment without incurring the above-described and other disadvantages incumbent in a high-end implement of snapshot replication.","This and other needs are addressed by the present invention which implements to a lightweight row transfer protocol that can be easily handled by thin clients, such as JAVA\u2122 applications using CORBA. The lightweight row transfer protocol serves to reduce bandwidth requirements by applying compression techniques to reduce the number and size of column lengths in a \u201cresult set\u201d of rows that are transmitted from one computer to another.","Accordingly, one aspect of the invention pertains to a computer-implemented method and a computer-readable medium bearing instructions for a method of transmitting data for multiple rows. The rows are encapsulated one or more result sets, and the result sets are transmitted. In one embodiment, the result sets contain column lengths corresponding to respective lengths of columns of data within the rows.","Another aspect of the invention relates to a computer-implemented method and a computer-readable medium bearing instructions for a method of receiving data multiple rows. In one embodiment, one or more result sets are received that contain column lengths corresponding to respective lengths of columns of data within the rows and are unpacked into the data for the rows.","Still other objects and advantages of the present invention will become readily apparent from the following detailed description, simply by way of illustration of the best mode contemplated of carrying out the invention. As will be realized, the invention is capable of other and different embodiments, and its several details are capable of modifications in various obvious respects, all without departing from the invention. Accordingly, the drawing and description are to be regarded as illustrative in nature, and not as restrictive.","A method, article, and apparatus for lightweight replication is described. In the following description, for the purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent, however, to one skilled in the art that the present invention may be practiced without these specific details. In other instances, well-known structures and devices are shown in block diagram form in order to avoid unnecessarily obscuring the present invention.","In a database management system, data is stored in one or more data containers, each container contains records, and the data within each record is organized into one or more fields. In relational database systems, the data containers are referred to as tables, the records are referred to as rows, and the fields are referred to as columns. In object oriented databases, the data containers are referred to as object classes, the records are referred to as objects, and the fields are referred to as attributes. Other database architectures may use other terminology.","Systems that implement the present invention are not limited to any particular type of data container or database architecture. However, for the purpose of explanation, the terminology and examples used herein shall be that typically associated with relational databases. Thus, the terms \u201ctable,\u201d \u201crow,\u201d and \u201ccolumn\u201d shall be used herein to refer respectively to the data container, record, and field.",{"@attributes":{"id":"P-00032","num":"00032"},"figref":"FIG. 1","b":["100","100","102","104","102","100","106","102","104","106","104","100","108","102","104","110","102"]},"Computer system  may be coupled via bus  to a display , such as a cathode ray tube (CRT), for displaying information to a computer user. An input device , including alphanumeric and other keys, is coupled to bus  for communicating information and command selections to processor . Another type of user input device is cursor control , such as a mouse, a trackball, or cursor direction keys for communicating direction information and command selections to processor  and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes, a first axis (e.g., x) and a second axis (e.g., y), that allows the device to specify positions in a plane.","The invention is related to the use of computer system  for lightweight replication. According to one embodiment of the invention, lightweight replication is provided by computer system  in response to processor  executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory  from another computer-readable medium, such as storage device . Execution of the sequences of instructions contained in main memory  causes processor  to perform the process steps described herein. One or more processors in a multi-processing arrangement may also be employed to execute the sequences of instructions contained in main memory . In alternative embodiments, hard-wired circuitry may be used in place of or in combination with software instructions to implement the invention. Thus, embodiments of the invention are not limited to any specific combination of hardware circuitry and software.","The term \u201ccomputer-readable medium\u201d as used herein refers to any medium that participates in providing instructions to processor  for execution. Such a medium may take many forms, including but not limited to, non-volatile media, volatile media, and transmission media. Non-volatile media include, for example, optical or magnetic disks, such as storage device . Volatile media include dynamic memory, such as main memory . Transmission media include coaxial cables, copper wire and fiber optics, including the wires that comprise bus . Transmission media can also take the form of acoustic or light waves, such as those generated during radio frequency (RF) and infrared (IR) data communications. Common forms of computer-readable media include, for example, a floppy disk, a flexible disk, hard disk, magnetic tape, any other magnetic medium, a CD-ROM, DVD, any other optical medium, punch cards, paper tape, any other physical medium with patterns of holes, a RAM, a PROM, and EPROM, a FLASH-EPROM, any other memory chip or cartridge, a carrier wave as described hereinafter, or any other medium from which a computer can read.","Various forms of computer readable media may be involved in carrying one or more sequences of one or more instructions to processor  for execution. For example, the instructions may initially be borne on a magnetic disk of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system  can receive the data on the telephone line and use an infrared transmitter to convert the data to an infrared signal. An infrared detector coupled to bus  can receive the data carried in the infrared signal and place the data on bus . Bus  carries the data to main memory , from which processor  retrieves and executes the instructions. The instructions received by main memory  may optionally be stored on storage device  either before or after execution by processor .","Computer system  also includes a communication interface  coupled to bus . Communication interface  provides a two-way data communication coupling to a network link  that is connected to a local network . For example, communication interface  may be an integrated services digital network (ISDN) card or a modem to provide a data communication connection to a corresponding type of telephone line. As another example, communication interface  may be a local area network (LAN) card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation, communication interface  sends and receives electrical, electromagnetic or optical signals that carry digital data streams representing various types of information.","Network link  typically provides data communication through one or more networks to other data devices. For example, network link  may provide a connection through local network  to a host computer  or to data equipment operated by an Internet Service Provider (ISP) . ISP  in turn provides data communication services through the worldwide packet data communication network, now commonly referred to as the \u201cInternet\u201d . Local network  and Internet  both use electrical, electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link  and through communication interface , which carry the digital data to and from computer system , are exemplary forms of carrier waves transporting the information.","Computer system  can send messages and receive data, including program code, through the network(s), network link , and communication interface . In the Internet example, a server  might transmit a requested code for an application program through Internet , ISP , local network  and communication interface . In accordance with the invention, one such downloaded application provides for front office replication as described herein.","The received code may be executed by processor  as it is received, and\/or stored in storage device , or other non-volatile storage for later execution. In this manner, computer system  may obtain application code in the form of a carrier wave.",{"@attributes":{"id":"P-00041","num":"00041"},"figref":"FIG. 2","b":["200","220","240","200","202","204","204","212","214","212","13","29","18","214","212","25","13","40","41","18"]},"In the illustrated embodiment, client site  and client site  are laptops that are temporarily connected to the master site  by a dial up line or the like, and belong to sales representatives Smith and Jones, respectively. In a front office automation environment, it is desirable for Smith to have a copy of Smith's customer information and a copy of the corresponding order information for those customers at Smith's laptop, i.e. client site , and for Jones to have a copy of Jones's customer and order information at Jones's laptop, i.e. client site .","Accordingly, client site  includes a front office client application , for example a thin application implemented in JAVA\u2122 that manages a foreign data store  that contains snapshots of the customer master table  and the order master table  as customer snapshot  and order snapshot , respectively. Foreign data store  need not be a relational database and may be implemented by less sophisticated means. Since Smith is presumably only interested in Smith's own data, the customer snapshot  and order snapshot  only keep a subset of the data in the customer master table  and the order master table , respectively. Specifically, customer snapshot  contains the rows for Smith's customers and order snapshot  contains the corresponding order information. For example, customer snapshot  contains two rows for customers  and , and rows for orders  and  are kept in order snapshot . The information required to maintain and drive the refreshes for the local snapshots , , such as the defining queries for the snapshots ,  and the latest refresh times, however, is kept at the master site  in snapshot metadata , although client site  maintains some metadata (not shown) identifying which snapshots are instantiated there, the refresh groups to which they belong, and the columns and column groups of each snapshot. Refresh groups and column groups are described in greater detail hereinafter.","Similarly, client site  includes a front office client application , such as a thin application implemented in JAVA\u2122, that manages a foreign data store  that containing snapshots of the customer master table  and the order master table  as customer snapshot  and order snapshot , respectively. Foreign data store  need not be a relational database and may be implemented by less sophisticated means. Since Jones is only properly interested in Jones's own data, the customer snapshot  and order snapshot  only keep a subset of the data in the customer master table  and the order master table , respectively. Specifically, the customer snapshot  contains a row for Jones's customers (e.g. customer ) and the order snapshot  contains the corresponding order information (e.g. orders  and ). The information required to maintain and drive the refreshes for the local snapshots, such as the defining queries for the snapshots and the latest refresh times, however, is kept at the master site  in snapshot metadata , although client site  maintains some metadata identifying which snapshots are instantiated there, the refresh groups to which they belong, and the columns and column groups of each snapshot.","Snapshot metadata  is stored at the master site  for supporting driving refreshes at the master site  of snapshots instantiated at client sites , . Some of the snapshot metadata  in accordance with one embodiment, is illustrated in  as a collection of data dictionary tables. The names for the data dictionary tables and their fields are supplied for ease of comprehension and need not reflect the actual name of any data dictionary table and their fields created at a master site  in any particular implementation.","Data dictionary table SNAP_SITES  is provided to maintain information about the various client sites at which the snapshots are instantiated. The site_name  of the data dictionary table SNAP_SITES  contains a user-friendly string for the name of the client site and must be unique within the replication environment. The site_id  contains a computer-friendly numeric identifier, which can be sequentially assigned and uniquely corresponds to each site_name . Each snapshot in this environment is identified by a key comprising the owner of the snapshot, the name of the snapshot, and the name of the snapshot.","Data dictionary table SNAPSHOT  holds the main metadata for all the snapshots managed by the master site . Sowner  contains the name of the owner of the snapshot, vname  contains the name of the snapshot, and instsite  contains the site identifier (correlated to site_id ) of the snapshot, thereby uniquely identifying the snapshot. An instsite  value of 0 identifies a server-side snapshot, as in the high-end implementation of snapshot replication. Two other pieces of metadata are illustrated in data dictionary table SNAPSHOTS , base_tables , which indicates the master tables, views, or other database objects that are used for the snapshot, and query txt  containing the definition query for the snapshot.","Data dictionary table SNAP_REFTIMES  maintains the refresh timestamps for each master table of a snapshot. Sowner  contains the name of the owner of the snapshot, vname  contains the name of the snapshot, and instsite  contains the site identifier (correlated to site_id ) of the snapshot, thereby uniquely identifying the snapshot. An instsite  value of 0 identifies a server-side snapshot, as in the high-end implementation of snapshot replication. Snaptime  identifies the last time the master table was involved in a refresh. The tablenum  is a numeric identifier for the master table, mowner  identifies the owner of the master table, and master  contains the name of the master table. Lastsuccess  indicates the last, verified successful refresh time for a snapshot.","Data dictionary table SNAP_COLUMN_MAPS  stores information about the aliasing of the snapshot columns with the master table columns. Sowner  contains the name of the owner of the snapshot, vname  contains the name of the snapshot, and instsite  contains the site identifier (correlated to site_id ) of the snapshot, thereby uniquely identifying the snapshot. An instsite  value of 0 identifies a server-side snapshot, as in the high-end implementation of snapshot replication. Snapshot_column  contains the name of the snapshot column and snapshot_position  identifies the position of the column in the snapshot. Likewise, for the corresponding columns of the master table (identified by tabnum ), master_column  contains the name of the snapshot column and snapshot_position  identifies the position of the column in the snapshot.","Since the snapshot metadata  for refreshing snapshots is stored at the master site , the master database server  has all the information for driving the refresh at its own site, without needing to confer with a client site to reconcile the difference between the master tables ,  and the snapshots , , avoiding almost all of the round trip RPCs for refreshing snapshots in the high-end implementation. Consequently, the bandwidth requirements of the network connection are significantly reduced, enabling the use of dial up lines and the like at acceptable levels of performance.","The use of refresh groups stems from the realization that a laptop user normally expects to refresh all the snapshots used by a suite of front office automation software at the same time. A refresh group is a collection of related snapshots that are refreshed at the same time. For example, the various snapshots of a front office application suite can be placed in the same refresh group, to allow them all to be refreshed at the same time.","Accordingly, snapshot metadata  also stores metadata to maintain refresh groups. With continued reference to , data dictionary table REFRESH_GROUPS  holds the metadata for the each refresh group defined at the master site . Refgroup  contains a number identifying the refresh group, owner  identifies the owner of the refresh group, and name  is a string storing user-friendly name of the refresh group. Instsite  contains an identifier (correlated to site_id ) of the site at which the refresh group is instantiated.","Data dictionary table REF_GROUP_OBJECTS  tracks the objects defined for a refresh group. Each object in the refresh group, for example a snapshot, is identified by a key comprising owner  for the name of the owner of the snapshot, name  for the name of the object, and insite  for the site identifier (correlated to site_id ) of the snapshot, thereby uniquely identifying the snapshot. An instsite  value of 0, of course, identifies a server-side refresh group object, an improvement compatible with the high-end implementation of snapshot replication. Type  indicates the type of the refresh group object and defaults to \u201csnapshot.\u201d Refgroup  is correlated with refgroup  to identify the refresh group for with the object defined.","Since refresh groups collect related snapshots at a client site, provision of refresh groups, therefore, allows the multiplicity of separate RPC calls for each snapshot and master table to be combined into a single snapshot refresh request, thereby further reducing the bandwidth requirements for the connection between the master site  and the client site . For example, if 200 snapshots of a front office application suite are placed in the same refresh group, then the client site  needs only make a single refresh request to the master site  to refresh all 200 snapshots.","Without refreshing snapshots over time become out-of-date. Therefore, at some point in time, a sales representative will want to refresh the snapshots ,  to bring them up to date. In addition, if the snapshots ,  have been installed as updatable snapshots, the sales representative may have changes such as new customer orders to be uploaded to the master site . Accordingly, the sales representative would connect the laptop  to the master site , for example by a dial up telephone line or the like, and request to update the snapshots ,  on the laptop .",{"@attributes":{"id":"P-00056","num":"00056"},"figref":"FIG. 4","b":["232","234","220","400","200","402","202","206"]},"If the local snapshots are updatable and updates have been indeed been made to the updatable snapshots, the queued updates are pushed to the master site  from the locally maintained update snapshot logs and the corresponding locally inserted entries in the snapshots are deleted (step ). The master database server , in response, receives the updates, stores them in a temporary table (whose lifetime is that of a database session while the client site  is connected to the master site ), and applies the updates to the master tables (step ).","At this point, refreshing the snapshots ,  in the specified refresh group is driven entirely at the master site , iterating through doubly nested loops over each snapshot ,  and its master tables , , to reconcile their differences with the snapshots ,  without incurring numerous round trip RPCs between the master site  and the client site . In the doubly nested loop controlled by step , the master database server  repeatedly performs the set up operation (step ). The set up operation, which is used when there are multiple snapshots ,  defined for the same table , processes the master log files corresponding to the master tables ,  to set the refresh time of the most recently added changes to the master tables ,  in the master logs to the current refresh time.","In the doubly nested loop controlled by step , the master database server  formulates SQL select statements based on the snapshot metadata  and executes the SQL select statements on the relational database , first to determine the deleted rows and then to determine the new rows that updated or inserted. These rows are streamed to the client application  at the client site (step ), preferably by a lightweight row transfer protocol described hereinafter. In response, the client application  receives and processes the refresh data in step . If the changes are successfully applied, the client application  sends an acknowledgement in step . In response to receiving the acknowledgement, by the master database server  commits the changes to the master logs response (step ).","Finally, in the doubly nested loop controlled by step , the master database server  performs the wrap up operation (step ). The wrap up operation, also used when there are multiple snapshots defined for the same table, purges the master logs of the entries that are older than the least recently refreshed snapshot to prevent the master logs from growing unacceptably large.","It is therefore evident that driving the snapshot refresh at the master site in accordance with an aspect of the invention dramatically reduces the number of round trip RPCs. For example, to refresh a refresh group containing 200 snapshots each using two master tables, the high-end approach required at least 1600 RPCs, but the corresponding master-driven snapshot refresh uses only one round-trip RPCs, to send the refresh request in step  and get back the data in step .","In accordance with yet another aspect, a lightweight communication protocol is employed in transferring the bulk of the data between the master site  and the client site  in refreshing the snapshots. Referring back to , such a lightweight protocol may be employed in transferring the updatable snapshot log entries from the client site  at step  to the master site  at step  (the \u201cpush\u201d direction) and the deleted and new rows from the master site  at step  to the client site  at step  (the \u201crefresh\u201d direction).","More specifically, such a lightweight communication employs a thin protocol that specifies that one or more rows of data in propagating changes between a snapshot and a master table are grouped together into a \u201cresult set.\u201d  depicts one implementation of a result set , in which the bytes that constitute the data for the rows are bundled into a data buffer , whose size is given by data buffer size . The delineation of those bytes into rows and columns are governed by flags , the number of rows field , the row lengths array , and the column delineator structure . The column delineator structure  includes a position indicator  and a column length array .","The meaning and presence of some of these header fields are context dependent, as described hereinafter, depending on whether the result set is used in the \u201crefresh direction\u201d (from master site  to client site ) or in the \u201cpush direction\u201d (from client site  to master site ). However, one of the flags , indicating whether or not the sizes for the column lengths are normalized, is used in both directions.","A \u201cnormalized column length size\u201d refers to a number of bytes in which the lengths of all the column data in the result set . For example, if the longest length of the column data is 120 bytes, then the normalized column length size would be 1, because all the column lengths can fit in one signed byte. As another example, if the longest column data length is 70,000 then at least three bytes is required to hold all of the column lengths.","Accordingly, as shown in FIG. (), the sending site (either master site  in the refresh direction or client site  in the push direction) determines whether the column lengths should be normalized, for example, by checking the maximum column lengths of all the fields (step ). If, for example, the maximum column length can fit in two bytes because there is no LOB data, then the normalized column bit in the flags  is set and a single column length size, for example a 2 in the first entry of the column length array , is set to the maximum column length (step ). If, on the other hand, column lengths should not be normalized, then the column length size is set as a prefix before every column length in the column length array .","At the receiving site, shown in FIG. (), the process is reversed where the flags  is checked to determine whether the sizes of the column lengths are normalized (step ). If the sizes of the column lengths are normalized, then a single column length size, for example the first entry in the of the column length array , is used (step ). For example, if the first entry is a 2, then every two byte sequence remaining in the of the column length array  is fetched as a column length. If, on the other hand, the column length sizes are not normalized, then the column length size is fetched as a prefix before every column length in the column length array .","In both the refresh direction and the push direction, the flags  header field also indicates whether the result set  has been broken up into a plurality of separate message, and, if so, which message is the last one for the current result set . These flags allow the result set  to be transmitted at a buffer size, e.g. 4K, that is efficient for the particular connection between the master site  and the client site .","The number of rows  in the result set  header specifies the number of rows that presently encapsulated in the particular result set . The following field is an array of row lengths , which contains the length of each row in result set .","The data buffer size field  indicates the size of all the row data in the data buffer  to be transferred. The row data is stored in the data buffer  end-to-end, and the start of each row is governed by the row lengths array  and the start of each column is governed by the column delineators array .","Lightweight communication in the refresh direction refers to the streaming of row data from the master site  to the client site . The flags  for this direction further indicates whether the rows contained in the result set  are rows to be deleted in the snapshot, rows to be inserted into snapshot, or rows to be \u201cupserted\u201d in the snapshot (updated if present, else inserted). Other values of the flags header field  in the refresh direction indicate whether the result set  is being transmitted for a inner table (e.g. customers master table  for the orders snapshot ) or the outer table (e.g. the orders master table  for the orders snapshot ). The inner and outer table flags are set if a snapshot defined by a subquery is being processed, because the refresh data for the inner table include additional information to correlate the inner table rows to the outer table rows. Subquery snapshots are described in the commonly assigned U.S. patent application Ser. No. 08\/880,928, entitled \u201cFast Refresh of Snapshots Containing Subqueries\u201d filed on Jun. 23, 1997 by Alan Downing et al., the entire contents of which of are hereby incorporated by reference herein.","The position array  is used differently depending on the value of the operation type. If the operation type is insert or upsert, potentially the entire row will be needed and therefore every column is sent. Accordingly, the position array  is set for all the columns in the snapshot. On the other hand, for a delete operation all such columns are unnecessary; thus, only the key columns are sent, with the position array  set to indicate that fact. For example, if only columns 2 and 3 are sent, then the position array  would have a 2 and a 3.","Consequently, the sending site operates as shown in FIG. (), where the operation type (delete, insert, upsert) is set in the flags  (step ). If the operation is a delete (step ), then the position array  is set only for the key columns (step ), but for the insert and upsert operations, the positions for all the columns are set (step ). In the other direction, shown in FIG. (), the receiving site checks the operation type in flags  (step ). If the operation is a delete (step ), then the position array  is fetched only for the key columns (step ), but for the insert and upsert operations, the positions for all the columns are fetched from the position array  (step ).","In the push direction, the flags header field  indicates whether the result set is for a normal deferred transaction, whether the result set is for an error transaction (which occurs if a deferred transaction encountered an error and the master database server  requests the same row data to be pushed up again) or whether the result is \u201cre-pushed\u201d. A re-push occurs when a client had previously only pushed the local updates, but decided not to refresh the local snapshot. In the case of a re-push, only the primary keys (old and new) are sent.","Since conflict resolution at the master site  uses both the old and new values for the column values in the push direction, it is desirable to reduce the amount of data being sent for conflict resolution. Thus, one of embodiment of the invention employs the techniques described in U.S. patent application Ser. No. 09\/081,297 entitled \u201cMethod for Data Replication with Conflict Detection\u201d filed on May 20, 1998 by James Stamos et al., the whole contents of which are incorporated by reference herein, in which the columns are partitioned into column groups, new and old values for unmodified column groups are not sent, and either of the new and old values for unmodified columns in a modified column group are not sent.","In contrast with the refresh direction, the result set  is not batched based on operation type. Rather the different rows of the result set are sent in the sequence in which the corresponding changes were made. Further the updatable snapshot queue contains updates for every snapshot at a particular master, regardless of the refresh group. Consequently, each row in the updatable snapshot queue includes a snapshot identifier for the updated snapshot, a DML type (insert, update, and delete) to indicate the operation, and a column changed vector to indicate which columns have changed. This information is included in the row data as columns with negative positions. For example, position \u22123 may be the snapshot identifier, position \u22122 the DML type, and position \u22121 the change vector.","Since the rows may be from different snapshots, the position array  explicitly contains entries for every row. For insert and delete DML operations, the position array  skips over zero-length rows, general key columns, changed columns, columns required for conflict resolution, and columns needed by a trigger at the master site. For the update DML operation, however, the position array  includes a position for all the old column even if zero-length, and for at least one new column.","Consequently, the sending site operates as shown in FIG. (), where the DML type (delete, insert, udpate) is set in the position array  with a negative position value, such as \u22122 (step ). If the operation is an update (step ), then the position array  is set for the positions of all the old column values, followed by the position of at least one new column, thereby introducing a repeated position number (step ). For the other operations, however, the positions for all the columns are set, except for those column that are zero-length (step ). In the other direction, shown in FIG. (), the receiving site checks the operation type in the position array  entry with a negative position (step ). If the operation is an update (step ), then the position array  is fetched the all old column values and at least one new column value, identified by a repeated position (step ). For the insert and delete operations, however, the positions for the columns are fetched from the position array , wherein skipped columns are considered to be zero-length (step ).","The above-described approach does not require the client site to implement SQL or PL\/SQL, an extension to SQL available from Oracle Corp., of Redwood Shores, Calif. As a result, the client site laptop can be installed with thin clients, such as JAVA\u2122 applications using CORBA, because the lightweight communication protocol requires much less computing resources than a thick SQL or PL\/SQL protocol.","While this invention has been described in connection with what is presently considered to be the most practical and preferred embodiment, it is to be understood that the invention is not limited to the disclosed embodiment, but on the contrary, is intended to cover various modifications and equivalent arrangements included within the spirit and scope of the appended claims.","For example, although the present invention has been extensive described with respect to the refreshing snapshots for front office automation, it is to be understood that the same techniques disclosed herein are readily applicable to refreshing snapshots in a high-end snapshot replication implementation, with peer-to-peer asynchronous replication, and even with the publish-subscribe model of data replication."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention is illustrated by way of example, and not by way of limitation, in the figures of the accompanying drawings and in which like reference numerals refer to similar elements and in which:",{"@attributes":{"id":"P-00022","num":"00022"},"figref":"FIG. 1"},{"@attributes":{"id":"P-00023","num":"00023"},"figref":"FIG. 2"},{"@attributes":{"id":"P-00024","num":"00024"},"figref":"FIG. 3"},{"@attributes":{"id":"P-00025","num":"00025"},"figref":"FIG. 4"},{"@attributes":{"id":"P-00026","num":"00026"},"figref":"FIG. 5"},"FIGS. (), (), and () are flowcharts for packaging the result set.","FIGS. (), (), and () are flowcharts for unpacking the result set."]},"DETDESC":[{},{}]}
