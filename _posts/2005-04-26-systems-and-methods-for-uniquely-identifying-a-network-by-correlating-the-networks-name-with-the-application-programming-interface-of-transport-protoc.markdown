---
title: Systems and methods for uniquely identifying a network by correlating the network's name with the application programming interface of transport protocol and the connectivity type of the network
abstract: A service is disclosed that discovers information about the logical networks to which a computer is connected and provides that information to applications. The information is keyed to names constructed by the service. There is a mapping between the names and the logical networks. Applications may rely on the names when selecting a configuration to use with a given logical network. The network name may be correlated with other information, such as physical network interface(s) on the computer through which the logical network is accessible, application programming interfaces of the transport protocols supported by the logical network, and the connectivity type of the logical network. Applications are notified when network information provided to them changes or when new information becomes available.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07007079&OS=07007079&RS=07007079
owner: Microsoft Corporation
number: 07007079
owner_city: Redmond
owner_country: US
publication_date: 20050426
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATION","TECHNICAL FIELD","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","I. Sensing Network Media Events","II. An Implementation of the Network Logic","III. Actions of the Network Logic in Response to Network Media Events","IV. Actions of Applications upon Notification that Something Changed","V. The NLRSP: Providing Network Connectivity Information","VI. An NLRSP API According to One Aspect of the Invention"],"p":["This application is a continuation of application Ser. No. 09\/840,569, filed on Apr. 23, 2001 which, in turn, is a continuation in part of application Ser. No. 09\/557,497, filed on Apr. 24, 2000, now abondoned.","This invention relates generally to computer networks and, more specifically, to identifying the networks to which a computer is attached.","Computers today connect to and disconnect from networks much more frequently than they did in the past. Laptops move around among one or more office networks and the home network. As a mobile computer with a radio network link passes from one radio access point to another, its network connection is, in effect, dropped and then reinstated.","Some computers can automatically sense when they are connected to a network and when that network connection changes. These computers are called \u201cmedia sense aware.\u201d Media sense awareness is very useful in many common computing scenarios because computers, applications, and system services may want to alter their behavior depending upon the network to which the computer is connected. For example, when a non-media sense aware computer's link is disconnected from one network and connected to another, an application that transmits secure information may not realize the change and may inadvertently leak that secure information out onto the new network. Likewise, a non-media sense aware system service that obeyed the bandwidth reservation guarantees given by a Quality of Service manager on a previous network may inadvertently violate the bandwidth guarantees on the new network. Mobile computers are specially sensitive to problems if they are not media sense aware because of their frequent network disconnects and subsequent connects.","Some media sense aware computers, applications, and system services can only respond to network connect and disconnect events. U.S. patent application Ser. No. 09\/652,501, \u201cSystems and Methods for Resynchronization and Notification in Response to Network Media Events,\u201d filed on Aug. 31, 2000 U.S. Pat. No. 6,782,422, expands on that basic functionality, allowing response to a broad range of network events. However, even when media sense aware applications and services know about a change in the status of their network connections, they may not have enough information to know how to respond, unless a user manually reconfigures them for their changed circumstances. The applications and services may be able to enumerate the network interfaces available on a computer but do not know to which logical network an interface connects nor whether multiple interfaces connect to the same network. This information is often needed, however, when the applications and services attempt to select an optimal configuration to use with the new network connectivity. They are left having to discover network information themselves before they can respond appropriately. The problem is especially acute for mobile computers that frequently move among different networks and for computers for which more than one network connection is available, such as multi-homed computers that may support both a LAN connection and a dial-out link.","Forcing each application and system service to discover network connectivity information creates further problems because there are multiple ways in which logical network connections may be determined, depending upon the types of the connections.","The above problems and shortcomings, and others, are addressed by the present invention, which can be understood by referring to the specification, drawings, and claims. The present invention discovers information about the logical networks to which a computer is connected. The information is provided to applications running on the computer, the information keyed to names constructed by the invention. There is a \u201cone-to-one\u201d mapping between the names and the logical networks. This one-to-one mapping has two fundamental properties. First, different logical networks are given different names. Second, a given logical network is given the same name whenever the computer connects to it. These properties are called \u201cuniqueness\u201d and \u201cpersistence,\u201d respectively. Because the network names are unique and persistent, applications may rely on them when selecting a configuration to use with a given logical network. Even though some embodiments of the invention may, in certain circumstances, produce mappings that are not strictly unique or persistent, the information they produce may still be valuable in selecting a configuration.","According to another aspect of the present invention, the network name is correlated with other information, such as physical network interface(s) on the computer through which the logical network is accessible, application programming interfaces of the transport protocols supported by the logical network, and the connectivity type of the logical network. Applications are notified when network information provided to them changes or when new information becomes available.","Turning to the drawings, wherein like reference numerals refer to like elements, the invention is illustrated as being implemented in a suitable computing environment. The following description is based on exemplary embodiments of the invention and should not be taken as limiting the invention in any way. Sections I through IV describe media sense awareness and notifications of changes in network connectivity. These sections are based on U.S. patent application Ser. No. 09\/652,501, \u201cSystems and Methods for Resynchronization and Notification in Response to Network Media Events.\u201d Sections V and VI build on the previous sections, describing aspects of the present invention as a service that identifies the logical networks to which a computer is attached.","In the description that follows, the invention is described with reference to acts and symbolic representations of operations that are performed by one or more computers, unless indicated otherwise. As such, it is understood that such acts and operations, which are at times referred to as being computer-executed, include the manipulation by the processing unit of the computer of electrical signals representing data in a structured form. This manipulation transforms the data or maintains them at locations in the memory system of the computer, which reconfigures or otherwise alters the operation of the computer in a manner well understood by those skilled in the art. The data structures where data are maintained are physical locations of the memory that have particular properties defined by the format of the data. However, while the invention is being described in the foregoing context, it is not meant to be limiting as those of skill in the art will appreciate that various of the acts and operations described hereinafter may also be implemented in hardware.","Sections following this one discuss how computer systems may respond when they sense network media events. This section provides information about the events themselves.","In , several computer systems with different communications mechanisms are configured to communicate with one another. While  shows all of the computing devices as resembling general-purpose computers, they may in practice range from multiprocessor mainframes to personal digital assistants, telephones, set top boxes for televisions, etc. A LAN  connects a first computing device , a server , and a router . The router also has a communications link to an internetwork  which may be a corporate intranet or the Internet. A second computing device  connects to the internetwork  by way of a dial-up modem  and telephone line. A third computing device  uses wireless technology to communicate. The wireless technology may be, for example, infrared or optical, but this example portrays a radio connection. Two radio access points (RAPs),  and , are connected to the internetwork  and may enable the third computing device  to communicate with the other computing devices connected to the internetwork. The first computing device  can also communicate via wireless means, in addition to using the LAN .",{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 2","FIG. 2","FIG. 2","FIG. 2","FIG. 1"],"b":["100","100","100","200","202","202","204","100","206","208","202","206","208","100","100","210","210","106","100","212","214"]},"Network logic within a computing device constantly monitors the characteristics of the physical medium that links the device to a network. Very generally, when that logic senses a change in the medium's characteristics, the logic reacts, possibly changing the way the device connects to the network. Also, the network logic informs applications running on the device of the change so that they may react appropriately. The following examples of network media events will aid in understanding the teachings of the present invention. Sections following this one describe in detail responses to the sensed change, both from the network logic and from the applications.","In a first example, assume that the computing device  is monitoring its link to the LAN  for the most fundamental of network media events: a media disconnect. In a media disconnect event, all incoming and outgoing traffic fails on the link. The manner in which a disconnect event is sensed may vary with the type of link. On some links, the computing device may sense the disconnect immediately while in others, the computing device may not know until a certain amount of time passes without detectable activity on the link. In any case, the response is usually the same with the computing device first attempting to reconnect to the network over the link. Failing that, the computing device might attempt to communicate over another link. This particular computing device may try the latter strategy because it has a radio transmitter. With the LAN inaccessible, the computing device may be able to reroute its traffic to RAP A  and then on to the other devices.","The complement of a media disconnect event is a media connect event. The computing device  may note that its connection to the LAN  is now working again. If that connection is faster or cheaper than the computing device's radio link, the computing device  may reroute its traffic off the radio link and back onto the LAN. In one embodiment of the present invention, the computing device  keeps track of how long the link was disconnected. If the disconnect period was very short, then the computing device proceeds to use the link as if nothing happened. For longer disconnects, however, procedures running on the computing device or on other devices may have timed out. In such a situation, the computing device needs to reestablish the network link as if it were connecting for the first time. Devices that are not always connected to a network, such as the computing device  that dials in, must go through this new connection routine whenever they access a network. To complicate matters, the computing device cannot always assume that the network to which it is now connected is the same network to which it was connected before the media disconnect event. In one embodiment of the present invention, the computing device performs some type of discovery to learn the nature of the newly connected network.","Wireless complicates these simple scenarios of media disconnect and connect events. Assume that the computing device  is using its transmitter to access devices via RAP A . Assume also that the computing device  is moving away from RAP A toward RAP B . While moving, the computing device monitors the strength of the signals coming from the two RAPs. The strength of RAP A's signal could suddenly go to zero which would be analogous to the LAN media disconnect event discussed above, but it is much more likely that the signal will gradually fade. Sensing the fade, the computing device may try to connect to RAP B even while the signal from RAP A is still tolerable. Thus, a wireless link is susceptible to more than simple media disconnect and connect events because the wireless link is not just \u201cup\u201d or \u201cdown\u201d but may be \u201cbetter\u201d or \u201cworse\u201d or \u201cmostly the same\u201d as one or more other available links. A wireless computing device may need to closely monitor all available links in order to make intelligent transmission choices.","This radio scenario hints at more complications of wireless communications. A wired device usually knows how many connections it can have: at most, one per network interface. A wireless device, on the other hand, has a potential connection to each access point whose signal strength is above a given threshold and these access points may appear and disappear unpredictably. This exacerbates the problem mentioned above in relation to wired networks: a connect following a disconnect need not be to the same network. In one embodiment of the invention, wireless links are checked to see to what they are connecting.","Going beyond media disconnect and connect events, network logic may detect a change in the error rate of data transmitted over the link. This may be due to link degradation, such as when a standard telephone line gets, wet, when a radio access point moves farther away, or when a radio link suffers from increased interference. The increased error rate may also be caused by a defective network interface card connected to the network, or may simply be a result of increased traffic loads on the network. If the detected error rate exceeds a certain amount, then the network logic may look to use another network link, even though the current link is not in any sense disconnected.","The effective data rate that a computing device gets from a network link may decrease, independently of any increase in the error rate on the link. This may be due to increased use by others of a shared link or by link logic changing the link's transmission characteristics to accommodate changes in its operating environment. The response could well be the same as for an increased error rate: the network logic could search for another link.","Devices may want to respond to changing conditions before they result in actual errors. For example, network logic may sense that the response time on a network link is increasing substantially, although it is still within the parameters formally defined as acceptable for this type of network link. By definition, this is not an error condition, but the network logic may still use this information in considering whether to send traffic by a different route.","Other types of media events can be sensed including a change in the latency experienced by packets traversing the network, a change in the variation in latency (jitter), a change in the maximum packet size allowed on the network, etc. Responses can be developed for many of these events.","The above examples begin to show the richness of the information available to a device that is critically aware of the state of its network media. The following sections build on this richness to show some of things that can be done with this information.","Before detailing how the network logic responds to network media events that it senses, it may help to have in mind one particular embodiment of that network logic. On each computing device in , network logic implements the communications protocols used. Many, but not quite all, of today's communications protocols follow the International Standards Organization Open Systems Interconnection (ISO\/OSI) protocol model shown in . In this model, the overall task of enabling network communications is divided into subtasks and those subtasks are each assigned to a logical layer in the protocol stack. The stack is hierarchical: each layer has a defined interface with the layers above and below it. Logically, each layer communicates with its peer layer on another computer, provides services to the layer above it in the stack, and uses the services provided by the layer below it. Physically, data flow down the stack from their originator until the physical layer  actually transmits them across the medium of the network connection, shown here as a LAN . When the data are received by the target computer, they are passed up the stack with each layer stripping off and responding to the data meant for it while passing the rest of the data up to the next level. For example, the network layer  defines how data are routed among networks. The network layer on one computer logically speaks with the network layer on another computer by passing a packet of data down to the data layer  on its own computer. The data layer in turn adds a header to the network layer's packet thus creating a data frame which it passes to the physical layer. The physical layer uses the physical network medium to transmit that data frame. When the data frame is received by the target computer, the target's data layer reads the data frame, stripping from it the header information meant for its own use. Then the data layer takes the rest of the frame, consisting of the originator's data packet, and sends it up to the network layer. Thus, the network layer on the target reads the data as sent by the network layer on the originator without having to decode the data layer header and other information used by the lower layers to transmit the data packet.","The primary advantage of this scheme is that application programs  can communicate with each other without concerning themselves with the myriad details of establishing and maintaining a network connection. Protocol layers find the remote application programs with which the originating application program wishes to speak, retransmit information damaged during transmission, ensure that information is received in order, reroute information when communications links fail, and do all the other tasks necessary to present as flawless as possible a connection to the application programs.","It should be remembered that the ISO\/OSI protocol stack is a conceptual model only and that no protocol follows it exactly. However, many popular protocols in use today follow this model to a greater or lesser extent and the model makes discussion of the communications tasks it defines more easily comprehendible.","The ISO\/OSI model does not, however, specify how a computing device  should internally implement the tasks required to support an ISO\/OSI layered communications protocol.  shows one possible implementation of a computing device supporting the popular Transmission Control Protocol\/Internet Protocol (TCP\/IP) stack. In this embodiment, but not necessarily in all embodiments, communications flow up and down a stack of computing components that is closely analogous to the layered stack in the ISO\/OSI model. Network communications services are presented to the application program  by the socket layer . The socket layer insulates the application program from the details of the ISO\/OSI communications protocol. This insulation is especially valuable when a computing device is connected to more than one network and running more than one communications protocol. (For an example of this, see .) When the application program calls a routine in the socket layer to send data to an application program on another computing device, the request works its way down the stack of protocol components with each component communicating with its peer on the other computing device as per the ISO\/OSI model. Even in this embodiment, however, some components do not map directly to ISO\/OSI layers. Some protocols do not implement all of the ISO\/OSI layers, as shown here by the lack of a specific layer  (Session Layer) component. An implementation may also combine the functionality of several ISO\/OSI layers into one component. In , layers  (Network Layer) and  (Transport Layer) are supported by a combined TCP\/IP driver . A complicated protocol such as TCP\/IP requires functions beyond the simple transport of data. In , these functions are represented by the 802.1X component , which provides authentication services, and by the dynamic host configuration protocol (DHCP) service , which provides for non-static network addresses.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 4B","FIG. 4A"],"b":["300","414","416","418","420","3","4","406","422"]},"According to one embodiment of the present invention, having sensed one of the several types of network media events discussed above, the network logic analyzes that event and responds in a manner calculated to best preserve effective communications. The response varies not only with the event, but with the existing communications environment, with the computing device on which the network logic is running, and with the specific implementation of the network logic. This section details responses to some events, taking examples from one possible implementation of the network logic. For purposes of illustration, the computing device is taken to be the general-purpose computer  of , connected to a TCP\/IP network . In general, however, the computing device may be any device connected to any communications link, such as a networked printer or even a telephone, etc.","On a Media Disconnect Event","In a preferred embodiment, when a physical layer driver ( in ) detects that its network media has been disconnected, it passes a notification of the event up the protocol stack to the Network Device Interface Specification (NDIS) . NDIS uses the IPStatus callback function to pass the notification to the TCP\/IP driver .","At this point, the TCP\/IP driver  may choose to wait for a short time and then query the lower protocol levels for the status of the network connection media. If the problem has been cleared up, then the TCP\/IP driver need do nothing more. This strategy smoothes out transient problems without having to inform the application programs .","If a computing device is equipped with more than one network interface (as is the case, for example, with the first computing device  in ), then the network logic attempts to reroute traffic intended for the failed network interface  to another network interface. In one embodiment of the present invention, this reroute is done entirely within the protocol stack, transparently to the application programs . Note, however, that even if traffic can be rerouted, the TCP\/IP driver  may choose to remove the address (or mark it unusable) and give an \u201cIP address deletion\u201d notification. This allows media sense aware applications to synchronize to the new state, if necessary. For example, routing software can respond to an immediate notification of a media disconnect or connect event. The routing software can then use its routing protocol to tell other routers about the event.","If a second network interface is available, the network logic may need to perform one or more of the following operations, in addition to rerouting traffic.\n\n","If the problem persists and traffic cannot be transparently rerouted, then the TCP\/IP driver  removes the TCP\/IP address associated with the failed network interface  and passes an \u201cIP address deletion\u201d notification up the stack. Application programs  receive that notification through the Transport Driver Interface , IPHLPAPI callbacks, the Winsock API (Application Program Interface), or Microsoft's Windows Management Instrumentation. The notification allows users of the TCP\/IP protocol stack to operate in the \u201cnetwork unreachable\u201d mode.","The next section describes other responses taken by application programs when they receive this notification.","On Media Connect Event","Notice of the event is passed up the stack, just as in the case of a media disconnect event, described immediately above. The TCP\/IP driver  passes the notice up to the DHCP service . The DHCP service requests either a DHCP renew or a DHCP discover, the choice depending on whether the service has a non-expired or an expired lease at the time of the media connect event. The TCP\/IP driver gets an IP address and other network configuration information (which may either be a renewal of the configuration existing prior to a media disconnect event or may be new). The TCP\/IP driver then passes up the stack a \u201csomething changed\u201d notification. Higher-level protocol drivers respond to this notification by tuning their behavior to use the new network connection in the most optimal manner possible. Some application programs  may not recognize the notification; they might have to be restarted to ensure that they use the new network configuration.","If the computing device  were disconnected from one network and then connected to another, its DHCP renew or discover request would be answered with a NACK from the new network's DHCP server. The computing device then gets a new address and configuration from the new network's DHCP server.","If the computing device has a statically configured address, then there is normally no need for a DHCP renewal or discovery. The static address is simply replumbed to make the protocol stack operational on the newly connected network interface. However, an Address Request Protocol message is sent to detect whether the static address is a duplicate of an address already in use. In the case of a disconnect from one network followed by a connect to another, the computing device can discover to which network it is connected by sending a DHCP discover. If the computing device determines that it is on a different network from the one for which it is configured, it can decide to stay in the disconnected state, go into the auto-net state in order to gain connectivity to other auto-net machines, or simply take the returned DHCP address if the DHCP server is available. A stored policy can tell the computing device which action to take in this situation.","Once the computing device has discovered and plumbed its new network configuration, it can proceed to do the following. The computing device rejoins the IP multicast groups it was in before the media disconnect event. There are two types of groups to be joined\u2014permanent and temporary. The \u201call hosts multicast\u201d and \u201call routers multicast\u201d groups are examples of permanent groups that all hosts and all routers, respectively, must join. Temporary groups are those that a computing device joins as a result of a request from an application program. On a media connect event, the computing device automatically joins the permanent groups when the protocol stack is initialized as part of the address plumbing. Media sense aware application programs can then request that the computing device rejoin its temporary groups.","If IPsec policies were in effect on the computing device, then they should be plumbed correctly. For example, the IPsec policy:\n\nfrom\/to me to\/from <IP addresses or wild card>, use 3DES encryption and MD5 authentication\n\nshould be plumbed. Note that if the IP address changes as a result of the media connect event, \u201cme\u201d in this IPsec policy would expand to the new IP address. This ensures that no information leaks as a result of the change from the former network to the new.\n","If a quality of service policy of the type:\n\n","If the computing device is \u201cICMP router discovery enabled,\u201d then it sends router discovery requests in order to discover the routers on the network. Similarly, the computing device discovers if other servers and services are available on the new network.","On a Change in Carrier Strength Event","As discussed above, a wireless computing device  moving away from one RAP  toward another RAP  will probably experience a degradation in the signal strength of the former RAP while the strength of the latter's signal increases. The computing device need not wait for an actual media disconnect on the RAP it is using but can anticipate it and respond by scanning for other RAPs. Upon notification of a change in signal strength, the computing device decides whether it is appropriate to connect to a new RAP. If so, it makes the connection and triggers a media connect event specifying the new RAP. Higher-level protocol drivers and applications are notified that the connection was not lost but may have changed. In addition, the following actions are taken:\n\n","Other network media events described above in the section entitled \u201cSensing Network Media Events\u201d include a change in the error rate on the communications link, a change in the effective throughput on the link, and a change in the response time of some other device on the network. The same principles described above can be used to enable the network logic to respond to these other network media events.","As described above, sometimes the network logic can respond to a network media event in such a manner that the application programs need never know of the event. More generally, however, the application programs are informed that something changed so that they may try to alter their operations in response to the changed circumstances caused by the event.","On a Network Changed Event","This is a \u201cgeneric\u201d event, indicating that something has changed but not saying what. Upon receiving notification of this event, the application enquires to determine what has changed. The most common possibilities are described below.","Media Disconnect","An application program may choose to close down if it cannot operate without network access. On the other hand, some application programs may continue to perform as best as they can while waiting to take advantage of a possible reconnect event in the near future. These applications inform their users of the problem and, if the original network connection cannot be reestablished, they remain ready to take advantage of a new network connection if one becomes available.","Some application programs may not recognize the notification of a media disconnect and so cannot immediately respond to the new circumstances. However, as soon as they attempt an operation on the failed network connection, they will receive a \u201cnetwork disconnected or unreachable\u201d error and can then respond appropriately.","Media Connect","If there were no working network connections before this event, then the application program changes its state from \u201cnetwork unreachable\u201d to \u201cnetwork initializing\u201d and goes through network initialization. This involves re-registering names and multicast groups on the new network.","Because applications vary widely in purpose one from another, they also vary widely in how they respond to changes in network connectivity. Some specific examples are given below.","An Internet browser application may query the new network configuration received from the DHCP server to see if the network contains a proxy server. If so, the browser can set itself up to use the proxy server.","The DNS Resolver service caches DNS server addresses so it is important that it notes any changes in those addresses. The new network configuration received from the DHCP server has this information.","The NetBIOS client notes changes to the WINS server addresses (also found in the new network's DHCP configuration) and uses those new WINS servers for NetBIOS name registrations, releases, and queries.","The printer service notes changes to the printer addresses (also found in the new network's DHCP configuration) and uses the new printers for servicing print requests.","An application program that receives a multicast stream via the Scalable Reliable Multicast mechanism may check to see if the available bandwidth on the new network connection is lower than it was on the previous network connection. If so, the application may inform the sending application so that it can throttle the send rate and thus avoid data loss within the network and subsequent retransmissions. In a like manner, an application sending a multicast stream may check the availability of bandwidth on the new network connection and adjust its send rate accordingly.","While the computing device was not connected to the network, a logon service may have granted access to a user on the basis of cached credentials. On reestablishing the network connection, the logon service can query a security server for the logon credentials.","The section immediately preceding this one gives examples of applications' responses to network media connect events. Because applications may need to adapt their behavior to the nature of the logical networks to which their host computer is attached, the applications seek to discover the nature of a newly connected network by communicating with devices on that network. Complications arise because networks differ in the set of discovery techniques applicable to them. Accordingly, one aspect of the present invention removes the burden of supporting all of the various discovery techniques from the applications. In accordance with the present invention, a set of services, for the sake of discussion called the Network Location Resolution Service Provider (NLRSP), is provided by the host computer to discover aspects of the new network connections. The discovered information is provided to applications through a common API.",{"@attributes":{"id":"p-0076","num":"0081"},"figref":"FIG. 5","b":"500"},"In step  of , the NLRSP constructs names for each logical network connected to the computer. The name given to a logical network is created by the NLRSP in such a manner that the combination of the name and the method through which the name was obtained uniquely identifies the logical network within the context of the computer. The NLRSP also tries to generate names in such a manner that there is a \u201cone-to-one\u201d mapping between the names and the logical networks. This one-to-one mapping has two fundamental properties. First, different logical networks are given different names. Second, a given logical network is given the same name whenever the computer connects to it. These properties are called \u201cuniqueness\u201d and \u201cpersistence,\u201d respectively. Because the network names are unique and persistent, applications may rely on them when selecting a configuration to use with a given logical network.","In order to try to construct a name that is both unique and persistent, the NLRSP follows a set formula for applying information it discovers about the network. First, the NLRSP searches the logical network for information, and only when it has enough information about the network does it construct a name that applies to no other network (uniqueness). Information used by embodiments of the NLRSP to construct network names includes the domain name of the network (obtainable via DHCP), static information entered by a user to name a network, and subnet addresses. On networks that support the 802.1X authentication protocol, the NLRSP can construct a network name based on the network identity string returned in an EAP Identity Request message. Second, by following a set formula, the NLRSP usually constructs the same name for the same logical network (persistence). Different embodiments of the invention may depend upon different methods for gathering logical network information, and some of these methods may, in certain circumstances, lead to names that violate either the uniqueness or the persistence property of an ideal mapping. The text accompanying , A, and B explain some of these situations and show why the information provided by the invention is still useful.","Step  of  illustrates that in some embodiments of the present invention, the NLRSP correlates the network name it constructs with other information. A globally unique identifier (GUID) may be given that identifies the computer's physical network interface through which the network is accessible. The GUID can be used by the application when asking for more information about the interface. The network name is also correlated to the APIs of the transport protocols supported by the network. Other information correlated to the network name may include the type of the network interface (e.g., Ethernet or Point-to-Point Protocol), the speed of the network interface, the name of the network access device which supports the network interface, and the port on the network access device through which this connection to the network is made. If the computer has multiple interfaces to the same logical network, then the NLRSP may generate information about each interface, and, while the network name for each interface will be the same, the different interfaces can be distinguished by their GUIDs.","In Step  of , the NLRSP presents its information to applications. Applications ask for information and may register to be informed when the information changes. The NLRSP keeps track of the information given to an application and notifies the application whenever any of the information given changes or when new information becomes available.",{"@attributes":{"id":"p-0081","num":"0086"},"figref":["FIGS. 6A and 6B","FIG. 6A"],"b":["100","106"]},{"@attributes":{"id":"p-0082","num":"0087"},"figref":["FIG. 6B","FIG. 6A","FIG. 6A","FIG. 6B"],"b":["600","602","604","606","608","604"]},{"@attributes":{"id":"p-0083","num":"0088"},"figref":"FIG. 6B","b":["100","610","612"]},{"@attributes":{"id":"p-0084","num":"0089"},"figref":"FIGS. 7A and 7B","b":["100","606"]},{"@attributes":{"id":"p-0085","num":"0090"},"figref":["FIGS. 8A through 8C","FIG. 8A","FIGS. 6A and 7A","FIG. 8B","FIG. 8C","FIG. 8B","FIG. 8C"],"b":["100","106","800"]},"In certain circumstances, it may be very difficult to create a mapping that conforms to the strict requirements of uniqueness and persistence. In , as in , the ISP provides the same network name to all its dial-in customers. If a user and her neighbor subscribe to the same ISP, then a laptop  will report the same network name (\u201cmyISP.net\u201d) whether it is connected at the user's home or at her neighbor's house. This mapping may violate the uniqueness property because it uses the same network name for connections originating from two different locations. However, this mapping may still be useful in choosing which network configuration to use because the user would most likely want to use the same network configuration when dialing into her ISP regardless of her location when dialing.","In the scenario depicted in , the property of persistence is violated. One night, a system administrator changes the name of the corporate network from \u201cworldWideWork.com\u201d to \u201ccaptivatingCareer.com.\u201d When the user plugs in her laptop  at work the next day, the invention maps the corporate network to the name \u201ccaptivatingCareer.com.\u201d The mapping is not persistent because the same network is given different names on different days. Although the laptop has no configuration stored for use with the new name, this problem is easily remedied. The laptop presents the new network name to the user and asks for guidance as to which configuration to use. Realizing what happened, the user directs her laptop to use the configuration once associated with \u201cworldWideWork.com.\u201d",{"@attributes":{"id":"p-0088","num":"0093"},"figref":["FIGS. 11A","FIG. 11A","FIG. 11B","FIG. 11B","FIG. 8A"],"b":["11","11","11","100","1100","1110","1102","1112","100","1108","1104","800","1114","1106","1110","1112","1114"]},"In addition to determining the connectivity type of the networks, the NLRSP checks to see if each network provides connectivity to the Internet.  shows how this may be accomplished. In step , the NLRSP checks some preliminary information. Then, in step , the NLRSP tries to resolve an Internet name. The particular name used is of little importance. If the name is resolved, then the network has connectivity to the Internet.",{"@attributes":{"id":"p-0090","num":"0095"},"figref":["FIG. 11D","FIG. 11A","FIG. 6B"],"b":"600"},"In some circumstances, domain administrators need to set up group policies to tailor network usage. These policies are preferably based on connectivity information presented by the NLRSP. For example, an ICS group policy may allow users to enable and run ICS at home but prohibit them from using ICS if the NLRSP detects that the computer is connected to a corporate network. Similarly, for safety's sake, a user may run a firewall application to guard the computer's network links if the user is at home or on the road. However, that firewall application becomes merely a nuisance if it is run on links to a network already protected by a dedicated firewall, such as a corporate network. The group policy may disable the firewall for those links, and only for those links, connected to the corporate network. Many other scenarios can be imagined where group policies are based on knowing the specific networks to which a computer is connected.","This section details one embodiment of the present invention, directed toward Microsoft's \u201cWINDOWS\u201d operating system. In this embodiment, the invention is presented as an API that allows applications to enumerate all of the logical networks  currently accessible from the application's host computer, to identify the name given to a logical network, and to identify the transport address of the physical network interface to a logical network. In addition, the WSANSPIoctl function is used to notify applications when information previously provided to them changes.","WSANSPIoctl","The Windows Sockets WSANSPIoctl function provides a method for making Input\/Output control calls to a registered namespace. It has the following structure:",{"@attributes":{"id":"p-0094","num":"0099"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"INT WSAPI WSANSPIoctl"]},{"entry":[{},"("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003HANDLE","hLookup,"]},{"entry":[{},"\u2003DWORD","dwControlCode,"]},{"entry":[{},"\u2003PVOID","pvInBuffer,"]},{"entry":[{},"\u2003PDWORD","pcbInBuffer,"]},{"entry":[{},"\u2003PVOID","pvOutBuffer,"]},{"entry":[{},"\u2003PDWORD","pcbOutBuffer,"]},{"entry":[{},"\u2003PWSACOMPLETION","pCompletion"]},{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"hLookup\n\n","dwControlCode\n\n","pvInBuffer\n\n","cbInBuffer\n\n","pvOutBuffer\n\n","pcbOutBuffer\n\n","pCompletion\n\n","Upon successful completion, WSANSPIoctl returns NO_ERROR. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling WSAGetLastError.","Error Codes:","WSANOTINIALISED\n\n","WSA_NVALID_HANDLE\n\n","WSAEFAULT\n\n","WSAEOPNOTSUPP\n\n","WSAEINVAL\n\n","WSA_NOT_ENOUGH_MEMORY\n\n","WSAEWOULDBLOCK\n\n","WSA_OPERATION_ABORTED\n\n","WSASYSCALLFAILURE\n\n","The WSANSPIoctl function is used to set or retrieve operating parameters associated with a namespace query handle.","Any IOCTL may block indefinitely, depending upon the relevant namespace's implementation. If an application cannot tolerate blocking in a WSANSPIoctl call, it uses overlapped Input\/Output. For these operations, which cannot be completed immediately, completion is indicated later through the mechanism specified in the pCompletion parameter, which is a pointer to a WSACOMPLETION structure. If pCompletion is NULL, this is a blocking call. To make this call non-blocking and return immediately, set WSACOMPLETION::Type to LUP_NOTIFY_IMMEDIATELY.",{"@attributes":{"id":"p-0114","num":"0135"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"WSACOMPLETION"]},{"entry":[{},"\u2003typedef struct_wsacompletion"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003enum_type"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003LUP_NOTIFY_IMMEDIATELY,"]},{"entry":[{},"\u2003\u2003\u2003LUP_NOTIFY_HWND,"]},{"entry":[{},"\u2003\u2003\u2003LUP_NOTIFY_EVENT,"]},{"entry":[{},"\u2003\u2003\u2003LUP_NOTIFY_PORT,"]},{"entry":[{},"\u2003\u2003\u2003LUP_NOTIFY_APC"]},{"entry":[{},"\u2003\u2003} Type;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003PVOID","Recipient;"]},{"entry":[{},"\u2003\u2003UINT_PTR","Completion;"]},{"entry":[{},"\u2003\u2003PWSAOVERLAPPED","Overlapped;"]},{"entry":[{},"\u2003}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"Members:\n\n","The following IOCTL code (command) is supported by NLA:","SIO_NSP_NOTIFY_CHANGE","This operation checks if the query results returned via calls to WSALookupServiceBegin and WSALookupServiceNext remain valid. If pCompletion is NULL, this operation is a poll and returns immediately. If the query set remains valid, WSAEWOULDBLOCK is returned to indicate that later invalidation will require an asynchronous notification. If the query set has changed and is invalid, NO_ERROR is returned indicating success in polling for invalidation of the query set. Not all name resolution protocols will be able to support this feature and thus this call may fail with WSAEOPNOTSUPP. A query containing data from multiple providers cannot call this IOCTL and will return WSAEINVAL.","pvInBuffer, pcbInBuffer, pvOutBuffer, and pcbOutBuffer are ignored.","Some protocols may simply cache the information locally and invalidate it after some time, in which case a notification is issued to indicate that the local cache has been invalidated.","For name resolution protocols where changes are infrequent, it is possible for a namespace service provider to indicate a global change event that may not be applicable to the query on which change notification was requested and issued.","Immediate poll operations are usually much less expensive because they do not require a notification object. In most cases, this is implemented as a simple Boolean variable check. Asynchronous notification, on the other hand, in addition to expenses related to the notification object involved with signaling the change event, may (depending on the implementation of the namespace service provider) necessitate the creation of dedicated worker threads or inter-process communication channels.","To cancel an asynchronous notification request, simply end the original query with a WSALookupServiceEnd call on the affected query handle. Canceling asynchronous notification for LUP_NOTIFY_HWND will not post any message, however an overlapped operation will be completed, and notification will be delivered with the error WSA_OPERATION_ABORTED.","Upon signaling an invalidation of query data, a namespace should permit, through extended semantics of WSALookupServiceNext, an application to query what about the data has changed.","Queries","Queries are performed using the following namespace calls.","NSPLookupServiceBegin","The returned lphHandle for the query is an internal LPNLA_QUERY_HANDLE structure allocated on a private heap for the namespace. It is treated as an opaque object by the application and not modified. It is not a true handle so WSAGetOverlappedResult cannot be used. The resulting query set comprises the adapter enumeration from GetAdaptersInfo and a registry-merge of non-active, saved network names. Registry-merge is the process of obtaining user-specific, persistent network names from HKEY_CURRENT_USER, combining the resulting list with global-system, persistent network names from HKEY_LOCAL_MACHINE, matching or adding them as appropriate to the adapter enumeration list, and producing a list of WSAQUERYSETW structures.","LUP_RETURN_NAME, LUP_RETURN_COMMENT, LUP_DEEP, and LUP_RETURN_BLOB may be set in dwControlFlags. These affect the output from future calls to NSPLookupServiceNext. Future calls only return the networks that contain the requested fields. For example, if LUP_RETURN_BLOB is requested, then only those networks with blob (binary large object) information will be returned from calls to NSPLookupServiceNext regardless of which controls flags are passed in. When LUP_DEEP is specified, NLA returns extended network information which may take a long time to acquire.","Error Codes:","WSANOTINITIALISED\n\n","WSASERVICE_NOT_FOUND\n\n","WSAEINVAL\n\n","WSANO_DATA\n\n","WSAEFAULT\n\n","WSA_NOT_ENOUGH_MEMORY\n\n","WSAEACCESS\n\n","WSAESYSNOTREADY\n\n","First, the lphhandle is checked to see that it is a true handle returned by NSPLookupServiceBegin. If valid, a new WSAQUERYSETW is copied into lpqsResults. If LUP_RETURN_BLOB was specified and various information about the networks exists, the information is returned in lpqsResults->lpBlob. Pointers in the view of the mapped file are offset relative to the beginning of each individual WSAQUERYSETW. These are changed to actual addresses in the namespace's process address space before being returned from this call. The resulting WSAQUERYSETW is formatted as follows.","LUP_RETURN_NAME, LUP_RETURN_COMMENT, and LUP_RETURN_BLOB may be set in dwControlFlags. These are independent of those supported in NSPLookupServiceBegin.","Upon receiving a WSA_E_NO_MORE from a WSALookupServiceNext call, if WSANSPIoctl was called with SIO_NSP_NOTIFY_CHANGE which succeeded immediately or returned pending, then WSALookupServiceNext may be called again to enumerate those networks that have changed. dwOutputFlags will contain one of the following:","RESULT_IS_ADDED","RESULT_IS_CHANGED","RESULT_IS_DELETED","A change can be indicated when any field which was requested at the time of WSALookupServiceBegin changes in any way.","When the enumeration completes, WSA_E_NO_MORE is received. A SIO_NSP_NOTIFY_CHANGE may be reissued at any time.","Error Codes:","WSANOTINITIALISED\n\n","WSAEINVAL\n\n","WSA_NVAL_HANDLE\n\n","WSAESYSNOTAVAIL\n\n","WSAEACCESS\n\n","WSAEFAULT\n\n","WSA_NOT_ENOUGH_MEMORY\n\n","WSA_E_NO_MORE\n\n","WSAESYSNOTREADY\n\n","The lookup handle is deallocated from the namespace private heap, and if the reference count hits zero, the LPC connection to the service is closed.","Error Codes:","WSANOTINITIALISED\n\n","WSA_INVALID_HANDLE\n\n","When LUP_RETURN_BLOB is specified for a given query, NLA attaches relevant NLA_BLOB entries to the resultant data in calls to NSPLookupServiceNext via (PNLA_BLOB)lpqsResults->lpBlob->pBlobData with the following format:",{"@attributes":{"id":"p-0155","num":"0203"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef enum_NLA_BLOB_DATA_TYPE"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003NLA_RAW_DATA","= 0,"]},{"entry":["\u2003NLA_INTERFACE","= 1,"]},{"entry":["\u2003NLA_802_1X_LOCATION","= 2,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003NLA_CONNECTIVITY","= 3,","\/\/ LUP_DEEP"]},{"entry":[{},{},"required."]},{"entry":["\u2003NLA_ICS","= 4,","\/\/ LUP_DEEP"]},{"entry":[{},{},"required."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} NLA_BLOB_DATA_TYPE, *PNLA_BLOB_DATA_TYPE;"},{"entry":"typedef enum_NLA_CONNECTIVITY_TYPE"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003NLA_NETWORK_AD_HOC","= 0,"]},{"entry":["\u2003NLA_NETWORK_MANAGED","= 1,"]},{"entry":["\u2003NLA_NETWORK_UNMANAGED","= 2,"]},{"entry":["\u2003NLA_NETWORK_UNKNOWN","= 3,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} NLA_CONNECTIVITY_TYPE, *PNLA_CONNECTIVITY_TYPE;"},{"entry":"typedef enum_NLA_INTERNET"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003NLA_INTERNET_UNKNOWN","= 0,"]},{"entry":["\u2003NLA_INTERNET_NO","= 1,"]},{"entry":["\u2003NLA_INTERNET_YES","= 2,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} NLA_INTERNET, *PNLA_INTERNET;"},{"entry":"typedef struct_NLA_BLOB"},{"entry":"{"},{"entry":"\u2003struct"},{"entry":"\u2003{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003NLA_BLOB_DATA_TYPE","type;"]},{"entry":["\u2003\u2003DWORD","dwSize;"]},{"entry":["\u2003\u2003DWORD","nextOffset;"]},{"entry":"\u2003} header;"},{"entry":"\u2003union"},{"entry":"\u2003{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\u2003\u2003\/\/ header.type -> NLA_RAW_DATA"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003CHAR","rawData[1];"]},{"entry":"\u2003\u2003\/\/ header.type -> NLA_INTERFACE"},{"entry":"\u2003\u2003struct"},{"entry":"\u2003\u2003{"},{"entry":["\u2003\u2003\u2003DWORD","dwType;"]},{"entry":["\u2003\u2003\u2003DWORD","dwSpeed;"]},{"entry":["\u2003\u2003\u2003CHAR","adapterName[1];"]},{"entry":"\u2003\u2003} interfaceData;"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\/\/ header.type -> NLA_802_1X_LOCATION"},{"entry":"\u2003\u2003struct"},{"entry":"\u2003\u2003{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003\u2003CHAR","information[1];"]},{"entry":"\u2003\u2003} locationData;"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\/\/ header.type -> NLA_CONNECTIVITY"},{"entry":"\u2003\u2003struct"},{"entry":"\u2003\u2003{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003\u2003NLA_CONNECTIVITY_TYPE","type;"]},{"entry":["\u2003\u2003\u2003NLA_INTERNET","internet;"]},{"entry":"\u2003\u2003} connectivity;"},{"entry":"\u2003\u2003\/\/ header.type -> NLA_ICS"},{"entry":"\u2003\u2003struct"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003struct"},{"entry":"\u2003\u2003\u2003{"},{"entry":["\u2003\u2003\u2003\u2003DWORD","speed;"]},{"entry":["\u2003\u2003\u2003\u2003DWORD","type;"]},{"entry":["\u2003\u2003\u2003\u2003DWORD","state;"]},{"entry":["\u2003\u2003\u2003\u2003WCHAR","machineName[256];"]},{"entry":["\u2003\u2003\u2003\u2003WCHAR","sharedAdapterName[256];"]},{"entry":"\u2003\u2003\u2003} remote;"},{"entry":"\u2003\u2003} ICS;"},{"entry":"\u2003} data;"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} NLA_BLOB, *PNLA_BLOB, *FAR LPNLA_BLOB;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"To eliminate the need for worker threads in the namespace dynamic library to wait upon change notification events and then translate them into the user-requested notification type, an NLA system service, running as localsystem under svchost.exe, is used. This also minimizes the number of recipients of change events to a single process for the entire system which then filters out the events only to the processes that are interested in such changes.","Upon system startup, the NLA service starts an LPC server port in a worker thread. It then blocks waiting for connection and notification-change registrations from a process using the namespace. When a new connection is registered, a FILE_MAP_READ file mapping handle is given to the calling client, and an LPC request is issued to obtain the network data separately.","When WSANSPIoctl is invoked upon a valid query handle with the operation SIO_NSP_NOTIFY_CHANGE, the service is given a duplicate of the query's registry key handle, and a change notification request is registered via the LPC connection. When the DHCP service signals in the service's main thread, the service reconstructs the file mapping, performs all client change-notifications, and clears the registration list. If a particular user registry key updates, that particular registration is notified and removed from the registration list. If an LPC connection is broken, the service removes that application's query sets from the registration set.","Superfluous notifications are permissible.","Network Persistence and Friendly Names","The mapping method maintains its quality of persistence even through the period during which a network is not active. That is to say, a network is given the same name whether or not that network is currently active. This property allows an application to configure to an inactive network, waiting for the network to become active.","NSPSetService","Parameters:","IpqsRegInfo\n\n","essOperation\n\n","dwControlFlags\n\n","WSANOTINITLKLISED\n\n","WSASERVICE_NOT_FOUND\n\n","WSAEINVAL\n\n","WSAEFAULT\n\n","WSAEACCESS\n\n","Because LPC is used, cleanup is simple as the NLA service will be notified of port closure.","The embodiments described above are illustrative only and are not intended to limit the scope of the present invention. In particular, the embodiments describe the invention with respect to TCP\/IP networking technologies and with respect to Microsoft \u201cWINDOWS\u201d operating systems but the invention applies as well to other networking technologies and to other computer technologies. The invention applies to all networks, to wireless as well as to wired network technologies. Therefore, the invention as described herein contemplates all such embodiments as may come within the scope of the following claims and equivalents thereof."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["While the appended claims set forth the features of the present invention with particularity, the invention, together with its objects and advantages, may be best understood from the following detailed description taken in conjunction with the accompanying drawings of which:",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4A"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 4B","FIG. 4A"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6A"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 6B","FIG. 6A"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIGS. 7A and 7B"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIGS. 8A through 8C"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIGS. 10A and 10B"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 11A"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 11B","FIG. 11A"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 11C"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 11D","FIG. 11A"]}]},"DETDESC":[{},{}]}
