---
title: System and method for allocating resources of a core space among a plurality of core virtual machines
abstract: A technique for executing a segmented virtual machine (VM) is disclosed. A plurality of core VM's is implemented in a plurality of core spaces. Each core VM is associated with one of a plurality of shell VM's. Resources of the core spaces are allocated among the core VM's.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07620953&OS=07620953&RS=07620953
owner: Azul Systems, Inc.
number: 07620953
owner_city: Mountain View
owner_country: US
publication_date: 20041005
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS REFERENCE TO OTHER APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","DETAILED DESCRIPTION"],"p":["Co-pending U.S. patent application Ser. No. 10\/823,414 entitled INFORMATION REDIRECTION filed Apr. 12, 2004 is incorporated herein by reference for all purposes; and co-pending U.S. patent application Ser. No. 10\/701,388 entitled MEMORY MANAGEMENT filed Aug. 4, 2003 is incorporated herein by reference for all purposes.","The present invention relates generally to virtual machines (VM's). More specifically, a segmented virtual machine is disclosed.","An increasing number of software applications are written to platform independent execution environments such as the Java Runtime Environment and the .NET Common Language Runtime. These applications generally execute within a virtual machine (VM) that provides a level of abstraction between the program execution environment and the external software interface. Applications often use middleware frameworks on top of these execution environments. Examples of such frameworks are J2EE application servers and the .NET framework.","A general purpose device, such as a computer, commonly has finite resources. If each VM's execution resources is provided by the general purpose device, any such device can only support a limited number of applications and VM's. Data centers often need to support a significant number of applications. As a result, a large number of general purpose devices are deployed for resource planning purposes, with each application allotted enough resources for its peak needs, making such a setup costly to deploy and administer.",{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1","b":["100","102","114","116","118","112","102","102","104","106","108","104","106","108","110"]},"In order to support a large number of applications, a large number of general purpose devices are deployed to accommodate the peak resource needs of the applications. It would be desirable to have a way to provide large scale application support at reduced deployment and administration costs. Also, given the existing investment in middleware frameworks and applications, an effective solution to the problem should be backward compatible with the existing applications and frameworks.","It should be appreciated that the present invention can be implemented in numerous ways, including as a process, an apparatus, a system, or a computer readable medium such as a computer readable storage medium or a computer network wherein program instructions are sent over optical or electronic communication links. It should be noted that the order of the steps of disclosed processes may be altered within the scope of the invention.","A detailed description of one or more preferred embodiments of the invention is provided below along with accompanying figures that illustrate by way of example the principles of the invention. While the invention is described in connection with such embodiments, it should be understood that the invention is not limited to any embodiment. On the contrary, the scope of the invention is limited only by the appended claims and the invention encompasses numerous alternatives, modifications and equivalents. For the purpose of example, numerous specific details are set forth in the following description in order to provide a thorough understanding of the present invention. The present invention may be practiced according to the claims without some or all of these specific details. For the purpose of clarity, technical material that is known in the technical fields related to the invention has not been described in detail so that the present invention is not unnecessarily obscured.","A system and method for an improved virtual machine (VM) are disclosed. In one embodiment, the VM segments its functionality into a shell VM and a core VM that are separate. The shell VM performs interactions with the external environment. The core VM performs VM internal execution functions including managing memory, performing computations, transferring data, processing data and processing logic. The core VM communicates through the shell VM for interaction with the external environment. Resources consumed by the core VM are separate, both logically and physically, from those consumed by the shell VM. The external environment does not need to be aware of the VM segmentation and can interact solely with the shell VM. To the external environment, the distribution of VM internal execution functions and shell functions appears transparent. The shell VM appears as a complete VM, even though it does not consume resources needed for VM internal execution.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 2A","b":["200","202","204","206","208","214","220","222","224","226","228","220","222","224","226","228","208","214"]},"The shell VM may utilize one or more communications interfaces on the shell VM device to communicate with the external applications as well as with the core VM on a core VM device. In some embodiments, the shell VM also communicates with the data storage device, and optionally with the resource manager. The interfaces are separate in some embodiments and shared in others. The shell VM may also communicate with applications that reside on the shell VM device. The core VM may utilize one or more communication interfaces on the core VM device to communicate with the shell VM on a shell VM device. In some embodiments, the core VM also communicates with the data storage device, and optionally the resource manager.","Both the shell and core VM devices may communicate with the data storage device to load necessary software components. A resource manager  may communicate with the shell VM, the core VM, the shell VM device and the core VM device, allocating and managing system resources. The resource manager is an optional part of the system and may be omitted in some embodiments.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 2B","b":["200","202","204","206"]},{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 2C","FIG. 2B"],"b":["206","216","218","220","222","200","202"]},"The shell and core VM segment the functionality of a conventional VM. The shell VM performs interactions with the external environment. For a user, a web server or a database that comes from the external environment, the interaction with the shell VM device is transparent; that is, the interaction appears to be substantially the same as the interaction with the general purpose device shown in . The shell VM appears to receive and respond to requests in substantially the same way as the conventional VM shown in . An existing system similar to the one shown in FIG.  can be transparently switched to using a new configuration similar to  without modifying the code for the application server and the application.","The external environment\u2014such as a web server or a user\u2014interacts with the system by sending requests to the shell VM device. There are many ways to conduct the interaction, including through system calls, networking calls, file input\/output (I\/O) calls, etc. For embodiments that employ Java VM, the interaction also includes using Java Native Interface (JNI) calls.","Calls into the VM are intercepted by shell VM  and forwarded to core VM  on core VM device . The calls are forwarded to the core VM using a predefined communication scheme. In one embodiment, the forwarding is performed via remote procedure calls (RPC's). The calls are received and processed by core VM , and then further processed by application server  and application . The processed result is sent to the shell VM, and eventually passed back to the caller. The core VM supports VM internal execution functionality such as maintaining memory and performing data processing in a way similar to a conventional VM.","Calls originating from the VM or the application executing within it are intercepted by core VM  and forwarded to shell VM  on shell VM device . The calls are forwarded to the shell VM using a predefined communication scheme. In one embodiment, the forwarding is performed via RPC's. The calls are received and processed by shell VM  which translates them into the proper interactions with the external environment. The processed result is sent to the core VM, and eventually passed back to the caller. The shell VM supports interactions with the external environment such as system calls, file I\/O, networking in a way similar to a conventional VM.","Segmenting functionality between a shell VM and a core VM improves the system's scalability, manageability, flexibility and efficiency. Since a shell VM is relatively lightweight and consumes fewer resources than a conventional VM, many instances of the shell VM can run on the same shell VM device. Similarly, many instances of core VM's, application servers and applications can run on the same core VM device. Since the shell VM's and the core VM's communicate via a network, there does not need to be a strict physical correspondence between the devices. A core VM device can concurrently host multiple core VM's and support multiple applications invoked by shell VM's from heterogeneous shell VM devices having different operating systems. Similarly, a shell VM device can concurrently support multiple shell VM's invoking applications on heterogeneous core VM devices.","In some embodiments, the core VM device includes specialized hardware designed to improve the performance of the core VM functionality. Many instances of core VM's executing application servers and applications can simultaneously reside on the same core VM device. The core VM device can concurrently support multiple applications invoked from heterogeneous shell VM devices. In one embodiment, a multiprocessor device with specialized hardware assists the core VM functionality. The device has the capacity to concurrently support many instances of the core VM software, executing applications and application servers, simplifying administration and increasing efficiency compared to a multitude of general purpose systems as shown in .","In the following discussion, flowcharts are used to illustrate various processes that take place for several embodiments of the system. It should be noted that application behavior and interactions with external environment depend on the individual application implementation and may vary for other embodiments.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 3","b":"300"},"In this embodiment, the shell VM is invoked by using the following command: \/bin\/java [VM configuration parameters] AppServerMain [application configuration parameters]. In this command, \/bin\/java is the execution path of the java program and points to the location of the shell VM on the data storage device. [VM configuration parameters] are optional configuration parameters that control the VM behavior. AppServerMain is the name of the main class used to start the application, and [application configuration parameters] include various configuration parameters used in the application.","Discovery of the core VM device () follows the invocation of the shell VM. The shell VM locates the core VM device in this step. In some embodiments, a resource manager that maintains policy information about available resources communicates with the shell VM and helps the shell VM locate a suitable core VM device. In other embodiments, the location of the core VM device could be specified in the [VM configuration parameters].","The core VM software is then started on the core VM device (). The shell VM may deliver the core VM software from the data storage device to the core VM device, which then launches the core VM. The shell VM and the core VM establish a connection to communicate requests, responses, etc., based on a pre-defined format. In some embodiments, the core VM software is cached on the core VM device, and thus does not need to be delivered from the data storage device.","The core VM is then initialized (). The classes needed by the core VM, including the main class and the libraries, are loaded into the core VM via file I\/O operations. In this embodiment, the shell VM handles the file I\/O operations and delivers the classes to be loaded by the core VM. In some embodiments, some classes may be cached on the core VM device.","The appropriate application is then invoked (). The code for the main class of the application is loaded and executed by the core VM. The core VM loads this class and performs operations according to the program instructions.","The application is then initialized (). The main class calls, loads, and invokes other application classes according to the instructions of the application. In this embodiment, the shell VM may need to be used to fetch the various classes by performing file I\/O interactions with external devices. The application then establishes connections to various external entities including databases, name servers, and web servers. These connections are indirect connections via the shell VM. In some embodiments, some of these connections from the core VM to external entities may be direct and bypass the shell VM. In some embodiments, the application also connects to backend systems such as Siebel and SAP. The application may communicate with the backend systems via the shell VM, using networking or JNI calls.","In a typical server application, once the application is initialized it enters a ready state (). At this point, the external applications (also referred to as clients) can make connections to the application to send requests to and receive responses from the application. Applications may open service sockets and wait for data to arrive on these sockets. The shell VM opens such service sockets for the application and relays the incoming requests to the application via the core VM.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 4","FIG. 3"],"b":["302","400","402"]},"Resource managers respond to the request () by announcing their presence. The shell VM selects a resource manager out of the replying set, establishes communication with the resource manager and sends the resource manager a resource request (). The resource request includes information about VM invocation, such as the parameters, the commands, the device and user names, etc.","The resource manager selects a core VM device to use () for this particular shell VM instance and determines the resource control parameters that would govern the resources available to the associated core VM on the core VM device. Generally, the resource manager maintains system configuration and resource allocation information for all the core VM devices as well as information regarding application resource usage policies. The resource manager makes policy decisions based on the information it maintains. The decision may be based on a variety of factors, including the resource request, the system configuration and the current state of the system. The resource manager sends the decision to the shell VM and in some cases the core VM device (). The shell VM then connects to the core VM device based on the decision, and sends the core VM device the core VM software ().",{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 5","b":["500","501","503","505"]},"The client then sends a packet that includes information about the \u201cget\u201d request (). In one embodiment, the shell VM relays the whole packet to the core VM. The core VM buffers the packet, and notifies the application that data is available. Within the core VM, the application reads bytes from a core VM buffer (). It continues to read more bytes until there is no more data in the buffer (). It is then determined whether the application has finished reading the request (). If it has not, control is transferred to step  and more data is sent and buffered. If the application has finished reading the request, it will go on to process the request ().",{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 6","b":["600","602","604","606","608"]},"If a query is sent as packets to the shell VM (), then the shell VM transfers these packets to the network (). The database that is queried then sends back the results, which are encapsulated in packets according to a pre-defined scheme. The shell VM receives the result packets from the network (), and then relays the result to the core VM () to complete any further processing ().","Upon receiving a JNI call from the application, the core VM forwards the call to the shell VM (). The shell VM then forwards the JNI calls to native libraries on the shell VM device, which perform operations according to the JNI calls (). The shell VM receives the result from the function call to the native libraries (). The shell VM then relays the result to the core VM () to complete any further processing ().",{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 7","b":["700","702","704","706","708"]},"In some embodiments, the shell VM terminates after some operations are completed. The core VM is terminated as well. The system is designed to handle both abrupt termination (shell VM terminates abruptly without notifying the core VM) and planned termination (shell VM terminates and gives the core VM notification).  is a flowchart illustrating an abrupt termination process according to one embodiment of the present invention. First, the shell VM terminates (). The core VM continuously monitors the shell VM's activities by using a heartbeat. Once the heartbeat ceases, the core VM detects that the shell VM has shut down (), the core VM then terminates ().",{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 8B","b":["810","812","814","816"]},{"@attributes":{"id":"p-0061","num":"0060"},"figref":["FIGS. 9A-9C","FIG. 9A"],"b":["904","902","904","902","906","904","906","906","902","904","906","904","906"]},"Segmentation into a shell VM  and core VM  may be transparent to external application ; that is, external application  may be unaware of any VM segmentation. Alternatively, the VM segmentation may be known by external application . As such, external application  may be specifically written for a segmented VM.","In some embodiments, shell VM  interprets operating system (OS) specific instructions and controls security, such as whether a particular connection is allowed or whether a file can be accessed. Core VM  is not necessarily OS specific, and thus many non OS specific tasks such as data processing can be passed to it.","The shell VM does not necessarily need to intercept all communication between the core VM and the external application, as shown in . In this example, external application  is shown to bypass shell VM  and communicate directly with core VM . This may occur when I\/O functions are moved from shell VM  to core VM . In some embodiments, external application  may communicate directly with core VM  using a shell bypass method, as further described in U.S. patent application Ser. No. 10\/823,414 which is incorporated by reference above.","A core VM may communicate directly with another core VM, as shown in . In this example, core VM  is shown to communicate directly with core VM . For example, there may be an instance of an application running on each of the two core VM's that communicate with each other to exchange state so that if one crashes, the other one takes over. As in , shell VM  interfaces with external application , while core VM  handles some of the tasks required by calls from the external application.","Non-transparent VM segmentation, where the program running within the segmented VM knowingly controls external communications paths that bypass the shell VM can be done via specific Application Programming Interfaces (APIs) or protocols exposed by the segmented VM, that are intentionally called by the running program. This behavior may be useful for bypass communications directly to another outside program or service (e.g. database connections, messaging services), or for tight coordination between two segmented VM based programs, running on separate segmented VMs (e.g. AppServer state clustering, message bus traffic, etc.).","A segmented VM may expose APIs or other control mechanisms to the running programs that allow it to open communications paths originating or terminating in the core VM, that communicate directly with the \u201coutside world\u201d (bypassing the shell VM). APIs may be used to coordinate between two (or more) programs running on separate segmented VMs, and establish a direct communication channel between their core VMs that bypasses their shell VMs. APIs may be used by a program running on a segmented VM to communicate directly with an outside service from the core VM, bypassing the shell VM.","Core VM's , , and , and  may reside on the same device or a plurality of devices. A device can include a full computer system, a processor, an application specific integrated circuit (ASIC), or any other appropriate device. The resources from these core devices, such as processing power, memory, and I\/O, can be aggregated and shared among a plurality of shell VM's. As used herein, a collection of core device resources is referred to as a core space. A core space can include one or more core device resources. As used herein, resources associated with one core device are referred to as a core subspace. One core device can include one or more core subspaces. As such, a core space can include one or more core subspaces on one or more core devices. The core space can include portions specifically allocated to core VM's and portions that are generally allocated. The portions that are generally allocated can be allocated based on a policy, such as a load sharing scheme. The portions that are specifically allocated are allocated to specific core VM's. In some embodiments, multiple core spaces are combined into a \u201ccore space domain\u201d, as more fully described below.",{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 10","b":["1000","1000","1000","1001","1002","1003","1004","1","2","3","4","4","1004","1020","1003","3","4","3","1020","4"]},"The remaining space includes portions , , and . This space is referred to as unreserved core space because it is available to be allocated among the core VM's as appropriate. For example, there may be a load balancing or load sharing scheme that is used to allocate the unreserved core space among various core VM's. Accordingly, the lines within core space  may dynamically grow and shrink with time.",{"@attributes":{"id":"p-0071","num":"0070"},"figref":["FIG. 11A","FIG. 4"],"b":["1102","1104","1108","1110","1112","1116"]},{"@attributes":{"id":"p-0072","num":"0071"},"figref":["FIG. 11B","FIG. 11A"],"b":["1110","1120","1122","1124"]},{"@attributes":{"id":"p-0073","num":"0072"},"figref":"FIG. 12","b":["1238","1204","1233","1235","1238","1233","1217","1221","1233","1217","1221","1217","1221","1216","1217","1204"]},"Similarly, core space  is shown to include core subspaces -. Core space  may include any number of core subspaces. Each of core subspace  to core subspace  resides on a core device. A core device may include more than one of core subspace  to core subspace . Core resource  within core subspace  is shown to be allocated by core allocator .","In some embodiments, core resources  and  are similar to the portions shown in . A new shell VM  is launched when an application is launched. A core VM request is formulated by shell VM . The request is sent to core allocator . Based on a policy, core allocator  assigns core resource  to shell VM  and the assignment information is sent to the shell VM and\/or to the core subspace . In some embodiments, core allocation information may also be sent to core resource . In some embodiments, core allocator  assigns core resource  according to the process shown in . Similarly, shell VM  can be assigned core resource .","Once the core space resource is initially allocated, a core allocation enforcer is used in some embodiments to enforce the allocation of resources within each core subspace. In some embodiments, the core allocation enforcer may be part of the resource manager.  is a block diagram illustrating a core allocation enforcer  within a core space . In this example, core space  represents a collection of core resources on a core device, i.e., core space  is a core subspace. Core allocation enforcer  is shown to reside within core space  but may reside on a separate device or in any other appropriate location. Core allocation enforcer  ensures that resources are returned to the unreserved core space or borrowed resources are returned as appropriate. For example, core allocation enforcer  can return borrowed processing power when an application from which that processing power has been borrowed requests it. When an application releases memory, core allocation enforcer  can provide the released memory to another process. Core allocation enforcer  may also request memory from an application to handle a memory request. Core allocation enforcer  may analyze the core space to optimally rebalance the distribution of resources on a periodic or event driven basis. In some embodiments, memory is managed according to the methods described in U.S. patent application Ser. No. 10\/701,388, entitled MEMORY MANAGEMENT which is incorporated by reference above.",{"@attributes":{"id":"p-0077","num":"0076"},"figref":["FIG. 14","FIG. 14"],"b":["1","2","3","1","2","3","1","2","3"]},"The core allocator may make placement (i.e., assignment of a core VM to a core space) decisions and allocation of resources between (and within) core VM devices and core spaces. For example, the core allocator may maintain a configurable policy that ensures that stated resource requirements are met and reservations made to guarantee those requirements; stated application redundancy requirements are met (e.g., as in the redundancy example provided above); stated resource limits are imposed, restricting application resources even when idle resources exist; and stated pooling\/placement of resources is met, assigning applications to one of a specified subset of devices.","The core VM compute resources can be \u201cvirtualized\u201d by using such a policy-based allocation of core VM resources and target core VM devices. For example, specification of a target core device by a launching application (when it starts a shell VM) is not necessary to receive an assignment. Core devices may be added to a core space by describing them to the allocator, and without reconfiguring any application or application parameters. A core device failure may be recovered without application reconfiguration. For example, the core allocator may use a policy to select another core device. The addition of applications, changes to policies, addition\/removal of core VM devices, may be performed without reconfiguration of applications or application parameters. For example, a policy engine may re-shuffle placement decisions and reservations between available devices to make a new policy, make new applications fit, and adapt placement to changes in available core VM device capacities.","An improved virtual machine (VM) system and its associated methods have been disclosed. A shell VM and a core VM are used to segment the overall functionality of a conventional VM. The segmented design improves scalability and efficiency, simplifies administration, and transparently integrates with existing systems.","Although the foregoing invention has been described in some detail for purposes of clarity of understanding, it will be apparent that certain changes and modifications may be practiced within the scope of the appended claims. It should be noted that there are many alternative ways of implementing both the process and apparatus of the present invention. Accordingly, the present embodiments are to be considered as illustrative and not restrictive, and the invention is not to be limited to the details given herein, but may be modified within the scope and equivalents of the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention will be readily understood by the following detailed description in conjunction with the accompanying drawings, wherein like reference numerals designate like structural elements, and in which:",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":["FIG. 2C","FIG. 2B"]},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 4","FIG. 3"],"b":"302"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 8A"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 8B"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIGS. 9A-9C"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 11A"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 11B"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 13","b":["1310","1300"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 14"}]},"DETDESC":[{},{}]}
