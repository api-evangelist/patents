---
title: Data driven remote device control model with general programming interface-to-network messaging adapter
abstract: A general programmatic interface-to-network messaging adapter exposes a suitable object integration interface or application programming interface to applications on a controller device and sends network data messages to invoke services or query status of a controlled device. The adapter maps application calls to the interface into network data messages according to service protocols of the controlled device. The general adapter provides the interface suitable to any specific service of a controlled device based on a data description of the interface, and converts the application calls to network data messages based on a data description of a protocol and format for network data messages to interact with the specific service. Once the interface/messaging description is obtained, applications on the controller device can programmatically interact with the adapter, and the adapter then handles appropriate message exchanges with the service of the controlled device. The general adapter allows controller device applications to be written using object-oriented programming, while avoiding code download.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07085814&OS=07085814&RS=07085814
owner: Microsoft Corporation
number: 07085814
owner_city: Redmond
owner_country: US
publication_date: 20001102
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATION DATA","TECHNICAL FIELD","BACKGROUND AND SUMMARY","DETAILED DESCRIPTION","APPENDIX","Universal Plug and Play Device Architecture","GLOSSARY"],"p":["This application is a continuation-in-part of U.S. patent application Ser. No. 09\/432,854, filed Nov. 2, 1999, which is based on provisional application No. 60\/139,137 filed Jun. 11, 1999, and provisional application No. 60\/160,235 filed Oct. 18, 1999.","This invention relates generally to dynamic configuration of interconnectivity among distributed devices and services, and more particularly relates to providing a capability to access device- or service-specific operational information and perform remote automation and control of embedded computing devices using a data-driven remote programming model, such as in a pervasive computing environment","The cost of computing and networking technologies have fallen to the point where computing and networking capabilities can be built into the design of many electronic devices in the home, the office and public places. The combination of inexpensive and reliable shared networking media with a new class of small computing devices has created an opportunity for new functionality based mainly on the connectivity among these devices. This connectivity can be used to remotely control devices, to move digital data in the form of audio, video and still images between devices, to share information among devices and with the unconstrained World Wide Web of the Internet (hereafter \u201cWeb\u201d) and to exchange structured and secure digital data to support things like electronic commerce. The connectivity also enables many new applications for computing devices, such as proximity-based usage scenarios where devices interact based at least in part on geographical or other notions of proximity. A prevalent feature of these connectivity scenarios is to provide remote access and control of connected devices and services from another device with user interface capabilities (e.g., a universal remote controller, handheld computer or digital assistant, cell phones, and the like). These developments are occurring at the same time as more people are becoming connected to the Internet and as connectivity solutions are falling in price and increasing in speed. These trends are leading towards a world of ubiquitous and pervasive networked computing, where all types of devices are able to effortlessly and seamlessly interconnect and interact.","In accordance with a new device connectivity architecture known as Universal Plug and Play, devices and services are controlled by exchanging well-defined XML-format data messages. At the programmatic level, on the other hand, it is useful and productive to work in an object-oriented framework.","Prior connectivity models are not adequate to bridge between object interfaces and the data messages exchanged with the controlled device over a network. Some prior connectivity models require a controlling device to download the program code (such as a device driver, Jini code, etc.) for interacting with the controlled device or service from a networked source. Such a code download requirement is unsuitable to the Web and other ubiquitous computing scenarios. Other connectivity models require use of a custom-written object for specific classes of services. This approach leads to deployment hassles (e.g., user setup and configuration) and also is unsuitable to ubiquitous computing.","In accordance with a technology described herein, a general programmatic interface-to-network messaging adapter (called a \u201crehydrator\u201d) is a module that exposes a suitable object integration interface or application programming interface to applications on a controller device and sends network data messages to invoke services or query status of a controlled device. The adapter maps application calls to the interface into network data messages according to service protocols of the controlled device. The described adapter preferably is generic to all devices and services compatible with the connectivity model, and adapts itself to specific of the devices based on a Service Description. In other words, this adapter operates as a universal module through which network data message-driven services on other networked computing devices can remote programmatic application programming interfaces, including object integration interfaces according to an object model such as Microsoft's COM, CORBA, JAVA, and the like.","More specifically, this general adapter provides the interface suitable to any specific service of a controlled device based on a data description of the interface, and converts the application calls to network data messages based on a data description of network data messages to interact with the specific service. Once the Service Description is obtained, applications on the controller device can programmatically interact with the adapter, and the adapter then handles appropriate message exchanges with the service of the controlled device. With the described adapter, no code download is required, only the interface\/messaging description is needed. The description can be obtained from the controlled device, a network server computer, or by pre-loading or caching on the controller device. The technology allows controller device applications to be written using object-oriented programming, while avoiding code download.","Additional features and advantages will be made apparent from the following detailed description of the illustrated embodiment which proceeds with reference to the accompanying drawings.","The following detailed description is directed toward a general programmatic interface-to-network messaging adapter (also known as a \u201crehydrator\u201d) in a device control model. In one described implementation, the rehydrator is used in a device architecture  () of a pervasive peer-to-peer networking connectivity protocol proposed by Microsoft Corporation, called Universal Plug and Play (\u201cUPnP\u201d), which is discussed in more detail in the Appendix section below entitled, \u201cUniversal Plug and Play Device Architecture.\u201d Although described in the context of a device control model, and specifically UPnP, the general programmatic interface-to-network messaging adapter of the invention also is more generally applicable in other distributed networking environments to provide an object-oriented or like application programming interface to applications for interacting remotely using network data messages.","UPnP provides a device-driven auto-configuration capability that preserves the experience that customers have on the web. Today, it is possible to navigate around the web without loading programs beyond the browser itself. Since UPnP enables the browser to be extended to control devices, and because UPnP devices are controlled with explicit protocols, the browser must somehow learn how to talk to UPnP devices. This learning process is driven entirely from the device itself and is accomplishing entirely by uploading an XML document that describes the capabilities of the device. The architectural component that enables device-driven auto-configuration is called the Rehydrator. The job of the Rehydrator is to convert between APIs and protocols.","Since the auto-configuration process itself is driven only by the exchange of formatted data, there is very little opportunity for a malicious attack from a hostile piece of code.","There are some scenarios where the web UI model is not sufficient for a rich customer experience. It would not be convenient to have to a web UI for each light switch in a house. To support a rich user interface and to enable the aggregation of devices into a single UI, UPnP enables programmatic control in addition to browser control of devices. This is achieved simply by enabling applications to call the same Rehydrator APIs that the browser does. Applications can also directly generate and consume the raw UPnP control protocols, provided they are not interested in the device-driven auto-configuration enabled by the Rehydrator.","UPnP assumes that there will be more than one device with UI that wants to control other devices in any given network, and it provides a simple mechanism that enables these Control Points to remain in sync. This mechanism can easily support device front panels and wireless remotes that do not run UPnP protocols. The UPnP control model is third-party control; any device can transfer bulk data (e.g. files) or A\/V data streams from any device on the network, to any device on the network, under the control of any device on the network.","Control Points, Controlled Devices and Bridges","With reference now to , UPnP is an application-level distributed network architecture where the logical nodes on the network are Control Points \u2013, Controlled Devices \u2013 and Bridges . These classifications refer to functionality rather than physical entities. The functionality of UPnP Control Points \u2013, Controlled Devices \u2013 and Bridges  can be packaged into physical entities (e.g., multiple function devices \u2013) in any combination.","A Control Point is a set of modules that enable communication with a UPnP Controlled Device. A module is a component of a device, software program, or system that implements some \u201cfunctionality\u201d, which can be embodied as software, hardware, firmware, electronic circuitry, or etc. Control Points initiate discovery and communication with Controlled Devices, and receive Events from Controlled Devices. Control Points are typically implemented on devices that have a user interface. This user interface is used to interact with Controlled Devices over the network. The modules minimally include a Discovery Client, a Description Client and a Rehydrator. Control Points may also include Visual Navigation, an Event Subscription Client, Event Sink, a web browser and an application execution environment. Control Points can add value to the network by aggregating the control of multiple Controlled Devices (the universal remote) or they can implement a function as simple as initiating the transfer of data to or from a Controlled Device. Examples of devices that could be Control Points are the personal computer (PC), digital television (DTV), set-top box (STB), handheld computer and smart mobile phone, and the like. Nothing prevents a single device from implementing the functionality of a Control Point and one or more Controlled Devices at the same time.","A Controlled Device is a set of modules that enable communication with a Control Point. Controlled Devices respond to discovery requests, accept incoming communications from Control Points and may send Events to Control Points. Devices that support Controlled Device functionality may also support local user interfaces such as front panel displays or wireless remotes. The modules minimally include a Discovery Server, a Description Server and a Control Server. Controlled Devices may also include a Presentation (web) Server, Event Subscription Server and Event Source. Examples of devices that could be Controlled Devices are the VCR, DVD player or recorder, heating\/ventilation\/air-conditioning equipment (HVAC), lighting controller, audio\/video\/imaging playback device, handheld computer, smart mobile phone and the PC, and the like. Nothing prevents a single device from implementing the functionality of a Control Point and one or more Controlled Devices at the same time.","A Bridge is a set of modules that enables Bridged and Legacy Devices to interact with native UPnP devices. The bridge itself exposes a collection of UPnP Controlled Devices to Control Points. The Bridge maps between native UPnP Device Control Protocols and the underlying protocols exposed by the Bridged and Legacy Devices. Optionally, such a device could expose UPnP Controlled Devices to Legacy Devices in the manner required by the Legacy Devices. Nothing prevents a single device from implementing the functionality of a Control Point, one or more Controlled Devices and a Bridge at the same time. Bridges  () expose devices that do not expose native UPnP protocols as native UPnP Controlled Devices. The Bridge itself looks to other UPnP Control Points like a set of Controlled Devices.","The Bridged Device is a device that cannot participate in UPnP at the native protocol level, either because the device does not have sufficient resources or because the underlying media is unsuitable to run TCP and HTTP. Examples of devices that could be Bridged Devices are power line-controlled A\/V equipment, light switches, thermostats, wristwatches and inexpensive toys. Bridged Devices are UPnP complaint and are exposed to other UPnP devices through a UPnP Bridge. The Legacy Device is any non-UPnP compliant device that must be exposed to other UPnP devices through a UPnP Bridge.","The primary distinction between a Control Point \u2013 and a Controlled Device \u2013 is that the Control Point is always the communication initiator of control operations (for discovery, the Controlled Device may be the initiator). After the initial communication, Control Points can receive events from Controlled Devices.","Controlled Devices \u2013 are responsible for storing the state of Services. Control Points are required to synchronize to the state on Controlled Devices.","Control Points typically have user interface that is used to access one or more Controlled Devices on the network. Controlled Devices only have local user interfaces.","The following table lists the modules in the Control Points \u2013 and Controlled Devices \u2013, along with their functions.",{"@attributes":{"id":"p-0050","num":"0049"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Control Point","Controlled Device"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Function","Module","Function","Module"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Initiate discovery of","Discovery Client","Respond to","Discovery"]},{"entry":["Controlled Devices.",{},"discovery","Server"]},{"entry":[{},{},"requests."]},{"entry":["Retrieve Device","Description Client","Provide Device","Description"]},{"entry":["Descriptions.",{},"Descriptions.","Server"]},{"entry":["Display a folder of","Visual Navigation"]},{"entry":"icons per discovered"},{"entry":"Device and allow"},{"entry":"transfer of control to"},{"entry":"a selected device."},{"entry":["View user interface","Web Browser","Provide user","Presentation"]},{"entry":["exposed by a",{},"inteface for","(Web)"]},{"entry":["Controlled Device.",{},"remote Control","Server"]},{"entry":[{},{},"Points."]},{"entry":["Execute","Application"]},{"entry":["applications.","Execution"]},{"entry":[{},"Environment"]},{"entry":["Invoke Actions on a","Rehydrator","Accept incom-","Control Ser-"]},{"entry":["Controlled Device",{},"ing Actions in","ver plus na-"]},{"entry":["by sending Service",{},"SCPs and","tive control"]},{"entry":["Control Protocols in",{},"execute them.","logic"]},{"entry":"response to local"},{"entry":"API calls."},{"entry":["Inform a Controlled","Event Subscription","Accept requests","Event Sub-"]},{"entry":["Device of a desire to","Client","for Events and","scription"]},{"entry":["receive Events.",{},"remember","Server"]},{"entry":[{},{},"them."]},{"entry":["Receive an Event.","Event Sink","Send an Event.","Event Source"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"Device Model","The UPnP Device Model  shown in  is the model of a UPnP Controlled Device or Bridge that is emulating native Controlled Devices. The Device Model includes the addressing scheme, eventing scheme, Device Description schema, Devices and Services schema and hierarchy, and the functional description of modules. The UPnP Device Model extends beyond simple API or a command and control protocol descriptions to enable multiple Control Points to have a consistent view of Controlled Devices. This requires that the state of running services be formally modeled and that all state changes be visible to Control Points. Central to the distributed UPnP architecture is the rule that Controlled Devices are the ultimate authority for the state of Services running on them.","Service","The fundamental controllable entity in UPnP is a Service \u2013. An example of a Service is \u201cClock\u201d. Services are defined with a mandatory common base set of functionality. Vendors can extend the base set with proprietary extensions provided the base functionality is implemented. Service Descriptions are versioned and later versions are constrained to be supersets of previous versions. UPnP enables searches for all Devices that contain a specified Service of a minimum version. This search would find all clocks, regardless of their packaging. A search for Device Type \u201cClock\u201d would be used to find only stand-alone clocks.","Every running instance of a Service includes:\n\n","The formal definition of a Service includes:\n\n","Device","According to the device model  shown in , a UPnP Device \u2013 (e.g., multiple function devices \u2013 of  and bridged devices \u2013 of ) is a logical container of one or more Services \u2013. Generally a Device represents a physical entity such as a VCR. Typical Services in the VCR Device example might be \u201cTRANSPORT\u201d, \u201cTUNER\u201d, \u201cTIMER\u201d and \u201cCLOCK\u201d. While Devices are often physical entities, a PC emulating the traditional functions of a VCR could also be modeled in the same way as the stand-alone VCR. Devices can contain other Devices. An example would be a TV\/VCR  () packaged into a single physical unit. A Device (e.g., devices \u2013) may also be a logical container of other Devices. The top-most Device in a hierarchy of nested Devices \u2013 is called the Root Device . A Device with no nested Devices is always a Root Device.","The UPnP Device Model was designed to be general and flexible. It should be possible to model an entire Nuclear Power Plant as a single Service or as a deeply nested hierarchy of Devices and Services. In general, a Service \u2013 is cohesive set of functions that enables flexible packaging into a variety of Devices. Services can be versioned independently of Devices.","All Devices, including Root Devices belong to one or more Device Types. Device Types are intended to enable instances of Devices to be simply and automatically grouped for presentation. An example of a Device Type is \u201cVCR\u201d  (). Device Types are formally defined in terms of a minimal set of versioned Services that a Device of Device Type must support. Device Types are not formally versioned. Device Type is a relatively high level grouping. A Device of Device Type only ensures that minimal set of Services of a minimal version is present. There can be other Services, higher versioned Services and Services with vendor extensions present on such a Device.","UPnP enables SSDP level searches for a unique instance of a Device (by UDN), all Devices of type Device Type and all Devices that contain at least one Service Type of minimum version. The result of an SSDP search is always a URL that points to the Device Description contained in the Root Device. In the event that matching Device is not the Root Device, the Device Description has a tree of nested Devices that can be traversed to find the matching Device.","Every Device includes:\n\n","The Root Device  includes a Discovery Server , which is a module that runs in a Controlled Device or Bridge that responds to SSDP queries. This Server is unique in that it must support UDP\/HTTP rather than just TCP\/HTTP.","Every Root Device  also includes the Device Description  and Description Server  for all Devices under and including itself. The Device Description is a structured unit of data that is used by a Control Point or UPnP Bridge to learn the capabilities of a Controlled Device. Device Descriptions are retrieved from the Description Server on a UPnP Controlled Device. There is one Device Description for every Root Device that describes the Root Device and all non-Root Devices. Device Descriptions adhere to XML grammar. To support localization, multiple Device Descriptions can exist. A Control Point requests the preferred localized Device Description by using the standard HTTP \u201caccept-language\u201d header. The Description Server is a module that runs in a Controlled Device or Bridge that responds to HTTP GETs and returns Device Descriptions. This service consists of a TCP\/HTTP server than can retrieve and return a Device Description from persistent storage (like a filesystem).","The formal definition of a Device (Device Definition ) includes:\n\n","There can be many Device Definitions that belong to a single Device Type.","Device Types","The formal definition of a Device Type includes:\n\n","Service State Table","A Service State Table (SST) logically consists of rows of:","Variable, Type, Legal Values, Default Value, Current Value","Although entries of the Service State Table in UPnP consist of these five items, the state table alternatively can contain fewer or additional items. Generally, each entry will minimally consist of a Variable name or identifier, and its current value.","Various Types of variables available in UPnP are listed in the Appendix.","The reason for representing Services this way is to ensure that the state of a Service is easily available in a common way to multiple Control Points.","An SST can be used to represent to current operational mode of device, act as an information source or sink and\/or simply be a repository for Actions. The SST of a VCR Service could represent the current transport mode, tuner channel selection, input and output switch selections, audio and video decoding format and current timer program. Alternatively, the VCR  could be represented as a Transport Service , Tuner Service, I\/O Switch Service, A\/V Decoding Configuration Service and Programmable Timer Service .","The SST of a clock  would likely represent the current time. Additionally an alarm clock could include Service Variables to configure the clock.","The SST of an image rendering device could implement a video frame-buffer that can accept raw pixel information or formatted JPG files. The SST of an audio or video playback device could implement a transfer buffer or queue of material to be played. The SST of PDA could implement a collection of formatted data that has changed and needed to be synchronized with another device, in addition to a transfer buffer for accepting incoming formatted data.","Control Point Synchronization","In accordance with an device state and eventing model illustrated in , UPnP rules require that every change to an evented variable in an SST generate a corresponding event to announce the change to the all interested Control Points.","An event is an unsolicited message generated by a Controlled Device and delivered to one or more Control Points. Events are used to maintain a consistent view of the state of Service across all interested Control Points. UPnP leverages the GENA event architecture (see \u201cGeneric Event Notification\u201d) to transport event messages. All events are delivered using TCP\/IP for reliability.","Device Addressing","With reference now to , UPnP is built on top of HTTP and leverages the native address format of the web, Uniform Resource Locators (URLs). URLs are a format for expressing web addresses. URLs minimally contain an identification of the protocol family that the URL is valid for, a Hostname, and a path. UPnP uses URLs as addresses whenever the module accepting the incoming connection is an HTTP server. URLs minimally contain an identification of the application protocol family (\u201chttp\u201d) that the URL is valid for, a Hostname and a path. In the context of UPnP, the path part of a URL can represent either a filesystem path or simply an identifier of the local system module and context that can process incoming messages.","A Hostname is the Domain Name System (DNS) or NetBIOS Name Service (NBNS) that, when resolved to an IP address, represents a network interface that can be used to establish TCP\/IP level connectivity to Control Points, Controlled Devices or Bridges. Hostnames can be used to provide persistent network level addressing on a network where IP addresses are dynamically assigned and of unknown lifespan or to integrate with an existing managed network. UPnP provides an algorithm for seeding a device's hostname from its UDN at manufacturing time.","While UPnP modules are described as HTTP servers, there is no requirement that implementations be based on actual web servers. The HTTP Server is a module that accepts incoming TCP\/HTTP connections and either returns a web page or forwards the payload data to another module. Client and Server describe only the direction of initiation of TCP\/HTTP connections. There is no relationship between the low level concepts of Client and Server and the high level concepts of Control Point and Controlled Devices. Logically, Control Points always discover and initiate communication with Controlled Devices, but this communication requires Client and Server functionality on both sides. In most cases, the job of the HTTP server is simply to accept the incoming connection, look at the local destination part of the address (the path) and forward the payload to another module. UPnP enables, but does not require, that all HTTP Servers be based on a common software implementation or runtime instance. Controlled Devices and Bridges can include a TCP port specification as part of a URL to override the default value of 80.","The successful result of a UPnP SSDP level search is always one or more Description URLs. These URLs can be used to navigate to the Device Description of a Controlled Device or Bridge. This URL always points to a Description Server on the Controlled Device. An HTTP GET can be issued on this URL to retrieve the Device Description. This URL is valid as an address for the lifetime of the Hostname embedded in the URL. A Control Point uploads the Device Description and extracts the URLs of the Servers running on the Controlled Device or Bridge.","All URLs returned in the Device Description have a lifetime equal to the lifetime of the Hostname embedded in them. Control Points can store these URLs as addresses without going through a search sequence first. Once they have been advertised in a Device Description, Controlled Device and Bridges cannot arbitrarily change Server URLs.","Whenever a Hostname changes, all URLs associated with all Devices addressed by that Hostname are invalidated. The UDN is the only UPnP identifier guaranteed never to change. Any persistent associations maintained by applications should at least store the UDN to able to unambiguously identify the target Device.","The lifetime of a Description URL is determined by Controlled Device or Bridge that advertises it. If a Controlled Device or Bridge allows an SSDP advertisement of a Description URL to expire, the URL is invalidated.","Control Points use the Event Subscription URL returned by the Controlled Device or Bridge to connect to the Event Subscription Server. This server does the housekeeping of remembering all Control Points that are interested in receiving Events on a Service. The Event Subscription Server needs an address to send the events back to. This address is called the Event Sink URL, and is supplied to the Controlled Device or Bridge in the GENA SUBSCRIBE message. The lifetime of an event subscription, and the Event Sink URL, is determined by the timeout on the SUBSCRIBE message.","Further details of UPnP addressing are listed in the following table.",{"@attributes":{"id":"p-0090","num":"0114"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"UPnP Addresses"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["URL","Function"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Description","Points to the Description Server and Document path on a"]},{"entry":["URL","Root Device. This URL is returned by the Description"]},{"entry":[{},"Server as part of the discovery process."]},{"entry":["Presentation","Points to a Presentation (web) Server on a Controlled"]},{"entry":["URL","Device. Every device, root or nested, may have a"]},{"entry":[{},"Presentation URL. This URL can be entered into the"]},{"entry":[{},"address bar of a web browser to navigate to the root web"]},{"entry":[{},"page of a Device. This URL is returned in the Device"]},{"entry":[{},"Description."]},{"entry":["Control URL","Points to the Control Server implementing a Service on a"]},{"entry":[{},"Controlled Device. There is one Control URL per instance"]},{"entry":[{},"of a Service. This URL is returned in the Device"]},{"entry":[{},"Description."]},{"entry":["Event Sub-","Points to an Event Subscription Server on a Controlled"]},{"entry":["scription","Device. This URL is returned in the Device Description."]},{"entry":"URL"},{"entry":["Event Sink","Points to an Event Sink (an HTTP Server) on a Control"]},{"entry":["URL","Point. This URL is specified by the Control Point in the"]},{"entry":[{},"GENA SUBSCRIBE message."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Device Discovery and Identification","UPnP enables SSDP searches for a unique Root or non-Root Device by UDN, devices of a specified Device Type and devices containing a Service of a specified Service Type. UPnP also supports a search for all Root devices.",{"@attributes":{"id":"p-0093","num":"0117"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"UPnP SSDP Level Searches and Results"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Search for","Returns"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["A unique Root","A single Description URL pointing to the Description"]},{"entry":["Device (by UDN)","Server and Document path on the Root Device."]},{"entry":["A unique non-","A single Description URL pointing to the Description"]},{"entry":["Root Device (by","Server and Document path on the Root Device that"]},{"entry":["UDN)","contains the non-Root Device."]},{"entry":["Type of Device","A set of Description URLs pointing to the Description"]},{"entry":[{},"Servers\/Document paths of all Root Devices that"]},{"entry":[{},"match the Device Type, or contain a non-Root Device"]},{"entry":[{},"that matches the Device Type."]},{"entry":["Type of Service","A set of Description URLs pointing to the Description"]},{"entry":[{},"Servers\/Document paths of all Root Devices that"]},{"entry":[{},"contain a matching Service, or contain a non-Root"]},{"entry":[{},"Device that contains a matching Service."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"SSDP specifies Service Type (ST), Notification type (NT), and Unique Service Name (USN) header fields for queries and for announcements. UPnP uses the ST or NT header to carry one of the UPnP defined identifiers. A unique USN is required for each unique SSDP announcement.","Multiple instances of the same Service Type within a Controlled Device \u2013 or Bridge  are not independently announced.","UPnP search identifiers are used during the discovery process. The result of a successful discovery is one or more Description URLs. The format for search identifiers is:",{"@attributes":{"id":"p-0097","num":"0121"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"upnp:searchtype: [ allformat | UDNformat | srvformat"]},{"entry":[{},"| devformat ]"]},{"entry":[{},"search type = [ UDN | SrvType | DevType | all ]"]},{"entry":[{},"allformat = all"]},{"entry":[{},"UDNformat = UDN:namespace:uniqueid"]},{"entry":[{},"namespace = [ GUID | IEEEMAC | 1394]"]},{"entry":[{},"srvformat = SrvType:servicetype:version"]},{"entry":[{},"devformat = DevType:devicetype"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"SSDP specifies that SSDP announcements must be made for all SSDP searchable values. The SSDP announcements with \u201call\u201d as the notification header value must carry the Root Device UDN as the USN header value. SSDP announcements for Device Types must carry the UDN of the Root Device concatenated with the Device Type URI as the USN header value. SSDP announcements for a Service Type will carry the UDN of the Root Device concatenated with the Service Type URI value as the USN header value. SSDP announcements of UDNs will repeat the UDN value as the USN header.",{"@attributes":{"id":"p-0099","num":"0123"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"UPnP SSDP Announcements"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"UPnP Notification",{}]},{"entry":["Announcement","Type","SSDP USN"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":[{},"\u201call\u201d","Root Device UDN"]},{"entry":["Unique Root Device","Root Device UDN","Root Device UDN"]},{"entry":["Unique non-Root","Non-Root Device","Non-Root Device UDN"]},{"entry":["Device","UDN"]},{"entry":["Device Type","Device Type","Root Device UDN + Device"]},{"entry":[{},"Identifier","Type Identifier"]},{"entry":["Service Type","Service Type","Root Device UDN + Service"]},{"entry":[{},"Identifier","Type Identifier"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"UPnP Bridges  () announce Bridged Devices \u2013 and associated Services using SSDP. The identifiers associated with the Bridged Devices are unique for the device, and they do not duplicate identifiers for Controlled Devices and Services directly available on the Bridge itself. This means that a Bridge that is also a Controlled Device must announce Bridged Devices and local Controlled Devices independently, with appropriate unique identifiers, Device Descriptions and associated URLs.","Description","The UPnP Device Description  () provides the information necessary to identify, describe, connect and control a UPnP Controlled Device \u2013 or Bridge  from a Control Point \u2013.","The Device Description is an XML document. UPnP defines the use of HTTP and XML for the Device Description and wire protocols. UPnP adheres to the schema declaration rules of XML-Data and Y. Goland, \u201cFlexible XML Processing Profile.\u201d","The top level XML elements are separated into three categories: per Device, per Service and shared.","Rehydrator","With reference now to , all (UPnP) Controlled Devices \u2013 () or Bridges  () expose one or more Services \u2013 () that can be controlled remotely. Controlling such Services involves a message exchange between a Control Point  and the device . This message exchange happens according to a specific Service Control Protocol (SCP) , which specifies the content and sequence of the messages exchanged.","Control Points  are not required to have any prior knowledge of the SCPs  required to control the Services on the various devices. Therefore, a Controlled Device or Bridge must be able to describe to a Control Point the protocols required to control its Services, such that the Control Point will be able to implement these protocols dynamically. This requires a standard way of declaring Service Control Protocols in a concise and unambiguous fashion. UPnP introduces a technique for declaring Service Control Protocols using a series of XML documents.","As part of the Service Description , a Service State Table  and Action set  are defined. These things can be combined in a deterministic way defined by UPnP to produce a Service Control Protocol Definition (Service Description) , which includes a Service Control Declaration  and a Service Control Protocol . The Service Description  is a representation of the schema of a Service. It is possible to reconstruct the SST, Action set and SCP from the Service Description.","A Rehydrator  is a module in the Control Point that exposes a suitable API to applications and either invokes Actions on a Service or queries the state of that Service, or receives and responds to events. The primary job of the Rehydrator is to map between API calls and the Service Control Protocol sequence that invokes the Action.","The Service Description is directly embedded into the Device Description  of a Controlled Device. When the Device Description is uploaded into the Control Point , the Rehydrator  can extract the Service Description from it. At this point, the Rehydrator has enough information to issue Service specific SCPs .","General Operation of the Rehydrator","More generally with reference to , the Rehydrator  operates as a universal adapter to provide a programmatic interface to any service-specific protocol of a remote computing device. The Rehydrator  simply obtains a data description or declaration of the methods, properties and events of the remote service, as well as a definition of the protocol of network data messages through which the Rehydrator invokes the methods, queries or sets the properties, and receives event notifications. In UPnP, this data description takes the form of the Device Description . The Device Description  also includes a declaration of the methods, properties and events for the Service. This information is sufficient for the Rehydrator to exchange the appropriate network data packets to interact with the Controlled Device Service, including to invoke Actions, query and set properties, and receive and respond to events, without download of any executable code to the Control Point  device and with a zero installation or configuration experience.","With reference to , the Rehydrator  exposes a programmatic interface (IUPnPService interface  defined in the listing shown in ) for programmatic access by the Browser User Interface () or other application on the Control Point to Controlled Device Actions. In the illustrated Rehydrator , the IUPnPService interface is supported on a Service Object  provided by the Rehydrator. The IUPnPService interface is a COM object integration interface conforming to the Microsoft Common Object Model (COM), which exposes a set of method members that can be invoked through local or remote procedure calls from the Browser or other Control Point application. Alternatively, the IUPnPService interface can be implemented as an object integration interface conforming to another object-oriented programming model, such as CORBA, Java classes, and scripting engine name extensions; or as other type programmatic interface. The methods exposed to the Browser and Control Point applications on the IUPnPService interface  permit the Browser or other Control Point application to programmatically invoke the Actions of Controlled Device Services. The Rehydrator converts the programmatic invocation from the Browser or other Control Point application to the appropriate XML network messages to invoke the Actions of the Controlled Device Service.","In an alternative implementation, the Rehydrator produces service-specific programmatic interfaces corresponding to Controlled Device Services for use by applications at the Control Point. Such programmatic interface is an application programming interface that can be in the form of an object integration interface of an object-oriented programming model, such as Microsoft COM, CORBA, Java classes, and scripting engine name extensions. In the example of a Controlled Device having a clock Service with \u201cget time\u201d and \u201cset time\u201d Actions, the Rehydrator  exposes a COM object integration interface (\u201cIClock\u201d interface), with methods getTime( ) and setTime( ), for the Controlled Device having a \u201cClock\u201d Service with GetTime and SetTime Actions. The Rehydrator  converts calls of an application program  to the IClock interface  into the network data messages specified in the Device Description to invoke the corresponding Actions of the Clock Service. The Rehydrator  likewise creates suitable further programmatic interfaces for other Services (e.g., Services \u2013 of ) based on the Device Description of their respective Controlled Devices.","Accordingly, the Rehydrator operates as a universal proxy object with data-driven conversion of programmatic interfaces to network data messages. Further, the Rehydrator exposes a programmatic interface at the Control Point through which Controlled Device Actions can be invoked, based solely on an XML data description. This operation allows the Rehydrator to produce just-in-time transient interfaces to remote device Services without the complexity of code downloads and installation or configuration. Upon a later release of the interface by the application, the Rehydrator destroys the interface without need to de-install or clean up persistent configuration data in a registry or configuration file of the operating system or object execution run-time.","Rehydrator Implementation","Summary. With reference to , a preferred implementation  of the Rehydrator  is as an internal Microsoft Windows component that routes service control requests from the UPnP API to devices. Applications wishing to control a service on a UPnP device obtain a Service object through the UPnP API and use the methods of this object to query the state variables of the service and invoke its actions. Those methods use the private Rehydrator API to turn the service control requests into network messages that travel to the UPnP device. In this sense, the Rehydrator performs a mapping between API calls and network protocols.","Basic Functionality. The preferred implementation of the Rehydrator is able to translate a service control call to the UPnP API into the appropriate network messages defined by the Service Control Protocol.","Asynchronous Event Notification. The preferred implementation of the Rehydrator is able to notify UPnP API clients of any asynchronous events generated by the devices they are controlling. Event notification is done by means of the event interfaces defined below.","Error Reporting. For a variety of reasons, state variable queries and action invocations may fail. The preferred implementation of the Rehydrator is able to provide a way to communicate the success or failure status of such operations to the parties initiating them.","Rehydrator Implementation Design. As illustrated in , the preferred implementation of the Rehydrator is used in two ways. First, the Device Finder  uses it to create Service objects . Then, these Service objects use it to carry out service control operations (querying state variables and invoking actions).","Creating Service Objects. When the Device Finder  creates a Device object, it invokes the Rehydrator  to create Service objects  for each of the service instances on that device. Each service instance supports a particular Service Control Protocol and the Rehydrator needs a description of this protocol in order to create a properly hydrated Service object.","The Service Control Protocol is declared in the Service Description. This document is passed to the Rehydrator as an IXMLDOMDocument interface pointer in the Rehydrator CreateServiceObject( ) API call.",{"@attributes":{"id":"p-0124","num":"0148"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"HRESULT"},{"entry":"HrRehydratorCreateServiceObject ("}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["IN","LPCWSTR","pcwszSTI,"]},{"entry":["IN","LPCWSTR","pcwszControlURL,"]},{"entry":["IN","LPCWSTR","pcwszEventSubURL,"]},{"entry":["IN","LPCWSTR","pcwszId,"]},{"entry":["IN","IXMLDOMDocument","* pSCPD,"]},{"entry":["OUT","IUPnPService","** pNewServiceObject)"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"This API returns a pointer to an IUPnPService interface on a newly created Service object. In addition to the creating the Service object, the Rehydrator sets up its internal data structures so that it can properly handle requests to control the service. Specifically, it creates a list of the properties and actions exported by the service and stores these as private data within the service object. The control and event subscription URLs as well as the service identifier and service type identifier are also stored in the service object.","Querying Service Properties. Applications can query the values of service properties by invoking the IUPnPService::QueryStateVariable( ) method on a Service object. Internally, this method makes a call to the HrRehydratorQueryStateVariable( ) function.",{"@attributes":{"id":"p-0127","num":"0151"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"HRESULT"},{"entry":"HrRehydratorQueryStateVariable("}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["IN","OUT SERVICE_STATE_TABLE_ROW * psstr,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["IN","LPCWSTR","pcwszSTI,"]},{"entry":["IN","LPCWSTR","pcwszControlURL,"]},{"entry":["OUT","LONG","* plTransportStatus)"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"The first parameter is a SERVICE_STATE_TABLE_ROW structure that encapsulates the state variable being queried. The second parameter is the service type identifier and the third is the control URL of the service. The fourth parameter returns the HTTP status of the operation.","This function will generate an HTTP request to the control server on the device. The body of this request will be an XML fragment containing a SOAP-encoded request for the variable's value. The following is an example of such a request:",{"@attributes":{"id":"p-0130","num":"0154"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"POST path of control URL HTTP\/1.1"},{"entry":"HOST: host of control URL:port of control URL"},{"entry":"CONTENT-LENGTH: bytes in body"},{"entry":"CONTENT-TYPE: text\/xml; charset=\u201cutf-8\u201d"},{"entry":"SOAPACTION: \u201curn:schemas-upnp-org:control-1-0#QueryStateVariable\u201d"},{"entry":"<s:Envelope"},{"entry":"xmlns:s=\u201chttp:\/\/schemas.xmlsoap.org\/soap\/envelope\/\u201d"},{"entry":"s:encodingStyle=\u201chttp:\/\/schemas.xmlsoap.org\/soap\/encoding\/\u201d>"},{"entry":"<s:Body>"},{"entry":"<u:QueryStateVariable xmlns:u=\u201curn:schemas-upnp-org:control-1-0\u201d>"},{"entry":"<u:varName>variableName<\/u:varName>"},{"entry":"<\/u:QueryStateVariable>"},{"entry":"<\/s:Body>"},{"entry":"<\/s:Envelope>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The control server will respond to this message with another XML fragment: the SOAP-encoded method response. The following is an example of such a response:",{"@attributes":{"id":"p-0132","num":"0156"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"HTTP\/1.1 200 OK"},{"entry":"CONTENT-LENGTH: bytes in body"},{"entry":"CONTENT-TYPE: text\/xml; charset=\u201cutf-8\u201d"},{"entry":"DATE: when response was generated"},{"entry":"EXT:"},{"entry":"SERVER: OS\/version UPnP\/1.0 product\/version"},{"entry":"<s:Envelope"},{"entry":"xmlns:s=\u201chttp:\/\/schemas.xmlsoap.org\/soap\/envelope\/\u201d"},{"entry":"s:encodingStyle=\u201chttp:\/\/schemas.xmlsoap.org\/soap\/encoding\/\u201d>"},{"entry":"<s:Body>"},{"entry":"<u:QueryStateVariableResponse xmlns:u=\u201curn:schemas-upnp-org:control-"},{"entry":"1-0\u201d>"},{"entry":"<return>variable value<\/return>"},{"entry":"<\/u:QueryStateVariableResponse>"},{"entry":"<\/s:Body>"},{"entry":"<\/s:Envelope>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The rehydrator will extract the return value from this XML fragment, place it in the SERVICE_STATE_TABLE_ROW structure whose address was passed as the first parameter to the HrRehydratorQueryStateVariable( ) function and then return.","Invoking Service Actions. The process of invoking a service action is very similar to querying a state variable. An application calls IUPnPService::InvokeAction( ) on a Service object, passing it the name of an action to invoke, and an array of arguments to the action. Internally, IUPnPService::InvokeAction( ) calls RehydratorInvokeServiceAction( ), declared as shown below.",{"@attributes":{"id":"p-0135","num":"0159"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"HRESULT"},{"entry":"HrRehydratorInvokeServiceAction("}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["IN","SERVICE_ACTION","* pAction,"]},{"entry":["IN","SAFEARRAY","* psaInArgs,"]},{"entry":["IN","LPCWSTR","pcwszSTI,"]},{"entry":["IN","LPCWSTR","pcwszControlURL,"]},{"entry":["IN","OUT SAFEARRAY","** ppsaOutArgs,"]},{"entry":["OUT","VARIANT","* pvReturnVal,"]},{"entry":["OUT","LONG","* plTransportStatus)"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"The first parameter is a structure describing the action to be invoked, the second is an array of input arguments, the third is the service type identifier, and the fourth is the control URL of the service. The out parameters and return value are returned in the fifth and sixth parameters, respectively. The HTTP status of the operation is returned in the seventh parameter.","RehydratorInvokeServiceAction( ) will send an HTTP request to the control server identified by the second parameter. As before, the body of this message will be an XML fragment containing a SOAP-encoded method call. An example HTTP request to invoke an action is shown below.",{"@attributes":{"id":"p-0138","num":"0162"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"POST path of control URL HTTP\/1.1"},{"entry":"HOST: host of control URL:port of control URL"},{"entry":"CONTENT-LENGTH: bytes in body"},{"entry":"CONTENT-TYPE: text\/xml; charset=\u201cutf-8\u201d"},{"entry":"SOAPACTION: \u201curn:schemas-upnp-org:service:serviceType:v#action-"},{"entry":"Name\u201d"},{"entry":"<s:Envelope"},{"entry":"xmlns:s=\u201chttp:\/\/schemas.xmlsoap.org\/soap\/envelope\/\u201d"},{"entry":"s:encodingStyle=\u201chttp:\/\/schemas.xmlsoap.org\/soap\/encoding\/\u201d>"},{"entry":"<s:Body>"},{"entry":"<u:actionName xmlns:u=\u201curn:schemas-upnp-org:service:serviceType:v\u201d>"},{"entry":"<argumentName>in arg value<\/argumentName>"},{"entry":"other in args and their values go here, if any"},{"entry":"<\/u:actionName>"},{"entry":"<\/s:Body>"},{"entry":"<\/s:Envelope>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The encoding of the body of this message is again specified in the Service Control Protocol. The Rehydrator will wait for the HTTP response to this request, which would look something like the example below.",{"@attributes":{"id":"p-0140","num":"0164"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"HTTP\/1.1 200 OK"]},{"entry":[{},"CONTENT-LENGTH: bytes in body"]},{"entry":[{},"CONTENT-TYPE: text\/xml; charset=\u201cutf-8\u201d"]},{"entry":[{},"DATE: when response was generated"]},{"entry":[{},"EXT:"]},{"entry":[{},"SERVER: OS\/version UPnP\/1.0 product\/version"]},{"entry":[{},"<s:Envelope"]},{"entry":[{},"xmlns:s=\u201chttp:\/\/schemas.xmlsoap.org\/soap\/envelope\/\u201d"]},{"entry":[{},"s:encodingStyle=\u201chttp:\/\/schemas.xmlsoap.org\/soap\/encoding\/\u201d>"]},{"entry":[{},"<s:Body>"]},{"entry":[{},"<u:actionNameResponse xmlns:u=\u201curn:schemas-upnp-"]},{"entry":[{},"org:service:serviceType:v\u201d>"]},{"entry":[{},"<argumentName>out arg value<\/argumentName>"]},{"entry":[{},"other out args and their values go here, if any"]},{"entry":[{},"<\/u:actionNameResponse>"]},{"entry":[{},"<\/s:Body>"]},{"entry":[{},"<s:Envelope>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"After receiving a response such as this, the Rehydrator will extract the return value, place it in the out parameter it was passed, and then return.",{"@attributes":{"id":"p-0142","num":"0166"},"figref":"FIGS. 31 through 43"},"Control Point","With reference now to , the Control Points  include Visual Navigation, Browser, Discovery Client, Event Subscription Client, Event Sink and Rehydrator modules.","The Visual Navigation module provides the Control Point functionality that displays the icons of discovered Devices and enables the transfer of control to a browser or application to interact with the Controlled Device. In Windows, Visual Navigation could be implemented as a folder of icons.","The Discovery Client is a module that runs in a Control Point that initiates SSDP queries.","The Browser is the Presentation Client. A web browser extended with a Rehydrator.","The Rehydrator is the Control Client. A Control Point module that translates between native operating system APIs and SCPs and events. The Rehydrator uploads Service Descriptions from Controlled Devices and Bridges and generates appropriate SCPs in response to application API requests to invoke Actions.","The Event Subscription Client is a module that runs in a Control Point that sends GENA SUBSCRIBE messages to the Event Subscription Server.","The Event Sink module runs in a Control Point and accepts incoming GENA event NOTIFYs. This service consists of a TCP\/HTTP server that passes the event information to interested applications running on the Control Point. The Event Sink is identified by an Event Sink URL. This URL, supplied by a Control Point, is used as an address to send event NOTIFYs to. This URL is valid as an address for the lifetime of the Hostname embedded in the URL. There is no explicit relationship between Event Sink URLs and Subscription Identifiers.","Device Description","With reference to , Control Points  can retrieve a Device Description  by issuing an HTTP GET on a Description URL. This URL is returned in the location header of either an SSDP announcement or an SSDP query response.","The HTTP GET must include an accept-language header that is used to request the preferred language of the response. If the requested language is not supported, a Device Description in the default language supported by the Controlled Device or Bridge may be returned.","An HTTP GET is used to retrieve sub elements of a Device Description that are expressed as URLs.","URL Handling","URLs embedded in Device Descriptions  take one of 3 forms: a fully qualified URL or a relative URL.","Fully qualified URLs take the form:","http:\/\/devicename\/pathname","The devicename part of the URL is a Hostname or IP address and the pathname is a filesystem path or equivalent. A fully qualified URL is used \u201cas is\u201d to establish an HTTP connection to a device.","A relative URL does not contain the \u201c:\u201d character and is of the form:","pathname","\/pathname","Relative URLS are a compact representation of the location of a resource relative to an absolute base URL. All relative URLs in a Device Description are appended to the value of the Device Description element <URLbase> to form fully qualified URLs.","Binary Data","Some elements of a Device Description are binary. XML does not directly support the embedding of binary data. In order to include binary data directly in a Device Description, one must convert the data to text using the Base 64 encoding scheme. This tends to increase the size of the data by 25% on the average. Much of this overhead can be eliminated if the binary data is passed by reference instead of by value. To reference binary data, a URL to the data is provided in a Device Description. The binary data can be retrieved by doing a HTTP GET with that URL.","As an example, consider the <image> element in the following Device Description:",{"@attributes":{"id":"p-0167","num":"0191"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<iconList>"]},{"entry":[{},"\u2003<icon>"]},{"entry":[{},"\u2003\u2003<size>16<\/size>"]},{"entry":[{},"\u2003\u2003<imageType>PNG<\/imageType>"]},{"entry":[{},"\u2003\u2003<color>1<\/color>"]},{"entry":[{},"\u2003\u2003<depth>8<\/depth>"]},{"entry":[{},"\u2003\u2003<image>"]},{"entry":[{},"\u201chttp:\/\/device.local\/iconpath\/icon.png\u201d\/>"]},{"entry":[{},"\u2003<\/icon>"]},{"entry":[{},"<\/iconList>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The icon would be retrieved with an HTTP GET of the following format:","GET iconpath\/icon.png HTTP 1.1","Host: device.local","The HTTP response would look like:","HTTP\/1.1 200 OK","Content-Type: image\/png","Content-length: ###","<binary color icon data in the PNG format>","Device Description Layout","The basic layout of the Device Description  is shown in . The elements of the Device Description are specified in the Appendix.",{"@attributes":{"id":"p-0178","num":"0202"},"figref":"FIG. 15","b":"226"},"Service Control Protocol and Service Description","As part of the Service Description  shown in , a Service State Table  and Action set  are defined. The Service Description  is a representation of the schema of a Service. It is possible to reconstruct the SST , Action set  and SCP  from the Service Description.","The declaration of such a protocol must specify the list of Variables that can be queried, the set of Actions that can be invoked, as well as the wire protocol (the content and sequence of network messages) required to carry out these operations. Service Description is specified in an XML documents. The Service Device Description , written in a language called Service Description Language, declares the list of state Variables and Actions associated with the Service Type to be controlled by the protocol.","Declaring the Service State Table and Action Set","A Service Description, written in UPnP Template Language  is used to specify the list of state Variables that a SCP can query and the set of Actions that it can invoke. UPnP Template Language is an XML schema, a set of rules for writing XML documents.",{"@attributes":{"id":"p-0184","num":"0208"},"figref":"FIG. 16"},"The <actionList> element contains an <action> element for every action associated with the Service. The elements within an <action> element specify the name of the action and any arguments the action may take. In this case, the service supports two actions that do not take arguments, ChannelUp and ChannelDown, and another, SetChannel, that takes a new channel number as an argument. The <argument> element and the elements nested within it define the argument. The <relatedStateVariable> element within <argument> specifies the name of one of the state variables to which the argument is related. In the UPnP Device Model, all arguments to actions must correspond directly to some state variable.",{"@attributes":{"id":"p-0186","num":"0210"},"figref":"FIGS. 17 and 18"},"Basic UPnP Eventing Architecture","With reference to , the UPnP architecture  () requires that clients of the UPnP API be enabled to receive notifications reliably from UPnP services \u2013 as their states change. Since state changes are relatively common, the eventing subsystem is efficiency and performance is a major consideration in this design.  and the following discussion describe the Basic UPnP Eventing Architecture , which encompasses both the controlled device  and Control Point  sides of the eventing service. It also includes the support APIs for both a low-level service interaction and a higher level COM-based wrapper of those APIs. The latter enables automation controllers like Visual Basic  to receive event notifications.","What is an Event?","Property change events are defined as any change in the value of a row of the Service State Table (SST)  () for a service \u2013. This change will be reflected as a property change notification. For example, if a \u201cVCR\u201d device has a \u201cVCR Transport\u201d service, one row in that service's SST may be TapeState and the value could be TapePresent. If the tape is ejected, the new value would be TapeAbsent. This state change would be reflected as a notification sent to all subscribers.","What is a Notification?","A UPnP event notification is an XML message sent over HTTP\/TCP to each and every subscriber to a particular UPnP service. The content of the XML is defined below. The important contents of this message are the unique identifier for the subscription, the property name and new value.","Notification Processing","In UPnP, the listener to Notifications is the SSDP service itself. SSDP already listens on another multicast address for \u201calive\u201d and \u201cbyebye\u201d messages sent by UPnP devices. The same listener will listen on a TCP port for notifications sent. All subscriptions sent from that Control Point contain the same callback URL and so all notifications will be directed to that URL. When a notification arrives the SSDP service will examine the NT header of the message and determine if it is an event notification. If so, the message is parsed further to determine if it should be forwarded on to subscribers (which must exist). GENA defines the format of the HTTP message, what headers can be used, and what they can be used for.","GENA","GENA is the protocol of communication that, in a preferred embodiment, UPnP devices use to send event notifications. Therefore, UPnP devices that wish to notify Control Points of state changes are recommended to use GENA. Notification subscribers will never be required to interact with a UPnP device directly and so they are not required to use GENA. The eventing API will encapsulate this complexity. Other appropriate event transport protocols may be used, such as publish\/subscribe systems.","Receiving Notifications","Applications written in C (C Application ) will be able to utilize the SSDP C API  to receive callbacks when notifications are processed by the SSDP service. This is analogous to SSDP clients registering for notifications that services have become available. When a Control Point registers for a notification, it passes as a parameter the URL of the service for which it is interested in receiving notifications. This URL is obtained from the Device Description for that service. (When a service is registered on a UPnP device, it uses this same URL to listen for subscription requests).","When a notification message is received by the SSDP service listener, the SID header is checked against the list of subscribers it maintains. If a subscriber is found, the callback function for that subscriber is invoked, with one of the parameters being the contents of the notification message. The notification client that implements the callback function can process this message in any appropriate way.","Notifications in the UPnP API","The UPnP API  is a consumer of the basic C interface provided by the SSDP C API  component. In order to integrate seamlessly, the registration of notifications is handled by the Service Object  inside the UPnP Object Model. Service objects will register for notifications when they are created. This ensures that the SST is maintained by the UPnP API and is kept up to date. They will implement the callback function required by the registration function. If this callback function is invoked, it will pass on that notification to Control Points. The Control Points can be written in C, C++, VB, or script code, so the mechanism for passing on notifications can be different.","Script Support","A feature of the illustrated eventing system is that it supports script languages such as VBScript . For VBScript, this is made possible by providing a property on the Service object that, when set, contains the IDispatch pointer for a VBScript function or subroutine that will be the event handler. When the Service object's notification callback is invoked, it checks to see if this IDispatch pointer was set, and if so, it calls IDispatch::Invoke on DISPID 0 of that interface to call the VBScript subroutine.","Eventing Subsystem Terminology","Control Point. Any piece of software that searches for devices and controls them.","Controlled Device. A hardware or software device that announces its availability thru SSDP and allows control by Control Points.","Subscriber\u2014A Control Point who wishes to be notified of event changes.","Notifying Resource (or simply \u201cResource\u201d)\u2014For the purposes of this document, this will always be a service contained within a UPnP Controlled Device .","Event Source\u2014a service that provides events. UPnP services are event sources. All notifying resources are event sources and vice versa.","Event\u2014message generated when a change in a resource's state occurs.","Property\u2014a single entry in the service's state table whose DefaultValue can change. Properties and events always have a one to one correspondence.","Subscribing To Resources","Integrating with the UPnP API","The UPnP API  exposes several interfaces with which a consumer can find and enumerate devices, control services, and get properties on devices and services. To allow the integration of events into this model, we add a new property to the IUPnPService interface called EventHandler. When this property is set, it tells the Service object  that its client is interested in receiving notifications for that service. The SSDP API RegisterNotification( ) API is called when the Service object is created so that it can maintain a local copy of the SST for that service. The Service object knows the URL of the service and therefore it can provide this as a parameter to RegisterNotification( ). RegisterNotification( ) is also provided a callback function which is a static member of the Service object class. This function will be invoked for each and every notification sent by that particular UPnP service.","The Notification Callback","The Service object  includes a static member function called EventNotifyCallback( ) which is invoked for each notification sent by the UPnP service. The callback is passed the entire HTTP message contents in a structure which is a parameter to the function. The prototype looks like this:",{"@attributes":{"id":"p-0215","num":"0239"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"static VOID"]},{"entry":[{},"CUPnPService::EventNotifyCallback(SSDP_CALLBACK_TYPE"]},{"entry":[{},"ssdpType,"]},{"entry":[{},"SSDP_MESSAGE *pssdpMsg,"]},{"entry":[{},"\u2003LPVOID pcontext);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The ssdpType parameter should always be SSDP_EVENT. The pssdpMsg parameter contains the relevant information about the event. The key piece of information is the body of the XML message. The body contains information about what property changed, what its new value is and what type it is, among other information. The pContext parameter will always be the this pointer of the Service object. This allows the code to call a method to fire the event to the Control Point. The callback will parse the XML body using the XML DOM services. Property changes are iterated and the local SST is updated to reflect these changes. After this processing is done, an event notification may be fired for each property that was changed to the owner of the subscription if one exists. Depending on what environment the owner is written in (C++ or script, etc . . . ), a different mechanism for firing the event may be employed.","A special case for this process is the very first notification received after a subscription is established. This notification contains the entire set of properties and their values and is used to locally sync up the SST. Events will not be fired to clients of the UPnP API in this case.","Firing Notifications","When the EventNotifyCallback( ) function is called, the local copy of the SST for the service is updated. After this, an event needs to be fired if a subscriber exists. A subscriber exists if the put EventHandler( ) method was called, either from VBScript, C++ code, or another source. To abstract away this complexity, a new interface called IUPnPServiceCallback is needed.","This interface has a method called StateVariableChanged( ) which takes several parameters. When the IUPnPService::AddCallback( ) function is called, its argument is an IUnknown. This pointer is QueryInterface'd( ) for IDispatch first, and if it succeeds, then IDispatch::Invoke( ) is called with DISPID 0 to invoke the default method. This allows VBScript  to be called. If that fails, however, it is Queried for IUPnPServiceCallback, and if that succeeds, the StateVariableChanged( ) method is called with the same parameters as for Invoke( ). The handles C++ Control Points effectively.","Subscribing with C++","To subscribe to a UPnP service from C++, a Control Point instantiates a UPnP service object, and calls the IUPnPService::AddCallback( ) function. This function takes one parameter, an IUnkown interface pointer to an object that implements IUPnPServiceCallback.","Subscribing With VBScript","To subscribe to a UPnP service's events, all that needs to be done by a script  is to create a function or subroutine as a handler function and set the pointer of that function to the EventHandler property of the Service object. Now, anytime an event is fired, this VBScript function or subroutine will be called. In VBScript, this is written as the following:",{"@attributes":{"id":"p-0225","num":"0249"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Dim devicefinder"]},{"entry":[{},"Set devicefinder ="]},{"entry":[{},"CreateObject(\u201cUPnP.UPnPDeviceFinder.1\u201d)"]},{"entry":[{},"Dim device"]},{"entry":[{},"Set device = devicefinder.FindByUDN(\u201cuuid:929f28c3-"]},{"entry":[{},"3ada-4c97-8238-f62e08124889\u201d)"]},{"entry":[{},"Dim args(0)"]},{"entry":[{},"Dim File(1)"]},{"entry":[{},"Dim Vol(1)"]},{"entry":[{},"set svc = device.services(\u201cupnp:id:pwrdim\u201d)"]},{"entry":[{},"svc.AddCallback GetRef(\u201ceventHandler\u201d)"]},{"entry":[{},"Sub eventHandler(callbackType, svcObj, varName,"]},{"entry":[{},"value)"]},{"entry":[{},"\u2003If (callbackType = \u201cVARIABLE_UPDATE\u201d) Then"]},{"entry":[{},"\u2003\u2003select case svcObj.Id"]},{"entry":[{},"\u2003\u2003\u2003case \u201cupnp:id:pwrdim\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003select case varName"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003Case \u201cPower\u201d\u2003\u2003\u2003Power.innerText = value"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003Case \u201cLevel\u201d\u2003\u2003\u2003Level.innerText = value"]},{"entry":[{},"\u2003\u2003\u2003\u2003end select"]},{"entry":[{},"\u2003\u2003\u2003end select"]},{"entry":[{},"\u2003\u2003End If"]},{"entry":[{},"End Sub"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In this example, the script finds the device given its UDN. When it finds the device, it queries that device for the \u201cupnp:id\u201dpwrdim\u201d service. Once it finds that service, it adds an event callback to that service called \u201ceventHandler\u201d. This name is arbitrary.","Sending and Receiving Notifications","GENA Server API","GENA servers  are generally going to be UPnP Control Points. A GENA server is anything that receives and processes NOTIFY messages to handle notifications from resources and sends SUBSCRIBE and UNSUBSCRIBE messages to receive notifications from resources. These APIs leverage the already existing SSDP APIs. The following are the changes to the APIs:","RegisterNotification( )","The RegisterNotification( ) allows a UPnP Control Point to request notification when an event occurs for a given UPnP service. The prototype is as follows:",{"@attributes":{"id":"p-0230","num":"0254"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"HANDLE WINAPI RegisterNotification"]},{"entry":[{},"(NOTIFY_TYPE nt, CHAR * szType,"]},{"entry":[{},"CHAR *szEventUrl,"]},{"entry":[{},"SERVICE_CALLBACK_FUNC fnCallback,"]},{"entry":[{},"VOID *pContext)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Parameters: Nt[in] An enumeration that determines the type of notification requested. The values are: SSDP_ALIVE\u2014a service has become available, and SSDP_PROPCHANGE\u2014a property has changed on the service. SzResourceType[in] A null-terminated string specifying the resource type desired. For SSDP_ALIVE, this is the service type, for SSDP_PROPCHANGE this is unused. SzEventUrl[in] A null-terminated string specifying the URL that a subscription request should be sent to. FnCallback[in] A pointer to a function that will be called each time a notification is received. The function pointer is defined in the SSDP spec. PContext[in] This parameter is included as a parameter when invoking the client-supplied callback function.","Return Value: If the function succeeds, the return value is a handle used in a subsequent call to the DeregisterNotification( ) function. If the function fails, the return value is INVALID_HANDLE_VALUE error code. To get extended error information, call GetLastError.",{"@attributes":{"id":"p-0233","num":"0257"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]},{"entry":[{},"ServiceCallbackFunc"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef enum_SSDP_CALLBACK_TYPE {"]},{"entry":[{},"\u2003SSDP_FOUND = 0,"]},{"entry":[{},"\u2003SSDP_ALIVE = 1,"]},{"entry":[{},"\u2003SSDP_BYEBYE = 2,"]},{"entry":[{},"\u2003SSDP_DONE = 3,"]},{"entry":[{},"\u2003SSDP_EVENT = 4,"]},{"entry":[{},"\u2003SSDP_DEAD = 5,"]},{"entry":[{},"} SSDP_CALLBACK_TYPE, *PSSDP_CALLBACK_TYPE;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"UPnP Control Point Architecture","When a UPnP Control Point wishes to subscribe to notifications for a particular UPnP service, it calls the RegisterNotification( ) API. It passes to this API a notification type that identifies the type of notification being requested, a URL to which a subscription should be sent, and a callback function and context for use when the notification is received.","RegisterNotification( ) will compose a SUBSCRIBE message, using the data passed in, and send that to the URL specified by the caller. The Callback header of the SUBSCRIBE message will be composed on the fly, as an arbitrary URL for notifications to be sent to for this subscription. This callback URL will likely be a constant since the server API will always know how to handle requests sent to this URL. It will then send the SUBSCRIBE message and await a response.","When the response is received, the Subscription-ID header contains a SID which is associated with the callback function specified by the caller.","Immediately after the response is received, the Control Point should expect an initial NOTIFY message that contains the complete set of properties maintained by the Controlled Device. This becomes the local cached SST on the Control Point side. From this point on, all modifications to the table are made via NOTIFY messages. This initial NOTIFY message will have sequence number 0 that indicates it is an initial property set and not an update. The Control Point can use this information in any way it sees fit. This ensures the Control Point's state table is always in sync with the one on the Controlled Device.","When a message is received by the HTTP server on the UPnP Control Point, it is passed to a function which determines the method name and Request-URI. If this is a NOTIFY message, the headers are parsed and packaged up into a structure. The callback function that was specified to RegisterNotification( ) is called with that structure as one of the parameters. Control Points who implement the callback function can find the headers and body of the NOTIFY message and do additional processing based on the notification type.","This all requires that the SSDP HTTP server listen on a TCP socket in addition to the UDP multicast port it already listens to. However, once a NOTIFY message is received, it is processed in the same way regardless of from which connection it originated.","Handling Failures","The following are subscription\/notification failures that can occur and their solutions:","Leaked Subscriptions","To protect against subscriptions that exist on the controlled device, but no longer on the Control Point, we institute the timeout feature of GENA subscriptions. The scenario is this: A Control Point subscribes to a Controlled Device, then the Control Point reboots. Meanwhile, the Controlled Device is still trying to send notifications to that Control Point. If the Control Point never comes back, the subscription would be leaked because the Control Point never told the Controlled Device that it was going away. So to correct this, each subscription request includes an arbitrary timeout value which indicates to the Controlled Device that the Control Point will be re-subscribing every n seconds indicated in the timeout header of the subscription request. If the timeout expires on the Controlled Device, the subscription is removed. The Control Point is required to re-subscribe before the timeout period has elapsed. If it fails to do so, the subscription will be terminated by the Controlled Device.","Some time before the timeout expires on the Control Point, a re-subscribe message should be sent. The re-subscribe message is similar to the subscribe message, but it does not contain an NT or Callback header. If the Control Point is unable to re-subscribe within the timeout period, the subscription will be terminated by the Controlled Device. If the Control Point sends a re-subscribe after the Controlled Device has terminated the subscription, the Controlled Device will return \u201c412 Precondition Failed\u201d.","Network Error Sending Event Notifications","If a controlled device receives an error sending an event notification to a subscriber, it will NOT cease to send notifications. It will continue to send notifications and receive errors until the subscription expires. The problem for the Control Point is that it will have missed a number of event notifications and so its state table will be out of sync. To correct this, each event notification message will contain a 32-bit sequence number that starts at 0 and increments for each message sent to a subscriber. If a subscriber receives a notification with a sequence number that is not exactly one more than the previous notification, it will know that it has lost events and will ignore all future notifications until it receives one with sequence number 0 again. Events with sequence number 0 indicate that the event is an \u201cinitial state\u201d event.","Once it realizes that is has lost one or more events, the Control Point will send an UNSUBSCRIBE message, followed by a SUBSCRIBE message. This is not the same as a re-subscription because re-subscriptions do not cause the Controlled Device to start the sequence over at 0. In this case, the active unsubscribe\/subscribe will cause the Controlled Device to restart the sequence at 0 and send the entire state table with the first notification message.","The SUBSCRIBE Message","When a UPnP Control Point wishes to subscribe to event notifications for a UPnP service \u2013, it will form a SUBSCRIBE message of the following format:","SUBSCRIBE service1 HTTP\/1.1","Host: vcr.local:200","NT: upnp:event","Callback: <http:\/\/danielwe\/upnp:923>","Timeout: Second-600","The response is as follows::","HTTP\/1.1 200 O.K.","SID: uuid:kj9d4fae-7dec-11d0-a765-00a0c91e6bf6","Timeout: Second-600","This example of a GENA SUBSCRIBE request and response demonstrates a subscription to event notifications for \u201cservice1.\u201d The host is \u201cvcr.local.\u201d All notifications for this service will be sent to the callback URL http:\/\/danielwe\/upnp:923. In the response, the \u201cSubscription-ID\u201d header provides the subscriber with an identifier to use when it wants to unsubscribe to this resource. The \u201cTimeout\u201d header indicates that the subscriber will send a re-subscription request before 10 minutes have elapsed. If the device does not receive this request within that period of time, it will remove the subscription.","The Re-SUBSCRIBE Message","When a UPnP Control Point wishes to re-subscribe to event notifications for a UPnP service, it will form a SUBSCRIBE message of the following format:","SUBSCRIBE service1 HTTP\/1.1","Host: vcr.local:200","SID: uuid:kj9d4fae-7dec-11d0-a765-00a0c91e6bf6","Timeout: Second-600","The response would be as follows::","HTTP\/1.1 200 O.K.","SID: uuid:kj9d4fae-7dec-11d0-a765-00a0c91e6bf6","Timeout: Second-600","Note that the NT and Callback headers are absent, but the SID header exists. This tells the Controlled Device  which subscription is being renewed and restarts the timeout. When the Controlled Device receives this message, it will persist the subscriptions to disk (or other persistent data storage medium), updating the absolute timeout based on the current time and a new timeout sent by the Control Point (if it was different).","The NOTIFY Message","When a resource wishes to send an event notification, it will form a NOTIFY message of the following format:","NOTIFY upnp HTTP\/1.1","Host: danielwe:923","NT: upnp:event","NTS: upnp:propchange","SID: uuid:kj9d4fae-7dec-11d0-a765-00a0c91e6bf6","Seq: 123","Content-Length: xxx","Content-Type: text\/xml","<event XML schema>","The response is as follows::","HTTP\/1.1 200 O.K.","This example of a GENA NOTIFY request and response demonstrates that a \u201cupnp:propchange\u201d event is being sent to http:\/\/danielwe\/upnp:923. The USN header identifies \u201cvcr.service1\u201d as the event source. The XML contains the property name, value, and type. The \u201cSeq\u201d header indicates the sequence number of the notification. Sequence number 0 indicates the initial state update for the subscriber.","Property Change Event XML Schema","A UPnP property change event will be of the following form:",{"@attributes":{"id":"p-0288","num":"0312"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<e:propertyset xmlns:e=\u201curn:schemas-upnp-org:event-"]},{"entry":[{},"1-0\u201d>"]},{"entry":[{},"\u2003<e:property>"]},{"entry":[{},"\u2003\u2003<foo>goodbye<\/foo>"]},{"entry":[{},"\u2003<\/e:property>"]},{"entry":[{},"\u2003<e:property>"]},{"entry":[{},"\u2003\u2003<bar>27<\/bar>"]},{"entry":[{},"\u2003<\/e:property>"]},{"entry":[{},"<\/e:propertyset>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Here, a property named \u201cfoo\u201d has a value of \u201cgoodbye\u201d and a property named \u201cbar\u201d has a value of 27. The XML contains a list of multiple properties that have changed.","The UNSUBSCRIBE Message","When a UPnP Control Point wishes to unsubscribe to event notifications for a UPnP service, it will form an UNSUBSCRIBE message of the following format:","UNSUBSCRIBE service1 HTTP\/1.1","Host: vcr.local:200","SID: uuid:kj9d4fae-7dec-11d0-a765-00a0c91e6bf6","The response would be as follows::","HTTP\/1.1 200 O.k.","This example of a GENA UNSUBSCRIBE request and response demonstrates that the Control Point is no longer interested in receiving event notifications from http:\/\/vcr.local\/service1:200.","Control Point State Synchronization Models","Controlled Device-Initiated NeedsSync Method","This method begins with the Controlled Device sending its initial state to the subscriber the first time an event is submitted by the service. Control Points will subscribe to the service first, then receive notifications for events as they occur. The first event will happen to be the initial state of the service. The Control Point state table will always be in sync with this method.","When the Controlled Device sends a notification to a subscriber and receives an error. In this case, it marks the subscriber as \u201cNeedsSync\u201d and the next time an event is submitted, all events are sent to the subscriber. The problem with this is that the API needs to keep track of which subscribers need syncing and which ones don't. The client of this API (the UPnP service) would need to send separate messages to each subscriber and know which ones needed all events and which ones just wanted the ones that changed.","Control Point-Initiated Sync","This method states that the Control Point should subscribe to event notifications, then call a function that obtained the state from the service. This means that any events that were received in the meantime would need to be matched against the incoming set of events and replaced if they were older. This method leads to synchronization issues where the Control Point may receive events that are newer but when it queries for the state, it gets an older view of the table. This requires using sequence numbers to determine which information is newer. If the view of the table received by the query is too old, it has to be discarded. Alternatively, the properties that were not received by event notification would not be overwritten, but all other properties would be. Using sequence numbers make this more complicated.","Controlled Device-Initiated Sync","This preferred method takes a simpler approach. Any time the Control Point subscribes to a service, the service will immediately afterwards, send the entire contents of the state table with the first notification. This precludes the Control Point from making a query for the state table. Subsequent events update the local state table on the Control Point. If the connection is lost, the Control Point will lose its subscription. If the Control Point realizes it has not received an event after a certain amount of time has elapsed, it will re-subscribe. At that point, the Controlled Device will re-send the entire state table again, and the Control Point is ensured to be up to date.","Exemplary Computer Hardware",{"@attributes":{"id":"p-0305","num":"0329"},"figref":"FIG. 21","b":["820","821","822","823","821","821"]},"The system bus may be any of several types of bus structure including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of conventional bus architectures such as PCI, VESA, AGP, Microchannel, ISA and EISA, to name a few. The system memory includes read only memory (ROM)  and random access memory (RAM) . A basic input\/output system (BIOS), containing the basic routines that help to transfer information between elements within the computer , such as during start-up, is stored in ROM .","The computer  further includes a hard disk drive , a magnetic disk drive , e.g., to read from or write to a removable disk , and an optical disk drive , e.g., for reading a CD-ROM disk  or to read from or write to other optical media. The hard disk drive , magnetic disk drive , and optical disk drive  are connected to the system bus  by a hard disk drive interface , a magnetic disk drive interface , and an optical drive interface , respectively. The drives and their associated computer-readable media provide nonvolatile storage of data, data structures, computer-executable instructions, etc. for the computer . Although the description of computer-readable media above refers to a hard disk, a removable magnetic disk and a Controlled Device, it should be appreciated by those skilled in the art that other types of media which are readable by a computer, such as magnetic cassettes, flash memory cards, digital video disks, Bernoulli cartridges, and the like, may also be used in the exemplary operating environment.","A number of program modules may be stored in the drives and RAM , including an operating system , one or more application programs , other program modules , and program data .","A user may enter commands and information into the computer  through a keyboard  and pointing device, such as a mouse . Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a serial port interface  that is coupled to the system bus, but may be connected by other interfaces, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video adapter . In addition to the monitor, computers typically include other peripheral output devices (not shown), such as speakers and printers.","The computer  operates in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a server, a router, a peer device or other common network node, and typically includes many or all of the elements described relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) . Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the local network  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications (e.g., via the LAN  and a gateway or proxy server ) over the wide area network , such as the Internet. The modem , which may be internal or external, is connected to the system bus  via the serial port interface . In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","In accordance with the practices of persons skilled in the art of computer programming, the present invention is described below with reference to acts and symbolic representations of operations that are performed by the computer , unless indicated otherwise. Such acts and operations are sometimes referred to as being computer-executed. It will be appreciated that the acts and symbolically represented operations include the manipulation by the processing unit  of electrical signals representing data bits which causes a resulting transformation or reduction of the electrical signal representation, and the maintenance of data bits at memory locations in the memory system (including the system memory , hard drive , floppy disks , and CD-ROM ) to thereby reconfigure or otherwise alter the computer system's operation, as well as other processing of signals. The memory locations where data bits are maintained are physical locations that have particular electrical, magnetic, or optical properties corresponding to the data bits.","Exemplary Embedded Computing Device",{"@attributes":{"id":"p-0313","num":"0337"},"figref":"FIGS. 22 and 23","b":["900","900","906"]},"With reference to , the device  includes a processing unit , and a memory  to provide embedded computing capability. The processing unit  has hardware interfaces to the operational circuitry  that operates devices functions. The processing unit  can be a microprocessor or micro-controller, such as are available from Intel, Motorola, IBM, and others. The memory  preferably incorporates RAM and ROM to hold software and data for basic operating code as well as for user applications.","The device  also includes a network adapter  for connecting with a network media  that is interconnected with the computer network in which the authoritative names registry (described below) is implemented in accordance with the invention. The network adapter  can be a network interface card (or chip set integrated on a single board with the processing unit ) appropriate to the particular network media . The network media can be any of various wired or wireless network media, including Ethernet, IEEE 1394 (a.k.a. firewire), radio frequency (including satellite, cell, pager, commercial signal sideband, etc.), power line carrier (PLC), phone line, and television cable, among others.","With reference now to , the embedded computing device  () has a software architecture  that conforms to the above described UPnP device control model. UPnP provides a mechanism for the embedded computing device to operate in the Internet, as well as networks that have no administrator and no connection to the Internet, and hence no access to configuration services like the Dynamic Host Configuration Protocol (DHCP). DHCP is a mechanism for providing devices with configuration information needed to access the Internet. The mechanism functions through the use of a multicast request for configuration information that is generally responded to with an IP address and DNS server location. Additional information can only be returned in the response.","In non-configured (ad-hoc) networks, UPnP uses the AutoIP protocol. AutoIP is an enhancement to DHCP that allows devices to claim IP addresses in the absence of a DHCP server or similar IP configuration authority. IP addresses are claimed from a reserved range that is not allowed to be transmitted on the open Internet; thus they are only good for the local network. The embedded computing device  claims an address by randomly generating an address in the reserved range and then making an ARP request to see if anyone else has already claimed that address. AutoIP systems will continually check for the presence of a DHCP server so that if one should ever come online, all the AutoIP devices will attempt to switch their IP addresses to one provided by the DHCP server. This allows a network to operate in isolation, be connected to the Internet with DHCP support and then to be returned to isolation. This type of scenario will be common in homes that use dial-up access.","The UPnP protocol also uses Multicast DNS for addressing the embedded computing device . The Internet Domain Name System (DNS) is a mapping system that translates human readable domain names, like microsoft.com, into their equivalent IP address. Most corporate intranets implement an internal version of the same technology to provide the same services. In small networks, such as at home or in small business, DNS servers may not exist. Multicast DNS allows DNS requests to be multicast. This allows a machine to see requests for its own name and respond to them. Like AutoIP, Multicast DNS is only used when a DNS server is not available. (For more information, see B. Woodcock, Zocolo, and B. Manning, \u201cMulticast Discovery of DNS Services,\u201d IETF Internet Draft, \u201cdraft-manning-multicast-dns-01.txt.\u201d)","UPnP implements a peer discovery mechanism that uses the Simple Service Discovery Protocol (SSDP) for discovery of devices on IP networks. SSDP is based on profiles. A single identifier specifies a profile that defines a control protocol between the client and service (e.g., operational functions provided by the embedded computing device). By identifying itself with the profile, the service advertises compliance with the associated control protocol.","Using a single identifier makes it possible to implement an extremely simple discovery system. Clients send out a User Datagram Protocol (UDP) multicast packet containing the identifier of the desired service on some standard channel. Services listen on the standard channel, read the request, see whether they provide the service, and respond if so.","UPnP also provides a Directories mechanism to allow discovery to scale\u2014to the entire Internet if needed. When present, a directory will read all incoming service requests and respond to them itself. This requires that all services (e.g., the embedded computing device ) register with the directory so that the directory is able to properly answer on their behalf. The directory is also responsible for communicating with other directories in order to determine whether the service is available within the local network, the WAN and potentially the Internet.","To simplify the discovery protocol, directories are treated as proxies. A proxy is a service that accepts requests and takes responsibility for finding the proper response. When a client comes online, it will perform discovery for the proxy. If the proxy is present, then the client will send all future discovery requests to the proxy. If the proxy isn't present, then the client will send all discovery requests to the reserved discovery multicast channel. Regardless of the presence of a proxy, the client's request format and procedures will always be the same. The only difference will be the address to which the client sends its requests. For services, the difference between a proxied and unproxied network is their need to answer discovery requests. On a proxied network, services need do nothing once they have registered with the proxy. On an unproxied network, they answer discovery requests directly.","SSDP uses the UDP- and Transmission Control Protocol (TCP)-based Hyptertext Transport Protocol (HTTP) to provide for service discovery. SSDP uses a Uniform Resource Identifier (URI) to represent the service and the OPTIONS method to provide for discovery. SSDP also will provide support for proxies. These proxies, which are really just fronts for directories, redirect discovery requests to themselves. It is the proxy's job to collect announce requests in order to determine what services are available as well as to communicate with other proxies in order to provide for scalable service discovery.","The discovery process returns only the basic information needed to connect to the embedded computing device. Once a service has discovered its peers, the service often needs to find out more information in order to work best with them. The description process returns a schema providing descriptive data about the service.","A schema is a structured data definition that defines a set of structured values that provide descriptive information about a service. UPNP uses the Extensible Markup Language (XML) for schema, because XML's self-describing structured data format provides the level of expressiveness and extensibility needed by a universal schema and data format.","Accordingly, UPNP supports automatic network introduction, meaning that devices and their related services have the ability to be self-describing and allow automatic configuration. When a device is plugged into the computer network, the device automatically configures itself and acquires a TCP\/IP address. The device then announces its presence to other devices already on the network using a simple discovery protocol based on the Internet HTTP protocol and is immediately ready to share its services with any device that requests them.","With UPNP, device developers are not required to develop specific device drivers to operate under UPNP. The task of preparing a device for operation in this network environment thus is fairly simple. Moreover, in configured networks, dynamic detection allows an operating system to immediately begin using added devices or stop using removed devices without rebooting.","UPNP Devices support automatic discovery, identification, and configuration to achieve interoperability in the home environment, but must also operate correctly in a managed corporate network. Devices can be networked instead of being attached directly to a PC, and devices are all autonomous citizens on the network, able to talk with each other and exchange information. UPNP provides a unified way of performing directory services with automatic configuration. Capability for simple discovery mechanism used in the home environment provides the ability for any device to become a node on the global Internet. Additionally, directory services can be leveraged if they are available in the corporate environment.","UPNP provides a common set of interfaces for accessing devices and services, enabling the operational unification of diverse media types. Communications protocols for Universal Plug and Play are based on industry standards, especially key Internet standards such as TCP\/IP, HTML, XML, HTTP, DNS, LDAP, and others. Individual implementations for particular networks and buses are built on established protocols.","As shown in , the software architecture  of the embedded computing device  () includes the following software code modules that implement UPNP: device functions , simple discovery , Hypertext Transport Protocol (HTTP) , Transmission Control Protocol\/Internet Protocol (TCP\/IP) stack , Autonet , Dynamic Host Configuration Protocol (DHCP) , and physical media  (also shown in ). The device functions  is a software code module to implement the device's functionality. For example, where the embedded computing device is a VCR, the device functions code can include code to implement start, stop, pause, record and other functions that the VCR can perform.","The simple discovery  is a software code module (about 4 Kbytes) that implements a simple discovery procedure (described below) for automatic network introduction under the UPNP protocol.","The simple discovery procedure additionally provides an Extensible Markup Language (XML) format device description, which is downloaded to clients that access the device to allow activation of device functionality from the client. XML is a textual, tag-based markup language. It was originally designed to be the \u201cwebby\u201d simplification of SGML (Standard Generalized Markup Language), and is therefore intended to be used to create \u201cvocabularies\u201d of tags that can be used to apply semantic markup to documents, such as who the author was, what constitutes a paragraph (semantically, not from a display point of view), when the author last had breakfast, and so on. (For more information, see A. Layman, E. Jung, E. Maler, H. Thompson, J. Paoli, J. Tigue, N. H. Mikula, S. De Rose, -, W3C Note 5 Jan. 1998.). In the context of UPNP, XML is used to provide the description of services and capabilities of the embedded computing device. The embedded computing device makes its features visible to clients by providing its XML device description, which the client can use to activate device functions . For example, if the device is a camera, the client's browser can direct the camera to zoom in\/out or adjust contrast using the mechanism of XML.","The XML device description can provide links (via a uniform resource locator or URL address) to an accompanying XSL format style sheet. The XSL style sheets are used to present the data in different ways, i.e., the style sheets are applied to present different views of the same data. For example, if the device contains a file system, one style sheet can show the file selections; another shows the file sizes in some sort of diagram; yet another style sheet could make thumbnails of these image files.","The HTTP  is a software code modules (about 20 Kbytes) that implements the standard HTTP protocol, which is an open standard mechanism for client\/server message-based communication. HTTP provides for proxying, content negotiation and security. (For more information, see R. Fielding, J. Gettys, J. Mogul, H. Frystyk, T. Berners-Lee, 1.1, IETF RFC 2068 (January 1997).) The TCP\/IP stack  implements the standard TCP\/IP networking protocols for communication on the computer network. The Internet Protocol (IP) is the foundation protocol of the Internet. It defines how a single message is sent from a source through zero or more routers to its final destination. It covers issues such as message length, message fragmentation, addressing, and routing concerns. The Transmission Control Protocol (TCP) is an IP-based protocol that provides support for the reliable, ordered delivery of messages over IP. Additionally, User Datagram Protocol (UDP) and Internet Group Management Protocol (IGMP) multicast send\/listen capability are included in the implementation.","The Autonet  is a software code module also used for automatic network introduction via AutoIP in the UPNP protocol. Autonet uses a predefined set of IP addresses and, when a device is connected to the network, it pings an address in this address space. If it gets no replies, the device assumes that the address is available and assigns it to itself. To make this functionality even more useful it is combined with Multicast DNS, in which the device itself holds its own name. Thus it is not even necessary to determine what IP address the device assigned to itself, because its name can always be used instead. An IP Multicast is a mechanism for sending a single message to multiple recipients. IP multicasting is especially useful for discovery operations where one does not know exactly who has the information one seeks. In such cases, one can send a request to a reserved IP multicast address. Any services that can provide the requested information will also subscribe to the multicast request and thus be able to hear the information request and properly respond. Multicast DNS is a proposal to the IETF on rules for making normal DNS requests using multicast UDP. (For more information, see B. Woodcock, B. Manning, \u201cMulticast Discovery of DNS Services\u201d, IETF Internet Draft, \u201cdraft-manning-multicast-dns-01.txt.\u201d)","The DHCP  is a software code module that implements the Dynamic Host Configuration Protocol (DHCP), which is a mechanism for providing devices with configuration information needed to access the Internet. The mechanism functions through the use of a multicast request for configuration information that is generally responded to with an IP address and DNS server location. Additional information can only be returned in the response.",{"@attributes":{"id":"p-0337","num":"0361"},"figref":["FIGS. 24 and 25","FIG. 22"],"b":["934","940","900","934","940"]},"At the announce phase, the embedded computing device  sends out a small multicast packet so that other devices can find it on the network. The multicast message packet essentially says, \u201cI am here, I am, (say), a camera, and you can reach me at this IP address or URL.\u201d","At the discovery phase, the embedded computing device  listens for a discovery packet coming from a simple discovery client, i.e., the device announces itself, then listens for discovery. The discovery packet also is sent out by multicast.","At response to discovery, the embedded computing device  listens to the multicast address and then parses the information from a Simple Discovery request to decide if the request is for its kind of device. If so, the device  then sends back a response packet containing the following information: the IP address or URL where it can be reached; identification of its own device type; and the discovery packet ID so the requesting client knows which request is being answered.","At the Autonet phase, the Autonet module  of the embedded computing device  uses a predefined set of IP addresses and, when the device is connected to the network, it pings an address in this address space. If no reply is received, the device  assumes that the address is available and assigns it to itself. Alternatively, the device  may combine Autonet with Multicast DNS, and itself hold its own name. In which case, it is not necessary to determine what IP address the device assigned to itself, because its name can always be used instead.","Both the Announce and Discovery packets also contain a link or a URL to an XML file that is used by the embedded computing device at the device description phase to describe itself (i.e., its functionality). This XML data contains all the facts about the device. XML can also have URLs that point to appropriate style sheets (XSL files) that are used for optimal presentation. The XSL style sheets are used to present the data in different ways, i.e., the style sheets are applied to present different views of the same data. For example, if the device contains a file system, one style sheet can show the file selections; another shows the file sizes in some sort of diagram; yet another style sheet could make thumbnails of these image files.","Exemplary Client","With reference now to , a client that accesses and uses the embedded computing device  over the computer network has an exemplary client software architecture , which includes software code modules for applications , simple discovery , XML , LDAP , TCP\/IP stack  and a network interface card (NIC)  that provides a physical connection to the computer network. The applications  is a software code module that provides a user interface features for locating desired devices (e.g., embedded computing device ) and services on the computer network, and also user interface features to interact with the located device or service. The applications  can include an Internet browser, such as the Microsoft Internet Explorer, that can present the XML device description in accordance with an associated XSL style sheet for interaction with the embedded computing device and activation of its operational functionality.","The simple discovery  is a module that implements the above-described simple discovery per the UPNP protocol. The XML  is a module that processes the XML device description and XSL style sheets for presentation in the application's user interface. The LDAP  implements the standard LDAP directory protocol for name look-up. The TCP\/IP stack  implements the TCP\/IP protocol for communications over the computer network.","Illustrative Pervasive Computing Environment",{"@attributes":{"id":"p-0345","num":"0369"},"figref":["FIG. 27","FIG. 22","FIG. 21"],"b":["1000","900","1000","1002","1004","1006","1002","1016","1010","1011","1012"]},"Various embedded computing devices also connect to the computer network via various network connections to the PCs , . These include an audio device  (e.g., speakers, radio tuner, microphone), and printer  which connect to the PC  through a USB . Also, a digital camera , a handheld PC(H\/PC)  and another personal computing device  connect via an infrared port (IRDA) , which also attaches to the PC  through the USB . Also, lighting switches  and like home appliances are connected via an A\/C power line-based networking  to the PC . Further, a chain of IEEE  cables  connect a digital TV , DVD player , digital video camcorder (DV\/DVC) , an audio device  (e.g., CD player\/recorder, radio receiver, amplifier, and like audio system component), and a game console . Devices, such as a portable telephone  and remote control , have a radio frequency network connection with the PC .","With their various inter-networked connections, the embedded computing devices are \u201cvisible\u201d and accessible from a client device  () also connected to the computer network.","Table of contents","Introduction","1. Discovery","2. Description","3. Control","4. Eventing","5. Presentation","Glossary","Introduction","What is Universal Plug and Play?","Universal Plug and Play (UPnP) is an architecture for pervasive peer-to-peer network connectivity of intelligent appliances, wireless devices, and PCs of all form factors. It is designed to bring easy-to-use, flexible, standards-based connectivity to ad-hoc or unmanaged networks whether in the home, in a small business, public spaces, or attached to the Internet. Universal Plug and Play is a distributed, open networking architecture that leverages TCP\/IP and the Web technologies to enable seamless proximity networking in addition to control and data transfer among networked devices in the home, office, and public spaces.\n\nUPnP is more than just a simple extension of the plug and play peripheral model. It is designed to support zero-configuration, \u201cinvisible\u201d networking and automatic discovery for a breadth of device categories from a wide range of vendors. This means a device can dynamically join a network, obtain an IP address, convey its capabilities, and learn about the presence and capabilities of other devices. DHCP and DNS servers are optional and are used only if available on the network. Finally, a device can leave a network smoothly and automatically without leaving any unwanted state behind.\n\nUPnP leverages Internet components, including IP, TCP, UDP, HTTP, and XML. Like the Internet, contracts are based on wire protocols that are declarative, expressed in XML, and communicated via HTTP. IP internetworking is a strong choice for UPnP because of its proven ability to span different physical media, to enable real world multiple-vendor interoperation, and to achieve synergy with the Internet and many home and office intranets. UPnP has been explicitly designed to accommodate these environments. Further, via bridging, UPnP accommodates media running non-IP protocols when cost, technology, or legacy prevents the media or devices attached to it from running IP.\n\nWhat is \u201cuniversal\u201d about UPnP? No device drivers; common protocols are used instead. UPnP networking is media independent. UPnP devices can be implemented using any programming language, and on any operating system. UPnP does not specify or constrain the design of an API for applications running on control points; OS vendors may create APIs that suit their customer's needs. UPnP enables vendor control over device UI and interaction using the browser as well as conventional application programmatic control.\n\nUPnP Forum\n\nThe UPnP Forum is an industry initiative designed to enable easy and robust connectivity among stand-alone devices and PCs from many different vendors. The UPnP Forum seeks to develop standards for describing device protocols and XML-based device schemas for the purpose of enabling device-to-device interoperability in a scalable networked environment. The UPnP Forum oversees a logo program for compliant devices.\n\nThe UPnP Forum has set up working committees in specific areas of domain expertise. These working committees are charged with creating proposed device standards, building sample implementations, and building appropriate test suites. This document indicates specific technical decisions that are the purview of UPnP Forum working committees. UPnP vendors can build compliant devices with confidence of interoperability and benefits of shared intellectual property and the logo program. Separate from the logo program, vendors may also build devices that adhere to the UPnP Device Architecture defined herein without a formal standards procedure. If vendors build non-standard devices, they determine technical decisions that would otherwise be determined by a UPnP Forum working committee.\n\nIn this Document\n\nThe Universal Plug and Play (UPnP) Device Architecture contained herein defines the protocols for communication between controllers, or control points, and devices. For discovery, description, control, eventing, and presentation, UPnP uses the following protocol stack.\n\nAt the highest layer, messages logically contain only UPnP vendor-specific information about their devices. Moving down the stack, vendor content is supplemented by information defined by UPnP Forum working committees. Messages from the layers above are hosted in UPnP-specific protocols, defined in this document. In turn, the above messages are formatted using the Simple Service Discovery Protocol (SSDP), General Event Notification Architecture (GENA), and Simple Object Access Protocol (SOAP). The above messages are delivered via HTTP, either a multicast or unicast variety running over UDP, or the standard HTTP running over TCP. Ultimately, all messages above are delivered over IP. The remaining sections of this document describe the content and format for each of these protocol layers in detail. For reference, colors in [square brackets] above indicate which protocol defines specific message components throughout this document.\n\nThe foundation for UPnP networking is IP addressing. Each device has a Dynamic Host Configuration Protocol (DHCP) client and search for a DHCP server when the device is first connected to the network. If a DHCP server is available, i.e., the network is managed, the device uses the IP addressed assigned to it. If no DHCP server is available, i.e., the network is unmanaged, the device uses Auto IP to get an address. In brief, Auto IP defines how a device intelligently chooses an IP address from a set of reserved addresses and is able to move easily between managed and unmanaged networks. If during the DHCP transaction, the device obtains a domain name, e.g., through a DNS server or via DNS forwarding, the device uses that name in subsequent network operations; otherwise, the device uses its IP address.\n\nGiven an IP address, the first step in UPnP networking is discovery. When a device is added to the network, the UPnP discovery protocol allows that device to advertise its services to control points on the network. Similarly, when a control point is added to the network, the UPnP discovery protocol allows that control point to search for devices of interest on the network. The fundamental exchange in both cases is a discovery message containing a few, essential specifics about the device or one of its services, e.g., its type, identifier, and a pointer to more detailed information. The UPnP discovery protocol is based on the Simple Service Discovery Protocol (SSDP). The section on Discovery below explains how devices advertise, how control points search, and details of the format of discovery messages. The second step in UPnP networking is description. After a control point has discovered a device, the control point still knows very little about the device. For the control point to learn more about the device and its capabilities, or to interact with the device, the control point retrieves the device's description from the URL provided by the device in the discovery message. Devices may contain other, logical devices, as well as functional units, or services. The UPnP description for a device is expressed in XML and includes vendor-specific, manufacturer information like the model name and number, serial number, manufacturer name, URLs to vendor-specific Web sites, etc. The description also includes a list of any embedded devices or services, as well as URLs for control, eventing, and presentation. For each service, the description includes a list of the commands, or actions, the service responds to, and parameters, or arguments, for each action; the description for a service also includes a list of variables; these variables model the state of the service at run time, and are described in terms of their data type, range, and event characteristics. The section on Description below explains how devices are described and how those descriptions are retrieved by control points.\n\nThe third step in UPnP networking is control. After a control point has retrieved a description of the device, the control point can send actions to a device's service. To do this, a control point sends a suitable control message to the URL for control URL for the service (provided in the device description). Control messages are also expressed in XML using the Simple Object Access Protocol (SOAP). Like function calls, in response to the control message, the service returns any action-specific values. The effects of the action, if any, are modeled by changes in the variables that describe the run-time state of the service. The section on Control below explains the description of actions, state variables, and the format of control messages.\n\nThe fourth step in UPnP networking is eventing. A UPnP description for a service includes a list of actions the service responds to and a list of variables that model the state of the service at run time. The service publishes updates when these variables change, and a control point may subscribe to receive this information. The service publishes updates by sending event messages. Event messages contain the names of one of more state variables and the current value of those variables. These messages are also expressed in XML and formatted using the General Event Notification Architecture (GENA). A special initial event message is sent when a control point first subscribes; this event message contains the names and values for all evented variables and allows the subscriber to initialize its model of the state of the service. To support scenarios with multiple control points, eventing is designed to keep all control points equally informed about the effects of any action. Therefore, all subscribers are sent all event messages, subscribers receive event messages for all evented variables that have changed, and event messages are sent no matter why the state variable changed (either in response to a requested action or because the state the service is modeling changed). The section on Eventing below explains subscription and the format of event messages.\n\nThe fifth step in UPnP networking is presentation. If a device has a URL for presentation, then the control point can retrieve a page from this URL, load the page into a browser, and depending on the capabilities of the page, allow a user to control the device and\/or view device status. The degree to which each of these can be accomplished depends on the specific capabilities of the presentation page and device. The section on Presentation below explains the protocol for retrieving a presentation page.\n\n0. Addressing\n\nAddressing is Step 0 of UPnP networking. Through addressing, devices get a network address. Addressing enables discovery (Step 1) where control points find interesting device(s), description (Step 2) where where control points learn about device capabilities, control (Step 3) where a control point sends commands to device(s), eventing (Step 4) where control points listen to state changes in device(s), and presentation (Step 5) where control points display a user interface for device(s).\n\nThe foundation for UPnP networking is IP addressing. Each device has a Dynamic Host Configuration Protocol (DHCP) client and search for a DHCP server when the device is first connected to the network. If a DHCP server is available, i.e., the network is managed, the device uses the IP addressed assigned to it. If no DHCP server is available, i.e., the network is unmanaged; the device uses automatic IP addressing (Auto-IP) to obtain an address. Auto-IP defines how a device: (a) determines if DHCP is unavailable, and (b) intelligently chooses an IP address from a set of link-local IP addresses. This method of address assignment enables a device to easily move between managed and unmanaged networks. The operations described in this section are further clarified in the reference documents listed below. Where conflicts between this document and the reference documents exist, the reference document always takes precedence.\n\n0.1 Addressing: Determining Whether to Use Auto-IP\n\nA device that supports AUTO-IP and is configured for dynamic address assignment begins by requesting an IP address via DHCP by sending out a DHCPDISCOVER message. The amount of time this DHCP Client listens for DHCPOFFERS is implementation dependent. If a DHCPOFFER is received during this time, the device continues the process of dynamic address assignment. If no valid DHCPOFFERS are received, the device may then auto-configure an IP address.\n\n0.2 Addressing: Choosing an Address\n\nTo auto-configure an IP address using Auto-IP, the device uses an implementation dependent algorithm for choosing an address in the 169.254\/16 range. The first and last 256 addresses in this range are reserved and is not used.\n\nThe selected address then is tested to determine if the address is already in use. If the address is in use by another device, another address is chosen and tested, up to an implementation dependent number of retries. The address selection is randomized to avoid collision when multiple devices are attempting to allocate addresses.\n\n0.3 Addressing: Testing the Address\n\nTo test the chosen address, the device uses an Address Resolution Protocol (ARP) probe. An ARP probe is an ARP request with the device hardware address used as the sender's hardware address and the sender's IP address set to 0s. The device will then listen for responses to the ARP probe, or other ARP probes for the same IP address. If either of these ARP packets is seen, the device considers the address in use and try a new address.\n\n0.4 Addressing: Periodic Checking for Dynamic Address Availability\n\nA device that has auto-configured an IP address periodically checks for the existence of a DHCP server. This is accomplished by sending DHCPDISCOVER messages. How often this check is made is implementation dependent, but checking every 5 minutes would maintain a balance between network bandwidth required and connectivity maintenance. If a DHCP offer is received, the device proceeds with dynamic address allocation. Once a DHCP assigned address is in place, the device may release the auto-configured address, but may also choose to maintain this address for a period of time to maintain connectivity.\n\nTo switch over from one IP address to a new one, the device cancels any outstanding advertisements and reissue new ones. The section on Discovery explains advertisements and their cancellations.\n\n0.5 Addressing: Device Naming and DNS Interaction.\n\nOnce a device has a valid IP address for the network, it can be located and referenced on that network through that address. There may be situations where the end user needs to locate and identify a device. In these situations, a friendly name for the device is much easier for a human to use than an IP address.\n\nMoreover, names are much more static than IP addresses. Clients referring a device by name don't require any modification when IP address of a device changes. Mapping of the device's DNS name to its IP address could be entered into DNS database manually or dynamically according to RFC 2136. While computers and devices supporting dynamic DNS updates can register their DNS records directly in DNS, it is also possible to configure a DHCP server to register DNS records on behalf of these DHCP clients.\n\n0.6 Addressing: Name to IP Address Resolution\n\nA computer that needs to contact a device identified by a DNS name needs to discover its IP address. The computer submits a DNS query according to RFC1034 and 1035 to the pre-configured DNS server(s) and receives a response from a DNS server containing the IP address of the target device. A computer can be statically pre-configured with the list of DNS servers. Alternatively a computer could be configured with the list of DNS server through DHCP, or after the address assignment through a DHCPINFORM message.\n\n1. Discovery\n\nDiscovery is Step 1 in UPnP networking. Discovery comes after addressing (Step 0) where devices get a network address. Through discovery, control points find interesting device(s). Discovery enables description (Step 2) where control points learn about device capabilities, control (Step 3) where a control point sends commands to device(s), eventing (Step 4) where control points listen to state changes in device(s), and presentation (Step 5) where control points display a user interface for device(s).\n\nDiscovery is the first step in UPnP networking. When a device is added to the network, the UPnP discovery protocol allows that device to advertise its services to control points on the network. Similarly, when a control point is added to the network, the UPnP discovery protocol allows that control point to search for devices of interest on the network. The fundamental exchange in both cases is a discovery message containing a few, essential specifics about the device or one of its services, e.g., its type, identifier, and a pointer to more detailed information.\n\nWhen a new device is added to the network, it multicasts a number of discovery messages advertising its embedded devices and services. Any interested control point can listen to the standard multicast address for notifications that new capabilities are available. Similarly, when a new control point is added to the network, it multicasts a discovery message searching for interesting devices, services, or both. All devices listen to the standard multicast address for these messages and responds if any of their embedded devices or services match the search criteria in the discovery message.\n\nTo reiterate, a control point may learn of a device of interest because that device sent discovery messages advertising itself or because the device responded to a discovery message searching for devices. In either case, if a control point is interested in a device and wants to learn more about it, the control point uses the information in the discovery message to send a description query message. The section on Description explains description messages in detail.\n\nWhen a device is removed from the network, it multicasts a number of discovery messages revoking it's earlier announcements, effectively declaring that it's embedded devices and services will not be available.\n\nTo limit network congestion, the time-to-live (TTL) of each IP packet for each multicast message defaults to 4 and is configurable.\n\nDiscovery plays an important role in the interoperability of devices and control points using different versions of UPnP networking. The UPnP Device Architecture (defined herein) is versioned with both a major and a minor version, usually written as major.minor, where both major and minor are integers. Advances in minor versions is a compatible superset of earlier minor versions of the same major version. Advances in major version are not required to be supersets of earlier versions and are not guaranteed to be backward compatible. Version information is communicated in discovery and description messages. In the former, each discovery message includes the version of UPnP networking that the device supports. As a backup, the latter also includes the same information. This section explains the format of version information in discovery messages and specific requirements on discovery messages to maintain compatibility with advances in minor versions.\n\nThe standard multicast address, as well as the mechanisms for advertising, searching, and revoking, are defined by the Simple Service Discovery Protocol (SSDP). The remainder of this section explains SSDP in detail, enumerating how devices advertise and revoke their advertisements as well as how control points search and devices respond.\n\n1.1 Discovery: Advertisement\n","When a device is added to the network, the UPnP discovery protocol allows that device to advertise its services to control points. It does this by multicasting discovery messages to a standard address and port. Control points listen to this port to detect when new capabilities are available on the network. To advertise the full extent of its capabilities, a device multicasts a number of discovery messages corresponding to each of its embedded devices and services. Each message contains information specific to the embedded device (or service) as well as information about its enclosing device. Messages include duration until the advertisements expire; if the device remains available, the advertisements are re-sent with (with new duration). If the device becomes unavailable, the device explicitly cancels its advertisements, but if the device is unable to do this, the advertisements will expire on their own.","1.1.1 Discovery: Advertisement Protocols and Standards","To send (and receive) advertisements, devices (and control points) use the following subset of the overall UPnP protocol stack. (The overall UPnP protocol stack is listed at the beginning of this document.)","At the highest layer, discovery messages contain vendor-specific information, e.g., URL for the device description and device identifier. Moving down the stack, vendor content is supplemented by information from a UPnP Forum working committee, e.g., device type. Messages from the layers above are hosted in UPnP-specific protocols, defined in this document. In turn, the above messages are delivered via a multicast variant of HTTP that has been extended using General Event Notification Architecture (GENA) methods and headers and Simple Service Discovery Protocol (SSDP) headers. The HTTP messages are delivered via UDP over IP. For reference, colors in [square brackets] above indicate which protocol defines specific headers and values in discovery messages listed below.\n\n1.1.2 Discovery: Advertisement: Device Available\u2014NOTIFY with ssdp:alive\n\nWhen a device is added to the network, it multicasts discovery messages to advertise its root device, to advertise any embedded devices, and to advertise its services. Each discovery message contains four major components:\n\n",{"@attributes":{"id":"p-0351","num":"0379"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"NT","USN"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Three discovery messages for the root device."}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","device UUID","device UUID"]},{"entry":["2","device type","device UUID and :: and device type"]},{"entry":["3","upnp:rootdevice","device UUID and :: and upnp:rootdevice"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Two discovery messages for each embedded device."}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","device UUID","device UUID"]},{"entry":["2","device type","device UUID and :: and device type"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Once for each service."}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","service type","device UUID and :: and service type"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}},"br":[{},{},{},{}]},{"@attributes":{"id":"p-0352","num":"0380"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"NOTIFY * HTTP\/1.1"},{"entry":"HOST: 239.255.255.250:1900"},{"entry":"CACHE-CONTROL: max-age = seconds until advertisement expires"},{"entry":"LOCATION: URL for UPnP description for root device"},{"entry":"NT: search target"},{"entry":"NTS: ssdp:alive"},{"entry":"SERVER: OS\/version, UPnP\/1.0, product\/version"},{"entry":"USN: advertisement UUID"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":[{},{},{},{}]},"Method defined by GENA for sending notifications and events.","*","Request applies generally and not to a specific resource.","HTTP\/1.1","HTTP version.","Headers","HOST",{"@attributes":{"id":"p-0356","num":"0000"},"ul":{"@attributes":{"id":"ul0013","list-style":"none"},"li":{"@attributes":{"id":"ul0013-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0014","list-style":"none"},"li":["Multicast channel and port reserved for SSDP by Internet Assigned Numbers Authority (IANA). Is 239.255.255.250:1900.\n\nCACHE-CONTROL\n","max-age directive specifies number of seconds the advertisement is valid. After this duration, control points assume the device (or service) is no longer available. Specified by UPnP vendor. Integer.\n\nLOCATION\n","Contains a URL to the UPnP description of the root device. In some unmanaged networks, host of this URL may contain an IP address (versus a domain name). Specified by UPnP vendor. Single URL.\n\nNT\n"]}}}},"Notification Type. Is one of the following. Single URI.","upnp:rootdevice","Sent once for root device.","uuid:schemas-upnp-org:device:device-type:device-UUID","Specified by UPnP vendor. Sent once for each device, root or embedded.","urn:schemas-upnp-org:device:device-type",{"@attributes":{"id":"p-0360","num":"0000"},"ul":{"@attributes":{"id":"ul0015","list-style":"none"},"li":{"@attributes":{"id":"ul0015-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0016","list-style":"none"},"li":["Defined by UPnP Forum working committee. Sent once for each device, root or embedded.\n\nurn:schemas-upnp-org:service:service-type\n","Defined by UPnP Forum working committee. Sent once for each service.\n\nNTS\n"]}}}},"Notification Sub Type. Is ssdp:alive. Single URI.","SERVER",{"@attributes":{"id":"p-0362","num":"0000"},"ul":{"@attributes":{"id":"ul0017","list-style":"none"},"li":{"@attributes":{"id":"ul0017-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0018","list-style":"none"},"li":["Concatenation of OS name, OS version, UPnP\/1.0, product name, and product version. Specified by UPnP vendor. String.\n\nUSN\n","header defined by SSDP. Unique Service Name. Is one of the following. (cf. table above.) The prefix (before the double colon) matches the value of the UDN element in the device description. (The section on Description explains the UDN element.) Single URI.\n\nuuid:device-UUID::upnp:rootdevice\n"]}}}},"Sent once for root device.","uuid:device-UUID","Specified by UPnP vendor. Sent once for every device, root or embedded.","uuid:device-UUID::urn:schemas-upnp-org:device:deviceType:v","Sent once for every device, root or embedded.","uuid:device-UUID::urn:schemas-upnp-org:service:serviceType:v","Sent once for every service.","(No response for a request with method NOTIFY.)","1.1.3 Discovery: Advertisement: Device Unavailable\u2014NOTIFY with ssdp:byebye","When a device and its services are going to be removed from the network, the device multicasts a ssdp:byebye message corresponding to each of the ssdp:alive messages it multicasted that have not already expired. If the device is removed abruptly from the network, it might not be possible to multicast a message. As a fallback, discovery messages include an expiration value in a CACHE-CONTROL header (as explained above); if not re-advertised, the discovery message eventually expires on its own and is removed from any control point cache.\n\n(Note: when a control point is about to be removed from the network, no discovery-related action is required.)\n\nWhen a device is about to be removed from the network, it explicitly revokes its discovery messages by sending one multicast request for each ssdp:alive message it sent. Each multicast request has method NOTIFY and ssdp:byebye in the NTS header in the following format. Values in italics are placeholders for actual values.\n",{"@attributes":{"id":"p-0368","num":"0400"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<SPAN class=gena>NOTIFY<\/SPAN> * HTTP\/1.1"},{"entry":"HOST: <SPAN class=ssdp>239.255.255.250<\/SPAN>:<SPAN"},{"entry":"class=ssdp>1900<\/SPAN>"},{"entry":"<SPAN class=gena>NT<\/SPAN>: <SPAN class=vendor>search target"},{"entry":"<\/SPAN>"},{"entry":"<SPAN class=gena>NTS<\/SPAN>: <SPAN class=ssdp>ssdp:byebye"},{"entry":"<\/SPAN>"},{"entry":"<SPAN class=ssdp>USN<\/SPAN>: <SPAN class=vendor>advertisement"},{"entry":"UUID<\/SPAN>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":[{},{},{},{}]},"Method defined by GENA for sending notifications and events.","*","Request applies generally and not to a specific resource.","HTTP\/1.1","HTTP version.","Headers","HOST","Multicast channel and port reserved for SSDP. Is 239.255.255.250:1900.","NT","Notification Type. Single URI.","NTS","Notification Sub Type. Is ssdp:byebye. Single URI.","USN","Unique Service Name. Single URI.","(No response for a request with method NOTIFY.)","Due to the unreliable nature of UDP, devices send each of the above messages more than once. As a fallback, if a control point fails to receive notification that a device or services is unavailable, the original discovery message will eventually expire yielding the same effect.\n\n1.2 Discovery: Search\n\nWhen a control point is added to the network, the UPnP discovery protocol allows that control point to search for devices of interest on the network. It does this by multicasting a search message with a pattern, or target, equal to a type or identifier for a device or service. Responses from devices contain discovery messages essentially identical to those advertised by newly connected devices; the former are unicast while the latter are multicast.\n\n1.2.1 Discovery: Search Protocols and Standards\n\nTo search for devices (and be discovered by control points), control points (and devices) use the following subset of the overall UPnP protocol stack. (The overall UPnP protocol stack is listed at the beginning of this document.)\n\nAt the highest layer, search messages contain vendor-specific information, e.g., the control point, device, and service identifiers. Moving down the stack, vendor content is supplemented by information from a UPnP Forum working committee, e.g., device or service types. Messages from the layers above are hosted in UPnP-specific protocols, defined in this document. In turn, search requests are delivered via a multicast variant of HTTP that has been extended using Simple Service Discovery Protocol (SSDP) methods headers. Search responses are delivered via a unicast variant of HTTP that has also been extended with SSDP. (GENA is not involved when control points search for devices.) Both kinds of HTTP messages are delivered via UDP over IP. For reference, colors in [square brackets] above indicate which protocol defines specific headers and values in discovery messages listed below.\n\n1.2.2 Discovery: Search: Request with M-SEARCH\n\nWhen a control point is added to the network, it sends a multicast request with method M-SEARCH in the following format. Values in italics are placeholders for actual values.\n","M-SEARCH*HTTP\/1.1","HOST: 239.255.255.250:1900","MAN: \u201cssdp:discover\u201d","MX: seconds to delay response","S: uuid:controlpoint UUID","ST: search target","(No body for request with method M-SEARCH.)","Listed below are details for the request line and headers appearing in the listing above. All header values are case sensitive except where noted.","Request Line","M-SEARCH","Method defined by SSDP for search requests.","*","Request applies generally and not to a specific resource.","HTTP\/1.1","HTTP version.","Headers","HOST","Multicast channel and port reserved for SSDP. Is 239.255.255.250:1900.","MAN","Is \u201cssdp:discover\u201d.","MX",{"@attributes":{"id":"p-0388","num":"0000"},"ul":{"@attributes":{"id":"ul0019","list-style":"none"},"li":{"@attributes":{"id":"ul0019-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0020","list-style":"none"},"li":["Maximum wait. Device responses are delayed a random duration between 0 and this many seconds to balance load for the control point when it processes responses. Specified by UPnP vendor. Integer.\n\nS\n","Source identifier. Universally-unique identifier for the control point. Specified by UPnP vendor. Single URI.\n\nST\n"]}}}},"Search Target. Is one of the following. (cf. NT header in advertisement.) Single URI.","ssdp:all","Search for all devices and services.","upnp:rootdevice","Search for root devices only.","uuid:schemas-upnp-org:device:device-type:device-UUID","Specified by UPnP vendor. Search for a particular device.","urn:schemas-upnp-org:device:device-type","Defined by UPnP Forum working committee. Search for any device of this type.","urn:schemas-upnp-org:service:service-type","Defined by UPnP Forum working committee. Search for any service of this type.","1.2.3 Discovery: Search: Response","To be found, a device sends a response in the following format. (Compare to multicast request with method NOTIFY and ssdp:alive in the NTS header above.) Values in italics are placeholders for actual values.","HTTP\/1.1 200 OK","CACHE-CONTROL: max-age=seconds until advertisement expires","DATE: when response was generated","EXT:","LOCATION: URL for UPnP description for root device","S: uuid:controlpoint UUID","SERVER: OS\/version, UPnP\/1.0, product\/version","ST: search target","USN: uuid:schemas-upnp-org:device:device-type:UUID","(No body for a response to a request with method M-SEARCH.)","Listed below are details for the headers appearing in the listing above. All header values are case sensitive except where noted.","Headers","CACHE-CONTROL",{"@attributes":{"id":"p-0404","num":"0000"},"ul":{"@attributes":{"id":"ul0021","list-style":"none"},"li":{"@attributes":{"id":"ul0021-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0022","list-style":"none"},"li":"max-age directive specifies number of seconds the advertisement is valid. After this duration, control points assume the device (or service) is no longer available. Specified by UPnP vendor. Integer.\n\nDATE\n"}}}},"When response was generated. RFC 1123 date.","EXT","Confirms that the MAN header was understood. (Header only; no value.)","LOCATION",{"@attributes":{"id":"p-0407","num":"0000"},"ul":{"@attributes":{"id":"ul0023","list-style":"none"},"li":{"@attributes":{"id":"ul0023-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0024","list-style":"none"},"li":["Contains a URL to the UPnP description of the root device. Specified by UPnP vendor. Single URL.\n\nS\n","Source identifier. Is the universally-unique identifier sent in the request. Specified by UPnP vendor. Single URI.\n\nSERVER\n","Concatenation of OS name, OS version, UPnP\/1.0, product name, and product version. Specified by UPnP vendor. String.\n\nST\n"]}}}},"Search Target. Single UR1. If ST header in request was,","ssdp:all",{"@attributes":{"id":"p-0409","num":"0000"},"ul":{"@attributes":{"id":"ul0025","list-style":"none"},"li":{"@attributes":{"id":"ul0025-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0026","list-style":"none"},"li":"Respond 3+2d+s times for a root device with d embedded devices and s embedded services.\n\nupnp:rootdevice\n"}}}},"Respond once for root device.","uuid:schemas-upnp-org:device:device-type:device-UUID","Respond once for each device, root or embedded.","urn:schemas-upnp-org:device:device-type","Respond once for each device, root or embedded.","urn:schemas-upnp-org:service:service-type","Respond once for each service.","USN","Unique Service Name. Single URI.","(No UPnP-specific errors are defined for search messages.) Errors may be returned by layers in the protocol stack below UPnP. Consult documentation on those protocols for details.","2. Description","Description is Step 2 in UPnP networking. Description comes after discovery (Step 1) where control points find interesting device(s). And description enables control (Step 3) where a control points send commands to device(s), eventing (Step 4) where control points listen to state changes in device(s), and presentation (Step 5) where control points display a user interface for device(s).\n\nAfter a control point has discovered a device, the control point still knows very little about the device\u2014only the information that was in the discovery message, i.e., the device's (or service's) UPnP type, the device's universally-unique identifier, and a URL to the device's UPnP description. For the control point to learn more about the device and its capabilities, or to interact with the device, the control point retrieves the device's description from the URL provided by the device in the discovery message.\n\nThe UPnP description for a device includes vendor-specific, manufacturer information like the model name and number, serial number, manufacturer name, URLs to vendor-specific Web sites, etc. (details below). The description also includes a list of any embedded devices or services, as well as URLs for control, eventing, and presentation. This section explains embedded devices; the section on Control explains how services are described, and the sections on Control, Eventing, and Presentation explain how URLs for control, eventing, and presentation are used, respectively.\n\nNote that a single physical device may include multiple logical devices. Multiple logical devices can be modeled as a single root device with embedded devices (and services) or as multiple root devices (perhaps with no embedded devices). In either case, there is one UPnP description for each root device, with embedded device descriptions as needed.\n\nThe UPnP description for a device is written by a UPnP vendor. The description is in XML syntax and is usually based on a standard UPnP Device Template. A UPnP Device Template is produced by a UPnP Forum working committee; they derive the template from the UPnP Template Language, which was derived from standard constructions in XML. This section explains the format for a UPnP device description, UPnP Device Templates, and the part of the UPnP Template Language that covers devices. (The section on Control explains the part of the UPnP Template Language that covers services.)\n\nRetrieving the UPnP description for a device is simple: the control point issues an HTTP GET request on the URL in the discovery message, and the device returns the description document. The protocol stack, method, headers, and body for the response and request are explained in detail below.\n\nUPnP vendors can differentiate their devices by extending services, including additional UPnP services, or embedding additional UPnP devices. When a control point retrieves a particular device's description, these added features are exposed to the control point for control, eventing, and presentation. (Other means for UPnP vendor differentiation are explained in the control section.)\n\nThe remainder of this section first explains how devices are described, explaining details of vendor-specific information, embedded devices, and URLs for control, eventing, and presentation. Then it explains UPnP Device Templates and the UPnP Template Language as it pertains to describing devices. Finally, it explains in detail how a control point retrieves a description from a device.\n\n2.1 Description: Device Description\n\nThe UPnP description for a device contains several pieces of vendor-specific information, definitions of embedded devices and services, and URLs for control, eventing, and presentation of the device.\n\nTo illustrate these, below is a listing with placeholders (in italics) for actual elements and values. Some of these placeholders would be specified by a UPnP Forum working committee (colored red) or by a UPnP vendor (purple). (Elements defined by the UPnP Device Architecture are colored green for later reference.) Immediately following the listing is a detailed explanation of the elements, attributes, and values.\n\n","Case sensitive.","root",{"@attributes":{"id":"p-0417","num":"0000"},"ul":{"@attributes":{"id":"ul0029","list-style":"none"},"li":{"@attributes":{"id":"ul0029-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0030","list-style":"none"},"li":"Has urn:schemas-upnp-org:device:1:0 as the value for the xmlns attribute; this references the UPnP Template Language (described below). Case sensitive. Contains all other elements describing the root device, i.e., contains the following sub elements:\n\nspecVersion\n"}}}},"Contains the following sub elements:","major","Major version of the UPnP Device Architecture. Is 1.","minor","Minor version of the UPnP Device Architecture. Is 0.","URLBase",{"@attributes":{"id":"p-0421","num":"0000"},"ul":{"@attributes":{"id":"ul0031","list-style":"none"},"li":{"@attributes":{"id":"ul0031-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0032","list-style":"none"},"li":"Defines the base URL. Used to construct fully-qualified URLs. All relative URLs that appear elsewhere in the description are appended to this base URL. If URLBase is empty or not given, the base URL is the value of the LOCATION header in the discovery message. Specified by UPnP vendor. Single URL.\n\ndevice\n"}}}},"Contains the following sub elements:","deviceType","UPnP device type.\n\n","Single URI.","friendlyName",{"@attributes":{"id":"p-0425","num":"0000"},"ul":{"@attributes":{"id":"ul0035","list-style":"none"},"li":{"@attributes":{"id":"ul0035-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0036","list-style":"none"},"li":"Short description for end user. Is localized (cf. ACCEPT-LANGUAGE header). String. Is <64 characters.\n\nmanufacturer\n"}}}},"Manufacturer's name. Specified by UPnP vendor. String. Is <64 characters.","manufacturerURL",{"@attributes":{"id":"p-0427","num":"0000"},"ul":{"@attributes":{"id":"ul0037","list-style":"none"},"li":{"@attributes":{"id":"ul0037-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0038","list-style":"none"},"li":["Web site for Manufacturer. May be relative to base URL. Specified by UPnP vendor. Single URL.\n\nmodelDescription\n","Long description for end user. Is localized (cf. ACCEPT-LANGUAGE header). Specified by UPnP vendor. String. Is <128 characters.\n\nmodelName\n"]}}}},"Model name. Specified by UPnP vendor. String. Is <32 characters.","modelNumber","Model number. Specified by UPnP vendor. String. Is <32 characters.","modelURL",{"@attributes":{"id":"p-0430","num":"0000"},"ul":{"@attributes":{"id":"ul0039","list-style":"none"},"li":{"@attributes":{"id":"ul0039-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0040","list-style":"none"},"li":["Web site for model. May be relative to base URL. Specified by UPnP vendor. Single URL.\n\npresentationURL\n","URL to presentation hosted by device (cf. section on Presentation). May be relative to base URL. Specified by UPnP vendor. Single URL.\n\nserialNumber\n"]}}}},"Serial number. Specified by UPnP vendor. String. Is <64 characters.","UDN",{"@attributes":{"id":"p-0432","num":"0000"},"ul":{"@attributes":{"id":"ul0041","list-style":"none"},"li":{"@attributes":{"id":"ul0041-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0042","list-style":"none"},"li":"Universal Device Name. Universally-unique identifier for the device, whether root or embedded.\n        \n        "}}}},"Single URI.","UPC",{"@attributes":{"id":"p-0434","num":"0000"},"ul":{"@attributes":{"id":"ul0044","list-style":"none"},"li":{"@attributes":{"id":"ul0044-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0045","list-style":"none"},"li":"Universal Product Code. 12-digit, all-numeric code that identifies the consumer package. Managed by the Uniform Code Council. Single UPC.\n\niconList\n"}}}},"Contains the following sub elements:","icon",{"@attributes":{"id":"p-0436","num":"0000"},"ul":{"@attributes":{"id":"ul0046","list-style":"none"},"li":{"@attributes":{"id":"ul0046-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0047","list-style":"none"},"li":"Icon to depict device in a control point UI. Recommend one icon in each of the following sizes (width\u00d7height\u00d7depth): 16\u00d716\u00d71, 16\u00d716\u00d78, 32\u00d732\u00d71, 32\u00d732\u00d78, 48\u00d748\u00d71, 48\u00d748\u00d78. Contains the following sub elements:\n\nmimetype\n"}}}},"Icon's MIME type (cf. RFC 2387). Single MIME image type.","width","Horizontal dimension of icon in pixels. Integer.","height","Vertical dimension of icon in pixels. Integer.","depth","Number of color bits per pixel. Integer.","url",{"@attributes":{"id":"p-0441","num":"0000"},"ul":{"@attributes":{"id":"ul0048","list-style":"none"},"li":{"@attributes":{"id":"ul0048-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0049","list-style":"none"},"li":"Pointer to icon image. (XML does not support embedding of binary data. See note below.) Retrieved via HTTP. May be relative to base URL. Specified by UPnP vendor. Single URL.\n\nserviceList\n"}}}},"Contains the following sub elements:","service",{"@attributes":{"id":"p-0443","num":"0000"},"ul":{"@attributes":{"id":"ul0050","list-style":"none"},"li":{"@attributes":{"id":"ul0050-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0051","list-style":"none"},"li":["Repeated once for each service defined by a UPnP Forum working committee. If UPnP vendor differentiates device by adding additional, standard UPnP services, repeated once for additional service. Contains the following sub elements:\n\ncontrolURL\n","URL for control (cf. section on Control). May be relative to base URL. Specified by UPnP vendor. Single URL.\n\neventSubURL\n","URL for eventing (cf. section on Eventing). May be relative to base URL. Specified by UPnP vendor. Single URL.\n\nSCPDURL\n","URL for service description (nee Service Control Protocol Definition URL). (cf. section on Control.) May be relative to base URL. Specified by UPnP vendor. Single URL.\n\nserviceId\n","Service identifier. Is unique within this device description. <format TBD>. Defined by a UPnP Forum working committee. Single URI.\n\nserviceType\n\nUPnP service type.\n","For standard service types defined by a UPnP Forum working committee, begins with urn:schemas-upnp-org:service: followed by a service type suffix (as shown in the listing above).","For non-standard service types specified by UPnP vendors, begins with urn:, followed by a domain name owned by the vendor, followed by :service:, followed by a service type suffix, i.e., urn:domain-name:service:service-type:service-version.\n\nSingle URI.\n\ndeviceList\n"]}}}},"Contains the following sub elements:","device",{"@attributes":{"id":"p-0445","num":"0000"},"ul":{"@attributes":{"id":"ul0052","list-style":"none"},"li":{"@attributes":{"id":"ul0052-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0053","list-style":"none"},"li":["Repeat once for each embedded device defined by a UPnP Forum working committee. If UPnP vendor differentiates device by embedding additional UPnP devices, repeat once for each embedded device. Contains sub elements as defined above for root sub element device.\n\nFor future extensibility, when processing XML like the listing above, devices and control points ignore any unknown elements and any sub elements or content as specified by the Flexible XML Processing Profile (FXPP).\n\nXML does not support directly embedding binary data, e.g., icons in UPnP descriptions. Binary data may be converted into text (and thereby embedded into XML) using an XML data type of either bin.base64 (a MIME-style base 64 encoding for binary data) or bin.hex (hexadecimal digits represent octets). Alternatively, the data can be passed indirectly, as it were, by embedding a URL in the XML and transferring the data in response to a separate HTTP request; the icon(s) in UPnP descriptions are transferred in this latter manner.\n\n2.2 Description: UPnP Device Template\n\nThe listing above also illustrates the relationship between a UPnP device description and a UPnP Device Template. As explained above, the UPnP description for a device is written by a UPnP vendor, in XML, following a UPnP Device Template. A UPnP Device Template is produced by a UPnP Forum working committee as a means to standardize devices.\n\nBy appropriate specification of placeholders, the listing above can be either a UPnP Device Template or a UPnP device description. Recall that some placeholders would be defined by a UPnP Forum working committee (colored red), i.e., the UPnP device type identifier, UPnP services, and UPnP embedded devices (if any). If these were defined, the listing would be a UPnP Device Template, codifying the standard for this type of device. UPnP Device Templates are one of the key deliverables from UPnP Forum working committees.\n\nTaking this another step further, the remaining placeholders in the listing above would be specified by a UPnP vendor (colored purple), i.e., vendor-specific information. If these placeholders were specified (as well as the others), the listing would be a UPnP device description, suitable to be delivered to a control point to enable control, eventing, and presentation.\n\nPut another way, the UPnP Device Template defines the overall type of device, and each UPnP device description instantiates that template with vendor-specific information. The first is created by a UPnP Forum working committee; the latter, by a UPnP vendor.\n\n2.3 Description: UPnP Template Language for Devices\n\nThe paragraphs above explain UPnP device descriptions and illustrate how one would be instantiated from a UPnP Device Template. As explained, UPnP Device Templates are produced by UPnP Forum working committees, and these templates are derived from the UPnP Template Language. This template language defines well-formed templates for devices and services. Below is a listing and explanation of this language as it pertains to devices. The section on Control explains the UPnP Template Language as it pertains to services.\n\nThe UPnP Template Language is written in XML syntax and is derived from XML Schema (Part 1: Structures, Part 2: Datatypes). XML Schema provides a set of XML constructions that express language concepts like required vs. optional elements, element nesting, and data types for values (as well as other properties not of interest here). The UPnP Template Language uses these XML Schema constructions to define elements like specVersion, URLBase, deviceType, et al listed in detail above. Because the UPnP Template Language is constructed using another, precise language, it is unambiguous. And because the UPnP Template Language, UPnP Device Templates, and UPnP device descriptions are all machine-readable, automated tools can automatically check to ensure the latter two have all required elements, are correctly nested, and have values of the correct data types. Below is the UPnP Template Language for devices as defined by the UPnP Device Architecture herein. The elements it defines are used in UPnP Device Templates; they are colored green here, and they are colored green in the listing above. Below is where these elements are defined; above is where they are used.\n\nImmediately following this is a brief explanation of the XML Schema elements, attributes, and values used. The reference to XML Schema at the end of the section has further details.\n\nUPnP Template Language for Devices\n","<?xml version=\u201c1.0\u201d ?>","<Schema name=\u201curn:schemas-upnp-org:device:1:0\u201d","xmlns=\u201curn:schemas-microsoft-com:xml-data\u201d","xmlns:dt=\u201curn:schemas-microsoft-com:datatypes\u201d>","<ElementType name=\u201croot\u201d content=\u201celtOnly\u201d>","<element type=\u201cspecVersion\u201d\/>","<element type=\u201cURLBase\u201d minOccurs=\u201c0\u201d\/>","<element type=\u201cdevice\u201d\/>","<\/ElementType>","<ElementType name=\u201cspecVersion\u201d>","<element type=\u201cmajor\u201d\/>","<element type=\u201cminor\u201d\/>","<\/ElementType>","<ElementType name=\u201cmajor\u201d dt:type=\u201cint\u201d\/>","<ElementType name=\u201cminor\u201d dt:type=\u201cint\u201d\/>","<ElementType name=\u201cURLBase\u201d dt:type=\u201curi\u201d\/>","<ElementType name=\u201cdevice\u201d content=\u201celtOnly\u201d>","<element type=\u201cUDN\u201d\/>","<element type=\u201cfriendlyName\u201d\/>","<element type=\u201cdeviceType\u201d\/>","<element type=\u201cpresentationURL\u201d minOccurs=\u201c0\u201d\/>","<element type=\u201cmanufacturer\u201d\/>","<element type=\u201cmanufacturerURL\u201d minOccurs=\u201c0\u201d P>","<element type=\u201cmodelName\u201d\/>","<element type=\u201cmodelNumber\u201d minOccurs=\u201c0\u201d\/>","<element type=\u201cmodelDescription\u201d minOccurs=\u201c0\u201d\/>","<element type=\u201cmodelURL\u201d minOccurs=\u201c0\u201d\/>","<element type=\u201cUPC\u201d minOccurs=\u201c0\u201d\/>","<element type=\u201cserialNumber\u201d minOccurs=\u201c0\u201d\/>","<element type=\u201ciconList\u201d\/>","<element type=\u201cserviceList\u201d\/>","<element type=\u201cdeviceList\u201d minOccurs=\u201c0\u201d\/>","<\/ElementType>","<ElementType name=\u201cUDN\u201d dt:type=\u201curi\u201d\/>","<ElementType name=\u201cfriendlyName\u201d dt:type=\u201cstring\u201d\/>","<ElementType name=\u201cdeviceType\u201d dt:type=\u201curi\u201d\/>","<ElementType name=\u201cpresentationURL\u201d dt:type=\u201curi\u201d\/>","<ElementType name=\u201cmanufacturer\u201d dt:type=\u201cstring\u201d\/>","<ElementType name=\u201cmanufacturerURL\u201d dt:type=\u201curi\u201d\/>","<ElementType name=\u201cmodelName\u201d dt:type=\u201cstring\u201d\/>","<ElementType name=\u201cmodelNumber\u201d dt:type=\u201cstring\u201d\/>","<ElementType name=\u201cmodelDescription\u201d dt:type=\u201cstring\u201d\/>","<ElementType name=\u201cmodelURL\u201d dt:type=\u201curi\u201d\/>","<ElementType name=\u201cUPC\u201d dt:type=\u201cstring\u201d>","<ElementType name=\u201cserialNumber\u201d dt:type=\u201cstring\u201d\/>","<ElementType name=\u201ciconList\u201d content=\u201celtOnly\u201d>","<element type=\u201cicon\u201d maxOccurs=\u201c*\u201d\/>","<\/ElementType>","<ElementType name=\u201cicon\u201d content=\u201celtOnly\u201d>","<element type=\u201cmimetype\u201d\/>","<element type=\u201cwidth\u201d\/>","<element type=\u201cheight\u201d\/>","<element type=\u201cdepth\u201d\/>","<element type=\u201curl\u201d\/>","<\/ElementType>","<ElementType name=\u201cmimetype\u201d dt:type=\u201cstring\u201d\/>","<ElementType name=\u201cwidth\u201d dt:type=\u201cint\u201d\/>","<ElementType name=\u201cheight\u201d dt:type=\u201cint\u201d\/>","<ElementType name=\u201cdepth\u201d dt:type=\u201cint\u201d\/>","<ElementType name=\u201curl\u201d dt:type=\u201curi\u201d\/>","<ElementType name=\u201cdeviceList\u201d content=\u201celtOnly\u201d>","<element type=\u201cdevice\u201d maxOccurs=\u201c*\u201d\/>","<\/ElementType>","<ElementType name=\u201cserviceList\u201d content=\u201celtOnly\u201d>","<element type=\u201cservice\u201d maxOccurs=\u201c*\u201d\/>","<\/ElementType>","<ElementType name=\u201cservice\u201d content=\u201celtOnly\u201d>","<element type=\u201cserviceType\u201d\/>","<element type=\u201cserviceId\u201d\/>","<element type=\u201ccontrolURL\u201d\/>","<element type=\u201ceventSubURL\u201d\/>","<element type=\u201cSCPDURL\u201d\/>","<\/ElementType>","<ElementType name=\u201cserviceType\u201d dt:type=\u201curi\u201d\/>","<ElementType name=\u201cserviceId\u201d dt:type=\u201curi\u201d\/>","<ElementType name=\u201ccontrolURL\u201d dt:type=\u201curi\u201d\/>","<ElementType name=\u201ceventSubURL\u201d dt:type=\u201curi\u201d\/>","<ElementType name=\u201cSCPDURL\u201d dt:type=\u201curi\u201d\/>","<\/Schema>\n\nElementType\n","Defines an element in the new, derived language. name attribute defines element name. dt:type attribute defines the data type for the value of element in the new, derived language.\n\nelement\n","References an element for the purposes of declaring nesting. minOccurs attribute defines minimum number of times the element occurs; default is minOccurs=1; optional elements have minOccurs=0. maxOccurs attribute defines maximum number of times the element occurs; default is maxOccurs=1; elements that can appear one or more times have maxOccurs=*.\n\n2.4 Description: Retrieving a Description\n\nAs explained above, after a control point has discovered a device, it still knows very little about the device. To learn more about the device and its capabilities, the control point retrieves the UPnP description for the device using the URL provided by the device in the discovery message. This is a simple HTTP-based process and uses the following subset of the overall UPnP protocol stack. (The overall UPnP protocol stack is listed at the beginning of this document.)\n\nAt the highest layer, description messages contain vendor-specific information, e.g., device type, service type, and services. Moving down the stack, vendor content is supplemented by information from a UPnP Forum working committee, e.g., model name, model number, and specific URLs. Messages from the layers above are hosted in UPnP-specific protocols, defined in this document. In turn, the above messages are delivered via HTTP over TCP over IP. For reference, colors in [square brackets] above indicate which protocol defines specific header and body elements in the description messages listed below.\n\nUsing this protocol stack, retrieving the UPnP description for a device is simple: the control point issues an HTTP GET request to the URL in the discovery message, and the device returns its description in the body of an HTTP response. The headers and body for the response and request are explained in detail below.\n\nFirst, a control point sends a request with method GET in the following format. Values in italics are placeholders for actual values.\n"]}}}},"GET path to device description HTTP\/1.1","HOST: host for device description:port for device description","ACCEPT-LANGUAGE: language preferred by control point","(No message body for request to retrieve a description.)","Listed below are details for the request line and headers appearing in the listing above. All header values are case sensitive except where noted.","Request Line","GET","Method defined by HTTP.","Path to Device Description",{"@attributes":{"id":"p-0450","num":"0000"},"ul":{"@attributes":{"id":"ul0054","list-style":"none"},"li":{"@attributes":{"id":"ul0054-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0055","list-style":"none"},"li":"Path component of device description URL (LOCATION header in discovery message). Single, relative URL.\n\nHTTP\/1.1\n"}}}},"HTTP Version.","Headers","HOST",{"@attributes":{"id":"p-0452","num":"0000"},"ul":{"@attributes":{"id":"ul0056","list-style":"none"},"li":{"@attributes":{"id":"ul0056-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0057","list-style":"none"},"li":["Domain name or IP address and optional port components of device description URL (LOCATION header in discovery message). If the port is empty or not given, port 80 is assumed.\n\nACCEPT-LANGUAGE\n","Preferred language(s) for device description. If no description is available in this language, device may return a description in a default language. RFC 1766 language tag(s).\n\nAfter a control point sends a request, the device takes the second step: a device sends a response in the following format. Values in italics are placeholders for actual values.\n"]}}}},"HTTP\/1.1 200 OK","CONTENT-LENGTH: bytes in body","CONTENT-TYPE: text\/xml","DATE: when responded","SERVER: OS\/version, UPnP\/1.0, product\/version","The body of this response is a UPnP device description as explained in detail above. Listed below are details for the headers appearing in the listing above. All header values are case sensitive except where noted.","Headers","CONTENT-LENGTH","Length of body in bytes. Integer.","CONTENT-TYPE","Is text\/xml.","DATE","When response was generated. RFC 1123 date.","SERVER",{"@attributes":{"id":"p-0461","num":"0000"},"ul":{"@attributes":{"id":"ul0058","list-style":"none"},"li":{"@attributes":{"id":"ul0058-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0059","list-style":"none"},"li":["Concatenation of OS name, slash, OS version, UPnP\/1.0, product name, slash, and product version. String.\n\n3. Control\n\nControl is Step 3 in UPnP networking. Control comes after discovery (Step 1) where control points find interesting device(s), and after description (Step 2) where control points learn about device capabilities. Control is intimately linked with eventing (Step 4) where control points listen to state changes in device(s). Through control, control points send actions to devices and poll for values. Control and eventing are complementary to presentation (Step 5) where control points display a user interface provided by device(s).\n\nAfter a control point has (1) discovered a device and (2) retrieved a description of the device, the control point has the bare essentials for device control. To learn more about the service, a control point retrieves a detailed UPnP description for each service.\n\nA UPnP description for a service includes a list of the commands, or actions, the service responds to, and parameters, or arguments, for each action. A service description also includes a list of variables. These variables model the state of the service at run time, and are described in terms of their data type, range, and event characteristics. This section explains the description of actions, arguments, state variables, and properties of those variables. The section on Eventing explains event characteristics.\n\nLike the UPnP description for a device, the UPnP description for a service is written by a UPnP vendor. The description is in XML syntax and is based on a standard UPnP Service Template. A UPnP Service Template is produced by a UPnP Forum working committee; they derive the template from the UPnP Template Language, augmenting it with human language where necessary. As explained above, the UPnP Template Language is derived from standard constructions in XML. This section explains the format for a UPnP service description, UPnP Service Templates, typical augmentations in human language, and the part of the UPnP Template Language that covers services. (The section on Description explains the part of the UPnP Template Language that covers devices.)\n\nTo control a device, a control point requests a device's service to perform an action. To do this, a control point sends a suitable control message to the control URL for the service (provided in the device description). In response, the service provides a simple acknowledgement; unlike function calls, no service-specific value is returned. The effects of the action, if any, are modeled by changes in the variables that describe the run-time state of the service. When these state variables change, events are published to all interested control points. This section explains the protocol stack for, and format of, control messages. The section on Eventing explains event publication.\n\nTo prevent a race condition between events headed for control points and requested actions headed for a service, control messages may include a key. With each new event message a service generates, the service increments the key, and includes that key in the event message. When a control point sends a control message, it may choose to include a key. If a control message includes a key, the service checks to see if the key is current, i.e., if no events have been sent since this key was issued. If the key is current (or if there was no key in the control message), then the service acknowledges the action request. If the key is not current, the service fails the action request. This section briefly explains the event key. The section on Eventing explains in detail event messages and event publication.\n\nTo determine the current value of a state variable, a control point may poll the service. Similar to requesting an action, a control point sends a suitable query message to the control URL for the service. In response, the service provides the value of the variable. This section also explains the format of these query messages. The section on eventing explains automatic notification of variable values.\n\nThe remainder of this section first explains how services are described, explaining details of actions, arguments, state variables, and properties of those variables. Second, it explains UPnP Service Templates, typical ways to augment service descriptions with human language, and the UPnP Template Language as it pertains to services. Third, it explains how a control point retrieves a service description. Finally, this section explains in detail how control and query messages are formatted and sent to devices.\n\n3.1 Control: Service Description\n\nThe UPnP description for a service defines actions and their arguments, and state variables and their data type, range, and event characteristics.\n\nEach action may have zero or more arguments. Each argument corresponds to a state variable. This direct-manipulation programming model reinforces simplicity.\n\nTo illustrate these points, below is a listing with placeholders (in italics) for actual elements and values. For a standard UPnP service, some of these placeholders would be defined by a UPnP Forum working committee (colored red) or specified by a UPnP vendor (purple). For a vendor-unique service, all of these placeholders would be specified by a UPnP vendor. (Elements defined by the UPnP Device Architecture are colored green for later reference.) Immediately following the listing is a detailed explanation of the elements, attributes, and values.\n","<?xml version=\u201c 1.0\u201d?>","<scpd xmlns=\u201curn:schemas-upnp-org:service:1:0\u201d>","<actionList>","<action>","<name>action name<\/name>","<argumentList>","<argument>","<name>formal parameter name<\/name>","<relatedStateVariable>state variable name<\/relatedStateVariable>","<\/argument>","Declarations for other arguments defined by UPnP Forum working committee (if any)","go here","<\/argumentList>","<\/action>","Declarations for other actions defined by UPnP Forum working committee (if any) go here","Declarations for other actions added by UPnP vendor (if any) go here","<\/actionList>","<serviceStateTable>","<stateVariable>","<name>variable name<\/name>","<dataType>variable data type<\/dataType>","<defaultValue>default value<\/defaultValue>","<allowedValueRange>","<minimum>minimum value<\/minimum>","<maximum>maximum value<\/maximum>","<step>increment value<\/step>","<\/allowedValueRange>","<\/stateVariable>","Declarations for other state variables defined by UPnP Forum working committee (if any) go here","Declarations for other state variables added by UPnP vendor (if any) go here","<\/serviceStateTable>","<\/scpd>\n\nListed below are details for each of the elements, attributes, and values appearing in the listing above. All elements and attributes are case sensitive; values are not case sensitive except where noted. Except where noted, the order of elements is insignificant.\n\nxml\n"]}}}},"Case sensitive.","scpd",{"@attributes":{"id":"p-0463","num":"0000"},"ul":{"@attributes":{"id":"ul0060","list-style":"none"},"li":{"@attributes":{"id":"ul0060-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0061","list-style":"none"},"li":"Has urn:schemas-upnp-org:service:1:0 as the value for the xmlns attribute; this references the UPnP Template Language (explained below). Case sensitive. Contains all other elements describing the service, i.e., contains the following sub elements:\n\nactionList\n"}}}},"Contains the following sub elements:","action","Contains the following sub elements:","name","Name of action. String. Is <32 characters.","argumentList","Repeat once for each parameter. Contains the following sub elements:","argument","Contains the following sub elements:","name",{"@attributes":{"id":"p-0469","num":"0000"},"ul":{"@attributes":{"id":"ul0062","list-style":"none"},"li":{"@attributes":{"id":"ul0062-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0063","list-style":"none"},"li":"Name of formal parameter. Is name of a state variable that models an effect the action causes. String. Is <32 characters.\n\nrelatedStateVariable\n"}}}},"Is the name of a state variable.","serviceStateTable","Contains the following sub elements:","stateVariable",{"@attributes":{"id":"p-0472","num":"0000"},"ul":{"@attributes":{"id":"ul0064","list-style":"none"},"li":{"@attributes":{"id":"ul0064-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0065","list-style":"none"},"li":["If UPnP vendor differentiates service by adding additional state variables, required for each additional variable. sendEvents attribute defines whether event messages will be generated when the value of this state variable changes; non-evented state variables have sendEvents=no; default is sendEvents=yes. Contains the following sub elements:\n\nname\n","Name of state variable. Defined by a UPnP Forum working committee for standard state variables; specified by UPnP vendor for extensions. String. Is <32 characters.\n\ndataType\n","Defined by a UPnP Forum working committee for standard state variables; specified by UPnP vendor for extensions. Is one of the following values:\n\ni4\n","Fixed point, integer number. May have a leading sign. May have leading zeros. (No currency symbol.) (No grouping of digits to the left of the decimal, e.g., no commas.) Is between \u22122147483648 and 2147483647, i.e., 4 byte, long integer. (Same as i4 data type defined by XML Schema, Part 2: Datatypes.)\n\nr8\n","Floating point number. Mantissa (left of the decimal) and\/or exponent may have a leading sign. Mantissa and\/or exponent may have leading zeros. Decimal character in mantissa is a period, i.e., whole digits in mantissa separated from fractional digits by period. Mantissa separated from exponent by E. (No currency symbol.) (No grouping of digits in the mantissa, e.g., no commas.) Is between \u22121.79769313486232E308 and \u22124.94065645841247E-324 for negative values, and between 4.94065645841247E-324 and 1.79769313486232E308 for positive values, i.e., IEEE 64-bit (8-byte) double. (Same as r8 data type defined by XML Schema, Part 2: Datatypes).\n\nstring\n"]}}}},"Unicode string. (Same as string data type defined by XML.)","dateTime",{"@attributes":{"id":"p-0474","num":"0000"},"ul":{"@attributes":{"id":"ul0066","list-style":"none"},"li":{"@attributes":{"id":"ul0066-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0067","list-style":"none"},"li":["Date and Time in ISO 8601 format (Same as dateTime data type defined by XML Schema, Part 2: Datatypes.)\n\nboolean\n","0, false, or no for false; 1, true, or yes for true. (Same as boolean data type defined by XML Schema, Part 2: Datatypes.)\n\nbin.hex or bin.bin64\n","Hexadecimal representation of binary data. (Same as bin.base64 and bin.hex data types defined by XML Schema, Part 2: Datatypes.)\n\ndefaultValue\n","Expected, initial value. Defined by a UPnP Forum working committee or delegated to UPnP vendor. Matches data type. Satisfies allowedValueList or allowedValueRange constraints.\n\nallowedValueList\n","Enumerates legal string values. Prohibited for data types other than string. At most one of allowedValueRange and allowedValueList may be specified. Sub elements are ordered (e.g., see NEXT_STRING_BOUNDED). Contains the following sub elements:\n\nallowedValue\n","A legal value for a string variable. Defined by a UPnP Forum working committee for standard state variables; specified by UPnP vendor for extensions. String. Is <32 characters.\n\nallowedValueRange\n","Defines bounds for legal numeric values; defines resolution for numeric values. Prohibited for data types other than i4 and r8. At most one of allowedValueRange and allowedValueList may be specified. At least one of the following sub elements is included. Contains the following sub elements:\n\nminimum\n","Inclusive lower bound. Defined by a UPnP Forum working committee or delegated to UPnP vendor. Single i4 or r8.\n\nmaximum\n","Inclusive upper bound. Defined by a UPnP Forum working committee or delegated to UPnP vendor. Single i4 or r8.\n\nstep\n","Size of an increment operation, i.e., value of s in the operation v=v+s. Defined by a UPnP Forum working committee or delegated to UPnP vendor. Single i4 or r8.\n\nFor future extensibility, when processing XML like the listing above, devices and control points ignores any unknown elements and any sub elements or content as specified by the Flexible XML Processing Profile (FXPP).\n\nNote that it is logically possible for a service to have no actions but have state variables and eventing; such a service would be an autonomous information source. Conversely, it is also logically possible for a service to have no state variables (and no eventing) but have actions; such a service might be stateless and cause short-term environmental effects.\n\nServices standardized by UPnP Forum working committees are versioned. Every later version of a service is a superset of the previous version, i.e., it includes all actions and state variables exactly as they are defined by earlier versions of the service. The UPnP service type remains the same across all versions of a service whereas the service version is larger for later versions.\n\n3.2 Control: UPnP Service Template\n\nThe listing above also illustrates the relationship between a UPnP service description and a UPnP Service Template. As explained above, the UPnP description for a service is written by a UPnP vendor, in XML, following a UPnP Service Template. A UPnP Service Template is produced by a UPnP Forum working committee as a means to standardize devices. By appropriate specification of placeholders, the listing above can be either a UPnP Service Template or a UPnP service description. Recall that some placeholders would be defined by a UPnP Forum working committee (colored red), i.e., actions and their parameters, and states and their data type, range, and event characteristics. If these were specified, the listing above would be a UPnP Service Template, codifying the standard for this type of service. Along with UPnP Device Templates (cf. section on Description), UPnP Service Templates are one of the key deliverables from UPnP Forum working committees.\n\nTaking this another step further, the remaining placeholders in the listing above would be specified by a UPnP vendor (colored purple), i.e., additional, vendor-specified actions and state variables. If these placeholders were specified (as well as the others), the listing would be a UPnP service description, suitable for effective control of the service within a device. Put another way, the UPnP Service Template defines the overall type of service, and each UPnP service description instantiates that template with vendor-specific additions. The first is created by a UPnP Forum working committee; the latter, by a UPnP vendor.\n\n3.3 Control: UPnP Template Language for Services\n\nThe paragraphs above explain UPnP service descriptions and illustrate how one would be instantiated from a UPnP Service Template. Like UPnP Device Templates, UPnP Service Templates are produced by UPnP Forum working committees, and these templates are derived from the UPnP Template Language. This template language defines well-formed templates for devices and services. The section on Description explains the UPnP Template Language as it pertains to devices. As explained in the section on Description, the UPnP Template Language is written in XML syntax and is derived from XML Schema (Part 1: Structures, Part 2: Datatypes). Below is a listing of this language as it pertains to services. The elements it defines are used in UPnP Service Templates; they are colored green here, and they are colored green in the listing above. Below is where these elements are defined; above is where they are used.\n\nImmediately following this is a brief explanation of the XML Schema elements, attributes, and values used. The reference to XML Schema at the end of the section has further details.\n\nUPnP Template Language for Services\n","<?xml version=\u201c1.0\u201d?>","<Schema name=\u201curn:schemas-upnp-org:service: 1:0\u201dxmlns=\u201curn:schemas-microsoft-com:xml-data\u201dxmlns:dt=\u201curn:schemas-microsoft-com:datatypes\u201d>","<ElementType name=\u201cname\u201d content=\u201ctextOnly\u201d dt:type=\u201cstring\u201d\/>","<ElementType name=\u201cdefaultValue\u201d content=\u201ctextOnly\u201d dt:type=\u201cstring\u201d\/>","<ElementType name=\u201cminimum\u201d content=\u201ctextOnly\u201d dt:type=\u201cnumber\u201d\/>","<ElementType name=\u201cmaximum\u201d content=\u201ctextOnly\u201d dt:type=\u201cnumber\u201d\/>","<ElementType name=\u201cstep\u201d content=\u201ctextOnly\u201d dt:type=\u201cnumber\u201d\/>","<ElementType name=\u201callowedValueRange\u201d content=\u201celtOnly\u201d model=\u201cclosed\u201d>","<element type=\u201c minimum\u201d\/>","<element type=\u201cmaximum\u201d\/>","<element type=\u201cstep\u201d minOccurs=\u201c0\u201d\/>","<\/ElementType>","<ElementType name=\u201callowedValue\u201d content=\u201ctextOnly\u201d\/>","<ElementType name=\u201callowedValueList\u201d content=\u201celtOnly\u201d model=\u201cclosed\u201d>","<element type=\u201callowedValue\u201d minOccurs=\u201c1\u201d maxOccurs=\u201c*\u201d\/>","<\/ElementType>","<ElementType name=\u201cdataType\u201d content=\u201ctextOnly\u201d dt:type=\u201cstring\u201d\/>","<ElementType name=\u201cstateVariable\u201d content=\u201celtOnly\u201d model=\u201cclosed\u201d>","<element type=\u201cname\u201d\/>","<element type=\u201cdataType\u201d\/>","<element type=\u201cdefaultValue\u201d minOccurs=\u201c0\u201d maxOccurs=\u201c1\u201d\/>","<group minOccurs=\u201c0\u201d maxOccurs=\u201c1\u201d order=\u201cone\u201d>","<element type=\u201callowedValueList\u201d\/>","<element type=\u201callowedValueRange\u201d\/>","<\/group>","<AttributeType name=\u201csendEvents\u201d\/>","<attribute default=\u201cyes\u201d type=\u201csendEvents\u201d required=\u201cno\u201d\/>","<\/ElementType>","<ElementType name=\u201cserviceStateTable\u201d content=\u201celtOnly\u201d model=\u201cclosed\u201d>","<element type=\u201cstateVariable\u201d minOccurs=\u201c1\u201d maxOccurs=\u201c*\u201d\/>","<\/ElementType>","<ElementType name=\u201crelatedStateVariable\u201d content=\u201ctextOnly\u201d dt:type=\u201cstring\u201d\/>","<ElementType name=\u201cargument\u201d content=\u201celtOnly\u201d model=\u201cclosed\u201d>","<element type=\u201cname\u201d\/>","<element type=\u201crelatedStateVariable\u201d\/>","<\/ElementType>","<ElementType name=\u201cargumentList\u201d content=\u201celtOnly\u201d model=\u201cclosed\u201d>","<element type=\u201cargument\u201d minOccurs=\u201c1\u201d maxOccurs=\u201c*\u201d\/>","<\/ElementType>","<ElementType name=\u201caction\u201d content=\u201celtOnly\u201d model=\u201cclosed\u201d>","<element type=\u201cname\u201d\/>","<element type=\u201cargumentList\u201d minOccurs=\u201c0\u201d maxOccurs=\u201c*\u201d\/>","<\/ElementType>","<ElementType name=\u201cactionList\u201d content=\u201celtOnly\u201d model=\u201cclosed\u201d>","<element type=\u201caction\u201d minOccurs=\u201c0\u201d maxOccurs=\u201c*\u201d\/>","<\/ElementType>","<ElementType name=\u201cscpd\u201d content=\u201celtOnly\u201d model=\u201cclosed\u201d>","<element type=\u201cserviceStateTable\u201d\/>","<element type=\u201cactionList\u201d\/>","<\/ElementType>","<\/Schema>\n\nattribute\n","References an attribute in the new, derived language for the purposes of declaring in which elements it may appear. Like any XML element, the AttributeType element may have attributes of its own. Using the required attribute within this element indicates whether the attribute is present; optional attributes have required=no.\n\nAttributeType\n","Defines an attribute in the new, derived language. Like any XML element, the AttributeType element may have attributes of its own. Using the name attribute within this element defines the name of the attribute as it will be used in the derived language.\n\nelement\n","References an element for the purposes of declaring nesting. minOccurs attribute defines minimum number of times the element occurs; default is minOccurs=1; optional elements have minOccurs=0. maxOccurs attribute defines maximum number of times the element occurs; default is maxOccurs=1; elements that can appear one or more times have maxOccurs=*.\n\nElementType\n","Defines an element in the new, derived language. name attribute defines element name. dt:type attribute defines the data type for the value of element in the new, derived language. model attribute indicates whether elements in the new, derived language can contain elements not explicitly specified here; when only previously specific elements may be used, model=closed. content attribute indicates what content may contain; elements that contain only other elements have content=eltOnly; elements that contain only strings have content=textOnly.\n\ngroup\n","Organizes content into a group to specify a sequence. minOccurs attribute defines minimum number of times the group occurs. maxOccurs attribute defines maximum number of times the group occurs. order attribute constrains the sequence of elements; when at most one element is allowed, order=one.\n\n3.4 Control: Augmenting the UPnP Template Language\n\nAs is the case with describing devices, some properties of services are difficult to capture in the XML Schema formalism. For services in particular, it is useful to describe the effect actions have on state variables. This procedural information is awkward to describe in a declarative language like XML, so below is a recommended vocabulary for UPnP Forum working committees to use when defining service actions or for UPnP vendors to use when they wish to document the effects of extra actions.\n\nASSIGN (v, a)\n","Variable v becomes the value of argument a, i.e., v=a. v and a is the same data type. <why both this and SET?>\n\nDECREMENT (v)\n"]}}}},"Equivalent to INCREMENT (v) with allowedValueRange step treated as \u2212step.","DECREMENT_BOUNDED (v)",{"@attributes":{"id":"p-0476","num":"0000"},"ul":{"@attributes":{"id":"ul0068","list-style":"none"},"li":{"@attributes":{"id":"ul0068-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0069","list-style":"none"},"li":["Equivalent to INCREMENT_BOUNDED (v) with allowedValueRange step treated as \u2212step.\n\nDECREMENT_WRAP (v)\n","Equivalent to INCREMENT_WRAP (v) with allowedValueRange step treated as \u2212step.\n\nINCREMENT (v)\n","Variable v becomes the value of v plus allowedValueRange step, i.e., v=v+step. Equivalent to DECREMENT (v) with allowedValueRange step treated as \u2212step. v is either i4 or r8 and has an allowedValueRange definition.\n\nINCREMENT_BOUNDED (v)\n","Variable v becomes the value of v plus allowedValueRange step, i.e., v=v+step.","If step is greater than 0 and if v plus step would be greater than allowedValueRange maximum, then v becomes maximum.","If step is less than 0 and if v plus step would be less than allowedValueRange minimum, then v becomes minimum.","Equivalent to DECREMENT_BOUNDED (v) with allowedValueRange step treated as\u2014step. v is either i4 or r8 and has an allowedValueRange definition.\n\nINCREMENT_WRAP (v, c)\n","Variable v becomes the value of v plus allowedValueRange step, i.e., v=v+step.","If step is greater than 0, and if v plus step would be greater than allowedValueRange maximum, then v becomes minimum plus step minus 1, i.e., v=minimum+step\u22121; if step is 1, this simplifies to v=minimum.","If step is less than 0 and if v plus step would be less than allowedValueRange minimum, then v becomes maximum plus step plus 1, i.e., v=maximum+step+1; if step is \u22121, this simplifies to v=maximum.","Equivalent to DECREMENT_WRAP (v) with allowedValueRange step treated as \u2212step. v is either i4 or r8 and has an allowedValueRange definition.\n\nNEXT_STRING_BOUNDED (v)\n","Variable v becomes the next allowedValue after the current value of v. If v was already the last allowedValue, then v does not change. v is a string data type and has an allowedValueList definition.\n\nNEXT_STRING_WRAP (v)\n","Variable v becomes the next allowedValue after the current value of v. If v was already the last allowedValue, then v becomes the first allowedValue. v is a string data type and has an allowedValueList definition.\n\nPREV_STRING_BOUNDED (v)\n","Variable v becomes the previous allowedValue before the current value of v. If v was already the first allowedValue, then v does not change. v is a string data type and has an allowedValueList definition.\n\nPREV_STRING_WRAP (v)\n","Variable v becomes the previous allowedValue before the current value of v. If v was already the first allowedValue, then v becomes the last allowedValue. v is a string data type and has an allowedValueList definition.\n\nSET (v, c)\n"]}}}},"Variable v becomes the value of constant c, i.e., v=c. v and c is the same data type.","TOGGLE (v)","Variable v becomes the boolean negation of the value of v, i.e., v=NOT v. v is boolean.","3.5 Control: Retrieving a Service Description","As explained above, after a control point has discovered a device and has retrieved a device description, it may need to learn more about the services provided by the device. Nearly identical to the process for retrieving a device description, a control point may retrieve a service description using a description URL in the description (vs. discovery) message. (For details on retrieving a service description, please consult the corresponding discussion on retrieving a device description in the section on Description.)\n\n3.6 Control: Sending an Action\n\nTo send actions and receive confirmation, control points (and devices) use the following subset of the overall UPnP protocol stack. (The overall UPnP protocol stack is listed at the beginning of this document.)\n\nAt the highest layer, control and query messages contain vendor-specific information, e.g., URL for control and argument values. Moving down the stack, vendor content is supplemented by information from a UPnP Forum working committee, e.g., service types, action names, argument names. Messages from the layers above are hosted in UPnP-specific protocols, defined in this document. In turn, the above messages are formatted using a Simple Object Access Protocol (SOAP) header and body elements, and the messages are delivered via HTTP over TCP over IP. For reference, colors in [square brackets] above indicate which protocol defines specific header elements in the subscription messages listed below.\n\n3.6.1 Control: Messages: Request\n\nThe Simple Object Access Protocol (SOAP) defines the use of XML and HTTP for remote procedure calls. UPnP uses SOAP to deliver control messages to devices and return acknowledgement or failure codes back to control points.\n\nSOAP defines additional HTTP headers, and to ensure that these are not confused with other HTTP extensions, SOAP follows the HTTP Extension Framework and specifies a SOAP-unique URI in the MAN header and prefixes the HTTP method with M-. In this case, the method is M-POST. Using M-POST requires the HTTP server to find and understand the SOAP-unique URI and SOAP-specific headers.\n\nTo provide firewalls and proxies greater administrative flexibility, SOAP specifies that requests first be attempted without the MAN header or M-prefix. If the request is rejected with a response of \u201c405 Method Not Allowed\u201d, then a second request is sent using the MAN header and M-prefix. If that request is rejected with a response of \u201c501 Not Implemented\u201d or \u201c510 Not Extended\u201d, the request fails. (Other HTTP responses is processed according to the HTTP specification.)\n\nBelow is a listing of a control message sent using the POST method (without the MAN header) followed by an explanation of the headers and body. This is immediately followed by a listing of a control message sent using the M-POST method and MAN header.\n\nAs explained above, a control message may include an key to indicate whether the control point has received the most recent message. To include a key, the body of a control message includes two SOAP headers, one for the event subscription UUID, and one for the key itself. Both are illustrated in the listings below. The section on Eventing explains the contents of the two headers in detail.\n\nTo send a requested action to a device, a control point sends a request with method POST in the following format. Values in italics are placeholders for actual values.\n\n","Method defined by HTTP.","Path Control URL",{"@attributes":{"id":"p-0481","num":"0000"},"ul":{"@attributes":{"id":"ul0072","list-style":"none"},"li":{"@attributes":{"id":"ul0072-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0073","list-style":"none"},"li":"Path component of URL for control for this service (controlURL sub element of service element of device description). Single, relative URL.\n\nHTTP\/1.1\n"}}}},"HTTP version.","Headers","HOST",{"@attributes":{"id":"p-0483","num":"0000"},"ul":{"@attributes":{"id":"ul0074","list-style":"none"},"li":{"@attributes":{"id":"ul0074-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0075","list-style":"none"},"li":"Domain name or IP address and optional port components of URL for control for this service (controlURL sub element of service element of device description). If the port is empty or not given, port 80 is assumed.\n\nACCEPT-LANGUAGE\n"}}}},"(No ACCEPT-LANGUAGE header is used in control messages.)","CONTENT-LENGTH","Length of body in bytes. Integer.","CONTENT-TYPE","Is text\/xlm.","MAN","(No MAN header in request with method POST.)","SOAPMETHODNAME",{"@attributes":{"id":"p-0488","num":"0000"},"ul":{"@attributes":{"id":"ul0076","list-style":"none"},"li":{"@attributes":{"id":"ul0076-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0077","list-style":"none"},"li":["Starts with urn:schemas-upnp-org:service:, followed by UPnP standard service type, colon, service version, hash mark, and name of action to be invoked. If used in a request with method M-POST, header name is qualified with name space defined in MAN header. Single URI.\n\nBody\n\nSOAP:Envelope\n","xmlns namespace attribute is \u201curn:schemas-xmlsoap-org:soap.v1\u201d. All SOAP-defined elements is qualified with this namespace. Contains the following sub elements:\n\nSOAP:Header\n"]}}}},"Is qualified with SOAP namespace. Contains the following sub elements:","SID",{"@attributes":{"id":"p-0490","num":"0000"},"ul":{"@attributes":{"id":"ul0078","list-style":"none"},"li":{"@attributes":{"id":"ul0078-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0079","list-style":"none"},"li":"Subscription Identifier. Unique identifier for this event subscription. (cf. section on Eventing.) xmlns namespace attribute is urn:schemas-upnp-org:control:1:0. Single URI.\n\nSequenceNumber\n"}}}},"Most recent event key received by control point from service. (cf. section on Eventing.)","Is qualified with SID namespace. Single integer.","SOAP:Body","Is qualified with SOAP namespace. Contains the following sub element:","actionName",{"@attributes":{"id":"p-0494","num":"0000"},"ul":{"@attributes":{"id":"ul0080","list-style":"none"},"li":{"@attributes":{"id":"ul0080-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0081","list-style":"none"},"li":["Name of element is name of action control point is requesting service to perform. xmlns namespace attribute starts with urn:schemas-upnp-org:service:, followed by UPnP standard service type, colon, and service version. Contains the following, ordered sub element(s):\n\nargumentName\n","Repeat once for each argument. Value to be passed to action. (Element name not qualified by a namespace; element nesting context is sufficient.) Single data type as defined by UPnP Service Template.\n\nIf a request with POST is rejected with a response of \u201c405 Method Not Allowed\u201d, then a control point sends a second request with method M-POST and MAN in the following format. Values in italics are placeholders for actual values.\n","M-POST path of control URL HTTP\/1.1","HOST: host of control URL:port of control URL","CONTENT-LENGTH: bytes in body","CONTENT-TYPE: text\/xml","MAN: \u201curn:schemas-xmlsoap-org:soap.v1\u201d; ns=01","01-SOAPMETHODNAME: urn:schemas-upnp-org:service:serviceType:serviceVersion#actionName\n\n(Message body for request with method M-POST is the same as body for request with method POST. See above.)\n\nRequest Line\n\nM-POST\n"]}}}},"Method defined by HTTP Extension Framework.","Path of Control URL",{"@attributes":{"id":"p-0496","num":"0000"},"ul":{"@attributes":{"id":"ul0082","list-style":"none"},"li":{"@attributes":{"id":"ul0082-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0083","list-style":"none"},"li":"Path component of URL for control for this service (controlURL sub element of service element of device description). Single, relative URL.\n\nHTTP\/1.1\n"}}}},"HTTP version.","Headers","HOST",{"@attributes":{"id":"p-0498","num":"0000"},"ul":{"@attributes":{"id":"ul0084","list-style":"none"},"li":{"@attributes":{"id":"ul0084-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0085","list-style":"none"},"li":"Domain name or IP address and optional port components of URL for control for this service (controlURL sub element of service element of device description). If the port is empty or not given, port 80 is assumed.\n\nACCEPT-LANGUAGE\n"}}}},"(No ACCEPT-LANGUAGE header is used in control messages.)","CONTENT-LENGTH","Length of body in bytes. Integer.","CONTENT-TYPE","Is text\/xlm.","MAN",{"@attributes":{"id":"p-0502","num":"0000"},"ul":{"@attributes":{"id":"ul0086","list-style":"none"},"li":{"@attributes":{"id":"ul0086-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0087","list-style":"none"},"li":["Is \u201curn:schemas-xmlsoap-org:soap.v1\u201d.ns directive defines namespace (e.g., 01) for other SOAP headers (e.g., SOAPMETHODNAME).\n\nSOAPMETHODNAME\n","Starts with urn:schemas-upnp-org:service:, followed by UPnP standard service type, colon, service version, hash mark, and name of action to be invoked. If used in a request with method M-POST, header name is qualified with name space defined in MAN header. Single URI.\n\n3.6.2 Control: Messages: Response\n\nIf a service accepts an action request from a control point, the service sends a response in the following format. Values in italics are placeholders for actual values.\n","HTTP\/1.1 200 OK","CONTENT-LENGTH: bytes in body","CONTENT-TYPE: text\/xml","DATE: when response was generated","EXT:","SERVER: OS\/version, UPnP\/1.0, product\/version","<SOAP:Envelope xmlns:SOAP=\u201curn:schemas-xmlsoap-org:soap.v1\u201d>","<SOAP:Body>","<m:actionNameResponse xmlns:m=\u201curn:schemas-upnp-org:service:sType:sVers\u201d>","<return>return code<\/return>","<m:actionNameResponse>","<\/SOAP:Body>","<\/SOAP:Envelope>\n\nListed below are details for each of the headers and body elements appearing in the listing above. All header values and element names are case sensitive; values are not case sensitive except where noted. Except where noted, the order of elements is insignificant.\n\nHeaders\n\nACCEPT-LANGUAGE\n"]}}}},"(No ACCEPT-LANGUAGE header is used in control messages.)","CONTENT-LENGTH","Length of body in bytes. Integer.","CONTENT-TYPE","Is text\/xlm.","DATE","When response was generated. RFC 1123 date.","EXT","Confirms that the MAN header was understood. (Header only; no value.)","SERVER",{"@attributes":{"id":"p-0508","num":"0000"},"ul":{"@attributes":{"id":"ul0088","list-style":"none"},"li":{"@attributes":{"id":"ul0088-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0089","list-style":"none"},"li":["Concatenation of OS name, forward slash, OS version, comma, UPnP\/1.0, comma, product name, forward slash, and product version. String.\n\nBody\n\nSOAP:Envelope\n","xmlns namespace attribute is \u201curn:schemas-xmlsoap-org:soap.v1\u201d. All SOAP-defined elements is qualified with this namespace. Contains the following sub elements:\n\nSOAP:Header\n"]}}}},"(No SOAP:Header element in response to control message.)","SOAP:Body","Is qualified with SOAP namespace. Contains the following sub element:","actionNameResponse",{"@attributes":{"id":"p-0511","num":"0000"},"ul":{"@attributes":{"id":"ul0090","list-style":"none"},"li":{"@attributes":{"id":"ul0090-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0091","list-style":"none"},"li":["Name of element is action name prepended to Response. xmlns namespace attribute starts with urn:schemas-upnp-org:service:, followed by UPnP standard service type, colon, and service version. Contains the following sub element:\n\nreturn\n","(Element name not qualified by a namespace; element nesting context is sufficient.) Has one of the following values:\n\n0\n","Service accepts action request and will attempt to perform it. Legal only from services without eventing.\n\n1\n","Event key is valid. Service accepts action request and will attempt to perform it. Legal only from services with eventing.\n\nIf the service does not accept an action request from a control point, the service sends a response in the following format. Values in italics are placeholders for actual values.\n"]}}}},"HTTP\/1.1 200 OK","CONTENT-LENGTH: bytes in body","CONTENT-TYPE: text\/xml","DATE: when response was generated","EXT:","SERVER: OS\/version, UPnP\/1.0, product\/version","<SOAP:Envelope xmlns:SOAP=\u201curn: schemas-xmlsoap-org:soap.v1\u201d>","<SOAP:Body>","<SOAP:fault>","<faultcode>code for request error<\/faultcode>","<faultstring>string describing request error<\/faultstring>","<runcode>did request get to device?<\/runcode>","<\/SOAP:fault>","<\/SOAP:Body>","<\/SOAP:Envelope>","(Headers for a response when a service does not accept an action request are the same as headers for a response when a service does. See above.)","Body","SOAP:Envelope",{"@attributes":{"id":"p-0527","num":"0000"},"ul":{"@attributes":{"id":"ul0092","list-style":"none"},"li":{"@attributes":{"id":"ul0092-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0093","list-style":"none"},"li":"xmlns namespace attribute is \u201curn:schemas-xmlsoap-org:soap.v1\u201d. All SOAP-defined elements is qualified with this namespace. Contains the following sub elements:\n\nSOAP:Header\n"}}}},"(No Header element in response to control message.)","SOAP:Body","Is qualified with SOAP namespace. Contains the following sub element:","SOAP:fault","Why the service did not accept the action request. Contains the following sub elements:","faultcode",{"@attributes":{"id":"p-0531","num":"0000"},"ul":{"@attributes":{"id":"ul0094","list-style":"none"},"li":{"@attributes":{"id":"ul0094-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0095","list-style":"none"},"li":"Code identifying why service did not accept the action request. Has one of the following values:\n\n301\n"}}}},"Invalid action name, i.e., no action by that name at this service.","302",{"@attributes":{"id":"p-0533","num":"0000"},"ul":{"@attributes":{"id":"ul0096","list-style":"none"},"li":{"@attributes":{"id":"ul0096-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0097","list-style":"none"},"li":"Invalid arguments. Could be any of the following: not enough arguments, too many arguments, no argument by that name, one or more arguments are of the wrong data type.\n\n303\n"}}}},"Out of synchronization. Action request accompanied by invalid event key.","401",{"@attributes":{"id":"p-0535","num":"0000"},"ul":{"@attributes":{"id":"ul0098","list-style":"none"},"li":{"@attributes":{"id":"ul0098-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0099","list-style":"none"},"li":["Action request failed. May be returned if current state of service prevents performing action. (No guarantee that service will return a fault in such situations.)\n\nfaultstring\n","Short description for end user. Defined by a UPnP Forum working committee or delegated to UPnP vendor. String. Recommend<256 characters.\n\nruncode\n","Whether or not the request reached the service. Could be relevant if another system is operating as a proxy, bridge, or gateway for device and it's services. Is one of the following values:\n\n0\n"]}}}},"Maybe","1","No","2","Yes","3.7 Control: Query for Variable","In addition to sending requested actions to a service, control points may also poll the service for the value of a state variable by sending a query message. A query message may query only one state variable; multiple query messages is sent to query multiple state variables.\n\n3.7.1 Control: Messages: Query\n\nTo query for the value of a state variable, a control point sends a request in the following format. Values in italics are placeholders for actual values.\n","POST path of control URL HTTP\/1.1","HOST: host of control URL:port of control URL","CONTENT-LENGTH: bytes in body","CONTENT-TYPE: text\/xml","SOAPMETHODNAME: urn:schemas-upnp-org:control:1:0#QueryStateVariable","<SOAP:Envelope xmlns:SOAP=\u201curn:schemas-xmlsoap-org:soap.v1\u201d>","<SOAP:Body>","<m:QueryStateVariable xmlns:m=\u201curn:schemas-upnp-org:control:1:0\u201d>","<m:varName>variableName<\/m:varName>","<\/m:QueryStateVariable>","<\/SOAP:Body>","<\/SOAP:Envelope>","Listed below are details for the request line, headers, and body elements appearing in the listing above. All header values and element names are case sensitive; values are not case sensitive except where noted. Except where noted, the order of elements is insignificant.\n\nRequest Line\n\nPOST\n","Method defined by HTTP.","Path of Control URL",{"@attributes":{"id":"p-0554","num":"0000"},"ul":{"@attributes":{"id":"ul0100","list-style":"none"},"li":{"@attributes":{"id":"ul0100-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0101","list-style":"none"},"li":"Path component of URL for control for this service (controlURL sub element of service element of device description). Single, relative URL.\n\nHTTP\/1.1\n"}}}},"HTTP version.","Headers","HOST",{"@attributes":{"id":"p-0556","num":"0000"},"ul":{"@attributes":{"id":"ul0102","list-style":"none"},"li":{"@attributes":{"id":"ul0102-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0103","list-style":"none"},"li":"Domain name or IP address and optional port components of URL for control for this service (controlURL sub element of service element of device description). If the port is empty or not given, port 80 is assumed.\n\nACCEPT-LANGUAGE\n"}}}},"(No ACCEPT-LANGUAGE header is used in control messages.)","CONTENT-LENGTH","Length of body in bytes. Integer.","CONTENT-TYPE","Is text\/xlm.","MAN","(No MAN header in request with method POST.)","SOAPMETHODNAME",{"@attributes":{"id":"p-0561","num":"0000"},"ul":{"@attributes":{"id":"ul0104","list-style":"none"},"li":{"@attributes":{"id":"ul0104-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0105","list-style":"none"},"li":"Is urn:schemas-upnp-org:control:1:0#QueryStateVariable. If used in a request with method M-POST, header name is qualified with name space defined in MAN header. Single URI.\n\nBody\n"}}}},"SOAP:Envelope\n\n","(No SOAP:Header is used to query the value of a variable.)","SOAP:Body","Is qualified with SOAP namespace. Contains the following sub element:","QueryStateVariable",{"@attributes":{"id":"p-0565","num":"0000"},"ul":{"@attributes":{"id":"ul0108","list-style":"none"},"li":{"@attributes":{"id":"ul0108-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0109","list-style":"none"},"li":["Action name. xmlns namespace attribute is urn:schemas-upnp-org:control:1:0. Contains the following, ordered sub element(s):\n\nvarName\n","Variable name. Is qualified by QueryStateVariable namespace. Values is name of state variable to be queried. String.\n\nIf a request with POST is rejected with a response of \u201c405 Method Not Allowed\u201d, then a control point sends a second request with method M-POST and MAN as explained above.\n\n3.7.2 Control: Messages: Response\n\nTo answer a query for the value of a state variable, the service sends a response in the following format. Values in italics are placeholders for actual vaules.\n"]}}}},"HTTP\/1.1 200 OK","CONTENT-LENGTH: bytes in body","CONTENT-TYPE: text\/xml","DATE: when response was generated","EXT:","SERVER: OS\/version, UPnP\/1.0, product\/version","<SOAP:Envelope xmlns:SOAP=\u201curn:schemas-xmlsoap-org:soap.v1\u201d>","<SOAP:Body>","<m:QueryStateVariableResponse xmlns:m=\u201curn:schemas-upnp-org:control:1:0\u201d>","<return>variable value<\/return>","<\/m:QueryStateVariableResponse>","<\/SOAP:Body>","<\/SOAP:Envelope>","Listed below are details for each of the headers and body elements appearing in the listing above. All header values and element names are case sensitive; values are not case sensitive except where noted. Except where noted, the order of elements is insignificant.\n\nHeaders\n\nACCEPT-LANGUAGE\n","(No ACCEPT-LANGUAGE header is used in control messages.)","CONTENT-LENGTH","Length of body in bytes. Integer.","CONTENT-TYPE","Is text\/xlm.","DATE","When response was generated. RFC 1123 date.","EXT","Confirms that the MAN header was understood. (Header only; no value.)","SERVER",{"@attributes":{"id":"p-0585","num":"0000"},"ul":{"@attributes":{"id":"ul0110","list-style":"none"},"li":{"@attributes":{"id":"ul0110-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0111","list-style":"none"},"li":["Concatenation of OS name, forward slash, OS version, comma, UPnP\/1.0, comma, product name, forward slash, and product version. String.\n\nBody\n\nSOAP:Envelope\n","xmlns namespace attribute is \u201curn:schemas-xmlsoap-org:soap.v1\u201d. All SOAP-defined elements is qualified with this namespace. Contains the following sub elements:\n\nSOAP:Header\n"]}}}},"(No SOAP:Header is used to query the value of a variable.)","SOAP:Body","Is qualified with SOAP namespace. Contains the following sub element:","QueryStateVariableResponse",{"@attributes":{"id":"p-0588","num":"0000"},"ul":{"@attributes":{"id":"ul0112","list-style":"none"},"li":{"@attributes":{"id":"ul0112-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0113","list-style":"none"},"li":["xmlns namespace attribute is urn:schemas-upnp-org:control:1:0. Contains the following sub element:\n\nreturn\n","(Element name not qualified by a namespace; element nesting context is sufficient.) Value is current value of the state variable specified in varName element in request.\n\nIf the service cannot provide a value for the request, then the service sends a response in the following format. Values in italics are placeholders for actual values.\n"]}}}},"HTTP\/1.1 200 OK","CONTENT-LENGTH: bytes in body","CONTENT-TYPE: text\/xml","DATE: when response was generated","EXT:","SERVER: OS\/version, UPnP\/1.0, product\/version","<SOAP:Envelope xmlns:SOAP=\u201curn:schemas-xmlsoap-org:soap.v1\u201d>","<SOAP:Body>","<SOAP:fault>","<faultcode>code for request error<\/faultcode>","<faultstring>string describing request error<\/faultstring>","<runcode>did request get to device?<\/runcode>","<\/SOAP:fault>","<\/SOAP:Body>","<\/SOAP:Envelope>","(Headers for a response when a service cannot provide a value are the same as headers for a response when a service does. See above.)","Body","SOAP:Envelope",{"@attributes":{"id":"p-0604","num":"0000"},"ul":{"@attributes":{"id":"ul0114","list-style":"none"},"li":{"@attributes":{"id":"ul0114-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0115","list-style":"none"},"li":"xmlns namespace attribute is \u201curn:schemas-xmlsoap-org:soap.v1\u201d. All SOAP-defined elements is qualified with this namespace. Contains the following sub elements:\n\nSOAP:Header\n"}}}},"(No Header element in response to control message.)","SOAP:Body","Is qualified with SOAP namespace. Contains the following sub element:","SOAP:fault","Why the service did not accept the action request. Contains the following sub elements:","faultcode",{"@attributes":{"id":"p-0608","num":"0000"},"ul":{"@attributes":{"id":"ul0116","list-style":"none"},"li":{"@attributes":{"id":"ul0116-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0117","list-style":"none"},"li":"Code identifying why service did not accept the action request. Has one of the following values:\n\n304\n"}}}},"Invalid variable name, i.e., no state variable by that name at this service.","faultstring",{"@attributes":{"id":"p-0610","num":"0000"},"ul":{"@attributes":{"id":"ul0118","list-style":"none"},"li":{"@attributes":{"id":"ul0118-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0119","list-style":"none"},"li":["Short description for end user. Defined by a UPnP Forum working committee or delegated to UPnP vendor. String. Recommend<256 characters.\n\nruncode\n","Whether or not the request reached the service. Could be relevant if another system is operating as a proxy, bridge, or gateway for device and it's services. Is one of the following values:"]}}}},{"@attributes":{"id":"p-0611","num":"0956"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"133pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0",{}]},{"entry":[{},"Maybe"]},{"entry":"1"},{"entry":[{},"No"]},{"entry":"2"},{"entry":[{},"Yes"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":[{},{},{},{},{},{},{},{},{},{},{},{},{}],"ul":{"@attributes":{"id":"ul0120","list-style":"none"},"li":{"@attributes":{"id":"ul0120-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0121","list-style":"none"},"li":"Is unique over the lifetime of the subscription, however long or short that may be. Generated by service in response to subscription message. Recommend universally-unique identifiers to ensure uniqueness. Single URI.\n\ndelivery URL for event messages\n"}}}},"Provided by control point in subscription message. Single URL.","event key",{"@attributes":{"id":"p-0613","num":"0000"},"ul":{"@attributes":{"id":"ul0122","list-style":"none"},"li":{"@attributes":{"id":"ul0122-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0123","list-style":"none"},"li":["Key is 0 for initial event message. Key is sequentially numbered for each subsequent event message; control points can verify that no event messages have been lost if the control point has received sequentially numbered event keys. Single integer.\n\nsubscription duration\n","Amount of time, or duration until subscription expires. Single integer or keyword infinite.\n\nThe service may wish to persist subscriptions across power failures. While control points can recover from complete network failure, if the problem is brief and localized to the device, reusing stored subscriptions may speed recovery.\n\nThe list of subscribers is updated via subscription, renewal, and cancellation messages explained below and event messages explained later in this section.\n\nTo subscribe to eventing for a service, a control point sends a subscription message containing a URL for the publisher, a service identifier for the publisher, and a delivery URL for event messages. The subscription message may also include a requested duration for the subscription. The URL and service identifier for the publisher come from a description message. As the section on Description explains, a description message contains a device description. A device description contains (among other things), for each service, an eventing URL (in the eventSubURL element) and a service identifier (in the serviceId element); these correspond to the URL and service identifier for the publisher, respectively. The subscription message is a request to receive all event messages. No mechanism is provided to subscribe to event messages on a variable-by-variable basis. A subscriber is sent all event messages from the service. This is one factor to be considered when designing a service.\n\nIf the subscription is accepted, the service responds with unique identifier for this subscription and a duration for this subscription. A duration is chosen that matches assumptions about how frequently devices are removed from the network; if devices are removed every few minutes, then the duration is similarly short, allowing a service to rapidly deprecate any expired subscribers; if devices are semi-permanent, then the duration is very long, minimizing the processing and traffic associated with renewing subscriptions. As soon as possible after the subscription is accepted, the service also sends the first, or initial event message to the subscriber. This message includes the names and current values for all evented variables. (The data type and range for each variable is described in a service description. The section on Control explains this in more detail.)\n\nTo keep the subscription active, a control point renews its subscription before the subscription expires by sending a renewal message. The renewal message is send to the same URL as the subscription message, but the renewal message does not include a delivery URL for event messages; instead the renewal message includes the subscription identifier. The response for a renewal message is the same as one for a subscription message.\n\nIf a subscription expires, the subscription identifier becomes invalid, and the service stops sending event messages to the control point and can clean up its list of subscribers. If the control point tries to send any message other than a subscription message, the service will reject the message because the subscription identifier is invalid. To send control messages to the service, the control point sends a subscription message and get a new subscription identifier.\n\nWhen a control point no longer needs eventing from a particular service, the control point cancels its subscription. Canceling a subscription generally reduces service, control point, and network load. If a control point is removed abruptly from the network, it might be impossible to send a cancellation message. As a fallback, the subscription will eventually expire on its own unless renewed.\n\nBelow is an explanation of the specific format of requests, responses, and errors for subscription, renewal, and cancellation messages.\n\n4.1.1 Eventing: Subscribing: SUBSCRIBE with NT and CALLBACK\n\nFor each service in a device, a description message contains an eventing URL (eventSubURL sub element of service element in the device description) and the UPnP service identifier (serviceId sub element in service element in device description). To subscribe to eventing for a particular service, a subscription message is sent to that service's eventing URL. The message contains that service's identifier as well as a delivery URL for event messages. A subscription message may also include a requested subscription duration. To subscribe to eventing for a service, a control point sends a request with method SUBSCRIBE and NT and CALLBACK headers in the following format. Values in italics are placeholders for actual values.\n"]}}}},"SUBSCRIBE publisher path HTTP\/1.1","HOST: publisher host:publisher port","CALLBACK: <delivery URL>","NT: upnp:event","TIMEOUT: Second-requested subscription duration","(No body for request with method SUBSCRIBE.)","Listed below are details for the request line and headers appearing in the listing above. All header values are case sensitive except where noted.",{"@attributes":{"id":"p-0619","num":"0966"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Request line"},{"entry":"SUBSCRIBE"},{"entry":"\u2003Method defined by GENA."},{"entry":"publisher path"},{"entry":"\u2003Path component of eventing URL (eventSubURL sub element in service"},{"entry":"\u2003element in device description). Single, relative URL."},{"entry":"HTTP\/1.1"},{"entry":"\u2003HTTP version."},{"entry":"Headers"},{"entry":"HOST"},{"entry":"\u2003Domain name or IP address and optional port components of eventing"},{"entry":"\u2003URL (eventSubURL sub element in service element in device"},{"entry":"\u2003description). If the port is missing or empty, port 80 is assumed."},{"entry":"CALLBACK"},{"entry":"\u2003Location to send event messages to. Defined by UPnP vendor. If there"},{"entry":"\u2003is more than 1 URL, when the service sends events, it will try these"},{"entry":"\u2003URLs in order until one succeeds. One or more URLs"},{"entry":"\u2003separated by angle brackets."},{"entry":"NT"},{"entry":"\u2003Notification Type. Is upnp:event."},{"entry":"SID"},{"entry":"\u2003(No SID header is used to subscribe.)"},{"entry":"TIMEOUT"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"ul":{"@attributes":{"id":"ul0124","list-style":"none"},"li":{"@attributes":{"id":"ul0124-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0125","list-style":"none"},"li":["Requested duration until subscription expires, either number of seconds or infinite.","Recommendation by a UPnP Forum working committee. Defined by UPnP vendor.","Keyword Second\u2014followed by an integer (no space) or keyword infinite.\n\nTo accept the subscription, the service assigns a unique identifier for the subscription, assigns a duration for the subscription, and sends an initial event message (explained in detail later in this section). To accept a subscription request, a service sends a response in the following format. Values in italics are placeholders for actual values.\n"]}}}},"HTTP\/1.1 200 OK","DATE: when response was generated","SERVER: OS\/version, UPnP\/1.0, product\/version","SID: uuid:subscription UUID","TIMEOUT: Second-actual subscription duration","(No body for response to a request with method SUBSCRIBE.)","Listed below are details for headers appearing in the listing above. All header values are case sensitive except where noted.",{"@attributes":{"id":"p-0625","num":"0975"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Headers"},{"entry":"DATE"},{"entry":"\u2003When response was generatd. RFC 1123 date."},{"entry":"SERVER"},{"entry":"\u2003Concatenation of OS name, forward slash, OS version, comma, UPnP\/"},{"entry":"\u20031.0, comma, product name, forward slash, and product version. String."},{"entry":"SID"},{"entry":"\u2003Subscription identifier. Is universally-unique. Begins with uuid:."},{"entry":"\u2003Defined by UPnP vendor. Single URI."},{"entry":"TIMEOUT"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"ul":{"@attributes":{"id":"ul0126","list-style":"none"},"li":{"@attributes":{"id":"ul0126-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0127","list-style":"none"},"li":["Actual duration until subscription expires, either number of seconds or infinite. Recommendation by a UPnP Forum working committee. Defined by UPnP vendor. Is >1800 seconds (30 minutes). Keyword Second\u2014followed by an integer (no space) or keyword infinite.\n\nIf a service cannot accept another event subscriber, or if there is an error with the subscription request, the service sends a response with one of the following errors.\n\nErrors\n\nIncompatible Headers\n","400 Bad Request. If SID header and one of NT or CALLBACK headers are present, the service responds with HTTP error 400 Bad Request.\n\nMissing or invalid CALLBACK\n","412 Precondition Failed. If CALLBACK header is missing or does not contain a valid HTTP URL, the service responds with HTTP error 412 Precondition Failed.\n\nUnable to accept subscription\n","5xx. If a service is not able to accept a subscription, it responds with a HTTP 500-series error code.\n\nOther errors may be returned by layers in the protocol stack below UPnP. Consult documentation on those protocols for details.\n\n4.1.2 Eventing: Renewing a Subscription: SUBSCRIBE with SID\n\nTo renew a subscription to eventing for a particular service, a renewal messages is sent to that service's eventing URL. However, unlike an initial subscription message, a renewal message does not contain either the service's identifier nor a delivery URL for event messages. Instead, the message contains the subscription identifier assigned by the service, providing an unambiguous reference to the subscription to be renewed. Like a subscription message, a renewal message may also include a requested subscription duration.\n\nThe renewal message uses the same method as the subscription message, but the two messages use a disjoint set of headers; renewal uses SID and subscription uses NT and CALLBACK. A message that includes SID and either of NT or CALLBACK headers is an error.\n\nTo renew a subscription to eventing for a service, a control point sends a request with method SUBSCRIBE and SID header in the following format. Values in italics are placeholders for actual values.\n"]}}}},"SUBSCRIBE publisher path HTTP\/1.1","HOST: publisher host:publisher port","SID: uuid:subscription UUID","TIMEOUT: Second-requested subscription duration","(No body for method with request SUBSCRIBE.)","Listed below are details for the request line and headers appearing in the listing above. All header values are case sensitive except where noted.",{"@attributes":{"id":"p-0630","num":"0984"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Request line"},{"entry":"SUBSCRIBE"},{"entry":"\u2003Method defined by GENA."},{"entry":"publisher path"},{"entry":"\u2003Path component of eventing URL (eventSubURL sub element in service"},{"entry":"\u2003element in device description). Single, relative URL."},{"entry":"HTTP\/1.1"},{"entry":"\u2003HTTP version."},{"entry":"Headers"},{"entry":"HOST"},{"entry":"\u2003Domain name or IP address and optional port components of eventing"},{"entry":"\u2003URL (eventSubURL sub element in service element in device"},{"entry":"\u2003description). If the port is missing or empty, port 80 is assumed."},{"entry":"CALLBACK"},{"entry":"\u2003(No CALLBACK header is used to renew an event subscription.)"},{"entry":"NT"},{"entry":"\u2003(No NT header is used to renew an event subscription.)"},{"entry":"SID"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"ul":{"@attributes":{"id":"ul0128","list-style":"none"},"li":{"@attributes":{"id":"ul0128-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0129","list-style":"none"},"li":["Subscription identifier. Is the subscription identifier assigned by service in response to subscription request. Is universally-unique. Begins with uuid:. Defined by UPnP vendor. Single URI.\n\nTIMEOUT\n","Requested duration until subscription expires, either number of seconds or infinite.","Recommendation by a UPnP Forum working committee. Defined by UPnP vendor.","Keyword Second\u2014followed by an integer (no space) or keyword infinite.\n\nTo accept a renewal, the service reassigns a duration for the subscription. (No initial event message. See below.) To accept a renewal, a service sends a response in the same format as a response to a request for a new subscription.\n\nIf a service cannot accept the renewal, or if there is an error with the renewal request, the service sends a response with one of the following errors.\n\nErrors\n\nIncompatible headers\n","400 Bad Request. If SID header and one of NT or CALLBACK headers are present, the service responds with HTTP error 400 Bad Request.\n\nInvalid SID\n","404 Not Found. If a SID does not correspond to a known, un-expired subscription, the service responds with HTTP error 404 Not Found.\n\nMissing SID\n","412 Precondition Failed. If the SID header is missing or empty, the service responds with HTTP error 412 Precondition Failed.\n\nUnable to accept renewal\n","5xx. If the service is not able to accept a renewal, it responds with a HTTP 500-series error code.\n\nOther errors may be returned by layers in the protocol stack below UPnP. Consult documentation on those protocols for details.\n\n4.1.3 Eventing: Canceling a Subscription: UNSUBSCRIBE\n\nWhen eventing is no longer needed from a particular service, a cancellation message is sent to that service's eventing URL. The message contains the subscription identifier. Canceling a subscription generally reduces service, control point, and network load. If a control point is removed abruptly from the network, it might be impossible to send a cancellation message. As a fallback, the subscription will eventually expire on its own unless renewed.\n\nTo cancel a subscription to eventing for a service, a control point sends a request with method UNSUBSCRIBE in the following format. Values in italics are placeholders for actual values.\n"]}}}},"UNSUBSCRIBE publisher path HTTP\/1.1","HOST: publisher host:publisher port","SID: uuid:subscription UUID","(No body for request with method UNSUBSCRIBE.)","Listed below are details for the request line and headers appearing in the listing above. All header values are case sensitive except where noted.","Request Line","UNSUBSCRIBE","Method defined by GENA.","Publisher Path",{"@attributes":{"id":"p-0635","num":"0000"},"ul":{"@attributes":{"id":"ul0130","list-style":"none"},"li":{"@attributes":{"id":"ul0130-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0131","list-style":"none"},"li":"Path component of eventing URL (eventSubURL sub element in service element in device description). Single, relative URL.\n\nHTTP\/1.1\n"}}}},"HTTP version.","Headers","HOST",{"@attributes":{"id":"p-0637","num":"0000"},"ul":{"@attributes":{"id":"ul0132","list-style":"none"},"li":{"@attributes":{"id":"ul0132-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0133","list-style":"none"},"li":"Domain name or IP address and optional port components of eventing URL (eventSubURL sub element in service element in device description). If the port is missing or empty, port 80 is assumed.\n\nCALLBACK\n"}}}},"(No CALLBACK header is used to cancel an event subscription.)","NT","(No NT header is used to cancel an event subscription.)","SID",{"@attributes":{"id":"p-0640","num":"0000"},"ul":{"@attributes":{"id":"ul0134","list-style":"none"},"li":{"@attributes":{"id":"ul0134-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0135","list-style":"none"},"li":"Subscription identifier. Is the subscription identifier assigned by service in response to subscription request. Is universally-unique. Begins with uuid:. Defined by UPnP vendor. Single URI.\n\nTIMEOUT\n"}}}},"(No TIMEOUT header is used to cancel an event subscription.)","To cancel a subscription, a service sends a response in the following format. Values in italics are placeholders for actual values.","HTTP\/1.1 200 OK","If there is an error with the cancellation request, the service sends a response with one of the following errors.","Errors","Incompatible headers",{"@attributes":{"id":"p-0643","num":"0000"},"ul":{"@attributes":{"id":"ul0136","list-style":"none"},"li":{"@attributes":{"id":"ul0136-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0137","list-style":"none"},"li":["400 Bad Request. If SID header and one of NT or CALLBACK headers are present, the service responds with HTTP error 400 Bad Request.\n\nInvalid SID\n","404 Not Found. If a SID does not correspond to a known, un-expired subscription, the service responds with HTTP error 404 Not Found.\n\nMissing SID\n","412 Precondition Failed. If the SID header is missing or empty, the service responds with HTTP error 412 Precondition Failed.\n\nOther errors may be returned by layers in the protocol stack below UPnP. Consult documentation on those protocols for details.\n\n4.2 Eventing: Event Messages\n\nA service publishes changes to its state variables by sending event messages. These messages contain the names of one or more state variables and the current value of those variables. Event messages is sent as soon as possible to get accurate information about the service to control points and allow control points to display a responsive user interface. If the value of more than one variable is changing at the same time, the service bundles these changes into a single event message to reduce processing and network traffic.\n\nAs explained above, an initial event message is sent when a control point first subscribes; this event message contains the names and values for all evented variables and allows the subscriber to initialize its model of the state of the service. This message is sent as soon as possible after the service accepts a subscription.\n\nEvent messages are tagged with an event key to detect a race condition between event messages headed for control points and control messages headed for a device. A separate event key is maintained by the service for each subscription to facilitate error detection (as explained below). The event key for a subscription is initialized to 0 when the service sends the initial event message. For each subsequent event message, the service increments the event key for a subscription, and includes that updated key in the event message. Any implementation of event keys handles overflow and wrap the event key back to 1 (not 0). Control point also handles this special case when the next event key is not an increment of the previous key.\n\nIf there is no response from a control point to the event message, the service continues to send event messages to the control point until the subscription expires.\n\nTo repair an event subscription, e.g., if a control point has missed one or more event messages, a control point unsubscribes and re-subscribes. By doing so, the control point will get a new subscription identifier, a new initial event message, and a new event key. With these, the control point can resume sending successful control messages to the service.\n\n4.2.1 Eventing: Event Messages: NOTIFY\n\nTo send an event message, a service sends a request with method NOTIFY in the following format. Values in italics below are placeholders for actual values.\n"]}}}},"NOTIFY delivery path HTTP\/1.1","HOST: delivery host:delivery port","CONTENT-TYPE: text\/xml","CONTENT-LENGTH: bytes in body","NT: upnp:event","NTS: upnp:propchange","SID: uuid:subscription UUID","SEQ: event key","<e:propertyset xmlns:e=\u201curn:schemas-upnp-org:event:1:0\u201d>","<e:property>","<variableName>new value<variableName>","<\/e:property>","Other variable names and values (if any) go here.","<\/e:propertyset>","Listed below are details for the request line, headers, and body elements appearing in the listing above. All header values are case sensitive except where noted. All body elements and attributes are case sensitive; body values are not case sensitive except where noted. Except where noted, the order of elements is insignificant.\n\nRequest Line\n\nNOTIFY\n","Method defined by GENA.","Delivery Path",{"@attributes":{"id":"p-0660","num":"0000"},"ul":{"@attributes":{"id":"ul0138","list-style":"none"},"li":{"@attributes":{"id":"ul0138-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0139","list-style":"none"},"li":"Path component of delivery URL (CALLBACK header in subscription message). Destination for event message. Single, relative URL.\n\nHTTP\/1.1\n"}}}},"HTTP version.","Headers","HOST",{"@attributes":{"id":"p-0662","num":"0000"},"ul":{"@attributes":{"id":"ul0140","list-style":"none"},"li":{"@attributes":{"id":"ul0140-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0141","list-style":"none"},"li":"Domain name or IP address and optional port components of delivery URL (CALLBACK header in subscription message). If the port is missing or empty, port 80 is assumed.\n\nCONTENT-LENGTH\n"}}}},"Length of body in bytes. Integer.","CONTENT-TYPE","Is text\/xml.","NT","Notification Type. Is upnp:event.","NTS","Notification Sub Type. Is upnp:propchange.","SID",{"@attributes":{"id":"p-0667","num":"0000"},"ul":{"@attributes":{"id":"ul0142","list-style":"none"},"li":{"@attributes":{"id":"ul0142-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0143","list-style":"none"},"li":["Subscription identifier. Is universally unique. Begins with uuid:. Defined by UPnP vendor. Single URI.\n\nSEQ\n","Event key. Is 0 for initial event message. Is incremented by 1 for each event message sent to a particular subscriber. Is 8 bytes. Single integer.\n\nBody\n\npropertyset\n","xmlns namespace attribute is urn:schemas-upnp-org:event:1:0. All sub elements is qualified with this namespace. Contains the following sub element.\n\nproperty\n","Repeat once for each variable name and value in the event message. Is qualified by propertyset namespace. Contains the following sub element.\n\nvariableName\n","Element is name of a state variable that changed (name sub element of stateVariable element in service description). Is qualified by propertyset namespace. Values is the new value for this state variable. Single data type as specified by UPnP Service Template.\n\nFor future extensibility, when processing XML like the listing above, devices and control points ignore any unknown elements and any sub elements or content as specified by the Flexible XML Processing Profile (FXPP).\n\nTo acknowledge receipt of this event message, a control point responds in the following format.\n"]}}}},"HTTP\/1.1 200 OK","(No body for a request with method NOTIFY.)","If there is an error with the event message, the control point responds with one of the following errors.","Errors","Missing SID",{"@attributes":{"id":"p-0669","num":"0000"},"ul":{"@attributes":{"id":"ul0144","list-style":"none"},"li":{"@attributes":{"id":"ul0144-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0145","list-style":"none"},"li":["412 Precondition Failed. If the SID header is missing or empty, the control point responds with HTTP error 412 Precondition Failed.\n\nInvalid SID\n","412 Precondition Failed. If a SID does not correspond to a known subscription, the control point responds with HTTP error 412 Precondition Failed. (Service terminates this SID when it receives this error response.)\n\nMissing NT or NTS Header\n","400 Bad Request. If the NT or NTS header is missing, the control point responds with HTTP error 400 Bad Request.\n\nInvalid NT or NTS header\n","(200 K. No error. If NT or NTS header is invalid, the control point ignores it and respond with HTTP 200 K.)\n\nOther errors may be returned by layers in the protocol stack below UPnP. Consult documentation on those protocols for details.\n\n4.3 Eventing: UPnP Template Language for Eventing\n\nThe UPnP Template Language defines well-formed templates for devices and services. To a lesser extent, it also provides a template for the body of event messages. The section on Description explains the UPnP Template Language as it pertains to devices, and the section on Control explains the UPnP Template Language as it pertains to services. As explained in those sections, the UPnP Template Language is written in XML syntax and is derived from XML Schema (Part 1: Structures, Part 2: Datatypes). Below is a listing of this language as it pertains to eventing. The elements it defines are used in event messages; they are colored green here, and they are colored green in the listing above. Below is where these elements are defined (though it is a minimal definition); above is where they are used.\n\nImmediately following this is a brief explanation of the XML Schema elements, attributes, and values used. The reference to XML Schema at the end of this section has further details.\n"]}}}},{"@attributes":{"id":"p-0670","num":"1041"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"UPnP Template Language for eventing"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003<?xml version\u201c1.0\u201d ?>"},{"entry":"\u2003<Schema name=\u201curn:schemas-upnp-org:event:1:0\u201d"},{"entry":"\u2003xmlns=\u201curn:schemas-microsoft-com:xml-data\u201d"},{"entry":"\u2003xmlns:dt=\u201curn:schemas-microsoft-com:datatypes\u201d>"},{"entry":"\u2003<ElementType name=\u201cpropertyset\u201d content=\u201celtOnly\u201d>"},{"entry":"\u2003<element type=\u201cproperty\u201d maxOccurs=\u201c*\u201d \/>"},{"entry":"\u2003<\/ElementType>"},{"entry":"\u2003<ElementType name=\u201cproperty\u201d content=\u201celtOnly\u201d model=\u201copen\u201d \/>"},{"entry":"\u2003<\/Schema>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{},"ul":{"@attributes":{"id":"ul0146","list-style":"none"},"li":{"@attributes":{"id":"ul0146-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0147","list-style":"none"},"li":["References an element for the purposes of declaring nesting. maxOccurs attribute defines maximum number of times the element occurs; default is maxOccurs=1; elements that can appear one or more times have maxOccurs=*.\n\nElementType\n","Defines an element in the new, derived language. name attribute defines element name. model attribute indicates whether elements in the new, derived language can contain elements not explicitly specified here; when only unspecified sub elements may be included, model=open. content attribute indicates what content may contain; elements that contain only other elements have content=eltOnly.\n\nAs explained in the section on Control, the UPnP Template Language for services also specifies a sendEvents attribute for a state variable. The default value for this attribute is yes. To denote that a state variable is evented, the value of this attribute is yes (or the attribute is omitted) in a service description; to denote that a state variable is non-evented, the value is no. Note that if all of a service's state variables are non-evented, the service has nothing to publish, and control points cannot subscribe and will not receive event messages from the service.\n\n4.4 Eventing: Augmenting the UPnP Template Language\n\nIt is useful to augment the description of devices and services with annotations that are not captured in the UPnP Template Language. To a lesser extent, there is value in these annotations to capture event filtering, or moderation.\n\nAs explained above, some state variables may change value too rapidly for eventing to be useful. Below is a recommended vocabulary for UPnP Forum working committees or UPnP vendors to document moderation in the number of event messages sent due to changes in a variables value.\n\nmaximumRate=n\n","Optional. State variable v will not be part of an event message more often than n seconds. If v is the only variable changing, then an event message will not be generated more often than every n seconds. If v ceases to change after an event message has been sent but before n seconds have transpired, an event message is sent with the new value of v. Recommended for variables that model continuously changing properties. Single integer.\n\nminimumDelta=n\n","Optional. State variable v will not be part of an event message unless its value has changed by more than n*allowedValueRange step since the last time an event message was sent that included v, e.g., unless v has been incremented n times. (cf. INCREMENT, INCREMENT_BOUNDED, and INCREMENT_WRAP explained in the section on Control.) Only defined variables with number and real data type. Recommended for variables that model counters. Single integer.\n\n5. Presentation\n\nPresentation is Step 5 in UPnP networking. Presentation comes after discovery (Step 1) where control points find interesting device(s), and after description (Step 2) where control points learn about device capabilities. Presentation exposes an HTML-based user interface for controlling and\/or viewing device status. Presentation is complementary to control (Step 3) where control points send actions to devices, and eventing (Step 4) where control points listen to state changes in device(s).\n\nAfter a control point has (1) discovered a device and (2) retrieved a description of the device, the control point is ready to begin presentation. If a device has a URL for presentation, then the control point can retrieve a page from this URL, load the page into a browser, and depending on the capabilities of the page, allow a user to control the device and\/or view device status. The degree to which each of these can be accomplished depends on the specific capabilities of the presentation page and device.\n\nThe URL for presentation is contained within the presentation URL element in the device description. The device description is delivered via a description message. The section on Description explains the device description and description messages in detail.\n\nRetrieving a presentation page is a simple HTTP-based process and uses the following subset of the overall UPnP protocol stack. (The overall UPnP protocol stack is listed at the beginning of this document.)\n\nAt the highest layer, the presentation page is specified by a UPnP vendor. Moving down the stack, the UPnP Device Architecture specifies that this page be written in HTML. The page is delivered via HTTP over TCP over IP. For reference, colors in [square brackets] are included for consistency with other sections in this document.\n\nTo retrieve a presentation page, the control point issues an HTTP GET request to the presentation URL, and the device returns a presentation page.\n\nUnlike the UPnP Device and Service Templates, and standard device and service types, the capabilities of the presentation page are completely specified by the UPnP vendor. The presentation page is not under the auspices of a UPnP Forum working committee. The page is an HTML page; it is version HTML 3.0 or later. However, other design aspects are left to the vendor to specify. This includes, but is not limited to, all capabilities of the control point's browser, scripting language or browser plug-ins used, and means of interacting with the device. To implement a presentation page, a UPnP vendor may wish to use UPnP mechanisms for control and\/or eventing, leveraging the device's existing capabilities but is not constrained to do so.\n"]}}}},"action",{"@attributes":{"id":"p-0671","num":"0000"},"ul":{"@attributes":{"id":"ul0148","list-style":"none"},"li":{"@attributes":{"id":"ul0148-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0149","list-style":"none"},"li":"Command exposed by a service. Takes one or more arguments but does not return values. For more information, see section on Control.\n\nargument\n"}}}},"Parameter for action exposed by a service. For more information, see section on Control.","control point",{"@attributes":{"id":"p-0673","num":"0000"},"ul":{"@attributes":{"id":"ul0150","list-style":"none"},"li":{"@attributes":{"id":"ul0150-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0151","list-style":"none"},"li":["Retrieves device and service descriptions, sends actions to services, polls for service state variables, and receives events from services.\n\ndevice\n","Logical device. A container. May embed other logical devices. Embeds one or more services. For more information, see section on Description.\n\ndevice definition\n","Formal definition of a logical device, expressed in the UPnP Template Language. Written in XML syntax. Specified by a UPnP vendor by filling in the placeholders in a UPnP Device Template, including, e.g., manufacturer name, model name, model number, serial number, and URLs for control, eventing, and presentation. For more information, see section on Description.\n\ndevice type\n","Standard device types are denoted by urn:schemas-upnp-org:device: followed by a unique name assigned by a UPnP Forum working committee. One-to-one relationship with UPnP Device Templates. UPnP vendors may specify additional device types; these are denoted by urn:domain-name:device: followed by a unique name assigned by the vendor, where domain-name is a domain name registered to the vendor. For more information, see section on Description.\n\nevent\n","Notification of one or more changes in state variables exposed by a service. For more information, see section on Eventing.\n\nroot device\n","A logical device that is not embedded in any other logical device. For more information, see section on Description.\n\nservice\n","Logical functional unit. Exposes actions and models the state of a physical device with state variables. For more information, see section on Control.\n\nservice definition\n","Formal definition of a logical service, expressed in the UPnP Template language. Written in XML syntax. Specified by a UPnP vendor by filling in any placeholders in a UPnP Service Template. (Was SCPD.) For more information, see section on Control.\n\nservice type\n","Standard service types are denoted by urn:schemas-upnp-org:service: followed by a unique name assigned by a UPnP forum working committee, colon, and a version number. One-to-one relationship with UPnP Service Templates. UPnP vendors may specify additional services; these are denoted by urn:domain-name:service: followed by a unique name assigned by the vendor, colon, and a version number, where domain-name is a domain name registered to the vendor. For more information, see section on Description.\n\nSOAP\n","Simple Object Access Protocol. A remote-procedure call mechanism based on XML that sends commands and receives values over HTTP. For more information, see section on Control.\n\nSSDP\n","Simple Service Discovery Protocol. A multicast discovery and search mechanism that uses a multicast variant of HTTP over UDP. For more information, see section on Discovery.\n\nstate variable\n","Single facet of a model of a physical service. Exposed by a service. Has a name, data type, optional default value, optional constraints values, and may trigger events when its value changes. For more information, see section on Control."]}}}},"UPnP Device Template\n\n","Having described and illustrated the principles of our invention with reference to an illustrated embodiment, it will be recognized that the illustrated embodiment can be modified in arrangement and detail without departing from such principles. It should be understood that the programs, processes, or methods described herein are not related or limited to any particular type of computer apparatus, unless indicated otherwise. Various types of general purpose or specialized computer apparatus may be used with or perform operations in accordance with the teachings described herein. Elements of the illustrated embodiment shown in software may be implemented in hardware and vice versa.","In view of the many possible embodiments to which the principles of our invention may be applied, it should be recognized that the detailed embodiments are illustrative only and should not be taken as limiting the scope of our invention. Rather, we claim as our invention all such embodiments as may come within the scope and spirit of the following claims and equivalents thereto."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIGS. 1 and 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 7","FIG. 3"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 8","FIG. 7","FIG. 3"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 9","FIG. 7"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIGS. 10 and 11","FIG. 3"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 12","FIG. 3"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 13","FIG. 3"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 14","FIG. 3"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 15","FIG. 3"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 16","FIG. 3"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIGS. 17 and 18","FIG. 3"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 19","FIG. 3"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 20","FIG. 19"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 21","FIG. 3"]},{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 22","FIG. 21","FIG. 3"]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 23","FIG. 22"]},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 24","FIG. 22"]},{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 25","FIG. 22"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 26","FIG. 3"]},{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 27","FIG. 21","FIG. 22","FIG. 3"]},{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIGS. 28 through 40","FIG. 9"]}]},"DETDESC":[{},{}]}
