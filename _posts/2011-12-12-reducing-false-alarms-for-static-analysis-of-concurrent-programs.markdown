---
title: Reducing false alarms for static analysis of concurrent programs
abstract: The claimed subject matter provides a method for performing a static analysis of concurrent programs. The method includes determining that a static analysis of the first concurrent program generates a warning for an input. The method also includes determining whether a static analysis of the second concurrent program generates the warning for the input. The method further includes removing the warning if the static analysis of the second concurrent program generates the warning.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08793664&OS=08793664&RS=08793664
owner: Microsoft Corporation
number: 08793664
owner_city: Redmond
owner_country: US
publication_date: 20111212
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["Static analysis is an approach to testing computer software that uses automation to reduce costs of traditional testing processes. Typically, a testing process involves running executable code, measuring results, etc. However, in static analysis, bugs are detected in source code without actually having a computer processor execute the code. Instead, a static analysis checker analyzes the code to find bugs, or to prove their absence. Static analysis checkers generate warnings to mark the potential bugs. In some approaches, the user provides a test harness that \u201cinvokes\u201d the programs to be analyzed. The test harness is a piece of code that sets up required preconditions for the program and exercises a particular test scenario. Because the source code is not actually executed, \u201cinvoking\u201d a program involves a simulated execution by the static analysis checker.","However, the test harness may lead to false alarms in the static analysis itself. One reason for this difficulty is that many programs have undocumented preconditions that an underspecified test harness may not specify. For instance, before invoking a read operation on a file, the program may assume the file is opened. Unless this precondition is satisfied by the test harness, the read operation may fail, causing the static analysis checker to generate a warning. However, reporting this warning to the user may hinder the testing process because the warning results from an incompleteness in the test harness, not a bug in the source code. These types of warnings are referred to herein as false alarms, or spurious warnings. The user may waste valuable resources attempting to fix false alarms, which are also a hindrance to further adoption of static analysis tools, specifically those for checking user-defined assertions in programs.","It is noted that false alarms are more broad than just the ones that happen due to underspecified harness. A false alarm is an alarm that does not correspond to a bug during the actual executions of a program. The lack of a fully specified harness is one source of false alarms for static analysis.","The following presents a simplified summary of the innovation in order to provide a basic understanding of some aspects described herein. This summary is not an extensive overview of the claimed subject matter. It is intended to neither identify key or critical elements of the claimed subject matter nor delineate the scope of the subject innovation. Its sole purpose is to present some concepts of the claimed subject matter in a simplified form as a prelude to the more detailed description that is presented later.","The claimed subject matter provides a method for performing a static analysis of concurrent programs. The method includes determining that a static analysis of the first concurrent program generates a warning for an input. The method also includes determining whether a static analysis of the second concurrent program generates the warning for the input. The method further includes removing the warning if the static analysis of the second concurrent program generates the warning.","The claimed subject matter also provides a system for performing a static analysis of concurrent programs. The system includes a processing unit and a system memory. The system memory includes code configured to direct the processing unit to determine that a static analysis of the first concurrent program generates a warning for an input. The first concurrent program comprises a first non-deterministic program. It is determined whether a static analysis of the second concurrent program generates the warning for the input. The second concurrent program comprises a second non-deterministic program, and is executed sequentially. The warning is removed if the static analysis of the second concurrent program generates the warning.","Additionally, the claimed subject matter includes a computer-readable storage media. The computer-readable storage media includes code configured to direct a processing unit to determine that a static assertion checking of the first concurrent program generates a warning for an input. The first concurrent program comprises a first non-deterministic program. It is determined whether a static assertion checking of the second concurrent program generates the warning for the input. The second concurrent program comprises a second non-deterministic program, and is executed sequentially. The warning is removed if the static analysis of the second concurrent program generates the warning. A deterministic filter is generated for a plurality of inputs to the static assertion checking. The deterministic filter removes a plurality of warnings for the plurality of inputs.","The following description and the annexed drawings set forth in detail certain illustrative aspects of the claimed subject matter. These aspects are indicative, however, of a few of the various ways in which the principles of the innovation may be employed and the claimed subject matter is intended to include all such aspects and their equivalents. Other advantages and novel features of the claimed subject matter will become apparent from the following detailed description of the innovation when considered in conjunction with the drawings.","The claimed subject matter is described with reference to the drawings, wherein like reference numerals are used to refer to like elements throughout. In the following description, for purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the subject innovation. It may be evident, however, that the claimed subject matter may be practiced without these specific details. In other instances, well-known structures and devices are shown in block diagram form in order to facilitate describing the subject innovation.","As utilized herein, the terms \u201ccomponent,\u201d \u201csystem,\u201d \u201cclient\u201d and the like are intended to refer to a computer-related entity, either hardware, software (e.g., in execution), and\/or firmware, or a combination thereof. For example, a component can be a process running on a processor, an object, an executable, a program, a function, a library, a subroutine, and\/or a computer or a combination of software and hardware.","By way of illustration, both an application running on a server and the server can be a component. One or more components can reside within a process and a component can be localized on one computer and\/or distributed between two or more computers. The term \u201cprocessor\u201d is generally understood to refer to a hardware component, such as a processing unit of a computer system.","Furthermore, the claimed subject matter may be implemented as a method, apparatus, or article of manufacture using standard programming and\/or engineering techniques to produce software, firmware, hardware, or any combination thereof to control a computer to implement the disclosed subject matter. The term \u201carticle of manufacture\u201d as used herein is intended to encompass a computer program accessible from any non-transitory computer-readable device, or media.","Non-transitory computer-readable storage media can include but are not limited to magnetic storage devices (e.g., hard disk, floppy disk, and magnetic strips, among others), optical disks (e.g., compact disk (CD), and digital versatile disk (DVD), among others), smart cards, and flash memory devices (e.g., card, stick, and key drive, among others). In contrast, computer-readable media generally (i.e., not necessarily storage media) may additionally include communication media such as transmission media for wireless signals and the like.","Of course, those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter. Moreover, the word \u201cexemplary\u201d is used herein to mean serving as an example, instance, or illustration. Any aspect or design described herein as \u201cexemplary\u201d is not necessarily to be construed as preferred or advantageous over other aspects or designs.","Some warnings from a static analysis checker may result from underspecified harnesses. Accordingly, in one embodiment, a system may automatically filter out or de-prioritize warnings that result from an underspecified harness, i.e., false alarms. In such an embodiment, the number of false alarms reported to the user may be reduced or eliminated. By reducing the false alarms, the system may improve the quality of static analysis checking.","Static assertion checking is an example of a static analysis approach that validates assertions specified in program source code. Software engineers may place assertions in source code as a way of testing certain computer program conditions when debugging. Programs may also include implicit assertions. If an assertion fails during testing, this may indicate a problem in the source code. Accordingly, static assertion checkers provide warnings to a user when assertions fail. In this way, the warnings help the user debug computer programs. It is noted that while the following discussion describes static assertion checking, the system, method, and techniques may be applied to other types of static analysis.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1","b":["100","100","102","104","106","108","110","112","102","102"]},"The interleaved bugs  are potential bugs that occur inconsistently across the concurrent programs  for a given input . For example, static assertion checking of a first concurrent program  with a specific input  and test harness  may result in a warning that may indicate a potential bug. A second concurrent program may be a single thread execution of the first concurrent program. If the second concurrent program  also generates the warning, the potential bug has happened sequentially. If the second concurrent program does not generate the warning, the potential bug is an interleaved bug .","The concurrent programs  may be deterministic or non-deterministic. A deterministic program has a fixed result for a given input . A non-deterministic program has multiple possible results for a given input. Non-determinism may arise from a number of issues, such as the modeling of external calls, or a thread scheduler. More specifically, non-determinism may arise from data non-determinism or control non-determinism. Data non-determinism refers to the concurrent program  making calls to libraries that are modeled non-deterministically. For example, in order to model a method to determine the time of day, a model may be provided that returns a non-deterministically chosen time. Accordingly, the concurrent program  inherits these sources of non-determinism. Control non-determinism refers to the concurrent program  having some non-determinism in scheduling.","The interleaved bug  may be less likely to be a false warning than the sequential bug because sequential bugs may be more likely to result from an underspecified harness. For example, every execution of a single program may assume a file is open. As such, if the test harness  does not open the file, all executions fail whenever the file is referenced. Accordingly, for inputs  with underspecified harnesses, interleaved bugs  do not occur because the failures occur in sequential executions.","In one embodiment, the filter  performs a method for prioritizing or reducing false alarms during static analysis of concurrent programs. The method partitions the set of inputs  to the concurrent program  into two sets: (1) A set of inputs that lead to an alarm, the violation of an assertion, in the static analysis of the sequential executions of the concurrent program, and (2) all other inputs. Then, the method merely reports the alarms that correspond to the second set of inputs. The method works by assuming that the inputs that cause an alarm in the sequential (non-interleaved) executions do not correspond to real bugs, but arise due to the underspecified test harness .","The method can be generalized to consider two non-deterministic concurrent programs  where the first program acts as a filter for the false alarms for the second program. The method consists of statically analyzing the two programs the two programs, and only reports alarms for the second program for an input that does not result in alarm for the first program. The method works by finding alarms in the second program and then querying the first program with the same input to see if the first program can raise an alarm. This process is repeated until no new alarms are found in the second program.","The method presented can be used with any static analysis method that can produce an input that causes static analysis to raise a false alarm. For clarity, the checker  represents static analysis for static assertion checking. The filter  may generate warnings for interleaved bugs  based on a static analysis of the concurrent programs  for the given inputs . In one embodiment, the filter  may generate warnings for the interleaved bugs  by performing a differential analysis of two concurrent programs , e.g., Pand P. The differential analysis of two programs, Pand P, involves finding an input , i, such that Pfails when executed with i, but Pdoes not. In this way, Pis tested against an input  only when Pdoes not fail on the input . For clarity, the differential analysis is represented as DiffError(P,P).","Let P be a concurrent program . Let Pbe the same program, but executions of Pare executed sequentially. Determining which inputs  result in interleaved bugs  is performed by solving DiffError(P, P). In one embodiment, various underapproximations of Pmay be selected for the purpose of proving the absence of interleaved bugs  for a specific input . An underapproximation of Prefers to another program whose executions are a subset of the executions of P.","Solving DiffError(P,P) may be more complex when the concurrent programs  are non-deterministic. In the following discussion, a simplified syntax is used for discussing the concurrent programs . Further, it is assumed that there is a single global variable, g, of type T. For the purpose of this discussion, the type, T, is not defined. Instead, the presence of certain predicates over T are defined. Additionally, the concurrent programs  are described as including a variable, Failed, which is a predicate of type T\u2192Boolean.","Each of the concurrent programs  is a list of procedure declarations. Each procedure takes a single variable of type T as input, returns a single variable of type T as output, and has a single statement. A program statement, st, may have the following syntax (in psuedocode):",{"@attributes":{"id":"p-0033","num":"0032"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"SYNTAX 1:"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"st::=st;st","(Sequence)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"|if (e) st else st","(if-then-else)"]},{"entry":[{},"|while (e) do st","(loop)"]},{"entry":[{},"|x:=e","(Assignment)"]},{"entry":[{},"|assume e","(Assume)"]},{"entry":[{},"|assert e","(Assert)"]},{"entry":[{},"|x = *","(Non-deterministic assignment)"]},{"entry":[{},"|call x:=foo(e)","(Procedure call)"]},{"entry":[{},"|async call foo(e)","(Thread spawn)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"In Syntax 1, e is an expression over variables in a program's scope, using some operators that are left undefined. Similar to the syntax of the C language, the statement, x=* is a non-deterministic assignment to the variable, x. This statement is also referred to herein as the havoc x statement. The assume e statement blocks in a state when e does not hold, and has no effect otherwise. Blocking refers to an execution that does not make any progress. The assert e statement fails in a state when e does not hold, in which case program control jumps to the end of the concurrent program  and the global variable, g, is modified such that Failed(g) holds. Otherwise, Failed(g) does not hold. The async call foo(e) statement spawns a new thread that executes procedure foo with argument e.","The havoc x statement induces data non-determinism. Similarly, concurrency (via threads spawned by async statements) induces control non-determinism. For the sake of clarity, references to non-determinism may be to either data or control non-determinism.","At any point in a concurrent program's execution, the concurrent program's state is represented by the values of variables in the concurrent program's scope. In particular, the input and output state of the concurrent program  is the value of the global variable, g. Given a concurrent program , P, Fmay represent a relation between P's input and output. Specifically, given input state, s, and output state, t, the relation (s,t) \u03b5 Fif there is an execution of the concurrent program  from input state, s, that ends in output state, t. A concurrent program  has a buggy execution on input s if (s,t) \u03b5 Ffor some t and Failed(t) holds.","To illustrate the differential analysis performed by the filter , the problem, DiffError is solved for two concurrent programs  that expect the same input, i. For the purpose of discussion, it is assumed that the concurrent programs  include assertions that capture a property of interest. The DiffError problem can be formally defined as follows. Given two programs Pand P, DiffError(P,P) holds if there exists an input state s such that: (1) there is some execution of Pstarting at state, s, that violates an assertion, and (2) no execution of Pon s violates an assertion.","Typically, static assertion checking involves finding a buggy execution of a concurrent program  for debugging. However, the filter  looks for a buggy execution of Pwhile reasoning over all executions of P. Specifically, given programs Pand P, the DiffError problem may be represented as shown in Formula 1.\n\n\u2203s\u2203t(F(s, t)Failed(t)\u2200t\u2032(F(s,t\u2032)Failed(t\u2032))). \u2003\u2003FORMULA 1:\n","In this way, instead of reporting all warnings resulting from static assertion checking of the concurrent programs , the filter  may merely report the interleaved bugs . By limiting the warnings to interleaved bugs , spurious warnings may be reduced or eliminated. When the program, P, is deterministic and terminating, the DiffError problem can be reduced to a standard verification problem, described in greater detail with respect to . Standard verification refers to any tool for finding bugs in a program.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 2","b":["200","200","112","200","202","112"],"sub":"1"},"Blocks - may be repeated for each input . At block , the modified P, may be executed. At block , it may be determined whether an error occurred in the execution of the modified P. If so, control may flow back to block  for the next input.","At block , concurrent program, P, is executed. Because the asserts are replaced by assumes in P, the modified program Pblocks on all inputs that cause Pto fail.","At block , it may be determined whether an error occurred in the execution of P. If not, control may flow back to block  for the next input. If an error does not occur, at block , the filter  may generate a warning for an interleaved bug . Because blocked inputs are not used in the execution of P, the interleaved bugs are limited to inputs  that fail on P, but not P, which solves Diff Error.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 3","b":["300","300","112","300","302","302","308","106"]},"At block , the filter  may determine whether a static analysis of concurrent program, P, generates a warning. A warning is generated if the static assertion checking results in an assertion failure for this input . In one embodiment, a tool may be used for finding assertion violations in a given program. Given a concurrent program  with assertions, this tool returns an indicator as to whether there are assertion violations. In the case that there are assertion violations for this input, the tool may return an execution trace that documents the assertion violation. An execution trace consists of a sequence of program statements in the order of execution. The execution trace may also include the values of variables at each statement in the execution trace.","If there is not an assertion failure in program, P, the method control flows to block . If there is an assertion failure, at block  it is determined whether a static analysis of concurrent program, P, generates a warning. If there is an assertion failure generating a warning, this may indicate an issue with the test harness . Accordingly, at block , the warning is removed. If there is not an assertion failure for P, the method control flows to block  for the next input.","If there is not an assertion failure in P, this indicates an interleaved bug . Accordingly, the filter  does not remove the warning for the interleaved bug . In one embodiment, warnings for interleaved bugs  may also be generated for other inputs that cause Pto fail. In such an embodiment, a modification of the trace t itself may be used to create a deterministic filter f that filters out i, as well as, other inputs that cause Pto fail along the trace t\u2032. The modification includes replacing the havoc x statements with x:=c, where c is the concrete value assigned to x in the trace returned by the tool. Additionally, a predicate transformer takes a trace t and a formula \u03c8 and returns a formula representing the path condition in terms of the inputs to the trace. The predicate transformers may be specified as represented in Equations 1-5:\n\npre(skip,\u03c8)=\u03c8\u2003\u2003(1)\n\npre(assume,\u03c8)=\u039b\u03c8\u2003\u2003(2)\n\npre(assert,\u03c8)=\u039b\u03c8\u2003\u2003(3)\n\npre(,\u03c8)=\u03c8[e\/x]\u2003\u2003(4)\n\npre(\u03c8)=pre(pre(\u03c8)) \u2003\u2003(5)\n","The checker  may execute the concurrent programs in a non-interleaved program execution. A non-interleaved program execution has a single thread of execution. As such, while executing thread T1, one of two possibilities occurs when spawning a new thread T2: T1 waits for T2, or T2 waits for T1. If T1 waits for T2, the spawned thread T2 executes upon being called, and T1 waits until T2 and any thread spawned by T2 completes. Additionally, while T2 is executing, any threads spawned by T2 follow this same option. If T2 waits for T1, the spawned thread T2 does not execute until T1 finishes. When T1 finishes, any of the threads spawned by it start executing.","Let Fbe a subset of Fsuch that (s,t) \u03b5 Fif and only if (s,t) \u03b5Fand there is some non-interleaved execution of P from input s that ends in state t. Interleaved bugs  are captured in FPseq. Accordingly, a program P has an interleaved bug if there is a pair of states (s,t)\u03b5Fsuch that Failed(t) holds and for all (s,t\u2032)\u03b5 F, Failed(t\u2032) does not hold.","Given two concurrent programs P and Q, the following statements are true. (i) If FQFPseq and DiffError(Q,P) does not hold, then P has no interleaved bugs . (ii) If FPseqFQ and DiffError(Q,P) holds, then P has an interleaved bug .","These statements suggest that it suffices to work with under-approximations of FPseq while proving the absence of interleaved bugs  and over-approximations of FPseq while proving the presence of interleaved bugs . Under-approximate filters may be defined as programs in the cases where T1 waits for T2 or T2 waits for T1. An under-approximate filter may also be defined for all non-interleaved executions. In the case of each under-approximate filter, the filter may defined using a syntactic program transformation. The resultant filter is a sequential program.","In an embodiment where T1 waits for T2, a filter program can lead to a deterministic filter if the program does not make use of data non-determinism, or the non-determinism does not influence the assertions. Such a filter may be obtained from P simply by replacing all async calls with normal procedure calls.","In an embodiment where T2 waits for T1, a filter program may be captured as an event-driven program. It is noted that an async call, in this case, is like posting an event that is processed when a current event finishes. Such behavior is typical of event-driven programs.","Let main be the entry procedure of P. Let EventSet be a multiset of events, where each event is a function pointer along with its arguments. A set of events may be initialized in the main procedure and then execute an arbitrary event from a specified set in a loop. Events may be added to the set by executing a async statement. The following transformation is applied to each async statement: async foo(e) \\(\\mapsto \\) EventSet.Add(new Event(foo, e))","When the concurrent program , P, has synchronization (e.g., thread join operations) then it is possible that AsyncAsEvents may deadlock. This may be acceptable in the system  because deadlocks are not considered to be bugs.","In the case of general non-interleaved executions, the filter program explores all non-interleaved executions. Such a program can have strictly more behaviors than both previous options put together. This is because it an execution is allowed to follow the first option (in the definition of non-interleaved executions) in some places and to follow the second option in other places.","Let main be the entry procedure of P. Further, let EventSet be as defined in AsyncAsEvents. Then, the AsyncGeneral filter has the same entry procedure as AsyncAsEvents. The difference is in the transformation of async statements. A Boolean variable, First, may be added to AsyncGeneral, and initialized as false. The following transformation may then be applied: async foo(e) \\(\\mapsto \\) if(First) \\{ foo(e); \\} else if(nondet( )) \\{First=true; foo(e); First=false; \\} else \\{EventSet.Add(new Event(foo, e)); \\}","The variable, First, is true when a spawned thread is executed immediately. In this case, any recursively spawned thread is also executed immediately. When First is false, one option is selected non-deterministically from two options: execute the thread immediately or delay it until the current thread finishes.",{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 4","b":["400","400"]},"The networking environment  includes one or more client(s) . The client(s)  can be hardware and\/or software (e.g., threads, processes, computing devices). As an example, the client(s)  may be computers providing access to servers over a communication framework , such as a local area network, wide area network, or the Internet.","The environment  also includes one or more server(s) . The server(s)  can be hardware and\/or software (e.g., threads, processes, computing devices). The server(s)  may be accessed by the client(s) .","One possible communication between a client  and a server  can be in the form of a data packet adapted to be transmitted between two or more computer processes. The environment  includes a communication framework  that can be employed to facilitate communications between the client(s)  and the server(s) .","The client(s)  are operably connected to one or more client data store(s)  that can be employed to store information local to the client(s) . The client data store(s)  may be located in the client(s) , or remotely, such as in a cloud server. Similarly, the server(s)  are operably connected to one or more server data store(s)  that can be employed to store information local to the servers .","With reference to , an exemplary operating environment  is shown for implementing various aspects of the claimed subject matter. The exemplary operating environment  includes a computer . The computer  includes a processing unit , a system memory , and a system bus .","The system bus  couples system components including, but not limited to, the system memory  to the processing unit . The processing unit  can be any of various available processors. Dual microprocessors and other multiprocessor architectures also can be employed as the processing unit .","The system bus  can be any of several types of bus structure(s) including the memory bus or memory controller, a peripheral bus or external bus, and\/or a local bus using any variety of available bus architectures known to those of ordinary skill in the art. The system memory  comprises non-transitory computer-readable storage media that includes volatile memory  and nonvolatile memory .","The basic input\/output system (BIOS), containing the basic routines to transfer information between elements within the computer , such as during start-up, is stored in nonvolatile memory . By way of illustration, and not limitation, nonvolatile memory  can include read only memory (ROM), programmable ROM (PROM), electrically programmable ROM (EPROM), electrically erasable programmable ROM (EEPROM), or flash memory.","Volatile memory  includes random access memory (RAM), which acts as external cache memory. By way of illustration and not limitation, RAM is available in many forms such as static RAM (SRAM), dynamic RAM (DRAM), synchronous DRAM (SDRAM), double data rate SDRAM (DDR SDRAM), enhanced SDRAM (ESDRAM), SynchLink\u2122 DRAM (SLDRAM), Rambus\u00ae direct RAM (RDRAM), direct Rambus\u00ae dynamic RAM (DRDRAM), and Rambus\u00ae dynamic RAM (RDRAM).","The computer  also includes other non-transitory computer-readable media, such as removable\/non-removable, volatile\/non-volatile computer storage media.  shows, for example a disk storage . Disk storage  includes, but is not limited to, devices like a magnetic disk drive, floppy disk drive, tape drive, Jaz drive, Zip drive, LS-100 drive, flash memory card, or memory stick.","In addition, disk storage  can include storage media separately or in combination with other storage media including, but not limited to, an optical disk drive such as a compact disk ROM device (CD-ROM), CD recordable drive (CD-R Drive), CD rewritable drive (CD-RW Drive) or a digital versatile disk ROM drive (DVD-ROM). To facilitate connection of the disk storage devices  to the system bus , a removable or non-removable interface is typically used such as interface .","It is to be appreciated that  describes software that acts as an intermediary between users and the basic computer resources described in the suitable operating environment . Such software includes an operating system . Operating system , which can be stored on disk storage , acts to control and allocate resources of the computer system .","System applications  take advantage of the management of resources by the operating system  through program modules  and program data  stored either in system memory  or on disk storage . It is to be appreciated that the claimed subject matter can be implemented with various operating systems or combinations of operating systems.","A user enters commands or information into the computer  through input device(s) . Input devices  include, but are not limited to, a pointing device (such as a mouse, trackball, stylus, or the like), a keyboard, a microphone, a joystick, a satellite dish, a scanner, a TV tuner card, a digital camera, a digital video camera, a web camera, and\/or the like. The input devices  connect to the processing unit  through the system bus  via interface port(s) . Interface port(s)  include, for example, a serial port, a parallel port, a game port, and a universal serial bus (USB).","Output device(s)  use some of the same type of ports as input device(s) . Thus, for example, a USB port may be used to provide input to the computer , and to output information from computer  to an output device .","Output adapter  is provided to illustrate that there are some output devices  like monitors, speakers, and printers, among other output devices , which are accessible via adapters. The output adapters  include, by way of illustration and not limitation, video and sound cards that provide a means of connection between the output device  and the system bus . It can be noted that other devices and\/or systems of devices provide both input and output capabilities such as remote computer(s) .","The computer  can be a server hosting various software applications in a networked environment using logical connections to one or more remote computers, such as remote computer(s) . The remote computer(s)  may be client systems configured with web browsers, PC applications, mobile phone applications, and the like.","The remote computer(s)  can be a personal computer, a server, a router, a network PC, a workstation, a microprocessor based appliance, a mobile phone, a peer device or other common network node and the like, and typically includes many or all of the elements described relative to the computer .","For purposes of brevity, only a memory storage device  is illustrated with remote computer(s) . Remote computer(s)  is logically connected to the computer  through a network interface  and then connected via a wireless communication connection .","Network interface  encompasses wireless communication networks such as local-area networks (LAN) and wide-area networks (WAN). LAN technologies include Fiber Distributed Data Interface (FDDI), Copper Distributed Data Interface (CDDI), Ethernet, Token Ring and the like. WAN technologies include, but are not limited to, point-to-point links, circuit switching networks like Integrated Services Digital Networks (ISDN) and variations thereon, packet switching networks, and Digital Subscriber Lines (DSL).","Communication connection(s)  refers to the hardware\/software employed to connect the network interface  to the bus . While communication connection  is shown for illustrative clarity inside computer , it can also be external to the computer . The hardware\/software for connection to the network interface  may include, for exemplary purposes only, internal and external technologies such as, mobile phone switches, modems including regular telephone grade modems, cable modems and DSL modems, ISDN adapters, and Ethernet cards.","An exemplary processing unit  for the server may be a computing cluster comprising Intel\u00ae Xeon CPUs. The disk storage  may comprise an enterprise data storage system, for example, holding thousands of impressions.","What has been described above includes examples of the subject innovation. It is, of course, not possible to describe every conceivable combination of components or methodologies for purposes of describing the claimed subject matter, but one of ordinary skill in the art may recognize that many further combinations and permutations of the subject innovation are possible. Accordingly, the claimed subject matter is intended to embrace all such alterations, modifications, and variations that fall within the spirit and scope of the appended claims.","In particular and in regard to the various functions performed by the above described components, devices, circuits, systems and the like, the terms (including a reference to a \u201cmeans\u201d) used to describe such components are intended to correspond, unless otherwise indicated, to any component which performs the specified function of the described component (e.g., a functional equivalent), even though not structurally equivalent to the disclosed structure, which performs the function in the herein illustrated exemplary aspects of the claimed subject matter. In this regard, it will also be recognized that the innovation includes a system as well as a computer-readable storage media having computer-executable instructions for performing the acts and\/or events of the various methods of the claimed subject matter.","There are multiple ways of implementing the subject innovation, e.g., an appropriate API, tool kit, driver code, operating system, control, standalone or downloadable software object, etc., which enables applications and services to use the techniques described herein. The claimed subject matter contemplates the use from the standpoint of an API (or other software object), as well as from a software or hardware object that operates according to the techniques set forth herein. Thus, various implementations of the subject innovation described herein may have aspects that are wholly in hardware, partly in hardware and partly in software, as well as in software.","The aforementioned systems have been described with respect to interaction between several components. It can be appreciated that such systems and components can include those components or specified sub-components, some of the specified components or sub-components, and\/or additional components, and according to various permutations and combinations of the foregoing. Sub-components can also be implemented as components communicatively coupled to other components rather than included within parent components (hierarchical).","Additionally, it can be noted that one or more components may be combined into a single component providing aggregate functionality or divided into several separate sub-components, and any one or more middle layers, such as a management layer, may be provided to communicatively couple to such sub-components in order to provide integrated functionality. Any components described herein may also interact with one or more other components not specifically described herein but generally known by those of skill in the art.","In addition, while a particular feature of the subject innovation may have been disclosed with respect to only one of several implementations, such feature may be combined with one or more other features of the other implementations as may be desired and advantageous for any given or particular application. Furthermore, to the extent that the terms \u201cincludes,\u201d \u201cincluding,\u201d \u201chas,\u201d \u201ccontains,\u201d variants thereof, and other similar words are used in either the detailed description or the claims, these terms are intended to be inclusive in a manner similar to the term \u201ccomprising\u201d as an open transition word without precluding any additional or other elements."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
