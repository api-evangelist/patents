---
title: Enabling event prediction as an on-device service for mobile interaction
abstract: By knowing which upcoming actions a user might perform, a mobile application can optimize a user interface or reduce the amount of user input needed for accomplishing a task. A herein-described prediction module can answer queries from a mobile application regarding which actions in the application the user is likely to perform at a given time. Any application can register and communicate with the prediction module via a straightforward application programming interface (API). The prediction module continuously learns a prediction model for each application based on the application's evolving event history. The prediction module generates predictions by combining multiple predictors with an online learning method, and capturing event patterns not only within but also across registered applications. The prediction module is evaluated using events collected from multiple types of mobile devices.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09372898&OS=09372898&RS=09372898
owner: Google Inc.
number: 09372898
owner_city: Mountain View
owner_country: US
publication_date: 20140717
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["Unless otherwise indicated herein, the materials described in this section are not prior art to the claims in this application and are not admitted to be prior art by inclusion in this section.","Mobile devices are ubiquitous in modern communication networks. Many of these mobile devices are \u201csmart phones\u201d capable of running one or more applications while acting as a communication device. The applications can include, but are not limited to, telephony applications, e-mail applications, Web browsing applications, games, calendar applications, contact managers, and weather\/news applications. In some cases, a user can use multiple applications during one session to interact with the smart phone.","In one aspect, a method is provided. A prediction module of a computing device receives a plurality of event notifications associated with a plurality of applications. The plurality of applications include a first application and a second application, where the first application differs from the second application. The plurality of event notifications include a first event notification and a second event notification. The first event notification is associated with the first application and regards a first event. The second event notification is associated with the second application and regards a second event. The prediction module of the computing device determines a plurality of event-prediction features for the plurality of events. The plurality of event-prediction features include a given event-prediction feature. The given event-prediction feature includes a first value that is based on a probability of an occurrence of the first event given an occurrence of the second event. The prediction module of the computing device receives a query to predict an occurrence of the first event. After receiving the query, the prediction module of the computing device determines a score predicting the occurrence of the first event based on the plurality of event-prediction features. The prediction module of the computing device provides the score from the prediction module.","In another aspect, a computing device is provided. The computing device includes one or more processors and a non-transitory computer readable medium. The non-transitory computer readable medium is configured to store executable instructions for at least a prediction module. The executable instructions, when executed by the one or more processors, cause the computing device to perform functions including: receiving a plurality of event notifications associated with a plurality of applications at the prediction module, where the plurality of applications include a first application and a second application, where the first application differs from the second application, where the plurality of event notifications include a first event notification received from the first application regarding a first event and a second event notification received from the second application regarding a second event; determining a plurality of event-prediction features for the plurality of events at the prediction module, where the plurality of event-prediction features include a given event-prediction feature that includes a first value that is based on a probability of an occurrence of the first event given an occurrence of the second event; receiving, at the prediction module, a query to predict an occurrence of the first event; after receiving the query, determining a score predicting the occurrence of the first event based on the plurality of event-prediction features using the prediction module; and providing the score from the prediction module.","In another aspect, a non-transitory computer readable medium is provided. The non-transitory computer readable medium is configured to store at least executable instructions. The executable instructions, when executed by one or more processors of a computing device, cause the computing device to perform functions including: receiving a plurality of event notifications associated with a plurality of applications at a prediction module of the computing device, where the plurality of applications include a first application and a second application, where the first application differs from the second application, where the plurality of event notifications include a first event notification associated with the first application regarding a first event and a second event notification associated with the second application regarding a second event; determining a plurality of event-prediction features for the plurality of events at the prediction module, where the plurality of event-prediction features include a given event-prediction feature that includes a first value that is based on a probability of an occurrence of the first event given an occurrence of the second event; receiving a query to predict an occurrence of the first event at the prediction module; after receiving the query, determining a score predicting the occurrence of the first event based on the plurality of event-prediction features using the prediction module; and providing the score from the prediction module.","In another aspect, a computing device is provided. The computing device includes prediction module means. The prediction module means include: means for receiving a plurality of event notifications associated with a plurality of applications, where the plurality of applications include a first application and a second application, where the first application differs from the second application, where the plurality of event notifications include a first event notification associated with the first application regarding a first event and a second event notification associated with the second application regarding a second event; means for determining a plurality of event-prediction features for the plurality of events, where the plurality of event-prediction features include a given event-prediction feature that includes a first value that is based on a probability of an occurrence of the first event given an occurrence of the second event; means for receiving a query to predict an occurrence of the first event; means for, after receiving the query, determining a score predicting the occurrence of the first event based on the plurality of event-prediction features; and means for providing the score.","Enabling Event Prediction as an On-Device Service for Mobile Interaction","Mobile devices, such as smart phones, offer a large (and growing) number of functions that can only be accessed via a limited interaction bandwidth. Predictive (or adaptive) user interfaces (UIs) for mobile devices can dynamically optimize the interaction flow or UI layout for specific actions that a user is likely to perform.","Predictive UIs can reduce the amount of user effort needed for carrying out a task by offering the user a prediction or suggestion related to the task. One simple example of predictive UIs is a recency list used by a phone dialer. Use of a recency list is based on an assumption that a recently performed task, such as dialing a phone number, is likely to be performed again. Then, by presenting a recent item at a top position in a list, the recency list potentially reduces the user effort for searching for a phone number to dial.","Herein are described techniques and prediction module support to enable event prediction for an application. Other methods may be related to predicting specific types of behavior in their domain, e.g., application invocations in a Launcher (often the Home screen on a mobile device). To predict interaction events for an arbitrary application, a prediction technique can be customizable and dynamically adaptable for unexpected behaviors.","The herein-described prediction module enables ready incorporation of event prediction into their mobile applications. Such a prediction module frees application developers from repetitive effort of creating their own prediction techniques; e.g., on a per-application basis. The prediction module can save scarce mobile computing resources by sharing the same data management and prediction components across applications. In addition, the herein-described prediction module, acting as a central service, enables an untapped opportunity for making more accurate prediction by seeing events across applications.","The prediction module can include both a general method for event prediction that combines multiple prediction mechanisms via a well-defined online learning framework and a service to applications for providing event prediction, including a concise set of APIs for application\/prediction module communication. The multiple prediction mechanisms rely on a number of features of event data from a device; e.g., event recency, previous events from the same application, previous events from other applications operating on the device, temporal and spatial regularity, and frequency patterns of events.","The herein-described prediction module provides a service for event prediction to software applications; e.g., applications for mobile devices. An application can send interaction events to the prediction module via a simple API. These interaction events can be arbitrary and only meaningful to the application, e.g., they can be application names for a launcher, phone numbers dialed for a dialer or search queries entered in a search box. Then, the application can then query how likely each of the interaction events would occur at a given time. An application can then optimize a user interface based on the predicted results, e.g., sorting a list of options based on their prediction scores.","The herein-described prediction module can serve arbitrary applications and so can be trained online; that is, without reference to prior training data. The prediction module can employ an online learning approach to combine multiple event prediction mechanisms that have each been proven useful for predicting certain behaviors. The prediction module can continuously refine a prediction model for each application as events from the corresponding application are received.","The herein-described prediction module can also learn how the events from one application relate to events from other applications; i.e., interaction behaviors in one application might be situated in a larger context. Utilizing events across applications can effectively address the sparsity of events for each single application. In some embodiments, the prediction module can be initially provided with prior data related to the application. The prior data can be based on a model of one or more general users, prior event captures, and\/or prior user interaction with other, similar devices (e.g., interaction with an older mobile device that has been or is being replaced).","The herein-described prediction module provides event prediction as a general service to applications, particularly applications on mobile devices. Any application can easily invoke the prediction module via a set of simple APIs. The prediction module can learn from events for a variety of application behaviors as they occur and predict events with reasonable accuracy at a negligible time cost, even when the semantics and underlying distribution of target events are unknown. Thus, the herein-described prediction module can provide reliable predictions with little or no prior training based on a number of features in the event data. Further, the prediction module, as an enabler, provides support for application developers to build predictive user interfaces.","Example Data Network",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1","b":["108","110","106","104","104","104","106","106"],"i":["a","b","c"]},"Although  only shows three programmable devices, distributed application architectures may serve tens, hundreds, or thousands of programmable devices. Moreover, programmable devices , , and (or any additional programmable devices) may be any sort of computing device, such as an ordinary laptop computer, desktop computer, network terminal, wireless communication device (e.g., a cell phone or smart phone), and so on. In some embodiments, programmable devices , , and may be dedicated to the design and use of software applications. In other embodiments, programmable devices , , and may be general purpose computers that are configured to perform a number of tasks and need not be dedicated to software development tools.","Server devices ,  can be configured to perform one or more services, as requested by programmable devices , , and\/or . For example, server device  and\/or  can provide content to programmable devices -. The content can include, but is not limited to, web pages, hypertext, scripts, binary data such as compiled software, images, audio, and\/or video.","The content can include compressed and\/or uncompressed content. The content can be encrypted and\/or unencrypted. Other types of content are possible as well.","As another example, server device  and\/or  can provide programmable devices -with access to software for database, search, computation, graphical, audio, video, World Wide Web\/Internet utilization, and\/or other functions. Many other examples of server devices are possible as well.","An Example Prediction Module","The design of event prediction methods can benefit from a solid understanding of mobile user behaviors. Developing interfaces that can reduce or eliminate the need for user input by predicting user actions can ease user effort and save user time while interacting with devices, such as smartphones. Recently, as mobile apps flourish, predicting application launches\u2014which application the user is likely to invoke, has become more important in order.","The regularity of event transitions in mobile use, formally a Markov chain, can be useful in predicting application launches. First-order transition probabilities for Markov chains can be used in the prediction module. The prediction module also can employ two application-specific types of transition probabilities: one for event transitions within a target application and one for transitions across multiple applications.","The temporal pattern of event occurrences can be used for event prediction. Specific hours of a day or days of a week might be more likely for certain events to occur than other times, e.g., a user might always use a Flashlight application at night. One approach for utilizing temporal patterns is to derive a probabilistic distribution based on how often a target event occurs in a given time window. In some embodiments, the prediction module can use the hour of a day and the day of the week when an event occurs as features.","Spatial patterns of event occurrences also can be used for event prediction. Cell tower IDs only give a coarse estimate about the user's location, but has proven useful in event prediction. In contrast, GPS localization that gives much more precise location information of the user. However, more specific location information may not significantly improve prediction accuracy. In addition, the excessive battery consumption of GPS is prohibitive for mobile devices. In some embodiments, the prediction module can prediction module does not perform any active location sensing; rather, the prediction module relies on location data from events contributed by applications.","An inference model, e.g., a sequential decision process or a Na\u00efve Bayesian model, can be used to combine individual prediction features (e.g., Markov-chain probabilities, recency-based probabilities, frequency, time of day, etc.). Typically, an inference model is either predetermined or has a dedicated training phase. In some embodiments, the prediction module can use online passive-aggressive algorithms to learn from events as they occur and to accommodate feature combination.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 2","b":["200","200","210","1","2","1","2"]},"Each feature F, F . . . can be a well-behaved primitive predictor. In some embodiments, each feature can generate a probability related to a probability of occurrence of one or more events. For example, a feature may provide a probability of an event occurring based on a most recent event that had previously occurred. In other examples, a feature can generate information related to a probability or prediction; e.g., a \u201cYes\u201d\/\u201cNo\u201d prediction, a probability histogram, distribution, or other representation of one or more probabilities related to a group of events.","At block , prediction module PM running on device D can receive a message M. For example, message M can be an event message reporting receipt of a message, a prediction request or query requesting a prediction, or some other type of message. In other embodiments, message M can be some other type of indication than a message; e.g., a method or other function of prediction module PM can be invoked to provide the information described as being in message M.","At block , prediction module PM can determine if message M is (a) an event report ER to report occurrence of an event E, (b) a prediction request message PR to request a prediction related to event E, or (c) some other type of message. Message M can be related to application AP; e.g., application AP can be a sender of message M or otherwise related to message M.","If message M is an event report ER, method  can proceed to block . If message M is an event report ER, method  can proceed to block . If message M is some other type of message, that is, not an event report or prediction request, method  can proceed to block .","At block , prediction module PM can update features F, F . . . to account for event E and application AP related to message M. After completing the procedures of block , method  can proceed to block .","At block , prediction module PM can determine prediction score PS to predict occurrence of event E for application AP based on features F, F, . . . , event E, and\/or application AP associated with prediction request PR.","At block , prediction module PM can generate an output related to score PS. For example, prediction module PM can generate a message M or other indication of one or more scores related to prediction request PR, event EP, and\/or application AP.","At block , prediction module PM and\/or one or more other component(s) of device D can determine whether prediction module PM is to continue execution. If prediction module PM is to continue execution, then method  can proceed to block . Otherwise, method  can end.","Using the Prediction Module","Mobile developers can enable event prediction in their application using the prediction module. In some embodiments, the prediction module can be implemented as an Android service for devices, such as smartphones, mobile devices, and other computing devices. A service utilizing the prediction module (e.g., a process or thread) can run in the background and awake in response to an application request. Although programming details shown herein are specific to Java and Android, the design of the prediction module system can be generalized for use with other operating systems and\/or programming languages.","As an example, suppose a developer D is developing a Phone Dialer application. To save the user effort of searching a desired contact, D wants the Phone Dialer to automatically recommend a list of contacts that a user is likely to call when the user opens the application. D can first register his application so to use the herein-described prediction module. Table 1 shows example Java code for registering an application to use the prediction module (called Reflection in the herein-provided code example).",{"@attributes":{"id":"p-0048","num":"0047"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Reflection reflection = new Reflection(appContext);"]},{"entry":[{},"reflection.register( ) = (new RegisterListener( ) {"]},{"entry":[{},"\u2003@Override"]},{"entry":[{},"\u2003public void onRegistered(int key) {"]},{"entry":[{},"\u2003dialerAppKey = key;"]},{"entry":[{},"\u2003\/\/ Save the key permanently for future"]},{"entry":[{},"\u2003\/\/ communication with Reflection"]},{"entry":[{},"\u2003}"]},{"entry":[{},"});"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"In Table 1, appContext is an interface to global information about an application environment by which the prediction module can perform operations such as invoking a background service. In some embodiments, as the prediction module runs in a separate background process rather than in the application's own process, all API calls to the prediction module are asynchronous. Then, return results can be received through a callback listener.","Once registered, the Phone Dialer application can receive a randomly generated unique key identifying the application to the prediction module; e.g., dialerAppKey. Internally, the prediction module can create a prediction model for the application that can be uniquely identified by the key. The Phone Dialer application can store the key persistently for future communication with the prediction module, for both contributing events and querying for prediction. The key is private to the application such that other applications cannot access the application's event data.","Once registered, the Phone Dialer application can record events with the prediction module. For example, every time the user accesses a contact, such as \u201cAnn\u201d, the Phone Dialer application can send an event message, e.g., a message with the name of the accessed contact, to the prediction module. Example software for sending the above-mentioned event message to the prediction module is shown below in Table 2.",{"@attributes":{"id":"p-0052","num":"0051"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"reflection.send(dialerAppKey, \u201cAnn\u201d, new SendListener( ){"]},{"entry":[{},"\u2003@Override"]},{"entry":[{},"\u2003public void onEventAdded(int success) {"]},{"entry":[{},"\u2003\u2003if (success == 1) {"]},{"entry":[{},"\u2003\u2003\u2003\/\/ The event has been successfully added to Reflection"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003}"]},{"entry":[{},"});"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":["1","2","1","1","2"]},"Upon receiving an event message, the prediction module can update a prediction model referred to by the key in the event message; that is, the prediction module updates the prediction model for the Phone Dialer application as the \u201cdialerAppKey\u201d is passed into the reflection.send( ) method call. In some embodiments, D can add additional semantics to the event message using a hierarchical name scheme. For example, suppose D wants to maintain a hierarchy involving \u201ctype of operation\u201d, which can include originating calls, receiving calls, and contact look ups. Then, for contacts, the hierarchy can include \u201ctype of contact\u201d and \u201ccontact\u201d names. Then, in the relection.send( ) call, D prefixing \u201cAnn\u201d with \u201cfamily\u201d delimited by \u201c\/\u201d to indicate Ann belongs to the contact group of family members; e.g., reflection.send(dialerAppKey, \u201ccontact\/family\/Ann\u201d). Other events in this hierarchy can include other family members; e.g., reflection.send(dialerAppKey, \u201ccontact\/family\/Mom\u201d) and\/or other types of contacts; e.g., reflection.send(dialerAppKey, \u201ccontact\/work\/George\u201d), reflection.send(dialerAppKey, \u201ccontact\/work\/Maurice\u201d), and other operations; e.g., reflection.send(dialerAppKey, \u201coriginate_call\/work\/George\u201d) to record the event of making a call to George at work.","The prediction module can extract multiple sub-events from an event that has hierarchies for updating prediction models. For example, the event \u201ccontact\/family\/Ann\u201d can generate three sub-events: \u201ccontact\/family\/Ann\u201d, \u201cfamily\/Ann\u201d, and \u201ccontact\/family\u201d. The event hierarchy allows the prediction module to capture more commonality across events, e.g., \u201ccontact\/family\/Carl\u201d will also generate the \u201ccontact\/family\u201d sub-event.","As another example, suppose that a Phone Dialer user looks up a family member named Ann, calls Ann but Ann does not answer, and so the user calls \u201cMom\u201d without looking up Mom's contact information. Then, just after calling Mom, the user receives a call from a number \u201c5551212\u201d which turns out to be \u201cBoss\u201d at work, discusses work with Boss, and then hangs up the phone. The Phone Dialer application can make calls to the prediction module as shown in Table 3 to send event messages for this example.",{"@attributes":{"id":"p-0056","num":"0055"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"reflection.send(dialerAppKey, \u201ccontact \/ family \/ Ann\u201d)"]},{"entry":[{},"reflection.send(dialerAppKey, \u201coriginate_ call \/ Ann\u201d)"]},{"entry":[{},"reflection.send(dialerAppKey, \u201chang up \/ Ann\u201d)"]},{"entry":[{},"reflection.send(dialerAppKey, \u201coriginate_call \/ Mom\u201d)"]},{"entry":[{},"reflection.send(dialerAppKey, \u201chang up \/ Mom\u201d)"]},{"entry":[{},"reflection.send(dialerAppKey, \u201creceive_call \/5551212\u201d )"]},{"entry":[{},"reflection.send(dialerAppKey, \u201ccontact \/ work \/ Boss\u201d )"]},{"entry":[{},"reflection.send(dialerAppKey, \u201chang up \/ Boss\u201d)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"As another example, D may want the Phone Dialer application to show a list of contacts when the user opens the application. To generate the list of contacts, the Phone Dialer application can query the prediction module for contacts that the user is likely to access. The prediction module can computes a score for each unique event that has been committed by the application, and can return a list of contacts sorted based on their scores. In some embodiments, the list of contacts can be provided using an asynchronous callback listener. In other embodiments, scores can be used by user interfaces. For example, fonts, type sizes, background color(s) and\/or foreground color(s) for displayed contacts can be based on a score for the contact; e.g., a type size for a contact can be proportional to the score for the contact. Table 4 below shows example code for querying the prediction module for predicted events.",{"@attributes":{"id":"p-0058","num":"0057"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"reflection.query(dialerAppKey, new QueryListener( ){"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003@Override"]},{"entry":[{},"\u2003public void onQueryProcessed(List<Prediction> items) {"]},{"entry":[{},"\u2003\/\/ Populate recent call list with prediction results"]},{"entry":[{},"\u2003for (Prediction prediction : items) {"]},{"entry":[{},"\u2003\u2003String contactName = prediction.event;"]},{"entry":[{},"\u2003\u2003float score = prediction.score;"]},{"entry":[{},"\u2003\u2003addItem(contactName, score);"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003}"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"});"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The prediction module can accept a filter in a query for predicted events. Using the dialer example of  above, Table 5 shows some example filtered queries and results",{"@attributes":{"id":"p-0060","num":"0059"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Filtered Prediction Module Query","Query Results"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["reflection.query(dialerAppKey,","Return predicted events related"]},{"entry":["\u201cfamily\u201d, QueryListener);","to \u201cfamily\u201d"]},{"entry":["reflection.query(dialerAppKey,","Return predicted events related to"]},{"entry":["\u201cfamily \/ Ann\u201d, QueryListener);","\u201cAnn\u201d associated with \u201cfamily\u201d"]},{"entry":["reflection.query(dialerAppKey,","Return predicted events related to"]},{"entry":["\u201cwork \/ Ann\u201d, QueryListener);","\u201cAnn\u201d associated with \u201cwork\u201d"]},{"entry":["reflection.query(dialerAppKey,","Return predicted events related to"]},{"entry":["\u201creceive_call\u201d, QueryListener);","\u201creceive_call\u201d events"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"As another example, another developer K is developing a mobile Ordering application for ordering pizza for a restaurant. To better personalize customers' ordering experience, K can program the Ordering application to have the prediction module help optimize dish recommendations. To do so, whenever the user makes an order, the Ordering application can send the order name as an event to the prediction module; e.g., reflection.send(orderAppKey, \u201cseafood deluxe\u201d).","The Ordering application can query the prediction module for the dishes that the user might want to order at a given time. To provide predictions on pizza orders for the Ordering application, or for other predictions, the prediction module can capture event patterns both within the same application (e.g., an Ordering user might often order \u201cseafood deluxe\u201d with \u201cbuffalo wings\u201d) and across different applications (e.g., ordering \u201cseafood deluxe\u201d might occur just before or just after the Phone Dialer application indicates a call \u201cAnn\u201d) Leveraging cross-application patterns is possible because the same prediction module receives events from various applications using the device. Each application developer does not have to be aware of interaction behaviors in other applications. Any complexity in capturing event patterns is transparent to developers and they only need to communicate with the prediction module via the above-mentioned APIs.","Example Event Prediction Features of the Prediction Module","The prediction module can create a prediction model for each registered application. The prediction module can predict events by combining a set of features, or well-behaved primitive predictors, using an online learning method. These features can include, but are not limited to, one or more of: a probabilistic recency feature, an event frequency feature, a Markov chain feature, a cross-application Markov chain feature, a time feature, a location feature, and a Poisson feature.","The Probabilistic Recency (Briefly, Recency) Feature.","As mentioned earlier, the recency of an event is a simple but effective indicator for whether the event is going to reoccur. Recency ranking can be readily updated for each event by moving a newly occurred event to a top position of a ranking list. Recency has been widely used in the research literature and commercial products; e.g., in the contexts of a recent call list or recently opened files.","However, a recency ranking\u2014the position of an item in the ranking list\u2014does not indicate how likely an event would occur. Determining a numerical value of recency proportional to how likely an event would occur can be useful in using recency as a feature for the prediction module. Equation (1) below can output the probability of an event, e, given a recency ranking r,\n\n()=\u03b1\u2003\u2003(1)\n","In Equation (1) and throughout, the term edenotes the ith event of all unique events in the target application. Also, in Equation (1), \u03b1 and \u03b2 are coefficients. In some embodiments, \u03b1 and \u03b2 can be are acquired by fitting a power function over the distribution of recency rankings of a pilot dataset. A power function may be used to provide a better fit with the recency distribution in comparison with other functions; e.g., exponential functions.","The Event Frequency (Briefly, Frequency) Feature.","Another simple measure that has been widely used is the frequency of visited items, i.e., more frequently used items are more likely to be revisited. Because frequency counts can be widespread, a probability function for recency rankings can be difficult to derive. Instead, given the frequency count, f, of an event, e, and an arbitrarily small value \u03b5, a score can be acquired for f>0, based on Equation (2):",{"@attributes":{"id":"p-0070","num":"0069"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mi":"P","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":["e","i"]},{"mi":["f","i"]}],"mo":"|"}}},{"mn":"1","mo":["-","+"],"mfrac":{"mn":"1","msub":{"mi":["f","i"]}},"mi":"\u03b5"}],"mo":"\u2248"}},{"mrow":{"mo":["(",")"],"mn":"2"}}]}}}}},"Equation (2) generates values in a range of 0 to 1 that is comparable with the value range of other features. This property is important for us to weigh these individual features appropriately for yielding the final prediction.","The Conjunct Markov Chain (Briefly, Markov) Feature.","An occurrence of a last event ecan signal how likely a next event e, is about to occur. Formally, this feature measures the transition probability P(e|e) between two adjacent events in the sequence using a first-order Markov chain. The transition probability distribution can be updated as each event arrives, as indicated by Equation (3):",{"@attributes":{"id":"p-0074","num":"0073"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":{"mi":"P","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":["e","i"]},{"mi":["e","l"]}],"mo":"|"}}},"mo":"=","mfrac":{"mrow":[{"mrow":[{"mo":["\uf603","\uf604"],"mrow":{"msub":[{"mi":["e","l"]},{"mi":["e","i"]}],"mo":"\u2062"}},{"mi":"dP","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["e","i"]}}}],"mo":"+"},{"mrow":{"mo":["\uf603","\uf604"],"msub":{"mi":["e","l"]}},"mo":"+","mi":"d"}]}}},{"mrow":{"mo":["(",")"],"mn":"3"}}]}}}}},"For Equation (3), |e| is the number of occurrences of the transition from eto e, and |e| is the number of observations of e, P(e) is a prior probability of e, and d is an estimate of the total number of unique events that has been observed. Equation (3) utilizes Laplace smoothing to give unobserved transitions a non-zero probability.","A first-order Markov chain only relies on the last event, which can be unreliable. However, looking at a longer event sequence in the past\u2014a higher order Markov chain\u2014can require significantly more observations to train and can be sensitive to noise. Instead, first-order Markov chains from multiple events in the time window T before the last event can be considered. Equation (4) can combines multiple Markov probabilities by taking the average of their log probabilities.",{"@attributes":{"id":"p-0077","num":"0076"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":{"mi":"P","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["e","i"]},"mo":"|","msubsup":{"mi":["E","l","T"]}}}},"mo":"=","msup":{"mrow":[{"mo":["(",")"],"mrow":{"munderover":{"mo":"\u220f","mrow":{"msub":{"mi":["e","r"]},"mo":"\u2208","msubsup":{"mi":["E","l","T"]}},"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mi":"P","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":["e","i"]},{"mi":["e","r"]}],"mo":"|"}}}}},{"mn":"1","mo":"\/","mrow":{"mo":["\uf603","\uf604"],"msubsup":{"mi":["E","l","T"]}}}]}}},{"mrow":{"mo":["(",")"],"mn":"4"}}]}}}}},"For Equation (4), Edenotes the set of unique events in the time window. In some embodiments, T can be set to 0 to only consider the most recent concurring events, e.g., multiple sub-events from an event hierarchy.","The Cross-Application Conjunct Markov Chain (Briefly, Cross-Markov) Feature.","In addition to event transitions within a target application, the prediction module can consider how the last event from one or more other applications predicts the event occurrence in the target application. The prediction module can capture first-order Markov chains of events that occur across different applications and use the resulting Cross-Markov feature for event prediction. The Cross-Markov feature is based on the intuition that an event occurrence might be situated in a larger context than only one application. Leveraging events from other applications allows the prediction module to capture more event correlations that can potentially boost the prediction accuracy of each application.","The calculation of this feature for a target application can be performed using equation similar to Equations (3) and (4) except that Eis the last occurred event in one or more non-target applications. In some embodiments, a larger time window T can be used for past events from non-target applications; e.g., T=60 seconds, to be more robust to noise from the non-target applications.","This feature can be calculated for each other application than the target application; e.g., if the prediction module is receiving predictions for N applications, A, A . . . AN, with A being the target application (without loss of generality), then N\u22121 Cross-Markov probabilities can be calculated: a probability for event occurrence for application A given the last event occurrence for application A, a probability for event occurrence for application A given the last event occurrence for application A, . . . and a probability for event occurrence for application A given the last event occurrence for application AN. The above-mentioned N\u22121 Cross-Markov probabilities can be calculated periodically; e.g., every 5 or 10 seconds and\/or when a predetermined number of events (e.g., 1 event, 5 events, 10 events) is\/are received from the applications A, A, . . . AN.","Other examples have concentrated on event transitions within a single application behavior, e.g., application launches, without leveraging event transitions outside of the target application. By factorizing Markov chains as two separate features\u2014a within-application Markov feature and a cross-application Markov feature, the state space of transition probabilities has been effectively reduced and the sparsity of events has been addressed.","The Temporal & Spatial Regularity\/Hour, Day, Cell Tower, and Cell Geo Features.","Many mobile interaction behaviors have a strong spatiotemporal pattern, e.g., calling someone on weekends or checking emails only at work. Unlike signals such as motion acceleration or GPS locations, time can be acquired for free. In particular, a probability for an event to occur in a specific hour of the day P(e|h), or on a specific day of the week P(e|d) can be used. For locations associated with mobile devices, a cell tower ID and its Geo code can provide a coarse measure of the user's location. Further, the cell tower ID can be easily acquired by many mobile devices. In some embodiments, Laplace smoothing can be used to give unobserved hours, days or cell tower IDs a non-zero probability. In other embodiments, a time feature can include the hours, the days, or the hours and days. In still other embodiments, a location feature can include a cell tower ID, a location based on the cell tower ID, and\/or another location (e.g., a location of a device determined via GPS or another technique).","The Poisson Feature.","The Poisson feature is related to a frequency pattern of events\u2014how often an event is supposed to occur in a given time interval based on an expected occurrence frequency. For example, Ben calls Angela about twice a week and these calls can occur on any day of the week. This calling pattern and other frequency patterns can be modeled as a Poisson distribution. The Poisson feature can use Equation (5) to output a probability of a given number of events to occur in a predefined time interval (e.g., a day), such as expressed in Equation (5):",{"@attributes":{"id":"p-0088","num":"0087"},"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":{"mi":"P","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["e","i"]},"mo":"|","mrow":{"msub":[{"mi":["c","i"]},{"mi":["\u03bb","i"]}],"mo":"\u2062"}}}},"mo":"=","mfrac":{"mrow":[{"msubsup":{"mi":["\u03bb","i"],"mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["c","i"]},"mo":"+","mn":"1"}}},"mo":"\u2062","msup":{"mi":"\u2147","mrow":{"mo":"-","msub":{"mi":["\u03bb","i"]}}}},{"mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["c","i"]},"mo":"+","mn":"1"}},"mo":"!"}]}}},{"mrow":{"mo":["(",")"],"mn":"5"}}]}}}}},"Given that an event ehas occurred in the predefined time interval ctimes at an expected rate of occurrence for predefined time interval \u03bb, Equation (5) can compute the probability P(e|c\u03bb) for the event eto occur again within the predefined time interval. In some embodiments, \u03bbcan be incrementally calculated each time interval.","In some embodiments, more situational factors can be added, such as GPS locations or motion signals. However, this additional information may not contribute to overall prediction accuracy, because these dimensions are often correlated with event time, which can be equated with event message arrival or, in some embodiments, be specified in an event message. In addition, extra signals can incur significant battery consumption and computational cost that are undesirable for a mobile prediction module.","Combining Features to Predict Event Occurrences","Each of the above-mentioned features can predict occurrence of an event based on a specific aspect of event patterns. Occurrence an event could depend more on some of the features but less on the rest. For example, a user might use Music Player more often at certain hours of the day (Hour), e.g., when she commutes, but visits a stock portfolio website only when her investment advisor calls (Cross-Markov). The occurrence of an event often depends on multiple features.","One approach to generate a prediction score based on multiple features is to linearly combine the features based on a set of weighting factors, or weights. Formally, let \u03c6refer to the jth feature mentioned above for 1\u2266j\u22669. The jth feature can be scored for each event eat time t and denoted as \u03c6(t, i). By concatenating the score from each feature, a feature vector \u03a6(t, i) can be acquired for event eat time t; that is, \u03a6(t, i)=(\u03c6(t, i), . . . , \u03c6(t, i)). Each event can be scored based on the dot product of weight vector, w, and feature vector \u03a6(t, i), as indicated by Equation (6):\n\nScore()=\u00b7\u03a6()\u2003\u2003(6)\n\nUsing Equation (6), events with a higher Score(e, t) value are more likely to occur than those with a lower Score(e, t) value. wcan be specified for each event (as denoted by its subscript) to allow dependency on features to differ from event to event.\n","An online learning task can be a task that a prediction engine needs to continuously update itself as event instances are observed in a sequential manner. One online learning algorithm is Perceptron, which updates weights only when a prediction is inconsistent with an observation. Other online learning algorithms include Passive Aggressive algorithms, a class of online learning algorithms that enhances Perceptron by applying additional constraints when updating the weights. These additional constraints can: 1) minimize the change to the weights so as to be conservative when seeing a single observation, and 2) enforce a minimum margin between the score of the target event and score(s) of other events.","Upon receiving each event, the received event can be used as the target event (i.e., a labeled example). The prediction module can determine how consistent a prediction of the received event's occurrence is consistent with the actual occurrence of the received event. If the prediction score for the received event is below a minimum margin value, the one or more other events can be classified as \u201cviolated\u201d since the received event violated a constraint associated with the minimum margin value. Then, weights for the weight vector of the received event can be increased and weights for violated, events can be decreased. Let r denote the index of the target event and let s be the index of a violated non-target event with r\u2260s. Equation (7) can be used to decrease weights of the violated event e:\n\n\u2212\u03c4\u03a6()\u2003\u2003(7)\n","where",{"@attributes":{"id":"p-0096","num":"0095"},"maths":{"@attributes":{"id":"MATH-US-00005","num":"00005"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"msup":{"mi":["\u03c4","t"]},"mo":"=","mfrac":{"mrow":[{"mn":"1","mo":["-","+"],"mrow":[{"mi":"Score","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":"e","mrow":{"mi":"r","mo":","}},"mo":"\u2062","mi":"t"}}},{"mi":"Score","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":"e","mrow":{"mi":"s","mo":","}},"mo":"\u2062","mi":"t"}}}]},{"msup":[{"mrow":{"mo":["\uf605","\uf606"],"mrow":{"mi":"\u03a6","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["t","r"],"mo":","}}}},"mn":"2"},{"mrow":{"mo":["\uf605","\uf606"],"mrow":{"mi":"\u03a6","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["t","s"],"mo":","}}}},"mn":"2"}],"mo":"+"}]}},"mo":";"}}},"br":{}},"Equation (8) can be used to increase the weights of the target event efor the same rate:\n\n\u2212\u03c4\u03a6()\u2003\u2003(8)\n","Overall, the prediction score for each event can be generated independently according to Equation (6). But, the prediction module can calibrate the weights of different events during learning by ensuring a target event's score is sufficiently larger than a non-target event's score. The prediction module continuously retrains these individual features and refines the weight for each event as each event is observed.","Evaluation of an Example Implementation of the Prediction Module","In some embodiments, the prediction module can include software written in Java, using Android SDK. In particular embodiments, a prediction engine of the prediction module does not use any platform-specific API calls (e.g., Android-specific API calls) and is platform independent.","The prediction module can include two components: the service and the client library. In some embodiments, the service is implemented as an Android Service running in a separate process in the background. The service can host the prediction engine by receiving prediction requests from applications, passing prediction requests to the prediction engine, and sending responses (results) from the prediction engine back to applications. The service can exit after processing all pending requests. The client library can run as part of an application process and can implement at least the API calls described above related to registering an application, sending event messages, and making prediction requests. The client library can encapsulate the details for communicating with the service. In some embodiments, communication between the client library and the service can be based on Android's Service Binding and Messenger Handler mechanisms, and all computation can take place locally on a mobile (or other computing) device.","The prediction module can predict events of interest and adapt to addressing different types of interaction behaviors. To test the prediction module, three popular mobile applications were chosen as clients of the prediction module: a Launcher application, a Dialer application, and a Browser application, where the Launcher application starts (or launches) applications (e.g., the Home Screen of a smartphone), the Dialer application can be used for telephone communications, and the Browser application can be used for Internet\/Web communications.","An example smartphone \u201cDevice A\u201d included an event logger for smartphone usage and collected data from over four thousand users to generate a herein-named Device A dataset, also including Dialer, Browser, and Launcher application usage. Another example smartphone \u201cDevice B\u201d had logging infrastructure for measuring smartphone usage longitudinally, including Dialer, Browser, and Launcher application usage. In particular, Device B was deployed with logging to 25 users for one year that generated a dataset named \u201cDevice B\u201d herein.","The prediction module was evaluated with two large-scale sets of in situ event logs: one was collected using Device A devices and the other was collected from Device B devices. For the Device A dataset, a logger ran quietly in the background of over 100 Device A participants and captured interaction events such as applications being launched, phone call events, and web URLs, including search queries, being issued and device status information; e.g., docking status. All privacy-sensitive information such as phone numbers and web queries were stored locally on a user's device and only index IDs were collected, e.g., in the Device A dataset, two phone calls are made to the same number can be identified but the specific number cannot be recovered.","To simulate the target input of the prediction module, namely a series of events contributed by applications, the Device A and Device B datasets were filtered to only include events of the three applications mentioned. For example, a Launcher event is registered only if application usage immediately follows the invocation of Launcher in a collected log trace, where the log trace is chronologically organized. In contrast, if application usage is recorded when a user clicks on the Back button, such usage is not considered as a Launcher event.","Users who only used their devices occasionally during data collection were excluded. In particular, only users with log traces longer than one month were selected. In each data set, each of the three applications had to have at least 20 unique events that occurred during the course of data collection for each user, to ensure a lower bound of event prediction complexity; i.e., typically, prediction difficulty increases with the number of unique events.","Based on these selection criteria, log traces of 57 Device A volunteers were used to form the Device A dataset. These log traces involved 141,196 events generated over one to three months (Median=39 days, Min=33, Max=106). The same filtering process was applied to the Device B dataset, which resulted in 478,029 events from 23 Device B users generated roughly over one year (Median=367 days, Min=279, Max=480).","To understand the complexity of the datasets, the number of unique events that users invoked in each of these applications was analyzed, as shown in the top row of , with the upper-left corner including a graph of data for the Device A dataset, and the upper-right corner including a graph of data for the Device B dataset.","A large amount of variation in the number of unique events per user and per application can be observed. For the Device A dataset, a number of unique behaviors invoked by Launcher obeys an exponential distribution (Median=47, Min=22, Max=116). Both the number of unique phone calls and the number of unique URLs for each user seem to obey a power law distribution (Dialer: Median=40, Min=20, Max=115, and Browser: Median=40, Min=20, Max=227).","For the Device B dataset, the median numbers of unique events invoked for application launching, phone calling and web browsing are 96 (Min=46, Max=527), 189 (Min=73, Max=452) and 257 (Min=83, Max=708), respectively. It is understandable that the Device B dataset has significantly more unique events per user because Device B data was collected over a longer time period than Device A data.","In addition to the number of unique targets that an event predictor has to choose from, the prediction complexity is also affected by how often an event occurs. Intuitively, the more an event occurs, the better chance a predictor can learn from it. The number of occurrences of an event in each target application for each user can obey a power law distribution, with a few events occurring very often and the rest occurring rarely as shown in the Device A and Device B graphs on the bottom row of .","For the Device A dataset, as graphed on the lower-left portion of , the mean length of each user's log trace\u2014the number of events in the trace\u2014is 2,477 events (SD=1,676). In particular, Launcher events accounted for the dominant portion of a trace (MEAN=75%, SD=15%), which is followed by Browser events (MEAN=15%, SD=12%) and Dialer events (MEAN=10%, SD=7%). For the Device B dataset, as graphed on the lower-right portion of , the mean length of each user's log trace is 20,688 events (SD=8,061), and similar to the Device A dataset, Launcher events accounted for the dominant portion of a trace (MEAN=80%, SD=7%), followed by Browser events (MEAN=12%, SD=7%) and Dialer events (MEAN=8%, SD=3%).","The performance of each of the nine features as a standalone predictor (referred to as a component predictor) and their combination (referred to as the prediction module) was evaluated using data from the two data sets. The prediction module was also compared with a Na\u00efve Bayesian predictor.","Each prediction technique\u2014component predictors, prediction module, and Na\u00efve Bayesian predictor\u2014was provided with an event stream; e.g., a log trace in a dataset in an online, or event by event, fashion. Each technique was requested to predict occurrence of an event after the event had been observed at least once, using the timestamp of the event as the query time. For the Device B dataset with collected Cell information, the Cell Tower and Cell Geo information was provided at query time. The ranking of the target event was recorded to calculate how often the target event was ranked as the top choice. The prediction technique was then permitted to learn from the event. This process was repeated for each event in the event stream.","As expected, the accuracy of each prediction method generally increases as more event occurrences are observed as shown in .  shows graphs of accuracy for each predictor versus a number of occurrences in a Device A dataset, in accordance with an embodiment.",{"@attributes":{"id":"p-0115","num":"0114"},"figref":["FIG. 4","FIG. 4","FIG. 4"],"b":["400","430","460","400","402","404","406","408","410","412","414","416","418","400","430","460"]},"Overall, prediction module predictor , which uses a weighted sum of all other feature predictions, performed the best for the Launcher application. Then, a Na\u00efve Bayesian predictor  and frequency feature  had a similar, if lesser, performance to that of prediction module predictor . Recency feature  and Poisson feature  were the least successful predictors for the Launcher application on Device A.","Graph  in the middle of  shows prediction accuracies for the Dialer application on Device A with respect to prediction module predictor , Na\u00efve Bayesian predictor , frequency feature , day feature , hour feature , Markov feature , Cross-Markov feature , recency feature , and Poisson feature . Overall, prediction module predictor  performed the best for the Dialer application with frequency feature  showing similar performance. Recency feature  and Poisson feature  were the least successful predictors for the Dialer application on Device A.","Graph  at the bottom of  shows prediction accuracies for the Browser application with respect to the prediction module predictor , Na\u00efve Bayesian predictor , frequency feature , day feature , hour feature , Markov feature , Cross-Markov feature , recency feature , and Poisson feature . Overall, prediction module predictor  performed the best for the Browser application. Regarding single features, frequency feature  and Cross-Markov feature  performed the best in this example and were virtually tied in performance. Hour feature  and Poisson feature  were the least successful predictors for the Browser application on Device A.",{"@attributes":{"id":"p-0119","num":"0118"},"figref":["FIG. 5","FIG. 5","FIG. 5","FIG. 5"],"b":["500","530","560","500","530","560","500","502","504","506","508","510","512","514","516","518","520","522","520","550","580","522","552","582","500","530","560"]},"Overall, prediction module predictor , which is a weighted sum of all other feature predictions, performed the best for the Launcher application with Na\u00efve Bayesian predictor , Markov feature , hour feature , location feature , frequency feature , Cell Geo feature , day feature , Cell Tower feature , and Cross-Markov feature  all showing similar, if somewhat lesser, performance to prediction module predictor . Recency feature  and Poisson feature  were the least successful predictors for the Launcher application on Device B.","Graph  in the middle of  shows prediction accuracies for the Dialer application on the Device B with respect to prediction module predictor , Na\u00efve Bayesian predictor , frequency feature , day feature , hour feature , Markov feature , Cross-Markov feature , recency feature , Poisson feature , Cell Geo feature , and Cell Tower feature . Overall, prediction module predictor  performed the best for the Dialer application with frequency feature  indicating similar performance to that of prediction module predictor . Cell Tower feature , Poisson feature , and recency feature  were the least successful predictors for the Dialer application on the Device B.","Graph  at the bottom of  shows prediction accuracies for the Browser application with respect to the prediction module predictor , Na\u00efve Bayesian predictor , frequency feature , day feature , hour feature , Markov feature , Cross-Markov feature , recency feature , Poisson feature , Cell Geo feature , and Cell Tower feature . Overall, prediction module predictor  performed the best for the Browser application with Na\u00efve Bayesian predictor  performing in a similar albeit lesser fashion. Regarding single-feature predictors, Markov feature  and recency feature  performed best initially, but frequency feature  caught up to recency feature  after approximately 35 event occurrences. Poisson feature , Hour feature , and Cell Tower feature  were the least successful predictors for the Browser application on Device B.","The prediction module predictors , , , , ,  consistently outperformed component a Na\u00efve Bayesian predictor and single-feature predictors across both datasets, indicating that a combination of single-feature predictors provides better accuracy than using any one of them alone. On average, after an application launch event has occurred 40 times, prediction module predictor  can predict an application launch with 44% accuracy compared to 41% accuracy by frequency feature  with \u03c7=7.8, p<0.01, the strongest component predictor for Launcher for the Device A dataset.","The prediction module predictors showed significant improvement over single-feature predictors in several situations. For example, prediction module predictor  exceeded strongest single-feature predictor for Browser behavior for Device A and Device B by 15% and 7% respectively. Additionally, prediction module predictor  for Device B Dialer application performance exceeded strongest component predictor performance by 7%.","The strongest single-feature predictor for each behavior tends to vary. For example, in the Device B dataset, on average, the Markov feature appears to be the most accurate single-feature predictor for Launcher. However, Cell Geo  was a strong single-feature predictor for the Device B Dialer.","Across all behaviors, the frequency feature seemed to perform better for the Device A dataset than the Device B dataset; e.g., as indicated by comparing frequency features , ,  for the Device A dataset with corresponding frequency features , ,  for the Device B data set. One explanation is that the data collection for the Device A dataset was performed over a relatively short duration so the accuracy of frequently occurred events dominates the overall performance. The Poisson feature performed poorly for Launcher and Browser behaviors, but the Poisson feature appears to be useful for the Dialer application, whose events occur more regularly in a given time interval, e.g., the number of calls to someone per day. The recency feature can perform well when there are few event occurrences\u2014especially for the Dialer and Browser applications. However, as more events are observed, the rate of improvement of the recency feature is slower than other features and\/or quickly plateaus.","One consideration was to learn how each single-feature component predictor contributes to the overall accuracy of the prediction module predictor and how single-feature component predictor weights evolve over time. To give an aggregated analysis of feature dependencies in each application, upon learning from each event occurrence, the weight vectors were averaged across all the events in the application",{"@attributes":{"id":"p-0128","num":"0127"},"figref":["FIG. 6","FIG. 6","FIG. 6"],"b":["600","630","660","600","630","660"]},"In each graph , , , weight percentages for features are shown in the following order: from top to bottom, the frequency feature, the recency feature, the Poisson feature, the Cross-Markov feature, the Markov feature, the hour feature, and the day feature. At any particular time; e.g., when a specified number of events are observed, a relative width of the region used to represent a given feature indicates a relative weighting for the feature\u2014the wider (narrower) a region for a designated feature in graph , , or , the stronger (weaker) the relative weighting for the designated feature.","Graph  shows weight percentages for features for the Launcher application based on the Device A dataset.  shows graph  with weight percentages for frequency feature , recency (Rec) feature , Poisson (Poi) feature , Cross-Markov feature , Markov feature , hour feature  and day feature . Graph  indicates that recency feature  has a relatively large width, and corresponding feature weight, when the number of Launcher event occurrences is small, but the relative weight of recency feature  diminishes as more events are seen. The opposite effect\u2014relative weights increasing as more Launcher events occur\u2014can be observed based on relative widths in graph  for Markov feature , hour feature , and, to a lesser extent, day feature .","Graph  shows weight percentages for features for the Dialer application based on the Device A dataset.  shows graph  with weight percentages for frequency feature , recency feature , Poisson feature , Cross-Markov feature , Markov feature , hour feature , and day feature . Relative widths for features in graph  indicate that a relative weight of recency feature  diminishes, and that a relative weight of Cross-Markov feature  increases somewhat as more Dialer events are seen.","Graph  shows weight percentages for features for the Browser application based on the Device A dataset.  shows graph  with weight percentages for frequency feature , recency feature , Poisson feature , Cross-Markov feature , Markov feature , hour feature , and day feature . The relative widths of recency feature  in graph  indicate that the relative weight of recency feature  diminishes initially as more Browser events are seen and then generally levels off. In contrast, the relative weight of Cross-Markov feature  increases steadily as more Browser events are seen, as indicated by the relative width of Cross-Markov feature  in graph .","Overall, the recency feature tends to be dominant initially but became less so as more event occurrences were observed, which is consistent as when used as a standalone predictor. Day and Hour features are more useful for predicting application launches as shown by graph  than for Browser URLs, as shown in graph .","The contribution of the frequency feature seems moderate across all three applications, which at a quick glance seems contradictory to the analysis discussed above in the context of . This is because frequently occurring events tend to dominate overall accuracy in , while  indicates how weights are allocated to each feature across events, using normalized weight vectors.","Markov and Cross-Markov are generally useful features across all the application behaviors. In particular, Cross-Markov grew into a dominant feature for predicting Browser behavior as more occurrences are observed as indicated in graph . The contribution of the Cross-Markov feature to the overall performance was validated by analyzing how the prediction module behaves without Cross-Markov. In most cases, use of the Cross-Markov feature improves performance of the prediction module, and the Cross-Markov feature can be used to significantly improve prediction accuracy for URLs, as indicated by the area covered by Cross-Markov feature  in graph .","The Poisson feature had the lowest prediction power compared to other features, but the Poisson feature seemed to be more useful to the Dialer application than other applications. Overall, although each application has several features that provide substantial contributions to the performance of the prediction module, the rest of the features still contribute to the overall performance of the prediction module in a non-trivial way.","To gain an understanding of how the prediction module performs in comparison with other prediction techniques, the prediction module was compared with a Na\u00efve Bayesian model used as a predictor, as mentioned above in the context of .","A variety of feature combinations were used for the Na\u00efve Bayesian model. Using many features in a Na\u00efve Bayesian model\u2014that is more vulnerable for overfitting\u2014generally hurts its performance based on our dataset as indicated in . A Na\u00efve Bayesian model that uses Markov, Hour, and Cell-Tower features per event is a generally good predictor for Launcher, Dialer, and Browser events and has shown effective in other examples. Overall, the prediction module predictor outperformed the Na\u00efve Bayesian for all behaviors for both Device A and Device B.",{"@attributes":{"id":"p-0139","num":"0138"},"figref":"FIG. 7","b":["700","730","760"]},"Graph  graphs a number of Launcher event occurrences on the X axis and a prediction accuracy on the Y axis, where prediction accuracy ranges from 0 to 1 as indicated above for . Graph  shows performance of the Na\u00efve Bayesian model using the 3 features, 8 features, and 9 features for Launcher events for both Device A and Device B, as discussed in the paragraph above. Similarly, graph  is a plot of a number of Dialer event occurrences on the X axis and a prediction accuracy on the Y axis, to indicate performance of the Na\u00efve Bayesian model using 3 features, 8 features, and 9 features for Dialer events for both Device A and Device B. And graph  is a graph with a number of Browser event occurrences on the X axis and a prediction accuracy on the Y axis, to indicate performance of the Na\u00efve Bayesian model using 3 features, 8 features, and 9 features for Dialer events for both Device A and Device B.","Although it is difficult to directly compare prediction module predictor results with previously reported results due to different datasets and experimental procedures, the results shown on  can give a useful understanding of how the prediction module predictor behaves in comparison with a Na\u00efve Bayesian approach in an online learning situation. A Na\u00efve Bayesian model assumes conditional independency between features and relies on features giving probability scores, which are hard to be accurate especially with limited observations. In contrast, the prediction module predictor has fewer requirements for features and is more flexible in combining them","To understand how fast the prediction module can predict and learn and how the time cost varies as the complexity increases, an example implementation of the prediction module was evaluated on a Google Nexus 5 smartphone, running Android\u2122 Version 4.4 (KitKat), with a Qualcomm Snapdragon\u2122 800 2.26 GHz processor. The prediction module was tested using 31,077 predictions and training cases on the device.","The overall time complexity for both prediction and learning is linearithmic,O (N log N) in the number of unique events N. Asymptotically, the expensive portion for prediction involves sorting all the events to generate a ranking list. The asymptotically expensive portion of learning is sorting the margins between the target event and each of the non-target events. Empirically, the most time-consuming component of the example implementation was actually generating the feature vector for each event.","In practice, the number of possible events for each application can be limited. For example, choosing 100 unique events per application as an upper bound, roughly 4 ms were used to either learn from an observation or make a prediction in the example implementation. When 200 unique events were used per application\u2014a reasonably large size for many applications, about 10 ms were used in either learning or prediction. Performance likely can be improved using better memory management techniques; e.g., caching feature results, and\/or profiling the example implementation to find candidate portions of software for optimization. The energy overhead for the example implementation of the prediction module was measured using a Mosoon power meter. In the example implementation, a \u201cquery\u201d or \u201csend\u201d request takes about 3 \u03bcAh of battery capacity to process and did not consume battery power at other times.","Experiments discussed above reveal that a Cross-Markov feature can bring an important contribution to the overall performance of the prediction module, especially for sparsely occurring events such as Browser and Dialer events. The Cross-Markov feature effectively addresses the sparsity of event occurrences\u2014a major challenge for event prediction on mobile devices\u2014by considering events that occurred in other applications as additional signals.","Although event transitions can be used without the distinction of within and cross-application transitions, factorizing event transitions as two separate Markov and Cross-Markov features allows each feature to have fewer parameters to learn which eases training. Also, having within-application (Markov) and cross-application (Cross-Markov) transitions gives the prediction module flexibility in weighing each type of transition. Leveraging cross-application event transitions likely is only feasible in a prediction module, as security and other system constraints often limit a typical application to little or no access to events related to other applications. In some embodiments, the Cross-Markov feature can account for usage and\/or other features of an application, so to give appropriate weighting to both events from often-used applications and events from less-often-used applications.","Generally speaking, the prediction module does not assume specific semantics or underlying distributions of target events. Rather, the prediction module learns the relative importance of each feature over time. This allows the prediction module to serve applications whose behaviors can be unexpected. Learning feature performance enables the addition, deletion, and\/or change of features used by the prediction module. For example, the prediction module can use one or more new features, such as a predictor that operates on textual content an application contributes along an event. Because each feature can be trained individually, adding, deleting, and\/or changing feature(s) have little impact on prediction module architecture.","In some embodiments, the prediction module can learn and use information about patterns of events to increase prediction accuracy for specific events and applications. For example, temporal bursts have been shown highly useful for predicting usage of applications, such as games. In these embodiments, the prediction module can be enhanced to allow applications to specify such unique event patterns specific to the application. In still other embodiments, the prediction module can be used with other applications than mentioned herein; e.g., suggesting destinations for a Maps application, improving a language model for text entry.","Computing Device Architecture",{"@attributes":{"id":"p-0149","num":"0148"},"figref":["FIG. 8A","FIG. 8A"],"b":["800","104","104","104","106","108","110","800","800","801","802","803","804","805"],"i":["a","b","c"]},"User interface module  can be operable to send data to and\/or receive data from external user input\/output devices. For example, user interface module  can be configured to send and\/or receive data to and\/or from user input devices such as a keyboard, a keypad, a touch screen, a computer mouse, a track ball, a joystick, a camera, a voice recognition module, and\/or other similar devices. User interface module  can also be configured to provide output to user display devices, such as one or more cathode ray tubes (CRT), liquid crystal displays (LCD), light emitting diodes (LEDs), displays using digital light processing (DLP) technology, printers, light bulbs, and\/or other similar devices, either now known or later developed. User interface module  can also be configured to generate audible output(s), such as a speaker, speaker jack, audio output port, audio output device, earphones, and\/or other similar devices.","Network-communications interface module  can include one or more wireless interfaces  and\/or one or more wireline interfaces  that are configurable to communicate via a network, such as network  shown in . Wireless interfaces  can include one or more wireless transmitters, receivers, and\/or transceivers, such as a Bluetooth transceiver, a Zigbee transceiver, a Wi-Fi transceiver, a WiMAX transceiver, and\/or other similar type of wireless transceiver configurable to communicate via a wireless network. Wireline interfaces  can include one or more wireline transmitters, receivers, and\/or transceivers, such as an Ethernet transceiver, a Universal Serial Bus (USB) transceiver, or similar transceiver configurable to communicate via a twisted pair wire, a coaxial cable, a fiber-optic link, or a similar physical connection to a wireline network.","In some embodiments, network communications interface module  can be configured to provide reliable, secured, and\/or authenticated communications. For each communication described herein, information for ensuring reliable communications (i.e., guaranteed message delivery) can be provided, perhaps as part of a message header and\/or footer (e.g., packet\/message sequencing information, encapsulation header(s) and\/or footer(s), size\/time information, and transmission verification information such as CRC and\/or parity check values). Communications can be made secure (e.g., be encoded or encrypted) and\/or decrypted\/decoded using one or more cryptographic protocols and\/or algorithms, such as, but not limited to, DES, AES, RSA, Diffie-Hellman, and\/or DSA. Other cryptographic protocols and\/or algorithms can be used as well or in addition to those listed herein to secure (and then decrypt\/decode) communications.","Processors  can include one or more general purpose processors and\/or one or more special purpose processors (e.g., digital signal processors, application specific integrated circuits, etc.). Processors  can be configured to execute computer-readable program instructions  that are contained in the data storage  and\/or other instructions as described herein.","Data storage  can include one or more computer-readable storage media that can be read and\/or accessed by at least one of processors . The one or more computer-readable storage media can include volatile and\/or non-volatile storage components, such as optical, magnetic, flash memory, organic or other memory or disc storage, which can be integrated in whole or in part with at least one of processors . In some embodiments, data storage  can be implemented using a single physical device (e.g., one optical, magnetic, organic or other memory or disc storage unit), while in other embodiments, data storage  can be implemented using two or more physical devices. The one or more computer-readable storage media can be, or can include, one or more non-transitory computer-readable storage media.","Data storage  can include computer-readable program instructions  and perhaps additional data, such as but not limited to one or more serialization buffers, virtual tables, objects, and\/or instances of objects. In some embodiments, data storage  can additionally include storage required to perform at least part of the herein-described methods and techniques and\/or at least part of the functionality of the herein-described devices and networks.","In other embodiments, computer-readable program instructions  can include instructions for prediction module . When instructions for prediction module are executed by processor(s) , instructions for prediction module can perform some or all of the herein-described functionality of a prediction module.","Cloud-Based Servers",{"@attributes":{"id":"p-0157","num":"0156"},"figref":["FIG. 8B","FIG. 6"],"b":["106","809","809","809","108","110","108","110","108","110","108","110"],"i":["a","b","c "]},"In some embodiments, data and services at server devices  and\/or  can be encoded as computer readable information stored in non-transitory, tangible computer readable media (or computer readable storage media) and accessible by programmable devices , , and , and\/or other computing devices. In some embodiments, data at server device  and\/or  can be stored on a single disk drive or other tangible storage media, or can be implemented on multiple disk drives or other tangible storage media located at one or more diverse geographic locations.",{"@attributes":{"id":"p-0159","num":"0158"},"figref":["FIG. 8B","FIG. 8B"],"b":["108","110","809","809","809","809","800","810","811","812","809","800","810","811","812","809","800","810","811","812"],"i":["a","b","c","a ","a","a","a ","a","b ","b","b","b ","c","c ","c","c","c ","c. "]},"In some embodiments, each of the computing clusters , , and can have an equal number of computing devices, an equal number of cluster storage arrays, and an equal number of cluster routers. In other embodiments, however, each computing cluster can have different numbers of computing devices, different numbers of cluster storage arrays, and different numbers of cluster routers. The number of computing devices, cluster storage arrays, and cluster routers in each computing cluster can depend on the computing task or tasks assigned to each computing cluster.","In computing cluster , for example, computing devices can be configured to perform various computing tasks of server . In one embodiment, the various functionalities of server  can be distributed among one or more computing devices , , and . Computing devices and in respective computing clusters and can be configured similarly to computing devices in computing cluster . On the other hand, in some embodiments, computing devices , , and can be configured to perform different functions.","In some embodiments, computing tasks and stored data associated with server devices  and\/or  can be distributed across computing devices , , and based at least in part on the processing requirements of server devices  and\/or , the processing capabilities of computing devices , , and , the latency of the network links between the computing devices in each computing cluster and between the computing clusters themselves, and\/or other factors that can contribute to the cost, speed, fault-tolerance, resiliency, efficiency, and\/or other design goals of the overall system architecture.","The cluster storage arrays , , and of the computing clusters , , and can be data storage arrays that include disk array controllers configured to manage read and write access to groups of hard disk drives. The disk array controllers, alone or in conjunction with their respective computing devices, can also be configured to manage backup or redundant copies of the data stored in the cluster storage arrays to protect against disk drive or other cluster storage array failures and\/or network failures that prevent one or more computing devices from accessing one or more cluster storage arrays.","Similar to the manner in which the functions of server devices  and\/or  can be distributed across computing devices , , and of computing clusters , , and , various active portions and\/or backup portions of these components can be distributed across cluster storage arrays , , and . For example, some cluster storage arrays can be configured to store the data of server device , while other cluster storage arrays can store data of server device . Additionally, some cluster storage arrays can be configured to store backup versions of data stored in other cluster storage arrays.","The cluster routers , , and in computing clusters , , and can include networking equipment configured to provide internal and external communications for the computing clusters. For example, the cluster routers in computing cluster can include one or more internet switching and routing devices configured to provide (i) local area network communications between the computing devices and the cluster storage arrays via the local cluster network , and (ii) wide area network communications between the computing cluster and the computing clusters and via the wide area network connection to network . Cluster routers and can include network equipment similar to the cluster routers , and cluster routers and can perform similar networking functions for computing clusters and that cluster routers perform for computing cluster ","In some embodiments, the configuration of the cluster routers , , and can be based at least in part on the data communication requirements of the computing devices and cluster storage arrays, the data communications capabilities of the network equipment in the cluster routers , , and , the latency and throughput of local networks , , , the latency, throughput, and cost of wide area network links , , and , and\/or other factors that can contribute to the cost, speed, fault-tolerance, resiliency, efficiency and\/or other design goals of the moderation system architecture.","Example Methods of Operation",{"@attributes":{"id":"p-0167","num":"0166"},"figref":"FIG. 9","b":["900","104","104","104","106","108","110","800"],"i":["a","b","c"]},"Method  can begin at block , where a prediction module of a computing device can receive event notifications. The computing device can be configured to execute a plurality of applications that include a first application and a second application. The first and second applications can differ. The plurality of event notifications can include a first event notification received from the first application regarding a first event and a second event notification received from the second application regarding a second event.","At block , the prediction module of the computing device can determine a plurality of event-prediction features for the plurality of events. The plurality of event-prediction features can include a Cross-Markov event-prediction feature. The Cross-Markov event-prediction feature can include a first value that is based on a probability of an occurrence of the first event given an occurrence of the second event.","In some embodiments, the plurality of event-prediction features additionally can include at least one feature selected from the group of features consisting of a recency feature, a frequency feature, a Markov feature, a Poisson feature, a location feature, and a time feature. In particular embodiments, the recency feature can be based on a recency ranking of the first event. In other particular embodiments, the frequency feature can be based on a frequency of occurrence of the first event. In even other particular embodiments, the Markov feature can be based on a probability of the occurrence of the first event given an occurrence of a third event, where the third event is an event received from the first application. In yet other particular embodiments, the location feature includes a probability of the occurrence of the first event based on the computing device being at a predetermined location. In further other particular embodiments, the time feature can include a probability of the occurrence of the first event based on a predetermined time of day.","In other embodiments, the Cross-Markov event-prediction feature can further include a second value that is based on a probability of an occurrence of the second event given an occurrence of the first event.","At block , the prediction module of the computing device can receive a query to predict an occurrence of the first event.","At block , after receiving the query, the prediction module of the computing device can determine a score predicting the occurrence of the first event based on the plurality of event-prediction features.","In some embodiments, determining the score can include determining a sum of the plurality of event-prediction features. In particular embodiments, the sum of the plurality of event-prediction features can include a weighted sum of the plurality of event-prediction features.","At block , the prediction module of the computing device can provide the score.","In some embodiments, method  further includes: receiving a second query to predict an occurrence of the second event at the prediction module and after receiving the second query, determining a score predicting the occurrence of the second event based on the plurality of event-prediction features using the prediction module.","Where example embodiments involve information related to a person or a device of a person, some embodiments may include privacy controls. Such privacy controls may include, at least, anonymization of device identifiers, transparency and user controls, including functionality that would enable users to modify or delete information relating to the user's use of a product.","Further, in situations in where embodiments discussed herein collect personal information about users, or may make use of personal information, the users may be provided with an opportunity to control whether programs or features collect user information (e.g., information about a user's physiology, medical history, social network, social actions or activities, profession, a user's preferences, or a user's current location), or to control whether and\/or how to receive content from the content server that may be more relevant to the user. In addition, certain data may be treated in one or more ways before being stored or used, so that personally identifiable information is removed. For example, a user's identity may be treated so that no personally identifiable information can be determined for the user, or a user's geographic location may be generalized where location information is obtained (such as to a city, ZIP code, or state level), so that a particular location of a user cannot be determined. Thus, the user may have control over how information is collected about the user and used by a content server.","The above detailed description describes various features and functions of the disclosed systems, devices, and methods with reference to the accompanying figures. In the figures, similar symbols typically identify similar components, unless context dictates otherwise. The illustrative embodiments described in the detailed description, figures, and claims are not meant to be limiting. Other embodiments can be utilized, and other changes can be made, without departing from the spirit or scope of the subject matter presented herein. It will be readily understood that the aspects of the present disclosure, as generally described herein, and illustrated in the figures, can be arranged, substituted, combined, separated, and designed in a wide variety of different configurations, all of which are explicitly contemplated herein.","With respect to any or all of the ladder diagrams, scenarios, and flow charts in the figures and as discussed herein, each block and\/or communication may represent a processing of information and\/or a transmission of information in accordance with example embodiments. Alternative embodiments are included within the scope of these example embodiments. In these alternative embodiments, for example, functions described as blocks, transmissions, communications, requests, responses, and\/or messages may be executed out of order from that shown or discussed, including substantially concurrent or in reverse order, depending on the functionality involved. Further, more or fewer blocks and\/or functions may be used with any of the ladder diagrams, scenarios, and flow charts discussed herein, and these ladder diagrams, scenarios, and flow charts may be combined with one another, in part or in whole.","A block that represents a processing of information may correspond to circuitry that can be configured to perform the specific logical functions of a herein-described method or technique. Alternatively or additionally, a block that represents a processing of information may correspond to a module, a segment, or a portion of program code (including related data). The program code may include one or more instructions executable by a processor for implementing specific logical functions or actions in the method or technique. The program code and\/or related data may be stored on any type of computer readable medium such as a storage device including a disk or hard drive or other storage medium.","The computer readable medium may also include non-transitory computer readable media such as non-transitory computer-readable media that stores data for short periods of time like register memory, processor cache, and random access memory (RAM). The computer readable media may also include non-transitory computer readable media that stores program code and\/or data for longer periods of time, such as secondary or persistent long term storage, like read only memory (ROM), optical or magnetic disks, compact-disc read only memory (CD-ROM), for example. The computer readable media may also be any other volatile or non-volatile storage systems. A computer readable medium may be considered a computer readable storage medium, for example, or a tangible storage device.","Moreover, a block that represents one or more information transmissions may correspond to information transmissions between software and\/or hardware modules in the same physical device. However, other information transmissions may be between software modules and\/or hardware modules in different physical devices.","While various aspects and embodiments have been disclosed herein, other aspects and embodiments will be apparent to those skilled in the art. The various aspects and embodiments disclosed herein are for provided for explanatory purposes and are not intended to be limiting, with the true scope being indicated by the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 8A"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 8B"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
