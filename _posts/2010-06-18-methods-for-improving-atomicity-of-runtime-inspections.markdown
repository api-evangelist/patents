---
title: Methods for improving atomicity of runtime inspections
abstract: A method for achieving atomicity while inspecting a running computer process using a copy-on-write process in a supervisor to generate a copy of a target's memory page being written to, prior to executing the write, the copy along with any unwritten to memory pages in the target being mapped to a measurement agent (MA) and used to reflect the state of the target at a particular moment in time which state when observed by the MA provides an atomic runtime inspection.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08832684&OS=08832684&RS=08832684
owner: The Johns Hopkins University
number: 08832684
owner_city: Baltimore
owner_country: US
publication_date: 20100618
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","STATEMENT OF GOVERNMENTAL INTEREST","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["This application relates to U.S. provisional application No. 61\/268,944, filed on Jun. 18, 2009, which is incorporated herein by reference in its entirety.","This invention was made with Government support under contract MDA904-02-D-0302. The Government has certain rights in the invention.","1. Field of the Invention","The present invention relates to methods for software inspection and verification and, more specifically, in one embodiment to methods for improving coherency by ensuring atomicity in runtime integrity measurements.","2. Description of the Related Art","Recent work in software integrity verification has expanded the scope of measurement collection from static load time images to running process states. Runtime integrity measurement relies on the ability of a measurement agent (MA) to observe the memory image of a running process and to construct some meaningful description of the process's current state. Both load time and runtime measurements may be evaluated by a remote appraiser as part of an access control decision. However, because runtime measurements represent fresher assertions about the target's state, one can have more confidence that decisions that include runtime measurements reflect the intent of the system owner than decisions which rely solely on load time measurements.","In some systems, a runtime measurement may consist of a cryptographic hash of critical but (presumably) static regions of the target's memory. Other systems include more complex characterizations of the target's dynamic state. No matter what technique is used it is vital that the measurement be meaningful and correct.","Unlike in load time measurement architectures, the target of a runtime measurement is running and, hence, able to change its state. In this setting, a proper measurement must reflect a coherent state of the target. This coherency property can be divided into two distinct properties which must be satisfied to obtain a coherent measurement. Atomicity requires the measurement to reflect the state of the target at a particular moment in time. Quiescence asserts that the target data is in a consistent state, i.e. not a critical section.","Without ensuring coherency of measurement, both false positive and negative results may ensue. In the former case, a failed measurement may mean unwarranted denial-of-service to the target, unnecessary rebooting, or manual inspection. Perhaps more dangerous is the latter case, where a compromised system may go undetected and continue to run, and exploit other systems that rely on the correctness of measurement. To elucidate the coherency problem, consider the effects of coherency on two example integrity measurements.","In a simple example, a system tracks two bits of information, a and b, and maintains a parity bit p. Integrity is measured by the assertion a xor b=p (i.e., the parity bit must accurately reflect the parity of the first two bits). Suppose an attacker can manipulate any of the three bits during measurement. The two parts of the coherency problem are as follows, illustrating false negative and false positive results, respectively.\n\n","This simple example demonstrates the necessity of coherent measurement. Failing to enforce either the atomicity or quiescence property may result in an incorrect measurement. Further, as the complexity of measurement increases, the challenge of maintaining coherency becomes more difficult, and the potential impact on the target becomes greater. Consider the following, more complex example.","A system maintains two distinct circular doubly-linked lists: in_use_list and free_list. Integrity is measured by the assertion that all elements of in_use_list have a particular flag set and elements of free_list do not. Further, there is an implicit assertion that in_use_list and free_list form distinct valid circular doubly-linked lists. The MA must walk both lists and record or validate the proposition.\n\n","This example further emphasizes the importance of coherency of measurement. Measurement must avoid the danger of an attacker changing things during measurement to escape detection. The quiescence failure in this example illustrates the fragility of runtime measurement; measurement must be done carefully to avoid measuring a target when the target is in a critical section.","A failure of atomicity is more relevant for false negatives than false positives. A false positive would mean that the system is valid at the beginning of measurement, and becomes bad during measurement. From the perspective of the point in time of measurement, reporting a bad measurement in this case is a false positive, since the state was valid at the point of the measurement. However, reporting this bad measurement at this point can hardly be considered a bad thing; in any case, an atomic measurement would not capture this invalid state, since it occurs after the point in time of measurement.","While not part of coherency, related goals of measurement are minimizing runtime overhead and avoiding target realization of measurement. A complete solution to the coherency problem will:\n\n","Load-time measurement systems implicitly meet the coherency goal because the target of measurement is not actively modifying its state while the measurement is being performed. For example, one system hashes the file system image of key objects (such as system executables) as they are loaded by the operating system kernel. Because the measurement is performed before the image is actually executed, there is no chance that the image is in an inconsistent state.","The problem is the atomicity property for run-time measurement agents. Naive approaches can accurately enforce the atomicity property, but exact undesirable performance penalties on the target.","Pausing the target during measurement will not allow the target to update any of its memory, thus making the measurement atomic. However, this has the undesirable effect of denial-of-service to the target for the duration of measurement, which may take several seconds. An alternative approach is to copy the entire memory of the target and perform measurement on the copies. This clearly has the side-effect of wasting large portions of memory for measurement and additionally imposing a time penalty for how long it takes to copy memory.",{"@attributes":{"id":"p-0020","num":"0027"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Time and Memory Overhead during Runtime Measurement"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"LKIM","Overhead"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Strategy","Memory","Activity","Runtime","Time","Memory"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}},{"entry":["Pause TD","256 MB","Idle","0.291 s","166.6 ms","\u20030 MB"]},{"entry":["FUll Copy","256 MB","Idle","0.471 s","161.6 ms","256 MB"]},{"entry":["Pause TD","1024 MB\u2002","Idle","0.291 s","165.0 ms","1024 MB\u2002"]},{"entry":["FUll Copy","1024 MB\u2002","Idle","0.995 s","668.4 ms","1024 MB\u2002"]},{"entry":["Pause TD","256 MB","Linux","0.952 s","636.8 ms","\u20030 MB"]},{"entry":[{},{},"kernel build"]},{"entry":["FUll Copy","256 MB","Linux","1.076 s","178.3 ms","256 MB"]},{"entry":[{},{},"kernel build"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}}]}}},"Table 1 above shows the time and memory overhead of the Linux Kernel Integrity Monitor (LKIM) see, e.g., P. A. Loscocco, et al., \u201cLinux kernel integrity measurement using contextual inspection,\u201d STC '07: Proceedings of the 2007 ACM Workshop on Scalable Trusted Computing, pp. 21-29, NY, N.Y., USA, 2007) measurement for these naive strategies for identical targets with different memory sizes and different levels of activity: either idle or building the Linux kernel. On idle targets, measurement is faster, since there is less active memory to measure. For more active targets, measurement takes longer, and can be several seconds; pausing the target for this amount of time is clearly undesirable. Further, the memory overhead for performing a full copy of memory is substantial, and can add significant downtime to the target; a full copy of a 1024 MB target takes longer to complete than the time measurement takes when pausing the target domain. (Note that the pause time of the Pause Target Domain (TD) strategy is less than the LKIM runtime due to some activity before and after the actual memory measurement.)","Given the above problems with current simple, yet naive, runtime measurement approaches it should be the objective of an inventive solution to improve coherency, and particularly atomicity, of runtime measurements without an extended denial-of-service to the target and without the need for large memory or the additional time required to copy large memory.","Therefore, the present invention has been made in view of the above problems and constraints, and provides a method to achieve the above measurement objectives.","More specifically, the present invention solves the above problems to a great extent through the use of memory copy-on-write (CoW) to achieve atomicity of runtime measurement, while providing significant improvements in time and memory overhead, compared with the above naive approaches. At the beginning of measurement, CoW is enabled on the target. The target is then briefly paused for some initialization, after which the target may run during measurement. Any memory writes in the target with CoW enabled generate copies of the memory page being written to, prior to executing the write. When measurement completes, CoW is disabled, causing the copied memory to be discarded.","During measurement, the measurement agent will observe the actual target's memory for any pages that have not been written to, and the copies for any pages that have. The measurement will be atomic, since the snapshot of the target's memory is maintained in the form of copies. This results in a reduction in the target downtime and resource usage, when compared with the naive approaches, since the target is allowed to run during measurement, and only the pages of memory that change during that time are copied.","More specifically the present invention is directed to a method for achieving atomicity while inspecting a running computer process comprising implementing a copy-on-write (CoW) process in a supervisor to generate a copy of a target's memory page being written to, prior to executing the write, the copy along with any unwritten to memory pages in the target being used to reflect the state of the target at a particular moment in time which state when observed by a measurement agent (MA) provides an atomic runtime inspection.","The present invention is also directed to a method for achieving atomicity while measuring the integrity of a running computer process wherein a measurement agent (MA) is measuring a target, the method comprising:","initiating the measurement by the MA requesting a hypervisor to begin mapping the target's memory pages;","enabling a copy-on-write (CoW) in the target by the hypervisor;","generating a copy of a target's memory page being written to, prior to executing the write; and","observing the copy along with any unwritten to memory pages in the target by the MA to provide an atomic runtime integrity measurement.","The present invention is further directed to a computer program product comprising a non-transitory computer usable medium having a computer readable program code embodied therein, the computer readable program code instructing a microprocessor to implement a method for achieving atomicity while inspecting a running computer process comprising using the microprocessor to implement a copy-on-write process in a supervisor to generate a copy of a target's memory page being written to, prior to executing the write, the copy along with any unwritten to memory pages in the target being used to reflect the state of the target at a particular moment in time which state when observed by a measurement agent (MA) provides an atomic runtime inspection.","The present invention is further directed to a machine for measuring the integrity of a running computer process wherein a measurement agent (MA) is measuring a target, the machine comprising a microprocessor coupled to a memory wherein the microprocessor is programmed to:","initiate the measurement by the MA requesting a hypervisor to begin mapping the target's memory pages;","enable a copy-on-write (CoW) in the target by the hypervisor;","generate a copy of a target's memory page being written to, prior to executing the write; and","observe the copy along with any unwritten to memory pages in the target by the MA to provide an atomic runtime integrity measurement.","These and other objects and advantages of the present invention will be fully apparent from the following description, when taken in connection with the annexed drawings.","In the following discussion, numerous specific details are set forth to provide a thorough understanding of the present invention. However, those skilled in the art will appreciate that the present invention may be practiced without such specific details. In other instances, well-known elements have been illustrated in schematic or block diagram form in order not to obscure the present invention in unnecessary detail.","Reference will now be made in detail to the exemplary embodiments of the present invention, examples of which are illustrated in the accompanying drawings.","Although a general strategy for atomicity of runtime integrity measurement is presented herein, the examples and experiments focus on runtime integrity measurement of the Linux kernel using the LKIM. Though the discussion focuses on measuring the kernel, copy-on-write (CoW) is applied to the memory of the entire domain, not just kernel memory. This provides support for measuring any portion of a domain's memory including all of user space, which is important if a compromised kernel stores data out-side kernel space, and allows for other measurement agents (MAs) that may want to measure more than just the kernel.","For the purposes of the following discussion, a page is assumed to be 4 KB of contiguous physical memory. Unifying with existing Xen and x86 terminology, the term page table denotes a level 1 page table, whose entries are data pages; a page directory is a level 2 page table, whose entries are either level 1 page tables or 4 MB pages. In the described embodiments, 4 MB pages are ignored, as Xen (see below) provides very limited support for 4 MB guest pages, and therefore so does the embodiment of the present invention.","One important aspect of paging is the manner in which writability of a page is determined. A read\/write (R\/W) flag is maintained in each page table entry (PTE), describing the R\/W property of the page mapped by the PTE. This allows the same page to be mapped with a different R\/W property in different PTEs. In other words, writability is a property of the mapping of a page, not a property of the page itself.","While the method of the present invention of memory copy-on-write for measurement is in the Xen hypervisor from XenSource, Inc., the focus on Xen-specific details will be only when necessary, so a rudimentary understanding of Xen will suffice. It is necessary to understand the concept of paravirtualization, which utilizes a software interface to a virtual machine (VM) that is different from the underlying hardware; the VM is aware that it is in a virtualized environment, and is in fact altered to suit this environment. In Xen, this interface is presented via hypercalls that a VM makes to the hypervisor to perform actions on its behalf, that it is not otherwise permitted to do (e.g., I\/O, changes to page tables).","In the discussion that follows, the following terminology and abbreviations will be used. A domain (also guest) is a virtual machine running in Xen; a domU, meaning a normal guest domain, is to be distinguished from the domain dom0, which has special privileges to do I\/O, manage other domains, etc. A measurement agent (MA) (e.g., LKIM) is the domain\/entity performing measurement of a target or target domain (TD) (e.g., Linux). In addition to measuring, the MA can also inspect, for example, searching for a cryptographic key, and\/or observe and, therefore, can also be called more broadly an inspection agent (IA). When necessary, the measurement agent process (MAP) is distinguished from the measurement agent kernel (MAK), since the process cannot interact with the hypervisor directly, but must go through the kernel. Also, the term snapshot is used to refer to the state of the target domain's memory at a given point in time. Finally, while the examples focus on the use of a hypervisor and, more specifically, the Xen hypervisor, the more generic category for a hypervisor is a supervisor which can include, but is not limited to, a hypervisor or an operating system kernel.","The method of the present invention of CoW in Xen is built with one necessary assumption and several simplifying assumptions. The only necessary assumption is that none of the target domain's memory be accessible using Direct Memory Access (DMA). This would permit direct writes to memory by the hardware, which would bypass the mechanism of the invention for copying pages that are being written to, and thereby break atomicity.","The embodiment of the present invention and results produced assume the following:\n\n","Shadow paging and balloon drivers are both additional Xen memory modes. Shadow paging adds a level of indirection to the page table structure, so the page tables the guest uses are translated into shadow page tables that the machine actually uses. This is not necessary for paravirtualized guests, so it is not currently supported. Balloon drivers are used to dynamically add or subtract memory from a domain. This creates added complexity for our purposes, particularly if pages are removed during measurement.","The current embodiment supports the TD and MA each using their own dedicated processor.","No support for memory that has been paged to disk is provided. This is not a problem when measuring the Linux kernel, as the kernel does not page any of its memory to disk. This may be an issue for measuring other kernels (such as the Windows kernel, which does page kernel memory to disk) or measuring user processes which may have memory paged out. This is a general problem for runtime integrity measurement that exists regardless of whether or not CoW is being used, since it involves measuring a portion of virtual memory that is not actually in physical memory at the time of measurement.","Writable page tables, which a paravirtualized guest may use to write to its own page tables are supported. As discussed herein, this creates some added complexity in monitoring page table changes. Shared pages (sharing automatically generates copies) is also supported, which is important as all of the I\/O for a domU occurs on shared memory, since it is not allowed to directly access hardware.",{"@attributes":{"id":"p-0055","num":"0069"},"figref":"FIG. 1"},"The CoW embodiment of the invention adds approximately 2000 lines of code to Xen. Before describing the embodiment of the invention, some changes to Xen and some general concepts used below are detailed.","The present invention requires changes to some Xen structures, particularly those doing memory management. To the structure keeping information about each domain, struct domain, a flag is added indicating that a domain is CoW-enabled, and a field to keep track of which domain initiated the CoW. A list is also added to struct domain, so the MA domain can keep the copies of any CoW-generated copies (as discussed below, the MA domain gets the copy, while the TD keeps the original). The struct page_info contains meta data about each page of memory. To this structure, two flags are added to the type_info field (that maintains information about the types of pages, e.g, page table or data page), one indicating if a page is a CoW page or not, and the other indicating whether or not the page has been copied. A pointer is also added from the original CoW page to where the copy resides; this allows Xen to map the copy to the MA in the event that the original has been written. In order to correctly force and handle page faults when the TD writes to a page, an available bit in each page table entry is used to keep track of the previous value of R\/W flag, which will be marked read-only for CoW purposes.","In the further discussion below, reference to copying a page, includes the following sequence of events. First, create a copy of the page of memory; second, in the page_info structure for this page, set the flag indicating the page was copied; third, in the same page_info, add a pointer from the original page to the copy. Note that while the copy of memory is exactly the same as the original, the copy's page_info will be different, since the meta data about the page is different.","In the CoW method of the invention the copy is given to the MA, which is necessary for several reasons. One of the implicit goals is to not disturb the running target domain, which is more likely if giving the copy to the TD and allowing the MA to keep the original. A particular challenge occurs if the TD is using 4 MB pages, which must be contiguous physical memory in a paravirtualized guest. First, finding a 4 MB contiguous block of memory for a copy may be difficult, if not impossible. Secondly, portions of the 4 MB page are allowed to be mapped as 4 KB pages. If a page fault occurs on a 4 MB page after one of the 4 KB pages has already been copied, replacing the copied 4 KB page inside the copied 4 MB page would be overly burdensome. Giving the copy to the TD alleviates this problem, as it does not require the 4 MB block to be mapped as 4 MB of contiguous physical memory, but can instead be mapped as several 4 KB pages.","In addition to this 4 MB page problem, whichever domain gets the copy will suffer a performance penalty, since any mappings of the original page will have to change to point to the copy. Were the copy to go to the TD, this would require a full page table walk to determine all locations where the page is mapped. As described below, better control is maintained over the mappings to the MA and a full page table walk is avoided. This fits with the goal to maximize target performance. Further, by giving the MA the copy, we can avoid any MMU-direct changes and avoid race conditions with the MA walking the page tables of the TD.",{"@attributes":{"id":"p-0061","num":"0075"},"figref":"FIG. 2"},"If there is insufficient memory for a copy of a page at any point during CoW, the TD is paused until unsnapshot is called. This allows an atomic measurement to run to completion, assuming that performing measurement is more important than starving the TD. Alternatively, the MA could be allowed to decide whether it wants to complete or abort measurement if memory exhaustion occurs, in such cases where starving the TD is undesirable.","When the hypercall snapshot (td) is received by Xen, the following operations occur:","1. Copy all TD page tables immediately;","2. Copy any pages shared to or from the TD;","3. Mark all pages in TD CoW;","4. Mark all page table entries (PTE's) in TD Read-Only; and","5. Copy the TD registers at time of snapshot.","Copying all TD's page tables immediately is necessary since they are changed in step 4. This will likely also result in time saving, as the page tables are likely to change anyway. Pages that are owned by the TD and shared with another domain are copied so CoW does not disturb the domain they are shared with, which may write to them (especially for I\/O purposes). Similarly, pages owned by another domain that are shared to the TD are also copied up front.","All of the pages in the target domain are then marked as CoW. This is done by marking a flag in the type_info field of the page_info struct corresponding to the page, which has been reserved for CoW purposes. It may be desirable to permit CoW enabling for only the portions of the target domain's memory that involve measurement, though this is not currently supported.","All of the page table entries (PTE's) in the target domain are then marked as read-only (RO), and the previous state of the R\/W flag is saved in an available bit. This ensures that any writes to one of the target domain's pages will trigger a page fault, so a copy can be generated and the R\/W flag reverted to its prior state. In truth, a PTE is only changed to read-only if the page that it refers to has not already been copied.","Finally, copies of the target domain's registers are made, so the MA can read the register values at the time of the snapshot. This is particularly relevant for the CR3 register, which contains a pointer to the page directory. The MA needs this value to determine the locations of the pages it wants to measure.","The following activities of the TD require additions to the hypervisor to support CoW:\n\n","Since all of the PTE's in the TD are marked as read-only, any of the resulting page Faults must be handled. If the page fault is a write fault on a CoW page, then it must be handled. Handling the fault entails copying the page as described herein, if the page was not already copied. After the page has been copied, the R\/W flag is reverted to its state prior to CoW initialization. Finally, any current mappings of the original page in the MA must be updated to point to the copy instead.","In order to ensure that writes in the TD trigger page faults, any time a PTE changes or a new page table is created, any entries referring to uncopied CoW pages must be read-only (if the page has been copied, the TD is free to write to it). When a PTE changes, the R\/W bit that it would change to is saved, and the entry marked read-only, so the PTE entry will act just as those that were present when CoW was initialized. In a similar fashion, when a data page is elevated to a page table, before installing the page table, the R\/W bit of each entry is saved, and marked read-only. Note that these changes are not relevant for the page directory, since the R\/W flag is only enforced on page tables, so there is no need to mark entries in the page directory read-only.","Changes to page tables can occur in a couple of ways, which add to the complexity of the method of the invention. A fully paravirtualized guest may issue hypercalls asking Xen to change a PTE, since the guest is not allowed write access to its page tables. However, Xen also supports a writable page table mode, where the guest is given write access to its (level 1) page tables. In this case, instead of permitting the guest to truly write to the page table, Xen actually emulates the instruction to update the PTE and verifies the result, giving the guest the illusion of writable page tables. The method of the invention supports both writable page tables and hypercalls for updates.","When a page owned by the TD is shared to another domain, the page is simply copied prior to sharing. This is to avoid affecting the sharing domain, since read-only page faults would have to be forced for its mapping of the page also. Since a page is being shared, it is likely that it is about to be written to anyway. Nothing is done when a page owned by another domain is shared to the TD, since it would not have been part of the TD's memory at the time of the snapshot.","As shown in , during measurement, the interface between the MA and the Xen hypervisor consists of the MA asking Xen to map pages of the TD for measurement. The first thing the MA will do is ask for the value of CR3 at the time of the snapshot. The MA will then request Xen to map the page corresponding to this CR3 value. This map call will ask for the machine frame number (mfn) of the page pointed to by CR3 for the snapshot. Since this page was copied, and the original may have changed, Xen maps in the copy. Once this page is mapped, the MA will have a handle on the page tables of the TD at the time of snapshot. The MA will then continue to ask for TD pages it wants to measure. Each map request entails the following sequence of actions:\n\n","The decision to map the copy or the original is transparent to the MA, which is not concerned with whether the copy or the original was mapped when performing measurement. The reverse mapping is an important step that was alluded to herein regarding page faults. In the case where the MA has an original page mapped, the same page will be shared with the TD. In the event that the TD writes to this page, a copy will be generated. In order to obtain a correct measurement, the MA will need to be updated to look at the copy rather than the (about to change) original. To simplify this task, Xen maintains this reverse mapping, so that whenever a page fault occurs in the TD that generates a new copy, Xen can transparently update the MA mappings of this page. Without this mapping, Xen would be forced to do a complete page table walk of the MA to determine where the page was mapped in, which is a very expensive operation.","When the hypercall unsnapshot (td) is received by Xen, the hypervisor completes the following sequence of operations:","1. Unmark CoW flags for all pages in TD;","2. Revert R\/W flag for all PTE's in TD to original value;","3. Unmap any TD pages (originals or copies) mapped by the MA; and","4. Free all page copies and scrub their contents.","These operations are straightforward. All of the flags in the page_info struct are returned to their prior state, and all PTE's revert to their pre-CoW state as well (for uncopied pages, the PTE's for any copied pages were already reverted). All of the copies are then freed and placed on a scrub list to clear the content of the pages. The domain changes are also cleaned up, such as unmarking the enable CoW flag; these steps are again straightforward.","The methodology for ensuring CoW is functioning properly from the target domain's perspective is to compare the memory at the actual time of the snapshot with the CoW copies and current pages at the time the snapshot ends. Hence, for testing purposes, when snapshot (td) is called, a full copy of the td's memory is created. At unsnapshot (td), a check of all pages owned by the domain is made to ensure that any CoW copies are the same as the original and any uncopied current pages are also the same as the original, as they must not have been modified (else they would have been copied). A series of tests were run including domains while idle, running a memory intensive application, and building the Linux kernel. These tests all showed that the method of invention correctly copied pages, apart from the console \u201cmagic page\u201d that dom0 updates on keyboard input. This page is not a shared page and is set up by dom0 when the domain is created, and is not specifically tracked by Xen.","The method of the invention is compared with the goals of solving the coherency problem described above and repeated here:\n\n","The method of the invention using CoW accomplishes the first goal of obtaining an atomic measurement. As described herein, for the tests run, at the end of CoW, any pages modified by the TD were successfully copied before modification, and any uncopied pages were the same as at the beginning of CoW. As discussed above, the quiescence problem is not addressed by the inventive method.","While the inventive method does not require the target to participate in measurement, enforcing that measurement is undetectable is more challenging. The method for forcing page faults on writes changes all of the page table entries of the TD. Since a paravirtualized guest has access to its page tables, it would not be difficult for the TD to notice that all of the entries have changed. However, at this point, it would be too late for the target to change things to avoid detection, because CoW will already be active. So, the TD may know that it is being measured, but be unable to affect measurement. Xen's shadow page mode can eliminate this detection, as this implements another level of indirection in the page tables, so the pages used by the machine are different from the pages the domain uses. It is also possible that the TD may be able to observe other resource usage, particularly if running on a single processor that is shared with the MA.","The performance results are based on a target domain that runs as a dom U and a measurement domain running as dom0. The measurement was run from dom0 since mapping another domain's memory is a privileged operation that cannot normally be done by a dom U.","Some performance results comparing Linux kernel measurements with LKIM using the CoW method of the invention, measurement that pauses the TD, and no measurement are now presented. All benchmarks were run on a Dell Optiplex 745 with an Intel Core2 Duo 2.66 GHz processor, with the TD pinned to one processor, and the MA pinned to the other; hence, both the TD and MA are running as single processor domains, but are dedicated to different processors. Pinning the TD and MA to different CPUs allows accurate determination of the effects of each measurement strategy on the benchmarks without measurement competing for the CPU that the TO is using. The benchmarks used are compiling the Linux kernel and Webstone 2.5, a network-based benchmark.","The LKIM configuration used in the experiments performs measurement of the Linux kernel's virtual file system (VFS). As discussed herein, other portions of the kernel could be measured, which may cause an additional impact on performance. Recall from previous discussions that the entire memory of the TD is being snapshotted, which is reflected in the results (particularly the memory overhead due to the full copy strategy).","While comparisons between CoW and pausing the TD are given, it is important to note that pausing the TD means the TD is inactive for the length of measurement, while CoW allows the target to run. This alone presents a significant improvement of CoW over the former approach, as the TD will only be paused for short periods of time for CoW initialization and deinitialization (approx. 5-7 milliseconds in both cases), and when handling page faults.","Building the Linux kernel is a good test of memory usage, CPU usage, and disk I\/O. Table 2 shows a comparison of compiling the Linux kernel with four different measurement strategies: no measurement, pause the TD during measurement, perform a full copy of the TD's memory, and enable CoW of the TD during measurement.","For these benchmarks, the TD had 256 MB of memory. The strategy for performing measurement was to run LKIM on the TD every five seconds (i.e. measure, then sleep for five seconds before measuring again). The results in Table 2 consist of an average over 10 kernel builds.",{"@attributes":{"id":"p-0091","num":"0118"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"105pt","align":"center"}}],"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Measure","Avg. #","Avg. Meas.","Avg. Overhead per Measurement"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"8"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"42pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Strategy","Runtime","Diff.","Meas.","Time","Init.","Deinit.","Memory"]},{"entry":{"@attributes":{"namest":"1","nameend":"8","align":"center","rowsep":"1"}}},{"entry":["None","5.21.19","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"8"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"21pt","align":"right"}},{"@attributes":{"colname":"8","colwidth":"21pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["Pause TD","5.59.02","11.77%","59.4","0.952 s","636.8 ms","0","MB"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"9"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"21pt","align":"right"}},{"@attributes":{"colname":"9","colwidth":"21pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Full Copy","5.35.94","4.59%","55.1","1.076 s","173.52 ms","4.85 ms","256.0","MB"]},{"entry":["COW","5.26.11","1.53%","54.3","0.989 s","\u20035.91 ms","6.07 ms","18.1","MB"]},{"entry":{"@attributes":{"namest":"1","nameend":"9","align":"center","rowsep":"1"}}}]}}]}}},"The left portion of Table 2 shows the average per-build characteristics: the average kernel build time over the 10 builds, the average difference of each strategy with no measurement, and the average number of measurements completed per build (note that longer runtimes mean more measurements will be done). The right portion of the table shows the per-measurement characteristics: average time of each measurement, and average overhead per measurement, including average initialization and deinitialization time (when the target is paused), and average additional memory usage. Note that pausing the TD has no distinction of initialization\/deinitialization, since the TD is paused for the length of measurement; also note that the difference between measurement time and overhead time is due to LKIM performing some initialization before actual measurement and outputting the results after measurement. Initialization of the full copy consists of copying the entire memory of the TD, and deinitialization releases that memory. CoW initialization (Snapshot), and CoW deinitialization (Unsnapshot) are as described herein.","In these experiments, pausing the TD caused the most significant slowdown to the kernel build, with more than eleven percent increase in the build time. While the average measurement time was the least in this strategy, the TD was down for more than half a second per measurement. Performing a full copy at each measurement introduces less overhead to the kernel build time than pausing the TD, but requires a large memory overhead to achieve. The initialization time to copy all of the memory takes a significant amount of time all at once, and will increase with the amount of memory given to the TD. Measurement time also takes longer, which is most likely due to the required translation process of the MA asking for pages based on the original addresses, which must be remapped to where the copies reside.","Of the three strategies, CoW had the best performance on building the Linux kernel, adding just over one and a half percent to the build time. The additional measurement time compared with pausing the TD is negligible. The average initialization and deinitialization times show that the TD will be paused for about 6 ms at a time, much improved over the other strategies. Considering the savings in downtime of the TD, the additional 18 MB of memory overhead is manageable, especially when compared with performing a full copy.","In order to test the impact of CoW-enabled measurements on network I\/O, the Webstone 2.5 benchmark was run; this benchmark uses several clients to fetch pages from a web server. In the results, the TD was the server and the clients were running on a remote machine. The TD had 256 MB of memory. Table 3 shows a comparison of this benchmark between the same strategies as before: no measurement, pause the TD during measurement, perform a full copy of the TD's memory, and enable copy-on-write of the TD during measurement.",{"@attributes":{"id":"p-0096","num":"0123"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"9"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"9","colwidth":"105pt","align":"center"}}],"thead":{"row":{"entry":"TABLE 3"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"9","align":"center","rowsep":"1"}}},{"entry":[{},{},"Server",{},{},{},{},{},{}]},{"entry":["Measure",{},"Thruput",{},"Avg. Resp.",{},"Avg. #","Avg. Meas.","Avg. Overhead per Measurement"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"11"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"9","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"10","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"11","colwidth":"42pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Strategy","Runtime","(Mb\/sec)","Diff","Time","Diff","Meas.","Time","Init.","Deinit.","Memory"]},{"entry":{"@attributes":{"namest":"1","nameend":"11","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"11"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"9","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"10","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"11","colwidth":"42pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["None","20 m","92.618","\u2014","0.0553 s","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"11"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"9","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"10","colwidth":"21pt","align":"right"}},{"@attributes":{"colname":"11","colwidth":"21pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["Pause TD","20 m","90.234","2.57%","0.0568 s","2.7%","225.8","0.315 s","161.93 ms","0","MB"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"12"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"9","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"10","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"11","colwidth":"21pt","align":"right"}},{"@attributes":{"colname":"12","colwidth":"21pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Full Copy","20 m","90.25","2.55%","0.0567 s","2.53%\u2002","217.4","0.509 s","161.97 ms","5.29 ms","256.0","MB"]},{"entry":["CoW","20 m","92.606","0.01%","0.0553 s","\u2002\u20090%","224.6","0.333 s","\u20036.59 ms","5.97 ms","1.4","MB"]},{"entry":{"@attributes":{"namest":"1","nameend":"12","align":"center","rowsep":"1"}}}]}}]}}},"The strategy for performing measurement, was as before, to run LKIM on the TD every five seconds (i.e. measure, then sleep for five seconds before measuring again). The results in Table 3 consist of an average over 5 runs of Webstone.","The benchmark results shown are Server Thruput (higher is better) and Average Response Time (lower is better). This benchmark is less file system intensive, so it does not take LKIM as long to perform measurement. Hence pausing the TD or performing a full copy causes less than a three percent overhead to the results. Interestingly, the amount of time it takes to perform the full copy of memory takes about the same amount of time as when pausing the TD, but uses an additional 256 MB of memory.","Enabling CoW for measurement performs essentially the same as the benchmark with no measurement. For both the Server Thruput and Average Response Time, CoW performs better than both Pausing the TD and Full Copy, with a slight decrease in the amount of measurement time compared with Pausing the TD. The reduced performance for the naive strategies is likely a result of the TD being paused for longer periods of time all at once. CoW permits the TD to run while being measured, which improves the liveness of the server. The amount of memory overhead for CoW is small, since the measurement time is short, and the webserver does not modify much memory when serving these pages.","In the benchmark experiments, the Cow method of the invention for enforcing atomicity caused a significant decrease in the time overhead that measurement imposes on the target. The memory overhead of CoW during measurement is relatively small and substantially less than the full copy strategy. In addition, CoW pauses the TD for much less time than the other approaches, thereby improving the liveness of the TD during measurement.","The experiments used an LKIM configuration that measured the virtual file system (VFS) of the Linux kernel. Measuring more of the kernel, such as the scheduler, device driver, and networking systems would cause an increase in the length of measurement time and the size of memory being measured. Additionally, the size of the kernel's object graph grows with the activeness of a domain. So, as a domain becomes more active, the data structures maintained by the kernel become larger. Both of these concerns\u2014increasing the size of the kernel's object graph and measuring more of the object graph\u2014will contribute to longer measurement runtimes, and therefore larger overhead due to measurement. The value of inventive CoW method to support atomicity of measurement will be greater as measurement runtime increases.","It should be apparent to those skilled in the art that the present invention may be embodied in many other specific forms without departing from the spirit or scope of the invention. Therefore, the present examples and embodiments are to be considered as illustrative and not restrictive, and the invention is not to be limited to the details given herein, but may be modified within the scope of the appended claims."],"GOVINT":[{},{}],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The teachings of the present invention can be readily understood by considering the following detailed description in conjunction with the accompanying drawings, in which:",{"@attributes":{"id":"p-0040","num":"0047"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0041","num":"0048"},"figref":"FIG. 2"}]},"DETDESC":[{},{}]}
