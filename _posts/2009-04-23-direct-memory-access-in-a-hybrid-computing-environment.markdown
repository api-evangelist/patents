---
title: Direct memory access in a hybrid computing environment
abstract: DMA in a computing environment that includes several computers and DMA engines, the computers adapted to one another for data communications by an data communications fabric, each computer executing an application, where DMA includes: pinning, by a first application, a memory region, including providing, to all applications, information describing the memory region; effecting, by a second application in dependence upon the information describing the memory region, DMA transfers related to the memory region, including issuing DMA requests to a particular DMA engine for processing; and unpinning, by the first application, the memory region, including insuring, prior to unpinning, that no additional DMA requests related to the memory region are issued, that all outstanding DMA requests related to the memory region are provided to a DMA engine, and that processing of all outstanding DMA requests related to the memory region and provided to a DMA engine has been completed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08037217&OS=08037217&RS=08037217
owner: International Business Machines Corporation
number: 08037217
owner_city: Armonk
owner_country: US
publication_date: 20090423
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF EXEMPLARY EMBODIMENTS"],"p":["1. Field of the Invention","The field of the invention is data processing, or, more specifically, methods, apparatus, and products for direct memory access in a hybrid computing environment.","2. Description of Related Art","The development of the EDVAC computer system of 1948 is often cited as the beginning of the computer era. Since that time, computer systems have evolved into extremely complicated devices. Today's computers are much more sophisticated than early systems such as the EDVAC. Computer systems typically include a combination of hardware and software components, application programs, operating systems, processors, buses, memory, input\/output (\u2018I\/O\u2019) devices, and so on. As advances in semiconductor processing and computer architecture push the performance of the computer higher and higher, more sophisticated computer software has evolved to take advantage of the higher performance of the hardware, resulting in computer systems today that are much more powerful than just a few years ago.","Computer systems today have advanced such that some computing environments now include core components of different architectures which operate together to complete data processing tasks. Such computing environments are described in this specification as \u2018hybrid\u2019 environments, denoting that such environments include host computers and accelerators having different architectures. Although hybrid computing environments are more computationally powerful and efficient in data processing than many non-hybrid computing environments, such hybrid computing environments still present substantial challenges to the science of automated computing machinery.","Methods, apparatus, and products for direct memory access (\u2018DMA\u2019) in a hybrid computing environment where the hybrid computing environment includes a host computer having a host computer architecture, an accelerator having an accelerator architecture, the accelerator architecture optimized, with respect to the host computer architecture, for speed of execution of a particular class of computing functions, the host computer and the accelerator adapted to one another for data communications by a system level message passing module. DMA in such a hybrid computing environment in accordance with embodiments of the present invention includes identifying, by the system level message passing module, a buffer of data to be transferred from the host computer to the accelerator according to a DMA protocol; segmenting, by the system level message passing module, the buffer of data into a predefined number of memory segments; pinning, by the system level message passing module, the memory segments against paging; and asynchronously with respect to pinning the memory segments, effecting, by the system level message passing module, DMA transfers of the pinned memory segments from the host computer to the accelerator.","The foregoing and other objects, features and advantages of the invention will be apparent from the following more particular descriptions of exemplary embodiments of the invention as illustrated in the accompanying drawings wherein like reference numbers generally represent like parts of exemplary embodiments of the invention.","Exemplary methods, apparatus, and products for direct memory access (\u2018DMA\u2019) in a hybrid computing environment according to embodiments of the present invention are described with reference to the accompanying drawings, beginning with .  sets forth a diagram of an example hybrid computing environment () useful for DMA according to embodiments of the present invention. A \u2018hybrid computing environment,\u2019 as the term is used in this specification, is a computing environment in that it includes computer processors operatively coupled to computer memory so as to implement data processing in the form of execution of computer program instructions stored in the memory and executed on the processors. In addition, the hybrid computing environment () in the example of  includes at least one host computer having a host architecture that operates in cooperation with an accelerator having an accelerator architecture where the host architecture and accelerator architecture are different architectures. The host and accelerator architectures in this example are characterized by architectural registers, registers that are accessible by computer program instructions that execute on each architecture, registers such as, for example, an instruction register, a program counter, memory index registers, stack pointers, and the like. That is, the number, type, structure, and relations among the architectural registers of the two architectures are different, so different that computer program instructions compiled for execution on the host computer of a hybrid computing environment typically cannot be executed natively by any associated accelerator of the hybrid computing environment.","Examples of hybrid computing environments include a data processing system that in turn includes one or more host computers, each having an x86 processor, and accelerators whose architectural registers implement the PowerPC instruction set. Computer program instructions compiled for execution on the x86 processors in the host computers cannot be executed natively by the PowerPC processors in the accelerators. Readers will recognize in addition that some of the example hybrid computing environments described in this specification are based upon the Los Alamos National Laboratory (\u2018LANL\u2019) supercomputer architecture developed in the LANL Roadrunner project (named for the state bird of New Mexico), the supercomputer architecture that famously first generated a \u2018petaflop,\u2019 a million billion floating point operations per second. The LANL supercomputer architecture includes many host computers with dual-core AMD Opteron processors coupled to many accelerators with IBM Cell processors, the Opteron processors and the Cell processors having different architectures.","The example hybrid computing environment () of  includes a plurality of compute nodes (), I\/O nodes (), and a service node (). The compute nodes () are coupled through network () for data communications with one another and with the I\/O nodes () and the service node (). The data communications network () may be implemented as an Ethernet, Internet Protocol (\u2018IP\u2019), PCIe, Infiniband, Fibre Channel, or other network as will occur to readers of skill in the art.","In the example hybrid computing environment () of , the compute nodes carry out principal user-level computer program execution, accepting administrative services, such as initial program loads and the like, from the service application () executing on the service node () and gaining access to data storage () and I\/O functionality (, ) through the I\/O nodes (). In the example of , the I\/O nodes () are connected for data communications to I\/O devices (, , ) through a local area network (\u2018LAN\u2019) () implemented using high-speed Ethernet or a data communications fabric of another fabric type as will occur to those of skill in the art. I\/O devices in the example hybrid computing environment () of  include non-volatile memory for the computing environment in the form of data storage device (), an output device for the hybrid computing environment in the form of printer (), and a user () I\/O device in the form of computer terminal () that executes a service application interface () that provides to a user an interface for configuring compute nodes in the hybrid computing environment and initiating execution by the compute nodes of principal user-level computer program instructions.","In the example of , each compute node includes a host computer () having a host computer architecture and one or more accelerators () having an accelerator architecture. A host computer () is a \u2018host\u2019 in the sense that it is the host computer that carries out interface functions between a compute node and other components of the hybrid computing environment external to any particular compute node. That is, it is the host computer that executes initial boot procedures, power on self tests, basic I\/O functions, accepts user-level program loads from service nodes, and so on. An accelerator () is an \u2018accelerator\u2019 in that each accelerator has an accelerator architecture that is optimized, with respect to the host computer architecture, for speed of execution of a particular class of computing functions. Such accelerated computing functions include, for example, vector processing, floating point operations, and others as will occur to those of skill in the art.","Because each of the compute nodes in the example of  includes a host computer and an accelerator, readers of skill in the art will recognize that each compute node represents a smaller, separate hybrid computing environment within the larger hybrid computing environment () of . That is, not only may the combination of the compute nodes () form a hybrid computing environment (), but it is also the case that each individual compute node may also be viewed as a separate, smaller hybrid computing environment. The hybrid computing environment () in the example of  then, may be viewed as composed of nine separate, smaller hybrid computing environments, one for each compute node, which taken together form the hybrid computing environment () of .","Within each compute node () of , a host computer () and one or more accelerators () are adapted to one another for data communications by a system level message passing module (\u2018SLMPM\u2019) () and by two or more data communications fabrics (, ) of at least two different fabric types. An SLMPM () is a module or library of computer program instructions that exposes an application programming interface (\u2018API\u2019) to user-level applications for carrying out message-based data communications between the host computer () and the accelerator (). Examples of message-based data communications libraries that may be improved for use as an SLMPM according to embodiments of the present invention include:\n\n","A data communications fabric (, ) is a configuration of data communications hardware and software that implements a data communications coupling between a host computer and an accelerator. Examples of data communications fabric types include Peripheral Component Interconnect (\u2018PCI\u2019), PCI express (\u2018PCIe\u2019), Ethernet, Infiniband, Fibre Channel, Small Computer System Interface (\u2018SCSI\u2019), External Serial Advanced Technology Attachment (\u2018eSATA\u2019), Universal Serial Bus (\u2018USB\u2019), and so on as will occur to those of skill in the art.","The arrangement of compute nodes, data communications fabrics, networks, I\/O devices, service nodes, I\/O nodes, and so on, making up the hybrid computing environment () as illustrated in  are for explanation only, not for limitation of the present invention. Hybrid computing environments capable of DMA according to embodiments of the present invention may include additional nodes, networks, devices, and architectures, not shown in , as will occur to those of skill in the art. Although the hybrid computing environment () in the example of  includes only nine compute nodes (), readers will note that hybrid computing environments according to embodiments of the present invention may include any number of compute nodes. The LANL supercomputer, taken as an example of a hybrid computing environment with multiple compute nodes, contains as of this writing more than 12,000 compute nodes. Networks and data communications fabrics in such hybrid computing environments may support many data communications protocols including for example TCP (Transmission Control Protocol), IP (Internet Protocol), and others as will occur to those of skill in the art. Various embodiments of the present invention may be implemented on a variety of hardware platforms in addition to those illustrated in .","The example hybrid computing environment () of  is configured for DMA according to embodiments of the present invention. As explained below in more detail, DMA as the term is used in this specification is a data communications protocol for passing data between a host computer and an accelerator with reduced operational burden on computer processor of the host computer and accelerator. DMA is carried out in the hybrid computing environment of  by pinning, by a first application, such as a host application (), executing on a first computer, a host computer (), a memory region () for DMA () transfer of data (), including providing, to all applications (, ) executing in the computing environment (), information () describing the memory region (). The second application, such as the accelerator application () executing on a second computer (), the accelerator (), effects DMA transfers related to the memory region () in dependence upon the information () describing the memory region (), including issuing DMA requests () to a particular DMA engine () for processing.","In computing environments of the prior art that include multiple applications and computers that effect DMA transfers with pinned memory regions, problems typically arise when the first application attempts to unpin the memory region. One example problem that typically occurs is that after the first application unpins the memory region, a second application issues a DMA transfer to a DMA engine where the DMA transfer is related to that memory region. Another problem that may arise is after the first application unpins the memory region, a DMA engine having previously been issued a DMA request related to the now-unpinned memory region, continues to carry out that request\u2014reading data from or writing data to a now-stale memory region. Further, the first application after unpinning may begin using the memory region for non-DMA purposes, while other applications and DMA engines use the memory region for DMA, making the data corrupt from one objects perspective or the other.","By contrast to computing environments of the prior art having multiple problems in unpinning memory regions use for DMA, the first application () in the example computing environment of  unpins the memory region (), and insures, prior to unpinning, that no additional DMA requests related to the memory region are issued, that all outstanding DMA requests related to the memory region are provided to a DMA engine, and that processing of all outstanding DMA requests related to the memory region and provided to a DMA engine () has been completed.","For further explanation,  sets forth a block diagram of an exemplary hybrid computing environment () useful for DMA according to embodiments of the present invention. The hybrid computing environment () of  includes four compute nodes. Similar to the compute nodes of , each of the compute nodes in the example of  may represent a small, separate hybrid computing environment which taken together make up a larger hybrid computing environment. One compute node () in the example of  is illustrated in an expanded view to aid a more detailed explanation of such a hybrid computing environment (). As shown in the expanded view of compute node (), each of the compute nodes (, ) in the example of  includes a host computer (). The host computer () includes a computer processor () operatively coupled to computer memory, Random Access Memory (\u2018RAM\u2019) (), through a high speed memory bus (). The processor () in each host computer () has a set of architectural registers () that defines the host computer architecture.","Each of the compute nodes also includes one or more accelerators (, ). Each accelerator (, ) includes a computer processor () operatively coupled to RAM () through a high speed memory bus (). Stored in RAM (,) of the host computer and the accelerators (, ) is an operating system (). Operating systems useful in host computers and accelerators of hybrid computing environments according to embodiments of the present invention include UNIX\u2122, Linux\u2122, Microsoft XP\u2122, Microsoft Vista\u2122, Microsoft NT\u2122, AIX\u2122, IBM's i5\/OS\u2122, and others as will occur to those of skill in the art. There is no requirement that the operating system in the host computers should be the same operating system used on the accelerators.","The processor () of each accelerator (, ) has a set of architectural registers () that defines the accelerator architecture. The architectural registers () of the processor () of each accelerator are different from the architectural registers () of the processor () in the host computer (). With differing architectures, it would be uncommon, although possible, for a host computer and an accelerator to support the same instruction sets. As such, computer program instructions compiled for execution on the processor () of an accelerator () generally would not be expected to execute natively on the processor () of the host computer () and vice versa. Moreover, because of the typical differences in hardware architectures between host processors and accelerators, computer program instructions compiled for execution on the processor () of a host computer () generally would not be expected to execute natively on the processor () of an accelerator () even if the accelerator supported the instruction set of the host. The accelerator architecture in example of  is optimized, with respect to the host computer architecture, for speed of execution of a particular class of computing functions. That is, for the function or functions for which the accelerator is optimized, execution of those functions will proceed faster on the accelerator than if they were executed on the processor of the host computer.","In the example of , the host computer () and the accelerators (, ) are adapted to one another for data communications by a system level message passing module (\u2018SLMPM\u2019) () and two data communications fabrics (, ) of at least two different fabric types. In this example, to support message-based data communications between the host computer () and the accelerator (), both the host computer () and the accelerator () have an SLMPM () so that message-based communications can both originate and be received on both sides of any coupling for data communications. Also in the example of , the host computer () and the accelerators (, ) are adapted to one another for data communications by a PCIe fabric () through PCIe communications adapters () and an Ethernet fabric () through Ethernet communications adapters (). The use of PCIe and Ethernet is for explanation, not for limitation of the invention. Readers of skill in the art will immediately recognize that hybrid computing environments according to embodiments of the present invention may include fabrics of other fabric types such as, for example, PCI, Infiniband, Fibre Channel, SCSI, eSATA, USB, and so on.","The SLMPM () in this example operates generally for data processing in a hybrid computing environment () by monitoring data communications performance for a plurality of data communications modes between the host computer () and the accelerators (, ), receiving a request () to transmit data according to a data communications mode from the host computer to an accelerator, determining whether to transmit the data according to the requested data communications mode, and if the data is not to be transmitted according to the requested data communications mode: selecting another data communications mode and transmitting the data according to the selected data communications mode. In the example of , the monitored performance is illustrated as monitored performance data () stored by the SLMPM () in RAM () of the host computer () during operation of the compute node ().","A data communications mode specifies a data communications fabric type, a data communications link, and a data communications protocol (). A data communications link () is data communications connection between a host computer and an accelerator. In the example of , a link () between the host computer () and the accelerator () may include the PCIe connection () or the Ethernet connection (, ) through the Ethernet network (). A link () between the host computer () and the accelerator () in the example of , may include the PCIe connection () or the Ethernet connection (, ) through the Ethernet network (). Although only one link for each fabric type is illustrated between the host computer and the accelerator in the example of , readers of skill in the art will immediately recognize that there may any number of links for each fabric type.","A data communications protocol is a set of standard rules for data representation, signaling, authentication and error detection required to send information from a host computer () to an accelerator (). In the example of , the SLMPM () may select one of several protocols () for data communications between the host computer () and the accelerator. Examples of such protocols () include shared memory transfers (\u2018SMT\u2019) () executed with a send and receive operations (), and direct memory access (\u2018DMA\u2019) () executed with PUT and GET operations ().","Shared memory transfer is a data communications protocol for passing data between a host computer and an accelerator into shared memory space () allocated for such a purpose such that only one instance of the data resides in memory at any time. Consider the following as an example shared memory transfer between the host computer () and the accelerator () of . An application () requests () a transmission of data () from the host computer () to the accelerator () in accordance with the SMT () protocol. Such a request () may include a memory address allocated for such shared memory. In this example, the shared memory segment () is illustrated in a memory location on the accelerator (), but readers will recognize that shared memory segments may be located on the accelerator (), on the host computer (), on both the host computer and the accelerator, or even off the local compute node () entirely\u2014so long as the segment is accessible as needed by the host and the accelerator. To carry out a shared memory transfer, the SLMPM () on the host computer () establishes a data communications connection with the SLMPM () executing on the accelerator () by a handshaking procedure similar to that in the TCP protocol. The SLMPM () then creates a message () that includes a header and a payload data and inserts the message into a message transmit queue for a particular link of a particular fabric. In creating the message, the SLMPM inserts, in the header of the message, an identification of the accelerator and an identification of a process executing on the accelerator. The SLMPM also inserts the memory address from the request () into the message, either in the header or as part of the payload data. The SLMPM also inserts the data () to be transmitted in the message () as part of the message payload data. The message is then transmitted by a communications adapter (, ) across a fabric (, ) to the SLMPM executing on the accelerator () where the SLMPM stores the payload data, the data () that was transmitted, in shared memory space () in RAM () in accordance with the memory address in the message.","Direct memory access (\u2018DMA\u2019) is a data communications protocol for passing data between a host computer and an accelerator with reduced operational burden on the computer processor (). A DMA transfer essentially effects a copy of a block of memory from one location to another, typically from a host computer to an accelerator or vice versa. Either or both a host computer and accelerator may include DMA engine, an aggregation of computer hardware and software for direct memory access. Direct memory access includes reading and writing to memory of accelerators and host computers with reduced operational burden on their processors. A DMA engine of an accelerator, for example, may write to or read from memory allocated for DMA purposes, while the processor of the accelerator executes computer program instructions, or otherwise continues to operate. That is, a computer processor may issue an instruction to execute a DMA transfer, but the DMA engine, not the processor, carries out the transfer.","In the example of , only the accelerator () includes a DMA engine () while the host computer does not. In this embodiment the processor () on the host computer may initiate a DMA transfer of data from the host to the accelerator in one of several ways: by sending a message according to the SMT protocol to the accelerator, instructing the accelerator to perform a remote \u2018GET\u2019 operation, or by direct communications with the DMA engine through the PCIe fabric (). The configuration illustrated in the example of  in which the accelerator () is the only device containing a DMA engine is for explanation only, not for limitation. Readers of skill in the art will immediately recognize that in many embodiments, both a host computer and an accelerator may include a DMA engine, while in yet other embodiments only a host computer includes a DMA engine.","To implement a DMA protocol in the hybrid computing environment of  some memory region is allocated for access by the DMA engine. Allocating such memory may be carried out independently from other accelerators or host computers, or may be initiated by and completed in cooperation with another accelerator or host computer. Shared memory regions, allocated according to the SMA protocol, for example, may be memory regions made available to a DMA engine. That is, the initial setup and implementation of DMA data communications in the hybrid computing environment () of  may be carried out, at least in part, through shared memory transfers or another out-of-band data communications protocol, out-of-band with respect to a DMA engine. Allocation of memory to implement DMA transfers is relatively high in latency, but once allocated, the DMA protocol provides for high bandwidth data communications that requires less processor utilization than many other data communications protocols.","A direct \u2018PUT\u2019 operation is a mode of transmitting data from a DMA engine on an origin device to a DMA engine on a target device. A direct \u2018PUT\u2019 operation allows data to be transmitted and stored on the target device with little involvement from the target device's processor. To effect minimal involvement from the target device's processor in the direct \u2018PUT\u2019 operation, the origin DMA engine transfers the data to be stored on the target device along with a specific identification of a storage location on the target device. The origin DMA knows the specific storage location on the target device because the specific storage location for storing the data on the target device has been previously provided by the target DMA engine to the origin DMA engine.","A remote \u2018GET\u2019 operation, sometimes denominated an \u2018rGET,\u2019 is another mode of transmitting data from a DMA engine on an origin device to a DMA engine on a target device. A remote \u2018GET\u2019 operation allows data to be transmitted and stored on the target device with little involvement from the origin device's processor. To effect minimal involvement from the origin device's processor in the remote \u2018GET\u2019 operation, the origin DMA engine stores the data in an storage location accessible by the target DMA engine, notifies the target DMA engine, directly or out-of-band through a shared memory transmission, of the storage location and the size of the data ready to be transmitted, and the target DMA engine retrieves the data from storage location.","Monitoring data communications performance for a plurality of data communications modes may include monitoring a number of requests () in a message transmit request queue (-) for a data communications link (). In the example of , each message transmit request queue (-) is associated with one particular data communications link (). Each queue (-) includes entries for messages () that include data () to be transmitted by the communications adapters (, ) along a data communications link () associated with queue.","Monitoring data communications performance for a plurality of data communications modes may also include monitoring utilization of a shared memory space (). In the example of , shared memory space () is allocated in RAM () of the accelerator. Utilization is the proportion of the allocated shared memory space to which data has been stored for sending to a target device and has not yet been read or received by the target device, monitored by tracking the writes and reads to and from the allocated shared memory. In the hybrid computing environment () of FIG. , shared memory space, any memory in fact, is limited. As such, a shared memory space () may be filled during execution of an application program () such that transmission of data from the host computer () to an accelerator may be slowed, or even stopped, due to space limitations in the shared memory space.","In some embodiments of the present invention, the hybrid computing environment () of  may be configured to operate as a parallel computing environment in which two or more instances the application program () executes on two or more host computers () in the parallel computing environment. In such embodiments, monitoring data communications performance across data communications modes may also include aggregating data communications performance information () across a plurality of instances of the application program () executing on two or more host computers in a parallel computing environment. The aggregated performance information () may be used to calculate average communications latencies for data communications modes, average number of requests in data communications links of a particular fabric type, average shared memory utilization among the plurality of host computers and accelerators in the parallel computing environment, and so on as will occur to those of skill in the art. Any combination of such measures may be used by the SLMPM for both determining whether to transmit the data according to requested data communications mode and selecting another data communications mode for transmitting the data if the data is not to be transmitted according to the requested data communications mode.","The SLMPM () of  receives, from an application program () on the host computer (), a request () to transmit data () according to a data communications mode from the host computer () to the accelerator (). Such data () may include computer program instructions compiled for execution by the accelerator (), work piece data for an application program executing on the accelerator (), or some combination of computer program instructions and work piece data. Receiving a request () to transmit data () according to a data communications mode may include receiving a request to transmit data by a specified fabric type, receiving a request to transmit data through a specified data communications link from the host computer to the accelerator, or receiving a request to transmit data from the host computer to the accelerator according to a protocol.","A request () to transmit data () according to a data communications mode may be implemented as a user-level application function call through an API to the SLMPM (), a call that expressly specifies a data communications mode according to protocol, fabric type, and link. A request implemented as a function call may specify a protocol according to the operation of the function call itself. A dacs_put( ) function call, for example, may represent a call through an API exposed by an SLMPM implemented as a DACS library to transmit data in the default mode of a DMA \u2018PUT\u2019 operation. Such a call, from the perspective of the calling application and the programmer who wrote the calling application, represents a request to the SLMPM library to transmit data according to the default mode, known to the programmer to be default mode associated with the express API call. The called function, in this example dacs_put( ), may be coded according to embodiments of the present invention, to make its own determination whether to transmit the data according to the requested data communications mode, that is, according to the default mode of the called function. In a further example, a dacs_send( ) instruction may represent a call through an API exposed by an SLMPM implemented as a DACS library to transmit data in the default mode of an SMT \u2018send\u2019 operation, where the called function dacs_send( ) is again coded according to embodiments of the present invention to make its own determination whether to transmit the data according to the requested mode.","An identification of a particular accelerator in a function call may effectively specify a fabric type. Such a function call may include as a call parameters an identification of a particular accelerator. An identification of a particular accelerator by use of a PCIe ID, for example, effectively specifies a PCI fabric type. In another, similar, example, an identification of a particular accelerator by use of a media access control (\u2018MAC\u2019) address of an Ethernet adapter effectively specifies the Ethernet fabric type. Instead of implementing the accelerator ID of the function call from an application executing on the host in such a way as to specify a fabric type, the function call may only include a globally unique identification of the particular accelerator as a parameter of the call, thereby specifying only a link from the host computer to the accelerator, not a fabric type. In this case, the function called may implement a default fabric type for use with a particular protocol. If the function called in the SLMPM is configured with PCIe as a default fabric type for use with the DMA protocol, for example, and the SLMPM receives a request to transmit data to the accelerator () according to the DMA protocol, a DMA PUT or DMA remote GET operation, the function called explicitly specifies the default fabric type for DMA, the PCIe fabric type.","In hybrid computing environments in which only one link of each fabric type adapts a single host computer to a single accelerator, the identification of a particular accelerator in a parameter of a function call, may also effectively specify a link. In hybrid computing environments where more than one link of each fabric type adapts a host computer and an accelerator, such as two PCIe links connecting the host computer () to the accelerator (), the SLMPM function called may implement a default link for the accelerator identified in the parameter of the function call for the fabric type specified by the identification of the accelerator.","The SLMPM () in the example of  also determines, in dependence upon the monitored performance (), whether to transmit the data () according to the requested data communications mode. Determining whether to transmit the data () according to the requested data communications mode may include determining whether to transmit data by a requested fabric type, whether to transmit data through a requested data communications link, or whether to transmit data according to a requested protocol.","In hybrid computing environments, where monitoring data communications performance across data communications modes includes monitoring a number of requests in a message transmit request queue (-) for a data communications link, determining whether to transmit the data () according to the requested data communications mode may be carried out by determining whether the number of requests in the message transmit request queue exceeds a predetermined threshold. In hybrid computing environments, where monitoring data communications performance for a plurality of data communications modes includes monitoring utilization of a shared memory space, determining whether to transmit the data () according to the requested data communications mode may be carried out by determining whether the utilization of the shared memory space exceeds a predetermined threshold.","If the data is not to be transmitted according to the requested data communications mode, the SLMPM () selects, in dependence upon the monitored performance, another data communications mode for transmitting the data and transmits the data () according to the selected data communications mode. Selecting another data communications mode for transmitting the data may include selecting, in dependence upon the monitored performance, another data communications fabric type by which to transmit the data, selecting a data communications link through which to transmit the data, and selecting another data communications protocol. Consider as an example, that the requested data communications mode is a DMA transmission using a PUT operation through link () of the PCIe fabric () to the accelerator (). If the monitored data performance () indicates that the number of requests in transmit message request queue () associated with the link () exceeds a predetermined threshold, the SLMPM may select another fabric type, the Ethernet fabric (), and link (, ) through which to transmit the data (). Also consider that the monitored performance () indicates that current utilization of the shared memory space () is less than a predetermined threshold while the number of outstanding DMA transmissions in the queue () exceeds a predetermined threshold. In such a case, the SLMPM () may also select another protocol, such as a shared memory transfer, by which to transmit the data ().","Selecting, by the SLMPM, another data communications mode for transmitting the data () may also include selecting a data communications protocol () in dependence upon data communications message size (). Selecting a data communications protocol () in dependence upon data communications message size () may be carried out by determining whether a size of a message exceeds a predetermined threshold. For larger messages (), the DMA protocol may be a preferred protocol as processor utilization in making a DMA transfer of a larger message () is typically less than the processor utilization in making a shared memory transfer of a message of the same size.","As mentioned above, the SLMPM may also transmit the data according to the selected data communications mode. Transmit the data according to the selected data communications mode may include transmitting the data by the selected data communications fabric type, transmitting the data through the selected data communications link, or transmitting the data according to the selected protocol. The SLMPM () may effect a transmission of the data according to the selected data communications mode by instructing, through a device driver, the communications adapter for the data communications fabric type of the selected data communications mode to transmit the message () according to a protocol of the selected data communications mode, where the message includes in a message header, an identification of the accelerator, and in the message payload, the data () to be transmitted.","The example hybrid computing environment () of  is configured for DMA in accordance with embodiments of the present invention. Although DMA is explained here with respect to a particular type of computing environment, a hybrid computing environment, readers of skill in the art will immediately recognize that that computing environments configured for DMA in accordance with embodiments of the present invention may be implemented in a variety of ways, on a variety of hardware platforms, with varying types and numbers of computers, applications, data communications fabrics, and so on. DMA, according to embodiments of the present invention includes pinning, by a first application () executing on a first computer (), a memory region () for DMA () transfer of data, including providing, to all applications (, ) executing in the computing environment (), information () describing the memory region ().","An application, such as the example host application () of , may pin a memory region through a system call to an operating system. The application may make such a system call at any time during execution, but in many embodiments, the application makes such a system call during initial startup, immediately setting aside a memory region for use in DMA transfers. Pinning is a process typically effected upon a system call from an application by an operating system () for a virtual address or range of virtual addresses that insures those virtual addresses are not paged from primary computer memory, such as RAM, to an alternative computer memory, such as a hard disk drive, which typically requires greater time to access than the primary computer memory. That is, in some embodiments, a pinned virtual address is always mapped to a real physical address in RAM. Pinning a memory region also removes the physical addresses mapped to a pinned memory region from reallocation by the operating system as virtual addresses. That is, once a memory region is pinned, the amount of available computer memory resources for virtual address management is reduced.","Pinning a memory region () against paging may also include updating a pinning page table () or tables. The SLMPM () in some example hybrid computing environments configured for DMA according to embodiments of the present invention maintains a pinning page table () or tables that are updated upon each system call to the operating system () to register memory addresses. A pinning page table as the term is used in this specification reflects currently registered memory segments. In some embodiments the pinning page table may be one or more tables of limited size, that is, having a limited number of entries where each entry may associate a memory segment and a handle representing the physical memory addresses to which the memory segment is mapped.","In pinning a memory region () for DMA transfers in the example of , the host application () also translates virtual memory addresses () of the memory region () into DMA addresses () and inserts, into a memory region control block () for the memory region (), as the information () describing the memory region (), a valid flag () indicating whether the memory region () is available for DMA transfers, the virtual memory addresses (), and the DMA addresses () of the memory region ().","A DMA address as the term is used in this specification is an address used by a DMA engine to address computer memory, such as RAM () or RAM (), in order to write data to and read data from the computer memory. Such a DMA address may be a real address, a handle representing a real address, a real address having appended to it, additional control information, and so on as will occur to readers of skill in the art.","A memory region control block as the term is used here is any data structure or structures that stores information describing a particular memory region that is capable, whether available or not, of use in DMA transfers. In this way, each memory region control block is associated with one and only one memory region and for each memory region in the computing environment that is pinned by an application for DMA transfers, one memory region control block is established. A memory region control block () must be available to all applications in the computing environment () that carry out DMA transfers with the particular memory region with which the control block is associated. In the example of , the accelerator application () may access the memory region control block (). The memory region control block may be made available to other applications in a variety of ways including, for example, by storing the memory region control block at a well known memory address accessible by the other applications, by copying the memory region control block through non-DMA data communications and maintaining the copy in accordance with the original control block, by providing the memory address or addresses of the memory region control block to the other applications, and so on as will occur to readers of skill in the art.","The example memory region control block () includes such example information () describing the memory region () as a valid flag (), DMA addresses () of the memory region (), and virtual addresses () of the memory region (). The example memory region control block () of  includes such data for explanation only, not limitation. A memory region control block employed for DMA in accordance with embodiments of the present invention may include more or less information as context requires.","A valid flag () is a member of a memory region control block, the value of which indicates whether a particular memory region is available for DMA transfers. The valid flag () may be implemented in a variety of ways including, for example, as a boolean element the value of which may be true indicating the memory region is available for DMA transfers or false indicating the opposite, a single binary bit in which a 1 indicates that the memory region is available for DMA transfers and 1 indicates the opposite, and so on as will occur to readers of skill in the art.","DMA according to embodiments of the present invention also includes effecting, by a second application () executing on a second computer () in dependence upon the information () describing the memory region (), DMA transfers related to the memory region (), including issuing DMA requests () to a particular DMA engine () for processing. DMA transfers are said to be \u2018related to\u2019 a particular memory region when the DMA transfer effects a write of data to the particular memory region or a read of data from the particular memory region.","In the example of , the second application\u2014the accelerator application ()\u2014may effect DMA transfers related to the memory region () by incrementing an entrance count () in a DMA injection control block () associated with the second application (); determining, in dependence upon a valid flag () in a memory region control block () associated with the memory region, whether memory region () is available for DMA transfers; and if the memory region () is available for DMA transfers: incrementing an issued count () in a DMA execution control block () associated with the particular DMA engine; inserting in a DMA request () a command () to write, as a value of a completed sequence count () in the DMA execution control block (), the value of the incremented issue count () upon completion by the particular DMA engine () of the DMA request (); providing the DMA request () to the particular DMA engine () to process; and incrementing an exit count () in the DMA injection control block () associated with the second application (). The particular DMA engine () in the example of  then processes the DMA request () including writing, as the value of the completed sequence count () in the DMA execution control block (), the value of the incremented issue count () upon completion of the DMA request (). If the memory region () is not available for DMA transfers, the accelerator application () stops the DMA transfer.","A DMA injection control block () is data structure associated with a particular application that initiates DMA transfers in the computing environment, the data structure including information describing status or progress of the application in generating a DMA request and providing that DMA request to a DMA engine, typically by storing the request in a DMA queue for the DMA engine. Although only one DMA injection control block () is shown in example computing environment of  for clarity, according to embodiments of the present invention each application that carries out DMA transfers in the computing environment () is associated with one, separate DMA injection control block and each DMA injection control block is accessible by all other applications that carry out DMA transfers. The DMA injection control block may be accessible to all applications in similar ways as the memory region control block () as described above. In the example of , the DMA injection control block () associated with the accelerator application is actually stored remotely in memory () of the host computer (). DMA injection control blocks () may be established by an application upon startup of an application and maintained throughout execution of the application in the computing environment ().","The DMA injection control block of  includes a entrance count () and an exit count (). The value of the entrance count () represents the number of times the application associated with the DMA injection control block has initiated a DMA transfer. The value of the exit count () represents the number of times the application associated with DMA injection control block, after initiating a DMA transfer, has provided a generated DMA request to a DMA engine.","A DMA execution control block () is a data structure associated with one particular DMA engine in the computing environment, the data structure including information describing the status or progress of the DMA engine in completely processing a DMA request. According to some embodiments of the present invention, each DMA engine in the computing environment () is associated with one, separate DMA execution control block and is accessible by applications in the computing environment that carry out DMA transfers. The DMA execution control block may be accessible to applications that carry out DMA transfers in ways similar to the memory region control block () as described above. A DMA execution control block may be established by any application that carries out DMA transfers in the hybrid computing environment, by an operating system upon system startup, by the SLMPM (), or by other applications at other times as will occur to readers of skill in the art.","The DMA execution control block () in the example computing environment of  includes an issued count () and a completed sequence count (). The value of the issued count () represents the number of DMA requests issued to the DMA engine associated with the DMA execution control block. The value of the completed sequence count () represents the number of DMA requests completely processed by the DMA engine associated with the DMA execution control block.","A DMA request () is an instruction provided to a DMA engine that may be processed by the DMA engine causes the DMA engine to effect a transfer of data. DMA requests may include a type of instruction, PUT or GET, for example, and a list of descriptors, each descriptor representing a separate transfer of data and each descriptor including a source and destination address for data () to be transferred, among other data. According to embodiments of the present invention the second application () also inserts into a DMA request a command to write, as a value of a completed sequence count () in the DMA execution control block (), the value of the incremented issue count () upon completion by the particular DMA engine () of the DMA request (). The second application may insert such a command into a DMA request by inserting, as a last descriptor in the descriptor list of the DMA request, a descriptor that includes a source memory address of the value of the completed sequence count, and a target memory address for the completed sequence count. When the DMA engine () processes the last descriptor of the DMA request (), the DMA engine () writes the value of the incremented issue count () into the memory address for the completed sequence.","DMA according to embodiments of the present invention also includes unpinning, by the first application (), the memory region (), including insuring, prior to unpinning, that no additional DMA requests related to the memory region are issued, that all outstanding DMA requests related to the memory region are provided to a DMA engine, and that processing of all outstanding DMA requests related to the memory region and provided to a DMA engine () has been completed.","The first application () may unpin the memory region () by setting the value of the valid flag () in the memory region control block () to indicate that the memory region () is not available for DMA transfers; and unpinning only if: the entrance count () in the DMA injection control block () associated with each application () executing in the computing environment () is greater than or equal to the exit count () in the DMA injection control block (); and the completed sequence count () in the DMA execution control block () associated with each DMA engine () in the computing environment () is greater than or equal to a corresponding issued count () in the DMA execution control block ().","Setting the value of the valid flag () in the memory region control block () to indicate that the memory region () is not available for DMA transfers has the effect of insuring that no additional DMA requests related to that particular memory region () are issued by any application in the computing environment. Setting the value of the valid flag () may be carried out by changing the value to another state, switching a 1 to 0, 0 to 1, true to false, and so on as will occur to readers of skill in the art.","Determining that the entrance count () in the DMA injection control block () associated with each application () executing in the computing environment () is greater than or equal to the exit count () in the DMA injection control block () insures that all outstanding issued DMA requests related to the memory region have been sent along to the DMA engine for processing. Carrying out the determination may include reading the entrance counts in all DMA injection control blocks, reading the exit counts in all DMA injection control blocks, comparing each read entrance count to each read exit count, and if the exit count is less than its corresponding entrance count, reading the exit count iteratively until the exit count is equal to or greater than the entrance count. Because the values of the entrance and exits counts in each DMA injection control block in the computing environment are not associated with any particular memory region, the entrance counts of every DMA injection control block are compared to the exit counts to insure that, from the time immediately following changing the value of the valid flag for the memory region, all DMA requests\u2014regardless of the memory region to which they relate\u2014have been sent along to a DMA engine for processing.","Determining that the completed sequence count () in the DMA execution control block () associated with each DMA engine () in the computing environment () is greater than or equal to a corresponding issued count () in the DMA execution control block () insures that all outstanding issued DMA requests related to the memory region and provided to a DMA engine have been completely processed. Carrying out this determination may include reading each and every issued count in each and every DMA execution control block, reading each and every completed sequence count in each and every DMA execution control block, comparing each issued count to each read completed sequence count, and if the issued count is less than its corresponding completed sequence count, reading the completed sequence count iteratively until the completed sequence count is equal to or greater than the issued count. Because the values of the issued and completed sequence counts in each DMA execution control block in the computing environment are not associated with any particular memory region, the issued counts of every DMA execution control block are compared to the completed sequence counts to insure that, from the time immediately following changing the value of the valid flag for the memory region, all DMA requests provided to a DMA engine\u2014regardless of the memory region to which the request relates\u2014has been completely processed.","The hardware, software applications, computers, data communications fabrics, and other components of the computing environment of  are described here for clarity only, not limitation. Other devices, networks, computers, data structures, computer memory, and so on may be implemented in computing environments according to embodiments of the present invention.","For further explanation,  sets forth a block diagram of a further exemplary hybrid computing environment () useful for DMA according to embodiments of the present invention. The hybrid computing environment of  is similar the hybrid computing environment of , including as it does, four compute nodes (, ), each of which includes a host computer () having a host computer architecture and an accelerator () having an accelerator architecture where the accelerator architecture is optimized, with respect to the host computer architecture, for speed of execution of a particular class of computing functions. The host computer () and the accelerator () are adapted to one another for data communications by a system level message passing module () and two or more data communications fabrics (, ) of at least two different fabric types. In the example of , the host computer () is adapted to accelerator () by an Ethernet fabric () and a PCIe fabric ().","The host computer () as illustrated in the expanded view of the compute node () includes an x86 processor. An x86 processor is a processor whose architecture is based upon the architectural register set of the Intel x86 series of microprocessors, the 386, the 486, the 586 or Pentium\u2122, and so on. Examples of x86 processors include the Advanced Micro Devices (\u2018AMD\u2019) Opteron\u2122, the AMD Phenom\u2122, the AMD Athlon XP\u2122, the AMD Athlon \u2122, Intel Nehalam\u2122, Intel Pentium 4, Intel Core 2 Duo, Intel Atom, and so on as will occur to those of skill in the art. The x86 processor () in the example of Figure illustrates a set of a typical architectural registers () found in many x86 processors including, for example, an accumulator register (\u2018AX\u2019), a base register (\u2018BX\u2019), a counter register (\u2018CX\u2019), a data register (\u2018DX\u2019), a source index register for string operations (\u2018SI\u2019), a destination index for string operations (\u2018DI\u2019), a stack pointer (\u2018SP\u2019), a stack base pointer for holding the address of the current stack frame (\u2018BP\u2019), and an instruction pointer that holds the current instruction address (\u2018IP\u2019).","The accelerator () in the example of  is illustrated as a Cell Broadband Engine (\u2018CBE\u2019) having a Cell Broadband Engine Architecture (\u2018CBEA\u2019). A CBEA is a microprocessor architecture jointly developed by Sony Computer Entertainment, Toshiba, and IBM, an alliance known as \u201cSTI.\u201d Microprocessors implemented according to the CBEA are sometimes referred to as \u2018Cell\u2019 processors or simply as CBEs. The CBEA combines a general-purpose POWER architecture core, a Power Processing Element (\u2018PPE\u2019) (), of modest performance with streamlined co-processing elements, called Synergistic Processing Elements (\u2018SPEs\u2019) () which greatly accelerate multimedia and vector processing applications, as well as many other forms of dedicated computation. The CBE architecture emphasizes efficiency\/watt, prioritizes bandwidth over latency, and favors peak computational throughput over simplicity of program code.","The accelerator () of , implemented as a CBE, includes a main processor () that in this example is a Power Processing Element (\u2018PPE\u2019), eight fully-functional co-processors called SPEs (), and a high-bandwidth circular data bus connecting the PPE and the SPEs, called the Element Interconnect Bus (\u2018EIB\u2019) (). The PPE () is a POWER architecture processor with a two-way multithreaded core acting as a controller for the eight SPEs (). The term \u201cPOWER architecture\u201d here refers to IBM's different generations of processor architectures, a broad term including all products based on POWER, PowerPC and Cell architectures. The architectural registers () of the PPE () of the CBE accelerator () therefore are different from those of the x86 processor () of the host computer (). The PPE () of  includes an example set of architectural registers () of the POWER architecture, including 32 general purpose registers (\u2018GPRs\u2019), 32 floating point registers (\u2018FPRs\u2019), a fixed-point exception register (\u2018XER\u2019), a count register (\u2018CTR\u2019), a Condition register (\u2018CR\u2019), an instruction address register (\u2018IAR\u2019), a link register (\u2018LR\u2019), and a processor version register (\u2018PVR\u2019).","The SPEs () handle most of the computational workload of the CBE (). While the SPEs are optimized for vectorized floating point code execution, the SPEs also may execute operating systems, such as, for example, a lightweight, modified version of Linux with the operating system stored in local memory () on the SPE. Each SPE () in the example of  includes a Synergistic Processing Unit (\u2018SPU\u2019) (), and a Memory Flow Controller (\u2018MFC\u2019) (). An SPU () is a Reduced Instruction Set Computing (\u2018RISC\u2019) processor with 128-bit single instruction, multiple data (\u2018SIMD\u2019) organization for single and double precision instructions. In some implementations, an SPU may contain a 256 KB embedded Static RAM () for instructions and data, called local storage which is visible to the PPE () and can be addressed directly by software. Each SPU () can support up to 4 Gigabyte (\u2018GB\u2019) of local store memory. The local store does not operate like a conventional CPU cache because the local store is neither transparent to software nor does it contain hardware structures that predict which data to load. The SPUs () also implement architectural registers () different from those of the PPE which include a 128-bit, 128-entry register file (). An SPU () can operate on 16 8-bit integers, 8 16-bit integers, 4 32-bit integers, or 4 single precision floating-point numbers in a single clock cycle, as well as execute a memory operation.","The MFC () integrates the SPUs () in the CBE (). The MFC () provides an SPU with data transfer and synchronization capabilities, and implements the SPU interface to the EIB () which serves as the transportation hub for the CBE (). The MFC () also implements the communication interface between the SPE () and PPE (), and serves as a data transfer engine that performs bulk data transfers between the local storage () of an SPU () and CBE system memory, RAM (), through DMA. By offloading data transfer from the SPUs () onto dedicated data transfer engines, data processing and data transfer proceeds in parallel, supporting advanced programming methods such as software pipelining and double buffering. Providing the ability to perform high performance data transfer asynchronously and in parallel with data processing on the PPE () and SPEs (), the MFC () eliminates the need to explicitly interleave data processing and transfer at the application level.","The SLMPM () in the example of  processes data in the hybrid computing environment () by monitoring data communications performance for a plurality of data communications modes between the host computer () and the accelerator (); receiving, from an application program () on the host computer (), a request to transmit data according to a data communications mode from the host computer () to the accelerator (); determining, in dependence upon the monitored performance, whether to transmit the data according to the requested data communications mode; and if the data is not to be transmitted according to the requested data communications mode: selecting, in dependence upon the monitored performance, another data communications mode for transmitting the data and transmitting the data according to the selected data communications mode.","The example hybrid computing environment () of  may be configured for DMA according to embodiments of the present invention. DMA may be carried out in the example hybrid computing environment () of  by pinning, by a first application () executing on a first computer (), a memory region for DMA transfer of data, including providing, to all applications () executing in the computing environment (), information describing the memory region; effecting, by a second application executing on a second computer () in dependence upon the information describing the memory region, DMA transfers related to the memory region, including issuing DMA requests to a particular DMA engine for processing; and unpinning, by the first application (), the memory region, including insuring, prior to unpinning, that no additional DMA requests related to the memory region are issued, that all outstanding DMA requests related to the memory region are provided to a DMA engine, and that processing of all outstanding DMA requests related to the memory region and provided to a DMA engine has been completed.","For further explanation,  sets forth a block diagram of a further exemplary hybrid computing environment () useful for DMA according to embodiments of the present invention. The hybrid computing environment of  is similar the hybrid computing environment of , including as it does, four compute nodes (, ), each of which includes a host computer () having a host computer architecture and one or more accelerators () each having an accelerator architecture where the accelerator architecture is optimized, with respect to the host computer architecture, for speed of execution of a particular class of computing functions. The host computer () and the accelerator () in the example of  are adapted to one another for data communications by a system level message passing module () and two or more data communications fabrics (, ) of at least two different fabric types. In the example of , the host computer () is adapted to accelerator () by an Ethernet fabric () and a PCIe fabric ().",{"@attributes":{"id":"p-0082","num":"0086"},"figref":["FIG. 4","FIG. 4","FIG. 4"],"b":["110","103","155","152","110","154","152","142","166","146","145","146"]},"Each x86 processor core () in the example of  is adapted through an Ethernet () and PCIe () fabric to a separate accelerator () implemented as a CBE as described above with respect to . Each core () of each AMD Opteron processor () in the host computer () in this example is connected to at least one CBE. Although in this example the ratio of cores of the Opteron processors to CBEs () is one-to-one, readers of skill in the art will recognize that other example embodiments may implement different ratios of processor cores to accelerators such as, for example, one-to-two, one-to-three, and so on.","Each instance of the SLMPM () executing on each x86 processor core () in the example of  processes data in the hybrid computing environment () by monitoring data communications performance across data communications modes between the host computer () and the accelerator () connected to the processor core (); receiving, from the instance of the application program () executing on the processor core () of the host computer (), a request to transmit data according to a data communications mode from the host computer () to the accelerator () connected to the processor core (); determining, in dependence upon the monitored performance, whether to transmit the data according to the requested data communications mode; and if the data is not to be transmitted according to the requested data communications mode: selecting, in dependence upon the monitored performance, another data communications mode for transmitting the data and transmitting the data according to the selected data communications mode.","The example hybrid computing environment () of  may be configured for DMA according to embodiments of the present invention. DMA may be carried out in the example hybrid computing environment () of  by pinning, by a first application () executing on a first computer (), a memory region for DMA transfer of data, including providing, to all applications () executing in the computing environment (), information describing the memory region; effecting, by a second application executing on a second computer () in dependence upon the information describing the memory region, DMA transfers related to the memory region, including issuing DMA requests to a particular DMA engine for processing; and unpinning, by the first application (), the memory region, including insuring, prior to unpinning, that no additional DMA requests related to the memory region are issued, that all outstanding DMA requests related to the memory region are provided to a DMA engine, and that processing of all outstanding DMA requests related to the memory region and provided to a DMA engine has been completed.","For further explanation,  sets forth a flow chart illustrating an exemplary method for DMA in a hybrid computing environment according to embodiments of the present invention. The method of  is carried out in a computing environment such as for example, the hybrid computing environments described above in this specification. Such a hybrid computing environment ( in ) includes a host computer () having a host computer architecture and an accelerator () having an accelerator architecture, the accelerator architecture optimized, with respect to the host computer architecture, for speed of execution of a particular class of computing functions, the host computer () and the accelerator () adapted to one another for data communications by an SLMPM () and, optionally, by two or more data communications fabrics (,  on ) of at least two different fabric types.","The method of  includes pinning (), by a first application executing on a first computer, a memory region () for DMA transfer of data, including providing, to all applications executing in the computing environment, information () describing the memory region (). Pinning (), by a first application executing on a first computer, a memory region () for DMA transfer of data in the method of  is carried out by translating () virtual memory addresses () of the memory region () into DMA addresses () and inserting (), into a memory region control block () for the memory region (), as the information () describing the memory region (), a valid flag () indicating whether the memory region () is available for DMA transfers, the virtual memory addresses (), and the DMA addresses () of the memory region ().","The method of  also includes effecting (), by a second application executing on a second computer in dependence upon the information () describing the memory region (), DMA transfers related to the memory region, including issuing DMA requests () to a particular DMA engine () for processing. In the method of , effecting () DMA transfers is carried out by incrementing () an entrance count () in a DMA injection control block () associated with the second application; determining (), in dependence upon a valid flag () in a memory region control block () associated with the memory region, whether memory region () is available for DMA transfers; and if the memory region () is available for DMA transfers: incrementing () an issued count () in a DMA execution control block () associated with the particular DMA engine (); inserting () in a DMA request () a command to write, as a value of a completed sequence count () in the DMA execution control block (), the value of the incremented issue count () upon completion by the particular DMA engine () of the DMA request (); providing () the DMA request () to the particular DMA engine () to process; and incrementing () an exit count () in the DMA injection control block () associated with the second application. If the memory region () is not available for DMA transfers, the method of  continues by stopping () the DMA transfer.","The method of  also includes processing (), by the particular DMA engine (), the DMA request () including writing (), as the value of the completed sequence count () in the DMA execution control block (), the value of the incremented issue count () upon completion of the DMA request (). Processing (), the DMA request () may include transferring data () to the memory region () from another memory location, or transferring data () from the memory region () to another memory location.","The method of  also includes unpinning (), by the first application, the memory region (), including insuring, prior to unpinning, that no additional DMA requests related to the memory region are issued, that all outstanding DMA requests related to the memory region are provided to a DMA engine, and that processing of all outstanding DMA requests related to the memory region and provided to a DMA engine has been completed. In the method of , unpinning () the memory region () is carried out by setting () a value of a valid flag () in a memory region control block () to indicate that the memory region () is not available for DMA transfers and unpinning () only if: an entrance count () in a DMA injection control block () associated with each application () executing in the computing environment () is greater than or equal to an exit count () in the DMA injection control block () and a completed sequence count () in a DMA execution control block () associated with each DMA engine () in the computing environment () is greater than or equal to a corresponding issued count () in the DMA execution control block (). That is, after setting () the valid flag, the first application determines () whether the entrance count is greater than or equal to the exit count and determines whether the completed sequence count is greater than or equal to the issued count. If either determination results in a \u2018no,\u2019 the first application does not () unpin the memory region.","For further explanation,  sets forth a flow chart illustrating a further exemplary method of DMA in a hybrid computing environment according to embodiments of the present invention. The method of , like the method of  is carried out in a hybrid computing environment similar to the hybrid computing environments described above in this specification. Such a hybrid computing environment ( in ) includes a host computer () having a host computer architecture and an accelerator () having an accelerator architecture, the accelerator architecture optimized, with respect to the host computer architecture, for speed of execution of a particular class of computing functions, the host computer () and the accelerator () adapted to one another for data communications by an SLMPM () and, optionally, by two or more data communications fabrics (,  on ) of at least two different fabric types. The method of  is similar to the method of  including, as it does, pinning () a memory region () for DMA transfer of data, effecting () DMA transfers related to the memory region, and unpinning () the memory region ().","The method of  differs from the method of , however, in that the method of  relies on a completed sequence count ( on ) in a DMA execution control block () to unpin a memory region, while the method of  relies on one or more completed sequence counts in a memory region control block (). As mentioned above, the completed sequence count ( on ) is not associated with any particular memory region. In computing environments in which many applications effect many DMA transfers, the completed sequence count may represent completed transfers related to many different memory regions. The first application according to method of  may be prevented if a large transfer of data is issued to a DMA engine and has not yet been completed, even if that DMA transfer is completely unrelated to the memory region. To reduce the effect of large data transfers unrelated to the memory region, the method of  employs completed sequence counts in a memory region control block (). Each memory region control block () in the computing environment includes a completed sequence count () for each DMA engine. In a computing environment that includes 10 DMA engines, each memory region control block () in the computing environment includes 10 separate completed sequence counts, one for each DMA engine. The completed sequence counts in a memory region control block represent the number of DMA requests completely processed by the DMA engine associated with the completed sequence count at the time the DMA engine processed the most recent DMA request related to the memory region. That is, in the method of , a DMA engine effectively maintains a running count of all DMA transfers, the issued count in the DMA execution control block, then, upon completing a DMA transfer related to a particular memory region, the DMA engine copies the value of the issued count () to the completed sequence count () in the memory region control block () associated with that particular memory region (). The use of separate completed sequence counts for each DMA engine in a memory region control block instead of one completed sequence count in a DMA execution control block () reduces the risk of large data transfers, completely unrelated to the pined memory region, preventing the unpinning of the memory region.","Effecting () DMA transfers related to the memory region in the method of  then includes incrementing () an entrance count () in a DMA injection control block () associated with the second application; determining (), in dependence upon a valid flag () in a memory region control block () associated with the memory region (), whether the memory region () is available for DMA transfers; and if the memory region () is available for DMA transfers: incrementing () an issued count () in a DMA execution control block () associated with the particular DMA engine (); inserting () in a DMA request () a command to write, as a value of a completed sequence count () for the particular DMA engine () in a memory region control block () associated with the memory region, the value of the incremented issue count () upon completion by the particular DMA engine () of the DMA request; providing () the DMA request () to the particular DMA engine () to process; incrementing () an exit count () in the DMA injection control block () associated with the second application. And the method of  also includes processing () the DMA request () by the particular DMA engine () including writing (), as the value of the completed sequence count () for the particular DMA engine in the memory region control block associated with the memory region (), the value of the incremented issue count () upon completion of the DMA request (). Processing () the DMA request () may include transferring data () to the memory region () from another memory location, or transferring data () from the memory region () to another memory location.","In the method of , unpinning () the memory region includes setting () a value of a valid flag () in a memory region control block () associated with the memory region () to indicate that the memory region is not available for DMA transfers and unpinning only if: an entrance count () in a DMA injection control block () associated with each application executing in the computing environment is greater than or equal to an exit count () in the DMA injection control block () and a completed sequence count (), for each DMA engine in the computing environment, in the memory region control block associated with the memory region is greater than or equal to a corresponding issued count () in a DMA execution control block () associated with the DMA engine (). That is, after setting () the valid flag, the first application determines () whether the entrance count is greater than or equal to the exit count and determines whether the completed sequence count in the memory region control block, not the DMA execution control block as in , is greater than or equal to the issued count. If either determination results in a \u2018no,\u2019 the first application does not () unpin the memory region.","Exemplary embodiments of the present invention are described largely in the context of DMA in a fully functional hybrid computing environment. Readers of skill in the art will recognize, however, that method aspects of the present invention also may be embodied in a computer program product disposed on signal bearing media for use with any suitable data processing system. Such signal bearing media may be transmission media or recordable media for machine-readable information, including magnetic media, optical media, or other suitable media. Examples of recordable media include magnetic disks in hard drives or diskettes, compact disks for optical drives, magnetic tape, and others as will occur to those of skill in the art. Examples of transmission media include telephone networks for voice communications and digital data communications networks such as, for example, Ethernets\u2122 and networks that communicate with the Internet Protocol and the World Wide Web. Persons skilled in the art will immediately recognize that any computer system having suitable programming means will be capable of executing the steps of the method of the invention as embodied in a program product. Persons skilled in the art will recognize immediately that, although some of the exemplary embodiments described in this specification are oriented to software installed and executing on computer hardware, nevertheless, alternative embodiments implemented as firmware or as hardware are well within the scope of the present invention.","It will be understood from the foregoing description that modifications and changes may be made in various embodiments of the present invention without departing from its true spirit. The descriptions in this specification are for purposes of illustration only and are not to be construed in a limiting sense. The scope of the present invention is limited only by the language of the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
