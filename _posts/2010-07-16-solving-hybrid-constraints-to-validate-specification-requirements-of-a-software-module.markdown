---
title: Solving hybrid constraints to validate specification requirements of a software module
abstract: In one embodiment, a software module is validated according to requirements associated with the software module. The software module has numeric and string variables, and is associated with first numeric constrains and first string constraints. Second numeric constraints applying to specific numeric variables and second string constraints applying to specific string variables are inferred. Each numeric constraint is represented with an equation, and each string constraint is represented with a finite state machine. Attempt to solve a solution for the numeric and string variables that satisfies all the first and second numeric constraints, all the first and second string constraints, and all the requirements associated with the software module by iteratively testing different possible values for the numeric and string variables.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08572574&OS=08572574&RS=08572574
owner: Fujitsu Limited
number: 08572574
owner_city: Kawasaki-shi
owner_country: JP
publication_date: 20100716
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","DESCRIPTION OF EXAMPLE EMBODIMENTS"],"p":["The present disclosure generally relates to testing and validating software modules.","A software application may include any number of modules (e.g., classes, functions, procedures, subroutines, or code blocks), and each module may be tested or validated individually. A software module may be tested or validated manually or automatically. In the former case, a person (e.g., a software testing engineer) may manually design test cases for the software module based on the design specification of the module, execute the module under the test cases, and check for module behavior or output that does not agree with the test cases. In the later case, a software testing tool, implemented as computer software or hardware, may automatically generate test cases for a software module under test, execute the module under test while simulating the test cases, and check for module behavior or output that does not agree with the test cases.","The present disclosure is now described in detail with reference to a few embodiments thereof as illustrated in the accompanying drawings. In the following description, numerous specific details are set forth in order to provide a thorough understanding of the present disclosure. It is apparent, however, to one skilled in the art, that the present disclosure may be practiced without some or all of these specific details. In other instances, well known process steps and\/or structures have not been described in detail in order not to unnecessarily obscure the present disclosure. In addition, while the disclosure is described in conjunction with the particular embodiments, it should be understood that this description is not intended to limit the disclosure to the described embodiments. To the contrary, the description is intended to cover alternatives, modifications, and equivalents as may be included within the spirit and scope of the disclosure as defined by the appended claims.","A software application is often organized into a number of software modules, and each software module may include code that perform specific functionalities. In a typical scenario, a software module may have any number of input or output variables. When the software module is invoked, actual input values may be passed to the software module (e.g., by the code that invokes the software module) as the values assigned to the input variables of the software module. The code of the software module may be executed in connection with the actual input values. Eventually, actual output values for the output variables of the software module may be determined and returned by the software module, at which point the software module completes its execution. Moreover, the actual output values determined by the code of the software module usually depend on the actual input values passed to the software module upon its invocation. In addition, the software module may have any number of local variables, also referred to as intermediate variables, whose values may also depend, directly or indirectly, on the values of the input variables. A local variable has a local scope. It only exists and is only accessible from within the context of the software module in which the local variable is declared. In contrast, the software application, to which the software module belongs, may have any number of global variables. A global variable has a global scope within the software application itself and is accessible to all the software modules that belong to the software application. When a software module is invoked, it may access or modify the value of a global variable, and the value modification is persistent even after the software module completes its execution.","JAVA\u00ae and JAVASCRIPT\u00ae are registered trademarks of Oracle America, Inc. MICROSOFT\u00ae is a registered trademark of Microsoft Corporation.","In particular embodiments, when the value of a first variable is determined based on the value of a second variable (i.e., the value of the first variable depends on the value of the second variable), the first variable is considered to depend on the second variable. A variable, whether input or output and whether local or global, usually has a specific data type, such as, for example and without limitation, character, string, integer, float, double, Boolean, pointer, array, and enumeration. The data type of a variable indicates what type of data (e.g., actual values) may be assigned to the variable. For example, only integer values should be assigned to a variable whose type is integer; and only true-false values should be assigned to a variable whose type is Boolean. Different programming languages may define different data types that the variables of the software modules or applications written in the specific languages may have, as well as different operations that may be applied to the specific data types. In particular embodiments, the data types of a programming language may be divided into two categories: string and numeric. The numeric data type may include the non-string data types, such as, for example and without limitation, integer, float, double, and Boolean.","String is a data type that is available in many programming languages, although different programming languages may define the type \u201cstring\u201d differently. For example, Java programming language defines the type \u201cstring\u201d as a Java class \u201cjava.lang.String\u201d, which represents a string as an immutable array of characters. In this case, once a string variable is declared and created, its value cannot be changed subsequently. Any modification to the value of a string variable results in a new string variable being declared and constructed. Class \u201cjava.lang.String\u201d also provides many operations, referred to as \u201cmethods\u201d, that may be applied to a string variable. On the other hand, with C programming language, a string may be defined as a one-dimensional character array that terminates with a null character. A C string is mutable such that its value may be modified in-place. In fact, each character in the array may be modified individually.","Each programming language generally defines several numeric data types, although the specific numeric data types available may vary from language to language. Integer, float, double, and Boolean are numeric data types that are commonly defined by most programming languages. Again, different programming languages may define specific numeric data types differently. For example, Java programming language provides two ways to declare an integer variable: either as a primitive data type \u201cint\u201d, or as a Java class \u201cjava.lang.Integer\u201d. Class \u201cjava.lang.Integer\u201d provides operations (i.e., methods) that may be applied an integer variable. On the other hand, C provides three primitive data types, \u201cshort\u201d, \u201cint\u201d, and \u201clong\u201d, that may be used to declare integer variables having different data sizes.","Sometimes, there may be any number of constraints placed on an input, output, or local variable of a software module. In particular embodiments, the constraints placed on a variable may specify, for example and without limitation, what values may be assigned to that variable, the size of the data values that may be assigned to the variable, or any other applicable conditions or limitations placed on the variable. Such variable constraints may be specified by or derived from the design specification or formal requirements of the software module, the specification of the programming language used to implement the software module, the code included in or the programming logic of the software module, the runtime environment within which the software module is executed, or other applicable factors. For example, a constraint may be placed on an integer variable \u201ca\u201d specifying that integer variable \u201ca\u201d may only be assigned integer values that is less than or equal to 0 xFFFFFFFF because the software module is executed within a runtime environment that represents each integer using four bytes. In this case, the constraint placed on integer variable \u201ca\u201d may be represented as an equation: \u201ca<0xFFFFFFFF\u201d. As another example, a constraint may be placed on a string variable \u201cs\u201d specifying that the length (i.e., the number of characters) of string variable \u201cs\u201d must be 8. In this case, the constraint placed on string variable \u201cs\u201d may be represented as another equation: \u201cs.length( )=8\u201d, using the syntax of Java programming language as an example. Sometimes, a constraint placed on one variable of a software module may depend, directly or indirectly, on the constraint placed on the value of another variable of the software module. For example, two constraints may be jointly placed on an integer variable \u201cb\u201d specifying that: (1) integer variable \u201cb\u201d may only be assigned integer values that is greater than or equal to \u221210; and (2) integer variable \u201cb\u201d may only be assigned integer values that is less than the value of variable \u201ca\u201d. In this case, the two constraints placed on integer variable \u201cb\u201d in combination may be represented as: \u201c(b>=\u221210) && (b<a)\u201d, with each constraint represented as a separate equation.","In particular embodiments, a software module may have any number of numeric or string variables, and these variables may be either input variables or local (i.e., intermediate) variables of the software module. In particular embodiments, a set of constraints may be placed on a specific numeric or string variable of the software module. Note that it is not necessary that a set of constraints is placed on each and every variable of a software module. In particular embodiments, given a numeric variable, it may have any number of numeric constraints or string constraints. For example, integer variable \u201cb\u201d may have a numeric constraint specifying that its value must be greater than or equal to \u221210 (e.g., constraint \u201cb>=\u221210\u201d). Integer variable \u201cb\u201d may also have a string constraint specifying that the text (i.e., string) representation of its value must equal to the string \u201c182\u201d (e.g., constraint \u201cb.toString( )=\u201c182\u201d\u201d). In this case, the set of constraints placed on integer variable \u201cb\u201d includes both numeric and string constraints, and therefore is a hybrid set of constraints (e.g., \u201c(b>=\u221210) && (b.toString( )=\u201c182\u201d)\u201d). Similarly, in particular embodiments, given a string variable, it may have any number of string constraints or numeric constraints. For example, string variable s\u201d may have a string constraint specifying that its value must begin with a substring \u201cca\u201d (e.g., constraint \u201cs.substring(0, 1)=\u201cca\u201d\u201d or \u201cs.startsWith(\u201cca\u201d)\u201d). String variable \u201cs\u201d may also have a numeric constraint specifying that its value must have a length of eight characters long (e.g., constraint \u201cs.length( )=8\u201d). In this case, again, the set of constraints placed on string variable \u201cs\u201d includes both numeric and string constraints, and therefore is a hybrid set of constraints (e.g., \u201c(s.substring(0, 1)=\u201cca\u201d) && (s.length( )=8)\u201d).","In particular embodiments, the constraints placed on a software module may include all the constraints, in combination, placed on its variables, including input, output, and local variables. For example, suppose that integer variable \u201cb\u201d and string variable \u201cs\u201d both belong to a software module \u201cm\u201d. In this case, the set of constraints placed on software module \u201cm\u201d itself includes the logical conjunction of the two sets of constraints placed on variables \u201cb\u201d and \u201cs\u201d respectively, which equals \u201c(b>=\u221210) && (b.toString( )=\u201c182\u201d) && (s.substring(0, 1)=\u201cca\u201d) && (s.length( )=8)\u201d. This is also a hybrid set of constraints because the set includes both numeric and string constraints.","In particular embodiments, it may be useful to determine and solve a hybrid set of constraints placed on a software module that has any number of numeric or string variables. It may also be useful to determine and solve a hybrid set of constraints placed on a specific variable of a software module. In particular embodiments, solving a set of constraints means attempting to find one or more solutions that satisfy all the constraints included in the set.  illustrates an example method for determining and solving constraints placed on a software module or a variable of a software module.  illustrates an example system  for determining and solving constraints placed on a software module or a variable of a software module. In particular embodiments, the components of system  illustrated in  may be implemented as computer hardware or software or a combination thereof.  are described in connection with each other.","In particular embodiments, a software module may have any number of numeric variables or string variables. For example, a software module \u201cm\u201d may have an integer variable \u201cvi\u201d, a Boolean variable \u201cvb\u201d, and a string variable \u201cvs\u201d. In this case, variables \u201cvi\u201d and \u201cvb\u201d are numeric variables. In particular embodiments, these variables may be input, output, or local variables of the software module.","In particular embodiments, initially, there may be any number of numeric constraints placed on specific numeric variables of the software module, and any number of string constraints placed on specific string variables of the software module. More specifically, a set of numeric constraints may be specified for and placed on a particular numeric variable, or a set of string constraints may be specified for and placed on a particular string variable. Each set of constraints may include one or more specific constraints. For example, a set of numeric constraints, \u201cnc1-vi\u201d, may be specified for and placed on integer variable \u201cvi\u201d; a set of numeric constraints, \u201cnc1-vb\u201d, may be specified for and placed on Boolean variable \u201cvb\u201d; and a set of string constraints, \u201csc1-vs\u201d, may be specified for and placed on string variable \u201cvs\u201d. In particular embodiments, these initial sets of constraints (e.g., \u201cnc1-vi\u201d, \u201cnc1-vb\u201d, and \u201csc1-vs\u201d) may be specified based on the design specification or formal requirements of the software module.","In particular embodiments, within the software module, there may be any number of operations applied to specific numeric variables of the software module, which take numeric input or produce numeric output. For example, an operation applied to integer variable \u201cvi\u201d may be \u201cri=vi+10\u201d, which takes two numeric values, the value of \u201cvi\u201d and \u201c10\u201d, as input and produces a numeric value, the value of \u201cri\u201d, as output.","In particular embodiments, within the software module, there may be any number of operations applied to specific numeric variables of the software module, which take string input or produce string output. For example, an operation applied to Boolean variable \u201cvb\u201d may be \u201cvb.toString( )\u201d, which produces a string value, which is a string representation of the value of Boolean variable \u201cvb\u201d (e.g., the string \u201ctrue\u201d), as its output.","In particular embodiments, within the software module, there may be any number of operations applied to specific string variables of the software module, which take string input or produce string output. For example, an operation applied to string variable \u201cvs\u201d may be \u201crs=vs.concat(\u201cabc\u201d)\u201d, which takes two string values, the value of \u201cvs\u201d and \u201cabc\u201d, as input and produces a string value, the value of \u201crs\u201d, as output.","In particular embodiments, within the software module, there may be any number of operations applied to specific string variables of the software module, which take numeric input or produce numeric output. For example, an operation applied to string variable \u201cvs\u201d may be \u201cvs.length( )\u201d, which produces a numeric value as its output indicating the number of characters contained in the value of string variable \u201cvs\u201d. Another operation applied to string variable \u201cvs\u201d may be \u201cvs.substring(5, 7)\u201d, which takes two numeric values as input.","Particular embodiments may analyze a software module (e.g., software module \u201cm\u201d) and the sets of numeric constraints initially specified for and placed on specific numeric variables (e.g., numeric constraints \u201cnc1-vi\u201d placed on integer variable \u201cvi\u201d and numeric constraints \u201cnc1-vb\u201d placed on Boolean variable \u201cvb\u201d) of the software module and the sets of string constraints initially specified for and placed on specific string variables (e.g., string constraints \u201csc1-vs\u201d placed on string variable \u201cvs\u201d) of the software module, as illustrated in step  of . In particular embodiments, the numeric and string constraints may initially be placed on either the input or the intermediate (i.e., the local) variables of the software module. Of course, in particular embodiments, it is not necessary that a set of numeric constraints is initially placed on each and every numeric variable of the software module, and a set of string constraints is initially placed on each and every string variable of the software module. It is possible that only specific numeric variables initially have associated numeric constraints, or only specific string variables initially have associated string constraints.","In particular embodiments, for a numeric or string constraint initially placed on an input variable of the software module, the constraint may be determined according to the design specification or formal requirements of the software module. For a numeric or string constraint initially placed on an intermediate variable of the software module, the constraint may be determined by performing symbolic execution on the software module. Symbolic execution is described in more detail below in connection with . Briefly, particular embodiments may perform symbolic execution on the software module while assigning a symbolic value to each of the input variables of the software module. Since an intermediate variable of the software module may depend, directly or indirectly, on one or more of the input variables of the software module, performing symbolic execution on the software module may result in, for the intermediate variable, a set of symbolic expressions indicating the dependency it has on the specific input variables. Particular embodiments may then determine a set of constraints placed on the intermediate variable based on the set of symbolic expressions obtained for the intermediate variable and the constraints placed on the specific input variables upon which the intermediate variable depend. For example, suppose that with software module \u201cm\u201d, \u201cvi\u201d is an input variable; \u201cri\u201d is an intermediate variable; and \u201cri=vi+10\u201d. In this case, performing symbolic execution on software module \u201cm\u201d may determine that intermediate variable \u201cri\u201d depends on input variable \u201cvi\u201d. Further suppose that a numeric constraint has been placed on input variable \u201cvi\u201d such that \u201cvi>0\u201d. Based on the result of the symbolic execution and the numeric constraint placed on input variable \u201cvi\u201d, a numeric constraint may be determined for intermediate variable \u201cri\u201d such at \u201cri>10\u201d.","From the analysis illustrated in step  of , particular embodiments may infer sets of string constraints placed on specific numeric variables of the software module and sets of numeric constraints placed on specific string variables of the software module, as illustrated in step  of . In particular embodiments, steps  and  of  may be performed by component  of system  illustrated in . In particular embodiments, component  may take as input a software module  and constraints  initially placed the variables of software module , which may include the numeric constraints initially specified for and placed on the numeric variables of the software module and the string constraints initially specified for and placed on the string variables of the software module. Component  may perform applicable analysis to infer string constraints to be placed on the numeric variables of software module  and numeric constraints to be placed on the string variables of software module . Component  may provide as output hybrid sets of numeric and string constraints that include both the specified and the inferred constraints placed on the variables of software module .","In particular embodiments, the constraints for the variables of the software module may be inferred based on various factors, and the present disclosure contemplates any applicable factor. For example and without limitation, numeric constraints may be inferred for both numeric and string variables and string constraints may be inferred for both numeric and string variables based on the operations applied to the specific variables, the specification of the programming language used to implement the software module, the runtime environment in which the software module is executed, or a combination of multiple factors.","In particular embodiments, given a numeric variable, a string constraint may be inferred based on an operation applied to the numeric variable, which may produce a string result. For example, suppose that the following two operations are applied to integer variable \u201cvi\u201d in software module \u201cm\u201d, \u201c(vi.toString( )).split(\u201c0\u201d)\u201d, which first produce a string representation of the value of integer variable \u201cvi\u201d (e.g., number 182 is represented as string \u201c182\u201d) and then split the string into two new strings at the location of character \u201c0\u201d. In order for the second operation (i.e., the string split operation) to be successful (e.g., not resulting in a null string), a string constraint may be inferred from the operations that the string representation of the value of integer variable \u201cvi\u201d must include at least one character \u201c0\u201d.","In particular embodiments, given a numeric variable, a numeric constraint may be inferred based on an operation applied to the numeric variable, which may produce a numeric result. For example, suppose that the following operation is applied to integer variable \u201cvi\u201d in software module \u201cm\u201d, \u201cMath.sqrt(vi)\u201d, which provides the square root of the value of integer variable \u201cvi\u201d. In order to perform this operation without encountering an error, a numeric constraint may be inferred from the operation specifying that the value of integer variable \u201cvi\u201d must be greater than or equal to 0.","In particular embodiments, given a string variable, a string constraint may be inferred based on an operation applied to the string variable, which may produce a string result. For example, suppose that the following operation is applied to string variable \u201cs\u201d in software module \u201cm\u201d, \u201cs.repalceAll(\u201cabc\u201d, \u201cxyz\u201d)\u201d, which replaces all substrings \u201cabc\u201d found in the value of string variable \u201cs\u201d with \u201cxyz\u201d. In order for the operation to have any actual effect on the value of string variable \u201cs\u201d, a string constraint may be inferred from the operation that the value of string variable \u201cs\u201d must include at least one occurrence of substring \u201cabc\u201d.","In particular embodiments, given a string variable, a numeric constraint may be inferred based on an operation applied to the string variable, which may produce a numeric result, or based on an operation applied to the string variable, which may take one or more numeric input. For example, suppose that the following operation is applied to string variable \u201cs\u201d in software module \u201cm\u201d, \u201cs.startsWith(\u201cabc\u201d)\u201d, which provides a Boolean result, as true or false, indicating whether the value of string variable \u201cs\u201d starts with substring \u201cabc\u201d. In order to perform this operation successfully, the value of string variable \u201cs\u201d must have at least three characters. Thus, a numeric constraint may be inferred from this operation specifying that the length of string variable \u201cs\u201d must be greater than or equal to 3. As another example, suppose that the following operation is also applied to string variable \u201cs\u201d in software module \u201cm\u201d, \u201cs.substring(6)\u201d, which takes a numeric value as input. In order to perform this operation successfully (e.g., not resulting in a null string), the value of string variable \u201cs\u201d must have at least six characters. Thus, a numeric constraint may be inferred from this operation specifying that the length of string variable \u201cs\u201d must be greater than or equal to 6.","In the above examples, within a software module, operations may be applied to numeric variables that produce string results; or, operations may be applied to string variables that take numeric input or produce numeric results. In particular embodiments, from these operations, numeric constraints may be inferred for and placed on specific string variables, and string constraints may be inferred for and placed on specific numeric variables. In particular embodiments, given a variable, either numeric or string, a complete set of constraints placed on the variable includes both the constraints initially specified for the variable, if any, and the constraints inferred for the variable, if any. This set of constraints may include either numeric constraints or string constraints or both. Because the set of constraints placed on the variable may include constraints inferred for the variable based on the individual operations applied to the variable, particular embodiments refer to the set of constraints thus obtained as an interacting hybrid set of constraints. In particular embodiments, given a software module that has any number of numeric or string variables, the set of constraints placed on the software module itself includes all the constraints placed on the individual variables of the software module.","Given a hybrid set of constraints placed on a variable of a software module or a software module itself, particular embodiments may represent each numeric constraint in the set with a mathematical equation (e.g., \u201cvi>=0\u201d, \u201cvb=true\u201d, or \u201cs.length( )>=6\u201d) and each string constraint in the set with a finite state machine (FSM), as illustrated in step  of .","In general, a FSM is a model of behavior composed of a finite number of states, transitions between these states, and actions. In particular embodiments, a FSM may be used to represent a string.  illustrates several FSMs used to represent strings. In , with each FSM, an intermediate state is represented by a single circle; an accepting state is represented by a double circle; and an input to a state is represented by an arrow leading to the circle.","For example, FSM  represents a string, \u201cS\u201d, that may have any character and of any length. FSM  represents a string, \u201cS\u201d, that has at least one character and the last character of the string is \u201cZ\u201d, and may be used to represent the constraint \u201cS.endsWith(\u201cZ\u201d)=true\u201d. FSM  represents a string, \u201cS\u201d, that has three or more characters, and may be used to represent the constraint \u201cS.length( )>=3\u201d.","FSM  represents a string, \u201cS\u201d, that has at least one character and contains at least one \u201cZ\u201d and the \u201cZ\u201d transition signifies the last \u201cZ\u201d in the string. FSM  represents a string, \u201cS\u201d, that does not have any character that is \u201cZ\u201d. Consider the constraint \u201c(a=S.lastIndexOf(\u201cZ\u201d))\u201d. From this constraint it can be inferred that if \u201ca>=0\u201d, then \u201c(S.substring(a, a+1)=\u201cZ\u201d)\u201d. FSM  represents the case when the above constraints are satisfied; that is, string \u201cS\u201d contains at least one \u201cZ\u201d character and the last \u201cZ\u201d occurring in \u201cS\u201d is at the index that equals the value of \u201ca\u201d. On the other hand, FSM  represents the case when the set of constraints is not satisfied; that is, string \u201cS\u201d does not contain any character \u201cZ\u201d, and thus \u201ca=\u22121\u201d. Hence the constraint \u201ca=S.lastIndexOf(\u201cZ\u201d)\u201d results in a fork in the symbolic execution tree and on one branch it assumes the case of FSM  with additional numeric constraint \u201ca>=0\u201d while on the other branch it assumes the case of FSM  with additional constraint \u201ca=\u22121\u201d.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 4","FIG. 4","FIG. 4","FIG. 4"],"b":["400","402","404","402","412","412","412","402","412","402","414","414","414","402","414"]},"In particular embodiments, given any set of constraints, each numeric constraint from the set may be represented using an applicable mathematical equation, and each string constraint from the set may be represented using an applicable FSM. In addition, given a set of constraints thus represented, particular embodiments may attempt to solve the constraints in order to find one or more solutions that satisfy all the constraints in the set at the same time, as illustrated in step  of . In particular embodiments, step  of  may be performed by component  of system  illustrated in . In particular embodiments, component  may be a constraint solver implemented based in part on the Satisfiability Modulo Theories (SMT). In particular embodiments, component  may take as input a set of constraints, which may include either or both numeric constraints represented using mathematical equations and string constraints represented using FSMs, and attempt to find one or more solutions that satisfy all the constraints from the set. If any solution may be found, component  may provide the solution as its output. Of course, it is possible that a set of constraints may not have any solution that satisfy all the constraints from the set. For example, consider the set of constraints, \u201c(s.equals(q)) && (s.startsWith(\u201cuvw\u201d)) && (q.endsWith(\u201cxyz\u201d)) && (s.length( )<a) && ((a+b)<6) && (b>0)\u201d, where \u201cs\u201d and \u201cq\u201d are strings and \u201ca\u201d and \u201cb\u201d are integers. There is no combination of values for \u201cs\u201d, \u201cq\u201d, \u201ca\u201d, and \u201cb\u201d that can satisfy all the constraints from this set at the same time. Therefore, this particular set of constraints is unsatisfiable.","Particular embodiments may solve a hybrid set of constraints using an iterative algorithm. Particular embodiments may group all the string constraints from the set, represented using FSMs, in a string domain, and all the numeric constraints from the set, represented using mathematical equations, in a numeric domain. Particular embodiments may then iteratively attempt to find one or more solutions in either the numeric domain or the string domain alone (i.e., solutions that satisfy either all the numeric constraints in the set or all the string constraints in the set), and feed the solutions found in one domain to the other domain, until: (1) one or more solutions are found to satisfy all the numeric and string constraints in the set; (2) it is determined that there is no solution that satisfies all the constraints in the set (i.e., the set of constraints is unsatisfiable); or (3) the number of iterations performed has reached a predetermined threshold, whichever occurs first. Particular embodiments may solve the numeric constraints in the numeric domain using a Satisfiability Modulo Theory (SMT) solver, and solve the string constraints in the string domain using regular expression union, intersection, complement, Kleene star, and other applicable algorithms. In addition, particular embodiments may take the following into consideration when attempting to find one or more solutions for a hybrid set of constraints. First, if the numeric constraints in the numeric domain alone are unsatisfiable (i.e., there is no solution that satisfies just the numeric constraints in the set), then the entire set of constraints is unsatisfiable. Second, if the solution for the string constraints in the string domain alone is a null string (i.e., an empty string), then, if there is no numeric constraint in the set at all, then the set is unsatisfiable; otherwise, the numeric constraints in the set is further constrained by the null string.","To explain the iterative process further, consider an example set of constraints, \u201cs.startsWith(\u201cuvw\u201d) && s.endsWith(\u201cxyz\u201d) && (a=s.lastIndexOf(\u201ct\u201d)) && (s.length( )<=b) && (b+c<=8) && ((a+d)>=4) && (c>0) && (d<0)\u201d, where \u201cs\u201d is a string and \u201ca\u201d, \u201cb\u201d, \u201cc\u201d, and \u201cd\u201d are integers. A solution that satisfies this set of constraints means that there is a combination of five values for string \u201cs\u201d and integers \u201ca\u201d, \u201cb\u201d, \u201cc\u201d, and \u201cd\u201d, respectively, that causes all the individual constraints in the set to be satisfied (i.e., all the conditions to be true) at the same time. More specifically, in order to satisfy constraint \u201cs.startsWith(\u201cuvw\u201d)\u201d, the first three characters of \u201cs\u201d must be \u201cuvw\u201d. In order to satisfy constraint \u201cs.endsWith(\u201cxyz\u201d)\u201d, the last three characters of \u201cs\u201d must be \u201cxyz\u201d. In order to satisfy constraint \u201ca=s.lastIndexOf(\u201ct\u201d)\u201d, the last occurrence of character \u201ct\u201d in \u201cs\u201d must have an index number that equals the value of \u201ca\u201d. In order to satisfy constraint \u201cs.length( )<=b\u201d, the number of characters in \u201cs\u201d must be less than or equal to the value of \u201cb\u201d. In order to satisfy constraint \u201cb+c<=8\u201d, the sum of the values of \u201cb\u201d and \u201cc\u201d must be less than or equal to 8. In order to satisfy constraint \u201c(a+d)>=4\u201d, the sum of the values of \u201ca\u201d and \u201cd\u201d must be greater than or equal to 4. In order to satisfy constraint \u201cc>0\u201d, the value of c\u201d must be greater than 0. And in order to satisfy constraint \u201cd<0\u201d, the value of d\u201d must be less than 0.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 5","b":["512","510","522","520","531","510","512","510","520"]},"During the second iteration , particular embodiments may derive additional constraints  placed on integers \u201ca\u201d, \u201cb\u201d, \u201cc\u201d, or \u201cd\u201d from the solution found for \u201cs\u201d during the previous iteration (i.e., \u201cuvwtxyz\u201d). For example, constraint \u201cs.length( )<=b\u201d requires that the number of characters in \u201cs\u201d must be less than or equal to the value of \u201cb\u201d. Because the shortest string solution for \u201cs\u201d found in string domain  must have a minimum of seven characters, this means that \u201cb>=7\u201d. Constraint \u201ca=s.lastIndexOf(\u201ct\u201d)\u201d requires that the last occurrence of character \u201ct\u201d in \u201cs\u201d must have an index number that equals the value of \u201ca\u201d. Since \u201ct\u201d is not the last character in \u201cs\u201d, this means that \u201ca<b\u201d. In addition, since \u201ct\u201d cannot be any of the first three characters in \u201cs\u201d, this also means that \u201ca>=3\u201d. Particular embodiments may add the three additional numeric constraints  placed on \u201ca\u201d, \u201cb\u201d, and \u201cc\u201d, which are derived from the solution for \u201cs\u201d, to the four numeric constraints  originally from the set, and attempt to find values for \u201ca\u201d, \u201cb\u201d, \u201cc\u201d, and \u201cd\u201d that satisfy all the numeric constraints , , including those originally from the set as well as those derived from the solution for string \u201cs\u201d. Again, if there are multiple values for integers \u201ca\u201d, \u201cb\u201d, \u201cc\u201d, and \u201cd\u201d that satisfy all the numeric constraints, particular embodiments select the smallest values first. From the four original numeric constraints  from the set and the three additional, derived numeric constraints , particular embodiments may determine a possible solution for \u201ca\u201d, \u201cb\u201d, \u201cc\u201d, and \u201cd\u201d as \u201ca=5\u201d, \u201cb=7\u201d, \u201cc=1\u201d and \u201cd=\u22121\u201d. In fact, for \u201ca\u201d, there are two possible values, 5 and 6. The value 5 is the smallest and therefore is selected first for \u201ca\u201d. These four values are fed back to string domain  to be verified against the string constraints.","During the third iteration , the solution for \u201ca\u201d, \u201cb\u201d, \u201cc\u201d, and \u201cd\u201d found in numeric domain  during the second iteration  is verified against the string constraints in string domain . If \u201cs\u201d is \u201cuvwtxyz\u201d, then \u201ca\u201d cannot equal 5, because the index of \u201ct\u201d is 3, which should equal the value of \u201ca\u201d. This new constraint  on \u201ca\u201d (i.e., \u201ca !=5\u201d) is again fed back to numeric domain .","During the fourth iteration , constraint , \u201ca !=5\u201d, is added to the other existing numeric constraints , . The next possible solution for \u201ca\u201d, \u201cb\u201d, \u201cc\u201d, and \u201cd\u201d that satisfy all currently existing numeric constraints , ,  is \u201ca=6\u201d, \u201cb=7\u201d, \u201cc=1\u201d and \u201cd=\u22121\u201d. This solution is fed back to string domain .","During the fifth iteration , the solution found for \u201ca\u201d, \u201cb\u201d, \u201cc\u201d, and \u201cd\u201d (i.e., \u201ca=6\u201d, \u201cb=7\u201d, \u201cc=1\u201d and \u201cd=\u22121\u201d) in numeric domain  during the previous iteration is similarly verified against the string constraints in string domain . Again, if \u201cs\u201d is \u201cuvwtxyz\u201d, then \u201ca\u201d cannot equal 6. This yields a new constraint  on \u201ca\u201d, \u201ca !=6\u201d, and is fed back to numeric domain .","During the sixth iteration , constraint , \u201ca !=6\u201d, is again added to the other existing numeric constraints , , . An attempt is made to find a solution that satisfy all numeric constraints , , , . However, there is no values for \u201ca\u201d, \u201cb\u201d, \u201cc\u201d, and \u201cd\u201d that satisfy all currently existing numeric constraints , , , . Therefore, if \u201cs\u201d equals \u201cuvwtxyz\u201d, then there is no solution that can be found for \u201ca\u201d, \u201cb\u201d, \u201cc\u201d, and \u201cd\u201d that satisfies all the numeric constraints. Note that in this case, \u201cs\u201d cannot have more than seven characters because of the three constraints \u201cs.length( )<=b\u201d, \u201cb+c<=8\u201d, and \u201cc>0\u201d. More specifically, since \u201cc>0\u201d, the smallest value \u201cc\u201d may have is 1. Since \u201cb+c<=8\u201d, if the smallest value \u201cc\u201d may have is 1, then the largest value \u201cb\u201d may have is 7. This means that the longest length \u201cs\u201d may have is seven characters because \u201cs.length( )<=b\u201d. At this point, it has been determined that this set of constraints is unsatisfiable. Therefore, the process may stop.","The example process illustrated in  may be used to determine a hybrid set of constraints (i.e., a set of constraints that includes both numeric and string constraints) placed on a software module or a particular variable of a software module, and attempt to find a solution that satisfy all the constraints from the set. There are various practical applications for such a process.","In particular embodiments, a process, such as the one illustrated in , may be used to automatically generate test data for a software module. The test data may then be used to test and detect errors in the software module. Often, a software module may include any number of conditional branching points (e.g., the \u201cif-else\u201d statements), and each conditional branching point has a branching condition specified by one or more variables (e.g., input variables or local variables) of the software module. Depending on whether the branching condition is satisfied, the software module may proceed down different execution paths at the conditional branching point. To explain conditional branching points further, consider the following example code segment of an example software module:",{"@attributes":{"id":"p-0058","num":"0057"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"SAMPLE CODE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u20021","if (m > n && k <= 10) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u20022","..."]},{"entry":[{},"\u20023","if (k > 2) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u20024","..."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u20025","} else {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u20026","if (n == k || n == m) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u20027","..."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u20028","} else {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u20029","..."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"10","}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"11","}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"12","} else {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"13","..."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"14","}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"In the above example, \u201cm\u201d, \u201cn\u201d, and \u201ck\u201d may be variables of the example software module. At line 1 there is a conditional branching point, and the branching condition is \u201cm>n && k<=10\u201d. Note that a branching condition may include multiple sub conditions (e.g., \u201cm>n\u201d and \u201ck<=10\u201d). For the branching condition at line 1 to be satisfied (i.e., to hold true), the value of variable \u201cm\u201d needs to be greater than the value of variable \u201cn\u201d, and the value of variable \u201ck\u201d needs to be less than or equal to 10. If the branching condition at line 1 is satisfied, then the code between lines 2-11 is executed. Otherwise (i.e., if the branching condition at line 1 is not satisfied), then the code at line 13 is executed. At line 3 there is another conditional branching point, and the branching condition is \u201ck>2\u201d. For the branching condition at line 3 to be satisfied, the value of variable \u201ck\u201d needs to be greater than 2. Similarly, if the branching condition at line 3 is satisfied, then the code at line 4 is executed. Otherwise, the code between lines 6-11 is executed. At line 6 there is a third conditional branching point, and the branching condition is \u201cn==k\u2225n==m\u201d, which also includes multiple sub conditions (e.g., \u201cn==k\u201d and \u201cn==m\u201d). For the branching condition at line 6 to be satisfied, the value of variable \u201cn\u201d needs to equal either the value of variable \u201ck\u201d or the value of variable \u201cm\u201d. If the branching condition at line 6 is satisfied, then the code at line 7 is executed. Otherwise, the code at line 9 is executed.","Furthermore, the conditional branching point at line 3 is nested within the conditional branching point at line 1, and the conditional branching point at line 6 is further nested within the conditional branching point at line 3. If the branching condition associated with the conditional branching point at line 1 is not satisfied, the conditional branching point at line 3 is never reached during execution of the code. However, if the branching condition associated with the conditional branching point at line 3 is not satisfied, the conditional branching point at line 6 is reached during execution of the code. In fact, in order to reach the conditional branching point at line 6, the branching condition at line 1 needs to be satisfied but the branching condition at line 3 cannot be satisfied.","Therefore, at each conditional branching point in a software module, depending on whether the branching condition associated with the conditional branching point is satisfied, the software module proceeds along a different execution path.  illustrates execution paths of an example software module that has multiple levels of nested conditional branches. At conditional branching point , if \u201cCONDITION \u201d is satisfied, the execution path proceeds toward processing steps , and if \u201cCONDITION \u201d is not satisfied, the execution path proceeds toward processing steps . At conditional branching point , which is nested within conditional branching point , if \u201cCONDITION \u201d is satisfied, the execution path proceeds toward processing steps , and if \u201cCONDITION \u201d is not satisfied, the execution path ends. At conditional branching point , which is also nested within conditional branching point , if \u201cCONDITION \u201d is satisfied, the execution path ends, and if \u201cCONDITION \u201d is not satisfied, the execution path proceeds toward conditional branching point . And at conditional branching point , which is further nested within conditional branching point , if \u201cCONDITION \u201d is satisfied, the execution path proceeds toward processing steps , and if \u201cCONDITION \u201d is not satisfied, the execution path proceeds toward processing steps . In , there are five possible execution paths, and the software module may proceed along any one of the five possible execution paths depending on whether the branching conditions are satisfied at the individual conditional branching points , , , .","Particular embodiments may consider the branching conditions as numeric or string constraints placed on the variables that represent the branching conditions. For example, at line 1 of SAMPLE CODE 1, the branching condition is \u201cm>n & & k<=10\u201d. If the branching condition is satisfied, then the value of \u201cm\u201d must be greater than the value of \u201cn\u201d and the value of \u201ck\u201d must be less than or equal to 10. This may be represented as a set of constraints placed on \u201cm\u201d, \u201cn\u201d, and \u201ck\u201d as \u201c(m>n) && (k<=10)\u201d. Any solution for \u201cm\u201d, \u201cn\u201d, and \u201ck\u201d that satisfies this set of constraints may result in the branching condition to be satisfied (i.e., hold true) and cause the software module to proceed along one execution path (i.e., the \u201cif\u201d portion of the code). If the branching condition is not satisfied, then either the value of \u201cm\u201d is less than or equal to the value of \u201cn\u201d or the value of \u201ck\u201d is greater than 10. This may be represented as another set of constraints placed on \u201cm\u201d, \u201cn\u201d, and \u201ck\u201d as \u201c(m<=n)\u2225(k>10)\u201d. Any solution for \u201cm\u201d, \u201cn\u201d, and \u201ck\u201d that satisfies this second set of constraints may result in the branching condition not to be satisfied (i.e., hold false) and cause the software module to proceed along another execution path (i.e., the \u201celse\u201d portion of the code).","Consequently, particular embodiments may determine a set of constraints corresponding to each possible execution path in a software module, find one or more solutions for each set of constraints, and test the software module using the solutions as test input.  illustrates an example method for testing a software module that include multiple possible execution paths resulting from one or more conditional branching points. In particular embodiments, a software module may have any number of variables (e.g., input or local variables) and any number of conditional branching points (e.g., the \u201cif-else\u201d statements). Each conditional branching point may be associated with a branching condition that is specified by one or more of the variables. In particular embodiments, a branching condition may include any number of sub-conditions. Depending on whether the branching condition associated with a conditional branching point is satisfied, the software module may proceed along different execution paths.","Particular embodiments may perform symbolic execution on the software module to determine, for each possible execution path of the software module, a set of symbolic expressions that causes the software module to proceed along and reach the end of that execution path, as illustrated in step  of . When determining each set of symbolic expressions, particular embodiments may incorporate the numeric and string constraints initially placed on the specific variables of the software module (e.g., as described in connection with step  of ), if any, as well as the numeric and string constraints inferred for the specific variables of the software module (e.g., as described in connection with step  of ), if any. In particular embodiments, step  of  may be performed by component  of system  illustrated in , which may take as input a software module , perform symbolic execution on software module , and provide as output sets of symbolic expressions corresponding to the execution paths of software module .","In the field of computer science, symbolic execution refers to the analysis of software programs by tracking symbolic rather than actual values, as a case of abstract interpretation. It is a non-explicit state model-checking technique that treats input to software modules as symbol variables. It creates complex mathematical equations or expressions by executing all finite paths in a software module with symbolic variables and then solves the complex equations with a solver (typically known as a decision procedure) to obtain error scenarios, if any. In contrast to explicit state model checking, symbolic execution is able to work out all possible input values and all possible use cases of all input variables in the software module under analysis. To further explain symbolic execution, consider an example software module named \u201cfoo\u201d:",{"@attributes":{"id":"p-0066","num":"0065"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"SAMPLE CODE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u20021","foo (a, b) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u20022","string a, b, c, d;"]},{"entry":[{},"\u20023","c = a.concat(b);"]},{"entry":[{},"\u20024","if !(c.equals(\u201cqrs\u201d)) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u20025","d = c.concat(\u201ct\u201d);"]},{"entry":[{},"\u20026","return d;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u20027","} else {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u20028","return c;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u20029","}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"10","}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"Software module \u201cfoo\u201d has two input variables \u201ca\u201d and \u201cb\u201d and two local variables \u201cc\u201d and \u201cd\u201d. In particular embodiments, the value of a local variable may depend, directly or indirectly, on the value of one or more input variables of the software module. For example, with module \u201cfoo\u201d, the value of local variable \u201cc\u201d depends directly on the values of input variables \u201ca\u201d and \u201cb\u201d, as indicated by line 3 of the code; and the value of local variable \u201cd\u201d depends indirectly on the values of input variables \u201ca\u201d and \u201cb\u201d, through local variable \u201cc\u201d, as indicated by line 5 of the code. In addition, module \u201cfoo\u201d contains a conditional branching point at line 4 of the code, caused by the \u201cif-else\u201d statement. The conditional branching point at line 4 is associated with a branching condition \u201c!(c.equals(\u201cqrs\u201d))\u201d. Depending on whether this branching condition is satisfied or holds true\u2014that is, whether local variable \u201cc\u201d equals \u201cqrs\u201d-module \u201cfoo\u201d proceeds down different execution paths and different portions of the code of module \u201cfoo\u201d is actually executed. More specifically, if local variable \u201cc\u201d does not equal \u201cqrs\u201d, then the value of local variable \u201cd\u201d is computed and returned, as indicated by lines 5 and 6 of the code. On the other hand, if local variable \u201cc\u201d does equal \u201cqrs\u201d, then the value of local variable \u201cc\u201d is returned, as indicated by line 8 of the code.","When symbolic execution is performed on module \u201cfoo\u201d, its input and local variables are each assigned a symbolic value instead of an actual value.  illustrates an example execution flow  representing the steps of performing symbolic execution on module \u201cfoo\u201d. In this example, input variable \u201ca\u201d is assigned symbolic value \u201cx\u201d; input variable \u201cb\u201d is assigned symbolic value \u201cy\u201d; local variable \u201cc\u201d is assigned symbolic value \u201cz\u201d; and local variable \u201cd\u201d is assigned symbolic value \u201cw\u201d. Since variables \u201ca\u201d, \u201cb\u201d, \u201cc\u201d, and \u201cd\u201d are of type \u201cstring\u201d, symbolic values \u201cx\u201d, \u201cy\u201d, \u201cz\u201d, and \u201cw\u201d each represent an arbitrary string.","In addition, \u201c\u03a6\u201d is the symbolic expression that represents the result of the symbolic execution at various points along the execution paths. More specifically, at , which corresponds to line 2 of the code of module \u201cfoo\u201d, variables \u201ca\u201d, \u201cb\u201d, \u201cc\u201d, and \u201cd\u201d are assigned their respective symbolic values \u201cx\u201d, \u201cy\u201d, \u201cz\u201d, and \u201cw\u201d, and \u201c\u03a6\u201d initially has an empty or null expression. As the execution proceeds further, expressions are added to \u201c\u03a6\u201d depending on what code has been executed. At , which corresponds to line 3 of the code of module \u201cfoo\u201d, \u201c\u03a6\u201d has the expression \u201cz=concat(x, y)\u201d because line 3 of the code is \u201cc=a.concat(b)\u201d and \u201cx\u201d, \u201cy\u201d, and \u201cz\u201d are the symbolic value assigned to variable \u201ca\u201d, \u201cb\u201d, and \u201cc\u201d, respectively. Next, line 4 of the code of module \u201cfoo\u201d is a conditional branching point and there are two possible execution paths down which the execution may proceed. Thus, the symbolic execution may also proceed down two different paths from : the first path, PATH , includes  and  corresponding to lines 5 and 6 of the code; and the second path, PATH , includes  corresponding to line 8 of the code.","In order to proceed down PATH , variable \u201cc\u201d does not equal \u201cqrs\u201d, which means symbolic value \u201cz\u201d does not equal \u201cqrs\u201d. Therefore, the expression \u201cz !=\u201cqrs\u201d\u201d is added to \u201c\u03a6\u201d at . Conversely, in order to proceed down PATH , variable \u201cc\u201d does equal \u201cqrs\u201d, which means symbolic value \u201cz\u201d equals \u201cqrs\u201d. Therefore, the expression \u201cz=\u201cqrs\u201d\u201d is added to \u201c\u03a6\u201d at . Along PATH , the value of variable \u201cd\u201d is determined at line 5 of the code, which corresponds to . Therefore, the expression \u201cw=concat(z, \u201ct\u201d)\u201d is added to \u201c\u03a6\u201d at . Note that because \u201cz=concat(x, y)\u201d, the expression for \u201cw\u201d may be rewritten as \u201cw=concat(concat(x, y), \u201ct\u201d)\u201d.  is the end of PATH , and thus, the expression of \u201c\u03a6\u201d at  represents the conditions, in symbolic form, that need to be satisfied in order to reach the end of execution PATH . Similarly,  is the end of execution PATH , and thus, expression of \u201c\u03a6\u201d at  represents the conditions, in symbolic form, that need to be satisfied in order to reach the end of PATH .","Since module \u201cfoo\u201d has two possible execution paths, symbolically executing module \u201cfoo\u201d results in two sets of expressions, one corresponding to each execution path. In particular embodiments, solving for the expression of \u201c\u03a6\u201d at  may provide the actual values for input variables \u201ca\u201d and \u201cb\u201d that cause module \u201cfoo\u201d to reach the end of PATH ; and solving for the expression of \u201c\u03a6\u201d at  may provide the actual values for input variables \u201ca\u201d and \u201cb\u201d that cause module \u201cfoo\u201d to reach the end of PATH .","To solve the sets of expressions resulted from performing symbolic execution on the software module, particular embodiments may represent each set of expressions as a set of constraints placed on the variables of the software module, as illustrated in step  of . For example, with module \u201cfoo\u201d, the set of expressions at  may be represented as a set of constraints placed on \u201ca\u201d, \u201cb\u201d, \u201cc\u201d, and \u201cd\u201d as \u201c(d=concat(concat(a, b), \u201ct\u201d)) && (c=concat(a, b)) && (c !=\u201cqrs\u201d)\u201d. The set of expressions at  may be represented as a set of constraints placed on \u201ca\u201d, \u201cb\u201d, \u201cc\u201d, and \u201cd\u201d as \u201c(c=concat(a, b)) && (c=\u201cqrs\u201d)\u201d.","For each set of constraints obtained from performing symbolic execution on the software module, particular embodiments may represent each numeric constraint from the set as an applicable mathematical equation and each string constraint from the set as an application FSM.  illustrate three example sets of constraints , ,  determined for an example software module together with the three corresponding execution paths , ,  of the software module, where the numeric constraints are represented as mathematical equations and the string constraints are represented as FSMs. To test this example software module, at the end of each path , , , each corresponding set of constraints , ,  is solved for the test cases.","Particular embodiments may then attempt to find one or more solutions for each set of constraints, as illustrated in step  of , using the process illustrated in , and then test the software module using the solutions found as test input, as illustrated in step  of . In particular embodiments, a solution for a set of constraints may include actual values for the variables on which the constraints are placed that satisfy all the constraints in the set. When testing the software module, these actual solution values may be assigned to the variables of the software module as test input. Given a solution found for a set of constraints, since the solution values together satisfy all the constraints from the corresponding set of constraints, and the set of constraints corresponds to a set of expressions (e.g., obtained from the symbolic execution) that represents the state of the software module as it proceeds along and reaches the end of a particular execution path, by applying this specific combination of actual values (i.e., the values from the solution found for the set of constraints) as test input to the software module, it ensures that the software module proceeds along and reaches the end of the particular execution path. Consequently, it means that the particular execution path is fully tested if these specific solution values are assigned to the corresponding variables of the software module as test input. Furthermore, if a solution may be found for each and every set of constraints corresponding to each and every set of expressions obtained for each and every execution path of the software module, and the solution values are applied to the software module as test input (e.g., by applying the actual values of one solution at a time), then all the possible execution paths of the software module may be fully tested. If there is any error in any of the execution paths of the software module, such systematic testing may be able to catch it eventually.","In particular embodiments, a process, such as the one illustrated in , may be used to validate whether design or specification requirements of a software module is satisfied. Typically, there may be formal design or specification requirements associated with any given software module. Some of these formal requirements may be placed on the input or output of the software module. In particular embodiments, a specification requirement placed on the input of a software module may be referred to as a pre-condition associated with the software module; and a specification requirement placed on the output of a software module may be referred to as a post-condition associated with the software module. Sometimes, a post-condition may depend on a pre-condition associated with the software module.","As explained above, often, a software module may include any number of conditional branching points (e.g., the \u201cif-else\u201d statements), and each conditional branching point has a branching condition specified by one or more variables (e.g., input variables or local variables) of the software module. Depending on whether the branching condition is satisfied, the software module may proceed down different execution paths. Thus, when the software module is executed, it may proceed down any one of the possible execution paths resulted from the conditional branching points included in the software module. Consequently, in particular embodiments, when validating whether a software module satisfies the formal specification requirements placed on its input and output (i.e., the pre-conditions and post-conditions associated with the software module), the software module is considered to pass the validation test (i.e., satisfy the specification requirements) if and only if all the pre-conditions and post-conditions associated with the software module hold true for all possible execution paths of the software module.",{"@attributes":{"id":"p-0077","num":"0076"},"figref":["FIG. 10","FIG. 10"],"b":"1002"},{"@attributes":{"id":"p-0078","num":"0077"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"SAMPLE CONDITIONS"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Pre-condition","IF String p = foo(a, b) and (b.endsWith(\u201cs\u201d))"]},{"entry":[{},"Post-condition","THEN p.endsWith(\u201ct\u201d)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"Particular embodiments may then negate the post-conditions of the software module, as illustrated in step  of . In the above example, software module has one post-condition, \u201cp.endsWith(\u201ct\u201d)\u201d. Logically negating this post-condition results in \u201c!(p.endsWith(\u201ct\u201d))\u201d.","Particular embodiments may perform symbolic execution on the software module to obtain a set of constraints that corresponds to each possible execution path of the software module and then incorporate the pre-conditions and the negated post-conditions into each set of constraints, as illustrated in step  of . Symbolic execution has be described above in connection with step  of , and may be similarly performed here. When determining each set of constraints, particular embodiments may incorporate the numeric and string constraints initially placed on the specific variables of the software module (e.g., as described in connection with step  of ), if any, as well as the numeric and string constraints inferred for the specific variables of the software module (e.g., as described in connection with step  of ), if any. For example, software module \u201cfoo\u201d has two possible execution paths, as illustrated in . Thus, performing symbolic execution on software module \u201cfoo\u201d results in two sets of expressions.","For the first path, PATH , the set of expressions obtained from performing symbolic execution on \u201cfoo\u201d may be written as \u201c(p=concat(concat(a, b), \u201ct\u201d))) && (concat(a, b) !=\u201cqrs\u201d)\u201d, as indicated by  of . Note that \u201cp\u201d has the value of \u201cd\u201d for PATH  because \u201cd\u201d is the value that is returned by \u201cfoo\u201d (i.e., the output of \u201cfoo\u201d) at the end of PATH , and \u201cw\u201d is the symbolic value assigned to \u201cd\u201d. Moreover, \u201ca\u201d is equivalent to \u201cx\u201d because \u201cx\u201d is the symbolic value assigned to \u201ca\u201d; \u201cb\u201d is equivalent to \u201cy\u201d; and \u201cz\u201d is equivalent to \u201cc\u201d, which equals \u201cconcat(a, b)\u201d according to the source code of \u201cfoo\u201d. The pre-conditions and the negated post-conditions may then be added to this set of constraints. The final set of constraints for PATH  thus becomes \u201c(p=concat(concat(a, b), \u201ct\u201d))) && (concat(a, b) !=\u201cqrs\u201d) && (b.endsWith(\u201cs\u201d) && !(p.endsWith(\u201ct\u201d))\u201d.","For the second path, PATH , the set of expressions obtained from performing symbolic execution on \u201cfoo\u201d may be written as \u201c(p=concat(a, b)) && (concat(a, b)=\u201cqrs\u201d)\u201d, as indicated by  of . Note that \u201cp\u201d has the value of \u201cc\u201d for PATH  because \u201cc\u201d is the value that is returned by \u201cfoo\u201d (i.e., the output of \u201cfoo\u201d) at the end of PATH , and \u201cz\u201d is the symbolic value assigned to \u201cc\u201d, which equals \u201cconcat(a, b)\u201d according to the source code of \u201cfoo\u201d. The pre-conditions and the negated post-conditions may then be similarly added to this set of constraints as well. The final set of constraints for PATH  becomes \u201c\u201c(p=concat(a, b)) && (concat(a, b)=\u201cqrs\u201d) && (b.endsWith(\u201cs\u201d) && !(p.endsWith(\u201ct\u201d))\u201d.","Particular embodiments may then attempt to find one or more solutions for each set of constraints corresponding to each possible execution path of the software module, as illustrated in step  of , using the process illustrated in . Each set of constraints includes the constraints obtained from performing symbolic execution on the software module as well as the pre-conditions and the negated post-conditions associated with the software module. In particular embodiments, for each set of constraints corresponding to a specific execution path of the software module, if no solution may be found that satisfies all the constraints from the set, then for this execution path, the software module satisfies the requirements placed on its input and output as represented by the pre-conditions and the post-conditions. Recall that each set of constraints includes the negated post-conditions placed on the output of the software module, as explained in steps  and  of . Thus, if no solution may be found for the set of constraints (i.e., the set of constraints is unsatisfiable), and more specifically, if no solution may be found that satisfies the negated post-conditions, then it means that the pre-conditions and the post-conditions hold true for the corresponding execution path. Conversely, if any solution may be found that satisfies all the constraints from the set, then for the corresponding execution path, the software module does not satisfy the requirements placed on its input and output because the pre-conditions and the post-conditions do not hold true for the execution path. Consequently, if any solution may be found for any set of constraints obtained in step  of , then the software module does not pass the validation test in connection with the requirements placed on its input and output. Only when each and every set of constraint obtained at step  of  is unsatisfiable does the software module pass the validation test with respect to the requirements placed on its input and output.",{"@attributes":{"id":"p-0084","num":"0083"},"figref":["FIG. 9B","FIG. 9A"],"b":["902","904","906","912","914","916","912","914","916","902","904","906"]},"In particular embodiments, a process, such as the one illustrated in , may be used to validate a software module designed to detect and catch injection attacks. An injection attack, also known as insertion attack, is a form a malicious software attack that often targets SQL databases and other vulnerable websites. In general, a SQL injection is a code injection technique that exploits a security vulnerability occurring in the database layer of a software application. The vulnerability may occur whenever one programming or scripting language is embedded inside another programming or scripting language. More specifically, the vulnerability may be present when user input is either incorrectly filtered for string literal escape characters embedded in SQL statements or user input is not strongly typed and thereby unexpectedly executed. For example, an injection attack may embed the string \u201cshutdown\u201d in anther string (e.g., a random set of characters) as \u201cqk%$d1shutdownsq&^d\u201d, and send this string as an input command (e.g., a SQL statement) to a database. If the database software does not catch the \u201cshutdown\u201d string embedded in the seemingly random input string and execute it, the \u201cshutdown\u201d string may cause the database to shut down inadvertently. As a result, most databases have software modules designed to detect and catch such injection attacks. In particular embodiments, the process illustrated in  may be used to verify whether such a security software module is able to detect many different forms of malicious strings that may be embedded in input as injection attacks. For example, one way to test a security software module may be to devise a malicious string or a way to embed a malicious string such that the security software module is unable to detect it (e.g., to fool the security software module into believing that the malicious string is harmless).",{"@attributes":{"id":"p-0086","num":"0085"},"figref":"FIG. 11"},"Particular embodiments may select a set of malicious strings, such as \u201cshutdown\u201d, that are likely to be used in connection with injection attacks, as illustrated in step  of . Let \u201cm\u201d represent a specific malicious string. Particular embodiments may then embed each malicious string from the set in another string, represented by \u201cs\u201d, as illustrated in step  of . There may be some characters (i.e., a substring) before the malicious string and some characters (i.e., another substring) after the malicious string in \u201cs\u201d. Thus, \u201cs\u201d may be represented as \u201cs=concat(concat(x, m), y)\u201d, where \u201cx\u201d represents the substring before malicious string \u201cm\u201d, and \u201cy\u201d represents the substring after malicious string \u201cm\u201d, in \u201cs\u201d. Note that either \u201cx\u201d or \u201cy\u201d may be an empty string, and \u201cm\u201d becomes another substring of \u201cs\u201d. String \u201cs\u201d may then be applied to a security software module as an input value.","Particular embodiments may perform symbolic execution on the security software module to obtain a set of constraints that, if satisfied, causes the security software module to execute to its end and return with an indication that the input value has passed all the security checks contained therein successfully (e.g., return TRUE), as illustrated in step  of . Symbolic execution has been described above in connection with step  of , and may be similarly performed here. When determining the set of constraints, particular embodiments may incorporate the numeric and string constraints initially placed on the specific variables of the software module (e.g., as described in connection with step  of ), if any, as well as the numeric and string constraints inferred for the specific variables of the software module (e.g., as described in connection with step  of ), if any. In particular embodiments, the set of constraints, thus obtained, represents all the constraints that need to be satisfied for an input value assigned to the input variable of the security software module to successfully pass all the security checks contained in the security software module so that the software module returns an output value indicating that the input value is harmless.","Particular embodiments may attempt to find one or more solutions for \u201cs\u201d, as each malicious string being embedded therein, such that \u201cs\u201d satisfies all the constraints, as illustrated in step  of , using the process illustrated in . If any solution may be found for \u201cs\u201d that satisfies the set of constraints, it means that there is at least one malicious string embedded in \u201cs\u201d that may slip pass all the security checks contained in the security software module. Consequently, the security software module is vulnerable to injection attacks.","Using malicious string \u201cshutdown\u201d as an example. Embedding this string in \u201cs\u201d results in \u201cs=concat(concat(x, \u201cshutdown\u201d), y)\u201d. Using the process illustrated in , particular embodiments may attempt to find if there is any solution for \u201cs\u201d providing values for substrings \u201cx\u201d and \u201cy\u201d such that \u201cs\u201d, with \u201cshutdown\u201d embedded therein, may satisfy all the constraints from the set of constraints obtained from performing symbolic execution on the security software module. If there is a solution for \u201cx\u201d and \u201cy\u201d, it means that there is at least one way to embed malicious string \u201cshutdown\u201d in string \u201cs\u201d having the value \u201cconcat(concat(x, \u201cshutdown\u201d), y)\u201d such that string \u201cs\u201d is able to pass all the security checks contained in the security software module successfully (i.e., the security software module fails to detect this specific injection attack embedded with malicious string \u201cshutdown\u201d).","In particular embodiments, each malicious string may be represented using different data types when embedded in string \u201cs\u201d. For example, the string \u201cshutdown\u201d represented as a hexadecimal number is \u201c0x73687574646f776e\u201d. Thus, one possible value for \u201cs\u201d may be \u201cexec shutdown\u201d representing the malicious string in string data type, while another possible value for \u201cs\u201d may be \u201cdeclare @a char(20) select @a=0x73687574646f776e exec (@a)\u201d representing the malicious string in integer data type. Particular embodiments may attempt to find solutions for \u201cs\u201d where the embedded malicious string is represented using different data types. As a result, not only is the security software module tested with the malicious strings represented in the conventional string data type but is tested with the malicious strings represented in unexpected data types (e.g., represented as integer or float numbers) as well.","Particular embodiments may embed each malicious string \u201cm\u201d from the set of malicious strings in \u201cs\u201d and then attempt to find solutions for \u201cs\u201d providing specific values for \u201cx\u201d and \u201cy\u201d such that \u201cs\u201d as a whole string (i.e., including \u201cx\u201d, \u201cm\u201d, and \u201cy\u201d) satisfies the set of constraints obtained from step  of . If any solution may be found for \u201cs\u201d with any malicious string \u201cm\u201d embedded therein, it means that the security software module is unable to detect the corresponding injection attack and is therefore vulnerable. Moreover, if no solution may be found for \u201cs\u201d with any malicious string \u201cm\u201d embedded therein, particular embodiments may further attempt to find a solution that satisfies the set of constraints obtained from step  of . If any solution may be found, particular embodiments may verify whether the solution itself is in fact a malicious string. This validation on the security software module attempts to determine whether a malicious string, in itself without being embedded in another string, is able to successfully pass all the security checks contained in the security software module (i.e., whether the security software module fails to detect any malicious string).",{"@attributes":{"id":"p-0093","num":"0092"},"figref":["FIG. 9C","FIG. 9A"],"b":["902","904","906","912","914","916","912","914","916","902","904","906"]},"Particular embodiments may be implemented in a network environment.  illustrates an example network environment  suitable for providing software validation as a service. Network environment  includes a network  coupling one or more servers  and one or more clients  to each other. In particular embodiments, network  is an intranet, an extranet, a virtual private network (VPN), a local area network (LAN), a wireless LAN (WLAN), a wide area network (WAN), a metropolitan area network (MAN), a portion of the Internet, or another network  or a combination of two or more such networks . The present disclosure contemplates any suitable network .","One or more links  couple a server  or a client  to network . In particular embodiments, one or more links  each includes one or more wireline, wireless, or optical links . In particular embodiments, one or more links  each includes an intranet, an extranet, a VPN, a LAN, a WLAN, a WAN, a MAN, a portion of the Internet, or another link  or a combination of two or more such links . The present disclosure contemplates any suitable links  coupling servers  and clients  to network .","In particular embodiments, each server  may be a unitary server or may be a distributed server spanning multiple computers or multiple datacenters. Servers  may be of various types, such as, for example and without limitation, web server, news server, mail server, message server, advertising server, file server, application server, exchange server, database server, or proxy server. In particular embodiments, each server  may include hardware, software, or embedded logic components or a combination of two or more such components for carrying out the appropriate functionalities implemented or supported by server . For example, a web server is generally capable of hosting websites containing web pages or particular elements of web pages. More specifically, a web server may host HTML files or other file types, or may dynamically create or constitute files upon a request, and communicate them to clients  in response to HTTP or other requests from clients . A mail server is generally capable of providing electronic mail services to various clients . A database server is generally capable of providing an interface for managing data stored in one or more data stores.","In particular embodiments, one or more data storages  may be communicatively linked to one or more severs  via one or more links . In particular embodiments, data storages  may be used to store various types of information. In particular embodiments, the information stored in data storages  may be organized according to specific data structures. In particular embodiment, each data storage  may be a relational database. Particular embodiments may provide interfaces that enable servers  or clients  to manage, e.g., retrieve, modify, add, or delete, the information stored in data storage .","In particular embodiments, each client  may be an electronic device including hardware, software, or embedded logic components or a combination of two or more such components and capable of carrying out the appropriate functionalities implemented or supported by client . For example and without limitation, a client  may be a desktop computer system, a notebook computer system, a netbook computer system, a handheld electronic device, or a mobile telephone. The present disclosure contemplates any suitable clients . A client  may enable a network user at client  to access network . A client  may enable its user to communicate with other users at other clients .","A client  may have a web browser , such as MICROSOFT INTERNET EXPLORER, GOOGLE CHROME or MOZILLA FIREFOX, and may have one or more add-ons, plug-ins, or other extensions, such as TOOLBAR or YAHOO TOOLBAR. A user at client  may enter a Uniform Resource Locator (URL) or other address directing the web browser  to a server , and the web browser  may generate a Hyper Text Transfer Protocol (HTTP) request and communicate the HTTP request to server . Server  may accept the HTTP request and communicate to client  one or more Hyper Text Markup Language (HTML) files responsive to the HTTP request. Client  may render a web page based on the HTML files from server  for presentation to the user. The present disclosure contemplates any suitable web page files. As an example and not by way of limitation, web pages may render from HTML files, Extensible Hyper Text Markup Language (XHTML) files, or Extensible Markup Language (XML) files, according to particular needs. Such pages may also execute scripts such as, for example and without limitation, those written in JAVASCRIPT, JAVA, MICROSOFT SILVERLIGHT, combinations of markup language and scripts such as AJAX (Asynchronous JAVASCRIPT and XML), and the like. Herein, reference to a web page encompasses one or more corresponding web page files (which a browser may use to render the web page) and vice versa, where appropriate.","Particular embodiments may be implemented on one or more computer systems.  illustrates an example computer system . In particular embodiments, one or more computer systems  perform one or more steps of one or more methods described or illustrated herein. In particular embodiments, one or more computer systems  provide functionality described or illustrated herein. In particular embodiments, software running on one or more computer systems  performs one or more steps of one or more methods described or illustrated herein or provides functionality described or illustrated herein. Particular embodiments include one or more portions of one or more computer systems .","This disclosure contemplates any suitable number of computer systems . This disclosure contemplates computer system  taking any suitable physical form. As example and not by way of limitation, computer system  may be an embedded computer system, a system-on-chip (SOC), a single-board computer system (SBC) (such as, for example, a computer-on-module (COM) or system-on-module (SOM)), a desktop computer system, a laptop or notebook computer system, an interactive kiosk, a mainframe, a mesh of computer systems, a mobile telephone, a personal digital assistant (PDA), a server, or a combination of two or more of these. Where appropriate, computer system  may include one or more computer systems ; be unitary or distributed; span multiple locations; span multiple machines; or reside in a cloud, which may include one or more cloud components in one or more networks. Where appropriate, one or more computer systems  may perform without substantial spatial or temporal limitation one or more steps of one or more methods described or illustrated herein. As an example and not by way of limitation, one or more computer systems  may perform in real time or in batch mode one or more steps of one or more methods described or illustrated herein. One or more computer systems  may perform at different times or at different locations one or more steps of one or more methods described or illustrated herein, where appropriate.","In particular embodiments, computer system  includes a processor , memory , storage , an input\/output (I\/O) interface , a communication interface , and a bus . Although this disclosure describes and illustrates a particular computer system having a particular number of particular components in a particular arrangement, this disclosure contemplates any suitable computer system having any suitable number of any suitable components in any suitable arrangement.","In particular embodiments, processor  includes hardware for executing instructions, such as those making up a computer program. As an example and not by way of limitation, to execute instructions, processor  may retrieve (or fetch) the instructions from an internal register, an internal cache, memory , or storage ; decode and execute them; and then write one or more results to an internal register, an internal cache, memory , or storage . In particular embodiments, processor  may include one or more internal caches for data, instructions, or addresses. The present disclosure contemplates processor  including any suitable number of any suitable internal caches, where appropriate. As an example and not by way of limitation, processor  may include one or more instruction caches, one or more data caches, and one or more translation lookaside buffers (TLBs). Instructions in the instruction caches may be copies of instructions in memory  or storage , and the instruction caches may speed up retrieval of those instructions by processor . Data in the data caches may be copies of data in memory  or storage  for instructions executing at processor  to operate on; the results of previous instructions executed at processor  for access by subsequent instructions executing at processor  or for writing to memory  or storage ; or other suitable data. The data caches may speed up read or write operations by processor . The TLBs may speed up virtual-address translation for processor . In particular embodiments, processor  may include one or more internal registers for data, instructions, or addresses. The present disclosure contemplates processor  including any suitable number of any suitable internal registers, where appropriate. Where appropriate, processor  may include one or more arithmetic logic units (ALUs); be a multi-core processor; or include one or more processors . Although this disclosure describes and illustrates a particular processor, this disclosure contemplates any suitable processor.","In particular embodiments, memory  includes main memory for storing instructions for processor  to execute or data for processor  to operate on. As an example and not by way of limitation, computer system  may load instructions from storage  or another source (such as, for example, another computer system ) to memory . Processor  may then load the instructions from memory  to an internal register or internal cache. To execute the instructions, processor  may retrieve the instructions from the internal register or internal cache and decode them. During or after execution of the instructions, processor  may write one or more results (which may be intermediate or final results) to the internal register or internal cache. Processor  may then write one or more of those results to memory . In particular embodiments, processor  executes only instructions in one or more internal registers or internal caches or in memory  (as opposed to storage  or elsewhere) and operates only on data in one or more internal registers or internal caches or in memory  (as opposed to storage  or elsewhere). One or more memory buses (which may each include an address bus and a data bus) may couple processor  to memory . Bus  may include one or more memory buses, as described below. In particular embodiments, one or more memory management units (MMUs) reside between processor  and memory  and facilitate accesses to memory  requested by processor . In particular embodiments, memory  includes random access memory (RAM). This RAM may be volatile memory, where appropriate Where appropriate, this RAM may be dynamic RAM (DRAM) or static RAM (SRAM). Moreover, where appropriate, this RAM may be single-ported or multi-ported RAM. The present disclosure contemplates any suitable RAM. Memory  may include one or more memories , where appropriate. Although this disclosure describes and illustrates particular memory, this disclosure contemplates any suitable memory.","In particular embodiments, storage  includes mass storage for data or instructions. As an example and not by way of limitation, storage  may include an HDD, a floppy disk drive, flash memory, an optical disc, a magneto-optical disc, magnetic tape, or a Universal Serial Bus (USB) drive or a combination of two or more of these. Storage  may include removable or non-removable (or fixed) media, where appropriate. Storage  may be internal or external to computer system , where appropriate. In particular embodiments, storage  is non-volatile, solid-state memory. In particular embodiments, storage  includes read-only memory (ROM). Where appropriate, this ROM may be mask-programmed ROM, programmable ROM (PROM), erasable PROM (EPROM), electrically erasable PROM (EEPROM), electrically alterable ROM (EAROM), or flash memory or a combination of two or more of these. This disclosure contemplates mass storage  taking any suitable physical form. Storage  may include one or more storage control units facilitating communication between processor  and storage , where appropriate. Where appropriate, storage  may include one or more storages . Although this disclosure describes and illustrates particular storage, this disclosure contemplates any suitable storage.","In particular embodiments, I\/O interface  includes hardware, software, or both providing one or more interfaces for communication between computer system  and one or more I\/O devices. Computer system  may include one or more of these I\/O devices, where appropriate. One or more of these I\/O devices may enable communication between a person and computer system . As an example and not by way of limitation, an I\/O device may include a keyboard, keypad, microphone, monitor, mouse, printer, scanner, speaker, still camera, stylus, tablet, touch screen, trackball, video camera, another suitable I\/O device or a combination of two or more of these. An I\/O device may include one or more sensors. This disclosure contemplates any suitable I\/O devices and any suitable I\/O interfaces  for them. Where appropriate, I\/O interface  may include one or more device or software drivers enabling processor  to drive one or more of these I\/O devices. I\/O interface  may include one or more I\/O interfaces , where appropriate. Although this disclosure describes and illustrates a particular I\/O interface, this disclosure contemplates any suitable I\/O interface.","In particular embodiments, communication interface  includes hardware, software, or both providing one or more interfaces for communication (such as, for example, packet-based communication) between computer system  and one or more other computer systems  or one or more networks. As an example and not by way of limitation, communication interface  may include a network interface controller (NIC) or network adapter for communicating with an Ethernet or other wire-based network or a wireless NIC (WNIC) or wireless adapter for communicating with a wireless network, such as a WI-FI network. This disclosure contemplates any suitable network and any suitable communication interface  for it. As an example and not by way of limitation, computer system  may communicate with an ad hoc network, a personal area network (PAN), a local area network (LAN), a wide area network (WAN), a metropolitan area network (MAN), or one or more portions of the Internet or a combination of two or more of these. One or more portions of one or more of these networks may be wired or wireless. As an example, computer system  may communicate with a wireless PAN (WPAN) (such as, for example, a BLUETOOTH WPAN), a WI-FI network, a WI-MAX network, a cellular telephone network (such as, for example, a Global System for Mobile Communications (GSM) network), or other suitable wireless network or a combination of two or more of these. Computer system  may include any suitable communication interface  for any of these networks, where appropriate. Communication interface  may include one or more communication interfaces , where appropriate. Although this disclosure describes and illustrates a particular communication interface, this disclosure contemplates any suitable communication interface.","In particular embodiments, bus  includes hardware, software, or both coupling components of computer system  to each other. As an example and not by way of limitation, bus  may include an Accelerated Graphics Port (AGP) or other graphics bus, an Enhanced Industry Standard Architecture (EISA) bus, a front-side bus (FSB), a HYPERTRANSPORT (HT) interconnect, an Industry Standard Architecture (ISA) bus, an INFINIBAND interconnect, a low-pin-count (LPC) bus, a memory bus, a Micro Channel Architecture (MCA) bus, a Peripheral Component Interconnect (PCI) bus, a PCI-Express (PCI-X) bus, a serial advanced technology attachment (SATA) bus, a Video Electronics Standards Association local (VLB) bus, or another suitable bus or a combination of two or more of these. Bus  may include one or more buses , where appropriate. Although this disclosure describes and illustrates a particular bus, this disclosure contemplates any suitable bus or interconnect.","Herein, reference to a computer-readable storage medium encompasses one or more non-transitory, tangible computer-readable storage media possessing structure. As an example and not by way of limitation, a computer-readable storage medium may include a semiconductor-based or other integrated circuit (IC) (such, as for example, a field-programmable gate array (FPGA) or an application-specific IC (ASIC)), a hard disk, an HDD, a hybrid hard drive (HHD), an optical disc, an optical disc drive (ODD), a magneto-optical disc, a magneto-optical drive, a floppy disk, a floppy disk drive (FDD), magnetic tape, a holographic storage medium, a solid-state drive (SSD), a RAM-drive, a SECURE DIGITAL card, a SECURE DIGITAL drive, or another suitable computer-readable storage medium or a combination of two or more of these, where appropriate. Herein, reference to a computer-readable storage medium excludes any medium that is not eligible for patent protection under 35 U.S.C. \u00a7101. Herein, reference to a computer-readable storage medium excludes transitory forms of signal transmission (such as a propagating electrical or electromagnetic signal per se) to the extent that they are not eligible for patent protection under 35 U.S.C. \u00a7101.","This disclosure contemplates one or more computer-readable storage media implementing any suitable storage. In particular embodiments, a computer-readable storage medium implements one or more portions of processor  (such as, for example, one or more internal registers or caches), one or more portions of memory , one or more portions of storage , or a combination of these, where appropriate. In particular embodiments, a computer-readable storage medium implements RAM or ROM. In particular embodiments, a computer-readable storage medium implements volatile or persistent memory. In particular embodiments, one or more computer-readable storage media embody software. Herein, reference to software may encompass one or more applications, bytecode, one or more computer programs, one or more executables, one or more instructions, logic, machine code, one or more scripts, or source code, and vice versa, where appropriate. In particular embodiments, software includes one or more application programming interfaces (APIs). This disclosure contemplates any suitable software written or otherwise expressed in any suitable programming language or combination of programming languages. In particular embodiments, software is expressed as source code or object code. In particular embodiments, software is expressed in a higher-level programming language, such as, for example, C, Perl, or a suitable extension thereof. In particular embodiments, software is expressed in a lower-level programming language, such as assembly language (or machine code). In particular embodiments, software is expressed in JAVA. In particular embodiments, software is expressed in Hyper Text Markup Language (HTML), Extensible Markup Language (XML), or other suitable markup language.","The present disclosure encompasses all changes, substitutions, variations, alterations, and modifications to the example embodiments herein that a person having ordinary skill in the art would comprehend. Similarly, where appropriate, the appended claims encompass all changes, substitutions, variations, alterations, and modifications to the example embodiments herein that a person having ordinary skill in the art would comprehend."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0004","num":"0003"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIGS. 9A-9C"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 13"}]},"DETDESC":[{},{}]}
