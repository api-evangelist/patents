---
title: Method and system for naming and binding objects
abstract: A method and system for referring to and binding to objects using a moniker object is provided. In a preferred embodiments moniker object contains information to identify linked source data and provides methods through which a program can bind to the linked source data. A binding method is provided that returns an instance of an interface through which the linked source data can be accessed. The moniker object can identify source data that is stored persistently or nonpersistently. In addition, moniker objects can be composed to form a composite moniker object. A composite moniker object is used to identify linked source data that is nested in other data. In a preferred embodiment, the moniker object provides other methods including a reducing method that returns a more efficient representation of the moniker object; equality and hash methods for comparing moniker objects; and inverse, common prefix, and relative-path-to methods for comparing and locating moniker objects from other moniker objects. Several implementations of a moniker object are provided including a file moniker, an item moniker, a generic composite moniker, a pointer moniker, and an anti moniker. Each implementation is a moniker class and has a class identifier that identifies code to manage the moniker class.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07150024&OS=07150024&RS=07150024
owner: Microsoft Corporation
number: 07150024
owner_city: Redmond
owner_country: US
publication_date: 20021029
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATION DATA","TECHNICAL FIELD","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This application is a continuation of U.S. patent application Ser. No. 09\/867,8537, filed May 29, 2001, now U.S. Pat. No. 6,519,764, entitled \u201cMethod and System for Naming and Binding Objects,\u201d the disclosure of which is hereby incorporated by reference, which is a continuation of U.S. patent application Ser. No. 08\/916,999, filed Aug. 20, 1997, now U.S. Pat. No. 6,263,379, entitled \u201cMethod and System for Referring to and Binding to Objects Using Identifier Objects,\u201d which is a continuation of U.S. patent application Ser. No. 08\/467,917, filed Jun. 6, 1995, now U.S. Pat. No. 5,740,439, entitled \u201cMethod and System for Referring to and Binding to Objects Using Identifier Objects,\u201d which is a divisional of U.S. patent application Ser. No. 08\/088,724, filed Jul. 6, 1993, now U.S. Pat. No. 5,581,760, entitled \u201cMethod and System for Referring to and Binding to Objects Using Identifier Objects,\u201d which is a continuation-in-part of U.S. patent application Ser. No. 07\/909,983, filed Jul. 6, 1992, entitled \u201cMethod and System for Naming and Binding Objects,\u201d now abandoned.","This invention relates generally to a computer method and system for referencing objects and, more specifically, to a method and system for naming objects and binding to objects","Current document processing computer systems allow a user to prepare compound documents. A compound document is a document that contains information in various formats. For example, a compound document may contain data in text format, chart format, numerical format, etc.  is an example of a compound document. In this example, the compound document  is generated as a report for a certain manufacturing project. The compound document  contains scheduling data , which is presented in chart format; budgeting data , which is presented in spreadsheet format; and explanatory data , which is presented in text format. In typical prior systems, a user generates the scheduling data  using a project management computer program and the budgeting data  using a spreadsheet computer program. After this data has been generated, the user creates the compound document , enters the explanatory data , and incorporates the scheduling data  and budgeting data  using a word processing computer program.",{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 2","b":["201","203","204","203","203","201","204"]},"After data has been copied to the clipboard , the user starts up the word processing program  to create the compound document . The user enters the explanatory data  and specifies the locations in the compound document  to which the scheduling data and budgeting data that are in the clipboard  are to be copied. The copying of data from a clipboard to a document is referred to as \u201cpasting\u201d from the clipboard. The word processing program  then copies the scheduling data  and the budgeting data  from the clipboard  into the compound document  at the specified locations. Data that is copied from the clipboard into a compound document is referred to as \u201cembedded\u201d data. The word processing program  treats the embedded data as simple bitmaps that it displays with a BitBlt operation when rendering the compound document  on an output device. In some prior systems, a clipboard may only be able to store data for one copy command at a time. In such a system, the scheduling data can be copied to the clipboard and then pasted into the compound document. Then, the budgeting data can be copied to the clipboard and then pasted into the compound document.","Since word processors typically process only text data, users of the word processing program can move or delete embedded data, but cannot modify embedded data, unless the data is in text format. Thus, if a user wants to modify, for example, the budgeting data  that is in the compound document , the user must start up the spreadsheet program , load in the budgeting data  from a file, make the modifications, copy the modifications to the clipboard , start up the word processing program , load in the compound document , and paste the modified clipboard data into the compound document .","Some prior systems store links to the data to be included in the compound document rather than actually embedding the data. When a word processing program pastes the data from a clipboard into a compound document, a link is stored in the compound document. The link points to the data (typically residing in a file) to be included. These prior systems typically provide links to data in a format that the word processing program recognizes or treats as presentation format. For example, when the word processing program  is directed by a user to paste the scheduling data and budgeting data into the compound document by linking, rather than embedding, the names of files in which the scheduling data and budgeting data reside in presentation format are inserted into the document. Several compound documents can contain links to the same data to allow one copy of the data to be shared by several compound documents.","A link is conceptually a path name to the data. Some prior systems store two-level links. A two-level link identifies both a file and an area within the file. For example, the two-level link \u201c\\BUDGET.XLS\\R2C2:R7C4\u201d identifies a spreadsheet file \u201c\\BUDGET.XLS\u201d and the range of cells \u201cR2C2:R7C4.\u201d The use of two-level links limits the source of the links to data that is nested one level within a file. If a file contains multiple spreadsheets, then a two-level link could identify the file and a spreadsheet, but could not identify a range within the spreadsheet. It would be desirable to have a method and system of supporting links to an arbitrary level.","Since the present invention is described below using object-oriented programming, an overview of well-known object-oriented programming techniques is provided. Two common characteristics of object-oriented programming languages are support for data encapsulation and data type inheritance. Data encapsulation refers to the binding of functions and data. Inheritance refers to the ability to declare a data type in terms of other data types.","In the C++ language, object-oriented techniques are supported through the use of classes. A class is a user-defined type. A class declaration describes the data members and function members of the class. For example, the following declaration defines data members and a function member of a class named CIRCLE.",{"@attributes":{"id":"p-0012","num":"0011"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"class CIRCLE"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{ public:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int x, y;"]},{"entry":[{},"int radius;"]},{"entry":[{},"void draw( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"In the syntax of C++, the following statement declares the objects a and b to be of type class CIRCLE.\n\n","A derived class is a class that inherits the characteristics\u2014data members and function members\u2014of its base classes. For example, the following derived class CIRCLE_FILL inherits the characteristics of the base class CIRCLE.",{"@attributes":{"id":"p-0015","num":"0023"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"class CIRCLE_FILL : CIRCLE"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{ public:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int pattern;"]},{"entry":[{},"void fill( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"A derived class may specify that a base class is to be inherited virtually. Virtual inheritance of a base class means that only one instance of the virtual base class exists in the derived class. For example, the following is an example of a derived class with two nonvirtual base classes.\n\n","The following is an example of a derived class with two virtual base classes.\n\n","A class may also specify whether its function members are virtual. Declaring that a function member is virtual means that the function can be overridden by a function of the same name and type in a derived class. In the following example, the function draw is declared to be virtual in classes CIRCLE and CIRCLE_FILL.",{"@attributes":{"id":"p-0019","num":"0033"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"class CIRCLE"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{ public:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int x, y;"]},{"entry":[{},"int radius;"]},{"entry":[{},"virtual void draw( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"};"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"class CIRCLE_FILL : CIRCLE"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{ public:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int pattern;"]},{"entry":[{},"virtual void draw( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The C++ language provides a pointer data type. A pointer holds values that are addresses of objects in memory. Through a pointer, an object can be referenced. The following statement declares variable c_ptr to be a pointer on an object of type class CIRCLE and sets variable c_ptr to hold the address of object c.\n\n",{"@attributes":{"id":"p-0021","num":"0041"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CIRCLE *c_ptr;",{}]},{"entry":[{},"c_ptr = &b"]},{"entry":[{},"c_ptr\u2212>draw( );","\/\/ CIRCLE_FILL::draw( )"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0022","num":"0042"},"figref":"FIG. 3","b":["301","302","303","304","305","301","302","302"]},"An advantage of using object-oriented techniques is that these techniques can be used to facilitate the sharing of objects. In particular, object-oriented techniques facilitate the creation of compound documents. A compound document (as described above) is a document that contains objects generated by various computer programs. (Typically, only the data members of the object and the class type are stored in a compound document.) For example, a word processing document that contains a spreadsheet object generated by a spreadsheet program is a compound document. A word processing program allows a user to embed a spreadsheet object (e.g., a cell) within a word processing document. To allow this embedding, the word processing program is compiled using the class definition of the object to be embedded to access function members of the embedded object. Thus, the word processing program would need to be compiled using the class definition of each class of objects that can be embedded in a word processing document. To embed an object of a new class into a word processing document, the word processing program would need to be recompiled with the new class definition. Thus, only objects of classes selected by the developer of the word processing program can be embedded. Furthermore, new classes can only be supported with a new release of the word processing program.","To allow objects of an arbitrary class to be embedded into compound documents, interfaces are defined through which an object can be accessed without the need for the word processing program to have access to the class definitions at compile time. An abstract class is a class in which a virtual function member has no implementation (pure). An interface is an abstract class with no data members and whose virtual functions are all pure.","The following class definition is an example definition of an interface. In this example, for simplicity of explanation, rather than allowing any class of object to be embedded in its documents, a word processing program allows spreadsheet objects to be embedded. Any spreadsheet object that provides this interface can be embedded, regardless of how the object is implemented. Moreover, any spreadsheet object, whether implemented before or after the word processing program is compiled, can be embedded.",{"@attributes":{"id":"p-0026","num":"0046"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"class","ISpreadSheet"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{ virtual void File( ) = 0;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"virtual void Edit( ) = 0;"]},{"entry":[{},"virtual void Formula( ) = 0;"]},{"entry":[{},"virtual void Format( ) = 0;"]},{"entry":[{},"virtual void GetCell (string RC, cell *pCell) = 0;"]},{"entry":[{},"virtual void Data( ) = 0;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"For example, a spreadsheet object developed by Microsoft Corporation may have a class identifier of \u201cMSSpreadsheet,\u201d while a spreadsheet object developed by another corporation may have a class identifier of \u201cLTSSpreadsheet.\u201d A persistent registry in each computer system is maintained that maps each class identifier to the code that implements the class. Typically, when a spreadsheet program is installed on a computer system, the persistent registry is updated to reflect the availability of that class of spreadsheet objects. So long as a spreadsheet developer implements each function member defined by the interface and the persistent registry is maintained, the word processing program can embed the developer's spreadsheet objects into a word processing document.","Various spreadsheet developers may wish, however, to implement only certain function members. For example, a spreadsheet developer may not want to implement database support, but may want to support all other function members. To allow a spreadsheet developer to support only some of the function members, while still allowing the objects to be embedded, multiple interfaces for spreadsheet objects are defined. For example, the interfaces IDatabase and IBasic may be defined for a spreadsheet object as follows.",{"@attributes":{"id":"p-0029","num":"0049"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"class","IBasic"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{ virtual void File( ) = 0;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"virtual void Edit( ) = 0;"]},{"entry":[{},"virtual void Formula( ) = 0;"]},{"entry":[{},"virtual void Format( ) = 0;"]},{"entry":[{},"virtual void GetCell (string RC, cell *pCell) = 0;"]},{"entry":[{},"}"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"class","IDatabase"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ virtual void Data( ) = 0;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"At run time, the word processing program would need to determine whether a spreadsheet object to be embedded supports the IDatabase interface. To make this determination, another interface is defined (that every spreadsheet object implements) with a function member that indicates which interfaces are implemented for the object. This interface is named IUnknown (and referred to as the unknown interface or the object management interface) and is defined as follows.",{"@attributes":{"id":"p-0031","num":"0051"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"class IUnknown"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{ virtual HRESULT QueryInterface (REFIID iid, void **ppv) = 0;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"virtual ULONG AddRef( ) = 0;"]},{"entry":[{},"virtual ULONG Release( ) = 0;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},{"@attributes":{"id":"p-0032","num":"0052"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"CODE TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"HRESULT XX::QueryInterface(REFIID iid, void **ppv)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{ ret = TRUE;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"switch (iid)"]},{"entry":[{},"{ case IID_IBasic:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"*ppv = *pIBasic;"]},{"entry":[{},"break;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case IID_IDatabase:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"*ppv = *pIDatabase;"]},{"entry":[{},"break;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case IID_IUnknown:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"*ppv = this;"]},{"entry":[{},"break;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"default:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"ret = FALSE;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"if (ret == TRUE){AddRef( );};"]},{"entry":[{},"return ret;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Code Table 1 contains C++ pseudocode for a typical implementation of the method QueryInterface for class XX, which inherits the class IUnknown. If the spreadsheet object supports the IDatabase interface, then the method QueryInterface includes the appropriate case label within the switch statement. The variables pIBasic and pIDatabase point to a pointer to the virtual function tables of the IBasic and IDatabase interfaces, respectively. The method QueryInterface invokes the method AddRef (described below) to increment a reference count for the object of class XX when a pointer to an interface is returned.",{"@attributes":{"id":"p-0034","num":"0054"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":[{"entry":[{},"CODE TABLE 2"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void XX::AddRef( ) {refcount++;}"]},{"entry":[{},"void XX::Release( ) {if (--refcount==0) delete this;}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The interface IUnknown also defines the methods AddRef and Release, which are used to implement reference counting. Whenever a new reference to an interface is created, the method AddRef is invoked to increment a reference count of the object. Whenever a reference is no longer needed, the method Release is invoked to decrement the reference count of the object and, when the reference count goes to zero, to deallocate the object. Code Table 2 contains C++ pseudocode for a typical implementation of the methods AddRef and Release for class XX, which inherits the class IUnknown.","The IDatabase interface and IBasic interface inherit the IUnknown interface. The following definitions illustrate the use of the IUnknown interface.",{"@attributes":{"id":"p-0037","num":"0057"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"class IDatabase : public IUnknown"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{ public:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"virtual void Data( ) = 0;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"class IBasic : public IUnknown"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{ public:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"virtual void File( ) = 0;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003virtual void Edit( ) = 0;"]},{"entry":[{},"\u2003virtual void Formula( ) = 0;"]},{"entry":[{},"\u2003virtual void Format( ) = 0;"]},{"entry":[{},"\u2003virtual void GetCell (string RC, cell *pCell) = 0;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0038","num":"0058"},"figref":"FIG. 4","b":["401","403","404","402","405","406","407","421","401","402","402","403","405","405","404","406","406","405","406","422"]},"The following pseudocode illustrates how a word processing program determines whether a spreadsheet object supports the IDatabase interface.",{"@attributes":{"id":"p-0040","num":"0060"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"if (pIBasic\u2212> QueryInterface(\u201cIDatabase\u201d, &pIDatabase) ==S_OK)"},{"entry":"\\* IDatabase supported"},{"entry":"else"},{"entry":"\\* IDatabase not supported"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"Normally, an object can be instantiated (an instance of the object created in memory) by a variable declaration or by the \u201cnew\u201d operator. However, both techniques of instantiation need the class definition at compile time. A different technique is needed to allow a word processing program to instantiate a spreadsheet object at run time. One technique provides a global function CreateInstanceXX, which is defined in the following.\n\n","It is an object of the present invention to provide a method and system for generating links to source data incorporated within a compound document.","It is another object of the present invention for binding links to source data.","It is another object of the present invention for interfacing with these links in a manner that is independent of the underlying source data.","It is another object of the present invention for linking to data nested to an arbitrary level within a compound document.","These and other objects, which will become apparent as the invention is more fully described below, are provided by a method and system for naming and binding data objects. In a preferred embodiment, a link to an object incorporated is stored as a moniker. A moniker is an identifier object that encapsulates the information needed to access the incorporated data and provides methods which bind to the incorporated data.","The present invention provides a computer implemented method and system for naming and binding to linked data. In a preferred embodiment, a compound document that incorporates linked data stores a persistent data handle, called a \u201cmoniker,\u201d which is a reference to the link source. A moniker is an identifier object that contains information to identify the linked data and provides methods through which a program can bind to the linked data. A binding method returns an instance of an interface through which the linked data can be accessed. A moniker may link to data that is itself embedded data within another compound document. For example, a moniker may link to a range of cells within a spreadsheet table that is contained in a word processing document. A moniker may link to data at any level within a compound document. During execution of the binding method, several applications may be invoked to locate the link data. For example, to bind to the range of cells within a spreadsheet table that is within a word processing document, the word processing program may be invoked to locate the embedded spreadsheet table and the spreadsheet program may be invoked to bind to the range of cells. The present invention defines an interface through which a moniker is accessed. A moniker can identify source data that is stored persistently or non-persistently.","In a preferred embodiment, monikers can be composed to form a composite moniker. A composite moniker is conceptually a path to a source object that is identified by the concatenation of the monikers. For example, if a moniker specifying a certain path (e.g., \u201cc:\\reports\u201d) is composed with a moniker specifying a certain file name (e.g., \u201cQ3.doc\u201d) then the result is the complete path name to the file (e.g., \u201cc:\\reports\\Q3.doc\u201d). Each composite moniker comprises a plurality of component monikers. The present invention provides a method and system for decomposing a composite moniker. In a preferred embodiment, each moniker provides a method that is used to retrieve each component moniker.","In a preferred embodiment, a moniker provides a reducing method which returns another moniker that is a more efficient representation of a moniker to the same source object. The reducing method may interpret a macro script that identifies the source object. Alternatively, the reducing method may evaluate a query request that identifies the source object.","In a preferred embodiment, a moniker provides an equality method and a hash method. The equality method determines whether two monikers identify the same source object. The hash method provides a hash value for a moniker. The equality method and hash method are used to implement hash tables indexed by monikers.","In a preferred embodiment, a moniker provides an inverse method that generates another moniker that is the inverse of the moniker. When a moniker is composed with its inverse, the result is NULL. The inverse moniker is said to annihilate the moniker. An inverse moniker may be used, for example, to remove portions of a path and is analogous to the \u201c . . . \u201d functionality of traditional file systems.","In a preferred embodiment, a moniker provides a common prefix with method and a relative path to method. The common prefix with method determines the common prefix portion of two monikers. For example, if one moniker identifies the object \u201cc:\\reports\\Q3.doc\u201d and another moniker identifies the object \u201cc:\\reports\\data\\Q3.xls\u201d the common prefix is \u201cc:\\reports\u201d. The relative path to method generates relative path to moniker that when composed with one moniker results in specified moniker. For example, the moniker specifying the path that is the inverse of a moniker identifying object \u201cQ3.doc\u201d composed with a moniker specifying the path \u201cdata\\Q3.xls\u201d is a relative path to moniker from the moniker \u201cc:\\reports\\Q3.doc\u201d to the moniker \u201cc:\\reports\\data\\Q3.xls\u201d. Relative path to monikers are preferably used when identifying objects by relative paths from another object.","In a preferred embodiment, the present invention provides several implementation monikers including a file moniker, an item moniker, a generic composite moniker, a pointer moniker, and an anti moniker. Each implementation is referred to as a moniker class and has a class identifier. A file moniker provides a moniker that conceptually is a path name in a file system. An item moniker provides a moniker that conceptually identifies a portion of an object. A generic composite moniker provides a mechanism for composing monikers with arbitrary implementations. For example, a file moniker can be composed with an item moniker to specify a portion of a file. A generic composite moniker is preferably created by the composing method of the file moniker. A pointer moniker is a moniker that wraps an instantiated source object in a moniker. A pointer moniker contains a pointer to the instantiated source object and when a pointer moniker is bound, it returns the pointer. An anti moniker is a moniker that is the inverse of other monikers. When a moniker is composed with an anti moniker, the result is NULL. If a generic composite moniker is composed with an anti moniker, the result is a moniker comprising all but the last component moniker. The anti moniker annihilates the last component moniker of a generic composite moniker.","In a preferred embodiment of the present invention, an application program that creates a compound document controls the manipulation of linked or embedded data generated by another application. In object-oriented parlance, this data is referred to as an object. (The reference Budd, T., \u201cAn Introduction to Object-Oriented Programming,\u201d Addison-Wesley Publishing Co., Inc., 1991, provides an introduction to object-oriented concepts and terminology.) An object that is either linked or embedded into a compound document is \u201ccontained\u201d within the document. Also, a compound document is referred to as a \u201ccontainer\u201d object and the objects contained within a compound document are referred to as \u201ccontainee\u201d objects. Referring to , the scheduling data  and budgeting data  are containee objects and the compound document  is a container object. The user can indicate to the word processor that the user wants to edit a containee object, such as the budgeting data . When the user indicates that the budgeting data  is to be edited, the word processing program determines which application should be used to edit the budgeting data (e.g., the spreadsheet program) and launches (starts up) that application. The user can then manipulate the budgeting data using the launched application, and changes are reflected in the compound document. The same procedure is used whether the budgeting data is stored as an embedded or linked object.",{"@attributes":{"id":"p-0099","num":"0120"},"figref":["FIG. 5","FIG. 1","FIG. 2"],"b":["501","503","505","501","501","502","502","204","501","503","504","505","505","502","501"]},"In a preferred embodiment, application programs (\u201capplications\u201d) cooperate using object linking and embedding facilities to create and manipulate compound documents. An application that creates a compound document is referred to as a client application, and an application that creates and manipulates containee objects are referred to as server applications. An application can behave as both a client and a server. Referring to , the project management program  and the spreadsheet program  are server applications, and the word processing program  is a client application. A client application is responsible for selection of the various objects within the container object and for invoking the proper server application to manipulate the selected containee object. A server application is responsible for manipulating the contents of the containee objects.","In a preferred embodiment, applications are provided with an implementation-independent Application Programming Interface (API) that provides the object linking and embedding functionality.","The section entitled \u201cDetails of Moniker Related Interfaces\u201d contains a detailed description of several functions within a preferred object linking and embedding system. This preferred object linking and embedding system is further described in Microsoft Corp., OBJECT Linking & Embedding OLE 2.0 Design Specification. Microsoft Corp. Apr. 15, 1993, which is herein incorporated by reference in its entirety. The API is a set of functions that are invoked by client and server applications. These functions manage, among other things, the setup and initialization necessary for client applications to send and receive messages and data to and from server applications. The API provides functions to invoke the correct server application to act upon a particular containee object and to manipulate containee objects.","In addition, the object linking and embedding API defines \u201cinterfaces\u201d through which client applications can communicate with their contained objects. An interface is a set of methods which abide by certain input, output, and behavior rules. If a contained object supports a particular interface, the client application can invoke the methods of that interface to effect the defined behavior. In a preferred embodiment, the client application is not allowed direct access to the object data; it manipulates the object using the supported interfaces. A client application is bound to a contained object through a pointer to an interface. The client application accesses the object by invoking the methods of the interface. To access the object data, the methods may send messages to the server application requesting the specified access. In a preferred embodiment, messages are sent between clients and servers using interprocess communications mechanisms provided by the underlying operating system.","An example will help illustrate the relationship between a client process and a server process. Referring again to , if a user wants to edit the budgeting data  of the compound document , then the following sequence of events occurs. First, the user starts up the word processor program, which is dynamically linked to the object linking and embedding API. Second, the user opens the compound document for editing. Third, the user selects the budgeting data, which is a containee object, and indicates that the selected object is to be edited. Fourth, the client application invokes a client API routine for performing an action on an object passing the routine a handle (which uniquely identifies the selected object) to the object and an indicator that the action is edit. Fifth, the client API routine determines that the spreadsheet program provides the actions for the budgeting data. Sixth, the client API code starts up the spreadsheet program as a server process, if it is not already started. Seventh, the word processor application sends a message to the spreadsheet program that it should edit the budgeting data. Eighth, the server API code receives the request to edit and invokes a routine in the spreadsheet program for editing the data. When editing is complete, the spreadsheet routine returns to the server API code. The server API code sends a message to the word, processor application to indicate that editing is complete. The client API code receives the message and returns from its invocation. Upon return from the invocation, the word processor application knows that the editing is complete.","In addition to the client and server API, the object linking and embedding facilities of the present invention provide information to client and server applications through a persistent global \u201cregistry.\u201d This registry is a database of information such as (1) for each type of object, the server application that implements the object type, (2) the actions that the each server application provides to client applications, (3) where the executable files for each server application are located, and (4) whether each server application has an associated object handler. An object handler is a collection of functions in a dynamic link library. An object handler can be used to provide certain functions without launching the server.",{"@attributes":{"id":"p-0106","num":"0127"},"figref":["FIGS. 6","FIG. 6","FIG. 7","FIG. 8"],"b":["7","8","601","602","603","602","601","603","603","602","704","704","706","702","602","702","702","701","702","603","702","704","704","806","806","807","807","603","808"],"sub":["13 ","13 ","13 ","13 "]},"In a preferred embodiment, a moniker is an object that supports the IMoniker interface of Code Table 3. The IMoniker interface inherits the IPersistStream interface; thus, monikers can be saved to and loaded from streams. The persistent form of a moniker contains the class identifier (CLSID) of its implementation which is used during the loading process, and new classes of monikers can be created transparently to clients.","The IMoniker interface provides for binding to the object to which it points, which is supported by the method BindToObject. This method takes as a parameter the interface identifier by which the caller wishes to talk to the object, runs whatever algorithm is necessary in order to locate the object, then returns a pointer of that interface type to the caller. Each moniker class can store arbitrary data in its persistent representation, and can run arbitrary code at binding time.","If there is an identifiable piece of persistent storage in which the object referenced by the moniker is stored, then the method BindToStorage can be used to access it. Many objects have such identifiable storage (e.g., a file), but some, such as the objects which are the ranges in a spreadsheet do not.","In a preferred embodiment, a particular moniker class is designed to be one step along the path (a component) to a data source. These components can be composed together to form a moniker which represents the complete path to the data source. For example, the moniker stored inside the chart of  might be a generic composite moniker formed from three component as illustrated in . This composite is itself a moniker; it is a moniker which is a sequenced collection of other composite monikers. The composition is generic in that it has no knowledge of the component monikers involved other than that they are monikers.",{"@attributes":{"id":"p-0111","num":"0132"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"308pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Code Table 3"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"308pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"class IMoniker : IPersistStream {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"virtual HRESULT BindToObject(pbc, pmkToLeft, iidResult, ppvResult) = 0;"]},{"entry":[{},"virtual HRESULT BindToStorage(pbc, pmkToLeft, iid, ppvObj) = 0;"]},{"entry":[{},"virtual HRESULT Reduce(pbc, dwReduceHowFar, ppmkToLeft. ppmkReduced) = 0;"]},{"entry":[{},"virtual HRESULT ComposeWith(pmkRight, fOnlyIfNotGeneric, ppmkComposite)"]},{"entry":[{},"virtual HRESULT Enum(fForward, ppenmMoniker) = 0;"]},{"entry":[{},"virtual HRESULT IsEqual(pmkOtherMoniker) = 0;"]},{"entry":[{},"virtual HRESULT Hash(pdwHash) = 0;"]},{"entry":[{},"virtual HRESULT IsRunning(pbc, pmkToLeft, pmkNewlyRunning) = 0;"]},{"entry":[{},"virtual HRESULT GetTimeOfLastChange(pbc, pmkToLeft, pfiletime) = 0;"]},{"entry":[{},"virtual HRESULT Inverse(ppmk) = 0;"]},{"entry":[{},"virtual HRESULT CommonPrefixWith(pmkOther, ppmkPrefix) = 0;"]},{"entry":[{},"virtual HRESULT RelativePathTo(pmkOther, ppmkRelPath);"]},{"entry":[{},"virtual HRESULT GetDisplayName(pbc, pmkToLeft, lplpszDisplayName) = 0;"]},{"entry":[{},"virtual HRESULT ParseDisplayName(pbc, pmkToLeft, lpszDisplayName, pcchEaten, ppmkOut) = 0;"]},{"entry":[{},"virtual HRESULT IsSystemMoniker(pdwMksys);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"308pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The example of , , and  illustrate the use of a moniker that identifies a file. The present invention allows moniker to be combined (composed) to an arbitrary level. , B, and C illustrate moniker composition. For example, if the chart file  contained multiple charts, it would be useful to designate a specific chart to be the source of a link. In one embodiment of the present invention, a moniker class named \u201cCChartMoniker\u201d could be implemented by the developer of the chart program. A chart moniker  would contain a name of a chart file (\u201cQ3.CHT\u201d) and an indication of a chart within the file (\u201cCHART2\u201d). The methods of the class CChartMoniker would have a behavior similar to that provided by the class CFileMoniker plus behavior needed to bind to the identified chart. As described above, the present invention allows two monikers to be composed to form a third moniker. By composing monikers, a developer can use an implementation developed by someone else. For example, the developer of the chart program could define and implement the class CChartMoniker to contain only an indication of a chart within a file. The class CChartMoniker can be developed assuming that an instance of chart moniker  will be composed with a file moniker (e.g., file moniker ). In a preferred embodiment, to facilitate the composing of monikers, a moniker of class CCompositeMoniker is defined and implemented. The class CCompositeMoniker encapsulates any two monikers into single generic composite moniker. The generic composite moniker  encapsulates the file moniker  and the chart moniker . A link to a chart is stored as a generic composite moniker which encapsulates a file moniker and a chart moniker. The client of the link need only know that the moniker supports the IMoniker interface.","In the following, each method of the IMoniker interface is defined. In addition, several implementations of various methods are described. In particular, implementations of methods of the classes CFileMoniker, CCompositeMoniker, and CItemMoniker are described. The class CFileMoniker (a file moniker) is a moniker class that identifies a path name in a file system. When a file moniker is bound to, it determines the class of the file by using the persistent global registry, ensures that the appropriate class server is running, and then requests the server to open the file. The class CCompositeMoniker (a generic composite moniker) is a moniker class that identifies a composition of two monikers (a left and a right moniker). When a generic composite moniker is bound to, it invokes the binding method of the right moniker indicating that the left moniker is composed with the right moniker. The right moniker performs its binding behavior, which may include invoking the binding method of the left moniker. The class CItemMoniker (an item moniker) is a moniker class that implements behavior common to the identification of containee objects. An item moniker can be used to identify, for example, a chart contained within a chart file or a range within a spreadsheet. An item moniker uses the IOleItemContainer interface (described in detail in the section entitled \u201cDetails of the Moniker Related Interfaces\u201d) to interact with the container. Code Table 4 contains the class definitions for a file moniker, a generic composite moniker, an item moniker, an anti moniker, and a pointer moniker. An anti moniker and a pointer moniker are described below in detail. A file moniker contains a string (mszPath) indicating a path name and a count of anti monikers (mcAnti). A generic composite moniker contains a pointer to the left moniker (mpmkLeft) and a pointer to the right moniker (mpmkRight) of the generic composite and a flag (mfReduced) indicating whether the composite is reduced. An item moniker contains a pointer to a string (mlpszItem) that defines the item.",{"@attributes":{"id":"p-0114","num":"0135"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"CODE TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"class CFileMoniker: IMoniker"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ char FAR * \u2003\u2003m_szPath;"]},{"entry":[{},"\u2003UINT m_cAnti;"]},{"entry":[{},"}"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"class CCompositeMoniker: IMoniker"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ LPMONIKER","m_pmkLeft;"]},{"entry":[{},"\u2003LPMONIKER","m_pmkRight;"]},{"entry":[{},"\u2003BOOL","m_fReduced;"]},{"entry":[{},"}"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"class CItemMoniker: IMoniker"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ char FAR *","m_lpszItem;"]},{"entry":[{},"}"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"class CAntiMoniker: IMoniker"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ ULONG","m_count;"]},{"entry":[{},"}"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"class CPointerMoniker: IMoniker"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ LPUNKNOWN","m_punk;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"br":[{},{}]},"The method BindToObject locates and loads the object semantically referred to by this moniker according to the interface specified by iidResult and returns a pointer to the object through ppvResult. In the following, the term \u201cthis moniker\u201d refers to the moniker for which a method is invoked. In general, each class of moniker is designed to be used as one component in a generic composite moniker which gives the complete path to the referenced object. In a generic composite, any component moniker has a certain prefix of the generic composite to its left, and a certain suffix to its right. If the method BindToObject is invoked on a component moniker, then the implementation of BindToObject typically requires certain services of the object indicated by the prefix to its left. Item monikers, for example, require the IOleItemContainer interface of the object to their left. The Item Moniker implementation of the method BindToObject (as described below) recursively calls pmkToLeft->BindToObject in order to obtain this interface. If the moniker does not need services of the object to its left, yet one is provided by the caller nevertheless, no error occurs. Rather, the moniker ignores the object to its left. If the object indicated by the moniker does not exist, then the error MK_E_NOOBJECT is returned.","In general, binding a moniker can be a complicated process, since it may need to launch servers, open files, etc. This may involve binding to other objects, and the binding components of a generic composite to the right of certain components will require the same other objects. In order to avoid loading the object, releasing it, then having it loaded again later, the method BindToObject can use the bind context passed through the pbc parameter to defer releasing objects until the binding process overall is complete. The bind context is described in detail in the section entitled \u201cDetails of the Moniker Related Interfaces\u201d.","Binding to a moniker a second time typically returns the same running object as binding the first time, rather than reloading it again from storage. This functionality is supported with a running object table. The running object table is a lookup table keyed by a moniker whose values are pointers to the corresponding now-running object. As objects become running, they register themselves in this table. Implementations of the method BindToObject uses this table to determine if the object to which they point is already running. More precisely, if the passed pmkToLeft parameter is NULL (and this is not an error; that is, the moniker does not require something to its left), then the moniker fully reduces itself, then looks itself up in the running object table, and returns the pointer to the object found there. The running object table is described in detail in the section entitled \u201cDetails of the Moniker Related Interfaces\u201d.","The following table describes the parameters of the method BindToObject:",{"@attributes":{"id":"p-0119","num":"0140"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pbc","IBindCtx*","the bind context to be used for this binding"]},{"entry":[{},{},"operation."]},{"entry":["pmkToLeft","IMoniker*","the moniker of the object to the left of this"]},{"entry":[{},{},"moniker."]},{"entry":["iidResult","IID","the requested interface by which the caller"]},{"entry":[{},{},"wishes to connect to the object."]},{"entry":["ppvResult","void**","on successful return, a pointer to the"]},{"entry":[{},{},"instantiated object is placed here, unless"]},{"entry":[{},{},"BINDFLAGS_JUSTTESTEXISTENCE was"]},{"entry":[{},{},"specified in the binding options, in which"]},{"entry":[{},{},"case NULL may be returned instead."]},{"entry":["return","HRESULT","S_OK, MK_E_NOOBJECT,"]},{"entry":["value",{},"STG_E_ACCESSDENIED,"]},{"entry":[{},{},"MK_E_EXCEEDEDDEADLINE,"]},{"entry":[{},{},"MK_E_CONNECTMANUALLY,"]},{"entry":[{},{},"MK_E_INTERMEDIATEINTERFACE-"]},{"entry":[{},{},"NOTSUPPORTED, E_OUTOFMEMORY,"]},{"entry":[{},{},"E_NOINTERFACE"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0120","num":"0141"},"figref":"FIG. 11","b":["1101","1105","1102","1102","1104","1102","1103","1105","1103","1104","1105","1106"]},{"@attributes":{"id":"p-0121","num":"0142"},"figref":"FIG. 12","b":["1201","1202","1203","1204","1205"]},{"@attributes":{"id":"p-0122","num":"0143"},"figref":"FIG. 13","b":["1301","1302","1302","1303"]},{"@attributes":{"id":"p-0123","num":"0144"},"figref":"FIG. 14","b":["1401","1402","1405","1402","1403","1405","1403","1404","1405","1408","1405","1406","1407","1406","1408","1407","1408"]},{"@attributes":{"id":"p-0124","num":"0145"},"figref":["FIGS. 15A through 15F","FIG. 15A","FIG. 14","FIG. 13","FIG. 14","FIG. 13","FIG. 11","FIG. 15F"],"b":["1501","1502","1503","1501","1502","1503","1501","1503","1502","1503","1501","1502","1504","1505","1504","1504","1504","1406","1406","1506","1504","1408","1503","1506","1503","1302","1302","1506","1506","1406","1406","1501","1408","1502","1501","1502","1302","1302","1501","1501","1105","1105","1106","1503","1303","1302"]},"IMoniker ComposeWith","RESULT IMoniker::ComposeWith(pmkRight, fOnlyIfNotGeneric, ppmkComposite)","This method ComposeWith returns a new moniker which is a composite formed with this moniker on the left and the passed moniker (pmkRight) on the right. There are two kinds of composite monikers: those composite monikers that know nothing about their component monikers other than that they are monikers (a generic composite moniker), and those composite monikers that know more (a special composite moniker). For example, a file moniker containing a relative path may be composed on to the end of another file moniker. The resulting composite moniker could be a new file moniker containing the complete path. The new file moniker is a special composition. A special composition is useful for monikers that are capable of collapsing a path within a storage domain to a more efficient representation in a subsequent reduction.","Each moniker class may have a set of other kinds of special monikers that can be composed onto the end of it in a non-generic way. Each implementation of the method ComposeWith examines the passed moniker on the right (pmkRight) to see if it is such a special moniker for the implementation. If the specified moniker on the right is special, then the implementation does whatever is appropriate for that special case. If it is not, then the passed flag fOnlyIfNotGeneric controls what occurs. If flag fOnlyIfNotGeneric is true, then NULL is passed back through parameter ppmkComposite and the status MK_E_NEEDGENERIC returned; if fOnlyIfNotGeneric is false, then a generic composite moniker is created using the function CreateGenericComposite and returned.","If the specified moniker on the right (pmkright) completely annihilates this moniker, the resulting composite is empty and the parameter ppmkComposite is set to NULL and the status S_OK returned.","Composition of monikers is an associative operation. That is, if A, B, and C are monikers, then\n\n","The following table describes the parameters of the method ComposeWith:",{"@attributes":{"id":"p-0130","num":"0153"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pmkRight","IMoniker*","the moniker to compose onto the end"]},{"entry":[{},{},"of the receiver."]},{"entry":["fOnlyIfNotGenenc","BOOL","controls whether a composite"]},{"entry":[{},{},"moniker should be returned when the"]},{"entry":[{},{},"right moniker is not a special moniker"]},{"entry":[{},{},"for this moniker."]},{"entry":["ppmkComposite","IMoniker*","on exit, the resulting composite"]},{"entry":[{},{},"moniker. Possibly NULL."]},{"entry":["return value","HRESULT","S_OK, MK_E_NEEDGENERIC"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0131","num":"0154"},"figref":"FIG. 16","b":["1601","1602","1603","1602","1603","1604","1605","1604","1605"]},{"@attributes":{"id":"p-0132","num":"0155"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0133","num":"0156"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"308pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"CODE TABLE 4A"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"308pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"CreateGenericComposite (pmkFirst, pmkRest, ppmkComposite)"},{"entry":"{"},{"entry":"Casel:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"pmkFirst\u2212>ComposeWith (pmkRest, TRUE, ppmkComposite)"]},{"entry":[{},"if (no composition occurred)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"CCompositeMoniker::Create (pmkFirst, pmkRest, ppmkComposite)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"308pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Case2:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"pmkFirst\u2212>ComposeWith (pmkFirstOfRest, TRUE, &pmk)"]},{"entry":[{},"if (no composition occurred)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"CCompositeMoniker::Create(pmkFirst, pmkRest, ppmkComposite)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if (pmk!=NULL)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"CreateGenericComposite(pmk, pmkAllButFirstOfRest, ppmkComposite)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"*ppmkComposite = pmkAllButFirstOfRest"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"308pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Case3:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"pmkLastOfFirst\u2212>ComposeWith(pmkRest, TRUE, &pmk);"]},{"entry":[{},"if (no composition occurred)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"CCompositeMoniker::Create(pmkFirst, pmkRest, ppmkComposite)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if (pmk!=NULL)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"CreateGenericComposite (pmkAllButLastOfFirst, pmk, ppmkComposite)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"*ppmkComposite = pmkAllButLastOfFirst"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"308pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Case4:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"pmkLastOfFirst\u2212>ComposeWith (pmkFirstOfRest, TRUE, &pmk)"]},{"entry":[{},"if (no composition occurred)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"CCompositeMoniker::Create(pmkFirst, pmkRest, ppmkComposite)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if (pmk!=NULL)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CreateGenericComposite (pmkAllButLastOfFirst, pmk, &pmk2)"]},{"entry":[{},"CreateGenericComposite (pmk2, pmkAllButFirstOfRest, ppmkComposite)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"CreateGenericComposite (pmkAllButLastOfFirst, pmkAllButFirstOfRest, ppmkComposite)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"308pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":[{},{}]},"The function CreateGenericComposite allocates and returns a new generic composite moniker. The parameters pmkFirst and pmkRest point to the first and trailing monikers that are to comprise the generic composite monikers, respectively. Either pmkFirst or pmkRest may be a generic composite moniker, or another kind of moniker. The following table describes the parameters of the function CreateGenericComposite:",{"@attributes":{"id":"p-0135","num":"0158"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pmkFirst","IMoniker*","the first moniker in the new composite."]},{"entry":["pmkRest","IMoniker*","the trailing (rest) moniker in the new"]},{"entry":[{},{},"composite."]},{"entry":["ppmkComposite","IMoniker*","a pointer to the new composite."]},{"entry":["return value","HRESULT","S_OK, E_OUTOFMEMORY"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Code Table 4A contains C++ pseudocode for the function CreateGenericComposite. The function handles four specific cases. The first case occurs when neither the first moniker (pmkFirst) nor the rest moniker (pmkRest) are generic composite monikers. The second case occurs when the first moniker is not a generic composite moniker, but the rest moniker is a generic composite moniker. The third case occurs when the first moniker is a generic composite moniker, but the rest moniker is not a generic composite moniker. The fourth case occurs when both the first moniker and the rest moniker are generic composite monikers.","In the first case, the function CreateGenericComposite invokes the method ComposeWith of the first moniker passing the rest moniker and specifying that a composition should occur only if not generic. If the rest moniker is not a special moniker for the first moniker, then no composition occurs and the function creates a composite moniker by invoking the method Create of the class CCompositeMoniker passing the first moniker and the rest moniker. The method Create of the class CCompositeMoniker creates a generic composite moniker that points to the specified monikers and returns a pointer to the created moniker.  illustrates the resulting generic composite moniker  of the first case when the rest moniker  is not a special moniker of the first moniker . In the second case, the function CreateGenericComposite invokes the method ComposeWith of the first moniker passing the first component moniker of the rest moniker. If the first component moniker of the rest moniker is not a special moniker for the first moniker, then no composition occurs and the method creates a composite moniker by invoking the method Create of the class CCompositeMoniker passing the first moniker and the rest moniker.  illustrates a representative resulting generic composite moniker  when the first component moniker  of the rest moniker  is not a special moniker of the first moniker . If, however, a composition of the first moniker and the first component of the rest moniker occurs and a moniker is returned, then the function recursively calls the function CreateGenericComposite to compose the moniker returned with all but the first component moniker of the rest moniker.  illustrates the resulting generic composite moniker  that contains the composite moniker , which is the composition of the first moniker and the first component moniker of the rest moniker, and contains the moniker , which includes all but the first component moniker of the rest moniker. If the composition of the first moniker and the first component moniker of the rest moniker resulted in an annihilation of the monikers (pmk==NULL), then the function returns a pointer to a moniker formed by all but the first component moniker of the rest moniker as illustrated in . In the third case, the function CreateGenericComposite invokes the method ComposeWith of the last component moniker of the first moniker passing the rest moniker. If the rest moniker is not a special moniker for the last component moniker of the first moniker, then no composition occurs and the function creates a composite moniker by invoking the method Create of the class CCompositeMoniker passing the first moniker and the rest moniker as illustrated by the representative generic composite moniker in . If, however, a composition occurs, and a moniker is returned, then the method recursively invokes the function CreateGenericComposite passing all but the last component moniker of the first component moniker and the returned moniker as indicated in . If, however, the composition of the first moniker with the first component moniker of the rest moniker resulted in an annihilation of the monikers, then the function returns a moniker comprising all but the last component moniker of the first moniker as the composite moniker as illustrated by . In the fourth case, the function CreateGenericComposite invokes the method ComposeWith of the last component moniker of the first moniker passing the first component moniker of the rest moniker. If the first component moniker of the rest moniker is not a special moniker for the last component moniker of the first moniker, then no composition occurs and the function invokes the method Create of the class CCompositeMoniker passing the first moniker and the rest moniker resulting in the sample generic composite moniker of . If, however, a composition does occur without annihilation, then the function recursively invokes the function CreateGenericComposite passing the composed moniker and all but the last component moniker of the first moniker. The function then recursively invokes the function CreateGenericComposite passing the resulting composite moniker and all but the first component moniker of the rest moniker resulting in the representative composite moniker of . If the composition results in annihilation of the last component moniker of the first moniker and the first component moniker of the rest moniker, then the function recursively invokes the function CreateGenericComposite passing all but the last component moniker of the first moniker and all but the first component moniker of the rest moniker resulting in the representative generic composite moniker of .","IMoniker::Reduce","HRESULT IMoniker::Reduce(pbc, dwReduceHowFar, ppmkToLeft, ppmkReduced)","The method Reduce requests a moniker to re-write itself into another equivalent moniker. This method returns a new moniker that will bind to the same object, but does so in a more efficient way. This capability has several uses:\n\n",{"@attributes":{"id":"p-0139","num":"0165"},"figref":"FIG. 22"},"The reduction of a moniker which is a composite of other monikers repeatedly reduces the component monikers of which it is composed until they all reduce to themselves, and then returns the composite of the reduced components. The parameter dwReduceHowFar controls the stopping point of the reduction process. It controls to what extent the reduction should be carried out. It has the following values.",{"@attributes":{"id":"p-0141","num":"0167"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"typedef enum tagMKRREDUCE {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"MKRREDUCE_ONE","= 3<<16,"]},{"entry":[{},"MKRREDUCE_TOUSER","= 2<<16,"]},{"entry":[{},"MKRREDUCE_THROUGUSER","= 1<<16,"]},{"entry":[{},"MKRREDUCE_ALL","= 0"]},{"entry":[{},"} MKRREDUCE;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},{"@attributes":{"id":"p-0142","num":"0168"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"210pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Value","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["MKRREDUCE_ONE","Perform only one step of reduction on this moniker. In general, the"]},{"entry":[{},"caller will have to have specific knowledge as to the particular kind of"]},{"entry":[{},"moniker in question in order to be able to usefully take advantage of"]},{"entry":[{},"this option."]},{"entry":["MKRREDUCE_TOUSER","Reduce this moniker to the first point where it first is of the form where"]},{"entry":[{},"it represents something that the user conceptualizes as being the identity"]},{"entry":[{},"of a persistent object. For example, a file name would qualify, but a"]},{"entry":[{},"macro or an alias would not. If no such point exists, then this option"]},{"entry":[{},"should be treated as MKRREDUCE_ALL."]},{"entry":["MKRREDUCE_THROUGUSER","Reduce this moniker to the point where any further reduction would"]},{"entry":[{},"reduce it to a form which the user does not conceptualize as being the"]},{"entry":[{},"identity of a persistent object. Often, this is the same stage as"]},{"entry":[{},"MKRREDUCE_TOUSER."]},{"entry":["MKRREDUCE_ALL","Reduce the entire moniker, then, if needed reduce it again and again"]},{"entry":[{},"to the point where it reduces to simply itself."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The following table describes the parameters of the method Reduce:",{"@attributes":{"id":"p-0144","num":"0170"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pbc","IBindCtx*","The bind context to use in this"]},{"entry":[{},{},"operation."]},{"entry":["dwReduceHowFar","DWORD","Indicates to what degree this moniker"]},{"entry":[{},{},"should he reduced."]},{"entry":["ppmkToLeft","IMoniker**","On entry, the moniker which is the"]},{"entry":[{},{},"prefix of this one in the composite"]},{"entry":[{},{},"in which it is found. On exit, the"]},{"entry":[{},{},"pointer is either NULL or non-"]},{"entry":[{},{},"NULL. Non-NULL indicates that"]},{"entry":[{},{},"what was previously thought of as the"]},{"entry":[{},{},"prefix should be disregarded and the"]},{"entry":[{},{},"moniker returned through"]},{"entry":[{},{},"ppmkToLeft considered the prefix in"]},{"entry":[{},{},"its place. NULL indicates that the"]},{"entry":[{},{},"prefix should not be so replaced."]},{"entry":[{},{},"Thus, most monikers will NULL out"]},{"entry":[{},{},"this parameter before returning."]},{"entry":["ppmkReduced","IMoniker**","On exit, the reduced form of this"]},{"entry":[{},{},"moniker. Possibly NULL."]},{"entry":["return value","HRESULT","S_OK,"]},{"entry":[{},{},"MK_S_REDUCED_TO_SELF,"]},{"entry":[{},{},"MK_E_EXCEEDEDDEADLINE."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0145","num":"0171"},"figref":"FIG. 23","b":["2301","2302","2303","2302","2303","2306","2304","2304","2305","2306","2309","2307","2307","2308","2309","2309","2310","2312","2310","2311","2312","2313","2314"]},{"@attributes":{"id":"p-0146","num":"0172"},"figref":["FIG. 24","FIG. 22"],"b":["2401","2402","2402","2403","2404","2405","2406","2407","2408"]},{"@attributes":{"id":"p-0147","num":"0173"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"CODE TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"224pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["{","A = CreateMoniker (cFileMoniker, \u201cc:\\reports\\expenses\\weekly\u201d)"]},{"entry":[{},"B = CreateMoniker (cFileMoniker, getcurrentusername)"]},{"entry":[{},"C = CreateMoniker (cFileMoniker, dayofweek (getcurrentdate-oneday))"]},{"entry":[{},"Result = A\u2218B\u2218C"]},{"entry":"}"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"CODE TABLE 6"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"224pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["{","A = CreateMoniker (cFileMoniker, \u201cc:\\taxes\u201d)"]},{"entry":[{},"Prompt \u201cEnter year:\u201d, year"]},{"entry":[{},"B = CreateMoniker (cFileMoniker, year)"]},{"entry":[{},"C = CreateMoniker (cFileMoniker, \u201c\\1040.XLS\u201d)"]},{"entry":[{},"D = CreateMoniker (cItemMoniker, \u201cR1C1:R10C10\u201d)"]},{"entry":[{},"Result = A\u2218B\u2218C\u2218D"]},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0148","num":"0174"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":[{"entry":[{},"CODE TABLE 6"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{","A = CreateMoniker (cFileMoniker, \u201cc:\\taxes\u201d)"]},{"entry":[{},{},"Prompt \u201cEnter year:\u201d, year"]},{"entry":[{},{},"B = CreateMoniker (cFileMoniker, year)"]},{"entry":[{},{},"C = CreateMoniker (cFileMoniker, \u201c\\1040.XLS\u201d)"]},{"entry":[{},{},"D = CreateMoniker (cltemMoniker, \u201cR1C1:R10C10\u201d)"]},{"entry":[{},{},"Result A\u2218B\u2218C\u2218D"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"In a preferred embodiment, a macro moniker allows for arbitrary moniker creation. A macro moniker contains a macro script that controls the reduction of a macro moniker to another moniker. During reduction, the script is parsed and processed by the method Reduce. One skilled in the art would appreciate that parsing and processing macro scripts are well known. The result of the processing is another moniker that is returned as the reduced moniker. For example, Code Table 5 contains a script that directs the macro moniker to reduce to a moniker referencing the directory \u201cc:\\reports\\expenses\\weekly\\user\\dayofweek\u201d, where user is the current user name (e.g., \u201cSmith\u201d) and dayofweek is the day of week of yesterday (e.g., \u201cThursday\u201d). The macro moniker with the script of Code Table 5 may reduce to a file moniker with a path name of \u201cc:\\reports\\expenses\\weekly\\smith\\thursday\u201d. The macro moniker may contain a pointer to the reduced moniker. The method BindToObject of a macro moniker would typically invoke the method Reduce and then invoke the method BindToObject of the reduced moniker. Code Table 6 contains a macro script that directs the macro moniker to reduce to a moniker and in the process prompts the user for a portion of the path.",{"@attributes":{"id":"p-0150","num":"0176"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"CODE TABLE 7"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{ \u2003SELECT FIRST printer.name"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"FROM CampusPrinter"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"WHERE","(printerType ==PostScript OR"]},{"entry":[{},{},"printerType ==PCL)"]},{"entry":[{},{},"AND"]},{"entry":[{},{},"printerLocation"]},{"entry":[{},{},"\u2003INCLUDES \u201cBuilding1\u201d"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"ORDER BY printQueueLength"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In a preferred embodiment, a query moniker allows for arbitrary reduction to a moniker identified by a query. A query moniker contains a query that controls the reduction. The query is evaluated to produce a file moniker that satisfies the query. For example, Code Table 7 contains a query (in a structured query language) that may reduce to the file moniker with path name \u201c\\\\printserver10\\printer2\u201d. The query evaluates to a list of printers that can accommodate either PostScript or PCL documents and that is in a certain building. The list is sorted by the length of the print queue, and the printer with the shortest print queue is selected.","IMoniker::IsEqual","HRESULT IMoniker::IsEqual(pmkOtherMoniker)","This method determines whether this moniker and the specified other moniker (pmkOtherMoniker) reference the same object. This method is used in a preferred implementation of a running object table. The following table describes the parameters of the method IsEqual:",{"@attributes":{"id":"p-0153","num":"0179"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pmkOtherMoniker","IMoniker*","the other moniker with whom this"]},{"entry":[{},{},"moniker is compared."]},{"entry":["return value","HRESULT","S_OK, S_FALSE"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0154","num":"0180"},"figref":"FIG. 25","b":["2501","2502","2502","2503","2503"]},{"@attributes":{"id":"p-0155","num":"0181"},"figref":"FIG. 26","b":["2601","2602","2602","2603","2603"]},"IMoniker::Hash","HRESULT IMoniker::Hash(pdwHash)","This method returns a 32-bit integer associated with this moniker. This integer is used for maintaining tables of monikers: the moniker can be hashed to determine a hash bucket in the table, then compared with the method IsEqual against all the monikers presently in that hash bucket. Two monikers that compare as equal have the same hash value. The following table describes the parameters of the method Hash:",{"@attributes":{"id":"p-0157","num":"0183"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pdwHash","DWORD*","the place in which to put the returned hash"]},{"entry":[{},{},"value."]},{"entry":["return value","HRESULT","S_OK"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0158","num":"0184"},"figref":"FIG. 27","b":["2701","2702","2703"]},"IMoniker::Inverse","HRESULT IMoniker::Inverse(ppmk)","The method Inverse returns a moniker that when composed onto the end of this moniker or one of similar structure annihilates it; that is, composes to NULL. The method Inverse is an abstract generalization of the \u201c . . . \u201d operation in traditional file systems. For example, a file moniker that represents the path \u201ca\\b\\c\\d\u201d has as its inverse a moniker containing the path \u201c . . . \\ . . . \\ . . . \\ . . . \u201d, since \u201ca\\b\\c\\d\u201d composed with \u201c . . . \\ . . . \\ . . . \\ . . . \u201d yields nothing. The inverse of a moniker does not annihilate just that particular moniker, but all monikers with a similar structure. Thus, the inverse of a generic composite moniker is the reverse composite of the inverse of its component monikers. Certain classes of monikers may have trivial inverses. If a moniker adds one more component moniker to an existing structure, its inverse is a moniker that removes the last component of the existing structure. A moniker that when composed onto the end of a moniker removes the last component is referred to as an anti moniker. One skilled in the art would appreciate that not all monikers have inverses. The inverse of an anti moniker, for example, does not exist. The following table describes the parameters of the method Inverse.",{"@attributes":{"id":"p-0160","num":"0186"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ppmk","IMoniker**","the place to return the inverse moniker."]},{"entry":["return value","HRESULT","S_OK, MK_E_NOINVERSE."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"An anti moniker is a moniker that when composed onto the end of a generic composite moniker removes the last component moniker. Composing an anti moniker onto the end of another kind of moniker preferably annihilates the other moniker. The class CAntiMoniker contains a data member that is a count of the number of anti monikers (m_cAnti). Whenever an anti moniker is composed with another anti moniker, the resulting composition is an anti moniker with its count equal to the sum of the counts of the composed anti monikers.",{"@attributes":{"id":"p-0162","num":"0188"},"figref":["FIGS. 28A","FIG. 28A","FIG. 28B","FIG. 28C"],"b":["28","28","2801","2802","2803","2804","2801","2802","2802","2801","2801","2802","2805","2806","2807","2806","2807","2806","2804","2801","2807","2802","2808","2802","2801","2808","2804"]},{"@attributes":{"id":"p-0163","num":"0189"},"figref":"FIG. 29","b":["2901","2902","2903"]},{"@attributes":{"id":"p-0164","num":"0190"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0165","num":"0191"},"figref":"FIG. 31","b":["3101","3102","3103","3102","3103","3104","3104"]},{"@attributes":{"id":"p-0166","num":"0192"},"figref":"FIG. 32","b":["3201","3202","3203","3202","3203"]},{"@attributes":{"id":"p-0167","num":"0193"},"figref":"FIG. 33","b":["3301","3302","3304","3302","3303","3304","3305","3305"]},"IMoniker:CommonPrefixWith","HRESULT IMoniker::CommonPrefixWith(pmkOther, ppmkPrefix)","This method determines the longest common prefix that this moniker shares with the other moniker (pmkOther). The following table describes the parameters of the method CommonPrefixWith",{"@attributes":{"id":"p-0169","num":"0195"},"tables":{"@attributes":{"id":"TABLE-US-00027","num":"00027"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pmkOther","IMoniker*","the moniker with whom the common prefix"]},{"entry":[{},{},"is to be determined."]},{"entry":["ppmkPrefix","IMoniker*","the place to return the common prefix"]},{"entry":[{},{},"moniker. NULL is returned only in the case"]},{"entry":[{},{},"that the common prefix does not exist."]},{"entry":["return value","HRESULT","MK_S_ME, indicating that this moniker"]},{"entry":[{},{},"is the common prefix. MK_S_HIM,"]},{"entry":[{},{},"indicating that the other moniker (pmkOther)"]},{"entry":[{},{},"is the common prefix. MK_S_US,"]},{"entry":[{},{},"indicating that the two monikers are"]},{"entry":[{},{},"equal. S_OK, indicating that the common"]},{"entry":[{},{},"prefix exists but is neither this moniker nor"]},{"entry":[{},{},"the other moniker. MK_S_NOPREFIX"]},{"entry":[{},{},"indicating that no common prefix exists."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0170","num":"0196"},"figref":"FIG. 34","b":["3401","3402","3401","3402","3403"]},{"@attributes":{"id":"p-0171","num":"0197"},"figref":"FIG. 35","b":["3501","3505","3502","3502","3503","3504","3504","3502","3505","3507","3509","3507","3508","3505","3507","3509","3510","3511","3510","3511","3512","3505","3511"]},{"@attributes":{"id":"p-0172","num":"0198"},"figref":"FIG. 36","b":["3601","3603","3602","3602","3603","3606","3604","3604","3605","3606","3607","3608","3609","3611","3610","3610","3611"]},{"@attributes":{"id":"p-0173","num":"0199"},"figref":"FIG. 37","b":["3701","3702","3702"]},{"@attributes":{"id":"p-0174","num":"0200"},"figref":"FIG. 38","b":["3801","3803","3802","3802","3805","3804","3804","3805","3806"]},"MonikerCommonPrefixWith","HRESULT MonikerCommonPrefixWith(pmkThis, pmkOther, ppmkPrefix)","This function is invoked by implementations of the method CommonPrefixWith. This function handles the situation when the implementation does not recognize the type of the other moniker. The following table describes the parameters of the function MonikerCommonPrefixWith:",{"@attributes":{"id":"p-0176","num":"0202"},"tables":{"@attributes":{"id":"TABLE-US-00028","num":"00028"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pmkThis","IMoniker*","one moniker for the computation of the"]},{"entry":[{},{},"common prefix."]},{"entry":["pmkOther","IMoniker*","the other moniker for the computation of"]},{"entry":[{},{},"the common prefix."]},{"entry":["ppmkPrefix","IMoniker**","pointer to the common prefix."]},{"entry":["return value","HRESULT","S_OK, MK_S_HIM, MK_S_ME,"]},{"entry":[{},{},"MK_S_US, MK_S_NOPREFIX"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0177","num":"0203"},"figref":"FIG. 39","b":["3901","3902","3903","3902","3903","3905","3904","3904","3905","3906","3907","3907","3905"]},"IMoniker::RelativePathTo","HRESULT IMoniker::RelativePathTo(pmkOther, ppmkRelPath)","This method returns as a moniker that, when composed onto the end of this moniker or one with a similar structure, yields the other moniker (pmkOther). Implementations of this method preferably determine the longest prefix that this moniker and the other moniker have in common. This method separates this moniker and the other into two parts, say (P,T) and (P,T) respectively, where P is the common prefix. Tand Trepresent the trailing components. The relative path result is then T\u2218T, where Tindicates the inverse. Thus, (P,T) \u2218(T\u2218T)=(P, T).",{"@attributes":{"id":"p-0179","num":"0205"},"tables":{"@attributes":{"id":"TABLE-US-00029","num":"00029"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pmk0ther","IMoniker*","the other moniker to which a relative path"]},{"entry":[{},{},"should be taken."]},{"entry":["ppmkRelPath","IMoniker*","May not be NULL. The place at which the"]},{"entry":[{},{},"relative path is returned."]},{"entry":["return value","HRESULT","MK_S_HIM, indicating that the only"]},{"entry":[{},{},"form of relative path is in fact just the"]},{"entry":[{},{},"other moniker (pmkOther). S_OK,"]},{"entry":[{},{},"indicating that a non-trivial relative path"]},{"entry":[{},{},"exists."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0180","num":"0206"},"figref":"FIG. 40","b":["4001","4002","4003","4001","4002","4002","4001","4003","4001","4003","4003"]},{"@attributes":{"id":"p-0181","num":"0207"},"figref":["FIGS. 41A and 41B","FIG. 41B"],"b":["4101","4101","4102","4101","4101","4103","4103","4104","4105","4106","4106","4107","4108","4109","4106","4101","4101","4106"]},{"@attributes":{"id":"p-0182","num":"0208"},"figref":"FIGS. 42A","b":["42","42","4201","4202","4227","4202","4207","4202","4203","4204","4205","4206","4208","4206","4207","4208","4207","4203","4208","4209","4214","4209","4210","4209","4211","4213","4211","4209","4212","4216","4213","4214","4215","4216","4215","4216","4216","4217","4221","4217","4218","4219","4220","4219","4221","4220","4221","4221","4223","4222","4222","4224","4223","4224","4224","4226","4225","4225","4226","4227","4228","4229","4230","4229","4230","4232","4230","4232","4233","4232","4233","4234","4230"]},"MonikerRelativePathTo","HRESULT MonikerRelativePathTo(pmkSrc, pmkDest, ppmkRelPath, reserved)","This function is invoked by implementations of the method RelativePathTo. This method handles the situation when the implementation does not recognize the type of the other moniker.",{"@attributes":{"id":"p-0184","num":"0210"},"tables":{"@attributes":{"id":"TABLE-US-00030","num":"00030"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"189pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pmkSrc","IMoniker*","the starting moniker for the computation of the relative path."]},{"entry":["pmkDest","IMoniker*","the moniker to which a relative path should be taken."]},{"entry":["ppmkRelPath","IMoniker**","May not be NULL. The place at which the moniker of pmkDest"]},{"entry":[{},{},"relative to pmkSrc is to be returned."]},{"entry":["reserved","BOOL","must be non-zero"]},{"entry":["return value","HRESULT","S_OK. MK_S_HIM"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0185","num":"0211"},"figref":"FIG. 43","b":["4301","4304","4302","4302","4303","4305","4303","4304","4305","4306","4305","4306","4307","4308","4307","4308","4309","4310","4311","4310","4308","4311"]},"IMoniker::Enum","HRESULT IMoniker::Enum(fForward, ppenmMoniker)","This method returns an interface that permits the enumeration of the component monikers of which this moniker is logically a composite. For a generic composite moniker, this enumerates the components of which the composite is composed. For other monikers, the semantics of the components of which it is a composite are implementation-defined. For example, enumerating the components of a file moniker returns each portion of the internally stored path name, even though they are not stored internally as actual separate monikers. Monikers that have no discernible internal structure return NULL instead of an enumerator.","The IEnumMoniker interface is an enumerator that supports the enumeration of items which are monikers.",{"@attributes":{"id":"p-0188","num":"0214"},"tables":{"@attributes":{"id":"TABLE-US-00031","num":"00031"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"interface IEnumMoniker IUnknown{"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"252pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"virtual HRESULT Next(ULONG celt, IMoniker* rgelt[], ULONG* pceltFetched) = 0;"]},{"entry":[{},"virtual HRESULT Skip(ULONG celt) = 0;"]},{"entry":[{},"virtual HRESULT Reset( ) = 0:"]},{"entry":[{},"virtual HRESULT Clone(IEnumMoniker** ppenm) = 0;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The following table describes the parameters of the method Enum:",{"@attributes":{"id":"p-0190","num":"0216"},"tables":{"@attributes":{"id":"TABLE-US-00032","num":"00032"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"196pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["fForward","BOOL","If true, then the enumeration should be done in the normal order. If"]},{"entry":[{},{},"false, then the order should be the reverse of the order enumerated"]},{"entry":[{},{},"by the normal order."]},{"entry":["ppenmMoniker","IEnumMoniker**","On exit, the returned enumerator. May be NULL, signifying that"]},{"entry":[{},{},"there is nothing to enumerate."]},{"entry":["return value","HRESULT","S_OK."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0191","num":"0217"},"tables":{"@attributes":{"id":"TABLE-US-00033","num":"00033"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"CODE TABLE 8"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"class CCompositeMonikerEnum: IEnum"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ CCompositeMoniker FAR * m_pcm;"]},{"entry":[{},"\u2002BOOL m_fForward;"]},{"entry":[{},"\u2002se m_pBase;"]},{"entry":[{},"\u2002se m_pTop;"]},{"entry":[{},"\u2002LPMONIKER m_pNext;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0192","num":"0218"},"figref":"FIG. 44","b":["4401","4402","4406","4406"]},{"@attributes":{"id":"p-0193","num":"0219"},"figref":"FIG. 45","b":["4501","4502","4503","4503","4504","4504","4505","4506","4507","4506","4503","4507","4503"]},{"@attributes":{"id":"p-0194","num":"0220"},"figref":"FIG. 46","b":["4601","4602","4603","4607","4603","4604","4605","4606","4602","4607","4608"]},"The methods Push and Pop of the class CCompositeMonikerEnum implement a stack. The method Push pushes the passed generic composite moniker onto a stack. The method Pop removes a top generic composite moniker from the stack and invokes the method GetNext passing it the right moniker if a search is being performed in the forward direction and a left moniker if the search is being performed in the reverse direction. The method Pop returns the component moniker returned by the method GetNext.","Pointer Moniker Class","In a preferred embodiment, a pointer moniker is a class of moniker that wraps an existing pointer to an object in a moniker so that it may participate as a component moniker in the moniker binding process. A pointer is a reference into \u201cactive space,\u201d that is, memory of a process. A moniker typically is a reference into \u201cpassive space,\u201d that is, the representation of an object on disk. Pointer monikers provide a means by which a given use of a moniker can transparently reference either active or passive space.","In a preferred embodiment, the method BindToObject of a pointer moniker invokes the method QueryInterface of the pointed to object. The method BindToStorage returns MK_E_NOSTORAGE. The method Reduce reduces the moniker to itself. The method ComposeWith does a generic composition. The method Enum returns NULL. The method IsSystemMoniker returns MKSYS_NONE. The method IsEqual uses the identity test paradigm on pointers after first checking that the other moniker for the right class. The method Hash returns a constant. The method GetTimeOfLastChange returns MK_E_UNAVAILABLE. The method Inverse returns an anti moniker. The method RelativePathTo returns the other moniker. The method GetDisplayName returns NULL. The method ParseDisplayName binds to the punk pointer using IParseDisplayName interface. Pointer monikers do not serialize; that is, the Save of the IPersistStream interface returns an error.","CreatePointerMoniker","HRESULT CreatePointerMoniker(punk, ppmk)","This function wraps a pointer in a pointer moniker so that it can be presented to interfaces that require monikers for generality, but specific uses of which can usefully deal with a moniker which cannot be saved to backing store. The following table describes the parameters of the method CreatePointerMoniker.",{"@attributes":{"id":"p-0199","num":"0225"},"tables":{"@attributes":{"id":"TABLE-US-00034","num":"00034"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["punk","IUnknown*","the pointer that we are wrapping up"]},{"entry":[{},{},"in a moniker."]},{"entry":["ppmk","IMoniker**","the returned Pointer Moniker."]},{"entry":["return value","HRESULT","S_OK, E_OUTOFMEMORY"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0200","num":"0226"},"figref":"FIG. 47","b":["4701","4702"]},{"@attributes":{"id":"p-0201","num":"0227"},"figref":"FIG. 48","b":"4801"},{"@attributes":{"id":"p-0202","num":"0228"},"figref":"FIG. 49","b":["4901","4902","4902","4901"]},"Although the present invention has been described in terms of preferred embodiments, it is not intended that the invention be limited to these embodiments. Modifications within the spirit of the invention will be apparent to those skilled in the art. The scope of the present invention is defined by the claims which follow.","Details of the Moniker Related Interfaces","1.0 Additional IMonikerMethods","IMoniker::IsRunning","HRESULT IMoniker::IsRunning(pbc, pmkToLeft, pmkNewlyRunning)","Answer as to whether this moniker is in fact running. As usual, the Running Object Table in whose context this question is to be answered is obtained by this moniker from the Bind context. pmkToLeft is the moniker to the left of this object in the generic composite in which it is found, if any.","If non-NULL, pmkNewlyRunning is the moniker which has most recently been added to the Running Object Table; the implementation of IsRunning( ) can assume that without this object in the R.O.T., that IsRunning( ) would have reported that it was not running; thus, the only way that it can now be running is if this newly running moniker is in fact itself! This allows for some n-to-n reductions in algorithms that use monikers. (If the moniker implementation chose to ignore pmkNewlyRunning, no harm would come: this moniker is in fact in the R.O.T.)","Implementations of this method in various kinds of moniker classes are roughly as follows:",{"@attributes":{"id":"p-0207","num":"0233"},"tables":{"@attributes":{"id":"TABLE-US-00035","num":"00035"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Generic Composite Moniker"},{"entry":"\u2003if(pmkToLeft != NULL)"},{"entry":"\u2003\u2003return (pmkToLeft->ComposeWith(this))-> IsRunning(pbc, NULL,"},{"entry":"\u2003pmkNewlyRunning);"},{"entry":"\u2003if(pmkNewlyRunning != NULL) {"},{"entry":"\u2003\u2003if (pmkNewlyRunning-> IsEqual(this) == NOERROR)"},{"entry":"\u2003\u2003\u2003return NOERROR;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003else if(pRunningObjectTable -> IsRunning(this) == NOERROR)"},{"entry":"\u2003\u2003return NOERROR;"},{"entry":"\u2003\/\/ otherwise, forward it on to my last element."},{"entry":"\u2003return this->Last( )->IsRunning(pbc, this->AllButLast( ),"},{"entry":"\u2003pmkNewlyRunning)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},{"@attributes":{"id":"p-0208","num":"0234"},"tables":{"@attributes":{"id":"TABLE-US-00036","num":"00036"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"if(pmkToLeft == NULL) {"]},{"entry":[{},"\u2003if (pmkNewlyRunning != NULL)"]},{"entry":[{},"\u2003\u2003return pmkNewlyRunning -> IsEqual(this);"]},{"entry":[{},"\u2003else"]},{"entry":[{},"\u2003\u2003return pRunningObjectTable -> IsRunning(this);"]},{"entry":[{},"\u2003}"]},{"entry":[{},"else"]},{"entry":[{},"\u2003return ResultFromScode(S_FALSE); \/\/ If I  running,"]},{"entry":[{},"\u2003\u2003then Generic Composite would have caught it."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0209","num":"0235"},"tables":{"@attributes":{"id":"TABLE-US-00037","num":"00037"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"if (pmkToLeft == NULL){"]},{"entry":[{},"\u2003if (pmkNewlyRunning != NULL)"]},{"entry":[{},"\u2003\u2003return pmkNewlyRunning->IsEqual(this) == NOERROR"]},{"entry":[{},"\u2003\u2003\u2003\u2225 pmkNewlyRunning->IsEqual(my wild card"]},{"entry":[{},"\u2003\u2003\u2003moniker)==NOERROR;"]},{"entry":[{},"\u2003if (pRunningObjectTable -> IsRunning(this) == NOERROR)"]},{"entry":[{},"\u2003\u2003return NOERROR;"]},{"entry":[{},"\u2003return pRunningObjectTable -> IsRunning(my wild card moniker);"]},{"entry":[{},"\u2003}"]},{"entry":[{},"else"]},{"entry":[{},"\u2003return pmkToLeft->ComposeWith(my wild card"]},{"entry":[{},"\u2003\u2003moniker) -> IsRunning(pbc, NULL, pmkNewlyRunning);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0210","num":"0236"},"tables":{"@attributes":{"id":"TABLE-US-00038","num":"00038"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"if (pmkToLeft == NULL) {"},{"entry":"\u2003if (pmkNewlyRunning != NULL) {"},{"entry":"\u2003\u2003if (pmkNewlyRunning->IsEqual(this) == NOERROR)"},{"entry":"\u2003\u2003\u2003return NOERROR;"},{"entry":"\u2003\u2003if(pmkNewlyRunning->IsEqual(my wild card"},{"entry":"\u2003\u2003moniker) != NOERROR)"},{"entry":"\u2003\u2003\u2003return ResultFromScode(S_FALSE);"},{"entry":"\u2003\u2003goto TestBind;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"if (pmkToLeft->ComposeWith(my wild card moniker)->IsRunning(pbc,"},{"entry":"\u2003\u2003NULL, pmkNewlyRunning) != NOERROR)"},{"entry":"\u2003return ResultFromScode(S_FALSE);"},{"entry":"Test Bind:"},{"entry":"\u2002\/\/ In general, connect to the container and ask whether the object is"},{"entry":"\u2002\/\/ running. The use of IOleItemContainer here is Item Moniker-specific,"},{"entry":"\u2002but the theme is a general one."},{"entry":"\u2002IOleItemContainer *pcont;"},{"entry":"\u2002pmkToLeft->BindToObject(pbc, NULL, IID_IOleItemContainer,"},{"entry":"\u2002&pcont);"},{"entry":"\u2002return pcont->IsRunning(szItemString);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The arguments to this function are as follows:",{"@attributes":{"id":"p-0212","num":"0238"},"tables":{"@attributes":{"id":"TABLE-US-00039","num":"00039"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pbc","IBindCtx*","the usual bind context"]},{"entry":["pmkToLeft","IMoniker*","the moniker to the left of this one in"]},{"entry":[{},{},"the composite which it is found."]},{"entry":["pmkNewlyRunning","IMoniker*","may be NULL. If non-NULL, then"]},{"entry":[{},{},"this is the moniker which has been"]},{"entry":[{},{},"most recently added to the R.O.T.. In"]},{"entry":[{},{},"this case, IMoniker::IsRunning( )"]},{"entry":[{},{},"implementations may assume that"]},{"entry":[{},{},"without this moniker in the R.O.T."]},{"entry":[{},{},"that IsRunning( ) would return"]},{"entry":[{},{},"S_FALSE"]},{"entry":["return value","HRESULT","S_OK_FALSE"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"Answer the earliest time after which the object pointed to by this moniker is known not to have changed.","The purpose of this function is to support the ability to determine whether a given OLE link object or OLE embedded object which contains links is up-to-date or not. This is usually done as user documents are opened; thus, in most cases it will be important that this operation is fast. Implementations should pay particular attention to the deadline parameter passed in the bind context.","If it is not the case that all the objects in a document are known to be up-to-date, the user will usually be prompted with a dialog as to whether they should be updated. If he says yes, then each of the objects which is not known to be up-to-date will be bound in order to retrieve a new presentation. The point germane to the present discussion is that GetTimeOfLastChange( ) is part of the mechanism of avoiding binding to objects unnecessarily. GetTimeOfLastChange( ) itself, therefore, should not bind to the object in order to obtain the most accurate answer. Rather, it should return the best available answer given objects that are akeady running. Many monikers denote an object contained in the object denoted by the moniker to their left. Implementations of GetTimeOfLastChange( ) in most of these monikers can take advantage of the fact they cannot have changed any later than the object in which they are contained. That is, these monikers can simply forward the call onto the moniker to their left.","The returned time of change is reported using a FILETIME. A FILETIME is a 64-bit value indicating a time in units of 100 nanoseconds, with an origin in 1601. A resolution of 100 nanoseconds allows us to deal with very fast-changing data; allocating this many bits gives us a range of tens of thousands of years. It is not expected that most change times in objects will actually be internally recorded with this precision and range; they only need be reported with such.","If the time of last change is unavailable, either because the deadline was exceeded or otherwise, then it is recommended that a FILETIME of {dwLowDateTime, dwHighDateTime}={OxFFFFFFFF,0x7FFFFFFF} (note the 0x7 to avoid accidental unsigned\/signed confusions) should be passed back. If the deadline was exceeded, then the status MK_E_EXCEEDEDDEADLINE should be returned. If the time of change is unavailable, and would not be available no matter what deadline were used, then MX_E_UNAVAILABLE should be returned. Otherwise S_OK should be returned.","If pmkToLeft is NULL, then this function should generally first check for a recorded change-time in the Running Object Table with IRunningObjectTable::GetTimeOfLastChange( ) before proceeding with other strategies. Moniker classes that support wildcards will have to take into consideration exactly what does get put in the R.O.T. and look for the appropriate thing; since Generic Composite Monikers know nothing of wildcards, they may even need to do that in the non-NULL pmkToLeft case.","See IMoniker::IsRunning( ).",{"@attributes":{"id":"p-0219","num":"0245"},"tables":{"@attributes":{"id":"TABLE-US-00040","num":"00040"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pbc","IBindCtx*","the binding context for this operation."]},{"entry":["pmkToLeft","IMoniker*","the moniker to the left of this one in the"]},{"entry":[{},{},"composite in which it is found."]},{"entry":["pfiletime","FILETIME*","the place in which the time of last change"]},{"entry":[{},{},"should be reported."]},{"entry":["return value","HRESULT","S_OK, MK_E_EXCEEDEDDEADLINE,"]},{"entry":[{},{},"MK_E_UNAVAILABLE,"]},{"entry":[{},{},"MK_E_CONNECTMANUALLY"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The bind context parameter passed to many of the liMoniker operations serves a few purposes.","Its primary purpose is to accumulate the set of objects that get bound during an operation but which should be released when the operation is complete. This is particularly useful in generic composites: using the bind context in this way avoids binding an object, releasing it, only to have it bound again when the operation moves on to another piece of the composite.","Another purpose of the bind context is to pass a group of parameters which do not change as an operation moves from one piece of a generic composite to another. These are the binding options, and are described below. Some of these binding options have a related return value in certain error conditions; the bind context provides the means by which they can be returned.","The bind context is also the only means through which moniker operations should access contextual information about their environment. Preferably, there should be no direct calls in moniker implementations to API functions that query or set state in the environment; all such calls should instead funnel through the bind context. Doing this allows for future enhancements which can dynamically modify binding behaviour. In OLE 2, the most important piece of contextual information that moniker operations need to access is the Running Object Table; monikers should always access this table indirectly through IBindCtx::GetRunningObjectTable( ), rather than using the global function GetRunningObjectTable( ). IBindCtx interface allows for future extensions to the passed-in contextual information in the form of the ability to maintain a stringkeyed table of objects.","See IBindCtx::RegisterObjectParam( ) and related functions.",{"@attributes":{"id":"p-0224","num":"0250"},"tables":{"@attributes":{"id":"TABLE-US-00041","num":"00041"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"interface IBindCTX : IUnknown {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"virtual","HRESULT","RegisterObjectBound(punk) = 0;"]},{"entry":[{},"virtual","HRESULT","RevokeObjectBound(punk) = 0;"]},{"entry":[{},"virtual","HRESULT","ReleaseBoundObjects( ) = 0;"]},{"entry":[{},"virtual","HRESULT","SetBindOptions(pbindopts) = 0;"]},{"entry":[{},"virtual","HRESULT","GetBindOptions(pbindopts) = 0;"]},{"entry":[{},"virtual","HRESULT","GetRunningObjectTable(pprot) = 0;"]},{"entry":[{},"virtual","HRESULT","RegisterObjectParam(lpszKey, punk) = 0;"]},{"entry":[{},"virtual","HRESULT","GetObjectParam(lpszKey, ppunk) = 0;"]},{"entry":[{},"virtual","HRESULT","EnumObjectParam(ppenum) = 0;"]},{"entry":[{},"virtual","HRESULT","RevokeObjectParam(lpszKey) = 0;"]},{"entry":[{},"};"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"typed struct {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"DWORD cbStruct;","\/\/the size in bytes of this structure. ie:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"sizeof(BINDOPTS)."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"DWORD grfFlags;"]},{"entry":[{},"DWORD grfMode;"]},{"entry":[{},"DWORD dwTickCountDeadline;"]},{"entry":[{},"}BINDOPTS;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"HRESULT CreateBindCtx(reserved, ppbc);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"IBindCtx::RegisterObjectBound"},{"entry":"HRESULT IBindCtx::RegisterObjectBound(punk)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Remember the passed object as one of the objects that has been bound during a moniker operation and which should be released when it is complete overall. Calling this function causes the binding context to create an additional reference to the passed-in object with IUnknown::AddRef( ); the caller is still required to Release( ) its own copy of the pointer independently.","The effect of calling this function twice with the same object is cumulative, in that it will require two RevokeObjectBound( ) calls to completely remove the registration of the object within the binding context.",{"@attributes":{"id":"p-0227","num":"0253"},"tables":{"@attributes":{"id":"TABLE-US-00042","num":"00042"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["punk","IUnknown*","the object which is being registered as"]},{"entry":[{},{},"needing to be released."]},{"entry":["return value","HRESULT","S_OK."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"This function undoes the effect of IBindCtx::RegisterObjectBound( ): it removes the object from the set that will be released when the bind context in IBindCtx::ReleaseBoundObjects ( ) (actually removes one occurrence of it). This function is likely to be rarely called, but is included for completeness.",{"@attributes":{"id":"p-0229","num":"0255"},"tables":{"@attributes":{"id":"TABLE-US-00043","num":"00043"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["punk","IUnknown*","the object which no longer needs to be"]},{"entry":[{},{},"released."]},{"entry":["return value","HRESULT","S_OK, MK_E_NOTBOUND,"]},{"entry":[{},{},"E_OUTOFMEMORY"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"Releases all the objects currently registered with the bind context through RegisterObjectBound( ). This function is (conceptually) called by the implementation of IBindCtx::Release( ).",{"@attributes":{"id":"p-0231","num":"0257"},"tables":{"@attributes":{"id":"TABLE-US-00044","num":"00044"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Argument","Type","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"return value","HRESULT","S_OK"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":[{},{}]},"Store in the bind context a block of parameters that will apply to later IMoniker operations using this bind context. Using block of parameters like this is just an alternative way to pass parameters to an operation. We distinguish the parameters we do for conveyance by this means because 1) they are common to most IMoniker operations, and 2) these parameters do not change as the operation moves from piece to piece of a generic composite.",{"@attributes":{"id":"p-0233","num":"0259"},"tables":{"@attributes":{"id":"TABLE-US-00045","num":"00045"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pbindopts","BINDOPTS*","the block of parameters to set. These can"]},{"entry":[{},{},"later be retrieved with GetBindOptions( )."]},{"entry":["return value","HRESULT","S_OK, E_OUTOFMEMORY"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"ul":{"@attributes":{"id":"ul0012","list-style":"none"},"li":{"@attributes":{"id":"ul0012-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0013","list-style":"none"},"li":"BINDOPTS is defined as follows:"}}}},{"@attributes":{"id":"p-0234","num":"0261"},"tables":{"@attributes":{"id":"TABLE-US-00046","num":"00046"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u2003typedef struct tagBINDOPTS {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u2003DWORD cbStruct;","\/\/ the size in bytes of this Structure. ie:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"sizeof(BINDOPTS)."]},{"entry":[{},"\u2003DWORD grfFlags;"]},{"entry":[{},"\u2003DWORD grfMode;"]},{"entry":[{},"\u2003DWORD dwTickCountDeadline;"]},{"entry":[{},"\u2003}BINDOPTS;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The members of this structure have the following meanings:",{"@attributes":{"id":"p-0236","num":"0263"},"tables":{"@attributes":{"id":"TABLE-US-00047","num":"00047"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Member","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["grfFlags","A group of boolean flags. Legal values that may"]},{"entry":[{},"be or'd together are taken from the enumeration"]},{"entry":[{},"of BINDFLAGS; see below. Moniker implemen-"]},{"entry":[{},"tations should simply ignore any set-bits in this"]},{"entry":[{},"field that they do not understand (presumably"]},{"entry":[{},"because their meanings were defined in some"]},{"entry":[{},"future OLE extension)."]},{"entry":["grfMode","A group of flags that indicates the intended use"]},{"entry":[{},"that the caller has towards the object that he"]},{"entry":[{},"ultimately receives from the associated moniker"]},{"entry":[{},"binding operation. Constants for this member are"]},{"entry":[{},"taken from the STGM enumeration, described in"]},{"entry":[{},"the chapter on \u201cPersistent Storage For Objects.\u201d"]},{"entry":[{},"When applied to the BindToObject( ) operation,"]},{"entry":[{},"by far the most significant flag values are:"]},{"entry":[{},"STGM_READ, STGM_WRITE, and"]},{"entry":[{},"STGM_READWRITE. It is possible that some"]},{"entry":[{},"binding operations might make use of the other"]},{"entry":[{},"flags, particularly"]},{"entry":[{},"STGM_DELETEONRELEASE or"]},{"entry":[{},"STGM_CREATE, but such cases are quite"]},{"entry":[{},"esoteric."]},{"entry":[{},"When applied to the BindToStorage( ) operation,"]},{"entry":[{},"most values are potentially useful here."]},{"entry":[{},"The default value for grfMode is"]},{"entry":[{},"STGM_SHARE_EXCLUSIVE."]},{"entry":["dwTickCountDeadline","This is an indication of when the caller would"]},{"entry":[{},"like the operation to complete. Having this"]},{"entry":[{},"parameter allows the caller to approximately"]},{"entry":[{},"& heuristically bound the execution time of"]},{"entry":[{},"an operation when it is more important that"]},{"entry":[{},"the operation perform quickly than it is that"]},{"entry":[{},"it perform accurately. Most often, this capa-"]},{"entry":[{},"bility is used with IMoniker::GetTimeOfLast-"]},{"entry":[{},"Change( ), as was previously described, though"]},{"entry":[{},"it can be usefully applied to other operations"]},{"entry":[{},"as well."]},{"entry":[{},"This 32-bit unsigned value is a time in milli-"]},{"entry":[{},"seconds on the local clock maintained by the"]},{"entry":[{},"GetTickCount( ) function. A value of zero indi-"]},{"entry":[{},"cates \u201cno deadline;\u201d callers should therefore"]},{"entry":[{},"be careful not to pass to the bind context a value"]},{"entry":[{},"of zero that was coincidentally obtained from"]},{"entry":[{},"GetTickCount( ). Clock wrapping is also a"]},{"entry":[{},"problem. Thus, if the value in this variable is"]},{"entry":[{},"less than the current time by more than 2"]},{"entry":[{},"milliseconds, then it should be interpreted as"]},{"entry":[{},"indicating a time in the future of its indicated"]},{"entry":[{},"value plus 2milliseconds."]},{"entry":[{},"Typical deadlines will allow for a few hundred"]},{"entry":[{},"milliseconds of execution. Each function should"]},{"entry":[{},"try to complete its operation by this time on the"]},{"entry":[{},"clock, or fail with the error"]},{"entry":[{},"MK_E_EXCEEDEDDEADLINE"]},{"entry":[{},"if it cannot do so in the time allotted. Functions"]},{"entry":[{},"are not required to be absolutely accurate in this"]},{"entry":[{},"regard, since it is almost impossible to predict"]},{"entry":[{},"how execution might take (thus, callers cannot"]},{"entry":[{},"rely on the operation completing by the deadline),"]},{"entry":[{},"but operations which exceeded their deadline"]},{"entry":[{},"excessively will usually cause intolerable user"]},{"entry":[{},"delays in the operation of their callers. Thus, in"]},{"entry":[{},"practice, the use of deadlines is a heuristic which"]},{"entry":[{},"callers can impose on the excution of moniker"]},{"entry":[{},"operations."]},{"entry":[{},"If a moniker operation exceeds its deadline"]},{"entry":[{},"because a given object or objects that it"]},{"entry":[{},"uses are not running, and if one of these had"]},{"entry":[{},"been running, then the operation would have"]},{"entry":[{},"completed more of its execution, then the"]},{"entry":[{},"monikers of these objects should be recorded"]},{"entry":[{},"in the bind context using RegisterObjectParam( )"]},{"entry":[{},"under the parameter names \u201cExceededDeadline\u201d,"]},{"entry":[{},"\u201cExceededDeadline1\u201d, \u201cExceededDeadline2\u201d,"]},{"entry":[{},"etc.; use the first name in this series that is"]},{"entry":[{},"currently unused. This approach gives the caller"]},{"entry":[{},"some knowledge as to when to try the operation"]},{"entry":[{},"again."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The enumeration BTNDFLAGS, which contains the legal values for the bitfield BLNDOPTS::grfFlags, is defined as follows:",{"@attributes":{"id":"p-0238","num":"0265"},"tables":{"@attributes":{"id":"TABLE-US-00048","num":"00048"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef enum tagBINDFLAGS {"]},{"entry":[{},"\u2002BINDFLAGS_MAYBOTHERUSER = 1,"]},{"entry":[{},"\u2002BINDFLAGS_JUSTTESTEXISTENCE = 2,"]},{"entry":[{},"\u2002}BINDFLAGS;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"These flags have the following interpretation.",{"@attributes":{"id":"p-0240","num":"0267"},"tables":{"@attributes":{"id":"TABLE-US-00049","num":"00049"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Value","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["BINDFLAGS","If not present, then the operation to which the"]},{"entry":["MAYBOTHERUSER","bind context containing this parameter is ap-"]},{"entry":[{},"plied should not interact with the user in any"]},{"entry":[{},"way, such to ask for a password for a network"]},{"entry":[{},"volume that needs mounting. If present, then"]},{"entry":[{},"this sort of interaction is permitted. If pro-"]},{"entry":[{},"hibited from interacting with the user when it"]},{"entry":[{},"otherwise would like to, an operation may elect"]},{"entry":[{},"to use a different algorithm that does not"]},{"entry":[{},"require user interaction, or it may fail with"]},{"entry":[{},"the error MK_MUSTBOTHERUSER."]},{"entry":["BINDFLAGS","If present, indicates that the caller of the"]},{"entry":["JUSTTESTEXISTENCE","moniker operation to which this flag is being"]},{"entry":[{},"applied is not actually interested in having"]},{"entry":[{},"the operation carried out, but only in learning"]},{"entry":[{},"of the operation could have been carried out"]},{"entry":[{},"had this flag not been specified. For example,"]},{"entry":[{},"this flag gives the caller the ability to express"]},{"entry":[{},"that he is only interested in finding out whether"]},{"entry":[{},"an object actually exists by using this flag in a"]},{"entry":[{},"BindToObject( ) call. Moniker implementations"]},{"entry":[{},"are free, however, to ignore this possible"]},{"entry":[{},"optimization and carry out the operation in full."]},{"entry":[{},"Callers, therefore, need to be able to deal with"]},{"entry":[{},"both cases. See the individual routine descrip-"]},{"entry":[{},"tions for details of exactly what status is"]},{"entry":[{},"returned."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"Return the current binding options stored in this bind context. See IBindCtx::SetBindOpts( ). for a description of the semantics of each option.","Notice that the caller provides a BINDOPTS structure, which is filled in by this routine. It is the caller's responsibility to fill in the cbStruct member correctly.",{"@attributes":{"id":"p-0243","num":"0270"},"tables":{"@attributes":{"id":"TABLE-US-00050","num":"00050"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pbindOpts","BINDOPTS","the structure of binding options which is"]},{"entry":[{},"*","to be filled in."]},{"entry":["Return value","SCODE"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"Return access to the Running Object Table relevant to this binding process. Moniker implementations should get access to the Running Object Table using this function rather than the global API GetRunningObjectTable( ). The appropriate Running Object Table is determined implicitly at the time the bind context is created.",{"@attributes":{"id":"p-0245","num":"0272"},"tables":{"@attributes":{"id":"TABLE-US-00051","num":"00051"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pprot","IRunningObjectTable*","the place to return the running object"]},{"entry":[{},{},"table."]},{"entry":[{},"*"]},{"entry":["return","SCODE"]},{"entry":"value"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"Register the given object pointer under the name lpszKey in the internally-maintained table of object pointers. The intent of this table is that it be used as a extensible means by which contextual information can be passed to the binding process. String keys are compared case-sensitive.","Like IBindCtx::RegisterObjectBound( ), this function creates an additional reference to the passed-in object using IUnknown::AddRef( ). The effect of calling this function a second time with the same lpszKey is to replace in the table the object passed-in the first time.","By convention, moniker implementers may freely use object parameters whose names begin with the string representation of the class Id of the moniker implementation in question.","This facility is also used as means by which various errors can convey information back to the caller. Associated with certain error values are the following object parameters:",{"@attributes":{"id":"p-0250","num":"0277"},"tables":{"@attributes":{"id":"TABLE-US-00052","num":"00052"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Error","Parameters"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["MK_E","Parameters named \u201cExceededDeadline\u201d,"]},{"entry":["EXCEEDEDDEADLINE","\u201cExceededDeadline1 \u201d, \u201cExceededDeadline2\u201d,"]},{"entry":[{},"etc., if they exist, are monikers whose appear-"]},{"entry":[{},"ance as running would make it reasonable for"]},{"entry":[{},"the caller to attempt the binding operation"]},{"entry":[{},"again."]},{"entry":["MK_E","The parameter named \u201cConnectManually\u201d is a"]},{"entry":["CONNECT-","moniker whose display name should be shown"]},{"entry":["MANUALLY","to the user requesting that he manually connect"]},{"entry":[{},"it, then retry the operation. The most common"]},{"entry":[{},"reason for returning this value is that a pass-"]},{"entry":[{},"word is needed. However, it could be that a"]},{"entry":[{},"floppy needs to be mounted."]},{"entry":[{},"The existence of this error return is a conces-"]},{"entry":[{},"sion. In the best case, this stuff should be"]},{"entry":[{},"completely handled inside the moniker imple-"]},{"entry":[{},"mentations themselves."]},{"entry":["E_CLASSNOTFOUND","The parameter named \u201cClassNotFound\u201d, if"]},{"entry":[{},"present, is a moniker to the storage of the"]},{"entry":[{},"object whose class was not able to be loaded"]},{"entry":[{},"in the process of a moniker operation."]},{"entry":[{},"When the moniker is being used in an OLE"]},{"entry":[{},"compound document situation, a sophisticated"]},{"entry":[{},"client may wish to BindToStorage( ) on this"]},{"entry":[{},"moniker, then attempt to carry out a Treat"]},{"entry":[{},"As. . . or Convert To. . . operation as described"]},{"entry":[{},"in the \u201cPersistent Storage For Objects\u201d chapter."]},{"entry":[{},"If this is successful, then the binding operation"]},{"entry":[{},"could be tried again. Such a methodology"]},{"entry":[{},"improves the usability of link operations."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"New moniker authors can freely use parameter names that begin with the string form of the CLSID of their moniker; see StringFrom CLSID( ).","The arguments to this function are as follows:",{"@attributes":{"id":"p-0253","num":"0280"},"tables":{"@attributes":{"id":"TABLE-US-00053","num":"00053"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["lpszKey","LPSTR","the name under which the object is being"]},{"entry":[{},{},"registered."]},{"entry":["punk","IUnknown*","the object being registered."]},{"entry":["return value","HRESULT","S_OK, E_OUTOFMEMORY"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"Lookup the given key in the internally-maintained table of contextual object parameters and return the corresponding object, if one exists.",{"@attributes":{"id":"p-0255","num":"0282"},"tables":{"@attributes":{"id":"TABLE-US-00054","num":"00054"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["lpszKey","LPSTR","the key under which to look for an object."]},{"entry":["ppunk","IUnknown**","The place to return the object interface"]},{"entry":[{},{},"pointer. NULL is returned on failure"]},{"entry":[{},{},"(along with S_FALSE)."]},{"entry":["return value","HRESULT","S_OK, S_FALSE"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"Enumerate the strings which are the keys of the internally-maintained table of contextual object parameters.",{"@attributes":{"id":"p-0257","num":"0284"},"tables":{"@attributes":{"id":"TABLE-US-00055","num":"00055"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ppenum","IEnumString*","the place to return the string enumerator."]},{"entry":[{},"*","If the time of change is unavailable, and"]},{"entry":[{},{},"would not be available no matter what"]},{"entry":[{},{},"deadline were used, then MK_E"]},{"entry":[{},{},"UNAVAILABLE should be returned."]},{"entry":["return value","HRESULT","S_OK, E_OUTOFMEMORY"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"Revoke the registration of the object currently found under this key in the internally-maintained table of contextual object parameters, if any such key is currently registered.",{"@attributes":{"id":"p-0259","num":"0286"},"tables":{"@attributes":{"id":"TABLE-US-00056","num":"00056"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["lpszKey","LPSTR","the key whose registration is to be revoked."]},{"entry":["return value","HRESULT","S_OK, S_FALSE"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"Allocate and initialize a new BindCtx using an OLE-supplied implementation.",{"@attributes":{"id":"p-0261","num":"0288"},"tables":{"@attributes":{"id":"TABLE-US-00057","num":"00057"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["reserved","DWORD","reserved for future use; must be zero."]},{"entry":["ppbc","IBindCtx*","the place in which to put the new BindCtx."]},{"entry":["return value","HRESULT","S_OK, E_OUTOFMEMORY"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},"Now that we understand how monikers provide a generalized abstraction of a reference to data, we will examine in detail the workings of the most common place in which monikers are actually used: OLE 2 linked compound-document objects.","As mentioned earlier, OLE 2 provides for tracking links as they move about relative to their sources. In order to support the most general such support it is necessary to as the moniker of the link source to generate a tracking representation of itself (which would be another moniker, of course, perhaps called a \u201ctracking moniker\u201d). Though this most-general support has been designed, and will be implemented in the future, it is not implemented in OLE 2. Instead, in OLE 2 knowledge of one particularly important link-tracking algorithm is incorporated in to the OLE-provided link object: in addition to storing the moniker given to it with IOIeLink::SetSourceMoniker( ), it also stores a relative moniker formed using its own moniker, the source moniker, and IMoniker::RelativePathTo( ). The relative moniker has priority over the original, absolute moniker: the link object always tries to bind the relative moniker first, using the absolute moniker on if the relative one fails to bind. Using a relative moniker in addition to the absolute moniker in this way covers the following link tracking scenanos:\n\n","From a container's perspective, the architectural difference between an embedding and a link is that a link supports IOIeLink interface whereas an embedding does not. IOIeLink interface contains functionality by which the moniker inside the link and the link's update options are manipulated.",{"@attributes":{"id":"p-0265","num":"0294"},"tables":{"@attributes":{"id":"TABLE-US-00058","num":"00058"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"interface IOleLink : IUnknown {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"virtual","HRESULT","SetUpdateOptions(dwUpdateOpt) = 0;"]},{"entry":[{},"virtual","HRESULT","GetUpdateOptions(pdwUpdateOpt) = 0;"]},{"entry":[{},"virtual","HRESULT","SetSourceMoniker(pmk, rclsid) = 0;"]},{"entry":[{},"virtual","HRESULT","GetSourceMoniker(ppmk) = 0;"]},{"entry":[{},"virtual","HRESULT","SetSourceDisplayName"]},{"entry":[{},{},{},"(lpszDisplayName) = 0;"]},{"entry":[{},"virtual","HRESULT","GetSourceDisplayName"]},{"entry":[{},{},{},"(lplpszDisplayName) = 0;"]},{"entry":[{},"virtual","HRESULT","BindToSource(bindflags, pbc) = 0;"]},{"entry":[{},"virtual","HRESULT","BindIfRunning( ) = 0;"]},{"entry":[{},"virtual","HRESULT","GetBoundSource(ppUnk) = 0;"]},{"entry":[{},"virtual","HRESULT","UnbindSource( ) = 0;"]},{"entry":[{},"virtual","HRESULT","Update(pbc) = 0;"]},{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}},"br":[{},{}]},"This function sets the link-update options for the link object. This controls exactly when the data andior presentation cache on the consuming end of the line is updated. dwUpdateOpt is taken from the enumeration OLEUPDATE, defined as follows:",{"@attributes":{"id":"p-0267","num":"0296"},"tables":{"@attributes":{"id":"TABLE-US-00059","num":"00059"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef enum tagOLEUPDATE {"]},{"entry":[{},"\u2003OLEUPDATE_ALWAYS=1,"]},{"entry":[{},"\u2003OLEUPDATE_ONCALL=3,"]},{"entry":[{},"\u2003}OLEUPDATE;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"These flags have the following semantics:",{"@attributes":{"id":"p-0269","num":"0298"},"tables":{"@attributes":{"id":"TABLE-US-00060","num":"00060"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Value","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["OLEUPDATE_ALWAYS","update the link object whenever possible."]},{"entry":[{},"This option supports the Automatic link-"]},{"entry":[{},"update option in the Links dialog box. This"]},{"entry":[{},"is the default value."]},{"entry":["OLEUPDATE_ONCALL","update the link object only when"]},{"entry":[{},"IOleObject::Update( ) is called. This option"]},{"entry":[{},"supports the Manual link-update option in"]},{"entry":[{},"the Links dialog box."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The arguments to this function have the following meanings.",{"@attributes":{"id":"p-0271","num":"0300"},"tables":{"@attributes":{"id":"TABLE-US-00061","num":"00061"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Argument","Type","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"dwUpdateOpt","DWORD","flags taken from the enumeration"]},{"entry":[{},{},{},"OLEUPDATE."]},{"entry":[{},"return value","HRESULT","S_OK, E_INVALIDARG"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":[{},{}]},"Retrieve update options previously set with IOIeLink::SetUpdateOptions( ).",{"@attributes":{"id":"p-0273","num":"0302"},"tables":{"@attributes":{"id":"TABLE-US-00062","num":"00062"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pdwUpdateOpt","DWORD*","a place to return flags taken from the"]},{"entry":[{},{},"enumeration OLEUPDATE."]},{"entry":["return value","HRESULT","S_OK"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"Stores inside of the link object a moniker which indicates the source of the link. This moniker becomes part of the persistent state of the object. In addition to storing this moniker, in order to support link source tracking, link objects also store a relative moniker computed as:\n\n","When in the running state (i.e.: the source moniker has been bound and connected), a link object registers itself on its link source to receive rename notifications. When one is received, the link object updates its source moniker to the new name. The primary reason for doing this is to handle as best we can the situation where a link is made to a newly created document that has never been saved, though doing this does provide better link tracking in general. For example, newly created Excel spreadsheets are named \u201cSHEET1\u201d, \u201cSHEET2\u201d, etc. Only when they are saved for the first time do they acquire a persistent identity which is appropriate to store in links to them. So long as the sheet is saved before its link consumer is closed the link will track correctly.","Recall that from the container's perspective, a link is just an embedding that also happens to support the IOIeLink interface. In particular, a link object may be at different times in both the loaded and the running state. When in the loaded state, the link object still needs to be able to carry out a limited amount of class-specific, such as verb enumeration, data format enumeration, etc. In order to be able to carry this out, the link object keeps as part of its persistent state an internal cache of the CLSID of the object to which it was last connected. The parameter rclsid here is the initial value of the cache. The cache is updated whenever the link connects. Further, SetSourceMoniker( ) does a BindIfRunning( ), so if the link source indicated by pink is currently running, then rclsid has basically no effect. See also IOIeLink::BindToSource( ).",{"@attributes":{"id":"p-0277","num":"0307"},"tables":{"@attributes":{"id":"TABLE-US-00063","num":"00063"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pmk","IMoniker*","the new moniker for the link."]},{"entry":["rclsid","REFCLSID","the value to set for the cached class of the"]},{"entry":[{},{},"link source that is kept in the link object."]},{"entry":[{},{},"Most often either CLSID_NULL or the"]},{"entry":[{},{},"previous value of the CLSID (obtainable"]},{"entry":[{},{},"with IOleObject::GetUserClassID( )) is"]},{"entry":[{},{},"passed."]},{"entry":["return value","HRESULT","S_OK"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"Retrieve the indication of the current link source.",{"@attributes":{"id":"p-0279","num":"0309"},"tables":{"@attributes":{"id":"TABLE-US-00064","num":"00064"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ppmk","IMoniker**","the place at which the moniker currently in"]},{"entry":[{},{},"the link should be placed."]},{"entry":["return value","HRESULT","S_OK"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"As described above in IMoniker::GetDisplayName( )., monikers used to indicate the source of embedded link objects have a display name by which they can be shown to the user. Conversely display names can be parsed into moniker using MkParseDisplayName( ). Most often, the indication of a link source is provided directly in a moniker, such as the moniker passed through the clipboard in a Copy\/Paste Link operation. Less frequently, it originates in a textual form, such as the text box in the Edit\/Links . . . dialog.","Monikers originating in textual form of course need to be parsed into monikers in order to be stored as the source of a link. A key question is whether this is done before or after the display name\/moniker is passed to the link object. Both scenarios are supported.\n\n","In the latter case, then by the first time the link needs to be bound the display name will be parsed and the resulting moniker stored in its place. Until such parsing takes place, the link object will not participate in auto-link reconnections; thus, most callers will either want to themselves call MKParseDisplayName( ) or will want to let the link object do the parsing but run the link immediately after setting the display name in order to cause the parsing to happen.",{"@attributes":{"id":"p-0283","num":"0315"},"tables":{"@attributes":{"id":"TABLE-US-00065","num":"00065"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["lpszDisplayName","LPSTR","the display name of the new link source."]},{"entry":[{},{},"May not be NULL."]},{"entry":["return value","HRESULT","S_OK, MK_E_SYNTAX"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"This returns the display name of the source of the link using the most efficient means available.","The present implementation carries this out by simply asking the internal moniker for its display name. This is sometimes expensive, though very rarely (and never with any of the OLE-supplied monikers). Thus, clients for whom this is a time-critical operation should consider caching the display name themselves.",{"@attributes":{"id":"p-0286","num":"0318"},"tables":{"@attributes":{"id":"TABLE-US-00066","num":"00066"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["lplpszDisplayName","LPSTR*","the place to return the name of the"]},{"entry":[{},{},"link source. May not be NULL."]},{"entry":["return value","HRESULT","S_OK + any error returned from"]},{"entry":[{},{},"IMoniker::GetDisplayName( )."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"Causes the link to bind the moniker contained within itself. When the user double-clicks a link and the server must be located, this is the workhorse function which is invoked to cause the connection to happen, though normally this is invoked by being called internally by DoVerb( ). pbc is the bind context to use for the bind operation.","When binding a link, it may be the case that the current class of the link source is not the same as it was the previous time that the link tried to connect. Imagine, for example, a link to a Lotus spreadsheet object that the user subsequently converted (using the Change Type dialog) to an Excel sheet. grfLinkBind controls the behaviour of the binding operation in this scenario. It contains values taken from the enumeration OLELINKBIND:",{"@attributes":{"id":"p-0289","num":"0321"},"tables":{"@attributes":{"id":"TABLE-US-00067","num":"00067"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef enum tagOLELINKBIND {"]},{"entry":[{},"\u2003OLELINKBIND_EVENIFCLASSDIFF = 1,"]},{"entry":[{},"\u2003}OLELINKBIND;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"If OLELINKBIND_EVENIFCLASSDIFF is not provided, then this function will return OLE_E_CLASSDIFF if the class is different than the previous time that this link successfully bound. If OLELINKBIND_EVENIFCLASSDIFF is given, then the bind process will proceed even if the class has changed.","When OleRun( ) is invoked on an embedding which is in fact a link object, it conceptually just invokes this function as\n\n","If OleRun( ) returned OLE_E_CLASSDIFF, then the client will have to call BindToSource( ) directly.",{"@attributes":{"id":"p-0293","num":"0326"},"tables":{"@attributes":{"id":"TABLE-US-00068","num":"00068"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Argument","Type","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"grfLinkBind","DWORD","value from the enumeration"]},{"entry":[{},{},{},"OLELINKBIND."]},{"entry":[{},"pbc","IBindCtx*","the bind context to use for the bind"]},{"entry":[{},{},{},"operation. May be NULL."]},{"entry":[{},"return value","HRESULT","S_OK, OLE_E_CLASSDIFF,"]},{"entry":[{},{},{},"MK_E_NOOBJECT,"]},{"entry":[{},{},{},"MK_E_EXCEEDEDDEADLINE,"]},{"entry":[{},{},{},"MK_E_SYNTAX"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":[{},{}]},"This binds the link to its source only if said source is in fact presently running.",{"@attributes":{"id":"p-0295","num":"0328"},"tables":{"@attributes":{"id":"TABLE-US-00069","num":"00069"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Argument","Type","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"return value","HRESULT","S_OK, MK_E_SYNTAX, others"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":[{},{}]},"This function retrieves the object to which the link is currently connected, if any is present. In the event that no source is currently connected, then S_FALSE is returned by the function and NULL is returned through *ppunk.",{"@attributes":{"id":"p-0297","num":"0330"},"tables":{"@attributes":{"id":"TABLE-US-00070","num":"00070"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ppUnk","IUnknown*","the place to return the currently-connected"]},{"entry":[{},{},"source of this object. May not be NULL. In"]},{"entry":[{},{},"the event that no source is currently"]},{"entry":[{},{},"connected, NULL is returned."]},{"entry":["return value","HRESULT","S_OK, S_FALSE"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"If the link object is presently connected to its source, then break that connection.",{"@attributes":{"id":"p-0299","num":"0332"},"tables":{"@attributes":{"id":"TABLE-US-00071","num":"00071"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Argument","Type","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"return value","HRESULT","S_OK"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":[{},{}]},"Carry out the same functionality as is described in IOIeObject::Update( ), but in addition record any bound objects in the passed in bind context. IOIeObject::Update( ) on an object which also supports IOIeLink should just call IOIeLink::Update(NULL) on itself. Non-NULL uses of pbc allow complex binding scenarios to be optimized by callers.","The OLE-provided Link Object implementation of IOIeLink::Update( ) requires that the link be made running; that is, that the source moniker be bound. In the event that the source is unavailable, then the implementation of Update( ) is careful not to lose the presentations that it already has cached from the previous time it connected. That is, a failed connect attempt will not cause any presentations to be lost.",{"@attributes":{"id":"p-0302","num":"0335"},"tables":{"@attributes":{"id":"TABLE-US-00072","num":"00072"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pbc","IBindCtx*","the bind context to use for binding operations"]},{"entry":[{},{},"carried out during the update. May be"]},{"entry":[{},{},"NULL."]},{"entry":["return value","HRESULT","S_OK, . . ."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The implementation if IsUpToDateO in links is a bit tricky. The problem is two-fold:\n\n","The solutions to these problems are embodied in the OLE-provided link object implementation; however, it is instructive nevertheless that others understand how they are addressed. Consider that whenever a link object updates from its source, it stores the remote time (rtUpdate) beyond which the data in that update is known not to have changed; this is the time returned by GetTimeOfLastChange( ) on the source moniker. In addition to this time, the link object also stores the local time (ItChangeOfUpdate) at which it first obtained a particular value of rtUpdate. That is, when rtUpdate is revised as a result of an Update( ), if the new value is different than the old, then ItChangeOfUpdate is set to the current local time; if it is the same, then ItChangeOfUpdate is left alone. Finally, the link object stores the local time(ItKnownUpToDate) at which it last knew itself to be up to date. For auto-links, this time is updated as part of their save sequence. Manual links update this time only at Update( ) time. When IsUpToDate( ) is invoked, it retrieves GetTimeOfLastChange( ), the value indicated by rtTimeOfLastChange in the diagram. Given this structure, a link is deemed to be up to date if (approximately):\n\n","More completely, backwards movement of clocks needs to be considered, and a case of equal remote times is taken as out of date (per the problem indicated above) only if less than two seconds has elapsed on our local clock (that is, we assume that remote clocks have a precision of at least two seconds).","4.0 IRunningObjectTableInterface","In general when binding to an object we want to open it if it is currently passive, but if not, then we want to connect to the running instance. A link to a Lotus 123 for Windows spreadsheet, for example, when first bound to should open the spreadsheet, but a second bind should connect to the already-open copy. The key technical piece that supports this is the Running Object Table.","The Running Object Table is a globally accessible table on each workstation. It keeps track of the objects that are currently running on that workstation so that if an attempt is made to bind to one a connection to the currently running instance can be made instead of loading the object a second time. The table conceptually is a series of tuples, each of the form:\n\n","The first element is the moniker that if bound should connect to the running object. The second element is the object that is publicized as being available, the object that is running. In the process of blinding, monikers being bound with nothing to their left consult the pmkObjectName entries in the Running Object Table to see if the object that they (the moniker being bound) indicate is already running.","Access to the Running Object Table is obtained with the function GetRunningObjectTable( ). This returns an object with the interface IRunningObjectTable (note as described earlier, however, that moniker implementations should not use this API, but should instead access the Running Object Table from the bind context as they are passed).","As entries are placed into the Running Object Table, they are matched against the Alert Object Table to see if any auto-link reconnections need to be done.",{"@attributes":{"id":"p-0311","num":"0348"},"tables":{"@attributes":{"id":"TABLE-US-00073","num":"00073"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"interface IRunningObjectTable:IUnknown {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003virtual","HRESULT","Register(reserved, pUnkObject,"]},{"entry":[{},{},"\u2003pmkObjectName, pdwRegister) = 0;"]},{"entry":["\u2003virtual","HRESULT","Revoke(dwRegister) = 0;"]},{"entry":["\u2003virtual","HRESULT","IsRunning(pmkObjectName) = 0;"]},{"entry":["\u2003virtual","HRESULT","GetObject(pmkObjectName,"]},{"entry":[{},{},"ppunkObject) = 0;"]},{"entry":["\u2003virtual","HRESULT","NoteChangeTime(dwRegister,"]},{"entry":[{},{},"pfiletime) = 0;"]},{"entry":["\u2003virtual","HRESULT","GetTimeOfLastChange(pmkObjectName,"]},{"entry":[{},{},"pfiletime) = 0;"]},{"entry":["\u2003virtual","HRESULT","EnumRunning(ppenumMoniker) = 0;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"};"},{"entry":"SCODE \u2003Get Running Object Table(reserved, pprot);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":[{},{}]},"Return a pointer to the Running Object Table for the caller's context.",{"@attributes":{"id":"p-0313","num":"0350"},"tables":{"@attributes":{"id":"TABLE-US-00074","num":"00074"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["reserved","DWORD","reserved for future use; must be"]},{"entry":[{},{},"zero."]},{"entry":["pprot","IRunningObjectTable*","the place to return the running ob-"]},{"entry":[{},"*","ject table."]},{"entry":["return value","HRESULT","S_OK"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"Register the fact that the object pUnkObject has just entered the running state and that if the moniker pmkObjectName is bound to, then this object should be used as the result of the bind (with an appropriate QueryInterface( )).","The moniker pmkObjectName should be fully reduced before registration. See IMoniker::Reduce( ) for a more complete discussion. If an object goes by more than one fully reduced moniker, then it should register itself under all such monikers. Here, \u201cfully reduced\u201d means reduced to the state MKRREDUCE_THROUGUSER.","OLE compound document objects should announce themselves as running by calling this function as soon as all of the following are true:\n\n","Normally, if a link has ever been made to an object, then it should be assumed that the link to the object still might exist. The consumer of the link might be on a floppy disk somewhere, for example, which may later reappear. The exceptions are some rare situations where a link is created but almost immediately destroyed before the link source is saved.","The moniker with which the OLE object should register itself as running is its full moniker as described in IOIeObject::GetMoniker( ).","Registering a second object under the same moniker sets up a second independent registration, though MX_S_MONIKERALREADYREGISTERED is returned instead of S_OK. This is done without regard to the value ofpUnkObject in the second registration; thus, registering the exact same (pmkObjectName, pUnkObject) pair a second time will set up a second registration. It is not intended that multiple registration under the same moniker be a common occurrence, as which registration actually gets used in various situations is non-deterministic.","The arguments to this function are as follows:",{"@attributes":{"id":"p-0321","num":"0363"},"tables":{"@attributes":{"id":"TABLE-US-00075","num":"00075"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"182pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["reserved","DWORD","reserved for future use; must be zero."]},{"entry":["pUnkObject","IUnknown*","the object which has just entered the running state."]},{"entry":["pmkObjectName","IMoniker*","the moniker which would bind to the newly running object."]},{"entry":["pdwRegister","DWORD*","a place to return a value by which this registration can later be"]},{"entry":[{},{},"revoked. May not be NULL."]},{"entry":["return value","HRESULT","S_OK, MK_S_MONIKERALREADYREGISTERED,"]},{"entry":[{},{},"E_NOMEMORY"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"Undo the registration done in IRunningObjectTable::Register( ), presumably because the object is about to cease to be running. Revoking an object that is not registered as running returns the status code MK_S_NOT_RUNNING. Whenever any of the conditions that cause an object to register itself as running cease to be true, the object should revoke its registration(s). In particular, objects should be sure to extant registration of themselves from the Running Object Table as part of their release process; there is no means by which entries in the Running Object Table can be removed automatically by the system.",{"@attributes":{"id":"p-0323","num":"0365"},"tables":{"@attributes":{"id":"TABLE-US-00076","num":"00076"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["dwRegister","DWORD","a value previously returned from"]},{"entry":[{},{},"IRunningObjectTable::Register( )."]},{"entry":["return value","HRESULT","S_OK, MK_S_NOT_RUNNING."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"Inquire by looking up in this Running Object Table as to whether an object with this moniker is currently registered as running. Success or failure is indicated using the return codes S_OK or S_FALSE. The R.O.T. compares monikers by sending IsEqual( ) to the monikers already in the table with moniker on the right as an argument.",{"@attributes":{"id":"p-0325","num":"0367"},"tables":{"@attributes":{"id":"TABLE-US-00077","num":"00077"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pmkObjectName","IMoniker*","the moniker that we want to see is"]},{"entry":[{},{},"running"]},{"entry":["return value","HRESULT","S_OK, S_FALSE."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"If the object designated by pmkObject name is registered as actually running, then return the object so registered. The R.O.T. compares monikers by sending IsEqual( ) to the monikers already in the table with moniker on the right as an argument.","This is the function moniker implementations should use to test if they are already running (and get the pointer to the object if so).",{"@attributes":{"id":"p-0328","num":"0370"},"tables":{"@attributes":{"id":"TABLE-US-00078","num":"00078"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pmkObjectName","IMoniker*","the moniker in whom interest is"]},{"entry":[{},{},"being expressed."]},{"entry":["ppunkObject","IUnknown**","the place to return the pointer to the"]},{"entry":[{},{},"object. A returned value of NULL"]},{"entry":[{},{},"indicates that the object is not"]},{"entry":[{},{},"registered."]},{"entry":["return value","HERESULT","S_OK, MK_S_NOT_RUNNING"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"Make a note of the time that a particular object has changed in order that IMoniker::GetTimeOfLastChange( ) can report an appropriate change time. This time so registered is retrievable with IRunningObjectTable::GetTimeOfLastChange( ). Objects should call this as part of their data change notification process.",{"@attributes":{"id":"p-0330","num":"0372"},"tables":{"@attributes":{"id":"TABLE-US-00079","num":"00079"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["dwRegister","DWORD","the token previously returned from"]},{"entry":[{},{},"IRunningObijectTable::Register( )."]},{"entry":[{},{},"The moniker whose change time is"]},{"entry":[{},{},"noted is the one specified in"]},{"entry":[{},{},"pmkObjectName in that call."]},{"entry":["pfiletime","FILETIME*","on entry, the time at which the"]},{"entry":[{},{},"object has changed."]},{"entry":["return value","HRESULT","S_OK"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"Look up this moniker in the running object table and report the time of change recorded for it if same is present. The R.O.T. compares monikers by sending IsEqual( ) to the monikers already in the table with moniker on the right as an argument. Implementations of IMoniker::GetTimeOfLastChange( ), when invoked with pmkToLeft == NULL, will want to call this function as the first thing they do.",{"@attributes":{"id":"p-0332","num":"0374"},"tables":{"@attributes":{"id":"TABLE-US-00080","num":"00080"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pmkObjectName","IMoniker*","the moniker in which we are interested"]},{"entry":[{},{},"in the time of change."]},{"entry":["pfiletime","FILETIIME*","on exit, the place at which the time of"]},{"entry":[{},{},"change is returned."]},{"entry":["return value","HRESULT","S_OK, MK_S_NOT_RUNNING"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"Enumerates the objects currently registered as running. The returned enumerator is of type IEnumMoniker, which enumerates monikers.\n\n","The monikers which have been passed to IRunningObjectTable::Register( ) are enumerated.",{"@attributes":{"id":"p-0335","num":"0378"},"tables":{"@attributes":{"id":"TABLE-US-00081","num":"00081"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ppenumMoniker","IEnumMoniker**","the place at which to return"]},{"entry":[{},{},"the enumerator."]},{"entry":["return value","HRESULT","S_OK, E_OUTOFMEMORY"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},"IOIeContainer interface provides the ability to enumerate objects in a container. An extension, IOIeItemontainer, is used by Item Monikers in the process of binding; see the chapter on moniker for more information.",{"@attributes":{"id":"p-0337","num":"0380"},"tables":{"@attributes":{"id":"TABLE-US-00082","num":"00082"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"interface IoleContainer : IParseDisplayName {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003virtual","HRESULT","EnumObjects(grfFlags, ppenum) = 0;"]},{"entry":["\u2003virtual","HRESULT","LockContainer(fLock) = 0;"]},{"entry":"\u2003}"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"interface IoleItemContainer : IOleContainer {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003virtual","HRESULT","GetObject(lpszitem, dwSpeedNeeded, pbc,"]},{"entry":[{},{},"iid, ppvObject) = 0;"]},{"entry":["\u2003virtual","HRESULT","GetObjectStorage(lpszItem, pbc, iid,"]},{"entry":[{},{},"ppvStorage) = 0;"]},{"entry":["\u2003virtual","HRESULT","IsRunning (lpszitem) = 0;"]},{"entry":"\u2003};"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}},"br":[{},{}]},"Enumerate the objects contained in this container. grfFlags is a group of flags which control the enumeration and which are taken from the enumeration OLECONTF:",{"@attributes":{"id":"p-0339","num":"0382"},"tables":{"@attributes":{"id":"TABLE-US-00083","num":"00083"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef enum tagOLECONTF {"]},{"entry":[{},"\u2003OLECONTF_EMBEDDINGS = 1,"]},{"entry":[{},"\u2003OLECONTF_LINKS = 2"]},{"entry":[{},"\u2003OLECONTF_OTHERS = 4"]},{"entry":[{},"\u2003OLECONTF_ONLYUSER = 8"]},{"entry":[{},"\u2003OLECONTF_ONLYIFRUNNING = 16"]},{"entry":[{},"\u2003} OLECONTF;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"These flags have the following meanings:",{"@attributes":{"id":"p-0341","num":"0384"},"tables":{"@attributes":{"id":"TABLE-US-00084","num":"00084"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Value","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["OLECONTF_EMBEDDINGS","The OLE embedded objects in the"]},{"entry":[{},"container should be enumerated."]},{"entry":["OLECONTF_LINKS","The OLE linked objects in the"]},{"entry":[{},"container should be enumerated."]},{"entry":["OLECONTF_OTHER","Objects in the container other than"]},{"entry":[{},"OLE compound document objects"]},{"entry":[{},"should be enumerated. Unless this"]},{"entry":[{},"flag is given, \u201cpseudo-objects\u201d in"]},{"entry":[{},"the container will be omitted."]},{"entry":["OLECONTF_ONLYUSER","Not all of the objects in the container"]},{"entry":[{},"are to be enumerated, only the"]},{"entry":[{},"ones which the user is consciously"]},{"entry":[{},"aware of. Hidden named-ranges in"]},{"entry":[{},"Microsoft Excel, for example, would"]},{"entry":[{},"not be enumerated if this flag is"]},{"entry":[{},"given."]},{"entry":["OLECONTF_ONLYIFRUNNING","If this flag is specified, then only the"]},{"entry":[{},"objects which are currently running"]},{"entry":[{},"inside this container are returned."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The returned enumeration is of type IEnumUnknown:\n\n","The arguments to this type of function are as follows:",{"@attributes":{"id":"p-0344","num":"0388"},"tables":{"@attributes":{"id":"TABLE-US-00085","num":"00085"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["grfFlags","DWORD","flags from the enumeration"]},{"entry":[{},{},"OLECONTF."]},{"entry":["ppenum","IEnumCNTDOBJ*","the place at which the enumerator"]},{"entry":[{},{},"should be returned."]},{"entry":["return value","HRESULT","S_OK, E_FAIL"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"This call is made by embedded objects on their container. It is used to keep the container running in the absence of other reasons forit to remain running. This is important during a silent update of a link to an embedding. A call to LockContainer(TRUE) should be balanced with a call to LockContainer(FALSE).","The container should keep track of whether and how many calls to LockContainer(TRUE) have been made. When that number is non-zero, it should remain running. If the lock count goes to zero and there are no other reasons to remain running, the container should shutdown. User actions can override locks; for example, if the container is visible and the user closes the application while the lock count is non-zero, the container should close.","Normally, object applications need not concern themselves with calling LockContainer( ): the Handler calls LockContainer( ) as appropriate when the object transitions to and from the running state. The Handler causes the object to transition into the running state, and calls LockContainer(TRUE) when it does so. It calls LockContainer(FALSE) in response to the reception of OnClose( ) notifications from the server.",{"@attributes":{"id":"p-0348","num":"0392"},"tables":{"@attributes":{"id":"TABLE-US-00086","num":"00086"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["fLock","BOOL","Indicates whether to lock (TRUE)"]},{"entry":[{},{},"or unlock (FALSE)."]},{"entry":["return value","HRESULT","S_OK, E_FAIL"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"IOIeItemContainer::GetObject( ) should first check to see of the given item designates an embedded object. If so, then it should load and run the object, then return it. If not, then it should check to see of the item designates a local object within the container. This latter case is just like OLESERVERDOC::GetObject( ) in OLE .","dwSpeedNeeded is an indication of how willing the caller is to wait to get to the object. This value is set by the implementation of Item Moniker; the value it uses is derived from the dwTickCountDeadline parameter in the Bind Context that it receives: dwSpeedNeeded is one of the following values:",{"@attributes":{"id":"p-0351","num":"0395"},"tables":{"@attributes":{"id":"TABLE-US-00087","num":"00087"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["typedef enum tagBINDSPEED {",{}]},{"entry":["\u2003BINDSPEED_INDEFINITE = 1,","\/\/the caller is willing to wait"]},{"entry":[{},"indefinitely"]},{"entry":["\u2003BINDSPEED_MODERATE = 2,","\/\/the caller is willing to wait a"]},{"entry":[{},"moderate amount of time"]},{"entry":["\u2003BINDSPEED_IMMEDIATE = 3,","\/\/the caller is willing to wait only"]},{"entry":[{},"a very short time"]},{"entry":"\u2003}BINDSPEED;"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"If BINDSPEED_IMMEDIATE is specified, then the object should be returned only if it is already running or if it is a pseudo-object (an object internal to the item container, such as a cell-range in a spreadsheet or a character-range in a word processor); otherwise, MK_E_EXCEEDEDDEADLINE should be returned. BINDSPEED_MODERATE would include those things indicated by BINDSPEED_IMMEDIATE, plus, perhaps, those objects which are always running when loaded: in this case, load (not load & run) the designated object, ask if it is running, and return it if so; otherwise, fail with MK_E_EXCEEDEDDEADLINE as before. BINDSPEED_INDEFINITE indicates that time is of no concern to the caller.","The actual bind context parameter is also here passed in pbc for the use of more sophisticated containers. Less sophisticated containers can simply ignore this and look at dwSpeedNeeded instead. In effect, what the implementation of Item Moniker does is convert the deadline in the bind context into an appropriate dwSpeedNeeded, in the hope that the latter is easier to take a decision on for most containers.",{"@attributes":{"id":"p-0354","num":"0398"},"tables":{"@attributes":{"id":"TABLE-US-00088","num":"00088"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["lpszItem","LPSTR","the item in this container that should be"]},{"entry":[{},{},"bound to."]},{"entry":["dwSpeedNeeded","DWORD","a value from the enumeration BIND-"]},{"entry":[{},{},"SPEED. See above."]},{"entry":["pbc","IBindCtx*","the actual deadline parameter involved"]},{"entry":[{},{},"in this binding operation. For the use"]},{"entry":[{},{},"of more sophisticated containers. Most"]},{"entry":[{},{},"can ignore this, and instead use"]},{"entry":[{},{},"dwSpeedNeeded."]},{"entry":["riid","REFIID","the interface with which a connection to"]},{"entry":[{},{},"that object should be made."]},{"entry":["ppvObject","void**","the bound-to object is returned here."]},{"entry":["return value","HRESULT","S_OK, MK_E"]},{"entry":[{},{},"EXCEEDDEDDEADLINE,"]},{"entry":[{},{},"MK_E_NOOBJECT, E"]},{"entry":[{},{},"NOINTERFACE, E"]},{"entry":[{},{},"OUTOFMEMORY"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"If lpszItem designates an item in this container that has an independently identifiable piece of storage (such as does an embedded object), then return access to that storage using the indicated interface.","pbc is the bind context as received by the Item Moniker BindToStorage( ) call. Most container implementations can simply ignore this value; it is passed for the benefit for more sophisticated containers.",{"@attributes":{"id":"p-0357","num":"0401"},"tables":{"@attributes":{"id":"TABLE-US-00089","num":"00089"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["lpszItem","LPSTR","the item access to whose storage is"]},{"entry":[{},{},"being requested."]},{"entry":["pbc","IBindCtx*","as in IoleItemContainer::GetObject( )."]},{"entry":[{},{},"Can be ignored by most containers."]},{"entry":["riid","REFIID","the interface by which the caller wishes"]},{"entry":[{},{},"to access that storage. Often IID"]},{"entry":[{},{},"IStorage or IID_IStream are used."]},{"entry":["ppvStorage","void**","the place to return the access to the"]},{"entry":[{},{},"storage"]},{"entry":["return value","HRESULT","S_OK, MK_E"]},{"entry":[{},{},"EXCEEDEDDEADLINE, MK_E"]},{"entry":[{},{},"NOOBJECT, E_OUTOFMEMORY,"]},{"entry":[{},{},"E_NOINTERFACE, MK_E"]},{"entry":[{},{},"NOSTORAGE"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"Answer whether the given item in this item container is in fact running or not. See IMoniker::IsRunning( ) for a sketch of how this function is used in Item Monikers.",{"@attributes":{"id":"p-0359","num":"0403"},"tables":{"@attributes":{"id":"TABLE-US-00090","num":"00090"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["lpszItem","LPSTR","the item access to whose running status"]},{"entry":[{},{},"is being requested."]},{"entry":["return value","HRESULT","S_OK, S_FALSE, MK_E_NOOBJECT"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},"An object is in the running state when its associated server executable, if any, is running and connected to the object. Certain operations can only be done while the object is in this state. For example, as was described earlier, IOIeObject::InitFromData( ) is such a function. Function invocations that fail merely because the object is not running in general return the status code E_NOTRUNNING. In response to this error, a caller should put the object into the running state with OleRun( ) then try the operation again. Since it is harmless to OleRun( ) an object that is already running, containers may wish simply to OleRun( ) the object before attempting any operation which may fail in this manner.","OleRun","HRESULT OleRun(pUnknown)","Cause the object to enter the running state if it is not presently running. If the object is not running, then this is often a very expensive operation, on the order of many seconds, since an application needs to be launched. If the object is already running, then this function has no effect.","This function, when invoked on an OLE link, may return the result OLE_E_CLASSDIFF, as will happen in the situation, say where a link has been made to an object which has been Convert To . . . 'd while the link has been passive. If the client wishes to go ahead anyway, he should invoke IOleLink::BindToSource ); see that function for more details.",{"@attributes":{"id":"p-0363","num":"0407"},"tables":{"@attributes":{"id":"TABLE-US-00091","num":"00091"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pUnknown","IUnknown*","the embedded object which should be"]},{"entry":[{},{},"made running."]},{"entry":["return value","HRESULT","S_OK, OLE_E_CLASSDIFF."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"This answers whether the object is currently in the running state or not.",{"@attributes":{"id":"p-0365","num":"0409"},"tables":{"@attributes":{"id":"TABLE-US-00092","num":"00092"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Argument","Type","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"pObject","IOleObject*","the object to be inquired of."]},{"entry":[{},"return value","BOOL","true or false"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"IDataObject interface provides the ability to pass data to and from an object using SetData( ) and GetData( ). The data that is passed is arranged according to a particular format denoted by a clipboard format. Optionally, the data is tagged as being composed or laid-out according to the characteristics of a particular target device. The data being transferred can be conveyed by one of several different media.","The set of formats, etc., that can legally be passed to and from an object can be enumerated with EnumFormatEtc( ). In addition, an advisory connection can be made to the data object whereby it will notify a caller when data it contains changes.",{"@attributes":{"id":"p-0368","num":"0412"},"tables":{"@attributes":{"id":"TABLE-US-00093","num":"00093"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"interface IDataObject : IUnknown {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003virtual","HRESULT","GetData(pformatetc, pmedium) = 0;"]},{"entry":["\u2003virtual","HRESULT","GetDataHere(pformatetc, pmedium) = 0;"]},{"entry":["\u2003virtual","HRESULT","QueryGetData(pformatetc) = 0;"]},{"entry":["\u2003virtual","HRESULT","GetCanonicalFormatEtc(pformatetcIn,"]},{"entry":[{},{},"pformatEtcOut) = 0;"]},{"entry":["\u2003virtual","HRESULT","SetData(pformatetc, pmedium,"]},{"entry":[{},{},"fRelease) = 0;"]},{"entry":["\u2003virtual","HRESULT","EnumFormatEtc(wDirection,"]},{"entry":[{},{},"ppenumFormatEtc) = 0;"]},{"entry":["\u2003virtual","HRESULT","DAdvise(pformatetc, grfAdvf,"]},{"entry":[{},{},"pAdvSink, pdwConnection) = 0;"]},{"entry":["\u2003virtual","HRESULT","DUnadvise(dwConnection) = 0;"]},{"entry":["\u2003virtual","HRESULT","EnumDAdvise(ppenumAdvise) = 0;"]},{"entry":"\u2003};"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}},"br":[{},{}]},"Retrieve data for a certain aspect of the object in a certain clipboard format formatted for a certain target device conveyed on a certain storage medium. The information as to what is to be retrieved and how it is to be passed is indicated in the parameter pformatetc.","pformatetc\u2192tymed may indicate that the caller is willing to receive the data on one of several media. The callee decides if it can support one of the media requested by the caller. If it cannot, then it returns DATA_E_FORMATETC. If it can, then it returns the actual data on a medium passed back through the pmedium parameter. Pmedium is conceptually an out parameter: the STGMEDIUM structure is allocated by the caller, but filled by the callee.","The callee gets to decide who is responsible for releasing the resources maintained on behalf of the medium: itself, or the caller. The callee indicates its decision through the value it returns through function pointer pmedium\u2192punkForRelease( ), as was described above. The caller always frees the returned medium by simply calling ReleaseStgMedium( ) (then, of course, freeing the STGMEDIUM structure itself).","If it is not presently possible to transfer ownership of a root-level IStorage from process to another, though this will be rectified in later releases. Therefore, at present, use of GetData( ) with TYMED_ISTORAGE requires that the callee retain ownership of the data, that is, that it use a non-NULL pUnkForRelease. Alternatively, callers are encouraged to instead use GetDataHere( ), as in general it is more efficient.",{"@attributes":{"id":"p-0373","num":"0417"},"tables":{"@attributes":{"id":"TABLE-US-00094","num":"00094"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pformatetc","FORMATETC*","the format, etc., in which the caller"]},{"entry":[{},{},"would like to obtain the returned"]},{"entry":[{},{},"data."]},{"entry":["pmedium","STGMEDIUM*","a place in which the medium containing"]},{"entry":[{},{},"the returned data is communicated."]},{"entry":["return value","HRESULT","S_OK, DATA_E"]},{"entry":[{},{},"FORMATETC."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"Send data in a specified format, etc., to this object. As in DataObject::GetData( ), pformatetc indicates the format, aspect, etc., on which the data is being passed. The actual data is passed through the caller-allocated pmedium parameter.","The caller decides who, itself or the callee, is responsible for releasing the resources allocated on behalf of the medium. It indicates its decision in the fRelease parameter. If false, then the caller retains ownership, and the callee may only use the storage medium for the duration of the call. If true, then the callee takes ownership, and should itself free the medium when it is done with it. The callee should not consider itself as having taken ownership of the data unless it successfully consumes it (i.e.: does not return DATA_E_FORMATETC or some other error). If it does take ownership, the callee frees the medium by calling ReleaseStg-Medium( ); see that function for a discussion of how the medium is actually freed.",{"@attributes":{"id":"p-0376","num":"0420"},"tables":{"@attributes":{"id":"TABLE-US-00095","num":"00095"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pformatetc","formatetc*","the format, etc., in which to interpret"]},{"entry":[{},{},"the data contained in the medium."]},{"entry":["pmedium","STGMEDIUM*","the actual storage medium (an in-"]},{"entry":[{},{},"parameter only)."]},{"entry":["fRelease","BOOL","indicates who has ownership of the"]},{"entry":[{},{},"medium after the call completes."]},{"entry":["return value","HRESULT","S_OK, DATA_E_FORMATETC."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},"IPersistStream is an interface that support the persistence objects that are cheap enough to use a simple serialize\/deserialize pacification model. OLE 2 compound-document objects (embeddings and links) specifically do not use this interface; see IPersistStorage instead. Monikers are an example of objects that do use this stream-based persistence model.","Unlike the IStorage instances used in IPersistStorage, the IStream instances used in this interface are valid only for the duration of the call in which they are passed; the object may not retain hold of them after the call completes.","Notice that this interface derives from IPersist.",{"@attributes":{"id":"p-0380","num":"0424"},"tables":{"@attributes":{"id":"TABLE-US-00096","num":"00096"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\u2003interface IPersistStream:IPersist {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003virtual","HRESULT","IsDirty( ) = 0;"]},{"entry":[{},"\u2003virtual","HRESULT","Load(pstm) = 0;"]},{"entry":[{},"\u2003virtual","HRESULT","Save(pstm, fClearDirty) = 0;"]},{"entry":[{},"\u2003virtual","HRESULT","GetSizeMax(pcbSize) = 0;"]},{"entry":[{},"\u2003};"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"HRESULT","ReadClassStm(pstm, pcid);"]},{"entry":[{},"HRESULT","WriteClassStm(pstm, clsid);"]},{"entry":[{},"HRESULT","OleSaveToStream(pPersistStm, pstm);"]},{"entry":[{},"HRESULT","OleLoadFromStream(pstm, iidInterface, ppvObj);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"br":[{},{}]},"Initialize the object from serialized state that it previously stored with IPersistStream::Save( ).","On entry, the stream is logically positioned just as it was in the call to Save( ). The implementation of Load( ) is permitted to both read from and seek about in the stream; however, it may not write to it. On exit, the stream should be left in the same position as it was on exit from Save( ), which is just past the end of the data.",{"@attributes":{"id":"p-0383","num":"0427"},"tables":{"@attributes":{"id":"TABLE-US-00097","num":"00097"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pstm","IStream *","the stream from which the object should load"]},{"entry":[{},{},"itself."]},{"entry":["return value","HRESULT","S_OK, E_FAIL, E_NOMEMORY"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"Save the state of the object to the indicated stream in such a way as it can be retrieved later with IPersistStream:Load( ). The object specifically does not write its own class identifier to the stream; this is done by the caller; this permits the caller in appropriate situations to more efficiently store homogeneous collections of objects. If fClearDirty is true, then the internal dirty flag is cleared as a result of this call.","On entry, the stream is positioned at the part of the stream at which the object should write its data; the object can immediately issue IStream::Write( ) calls. The object is specifically allowed to seek about in the stream should it choose to do so, it may also read back pieces of the stream that it has written; however, the object should not seek the stream before the position at which it was on function entry. On function exit, the stream should be positioned immediately past all the persistent data of the object.","The error STG_E_MEDIUMFULL is to be returned by this if pstm\u2192Write( ) call returns STG_E_MEDIUM FULL. This function may also return the error STG_E_CANTSAVE if for some reason the object is not currently in a state where it is serializable. Such a situation might arise if the object contains other objects which may or may not themselves be serializable. On error return, the position of the seek pointer is undefined.",{"@attributes":{"id":"p-0387","num":"0431"},"tables":{"@attributes":{"id":"TABLE-US-00098","num":"00098"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pstm","IStream *","the stream into which the object should be"]},{"entry":[{},{},"stored."]},{"entry":["fClearDirty","BOOL","whether the internal dirty flag should be"]},{"entry":[{},{},"cleared as a result of the save."]},{"entry":["return value","HRESULT","S_OK, STG_E_MEDIUMFULL,"]},{"entry":[{},{},"STG_E_CANTSAVE"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"Answer an upper bound as to the size of stream that would be required if Save( ) were called on this object at this instant in time. This value can be used by callers to set buffer size for immediately subsequent Save( ) calls. This value should be a conservative estimate of the size required, since the caller of Save( ) may choose to provide a non-growable buffer.",{"@attributes":{"id":"p-0389","num":"0433"},"tables":{"@attributes":{"id":"TABLE-US-00099","num":"00099"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pcbSize","LARGE_INTEGER*","the place to return the size hint."]},{"entry":["return value","HRESULT","S_OK"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"Answer whether the object is dirty; i.e., whether it has changed in such a way that a Save( ) is required in order to avoid information loss. This flag is cleared in the implementation of IPersistStream::Save( ).",{"@attributes":{"id":"p-0391","num":"0435"},"tables":{"@attributes":{"id":"TABLE-US-00100","num":"00100"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Argument","Type","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"return value","HRESULT","S_OK, S_FALSE"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":[{},{}]},"Read a CLSID from the stream that was previously written with WriteClassStm( ).",{"@attributes":{"id":"p-0393","num":"0437"},"tables":{"@attributes":{"id":"TABLE-US-00101","num":"00101"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pstm","IStream *","the stream from which the CLSID is to be"]},{"entry":[{},{},"read."]},{"entry":["pcid","CLSID *","the place at which the CLSID is to be"]},{"entry":[{},{},"returned."]},{"entry":["return value","HRESULT","S_OK, S_FALSE if end-of-stream hit"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"Write the indicated class identifier to the stream in such a way as it can be reconstituted with ReadClassStm( ).",{"@attributes":{"id":"p-0395","num":"0439"},"tables":{"@attributes":{"id":"TABLE-US-00102","num":"00102"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pstm","IStream *","the stream into which the CLSID is to be"]},{"entry":[{},{},"written."]},{"entry":["clsid","REFCLSID","the CLSID to write to the stream."]},{"entry":["return value","HRESULT","S_OK, STG_E_MEDIUMFULL"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"This helper function simplifies saving an IPersistStream object. It first asks the object for its class with IPersistStream::GetClassID( ), then writes it to the stream with WriteClassStm( ). It then asks the object to save itself to the stream with\n\n","Note that this clears the dirty flag in the object.","pPersistStm may legally be NULL. This has the effect of simply writing CLSID_NULL to the stream. See also OleLoadFromStream( ).",{"@attributes":{"id":"p-0399","num":"0444"},"tables":{"@attributes":{"id":"TABLE-US-00103","num":"00103"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pPersistStm","IpersistStream*","the object which is to be saved to the"]},{"entry":[{},{},"stream, preceded by its serialized class id."]},{"entry":["pstm","Istream *","the stream in which the object is to be"]},{"entry":[{},{},"serialized."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"This helper function simplifies loading an IPersistStream-supporting object from the stream in the common case where the class id of the object immediately precedes the data of the object in the stream. As usual, the caller indicates the interface by which he wishes to talk to the object, and a pointer to such an interface is returned through a void** parameter.","Calling this function on a stream with a class id of CLSID_NULL causes S_FALSE to be returned from this function and NULL to be returned through ppvObj.",{"@attributes":{"id":"p-0402","num":"0447"},"tables":{"@attributes":{"id":"TABLE-US-00104","num":"00104"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pstm","IStream *","the stream from which the object is to be"]},{"entry":[{},{},"loaded."]},{"entry":["iidInterface","REFIID","the interface by which the caller wishes to"]},{"entry":[{},{},"talk to the object."]},{"entry":["ppvObj","void **","the place to return the newly-created object."]},{"entry":["return value","HRESULT","S_OK, S_FALSE, E_OUTOFMEMORY"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},"IPersistFile interface is an interface which permits the loading and saving of documents which live in actual disk files (as opposed to objects which live in IStorage instances). The key point here is that the application itself is responsible for opening the file, since, in general, the detailed semantics about how to open an application vary from application to application. Notice that this interface derives from IPersist.",{"@attributes":{"id":"p-0404","num":"0449"},"tables":{"@attributes":{"id":"TABLE-US-00105","num":"00105"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"interface IPersistFile : IPersist {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003virtual","HRESULT","IsDirty( ) = 0;"]},{"entry":["\u2003virtual","HRESULT","Load(lpszFileName, grfMode) = 0;"]},{"entry":["\u2003virtual","HRESULT","Save(lpszFileName, fRemember) = 0;"]},{"entry":["\u2003virtual","HRESULT","SaveCompleted(lpszFileNameSaved) = 0;"]},{"entry":["\u2003virtual","HRESULT","GetCurFile(lplpszFileName) = 0;"]},{"entry":"\u2003};"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["HRESULT","GetClassFile(lpszFileName, pcid);"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":[{},{}]},"Load the document that is contained in the given file name. The file name will not be a relative path, always an absolute one. This is purely an initialization frmnction; the document is not to be shown to the user at this time. This function is called by the implementation of BindToObject( ) in file monikers.",{"@attributes":{"id":"p-0406","num":"0451"},"tables":{"@attributes":{"id":"TABLE-US-00106","num":"00106"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["lpszFileName","LPSTR","the absolute path name of the file to open."]},{"entry":["grfMode","DWORD","the access mode with which the caller"]},{"entry":[{},{},"intends to use the file. Values taken"]},{"entry":[{},{},"from the STGM enumeration. These only"]},{"entry":[{},{},"express the intent that the caller has"]},{"entry":[{},{},"in opening the file; the application may"]},{"entry":[{},{},"add more restrictive permissions as"]},{"entry":[{},{},"necessary. A value of zero for this"]},{"entry":[{},{},"parameter is legal; the object should"]},{"entry":[{},{},"interpret the request with the usual"]},{"entry":[{},{},"defaults as if the user had opened"]},{"entry":[{},{},"the file."]},{"entry":["return value","HRESULT","S_OK, E_NOMEMORY, any"]},{"entry":[{},{},"STG_E_*value, E_FAIL"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"Save (a copy of) the object to the indicated file name. This function is not called by the OLE libraries, but some clients of objects will find it useful for pro grammatically manipulating documents.","If non-NULL, the lpszFileName indicates the full path name of the destination for the save. If the object currently has an associated disk file, then lpszFileName may legally be NULL, indicating that a simple \u201cFile\/Save\u201d is requested to now-current file name. Whether the object currently has an associated disk file can be determined with IPersist File::GetCurFile( ).","If lpszFileName is non-NULL, then fRemember distinguishes whether a \u201cSave As . . . \u201d or a \u201cSave a Copy As . . . \u201d is being asked for. True indicates that lpszFileName should become the working copy of the document (\u201cSave As . . . \u201d); false indicates that after the function the working copy should be whatever it was before the function (\u201cSave a Copy As . . . \u201d).","In the case that the file saved to is on exit the now-current file of the document, then the internal dirty flag maintained by this object should be cleared as a result of this call. Also in this case, the caller is responsible for later calling IPersistFile::SaveCompleted( ) when it is done with the data found in the file.","In the case that the file saved to is on exit the now-current file of the document and this new file is different than the original file of the document, then the object should send a \u201crename\u201d notification to any extant advisory connections (see IAdviseSink::OnRename( )).",{"@attributes":{"id":"p-0412","num":"0457"},"tables":{"@attributes":{"id":"TABLE-US-00107","num":"00107"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["lpsFileName","LPSTR","the file to which the document should be"]},{"entry":[{},{},"saved. May sometimes be NULL; see above."]},{"entry":["fRemember","BOOL","valid only if lpszFileName is non-NULL."]},{"entry":[{},{},"Determines to which disk file the"]},{"entry":[{},{},"document is to be logically associated"]},{"entry":[{},{},"after the call completes."]},{"entry":["return value","HRESULT","S_OK, STG_E_*values, E_FAIL"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"In the case that the file saved to in IPersistFile::Save( ) is on exit from that function the now-current file of the document, the IPersistFile::SaveCompleted( ) should be called when the caller of Save( ) is done doing whatever it is that it needs to do with the contents of the file. In the interim, the IPersistFile object should not change the contents of the file. When the object receives SaveCompleted, it should send IAdviseSink::OnSave( ) notifications to any extant advisory connections.",{"@attributes":{"id":"p-0414","num":"0459"},"tables":{"@attributes":{"id":"TABLE-US-00108","num":"00108"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["lpszFileNameSaved","LPSTR","the file name to which a Save( )"]},{"entry":[{},{},"was previously done. This"]},{"entry":[{},{},"argument is passed mainly as a"]},{"entry":[{},{},"convenience to the callee."]},{"entry":["Return value","HRESULT","S_OK"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"This call returns one of two things, depending on whether the document has a currently-associated file or not. If it has such a file, then the absolute path name of that file is returned, and S_OK is the function return value. If it has no such file, then the file name prompt that would be used in a As . . . File\/Save dialog is returned (just the default prompt for the file name, exclusive of any directory path), and S_FALSE is returned from the function.",{"@attributes":{"id":"p-0416","num":"0461"},"tables":{"@attributes":{"id":"TABLE-US-00109","num":"00109"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["lplpszFileName","LPSTR *","the place to return the current path"]},{"entry":[{},{},"name or the default save prompt of the"]},{"entry":[{},{},"document, as appropriate for the current"]},{"entry":[{},{},"object state."]},{"entry":["return value","HRESULT","S_OK indicates that the return value is"]},{"entry":[{},{},"a path name; S_FALSE"]},{"entry":[{},{},"indicates it is the save prompt."]},{"entry":[{},{},"E_OUTOFMEMORY,"]},{"entry":[{},{},"E_FAIL"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"Answer whether a save is required in order to avoid information loss resulting from a change in the object that occurred after the last Save(L) to the object's home file. This flag is conditionally cleared in IPersistFile::Save( ).",{"@attributes":{"id":"p-0418","num":"0463"},"tables":{"@attributes":{"id":"TABLE-US-00110","num":"00110"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Argument","Type","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"return value","HRESULT","S_OK, S_FALSE"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"In the Component Object Model, clients communicate with objects solely through the use of vtable-based interface instances. The state of the object is manipulated by invoking functions on those interfaces. For each interface method, the object provides an implementation which does the appropriate manipulation of the object internals.","The underlying goal of interface remoting is to provide infrastructure and mechanisms such that the client and the server objects can in fact be in different processes. Thus, when the client makes a call on an interface of the object, a process transition must be made to the server process, the work carried out, and a return process transition made back to the client process.","A significant subgoal is that this infrastructure be transparent: it must not be the case that either client or object is necessarily aware that the other party is in fact in a different process; the glue that makes this happen must be automatically stuck in the loop at the right time.","The crux of the problem to be addressed in interface remoting can thus be summarized as follows:\n\n","We state the problem in this way so as to avoid for the moment the issue of how an initial connection is made between the client and the server process; we will return to that later.","Let's look at an example. Suppose we have an object in a server process which supports an interface IFoo, and that interface of the object (and IUnknown) has sometime in the past been remoted to a client process through some means not here specified. In the client process, there is an object proxy which supports the exact same interfaces as does the original server object, but whose implementations of methods in those interfaces are special, in that they forward calls they receive on to calls on the real method implementations back in the server object. We say that the method implementations in the object proxy marshal the data, which is then conveyed to the server process, where it is unmarshalled. That is, \u201cmarshalling\u201d refers to the packaging up of method arguments for transmission to a remote process; \u201cunmarshalling\u201d refers to the unpackaging of this data at the receiving end. Notice that in a given call, the method arguments are marshalled and unmarshalled in one direction, while the return values are marshalled and unmarshalled in the other direction.","For concreteness, let us suppose that the IFoo interface is defined as follows:\n\n","If in the client process pFoo\u2192ReturnABar( ) is invoked, then the object proxy will forward this call on to the IFoo::ReturnABar( ) method in the server object, which will do whatever this method is supposed to do in order to come up with some appropriate IBar*. The server object is then required to return this IBar* back to the client process. The act of doing this will end up creating a second connection between the two processes.","It is the procedure by which this second connection is established which is the subject of our discussion here. This process involves two steps:","1. On the server side, the IBar* is packaged or marshalled into a data packet.","2. The data packet is conveyed by some means to the client process, where the data it contains is unmarshalled to create the new object proxy.","The process begins with the code doing the marshalling of the returned IBar*. This code has in hand a pointer to an interface that it knows in fact to be an IBar*. The first step in marshalling involves finding out whether the object of which this is an interface in fact supports Custom Marshalling. Custom marshalling is a mechanism that permits an object to be in control of creation of remote object proxies to itself. In certain situations, Custom Marshalling can be used to create a more efficient object proxy than would otherwise be the case. Use of Custom Marshalling is completely optional on the object's part; if the object chooses not to support Custom Marshalling, then Standard Marshalling is used to marshal the IBar*. Standard marshalling uses a system-provided object proxy implementation in the client process. This standard object proxy is a generic piece of code; it can be used as the object proxy for any interface on any object. However, the act of marshalling (and unmarshalling) method arguments and return values is inherently interface-specific, since it is highily sensitive to the semantics of the particular methods in question. To accommodate this, the standard object proxy dynamically loads in interface-specific pieces of code as needed in order to do the marshalling.","Let's examine how Custom Marshalling works.","Architecture of Custom Marshalling","Imagine that we are presently in a piece of code whose job it is to marshal an interface pointer that it has in hand. For clarity, in what follows we'll refer to this piece of code as the \u201coriginal marshalling stub.\u201d The general case is that the original marshalling stub does not statically know the particular interface identifier (IID) to which the pointer conforms; the IID may be passed to this code as a second parameter. This is a common paradigm in OLE2. Examples include:","IUnknown::QueryInterface(REFIID riid, void** ppvObject);","IOleltemContainer::GetObject( . . . , REFIID riid, void** ppvObject);","IClassFactory::CreateInstance( . . . , RIEFIID riid, void** ppvNewlyCreatedObject);","For the moment, let us assume the slightly less general case where the marshalling stub in fact does know a little bit about the IID: in particular, let us assume that it knows that the interface in fact derives from IUnknown (we'll discuss later the situation in which this is not true).","To find out whether the object to which it has an interface supports Custom Marshalling, the original marshalling stub simply does a QueryInterface( ) for the interface IMarshal. That is, an object signifies that it wishes to do Custom Marshalling simply by implementing the IMarshal interface. IMarshal is defined as follows:",{"@attributes":{"id":"p-0435","num":"0484"},"tables":{"@attributes":{"id":"TABLE-US-00111","num":"00111"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"interfaceIMarshal:IUnknown {"},{"entry":"\u2003virtual HRESULT GetUnmarshalClass(iid, pvInterface, dwDestContext,"},{"entry":"\u2003pvDestContext,"},{"entry":"\u2003\u2003mshlflags, pclsid) = 0;"},{"entry":"\u2003virtual HRESULT GetMarshalSizeMax(iid, pvInterface,"},{"entry":"\u2003dwDestContext, pvDestContext,"},{"entry":"\u2003\u2003mshlflags, pcb) = 0;"},{"entry":"\u2003virtual HRESULT MarshalInterface(pstm, iid, pvInterface,"},{"entry":"\u2003dwDestContext,"},{"entry":"\u2003\u2003pvDestContext, mshlflags) = 0;"},{"entry":"\u2003virtual HRESULT UnmarshallInterface(pstm, iid, ppvInterface) = 0;"},{"entry":"\u2003virtual HRESULT DisconnectObject(dwReserved) = 0;"},{"entry":"\u2003virtual HRESULT ReleaseMarshalData(pstm) = 0;"},{"entry":"\u2003};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The idea is that if the object says \u201cYes, I do want to do custom Marshalling\u201d that the original marshalling stub will use this interface in order to carry out the task. The sequence of steps that carry this out is:","1. Using GetUnmarshalClass( ), the original marshalling stub asks the object which kind of (i.e.: which class of) proxy object it would like to have created on its behalf in the client process.","2. (optional) Using GetMarshalSizeMax( ), the stub asks the object how big of a marshalling packet it will need. The object will return an upper bound on the amount of space it will need.","3. The marshalling stub allocates a marshalling packet of appropriate size, then creates an IStream* which points into the buffer. Unless in the previous step the object gave an upper bound on the space needed, the IStream* must be able to grow its underlying buffer dynamically as IStream::Write( ) calls are made.","4. The original marshalling stub asks the object to marshal its data using MarshalInterface( ).","We will discuss the methods of this interface in detail in a moment.","At this point, the contents of the memory buffer pointed to by the IStream* together with the class tag returned in step (1) comprises all the information necessary in order to be able to create the proxy object in the client process. It is the nature of remoting and marshalling that \u201coriginal marshalling stubs\u201d such as we have been discussing know how to communicate with the client process; recall that we are assuming that an initial connection between the two processes has already been established. The marshalling stub now communicates to the client process, by whatever means is appropriate, the class tag and the contents of the memory that contains the marshalled interface pointer. In the client process, the proxy object is created as an instance of the indicated class using the standard Component Object Model instance creation paradigm. IMarshal is used as the initialization interface; the initialization method is IMarshal::UNmarshalInterface( ). The unmarshalling process looks something like the following:",{"@attributes":{"id":"p-0443","num":"0492"},"tables":{"@attributes":{"id":"TABLE-US-00112","num":"00112"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"void ExampleUnmarshal(CLSID& clsidProxyObject, IStream* pstm, IID&"},{"entry":"\u2003iidOriginallyMarshalled void** ppvReturn)"},{"entry":"{"},{"entry":"\u2003IClassFactory* pcf;"},{"entry":"\u2003IMarshal* pmsh;"},{"entry":"\u2003CoGetClassObject(clsidProxyObject, CLSCTX_INPROC_HANDLER,"},{"entry":"\u2003NULL,"},{"entry":"\u2003\u2003IID_IClassFactory, (void**)&pcf);"},{"entry":"\u2003pcf->CreateInstance(NULL, IID_IMarshal, (void**)pmsh);"},{"entry":"\u2003pmsh->UnmarshalInterface(pstm, iidOriginallyMarshalled, ppvReturn);"},{"entry":"\u2003pmsh->Release( );"},{"entry":"\u2003pcf->Release( );"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"There are three important reasons why an object may choose to do Custom Marshalling. First, objects which already are proxy objects can use Custom Marshalling to avoid creating proxies to proxies; new proxies are instead short-circuited back to the original server. This is both an important efficiency and an important robustness consideration. Second, object implementations whose whole state is kept in shared memory can often be remoted by creating an object in the client that talks directly to the shared memory rather than back to the original object. This can be a significant performance improvement, since access to the remoted object does not result in context switches. The Compound File implementations of IStorage and IStream are important examples of this use of Custom Marshalling. Third, some objects are of the nature that once they have been created, they are immutable: their internal state does not subsequently change. Many monikers are an example of such objects. These sorts of objects can be efficiently remoted by making independent copies of themselves in client processes. Custom marshalling is the mechanism by which they can do that, yet have no other party be the wiser for it. However, Custom Marshalling may not be used by OLE2 embeddings; it is intended primarily for other situations such as Monikers, Compound Files, etc. More correctly, Custom Marshalling may not be used by OLE2 embeddings which are not completely implemented in an INPROC_SERVER. This restriction arises because of the fact architecture of how an OLE2 embedding handler, created when the object enters the loaded state, communicates with the Local Server as the running state is entered. It is possible that this restriction may be removed in the future.","Architecture of Standard Marshalling","If the object being remoted does not support Custom Marshalling, signified by the lack of support for IMarshal interface, then Standard Marshalling is used instead. With Standard Marshalling, the actual marshalling and unmarshalling of interface function parameters is handled by the system. However, the object being marshalled is given a second chance to indicate that it would like code that is specifies to run in the client process. Such code would presumably handle some processing locally, but refer the majority of requests back to the original object using the system supplied mechanism.","This is accomplished in the following way. Once the system has been determined that Standard Marshalling is to be used, the object is queried in order for IStdMarshalInfo and IPersist. If either of these interfaces is supported, then the CLSID returned by invoking the one method contained in each is used to identify the handler that is to be loaded in the client context (see CoGetClassObject( )). The handler of this class must use the standard remoting connection architecture. Presently, this means that such handlers must aggregate in the OLE2 Default Handler, as is described in OleCreateDefaultHandler( ).","If neither of these interfaces is supported, then a vanilla handler which merely remotes all calls back to the original object is used. For components which are not embeddings, this is likely to be the common situation. It corresponds to the classic RPC scenario, where the remote proxy is little more than a forwarder of requests.","IStdMarshalInfo::GetClassForHandler","HRESULT IStdMarshalInfo::GetClassForHandler(dwDestContext, pvDestContext, pClsid)","Retrieves the class identifier used to determine the handler in the destination process that is used in standard marshalling.","Server applications which support class conversion (Activate As in the Convert dialog box) must implement the IStdMarshalInfo interface. Implementation is necessary for the correct handler to be determined in all cases. See also the discussion of Activate As in the chapter on \u201cPersistent Storage for Objects.\u201d",{"@attributes":{"id":"p-0450","num":"0499"},"tables":{"@attributes":{"id":"TABLE-US-00113","num":"00113"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["dwDestContext","DWORD","The type of destination context to which"]},{"entry":[{},{},"this object is being passed."]},{"entry":["pvDestContext","void *","Pointer to the destination context."]},{"entry":["pClsid","CLSID*","A pointer to where to return the"]},{"entry":[{},{},"handler's class identifier."]},{"entry":["return value","HRESULT","S_OK"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},"In normal marshalling usage, interface pointers which are marshalled are merely transported across the \u201cwire\u201d to the other side (the other process), where they are unmarshalled. In this usage, the data packet that results from the marshalling process is unmarshalled exactly once. In contrast, there are occasions where we have need to marshal an interface pointer and store it in a globally accessible table. Once in the table, the data packet can be retrieved and unmarshalled zero, one, or more times. The Running Object Table and the table maintained by CoRegisterClassObject( ) are examples of this situation. In effect, the marshalled data packet sitting in the table acts very much like another pointer to the object. Depending on the semantics of the table in question, the \u201cdata packet pointer\u201d may need to either act as a reference-counted or non-reference-counted pointer to the interface. That is, depending on in which table the object is placed, the presence of the object in the table either does or does not keep the object alive. Further, because of this behavior, we must be careful to have marshalling-specific code execute at the time that these data-packets are removed from these tables and destroyed. We cannot simply throw the packets away, as the presence or absence of the internal state that they maintain may be important to the object that they indicate.","Technically, we address this space of possibilities in the following way. When an interface pointer is marshalled it is told by a parameter for which of the following three reasons it is being marshalled.","1. This is a normal marshal-then-unmarshal-once case.","2. This is a marshal for storing into a global table case, and the presence of the entry in to the table is to count as an additional reference to the interface.","3. This is a marshal for storing into a global table case, and the presence of the entry in to the table is not to count as an additional reference to the interface.","Further, whenever, a Case 2) or Case 3) marshalled-data-packet is removed from the table, it is the responsibility of the table implementor to call CoReleaseMarshalData( ).","Creating an Initial Connection Between Processes","Earlier we said we would later discuss how an initial remoting connection is established between two processes. It is now time to have that discussion.","The real truth of the matter is that the initial connection is established by some means outside of the architecture that we have been discussing here. The minimum that is required is some primitive communication channel between the two processes. As such, we cannot hope to discuss all the possibilities. But we will point out some common ones.","One common approach, used heavily in OLE 2.0, is that initial connections are established just like other connections: an interface pointer is marshalled in the server process, the marshalled data packet is ferried the client process, and it is unmarshalled. The only twist is that the ferrying is done by some means other than the RPC mechanism which we've been describing. There are many ways this could be accomplished. Among them are:\n\n","Another common approach likely to be prevalent in networking situations is that a centralized directory service is used.","Remoting-Related Function Descriptions","The following functions are related to interface remoting:",{"@attributes":{"id":"p-0462","num":"0514"},"tables":{"@attributes":{"id":"TABLE-US-00114","num":"00114"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["HRESULT","CoMarshalInterface(pstm, riid, pUnk, dwDestContext,"]},{"entry":[{},"pvDestContext, mshlflags);"]},{"entry":["HRESULT","CoUnmarshallInterface(pstm, iid, ppv);"]},{"entry":["HRESULT","CoDisconnectObject(pUnkInterface, dwReserved);"]},{"entry":["HRESULT","CoReleaseMarshalData(pstm);"]},{"entry":["HRESULT","CoGetStandardMarshal(iid, pUnkObject, dwDestContext,"]},{"entry":[{},"pvDestContext, mshlflags, ppmarshal);"]},{"entry":["HRESULT","CoMarshalHresult(pstm, hresult);"]},{"entry":["HRESULT","CoUnmarshalHresult(pstm, phresult);"]},{"entry":["HRESULT","CoLockObjectExternal(pUnk, fLock,"]},{"entry":[{},"fLastUnlockReleases);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef enum tagMSHLFLAGS {"},{"entry":"\u2003MSHLFLAGS_NORMAL = 0,"},{"entry":"\u2003MSHLFLAGS_TABLESTRONG = 1,"},{"entry":"\u2003MSHLFLAGS_TABLEWEAK = 2,"},{"entry":"\u2003} MSHLFLAGS;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{},"ul":{"@attributes":{"id":"ul0043","list-style":"none"},"li":"HRESULT CoMarshalInterface(pstm, riid, pUnk, dwDestContext, pvDestContext, mshlflags)"}},"Marshal the interface riid on the object on which pUnk is an IUnknown* into the given stream in such a way as it can be reconstituted in the destination using CoUnmarshalInterface( ). This is the root level function by which an interface pointer can be marshalled into a stream. It carries out the test for Custom Marshalling, using it if present, and carries out Standard Marshalling if not. This function is normally only called by code in interface proxies or interface stubs that wish to marshal an interface pointer parameter, though it will sometimes also be called by objects which support Custom Marshalling.","This function is, in fact, a helper function in that it carries out nothing internally that is not otherwise publicly available.","Riid indicates the interface on the object which is to be marshalled. It is specifically not the case that pUnk need actually be of interface riid; this function will QueryInterface from pUnk to determine the actual interface pointer to be marshalled.","dwDestContext identifies the execution context relative to the current context in which the unmarshalling will be done. Different marshalling might be done, for example, depending on whether the unmarshal happens on the same workstation vs. on a different workstation on the network; an object could choose to do Custom Marshalling in one case but not the other. The legal values for dwDestContext are taken from the enumeration MSHCTX, which presently contains the following values.",{"@attributes":{"id":"p-0467","num":"0520"},"tables":{"@attributes":{"id":"TABLE-US-00115","num":"00115"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef enum tagMSHCTX {"},{"entry":"\u2003MSHCTX_NOSHAREDMEM = 1, \/\/ only lower most bit is significant"},{"entry":"\u2003} MSHCTX;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"These flags have the following meanings.",{"@attributes":{"id":"p-0469","num":"0522"},"tables":{"@attributes":{"id":"TABLE-US-00116","num":"00116"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Value","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["MSHCTX_NOSHAREDMEM","The unmarshalling context does not"]},{"entry":[{},"have shared memory access with the"]},{"entry":[{},"marshalling context."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"In the future, more MSHCTX flags will be defined, particularly when network-remoting is implemented. pvDestContext is a parameter reserved for the use of future-defined MSHCTX's. ppvDestContext parameters may not be stored in the internal state of custom marshallers.","mslflags indicates the purpose for which the marshal is taking place, as was overviewed in an earlier part of this document. Values for this parameter are taken from the enumeration MSHLFLAGS, and have the following interpretation.",{"@attributes":{"id":"p-0472","num":"0525"},"tables":{"@attributes":{"id":"TABLE-US-00117","num":"00117"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Value","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["MSHLFLAGS_NORMAL","The marshalling is occuring because of the normal case of"]},{"entry":[{},"passing an interface from one process to another. The"]},{"entry":[{},"marshalled-data-packet that results from the call will be transported to"]},{"entry":[{},"the other process, where it will be unmarshalled 9see"]},{"entry":[{},"CoUnmarshalInterface( ))."]},{"entry":[{},"With this flag, the marshalled data packet will be unmarshalled either"]},{"entry":[{},"one or zero times. CoReleaseMarshalData( ) is always (eventually)"]},{"entry":[{},"called to free the data packet."]},{"entry":["MSHLFLAGS_TABLESTRONG","The marshalling is occurring because the data-packet is to be"]},{"entry":[{},"stored in a globally-accessible table from which it is to be"]},{"entry":[{},"unmarshalled zero, one, or more times. Further, the presence"]},{"entry":[{},"of the data-packet in the table is to count as a reference on the"]},{"entry":[{},"marshalled interface."]},{"entry":[{},"When removed from the table, it is the responsibility of"]},{"entry":[{},"the table implementor to call CoReleaseMarshalData( ) on the"]},{"entry":[{},"data-packet."]},{"entry":["MSHLFLAGS_TABLEWEAK","The marshalling is occurring because the data-packet is"]},{"entry":[{},"to be stored in a globally-accessible table from which it is to be"]},{"entry":[{},"unmarshalled zero, one, or more times. However, the presence"]},{"entry":[{},"of the data-packet in the table is not to count as a reference on"]},{"entry":[{},"the marshalled interface."]},{"entry":[{},"Destruction of the data-packet is as in the"]},{"entry":[{},"MSHLFLAGS_TABLESTRONG case."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"A consequence of this design is that the marshalled data packet will want to store the value of mshlflags in the marshalled data so as to be able to do the right thing at unmarshal time.",{"@attributes":{"id":"p-0474","num":"0527"},"tables":{"@attributes":{"id":"TABLE-US-00118","num":"00118"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"189pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pstm","IStream *","the stream onto which the object should be marshalled. The"]},{"entry":[{},{},"stream passed to this function must be dynamically growable."]},{"entry":[{},{},"In the absence of better information, it is suggested that this"]},{"entry":[{},{},"stream contain at least MARSHALINTERFACE_MIN bytes of"]},{"entry":[{},{},"space, though it is by no means guaranteed that this will be"]},{"entry":[{},{},"sufficient."]},{"entry":["riid","REFIID","the interface that we wish to marshal."]},{"entry":["pUnk","IUnknown *","the object on which we wish to marshal the interface riid."]},{"entry":["dwDestContext","DWORD","the destination context in which the unmarshalling will occur."]},{"entry":["pvDestContext","void*","related to some TBD destination contexts."]},{"entry":["mshlflags","DWORD","the reason that the marshalling is taking place."]},{"entry":["return value","HRESULT","S_OK, STG_E_MEDIUMFULL, E_FAIL"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"Unmarshal from the given stream an object previously marshalled with CoMarshalInterface( ).",{"@attributes":{"id":"p-0476","num":"0529"},"tables":{"@attributes":{"id":"TABLE-US-00119","num":"00119"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pstm","IStream *","the stream from which the object should"]},{"entry":[{},{},"be unmarshalled."]},{"entry":["iid","REFIID","the interface with which we wish to talk to"]},{"entry":[{},{},"the reconstituted object."]},{"entry":["ppv","void **","the place in which we should return the"]},{"entry":[{},{},"interface pointer."]},{"entry":["return value","HRESULT","S_OK, E_FAIL"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"This function severs any extant Remote Procedure Call connections that are being maintained on behalf of all the interface pointers on this object. This is a very rude operation, and is not to be used in the normal course of processing; clients of interfaces should use IUnknown::Release( ) instead. In effect, this function is a privileged operation, which should generally only be invoked by the process in which the object actually is managed by the object implementation itself.","The primary purpose of this operation is to give an application process certain and definite control over remoting connections to other processes that may have been made from objects managed by the process. If the application process wishes to exit, then we do not want it to be the case that the extant reference counts from clients of the application's objects in fact keeps the process alive. When the application process wishes to exit, it should inform the extant clients of its objects that the objects are going away. Having so informed its clients, the process can then call this function for each of the objects that it manages, even without waiting for a confirmation from each client. Having thus released resources maintained by the remoting connections, the application process can exit safely and cleanly. In effect, CoDisconnectObject( ) causes a controlled crash of the remoting connections to the object.","For illustration, contrast this with the situation with DDE. If it has extant DDE connections, an application is required to send a DDE Terminate message before exiting, and it is also responsible for waiting around for an acknowledgment from each client before it can actually exit. Thus, if the client process has crashed, the application process will wait around forever. Because of this, with DDE there simply is no way for an application process to reliably and robustly terminate itself. Using CoDisconnectObject( ), we avoid this sort of situation.",{"@attributes":{"id":"p-0480","num":"0533"},"tables":{"@attributes":{"id":"TABLE-US-00120","num":"00120"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pUnkInterface","IUnknown *","the object that we wish to disconnect."]},{"entry":[{},{},"May be any interface on the object"]},{"entry":[{},{},"which is polymorphic with IUnknown*,"]},{"entry":[{},{},"not necessarily the exact interface"]},{"entry":[{},{},"returned by QueryInterface"]},{"entry":[{},{},"(IID_IUnknown . . .)."]},{"entry":["dwReserved","DWORD","reserved for future use; must be zero."]},{"entry":["return value","HRESULT","S_OK, E_FAIL"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"This helper function destroys a previously marshalled data packet. This function must always be called in order to destroy data packets. Examples of when this occurs include:","1. an internal error during an RPC invocation prevented the UnmarshalInterface( ) operation from being attempted.","2. a marshalled-data-packet was removed from a global table.","3. following a successful, normal, unmarshal call.","This function works as should be expected: the class id is obtained from the stream; an instance is created; IMarshal is obtained from that instance; then IMarshal::ReleaseMarshalData( ) is invoked.",{"@attributes":{"id":"p-0486","num":"0539"},"tables":{"@attributes":{"id":"TABLE-US-00121","num":"00121"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pstm","IStream*","a pointer to a stream that contains the data"]},{"entry":[{},{},"packet which is to be destroyed"]},{"entry":["return value","HRESULT","S_OK, E_FAIL"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"Return an IMarshal instance that knows how to do the Standard Marshalling and unmarshalling in order to create a proxy in the indicated destination context. Custom marshalling implementations should delegate to the marshaller here returned for destination contexts that they do not fully understand or which for which they choose not to take special action. The standard marshaller is also used in the case that the object being marshalled does not support Custom Marshalling.",{"@attributes":{"id":"p-0488","num":"0541"},"tables":{"@attributes":{"id":"TABLE-US-00122","num":"00122"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["iid","REFIID","the interface id we would like to marshal."]},{"entry":["pUnkObject","IUnknown*","the object that we wish to marshal. It is"]},{"entry":[{},{},"specifically not the case that this interface"]},{"entry":[{},{},"is known to be of shape iid; rather, it can"]},{"entry":[{},{},"be any interface on the object which"]},{"entry":[{},{},"conforms to IUnknown. The standard"]},{"entry":[{},{},"marshaller will internally do a"]},{"entry":[{},{},"QueryInterface( )."]},{"entry":["dwDestContext","DWORD","the destination context in which the"]},{"entry":[{},{},"unmarshalling will occur."]},{"entry":["pvDextContext","void*","associated with the destination context"]},{"entry":["mshlflags","DWORD","the marshal flags for the marshalling"]},{"entry":[{},{},"operation."]},{"entry":["ppmarshal","IMarshal **","the place at which the standard marshaller"]},{"entry":[{},{},"should be returned."]},{"entry":["return value","HRESULT","S_OK, E_FAIL"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"Marshal an HRESULT to the given stream in such a way as it can be unmarshalled with CoUnmarshalHresult( ). Custom marshallers should use this function when they have need to marshal an HRESULT.",{"@attributes":{"id":"p-0490","num":"0543"},"tables":{"@attributes":{"id":"TABLE-US-00123","num":"00123"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pstm","IStream*","the stream into which the HRESULT is to"]},{"entry":[{},{},"be marshalled."]},{"entry":["hresult","HRESULT","the HRESULT to be marshalled."]},{"entry":["return value","HRESULT","S_OK; errors as in IStream::Write( )."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"Unmarshal an HRESULT previously marshalled with CoMarshalHresult( ). Custom unmarshallers will want to use this function if the corresponding custom marshaller uses CoMarshalHresult( ).",{"@attributes":{"id":"p-0492","num":"0545"},"tables":{"@attributes":{"id":"TABLE-US-00124","num":"00124"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pstm","IStream*","the stream into which the HRESULT is to be"]},{"entry":[{},{},"marshalled."]},{"entry":["phresult","HRESULT*","the place at which the unmarshalled"]},{"entry":[{},{},"HRESULT is to be returned."]},{"entry":["return value","HRESULT","S_OK; errors as in IStream::Read( )."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"This function locks an object so that its reference count cannot decrement to zero. It also releases such a lock. From the object's point of view, the lock functionality is implemented by having the system AddRef( ) the object and not Release( ) it until CoLockObjectExternal( . . . , FALSE, . . . ) is later called.","CoLockObiectExternal( ) must be called in the process in which the object actually resides (that is, the server process, not the process in which handlers for the object may be loaded).","The function can be used for the user's reference count as it acts external to the object, much like the user does. It can also be used for the IOIeContainer::LockContainer( ) functionality, although the container must still keep a lock count so that it exits when the lock count reaches zero and the container is invisible.","This function does not in any way change the normal registration\/revoking process for objects.",{"@attributes":{"id":"p-0497","num":"0550"},"tables":{"@attributes":{"id":"TABLE-US-00125","num":"00125"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"189pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pUnk","IUnknown*","Points to the object to be locked or unlocked."]},{"entry":["fLock","BOOL","Either locks or unlocks the object. FALSE releases such locks."]},{"entry":[{},{},"TRUE holds the object alive (holds a reference to the object)"]},{"entry":[{},{},"independent of external or internal AddRef\/Release operations,"]},{"entry":[{},{},"or registrations, or revokes. If fLock is TRUE,"]},{"entry":[{},{},"fLastLockReleases is ignored."]},{"entry":["fLastLockReleases",{},"BOOL TRUE means release all pointers to the object if this"]},{"entry":[{},{},"lock is the last reference to the object which is supposed to"]},{"entry":[{},{},"hold it alive (there may be other references which are not"]},{"entry":[{},{},"supposed to hold it alive)."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"This function is documented in the chapter on concurrency control.","IMarshal Interface","IMarshal interface is the mechanism by which an object is custom-marshalled. IMarshal is defined as follows:",{"@attributes":{"id":"p-0500","num":"0553"},"tables":{"@attributes":{"id":"TABLE-US-00126","num":"00126"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"interface IMarshal : IUnknown {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003virtual HRESULT","GetUnmarshalClass(iid, pvInterface,"]},{"entry":[{},"dwDestContext, pvDestContext, mshlflags,"]},{"entry":"pclsid) = 0;"},{"entry":["\u2003virtual HRESULT","GetMarshalSizeMax(iid, pvInterface,"]},{"entry":[{},"dwDestContext, pvDestContext, mshlflags,"]},{"entry":[{},"pcb) = 0;"]},{"entry":["\u2003virtual HRESULT","MarshalInterface(pstm, iid, pvInterface,"]},{"entry":[{},"dwDestContext, pvDestContext, mshlflags) = 0;"]},{"entry":["\u2003virtual HRESULT","UnmarshalInterface(pstm, iid, ppvInterface) = 0;"]},{"entry":["\u2003virtual HRESULT","DisconnectObject(dwReserved) = 0;"]},{"entry":["\u2003virtual HRESULT","ReleaseMarahalData(pstm) = 0;"]},{"entry":"};"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The process of Custom Marshalling an interface pointer involves two steps, with an optional third:","1. The code doing the marshalling calls IMarshal::GetUnmarshalClass( ). This returns the class id that will be used to create an uninitialized proxy object in the unmarshalling context.","2. (optional) The marshaller calls IMarshal::GetMarshalSizeMax( ) to learn an upper bound on the amount of memory that will be required by the object to do the marshalling.","3. The marshaller calls IMarshal::MarshalInterface( ) to carry out the marshalling.","The class id and the bits that were marshalled into the stream are then conveyed by appropriate means to the destination, where they are unmarshalled. Unmarshalling involves the following essential steps:","1. Load the class object that corresponds to the class that the server said to use in GetUnmarshalClass( ).\n\n","2. Instantiate the class, asking for IMarshal interface;\n\n","3. Initialize the proxy with IMarshal::UnmarshalInterface( ) using a copy of the bits that were originally produced by IMarshal::MarshalInterface( ) and asking for the interface that was originally marshalled.\n\n","The object proxy is now ready for use.","IMarshal::GetUnmarshalClass","HRESULT IMarshal::GetUnmarshalClass(iid, pvInterface, dwDestContext, pvDestContext, mshlflags, pclsid)","Answer the class that should be used in the unmarshalling process to create an uninitialized object proxy.","dwDestContext is described in the API function CoMarshalInterface( ). The implementation of GetUnmarshalClass( ) may wish for some destination contexts for which it takes no special action to delegate to the Standard Marshalling implementation, which is available through CoGetStandardMarshal( ). In addition, this delegation should always be done if the dwDestContext parameter contains any flags that the GetUnmarshalClass( ) does not fully understand; it is by this means that we can extend the richness of destination contexts in the future. For example, in the future, one of these bits will likely be defined to indicate that the destination of the marshalling is across the network.","If the caller already has in hand the iid interface identified as being marshalled, he should pass the interface pointer through pvInterface. If he does not have this interface already, then he should pass NULL. This pointer will sometimes, though rarely, be used in order to determine the appropriate unmarshal class. If the IMarshal implementation really needs it, it can always QueryInterface( ) on itself to retrieve the interface pointer; we optionally pass it here only to improve efficiency.",{"@attributes":{"id":"p-0513","num":"0574"},"tables":{"@attributes":{"id":"TABLE-US-00127","num":"00127"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["iid","REFIID","the interface on this object that we are"]},{"entry":[{},{},"going to marshal."]},{"entry":["pvInterface","void *","the actual pointer that will be marshalled."]},{"entry":[{},{},"May be NULL."]},{"entry":["dwDestContext","DWORD","the destination context relative to the"]},{"entry":[{},{},"current context in which the unmarshalling"]},{"entry":[{},{},"will be done."]},{"entry":["pvDestContext","void*","non-NULL for some dwDestContext"]},{"entry":[{},{},"values."]},{"entry":["mshlflags","DWORD","as in CoMarshallInterface( )."]},{"entry":["pclsid","CLSID *","the class to be used in the unmarshalling"]},{"entry":[{},{},"process."]},{"entry":["return value","HRESULT","S_OK, E_FAIL"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"Marshal a reference to the interface iid of this object into the given stream. The interface actually marshalled is the one that would be returned by this\u2192QueryInterface(iid, . . . ). Once the contents of this stream are conveyed to the destination by whatever means, the interface reference can be reconstituted by instantiating with IMarshal interface the class here retrievable with GetUnmarshalClass( ) and then calling IMarshal::UnmarshalInterface( ). The implementation of IMarshal::MarshalInterface( ) writes in the stream any data required for initialization of this proxy.","If the caller already has in hand the iid interface identified as being marshalled, he should pass the interface pointer through pvInterface. If he does not have this interface already, then he should pass NULL; the IMarshal implementation will QueryInterface( ) on itself to retrieve the interface pointer.","On exit from this function, the seek pointer in the stream must be positioned immediately after the last byte of data written to the stream.",{"@attributes":{"id":"p-0517","num":"0578"},"tables":{"@attributes":{"id":"TABLE-US-00128","num":"00128"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pstm","IStream *","the stream onto which the object should"]},{"entry":[{},{},"be marshalled."]},{"entry":["iid","REFIID","the interface of this object that we wish"]},{"entry":[{},{},"to marshal."]},{"entry":["pvInterface","void *","the actual pointer that will be marshalled."]},{"entry":[{},{},"May be NULL."]},{"entry":["dwDestContext","DWORD","as in CoMarshalInterface( )."]},{"entry":["pvDestContext","void *","as in CoMarshalInterface( )."]},{"entry":["mshlflags","DWORD","as in CoMarshallInterface( )."]},{"entry":["return value","HRESULT","S_OK, STG_E_MEDIUMFULL,"]},{"entry":[{},{},"E_FAIL"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"Return an upper bound on the amount of data that would be written into the marshalling stream in an IMarshal::MarshalInterface( ) stream. Callers can optionally use this value to pre-allocate stream buffers used in the marshalling process. Note that when IMarshal::MarshalInterface( ) is ultimately called, the IMarshal cannot rely on the caller actually having called GetMarshalSizeMax( ) beforehand; it must still be wary of STG_E_MEDIUMFULL errors returned by the stream.","The value returned by this function is only guaranteed to be valid so long as the internal state of the object being marshalled does not change. As a consequence, the actual marshalling should be done immediately after this function returns, or the caller runs the risk that the object requires more memory to marshal that it originally indicated.","An object must return a reasonable maximum size needed for marshalling: callers have the option of allocating a fixed-size marshalling buffer.",{"@attributes":{"id":"p-0521","num":"0582"},"tables":{"@attributes":{"id":"TABLE-US-00129","num":"00129"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["iid","REFIID","the interface of the object that we wish to"]},{"entry":[{},{},"marshal."]},{"entry":["pvInterface","void *","the actuator pointer that will be"]},{"entry":[{},{},"marshalled. May be NULL."]},{"entry":["dwDestContext","DWORD","as in CoMarshalInterface( )."]},{"entry":["pvDestContext","void *","as in CoMarshalInterface( )."]},{"entry":["mshlflags","DWORD","as in CoMarshalInterface( )."]},{"entry":["pcb","ULONG *","the place at which the maximum marshal"]},{"entry":[{},{},"size should be returned."]},{"entry":["return value","HRESULT","S_OK"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"This is called as part of the unmarshalling process in order to initialize a newly created proxy; see the above sketch of the unmarshalling process for more details.","iid indicates the interface that the caller in fact would like to retrieve from this object; this interface instance is returned through ppvInterface. In order to support this, UnmarshalInterface( ) will often merely do a QueryInterface(iid, ppvInterface) on itself immediately before returning, though it is free to create a different object (an object with a different identity) if it wishes.","On successful exit from this function, the seek pointer must be positioned immediately after the data read from the stream. On error exit, the seek pointer should still be in this location: even in the face of an error, the stream should be positioned as if the unmarshal were successful.","See also CoReleaseMarshalData( ).",{"@attributes":{"id":"p-0526","num":"0587"},"tables":{"@attributes":{"id":"TABLE-US-00130","num":"00130"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Argument","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["pstm","IStream *","the stream from which the interface should"]},{"entry":[{},{},"be unmarshalled."]},{"entry":["iid","REFIID","the interface that the caller ultimately wants"]},{"entry":[{},{},"from the object."]},{"entry":["ppvInterface","void **","the place at which the interface the caller"]},{"entry":[{},{},"wants is to be returned."]},{"entry":["return value","HRESULT","S_OK, E_FAIL"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},"This function is called by the implementation of CoDisconnectObject( ) in the event that the object attempting to be disconnected in fact supports Custom Marshalling. This is completely analogous to how CoMarshalInterface( ) defers to IMarshal::MarshalInterface( ) in if the object supports IMarshal.",{"@attributes":{"id":"p-0528","num":"0589"},"tables":{"@attributes":{"id":"TABLE-US-00131","num":"00131"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Argument","Type","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"dwReserved","DWORD","as in CoDisconnectObject( )."]},{"entry":[{},"return value","HRESULT","as in CoDisconnectObject( )."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":[{},{}]},"This function is called by CoReleaseMarshalData( ) in order to actually carry out the destruction of a marshalled-data-packet. See that function for more details.","Note that whereas the IMarshal methods\n\n",{"@attributes":{"id":"p-0531","num":"0598"},"tables":{"@attributes":{"id":"TABLE-US-00132","num":"00132"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Argument","Type","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"pstm","IStream*","as in CoReleaseMarshalData( )."]},{"entry":[{},"return value","HRESULT","as in CoReleaseMarshalData( )."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}}],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0047","num":"0068"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0048","num":"0069"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0049","num":"0070"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0050","num":"0071"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0051","num":"0072"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0052","num":"0073"},"figref":"FIGS. 6","b":["7","8"]},{"@attributes":{"id":"p-0053","num":"0074"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0054","num":"0075"},"figref":"FIGS. 10A","b":["10","10"]},{"@attributes":{"id":"p-0055","num":"0076"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0056","num":"0077"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0057","num":"0078"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0058","num":"0079"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0059","num":"0080"},"figref":"FIGS. 15A through 15F"},{"@attributes":{"id":"p-0060","num":"0081"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0061","num":"0082"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0062","num":"0083"},"figref":"FIGS. 18","b":["19","19","19","20","20","20","21","21","21"]},{"@attributes":{"id":"p-0063","num":"0084"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0064","num":"0085"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0065","num":"0086"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0066","num":"0087"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0067","num":"0088"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0068","num":"0089"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0069","num":"0090"},"figref":"FIGS. 28A","b":["28","28"]},{"@attributes":{"id":"p-0070","num":"0091"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0071","num":"0092"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0072","num":"0093"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0073","num":"0094"},"figref":"FIG. 32"},{"@attributes":{"id":"p-0074","num":"0095"},"figref":"FIG. 33"},{"@attributes":{"id":"p-0075","num":"0096"},"figref":"FIG. 34"},{"@attributes":{"id":"p-0076","num":"0097"},"figref":"FIG. 35"},{"@attributes":{"id":"p-0077","num":"0098"},"figref":"FIG. 36"},{"@attributes":{"id":"p-0078","num":"0099"},"figref":"FIG. 37"},{"@attributes":{"id":"p-0079","num":"0100"},"figref":"FIG. 38"},{"@attributes":{"id":"p-0080","num":"0101"},"figref":"FIG. 39"},{"@attributes":{"id":"p-0081","num":"0102"},"figref":"FIG. 40"},{"@attributes":{"id":"p-0082","num":"0103"},"figref":"FIGS. 41A and 41B"},{"@attributes":{"id":"p-0083","num":"0104"},"figref":"FIGS. 42A","b":["42","42"]},{"@attributes":{"id":"p-0084","num":"0105"},"figref":"FIG. 43"},{"@attributes":{"id":"p-0085","num":"0106"},"figref":"FIG. 44"},{"@attributes":{"id":"p-0086","num":"0107"},"figref":"FIG. 45"},{"@attributes":{"id":"p-0087","num":"0108"},"figref":"FIG. 46"},{"@attributes":{"id":"p-0088","num":"0109"},"figref":"FIG. 47"},{"@attributes":{"id":"p-0089","num":"0110"},"figref":"FIG. 48"},{"@attributes":{"id":"p-0090","num":"0111"},"figref":"FIG. 49"}]},"DETDESC":[{},{}]}
