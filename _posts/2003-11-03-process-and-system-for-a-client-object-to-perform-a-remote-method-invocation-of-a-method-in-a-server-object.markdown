---
title: Process and system for a client object to perform a remote method invocation of a method in a server object
abstract: An adapter is generated by introspecting on the interfaces of an Enterprise JavaBean (EJB) running on a CORBA server. The adapter resides on the Java client-side and contains a remote proxy of the CORBA server that runs the EJB. The adapter is a Java class that implements the interfaces specified by the EJB for invoking its business methods. Adapters delegate all of the business method calls from the client to the CORBA proxy on the server and perform data marshalling from the Java client to the CORBA proxy and vice versa. Any business method calls made by the client to the adapter are delegated by the adapter to the CORBA proxy after appropriate data conversion. Thus, the adapter acts as transparent glue between the Java client and the EJB on the CORBA server.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06959307&OS=06959307&RS=06959307
owner: International Business Machines Corporation
number: 06959307
owner_city: Armonk
owner_country: US
publication_date: 20031103
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT"],"p":["The present application is a continuation of application Ser. No. 09\/259,141, filed Feb. 26, 1999, now abandoned, and is related to application Ser. No. 09\/259,172, filed (concurrently herewith), titled \u201cMethod and System for Persisting Beans as Container-Managed Fields,\u201d which is hereby incorporated by reference.","1. Technical Field","The present invention relates generally to an improved distributed data processing system and in particular to a method and apparatus for a distributed application comprising objects on clients and servers within the distributed data processing system.","2. Description of Related Art","Software developers face the fundamental problem that writing an enterprise-wide application is difficult and that writing a distributed application is even more difficult. In addition, an enterprise seeks to build an application as fast as possible without being locked into one platform. Ideally, enterprise developers would like to be able to write the application once and run it on all of their platforms. Enterprise JavaBeans\u2122 technology seeks to provide this ability.","The Enterprise JavaBeans (EJB) component architecture is designed to enable enterprises to build scalable, secure, multi-platform, business-critical applications as reusable, server-side components. Its purpose is to solve the enterprise problems by allowing the enterprise developer to focus only on writing business logic.","The server-side environment and the tools needed to service it have greatly influenced the design goals for EJB technology. One key design goal was to reduce the process of building distributed applications as much as possible. This goal has been accomplished by turning features that ordinarily would need to be hand-coded into simple declarative properties of the Enterprise JavaBeans. These declarative properties generate a significant increase in development efficiency because certain behaviors, like security and transactions, are set, not in code, but are \u201cflags\u201d on the bean itself.","The EJB specification creates an infrastructure that takes care of the system-level programming, such as transactions, security, threading, naming, object-life cycle, resource pooling, remote access, and persistence. It also simplifies access to existing applications, and provides a uniform application development model for tool creation use.","Java provides a mechanism by which a Java client can invoke methods on a Java server that is running in a separate process using a methodology called Remote Method Invocation (RMI). However, if the server is not running in a Java environment, such as a CORBA-compliant (Common Object Request Broker Architecture) server, then the Java client cannot make any method calls to the method on the CORBA server since Java does not provide an inherent mechanism for communicating with CORBA objects.","Simply stated, CORBA is an Object Request Broker (ORB) that allows applications to communicate with one another no matter where they are located or who has designed them. An ORB is the middleware that establishes the client-server relationships between objects. Enterprises have turned to CORBA as a solution to provide inter-operability between various software applications.","There is no standard mechanism for performing data marshalling, i.e., data conversion for different types of data, between a Java client and a CORBA server. It would be advantageous to have a mechanism that allows a Java client to communicate with another Java application, such as an EJB, running in a non-Java environment, such as a CORBA server.","The present invention provides an adapter that is generated by introspecting on the interfaces of an Enterprise JavaBean (EJB) running on a Common Object Request Broker Architecture (CORBA) server. The adapter resides on the Java client-side and contains a remote proxy of the CORBA server that runs the EJB. The adapter is a Java class that implements the interfaces specified by the EJB for invoking its business methods. Adapters delegate all of the business method calls from the client to the CORBA proxy on the server and perform data marshaling from the Java client to the CORBA proxy and vice versa. Any business method calls made by the client to the adapter are delegated by the adapter to the CORBA proxy alter appropriate data conversion. Thus, the adapter acts as transparent glue between the Java client and the EJB on the COBRA server. The method may he generalized for a client object and a server object implemented in different languages. An adapter may wrap an object reference for a server object. While attempting to invoke a method in a server object, a client abject invokes a method within the adapter, which transparently uses the object reference to call a skeleton of the object reference on the server, which then calls the method within the server object.","With reference now to the figures,  depicts a pictorial representation of a distributed data processing system in which the present invention may be implemented. Distributed data processing system  is a network of computers in which the present invention may be implemented. Distributed data processing system  contains a network , which is the medium used to provide communications links between various devices and computers connected together within distributed data processing system . Network  may include permanent connections, such as wire or fiber optic cables, or temporary connections made through telephone connections.","In the depicted example, a server  is connected to network  along with storage unit . In addition, clients , , and  also are connected to a network . These clients , , and  may be, for example, personal computers or network computers. For purposes of this application, a network computer is any computer, coupled to a network, which receives a program or other application from another computer coupled to the network. In the depicted example, server  provides data, such as boot files, operating system images, and applications to clients -. Clients , , and  are clients to server . Distributed data processing system  may include additional servers, clients, and other devices not shown. In the depicted example, distributed data processing system  is the Internet with network  representing a worldwide collection of networks and gateways that use the TCP\/IP suite of protocols to communicate with one another. At the heart of the Internet is a backbone of high-speed data communication lines between major nodes or host computers, consisting of thousands of commercial, government, educational and other computer systems that route data and messages. Of course, distributed data processing system  also may be implemented as a number of different types of networks, such as for example, an intranet, a local area network (LAN), or a wide area network (WAN).  is intended as an example, and not as an architectural limitation for the present invention.","Referring to , a block diagram depicts a data processing system, which may be implemented as a server, such as server  in , in accordance with a preferred embodiment of the present invention. Data processing system  may be a symmetric multiprocessor (SMP) system including a plurality of processors  and  connected to system bus. . Alternatively, a single processor system may be employed. Also connected to system bus  is memory controller\/cache , which provides an interface to local memory . I\/O bus bridge  is connected to system bus  and provides an interface to I\/O bus . Memory controller\/cache  and I\/O bus bridge  may be integrated as depicted.","Peripheral component interconnect (PCI) bus bridge  connected to I\/O bus  provides an interface to PCI local bus . A number of modems \u2013 may be connected to PCI bus . Typical PCI bus implementations will support four PCI expansion slots or add-in connectors. Communications links to network computers \u2013 in  may be provided through modem  and network adapter  connected to PCI local bus  through add-in boards.","Additional PCI bus bridges  and  provide interfaces for additional PCI buses  and , from which additional modems or network adapters may be supported. In this manner, server  allows connections to multiple network computers. A memory-mapped graphics adapter  and hard disk  may also be connected to I\/O bus  as depicted, either directly or indirectly.","Those of ordinary skill in the art will appreciate that the hardware depicted in  may vary. For example, other peripheral devices, such as optical disk drives and the like, also may be used in addition or in place of the hardware depicted. The depicted example is not meant to imply architectural limitations with respect to the present invention.","The data processing system depicted in  may be, for example, an IBM RISC\/System 6000 system, a product of International Business Machines Corporation in Armonk, N.Y., running the Advanced Interactive Executive (AIX) operating system.","With reference now to , a block diagram illustrates a data processing system in which the present invention may be implemented. Data processing system  is an example of a client computer. Data processing system  employs a peripheral component interconnect (PCI) local bus architecture. Although the depicted example employs a PCI bus, other bus architectures such as Micro Channel and ISA may be used. Processor  and main memory  are connected to PCI local bus  through PCI bridge . PCI bridge  also may include an integrated memory controller and cache memory for processor . Additional connections to PCI local bus  may be made through direct component interconnection or through add-in boards. In the depicted example, local area network (LAN) adapter , SCSI host bus adapter , and expansion bus interface  are connected to PCI local bus  by direct component connection. In contrast, audio adapter , graphics adapter , and audio\/video adapter  are connected to PCI local bus  by add-in boards inserted into expansion slots. Expansion bus interface  provides a connection for a keyboard and mouse adapter , modem , and additional memory . SCSI host bus adapter  provides a connection for hard disk drive , tape drive , and CD-ROM drive . Typical PCI local bus implementations will support three or four PCI expansion slots or add-in connectors.","An operating system runs on processor  and is used to coordinate and provide control of various components within data processing system  in . The operating system may be a commercially available operating system such as OS\/2, which is available from International Business Machines Corporation. \u201cOS\/2\u201d is a trademark of International Business Machines Corporation. An object oriented programming system such as Java may run in conjunction with the operating system and provides calls to the operating system from Java programs or applications executing on data processing system . \u201cJava\u201d is a trademark of Sun Microsystems, Inc. Instructions for the operating system, the object-oriented operating system, and applications or programs are located on storage devices, such as hard disk drive , and may be loaded into main memory  for execution by processor .","Those of ordinary skill in the art will appreciate that the hardware in  may vary depending on the implementation. Other internal hardware or peripheral devices, such as flash ROM (or equivalent nonvolatile memory) or optical disk drives and the like, may be used in addition to or in place of the hardware depicted in . Also, the processes of the present invention may be applied to a multiprocessor data processing system.","For example, data processing system , if optionally configured as a network computer, may not include SCSI host bus adapter , hard disk drive , tape drive , and CD-ROM , as noted by dotted line  in  denoting optional inclusion. In that case, the computer, to be properly called a client computer, must include some type of network communication interface, such as LAN adapter , modem , or the like. As another example, data processing system  may be a stand-alone system configured to be bootable without relying on some type of network communication interface, whether or not data processing system  comprises some type of network communication interface. As a further example, data processing system  may be a Personal Digital Assistant (PDA) device which is configured with ROM and\/or flash ROM in order to provide non-volatile memory for storing operating system files and\/or user-generated data.","The depicted example in  and above-described examples are not meant to imply architectural limitations.","The present invention provides a method, data processing system, and instructions for providing a distributed application in which a Java client can communicate with an EJB on a CORBA server. A more detailed description of generic distributed applications in the prior art is now given in order to provide a context for describing the present invention within a distributed application.","The processes of the present invention may be implemented using the Java programming system, which is an object-oriented programming system. Object-oriented programming techniques involve the definition, creation, use, and instruction of \u201cobjects\u201d. These objects are software entities comprising data elements or attributes and methods, which manipulate data elements. Objects also may include data related to events outside of the object to trigger or control methods within the object.","Objects are defined by defining \u201cclasses\u201d, which are not objects, but templates, which instruct a compiler how to construct the actual object. For example, a class may specify the number and type of data variables and the steps involved in the functions, which manipulate data. An object is actually created in the program by means of a special function called a constructor, which uses the corresponding class definition and additional information, such as arguments provided during object creation, to construct the object. Objects are destroyed by a special function called a destructor. Java also allows for the creation of totally abstract classes known as interfaces, which allow the defining of methods that may be shared with several classes without regard for how other classes are handling the methods.","With reference now to , a diagram illustrating a prior art distributed application is depicted. As can be seen, client object  resides on the client-side of the distributed application while server object  forms the server-side of the distributed application. Client object  is located on a client computer, such as, for example, client  in distributed data processing system  in . Server object  is located on a server, such as server  in . Client object  may initiate calls to server object  to access database  based on various business rules or business logic implemented within server object . Database  may be located within the server or be a remote database. Server object  may also provide access to current enterprise applications  and access to legacy applications . A customizer may be provided to allow a user building a distributed application to configure a host name or the Internet Protocol (IP) address of the second tier computer implementing server object . In this example, a Java remote method invocation (RMI) protocol  is employed for distributed communication between objects, such as client object  and server object .","Server object  contains the actual business logic that is implemented using application programming interfaces (APIs) that utilize the Java-defined Java database connectivity (JDBC) structured query language (SQL) database access interface, which provides uniform access to a wide range of relational databases. In the depicted example, these databases may be found in database . Server object  contains methods used to provide needed functions invoked from client object . The above mentioned methods could be written to access other backend systems (i.e. CICS, IMS, MQ, SAP, etc.) and should not be restricted to just JDBC or database access.","Continuing with the example of database access within a distributed application, the database access functions may be divided into two objects\u2014a client object and a server object. The server object implements an interface that contains the methods that are invoked from the client object and which use JDBC.","The client object can serve as an event source or an event sink for various events. At build time, the client object is used in a client-side builder environment and is connected to other client-side software components. For example, at client-side build time, an application assembler uses a client-side builder environment to connect a GUI object to the client object so that when a button is pressed an event will be sent to the object to retrieve certain data. At server-side build time, an application assembler uses a builder environment to connect the server object.","At run time, the user presses a button on the client, which signifies that certain data is requested for view. The GUI object generates an event, which is sent to the client object. The client object invokes a method on the server object requesting the needed data. The client object communicates with its corresponding server object by using such protocols as RMI or an Object Request Broker (ORB) using Internet InterOrb Protocol (IIOP). The server-side object retrieves the data and sends the data back to the client-side object. The data is then returned by the client-side object to the GUI object for display to the end-user.","In the depicted example, two Java beans may be employed that implement the client object  and server object . What makes a bean different from a pure object is that it has an external interface, called the properties interface, which allows a tool to read what the component is supposed to do and hook it up to other beans and plug it into another environment. Two different types of beans may be used-JavaBeans and Enterprise JavaBeans (EJB). JavaBeans are intended to be local to a single process and are often visible at runtime. This visual component may be a button, list box, graphic or chart, for example, but it is not a requirement.","An EJB is a non-visual, remote object designed to run on a server and be invoked by clients. An EJB can be built from multiple, non-visual JavaBeans. EJBs are intended to live on one machine and be invoked remotely from another machine, and EJBs have a deployment descriptor that is intended as a description about the bean that can be read by a tool. EJBs are also platform independent and can be used on any platform that supports Java.","Server beans or EJBs are remotely executable components or business objects deployed on the server. EJBs have a protocol that allows them to be accessed remotely, and this protocol also allows them to be installed or deployed on a particular server. They have a set of mechanisms that allow them to delegate major qualities of service, security, transactional behavior, concurrency (the ability to be accessed by more than one client at a time), and persistence (how their state can be saved) to the container in which they are placed on the EJB server. EJBs get their behavior from being installed in a container, which provides the different qualities of service. Any platform independent JavaBean can be adopted, through the use of a deployment tool, into a platform specific EJB that has the correct qualities of services available to meet the specific requirements of existing business systems and applications.","With this separation between client bean  and server bean , changes to various business logic within server bean  may be performed without having to modify client bean . This is desirable because there may be thousands of clients that access a single server. In addition, these processes also may be applied to programs written in non-current programming languages, such as COBOL or to programs for which source code is unavailable. Dynamic changes to such programs may be made by creating an interface for the program to make the program compatible with an object-oriented programming system, such as Java.","Communication services within and between distributed applications may be implemented equally well with other types of distributed protocols other than Java RMI, such as, for example, the Common Object Request Broker Architecture (CORBA) standard designed by the Object Management Group consortium. CORBA is the Object Management Group's answer to the need for interoperability among the rapidly proliferating number of hardware and software products available today. Simply stated, CORBA is an ORB that allows applications to communicate with one another no matter where they are located or who has designed them.","An ORB is the middleware that establishes the client-server relationships between objects. Using an ORB, client can transparently invoke a method on a server object, which can be on the same machine or across a network. The ORB intercepts the call and is responsible for finding an object that can implement the request, pass it the parameters, invoke its method, and return the results. The client does not have to be aware of where the object is located, its programming language, its operating system, or any other system aspects that are not part of an object's interface. In so doing, the ORB provides interoperability between applications on different machines in heterogeneous distributed environments and seamlessly interconnects multiple object systems.","In fielding typical client\/server applications, developers use their own design or a recognized standard to define the protocol to be used between the devices. Protocol definition depends on the implementation language, network transport and a dozen other factors. ORBs simplify this process and provide flexibility. They let programmers choose the most appropriate operating system, execution environment and even programming language to use for each component of a system under construction. More importantly, ORBs allow the integration of existing components. In an ORB-based solution, developers simply model the legacy component using the same interface that they use for creating new objects, then write \u201cwrapper\u201d code that translates-between the standardized bus and the legacy interfaces.","CORBA is an ORB that represents an important advance towards object-oriented standardization and interoperability. With CORBA, users gain access to information transparently without having to know on which software or hardware platform the information resides or where it is located within a network. The goal in CORBA object development is the creation and registration of an object server, or simply server. A server is a program, which contains the implementation of one or more object types and which has been registered with the ORB.","CORBA details an object bus that lets objects communicate across enterprises and even continents. CORBA was designed to allow intelligent components to discover each other and inter-operate on an object bus. However, CORBA goes beyond just inter-operability. It also specifies an extensive set of bus-related services for creating and deleting objects, accessing them by name, storing them in persistent stores, externalizing their states, and defining ad-hoc relationships between them.","With the release of JDK version 1.1, Java has its own, built-in native ORB, called RMI. Though RMI is an ORB in the generic sense that it supports making method invocations on remote objects, it's not a CORBA-compliant ORB. RMI is native to Java. RMI is, in essence, an extension to the core Java language. RMI depends on many of the other features of Java-object serialization, portable, downloadable object implementations, and Java interface definitions, among others. On the other hand, RMI has some limitations\u2014the principle limitation being a consequence of its greatest strength\u2014its tight integration with Java makes it impractical for use with objects or applications written in any other language.","Java, with RMI by extension, is a concrete programming technology. It is primarily designed to solve the problems of writing and organizing executable code. As such, it constitutes a specific point in the space of programming technologies. The chasm that exists between Java and other programming languages is sometimes difficult to cross. The techniques used to make a call from Java code to Ada code are somewhat different from those used to make a call from Java code to C++ code, etc. This causes the complexity of building systems in a multilingual environment to increase significantly, sometimes non-linearly, with the number of languages being used.","Java supplies an API called JNI, or Java Native Interface, that allows Java code to call and be called by routines in other languages. It is primarily geared toward inter-operating with C and C++, and it is rather difficult interface to master. RMI is a Java-to-Java technology. If you want a Java client to use RMI to communicate with a remote object in another language, you must do it by way of a Java intermediary that is co-located with the \u201cforeign\u201d remote object. The underlying problem here is that Java is a programming technology that, by definition, works within the boundaries of the language itself.","By contrast, CORBA is an integration technology, not a programming technology. It is specifically designed to be the glue that binds disparate programming technologies together. CORBA does not exist as a point in the programming space by design, it occupies the spaces between the points representing individual languages. When a Java client uses CORBA technology to communicate with a C++ object, for example, both the C++ programmer and the Java programmer work completely within their respective language environments. The CORBA ORB presents the Java client with a Java stub interface and the C++ programmer with a C++ skeleton interface. CORBA resolves the cross-language issues automatically.","CORBA offers an integration-oriented point of view, where design efforts focus on the boundaries between elements of the system. The underlying interface technologies (e.g., IIOP) are designed to make those boundaries as flexible, adaptive, and programming technology-independent as possible. Interface technologies, such as CORBA, not only have longer half-lives than programming technologies, they are the best defense against the adding and death of applications due to dependence on obsolete programming technology.","With reference now to , a diagram illustrates a prior art distributed application using the CORBA standard. Client object  communicates with CORBA server  using the IIOP standard illustrated as communication link . CORBA server  provides integration and interoperability for disparate types of software objects. JavaBean , C++ object , Enterprise JavaBean (EJB) , and COBOL object  communicate and register with service functions using the CORBA services provided by server . Client object  may invoke functions and methods provided by objects \u2013 through the CORBA services.","With reference now to , a diagram depicts the components within a prior art distributed application that uses CORBA to provide interoperability functions.  shows method request  sent from client  to a CORBA object implementation in a server. A client is any code, perhaps itself a CORBA object, that invokes a method on a CORBA object. Servant  is an instance of the object implementation the actual code and data that implements the CORBA object.","Client  of a CORBA server object has object reference  for the server object and the client uses this object reference to issue method request .","An object reference is the information needed to specify an object within an ORB. Clients typically obtain object references in a few different ways. First, a client can invoke a \u201ccreate\u201d method on an object in order to create the object. The create method would return an object reference for the new object to the client. Second, a client could obtain an object reference by issuing a request to a naming service. A naming service stores object references by name in a data structure, and a client may lookup or resolve object references by the object's associated name rather than some type of hardcoded network address, i.e., locate an object within the same physical machine or elsewhere on the network. Finally, a client may obtain an object reference from a string that was specifically created by stringifying an object reference.","Once an object reference is obtained, the client narrows the CORBA object to its proper type so that the client can invoke on it.","If the server object is remote, the object reference points to stub function , which uses the ORB machinery to forward invocations to the server object. A CORBA client needs a local ORB object to perform all of its data marshalling and IIOP work. The stub code uses ORB  to identify the machine that runs the server object and asks that machine's ORB  for a connection to the object's server . When the stub code has the connection, it sends the object reference and parameters to skeleton code  linked to the destination object's implementation. The skeleton code transforms the call and parameters into the required implementation-specific format and calls the object. Any results or exception are returned along the same path.","The client has no knowledge of the CORBA object's location, implementation details, nor which ORB is used to access the object. Different ORBs may communicate via Internet InterORB Protocol (IIOP) .","A client may only invoke methods that are specified in the CORBA object's interface. An interface defines an object type and specifies a set of named methods and parameters as well as the exception types that these methods may return. A client of a server object has access to an object reference for the server object and invokes operations on the object. A client object knows only the logical structure of the server object according to its interface and experiences the behavior of the server object through method invocations. It is important to realize that the client-server relationship is relative to two particular objects the implementation of one server object may be a client of other server objects.","The stub and skeleton files are generated in a variety of ways. Stub files present the client with access to server methods in the client programming language. The server skeleton files glue the object implementation to the ORB runtime. The ORB uses the skeletons to dispatch methods to the object implementation instances (servants).","Turning now from the discussion of the prior art to a discussion of the present invention, the descriptions of  provide details of the present invention for combining the advantages of Java and CORBA. As noted previously, RMI is a Java-to-Java technology that mandates that a Java client must use RMI to communicate with a remote object. Java is a programming technology that, by definition, works within the boundaries of the language itself. By contrast, CORBA is an integration technology, not a programming technology. The present invention allows a Java client to invoke the business methods of an EJB residing on a CORBA client.","With reference now to , a block diagram depicts the components that may be used to implement a method for invoking remote business methods of an Enterprise JavaBean running in a CORBA server. The system in  is similar to the systems shown in .  is similar to the distributed application shown in  except that client  and server  are specifically enabled with a Java runtime environment that contains JVM  and JVM .  is similar to  because Java client object  is attempting to invoke a method within remote EJB  similar to client  and server .","In addition, the distributed application in  comprises ORB  and ORB  for communicating object requests and responses across IIOP . The generic architecture of  comprising a client, a server, stubs, and skeletons, and object request broker is reflected in the software architecture of  that allows Java objects to communicate using CORBA according to the method of the present invention.","JVM  comprises Java client object  that is attempting to invoke a business method residing in EJB . The Java virtual machine (JVM) is a virtual computer component that resides in memory. In some cases, the JVM may be implemented in a processor. The JVM allows Java programs to be executed on a different platform as opposed to only the one platform for which the code was compiled. Java programs are compiled for the JVM. In this manner, Java is able to support applications for many types of data processing systems, which may contain a variety of central processing units and operating systems architectures.","To enable a Java application to execute on different types of data processing systems, a compiler typically generates an architecture-neutral file format\u2014the compiled code is executable on many processors, given the presence of the Java run-time system. The Java compiler generates bytecode instructions that are non-specific to a particular computer architecture. A bytecode is a machine independent code generated by the Java compiler and executed by a Java interpreter. A Java interpreter is a module in the JVM that alternately decodes and executes a bytecode or bytecodes. These bytecode instructions are designed to be easy to interpret on any computer and easily translated on the fly into native machine code.","JVM  also comprises adapter  that provides EJB interface  to client object  so that client object  may call a method in EJB interface  using the known method of remote method invocation. EJB interface  calls CORBA proxy  to initiate CORBA communication with server . CORBA proxy  passes an object request to ORB . In this example, ORB  is implemented in Java. If the ORB was implemented in C++, then the object request would pass through a Java Native Interface (JNI). ORB  and ORB  communicate across IIOP  to ensure that object requests are transparently supported by the client and server objects using the object request broker. Once ORB  receives an object request, code within EJB skeleton  is called to begin the invocation of the requested business method from EJB . EJB skeleton  uses JNI  to invoke EJB  and pass the appropriate arguments to EJB  contained within JVM . In this particular example, EJB skeleton  may be implemented in C++ but could be implemented in another language other than Java that would require the use of JNI .","With reference now to , a block diagram depicts the components that may be used to implement a method for invoking remote methods of a server object. The system in  is similar to the system shown in  except that it has been generalized for an environment in which client  has client object  implemented in one language and server  has server object  implemented in a different language.","Client  comprises adapter . An adapter uses object reference  to simulate a remote method invocation on server object  on behalf of client object . Client object  invokes a method within adapter , which calls object reference  to initiate object communication with server . Object reference  passes an object request through data marshalling module  to object dispatcher . Object dispatcher  and object dispatcher  communicate across object communication link  to ensure that object requests are transparently supported by the client and server objects using an appropriate object request protocol. Object dispatcher  passes an object request through data marshalling module  to remote call skeleton . Data marshalling module  and data marshalling module  provide appropriate data conversion and call translation facilities for the interoperable environment consisting of objects implemented in different languages. Remote call skeleton  invokes the method in server object  and passes the appropriate arguments to server object .","With respect to , a flowchart depicts the steps of a method for invoking a remote business method on an Enterprise JavaBean running in a CORBA server. The process flow from the Java client object through the Java adapter, ORB, and EJB skeleton to the desired EJB, as described with respect to , is similar to the process flow further described in , which describes actual calls and class manipulations within the Java and CORBA environment of the present invention.","The process begins when code within the client looks up the name of a remote object (step ). The client may require the execution of a method of an object in a remote server, such as a business method within an EJB. The code within the lookup method finds the name of a CORBA proxy that corresponds to the remote object containing the desired method (step ). After an appropriate CORBA proxy is found, a suitable adapter class is located for its corresponding CORBA proxy (step ). The CORBA proxy is wrapped with the suitable adapter class (step ), and the adapter class is returned to the calling client code as a generic object (step ). The client code typecasts the returned generic object to the necessary class type (step ). The client code then calls the desired method from the newly obtained object (step ), and the desired method in the newly obtained adapter class is invoked (step ). The code within the invoked adapter class method calls its corresponding method in the CORBA proxy (step ). Once the method begins executing within the CORBA proxy, the CORBA infrastructure handles the invocation of the remote object corresponding to the CORBA proxy on the CORBA server (step ).","The method steps of  may be generalized for the object-oriented environment shown in . Rather than invoking a method of an EJB through a CORBA proxy, the source object and target objects have been generalized to a method of a server object being invoked through its object reference. According to the generalized method of the present invention, the object reference for the server object is wrapped with an adapter so that the client object's invocation of a method in the server object is transparently handled by an adapter. When the client object attempts to invoke a method of the server object, the method is actually invoked within an adapter object. The adapter class essentially wraps the object reference in a manner such that the object reference is isolated from the client code. The client does not know anything about the object reference. The client only \u201ctalks\u201d to the adapter code whereas the object reference that \u201ctalks\u201d to the skeleton code on the server does not know anything about the client-based adapter.","With reference now to , examples of Java programming language statements are shown that describe a distributed application in which a Java client invokes a remote business method from an Enterprise JavaBean running in a CORBA server. In , an example shows the standard RMI technique in a Java program. A remote object of the CustomerImpl class may have a set of business methods represented by an interface CustomerInterface. Methods included within CustomerInterface can be invoked remotely from a Java client. In this case, the client code would appear similar to statements \u2013. Statement  shows the use of a naming service to obtain an object reference for a remote object. Object \u201cobj\u201d is an RMI proxy of the remote Java object that implements CustomerInterface. After obtaining an object reference in statement , the object is narrowed by typecasting it to the appropriate object type in statement . In statement , the Java client code calls a business method on the proxy object as if it were a local object. The client is unaware that the call is implemented using an ORB. The proxy object transfers the method call to the remote object in a manner defined by the CORBA standard.","According to a method of the present invention, the RMI behavior within Java is simulated using the CORBA mechanism for executing remote objects. A special NamingContext and a set of adapter classes are implemented as shown in . The lookup method in the special NamingContext class is implemented as shown in . Statement  shows the definition of the special lookup method. Statement  shows that a lookup method within the CORBA naming services is used to find a CORBA proxy corresponding to the desired remote object in statement . Once the CORBA proxy is found, statement  creates a new adapter class. Statement  shows that a CORBA proxy is wrapped by the suitable adapter class. Statement  shows the return of an object reference as a return value from the lookup method.",{"@attributes":{"id":"p-0083","num":"0082"},"figref":["FIG. 9C","FIG. 9A","FIG. 9B"],"b":["922","924","926"]},{"@attributes":{"id":"p-0084","num":"0083"},"figref":"FIG. 9D","b":["930","932"]},"The adapter class must implement the business interface supported by the EJB on the CORBA server. The adapter class essentially wraps the CORBA proxy in a manner such that the CORBA proxy is isolated from the Java client code. It is important to note that the Java client does not know anything about the CORBA proxy. The Java client only talks to the Java-based adapter code whereas the CORBA proxy that talks to the skeleton code on the CORBA server does not know anything about the Java-based adapter.","In the examples shown in , the arguments for the business method of the remote object are simply passed from the adapter to the proxy object. No data conversion for the arguments are shown. If a business method takes or returns an EJB as an argument, it is the duty of the adapter code of that business method to perform appropriate wrapping or unwrapping of the proxy object by a suitable adapter as necessary. In the example, a business method is invoked for a CustomerInterface class without expecting a return value.","In an example in which a business method takes an integer and an EJB as arguments and returns an EJB as a return value, the EJBs must be wrapped and unwrapped.","With respect to , examples of Java programming language statements describe a process of wrapping and unwrapping EJBs used as arguments to Java methods.  is an example of a declaration of a Java business method that takes an integer and an EJB of type\u201cEmployee\u201d as arguments and returns an EJB of type \u201cCustomer\u201d as a return value.",{"@attributes":{"id":"p-0089","num":"0088"},"figref":["FIG. 10B","FIGS. 9B\u20139D","FIG. 10B"],"b":["1010","1","1012","1","1014","1016"]},"When a business method is invoked on the adapter by a Java client by passing in the employee EJB as an argument, which in this case is an adapter object that implements an \u201cEmployee\u201d interface, the adapter code unwraps the adapter from \u201cEmployee ee\u201d and passes the CORBA proxy inside it over the ORB. Similarly, the resulting return value returned across the ORB actually contains a CORBA proxy of the customer EJB. In this case, the adapter code wraps the return proxy with a suitable adapter before sending it back to the client.",{"@attributes":{"id":"p-0091","num":"0090"},"figref":["FIG. 10C","FIG. 9D","FIG. 10C"],"b":["1020","1022","1024","1026","1028","1030"]},"With reference now to , a flowchart depicts the wrapping and unwrapping of EJB arguments with suitable adapters according to the method of the present invention. The process begins when a client object calls a business method and passes various arguments into the business method (step ). In this case, the client invokes a method within the adapter class that is implementing the interface for the business method of the remote EJB on a CORBA server. The adapter parses the list of arguments for the business method (step ) and performs data conversion on the argument if necessary (step ). A determination is then made as to whether the argument represents an EJB, which in this case would be the CORBA proxy for the EJB wrapped by an adapter (step ). If so, then the adapter code unwraps the adapter from the EJB argument and obtains the CORBA proxy (step ).","If the argument is not an EJB, the process continues to the determination of whether there are more arguments to be processed for this method call (step ). If so, the process returns to step  to obtain the next argument. If there are no more arguments, then the adapter delegates the method call to the CORBA proxy representing the EJB across the ORB (step ).","A determination is then made as to whether there is a return value for the called CORBA proxy (step ). If not, then the adapter completes execution and returns control flow to the client code (step ). If there is a return value, a determination is then made as to whether the return value is an EJB proxy (step ). If not, then the return value is returned as a result value to the client (step ). If the return value is an EJB proxy, then the adapter wraps the returned proxy with a suitable adapter (step ) before returning the results to the client (step ). The process then completes with the client code continuing its execution (step ).","The advantage of the present invention should be apparent with reference to the detailed description of the figures given above. Java provides a mechanism by which a Java client can invoke methods on Java server that is running in a separate process using a methodology called Remote Method Invocation (RMI). However, if the server is not running in a Java environment, such as a CORBA compliant server, then the Java client cannot make any method calls to the method on the server since Java does not provide an inherent mechanism for communicating with CORBA objects. There is also no standard mechanism for performing data marshalling, i.e., data conversion for different types of data, between a Java client and a CORBA server. These methods may involve passing references to other EJBs running on other servers. There is no standard mechanism that allows a Java client to communicate with another Java application, such as an EJB, running in a non-Java environment, such as a CORBA server.","The present invention uses adapters that are generated by introspecting on the interfaces of the Enterprise JavaBean running in the CORBA server. These adapters reside on the Java client-side and carry within them a remote proxy of the CORBA server that runs the EJB. An adapter is a Java class that implements the interfaces specified by the EJB for invoking its business methods. Adapters delegate all of the business method calls from the client to the CORBA proxy on the server and perform data marshaling from the Java client to the CORBA proxy and vice versa.","From the perspective of the client object, an adapter is a replica of an EJB that actually resides on the CORBA server. The client object is not even aware that it communicates with the EJB across an object request broker to the CORBA server. An adapter stores in itself a CORBA proxy of the server that runs the EJBs. Any business method call made by the client to the adapter is delegated by the adapter to the CORBA proxy after appropriate data conversion. Thus, the adapter acts as transparent glue between the Java client and the EJB on the CORBA server.","It is important to note that while the present invention has been described in the context of a fully functioning data processing system, those of ordinary skill in the art will appreciate that the processes of the present invention are capable of being distributed in a form of a computer readable medium of instructions and a variety of forms and that the present invention applies equally regardless of the particular type of signal bearing media actually used to carry out the distribution. Examples of computer readable media include recordable-type media such a floppy disc, a hard disk drive, a RAM, and CD-ROMs and transmission-type media such as digital and analog communications links.","The description of the present invention has been presented for purposes of illustration and description, but is not limited to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain the principles of the invention the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The novel features believed characteristic of the invention are set forth in the appended claims. The invention itself, however, as well as a preferred mode of use, further objectives and advantages thereof will best be understood by reference to the following detailed description of an illustrative embodiment when read in conjunction with the accompanying drawings, wherein:",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 7A"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 7B"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIGS. 9A\u20139D"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIGS. 10A\u201310C"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 11"}]},"DETDESC":[{},{}]}
