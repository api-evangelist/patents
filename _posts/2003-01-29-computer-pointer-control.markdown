---
title: Computer pointer control
abstract: The present invention relates to a method and system which allows for the transfer of pointer movements and events from small devices with space and data rate constraints to a display device. This will allow a pointer device to be implemented in a small area, but will still enable full pointer movement and event capabilities.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07109975&OS=07109975&RS=07109975
owner: Meta4Hand Inc.
number: 07109975
owner_city: Edmonton
owner_country: CA
publication_date: 20030129
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF INVENTION","SUMMARY OF INVENTION","DETAILED DESCRIPTION"],"p":["The present invention relates to a method and system for controlling the movement of a computer pointer.","The development of low-power, compact, mobile remote control devices has fostered a need for the development of methods of sending pointer and control information to a display device.","The original pointer controller, now referred to as a \u201cmouse\u201d, was developed in 1964 and has since become one of the primary input devices for a multitude of different computer systems and the dominant input device for personal desktop computing. The mouse, in its current form, works well for situations where there is sufficient room for the movement of the mouse device (approximately one square foot). However, it does not work well for situations where there is very little room for hand movements, such as on a laptop or handheld computer. The prior art describes a variety of different pointer controllers, some of which have been realized into commercial products and many of which have not. Two notable controllers are designed for compact situations and have been embodied in commercial products. One is a joystick-like device, which is located on the keyboard and works in response to lateral directional pressure placed on it by a user. Click information is provided by a separate button. The other is a touch pad, which works by tracking the pressure, direction and velocity of touch movements (finger or stylus) and relaying this information to the computer. The pointer movement mimicks the movement of the finger or stylus.","However, all of these devices have the disadvantage of requiring special hardware and requiring a constant transmission of data. This is fine for systems having a direct connection to their computing devices; however, they are not well suited to low-power, portable wireless systems which do not have the substantial resources required.","Therefore, there is a need in the art for methods and systems which permit the sending of pointer data from a low-power, compact pointer controller to a display device.","The present invention is based on the principle that pointer commands and movement do not necessarily have to involve the constant relay of information from the pointer device itself. Therefore it is possible to indicate a direction, magnitude of movement, and a stop indicator which can be controlled by the operator while viewing the pointer movement on the screen. This is very useful for sending pointer movement commands in a space-limited application such as a touch screen similar to that found on a personal data assistant (PDA) or cell phone.","Therefore, in one embodiment, the invention comprises a method whereby when the user first touches the control surface, using a finger or stylus, the x and y coordinates of that point are stored into the memory of the system and a timer is started. The point of initial contact becomes the centre coordinate (0,0). Thus, it does not matter where the user initially applies pressure.","If the user removes pressure before the timer expires, then a \u201cclick\u201d event is generated; otherwise, continued pressure will indicate that the operator wants to initiate or continue a pointer movement. For the purpose described herein, a click event is defined as either the simulation, or the physical act, of pressing down and releasing a button and is intended to be the equivalent of a \u201cmouse click\u201d. If pressure is maintained on the surface of the pad, and the user moves the pressure point away from the centre point, the angle and distance of the pressure point from that centre point is continuously calculated by the controller device.","In one embodiment, the system sets up a polar grid projecting away from the centre point in all directions. The grid is defined by directional lines which radiate outwardly from the centre point to divide the grid into directional zones. Substantially circular lines intersect the directional lines to create annular velocity zones. The polar grid therefore is analogous to a dart board with the centre point being equivalent to the \u201cbulls eye\u201d. An individual sector therefore corresponds to a direction and a velocity. Only when the user moves from one sector of the grid to another will the system actually transfer the data to the other system. If pressure is maintained within one sector, then the last transmitted angle and velocity are maintained.","Essentially, the user starts the pointer off in an initial direction with an initial velocity and thereafter moves it into other directions and\/or velocities, by scales of magnitude associated with each sector of the grid, until the pointer gets to where the user wants it. At this point, the user will release the pressure on the pad and a stop command is transmitted to terminate movement of the pointer.","Fine pointer control may be provided by increasing the number of sectors by increasing either or both of the number of directional zones or the number of velocity zones. If pressure is maintained, and the user moves further away from the centre point, the screen pointer direction movements will get coarser as velocity increases relative to the distance from the centre point. The screen pointer can therefore move a greater distance more quickly with only a relatively small movement along the pressure grid of the controller.","As the user applies pressure back towards the centre point, the screen pointer\u2033s velocity will slow and accuracy will be restored. For example, if the user wants to quickly move the screen pointer across the screen, the user will venture further away from the centre point in the direction they want to go and a fast, but coarse, screen pointer movement will result. If the user wishes to home the screen pointer in on a specific point on the display, they will stay very close to, or return to, the centre point and slow but accurate movements will result.","It is preferred, but not necessary, that the directional lines be equally spaced apart, thereby creating directional zones of equal size. However, it may be preferred, but not necessary, that the velocity zones be unequally spaced. In one embodiment, the slower velocity zones nearer the centre point are tightly bunched while the faster zones are larger. As well, the relationship between the velocity assigned to a point and distance to the centre point need not be linear.","To stop movement of the pointer, the user disengages touching the pad resulting in a stop command being sent to the display device. Therefore, if the user stops movement on the pad, but maintains pressure on the pad, the screen pointer on the display device will still continue to move in the last direction transmitted and with the velocity specified by that transmission. Only when the user stops touching the pad does the screen pointer on the display stop moving.","The pad movement calculation is triggered whenever the user has moved a far enough distance along the pad that a discernable unit (sector) difference is now identified by the controller. This could be a movement from one pixel (or twip) to another or could be a voltage level change from a pressure sensor. The movement calculation involves the use of trigonometric functions to determine a distance and angle away from the centre point. This distance and angle may then be normalized and a sector. coordinate given that represents a fixed velocity and direction.","Most pointers include not only the ability to move the screen pointer but also the ability to click on and move objects. These events require one or more buttons. These buttons can be actual buttons or an area of the pad designated to act like buttons in order to provide for the transmission of button events such as button click, button down and button up. On a touch screen, the buttons may be represented as graphics on the screen and the pad may be any section of the screen in which the method described here is implemented.","Therefore, in one aspect, the invention may comprise a method of providing user input to a computer, including control of pointer and click events, comprising the steps of:","(a)defining a contact-sensitive sensor area;","(b)establishing an initial x-y coordinate for an initial contact point wherein such contact may then be moved while remaining in contact with the sensor area to a second x-y coordinate;","(c)calculating the distance r and the angle \u03b8 between the first and second x-y coordinates;","(d)correlating the angle \u03b8 to a direction of pointer movement and correlating distance r to a velocity of pointer movement;","(e)creating a signal to move or click the pointer, said signal including velocity, direction, and click information.","In another aspect, the invention may comprise a method of controlling a pointer on a display screen of a computing device, including click events, comprising the steps of:","(a)sending a signal combining event type data, directional data and velocity data to control the pointer;","(b)causing the pointer to move in accordance with the signal until a new signal is sent, wherein a new signal is sent only upon a change in one or more of event type data, directional data or velocity data comprising the signal.","In another aspect, the invention may comprise a system for controlling a pointer in a computer system, comprising:","(a)a contact-sensitive sensor area associated with a Cartesian coordinate grid;","(b)means for calculating the distance r and the angle \u03b8 between any two points in the grid;","(c)means for correlating the angle \u03b8 to a direction of pointer movement and distance r to a velocity of pointer movement;","(d)means for creating a signal to move or click the pointer, said signal including velocity, direction, and click information.","In another aspect, the invention may comprise a system for controlling a pointer on a display screen of a computing device, including click events, comprising:","(a)means for sending a signal combining event type data, directional data and velocity data to control the pointer;","(b)means for causing the pointer to move in accordance with the signal until a new signal is sent, wherein said new signal is sent only upon a change in one or more of event type data, directional data or velocity data comprising the signal.","A computing system which includes the pointer control system of the present invention will include a display device () which typically comprises a display screen (). This display () could be an LCD, CRT, projection, or any other device that provides visual feedback and is exemplified by a CRT computer monitor. The other device that is required is a pointer device () which may be a handheld computer, cell phone or a personal digital assistant (PDA). This device must have a contact-sensitive sensor area that allows input of pointer commands () and could be a touch pad, joystick, or as shown in , a touch screen (). As used herein, a \u201ccontact-sensitive sensor area\u201d means any pre-defined or user defined area where contact and\/or movement may be sensed by any means. One embodiment described herein will refer to a pointer area referred to hereafter as a \u201cpad\u201d or \u201ctouch pad\u201d having a rectangular shape and area.","The methods of the present invention may be implemented in the pointer device as software embodied as an application running inside an operating system, an embedded application, or as firmware encoded on a processor. Hardware, which could be any logic device, synchronous or asynchronous, that is capable of running the software, may be referred to herein as a system. In one embodiment, an integrated circuit could be designed to incorporate all of the hardware and software into a single chip.","An implement () must also be used to apply pressure to the pad to indicate movement. This could be a finger, or as shown in , a touch screen stylus as is commonly seen on PDAs. As well, there must be some type of communications interface () between the two devices which could be a wired or wireless connection using any protocol whatsoever. The output from the pointer device () is processed by signal processing circuits or software which provides outputs for the pointer control circuit or software associated with the display ().","When the user presses on the pad () with the implement (), and moves the implement () in a direction away from the point of first contact (), the pointer () on the display device () will move accordingly in the same direction () as the movement on the pointer device (). The velocity of this movement () is controlled by the distance between the last position of the implement and the point of first contact. The velocity will change as the implement is moved further away or closer to the point of first contact. If the user stops moving the implement (), but still has contact with the pad (), the pointer () will continue moving in the same direction (), but will maintain a constant velocity. If the user lifts the implement () from the pad (), the pointer () will stop moving.","To accomplish the above movement, when the user first touches the pad (), the Cartesian coordinates of that point of first contact are stored as X () and Y () and (X,Y) defines the centre point (). Some systems with very small pad surfaces () may require the use of constant X () and Y () values and, therefore, a constant centre point (). Coincidental with the storage of (X,Y), a timer is also initiated on first contact. If the implement () is removed from the pad () prior to the timer expiring, a button click event will be sent and no pointer () movement will be initiated. This latter event is equivalent to the left-mouse button click on a standard computer mouse. The timer may be set or adjusted by the user for an appropriate length of time.","The pad () is divided into a Cartesian grid of which there may be a plurality of different points all of which can be represented by x and y values. These points may correspond to individual pixels on an LCD touch screen.  shows the trigonometry of the centre point () and a new point x,y (). As the user moves away from the centre point (), the current x () and y () values of the new point () are used to calculate the angle \u0398 () and distance r () away from the centre point (). Angle \u0398 () determines the direction of pointer movement and distance r () determines the speed of pointer movement.","Angle \u0398 () is determined by the magnitude of rise Dy () and the run Dx () from the centre point (), as shown in Equation 1.\n\n\n\n\u2003\u2003(1)\n","In order to ensure the successful calculation of the angle \u0398 (), a test is made to ensure that Dx () is non-zero as the Arc Tangent function will fail if the Dx () value is zero. If the value of Dx (27) is zero, then the value of the angle (26) will be 90\u00b0 if the value of Dy () is positive, and will be 270\u00b0 if the value of Dy () is negative. For all other values where Dx () is non-zero, Equation 2 will give the value of the angle \u03b2 (in degrees) from the nearest reference axis.",{"@attributes":{"id":"p-0053","num":"0052"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"\u03b2","mo":"=","mrow":{"mrow":{"mi":"arctan","mo":"\u2061","mrow":{"mo":["(",")"],"mfrac":{"mi":["Dy","Dx"]}}},"mo":"\u00d7","mfrac":{"mn":"180","mi":"\u03c0"}}}}}},"The angle \u03b2 will be the same as angle \u03b8 () when both the Dx () and Dy () values are positive; however, when both values are not positive the angle \u03b8 () can be derived from angle \u03b2 using basic trigonometric principles. Therefore, the logic tree in Equation 3 will provide the correct angle \u03b8 () referenced to the positive x-axis.",{"@attributes":{"id":"p-0055","num":"0054"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if Dx > 0then","(3)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if Dy > 0then"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u03b8 = \u03b2"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u03b8 = 360 + \u03b2"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"end if"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u03b8 = 180 + \u03b2"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"end if"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Equation 3 essentially checks to see which quadrant the point is in and then uses the known sign to calculate the angle \u03b8 (). If both Dx () and Dy () are positive, then the point () is in quadrant I and the angle \u03b8 () is equal to angle \u03b2. If Dx () is positive and Dy is negative, then we know that the point () is in the IV quadrant and that the angle \u03b2 is negative. Therefore, if we add 360\u00b0 we will obtain the angle \u03b8 (). For the case where the point () is in quadrants II or III, the angle \u03b8 () will be calculated by adding the value of \u03b2 to 180\u00b0. The arc tangent function will produce a negative angle whenever the signs of Dx () and Dy () differ, or, stated another way, whenever the point is in quadrants II or IV. Therefore, if the point is in quadrant II, the angle \u03b2 will be negative. Therefore, adding 180\u00b0 will produce the angle \u03b8 () somewhere in between 90\u00b0 and 180\u00b0. If the point is in quadrant III, the angle \u03b2 will be positive. Therefore, adding 180\u00b0 will produce the angle \u03b8 () somewhere between 180\u00b0 and 270\u00b0.","After the angle \u03b8 () has been calculated, the distance r () from the centre point () to the current point () must be calculated. This distance r () is easily calculated using Pythagoras\u2033s theorem and the calculation is shown in Equation 4.\n\n\u2003\u2003(4)\n","Distance r may be correlated to velocity of the pointer by a pre-determined formula or by a look-up table. In its simplest form, velocity may equal r multiplied by a constant, which creates a linear relationship between r and velocity. In one embodiment, shown in , distance r is normalized by creating annular velocity zones () with concentric circles having the common centre point. The acceleration between velocity zones (), and across an acceleration point, () is defined as instantaneous and can be described by a unit step function. The length of velocity zones (), or the space between acceleration points (), is called the velocity factor \u03a6. In one embodiment, the factor is calculated by taking the length of the screen () from corner to corner () and dividing it by twice the number of acceleration points (). This number is then used to normalize the distance r. For linearly spaced acceleration points () as shown in , the following formula can be used:",{"@attributes":{"id":"p-0059","num":"0058"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mi":["Velocity","Zone"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"mfrac":[{"mi":"Distance","mrow":{"mi":["Velocity","Factor"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}},{"mi":["r","\u03a6"]}],"mo":"="}],"mo":"="}},{"mrow":{"mo":["(",")"],"mn":"5"}}]}}}}},"Alternatively, the velocity factor \u03a6 may be variable resulting in non-uniformly spaced acceleration points () as shown in . In , the acceleration points are spaced farther apart as the distance r from the centre point increases and velocity increases. In , the acceleration points are spaced further apart as distance r increases to a point where the spacing becomes smaller as distance r increases.","In another alternative embodiment, velocity may increase as distance r increases to a maximum value at which point velocity decreases as distance r increases.","Alternatively, non-linear velocity gradients may be provided using uniformly spaced acceleration points combined with velocity set points which increase non-linearly. Therefore, in one embodiment, finer speed control is possible by making a gradient of velocity zones () such that there is a smoother transition between zero velocity and maximum velocity. There will be a large number of acceleration points (). This would require more computation, but would provide the user maximum flexibility in movement.","In each of the embodiments described above, distance r is translated to a velocity without regard to the direction of travel. Thus, the velocity zones are circular and concentric about a common centre point. However, in alternative embodiments, the velocity zones may be oval shaped or some other non-circular shape as is illustrated in . Or the velocity zones may be circular but not concentric, as is shown in . In these cases, as one skilled in the art will realize, the calculation of velocity from distance r must also factor in a directional component.","With the direction and velocity (or velocity zone ()) calculated, that information must now be transferred to the display device. The simplest way to transfer this data would be to send both the direction and the velocity. However, this data may contain floating point values and may require the transfer of several bytes of data. In one embodiment, it is preferred to condense both the direction and magnitude such that the data can be put into a single byte; however, some degree of precision is sacrificed.","The first accuracy adjustment is to send a normalized angle instead of the exact angle as illustrated in . This will involve a normalization calculation where the calculated angle () is normalized by dividing the angle () by a predefined sector size Y ().",{"@attributes":{"id":"p-0066","num":"0065"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mi":"N","mo":"=","mfrac":{"mrow":[{"mi":"Angle","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},"mrow":{"mo":["(",")"],"mi":"\u03b8"}},{"mi":["Sector","Size"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mrow":{"mo":["(",")"],"mi":"\u03b3"}}]}}},{"mrow":{"mo":["(",")"],"mn":"6"}}]}}}}},"Where N is the normalized direction, angle \u0398 () is the value calculated above and the sector size Y () is the number of degrees per direction sector (). The sector size Y () is calculated by taking 360 degrees and dividing it by the total number of divisions M.",{"@attributes":{"id":"p-0068","num":"0067"},"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":{"mi":["Sector","Size"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mrow":{"mo":["(",")"],"mi":"\u03b3"}},"mo":"=","mfrac":{"mn":"360","mrow":{"mi":["Number","Of","Divisions"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mrow":{"mo":["(",")"],"mi":"M"}}}}},{"mrow":{"mo":["(",")"],"mn":"7"}}]}}}}},"Therefore, in the example given in  there are 32 divisions throughout the circle and, thus, the sector size () would be 360\/32 or 11.25\u00b0. Now, if the point () had an angle () of 25\u00b0, then the normalized direction N equals 25\/11.25 or 2.22. It therefore would be increased to the next largest whole number and thus the normalized direction would be 3. This results in the point () being in the third directional sector () and in the third velocity zone ().","If a large number of velocity zones () are used, then the velocity zone may need to be normalized as well. This could be done during the velocity zone calculation or afterwards by dividing the velocity zone by a normalization factor.","Once velocity and direction information is collected, it must be transferred to the display. It is preferable that such information be transferred in a compact form. In one embodiment, all pointer command information, including velocity and direction, may be included in one byte of data.","The first step in transferring the information using a single byte is to make sure that both the vector zone () and normalized direction are integer values with no floating-point components. This conversion can be performed by rounding, truncation, or increasing the number to the next largest integer value (this can be performed by truncating the value and adding one). This loss of accuracy will not be noticeable by the user as long as the sector size () is optimized for both usability and data transfer which involves using as many divisions as possible without overflowing the space allocated for the data.","Most pointer devices also include one or more buttons and this control information must be transferred as well. Essentially there are three types of button events: up, down, and click. Although a click event can be described as a down event immediately followed by an up event, often it is easier to send a click as a separate event. The click event is determined by a down event and an up event that occurs within a certain time period. Essentially, when a down event occurs, a timer is started. If the up event occurs before the timer expires, then the user intended a click to occur and a click event is passed to the display. If the timer expires, then a down event is sent to the display. When the user releases the button, an up event is sent to the display. In a touch screen device, if the user presses on the touch screen for less than the timer period, it will be recorded as a click event for the more commonly used button (on two button systems this will normally be the left button).","Now that all of the data is ready (direction, magnitude, and button events), that data can now be transferred. As mentioned previously, the data could be sent as several bytes. However, all of the information can be packed into a single byte if the requirements of the data stream are such to require this.","In one embodiment, the pointer control data may be transmitted by:\n\n","To transmit a button event:\n\n","The above allows for the transfer of any pointer movement or button event as a single byte; however, the cost of doing this is that, since the number of sectors () and the number of velocity zones () is minimal, the resulting pointer () movements may be awkward. The transmission of a stop movement, or \u201cstop everything\u201d command, could be to set the data type bit () and clear all the other bits.","When movement data is received, it is broken down into a magnitude () and an angle (). Recovery of the angle () and magnitude () from the sent data can take several forms\u2014which can differ for bandwidth and performance reasons.","To recover pointer movement data, which was encoded with the bit-wise method described above, the type of data must first be determined. This is done by testing the top-most significant bit () and, if it is cleared, then the data indicates a movement; if it is set, then the data represents a button event. The velocity zone (,) can be recovered by masking the byte () with 01100000, or in hexadecimal, 0\u00d760, and bit shifting the resultant value to the right five times. To recover the normalized direction (), the byte () must be masked with 00011111, or in hexadecimal, 0\u00d71F, multiplying this value by the sector size () to recover the normalized direction. These two values can then be used to facilitate a pointer movement using the method outlined below.","The computer code in ANSI C that would allow the recovery of a normalized angle (direction) 112.5\u00b0 and velocity zone (,) 3 from a byte with the binary value 01101010 is:\n\ninput_byte=0b01101010;\n\nsector_size=11.25;\n\ndirection=(input_byte & 0\u00d71F)*sector_size;\n\nvelocity_zone=(input_byte & 0\u00d760)>>5;\n","If the received byte () is a pointer button event, i.e. the data type bit () is set, then the button and event data can be recovered using the same masking technique as shown for the recovery of pointer movements. When pointer button events are received, they are immediately sent to the operating system as such, through standard interface calls. Similarly, a stop command would be immediately sent to the operating system.","An alternate method of encoding the data, that can improve the resolution of the direction and can include more velocity zones () than the bit-wise method, while still using only a single data byte, is outlined below.","The velocity zone () and number of directional divisions (M) should be selected so that the product of the velocity zone () and number of divisions (M) is less than 255 (for one byte) with enough values left to accommodate pointer button events. To prevent the need for another byte for transferring point button event data, there should be a sufficient number of values left in the byte to represent all possible pointer button events. Equation 8 illustrates the calculation of this value.\n\nValue=N+(M\u00d7Velocity Zone)\u2003\u2003(8)\n","To encode any pointer button events, a maximum value for the velocity zone () is set so that enough values in the byte are available to accommodate all of the pointer button events. Pointer button events are then assigned values in the remaining integers. The same would be true for the stop movement event.","To differentiate between pointer button events and pointer movement data, a maximum value is checked. If the value is higher than that maximum, the data indicates that a pointer button event is to be recovered and each number above the maximum would then indicate a certain button event. If the value is lower than that maximum, pointer movement data is recovered. Since the encoded value contains a multiple of the number of divisions (M), dividing the encoded value by the number of divisions (M) and truncating this result will give the velocity zone (,) (Equation 9). The normalized direction (N) is calculated by subtracting the number of divisions (M) times the velocity zone (,) from the encoded value (Equation 10). The normalized angle () is calculated by taking this result and multiplying it by the sector size (y) (Equation 11).",{"@attributes":{"id":"p-0086","num":"0093"},"maths":{"@attributes":{"id":"MATH-US-00005","num":"00005"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mi":["Velocity","Zone"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"mi":"Trunc","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mo":["(",")"],"mfrac":{"mi":["Value","M"]}}}],"mo":"="}},{"mrow":{"mo":["(",")"],"mn":"9"}}]}}}},"br":[{},{}],"in-line-formulae":[{},{},{},{}],"i":["N","M\u00d7Velocity Zone)","N\u00d7y"]},"The above methods of packaging data are only two possible methods. Other methods are possible and are included within the scope of the present invention.","After recovering the velocity zone (,) and normalized angle (), the velocity vector () can be calculated. This velocity vector () can be used to calculate the horizontal () and vertical () change from the current pointer position. The horizontal component, or x component (), is found using Equation 12. The vertical component, or y component (), is found using Equation 13. These components can then be multiplied by scaling factors, which will provide additional velocity to the pointer movements. Different scaling factors for different velocity zones can provide for varying acceleration and adjustments for display resolutions.\n\n=scale factor\u00d7velocity zone\u00d7cos(Normalized Angle)\u2003\u2003(12)\n\n=(\u22121)\u00d7scale factor\u00d7velocity zone\u00d7sin(Normalized Angle)\u2003\u2003(13)\n","It is often necessary to invert the sign of the y component (), because the top left corner of most displays are set to zero coordinates and all of the values right and down from there are positive values. Therefore, the y values increase down the screen.","A vector that indicates a movement up will have a positive y component and if this were added to the current y position, then the net movement would be towards the bottom of the screen opposite to that desired. To compensate for this, often a multiplying factor of \u22121 is used to adjust the y component.","Different velocity zones (,) can be scaled for each movement of the mouse pointer. At each threshold state, a different scaling factor can by multiplied to the velocity zone () to achieve a different net effect allowing control of the pointer movement on the display device at different rates. For example, on a CRT monitor, the factor multiplied to the velocity zone could be increased, as the resolution displayed on the monitor is increased, to give relational movement to the size of the screen. An example of how a single velocity vector can be scaled is shown in .","The velocity zone (,) can be used to create a delay factor for sending inputs to the operating system. A delay factor is necessary for regulating pointer movement at a pace where the user has a reasonable time to react and to control the pointer. The final delay factor can be found by dividing a maximum delay value by the current velocity zone. The maximum delay value is arbitrary, but should be large enough so that the slowest pointer movement is precise. By reducing the delay value, movements will occur more frequently and thus speed of movement is also increased. Alternate methods for delaying movement can also be used.","When several velocity vectors (, , ) are received in succession, the net effect is vector addition of the vectors. Each movement is sent to and interpreted by the operating system, a delay is initiated, and the next vector is added. The pointer movement appears much more fluid in this manner and movement appears predictable to the user. An example of this behavior can been seen in . If a single velocity vector () is received, but no stop command is issued, the pointer continues to move at the initial speed, direction, and velocity zone, as demonstrated in .","Movement is performed using a worker thread on a multi-threaded operating system. The movement thread sends an API (Application Programming Interface) call to the operating system, which tells it to move the pointer\u00d7pixels\/twips horizontally and y pixels\/twips vertically. The thread then pauses for a time period specified by the delay value and repeats until the thread is to be terminated. Each pointer movement is initiated from the end of the last pointer movement. An initial, non-terminated, velocity vector () is recovered and over three loops of the movement thread results in the second net movement.","When movement is initiated on the target device, a worker thread is created on the target device to send successive inputs to the operating system using API calls. These API calls can be interpreted as direct input to the operating system for pointer input. If pointer movement data is received, and a worker thread is already sending pointer movement instructions to the operating system, the velocity zone (, ), direction (), and delay are changed, but the thread is left running. Once a stop movement command is received, the velocity vector () is set to zero and the worker thread is terminated.","In the absence of a multithreading system, any new velocity vectors () would need to be interpreted, and both the x, y and delay values would have to be set before resuming movement of the pointer. The main function loop could have an infinite loop checking for new velocity vector data, as well as moving the pointer when necessary.","It will be readily seen by those skilled in the art that various modifications of the present invention may be devised without departing from the essential concept of the invention, and all such modifications and adaptations are expressly intended to be included in the scope of the claims appended hereto."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":["Embodiments of the invention will now be described with reference to the accompanying drawings in which:",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIGS. 3A","b":["3","3","3","3"]},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
