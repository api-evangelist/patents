---
title: Service monitoring and service problem diagnosing in communications network
abstract: User equipment uses traces of service primitives of one or multiple service sessions to automatically discover a service sequence. Service sequences are refined by analyzing sequences captured during multiple sessions of the same service. A daemon receives from a plurality of user equipment the observed service sequences. The sequences from different user equipment are aggregated. The daemon sends back the refined service sequences to user equipment. User equipment sends a problem report to the daemon and/or a service monitor in the case of a service failure. The daemon or the service monitor aggregates such problem reports and discovers the causes of service degradations.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08873402&OS=08873402&RS=08873402
owner: Telefonaktiebolaget L M Ericsson (publ)
number: 08873402
owner_city: Stockholm
owner_country: SE
publication_date: 20090731
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The present invention relates to multimedia services provided in a communications network, in general, and in particular to fault reporting and diagnosis in a communications network.","With the advent of high speed internet access whether via wireline or wireless connection accessing television or other multimedia services become reality. However, distributing TV in an IP (Internet Protocol) network is a challenging task. TV viewers expect nothing but the highest quality, while the IPTV (Internet Protocol TV) service itself puts higher requirements on the IP network than other services. The ability to act quickly and decisively in addressing any problems in the IPTV delivery chain from a head end to a subscriber is absolutely the key to success.","However, diagnosis of IP TV service is a non-trivial problem. The modern telecommunication network is a large-scale distributed system composed of complex inter-operating sub-networks. Each service deployment involves a number of heterogeneous network entities (servers, routers, switches) with different functionalities (authentication, resource control, etc). Any entity in the network may be faulty, e.g. out of order or of poor performance. The large amount of entities and the complicated (direct or indirect) dependencies in many cases bury the faulty entities. This is demonstrated in , which shows example of user steps in video-on-demand shop TV service. It is not important for understanding of the present invention that is to be described what are the individual steps, what is important is that if any of the steps leading to the service goes wrong, the service would fail.","On the other hand, current network and service monitoring tools provides little reliable indication of where the problem lies. Thus, when a service like IPTV goes down, it may take the service providers considerable amount of time before the cause of the problem is found.","There are known systems that can detect service quality degradation like servicEye or Agama IPTV Quality Assurance. This is, however not enough because the service provider needs to know the causes of the degradation.","ITU-T Recommendation G.1081 defines performance monitoring points for IPTV which will allow the service provider\/network operator to monitor the performance of the complete IPTV service delivery to the end user. The management platform entities manage domains and collect parameters from monitoring points, perform performance analysis, and generate reports. Through network-wide deployment of monitors (performance monitoring points), it is possible to localize the problems to a network segment (or a network domain), but undoubtedly this would be very expensive to achieve high granularity of monitoring. Moreover, service diagnosis requires more than just collecting metrics like packet loss ratio and delay.","In consequence monitoring, diagnosis and fault reporting in services providing multimedia contents over IP network is not properly addressed.","It is the object of the present invention to obviate at least some of the above disadvantages and provide an improved service problem reporting and diagnosis for use in a communications network.","Accordingly, the invention seeks to preferably mitigate, alleviate or eliminate one or more of the disadvantages mentioned above singly or in any combination.","According to a first aspect of the present invention there is provided a method of reporting a failure of a service providing multimedia content in a communications network. The method comprises collecting connectivity configuration information at user equipment. The user equipment also monitors in real time service connectivity sequences by recording information obtained from headers of packets sent by the user equipment. The method also comprises refining the recorded service connectivity sequences by removing from the recorded service connectivity sequences information related to non-critical connectivity. The step of refining is aimed at discarding irrelevant or sporadic connectivity. Further, the method comprises collecting by a service sequence daemon service connectivity sequences from a plurality of user equipment. In the next step the refined service connectivity sequences are sent to the user equipment. When the user equipment experience a broken service the method comprises reporting by the user equipment the broken service sequence by providing information based on the last correct connectivity in the broken service sequence.","According to a second aspect of the present invention there is provided a method of service performance diagnosis based on reported failure information from a plurality of user equipment operating in a communications network. The method comprises grouping the reported failure information, mapping IDs of the user equipment that reported failures onto a topology of the network and filtering out sporadic failure reports to identify an element of the network that caused the access failure. Finally, when the element which caused the failure is identified the method comprises raising an alarm by sending a message to an Operations Support System, OSS, and\/or displaying said alarm on administrative interfaces.","According to a third aspect of the present invention there is provided a network element comprising a processing unit, an interface for transmitting and receiving information to and from a plurality of user equipment. The interface is adapted to receive from a plurality of user equipment information related to service connectivity sequences recorded in real time by the user equipment. The processing unit is adapted to collect refined service connectivity sequences from a plurality of user equipment and to send to the plurality of user equipment the refined service connectivity sequences. The processing unit is further adapted to receive from a user equipment a report about a broken service sequence based on the last correct connectivity in the broken service sequence.","According to a fourth aspect of the present invention there is provided a user equipment for use in a communications network, the user equipment comprising a client for receiving multimedia services and a service sequence monitor. The service sequence monitor is adapted to collect connectivity configuration information associated with multimedia services accessed by the user equipment and to monitor in real time service connectivity sequences by recording information obtained from headers of packets sent by the user equipment. The service sequence monitor is also adapted to send the recorded information related to service connectivity sequence to a network element operating in said network.","Further features of the present invention are as claimed in the dependent claims.","The present invention provides the benefit of reduced costs of operation of a telecommunications network (reduced OPEX), because the proposed methods are fully automated and require no human interaction. The present invention is also easy to implement and run as it is end-to-end based, implemented at user equipment and a server running a service sequence daemon, and requires no modifications to intermediate nodes inside the network. Additionally, when running, the invention requires no prior knowledge about service.","Low reporting overhead is another advantage of the present invention. In the present solution reports are sent only when there are problems and therefore, the traffic overhead is reasonably low.","Accuracy of root cause analysis is greatly improved thanks to sequence refinement methods used in this invention.","In a simple embodiment of the present invention user equipment (UE) uses traces of service primitives of one or multiple service sessions. The traces are used to automatically discover service connectivity sequence. With the service connectivity sequence known the UE refines the service connectivity sequences by analyzing connectivities captured during multiple sessions of the same service type and discarding connectivity that does not match the temporal order of majority of the recorded service connectivity sequences of the same service type. In a communications network a plurality of user equipment send the observed and recorded service connectivity sequences of the same service to a service sequence daemon, which then aggregates the service connectivity sequences from different user equipment and filters out irrelevant (noisy) connectivity. The service sequence daemon sends back the refined service connectivity sequence to UE and each UE uses such service connectivity sequence to detect service breakpoints. In case of a service failure the UE sends a problem report to the service sequence daemon and\/or to a service monitor.","The term service monitor refers to a service assurance solution or product that monitors quality and end user experiences of the service. The levels of the monitoring include basic monitoring level (service KPIs, Key Performance Indexes, and management of access), built-in set-top-box monitoring, service level management, and broad service monitoring with non-intrusive probes.","A service sequence daemon is software process operating in a server in the communications network that collects the recorded service connectivity sequences from user equipment. In some embodiments of the present invention it refines the service connectivity sequences of the same type and performs service problem diagnosis based on the refined service connectivity sequences.","With a large number of user equipment operating in the network and reporting a failure the service sequence daemon or service monitor aggregates the problem reports received from various UE and discovers the causes of the failure or service degradations.","In order to implement the present invention in its various embodiments it is necessary to overcome some technical challenges of service sequence discovery through capturing connectivity. The most important challenges are discussed below.","(i) Automation. The service sequence is implementation specific. The discovery process must be automated, in order to reduce OPEX and management complexity. The method in accordance with embodiments of this invention is fully automated in sequence discovery and refinement, and requires no human intervention.\n\n(ii) Noise traffic. In the captured service connectivity sequence, some background traffic, such as scheduled email checking, may also be recorded. Such connectivity is irrelevant to the monitored service and needs to be filtered out.\n\n(iii) Repeated service operations. Some captured connectivity, although relevant to the service, may be redundant. For example, end user may repeat some service operations (e.g. PLAY-PAUSE-PLAY-PAUSE). Such repetitions should be filtered out and only essential connectivity is kept.\n\n(iv) Missing connectivity. Some service-related connectivity may not appear in each service sequence. For example, DNS lookup will not be initiated if previous query results are cached locally. So the shortest sequence may lose such connectivity. In some system designs (such as high availability solutions and load balancing), connectivity that performs the same activities may be different, i.e. the server IP addresses may change over time. Therefore, connectivity with two different server IP addresses may have the same functions and needs to be merged.\n","The present invention in its various embodiments treats a service session as the execution of a series of service activities. Since a service may have multiple implementations, the detailed activities depend on implementations and configurations. However, for a specific implementation of a service, the sequence of the activities should be the same; that is, no matter which client has access to this service, it has to follow the same rules or protocols. Therefore, a set of activities (or steps, such as authentication and DNS lookup) that occur in temporal order during a service session is called an activity sequence for that service (or service implementation). Accordingly, a service activity model consists of a number of activity patterns of the service as illustrated in . For example, the user steps shown in the Video-On-Demand shop TV Service illustrated in  form a service sequence.","A service sequence describes the detailed rules (or logics) behind the specific service implementation. A failed service session means a broken service sequence. The breakpoint of the sequence indicates the causes of the service failure.","A service sequence depends on methods of service implementations and configurations. Discovering the service sequence commonly relies on the knowledge from application designers and owners. These specifications can be written into reports and other deliverables. While straightforward, this requires significant human effort to keep up with the evolution of the service and its deployment environment, especially for the purpose of service problem diagnosis and root cause analysis. This increases OPEX costs. Therefore, it is desirable to investigate automatic service sequence methodologies.","A service connectivity sequence refers to a sequence of connectivity through elements of the network through which a service client communicates with different servers in a service session. A service connectivity may perform one or multiple service activities. Service connectivity sequence is closely correlated with service sequence. Broken service connectivity sequence indicates broken service sequence. Therefore, monitoring service connectivity sequence can be used to represent service sequences, like in a black-box testing approach where internal structure of the system (or a service in this case) is irrelevant.","The present invention assumes that the service sequence is discovered automatically. The reasons for not using a pre-defined service sequence are:\n\n","In order to discover a service sequence based on monitoring service connectivity, it would be advantageous to have the knowledge of service behaviour model, in order to determine the approximate status of a service session.","A service behaviour model represents high-level service-specific access activities. For example, service behaviour model of mobile TV services describes:\n\n",{"@attributes":{"id":"p-0040","num":"0044"},"figref":"FIG. 3","b":["302","304","306","308","308","302","306"]},"A traditional method of service behaviour modelling is based on observing the behaviour of individual nodes and aggregating this to observe the behaviour of the service as a whole. Dynamic Bayesian Network (BN) is the common way of achieving this. Here only the basic mechanism of BN is described as the process is well known in the art and is not subject matter of the present invention. The detailed method is implementation specific and has been presented in many existing solutions.","Bayesian Network is a popular technology for monitoring different types of behaviour by specifying the dependencies that hold between aspects of a system. A BN consists of a Directed Acyclic Graph (DAG) structure, where the nodes represent variables from an application domain and the arcs represent the influential relationships between them. Additionally, there is an associated conditional probability distribution over these variables which encode the probability that the variables assume their different values given the values of their parent variables in the BN. The probability distribution can be assigned by an expert, learnt off-line from historical data, or learnt on-line incrementally from a live feed of data.","When applied to embodiments of the present invention the service behaviour model determines when the service sequence monitor starts and finishes capturing connectivity traces. The relationship between service behaviour model, service activity model (including service sequence), and service connectivity sequence is shown in .","From  one can see that one high level activity in the service behaviour model, e.g. b, comprises two activity elements (a, a) arranged in a particular order. For example at the behaviour model level an user activity of tuning in IP TV service may consist of authentication and session setup at the service activity model level. In the embodiment illustrated in  step a, in turn, require a sequence of connectivities arranged in a particular order: c and c. In one embodiment the connectivity c will be retrieving the description of a media object identified by the request URL from a server (i.e. RTSP DESCRIBE request and response), and the connectivity c will be with the service provider setting up a connection of a required (or available) bandwidth (i.e. RTSP SETUP request and response).","One embodiment of the present invention is illustrated in . In a preferred embodiment of the present invention a service sequence monitor, , shown in , is implemented in user equipment  and a service sequence daemon  is implemented in a server or network element  in a communications network . A method of reporting a failure of a service providing multimedia content in a communications network  comprises steps of discovering service connectivity sequence by collecting, , connectivity configuration information and monitoring, , in real time service connectivity sequences.","The operations of sequence discovery are carried out in a service sequence monitor , a module implemented in the user equipment  (e.g. mobile phone, netbook, laptop, etc.), and in one embodiment the service sequence monitor  collects pre-defined connectivity configuration information, including IP addresses of servers (such as content servers and authentication servers) and source\/destination port number (this is important for services running on non-official ports). This information can be extracted from captured SDP messages (Session Description Protocol) or from other configuration files.","In the embodiment using the SDP messages, a SDP message contains the following fields:","Media Descriptions (\u201cm=\u201d)","m=<media> <port> <proto> <fmt>","In its sub-fields, <media> is the media type (\u201caudio\u201d, \u201cvideo\u201d, \u201ctext\u201d, \u201capplication\u201d, and \u201cmessage\u201d)<port> is the transport port to which the media stream is sent. The meaning of the transport port depends on the network being used as specified in the relevant \u201cc=\u201d field, and on the transport protocol defined in the <proto> sub-field of the media field.","Connection Data (\u201cc=\u201d)","c=<nettype> <addrtype> <connection-address>","If the session is multicast, the connection address (\u201c<connection-address>\u201d) is an","IP multicast group address. If the session is not multicast, then the connection address contains the unicast IP address of the expected data source or data relay or data sink as determined by additional attribute fields.","Example: c=1N IP4 224.2.36.42\/127","Such information is preferably recorded in a table and used for defining connectivity dumping patterns. Table 1 below is an example of such table.",{"@attributes":{"id":"p-0055","num":"0059"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"center"}}],"thead":{"row":[{"entry":[{},"TABLE 1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"ROLE","PORT NUMBER","IP ADDRESS"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"RTP\/VIDEO (Data)","49170\/c","224.2.36.42"]},{"entry":[{},"RTCP (Control)","49171\/c","\u2014"]},{"entry":[{},"RTSP (Control)","\u2003554\/s",". . ."]},{"entry":[{},". . .",". . .",". . ."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"The service sequence monitor  in the UE monitors, , in real time service connectivity sequences by recording information obtained from headers of packets sent by the user equipment . In a preferred embodiment the real time monitoring also includes recording information obtained from headers of packets received by the user equipment.","The service sequence monitor  dumps headers of the packets sent and received by the UE. In one embodiment it is achieved through porting TCPDUMP\/LIBPCAP to mobile software platform or using existing APIs, Application Programming Interfaces, provided by mobile operating systems. TCPDUMP\/LIBPCAP is a packet sniffer (or packet analyzer), a function implemented in software that can intercept and log traffic passing through a digital network and be used for low level packet capture. The activities are recorded in temporal order as illustrated in Table 2 below.",{"@attributes":{"id":"p-0058","num":"0062"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}},{"entry":["TIME-","LOCAL","LOCAL","REMOTE","REMOTE","DIREC-"]},{"entry":["STAMP","IP","PORT","IP","PORT","TION"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["10.473000","224.2.36.42","3937","82.211.92.253","554","Send &"]},{"entry":[{},{},{},{},{},"Recv"]},{"entry":[". . .",". . .",". . .",". . .",". . .",". . ."]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The dumping period is determined by the service behaviour model. Based on the behaviour model of the IP TV service (over fixed or mobile connection) as illustrated in , in order to capture a full connectivity sequence the monitor begins to capture the connectivity information when the end user TV client is started. In order to avoid recording unnecessary information the monitor stops dumping connectivity after first data packets (e.g. RTP for IPTV services) are received. This indicates that content delivery has started. The connectivity sequence recorded during such a period is called a Startup Sequence.","The Startup Sequence is captured each time the TV client is started. In addition to the Startup Sequence in alternative embodiments the monitor captures other connectivity sequences.","For example, the monitor starts dumping connectivity when a outgoing RTSP (Real Time Streaming Protocol) DESCRIBE packet is detected on port , as shown in Table 2 (i.e. sent by the UE), which indicates that the user is to retrieve the description of a presentation or media object identified by the request URL from a content server. In alternative embodiments, for HTTP based solutions, the monitor starts dumping connectivity when an initial HTTP Get request is detected. Similarly, the monitor stops dumping connectivity, after the first data packets, e.g. RTP (Real-time Transport Protocol) for IPTV services, are received. These connectivity sequences are called Non-startup Sequences.","Without losing generality, this invention allows for user-defined sequence dumping patterns. That is, the service provider may define its own dumping start and end points.","From the service behaviour model we can see that, the Startup Sequence describes a full connectivity a client requires in a TV session. Other connectivity sequences are subsets of the Startup Sequence. Receiving the first content packet is treated in one embodiment of the present invention as the end point of connectivity dumping, because successful delivery of the first packet indicates that a service session has been established.","If no content packets are observed within a timeout period, the recorded sequence is discarded. The value of the timeout interval may be the same with the timeout interval of the TV client software. In this way only connectivity sequences of successful service sessions are recorded. Sequences of unsuccessful service sessions are discarded as being partial and inaccurate, and potentially leading to recording a false picture of the service sequence connectivity.","Refining of the Recorded Service Connectivity Sequences","The recorded service connectivity sequences are refined by discarding information related to non-critical connectivity. The non-critical connectivity in the context of this invention is for example noise traffic and repeated service operations briefly discussed earlier. In general this term refers to traffic that is irrelevant or not necessary for the monitored service.","In a simplest embodiment the refinement  is carried out only at the UE  and in this process the service sequence monitor  analyses service connectivity sequences recorded during multiple sessions of the same service type and discards non-critical connectivity. Different types of sequences, e.g. startup connectivity sequences and non-startup sequences, are analyzed separately. Service sessions of the same service type refer to, for example, multiple user sessions of the same IPTV service. An IPTV viewer may watch two TV programs, program A and program B, through the same IPTV service and therefore they are classified as service sessions of the same service type. Watching these two programs generates similar connectivity sequence records. In one embodiment connectivity is classified as non-critical if it is present in less than a defined percentage of the multiple service sessions of the same service type. In this way any random fluctuations in accessing the service experienced by an individual UE are eliminated.","In operation, as illustrated in , in the process of refinement carried out in the user equipment  the service sequence monitor modifies a recorded service connectivity sequence by merging, , multiple successive connectivity to the same host (for example, C={c, c, c, c}) into (C\u2032={c, c, c}). It is assumed that to connect to one host from the same device the same connectivity set is required. In some situations, however, a recorded service connectivity sequences may contain steps not present in other recorded connectivities. In the next step the service sequence monitor  determines a service connectivity sequence sub-set which is a set of service connectivity present in each modified service connectivity sequence of multiple service sessions of the same service type (also referred to as must-have service connectivity set). This is achieved by calculating intersection, , of the sets C\u2032x, i.e. C\u2032\u2229C\u2032. By analysing a plurality of service connectivity sequences to the same host it is possible to identify these elements of the sequence that are present in each of the recorded and analysed sequences. Once the must-have service connectivity set is identified the service sequence monitor, for each modified connectivity sequence, generates a new sequence C\u2033 by discarding, , connectivity that does not appear in the must-have service connectivity set. In the following step the service sequence monitor selects, , the shortest service connectivity sequence from the modified connectivity sequences as a must-have service connectivity sequence. A must-have service connectivity sequence is produced by removing repeated connection patterns to the same host, i.e. {c, c, c, c}=>{c, c}.","It is important to understand the difference between a must-have service connectivity set and a must-have service connectivity sequence. A must-have service connectivity set is a mathematical set concept, in which the elements (e.g. connectivity) are not ordered, whereas a must-have service connectivity sequence a mathematical sequence concept, in which the elements are ordered.","Then, for each recorded service connectivity sequence of multiple service sessions of the same service type, the service sequence monitor, , compares, , said service connectivity sequence with the produced shortest must-have service connectivity sequence. If connectivity with a second host occurs after connectivity with a first host in at least a predefined number of connectivity sequences, , and if the connectivity with the first host is part of the shortest must-have service connectivity sequence, , then the connectivity with the second host is inserted, , into the shortest must-have service connectivity sequence. Otherwise, the next connectivity in the sequence is checked, .","The refinement carried out by the service sequence monitor, , can be described as temporal refinement as it takes into account the sequential flow of connectivity leading to provision of a service by discarding connectivity that does not fit into a statistical pattern recorded for an individual UE.","In an alternative embodiment the refinement, , is carried out only by the service sequence daemon . In this embodiment the service sequence daemon, , collects the recorded service connectivity sequences received from a plurality of user equipment and compares service connectivity sequences of the same type. The refinement, , is carried out by removing from the recorded service connectivity sequences information related to non-critical connectivity based on service connectivity sequences from a plurality of user equipment. The service connectivity sequence is sent by the service sequence monitor, , to the service sequence daemon, , for refinement based on spatial aggregation. The refinement based on spatial aggregation is based on the following rules:\n\n","In one embodiment the non-critical connectivity is defined at the service sequence daemon as a connectivity that is present in less than a defined percentage of the service connectivity sequences of the same service type reported by a plurality of user equipment.","Therefore, the service sequence daemon, , compares the connectivity sequences from a plurality of UE. If connectivity c from one sequence does not appear in all (or, for example, 90%) of the other sequences, it is safe to remove such connectivity from the sequence as being non-critical.","This type of refinement can be described as a spatial refinement as it takes into account data (service connectivity sequences) recorded by a plurality of user equipment located in different parts of the network and discards data that does not fit into statistical pattern for the plurality of user equipment accessing service of the same type.","In a preferred embodiment refining of the recorded service connectivity sequences is carried out in two phases\u2014temporal and spatial. Preferably the temporal refinement is carried out at the user equipment, , as described earlier and the resulting, refined service connectivity sequences are sent from the user equipment, , to the service sequence daemon, . The service sequence daemon, , receives such refined sequences from a plurality of UE and then further refines the received sequences. The refinement performed by the service sequence daemon is the spatial refinement as discussed earlier.","In an alternative embodiment both temporal and spatial refinement processes are performed by the service sequence daemon, . In this embodiment the UE sends unrefined service connectivity sequences and the daemon, , carries out the temporal refinement of data received from individual UE in isolation from refinement of data received from any other UE. The operation of spatial refinement in this embodiment is not affected.","In yet another embodiment the daemon  carries out only the temporal refinement, , of unrefined service connectivity sequences received from a plurality of user equipment.","Once the service connectivity sequences are freed from irrelevant information in the refinement process the refined service connectivity sequences of the same type received from a plurality of user equipment are preferably aggregated  by the service sequence daemon . The step of aggregation, , allows for capturing in one service sequence more than one service connectivity sequence that can be used to obtain the same service. For example, if a connectivity c of the sequence S has different server IP address compared with the corresponding connectivity c\u2032 of the sequence S, and both are for the same service, then both IP addresses are recorded (aggregated) in the final service sequence (i.e. two servers providing the same functions). After the aggregation the service sequence daemon sends (or announces), , to the user equipment the aggregated service connectivity sequences.","In an alternative embodiment the service sequence daemon  does not perform aggregation and simply sends, , the collected and refined service connectivity sequences to the plurality of user equipment. The service sequence daemon, , collects the service connectivity sequences from the plurality of UE. The number of the service connectivity sequences sent to the many UE is large because by not aggregating the received service connectivity sequences the population of the service connectivity sequences is not reduced. However, as a result of removing of the irrelevant connectivity in the refinement process there will be a relatively large number of identical service connectivity sequences. This means it is not necessary to send to the plurality of UE all of these refined service connectivity sequences, but only those that are different, leaving out identical refined service connectivity sequences. In this embodiment the daemon  has several different sequences that in a preferred embodiment would be aggregated as discussed earlier, but instead of being aggregated they are sent separately. The UE  uses them in same way as it would use the aggregated ones, but instead of checking one aggregated service connectivity sequence the UE must check two or more service connectivity sequences.","In a preferred embodiment a service sequence repository is updated  with the results of said aggregation. The sequence repository is a database stored in a memory unit. The memory unit may be located in the network element  where the daemon  operates, but in alternative embodiments it may be located elsewhere in the communications network .","In the next step the aggregated service connectivity sequence is sent  to the plurality of user equipment. This provides the UE  with a description of a sequence leading to provision of a specific service. Based on that the UE  can identify which of the steps of the service connectivity sequence have been successful and if there is a problem with getting the requested service it is possible to identify which connectivity in the sequence was the last correct connectivity and this allows to localize where the failure occurred. In case of a failure, e.g. the service stops in the middle of the sequence, and the next connectivity in the sequence does not appear, the user equipment reports  a broken service sequence by providing information based on the last correct connectivity in the broken service sequence. For example, a client sends a RSTP PLAY request (observed by the sequence monitor); it expects the arrival of the RTP packet, as recorded in the connectivity sequence. However, if nothing is received, the service sequence is violated and the service sequence monitor  reports  this breakpoint.","After receiving several reports pointing to the same server, the daemon  sends, , alarms to OSS  or to a service management system to acknowledge this.","Preferably the user equipment  reports, , the broken service sequence to the service monitor  of the communications network . Also preferably the method comprises a step of sending  from the service sequence daemon  to the service monitor  of the communications network  service connectivity sequences from the updated service sequence repositories. The service monitor  may display and\/or send alarms to the service provider, and\/or directly to network management systems. The follow-on procedures depend on the design of the service monitor . The role and location of the service monitor  is independent of this invention. The service monitor  is a service-level way of reporting a broken sequence to service provider to help diagnosis. The service monitor is generally capable of integration with Network Management System\/Operations Support System, so it is possible to correlate the reported broken sequence with other data sources, such as events and topology, in order to help discover root cause of service problems.","With reference to  a method of service performance diagnosis in one embodiment of the present invention is illustrated. The method is based on failure information received  in reports from a plurality of user equipment operating in the communications network. The method assumes that if in a network in which a plurality of UE accesses the same service a failure occurred the analysis of the reports will help diagnosing the root cause of the problem\u2014i.e. identify an element of the network that caused the failure.","When a UE  receives from the service sequence daemon  the refined or refined and aggregated service connectivity sequences it is able to identify in case of a failure the last element of the network  that it had connectivity with. The UE  monitors in real time service connectivity sequence by recording information obtained from headers of packets sent by the UE  and preferably also received by the UE. In this way the UE knows which element of the network was the last one correctly connected with the UE. This knowledge combined with identification of the service connectivity sequence that corresponds to the service the UE was trying to access forms a failure report that is sent to the service sequence daemon . In the case of real failure of an element of the network the service sequence daemon  receives a large number of failure reports. The service sequence daemon groups  the reported failure reports. In order to find the failed element the daemon tries different ways of grouping the reports, for example by a server port number, a failure timestamp, a server IP address, or any combination of these.","In the next step IDs of the user equipment that reported failures are mapped  onto a network topology. Then filtering out  sporadic failure reports is carried out to identify  the element of the network  that caused the access failure. In the identification step using information about service connectivity sequences obtained from a service sequence repository is preferably used. For example, if the daemon received thousand failure reports in which the last connectivity was with router X and only fifty reports where the last connectivity was with various other elements of the network then by discarding the information from the fifty reports, as being sporadic failures, the daemon finds out, using service connectivity sequence from the service sequence repository, that the element that is after the router X in the sequence is the one that caused the failure. Finally, an alarm is raised  by sending  a message to an Operations Support System, OSS,  and\/or displaying said alarm on administrative interfaces. The OSS , in one embodiment, exchanges, , this information with the service monitor .","To prevent raising random alarms in a preferred embodiment an element of the network is identified  as the element that caused the access failure if the number of failure reports leading to said element as a cause of failure is above a predefined threshold .",{"@attributes":{"id":"p-0088","num":"0094"},"figref":["FIG. 5","FIG. 5"],"b":["500","508","500","502","502","504","506","508","504","516","504","516"]},"The interface  receives  from plurality of user equipment  information related to service connectivity sequences recorded in real time by the user equipment . In one embodiment the information contains service connectivity sequences refined by the user equipment and in alternative embodiment unrefined. The service sequence daemon  collects the service connectivity sequences from a plurality of user equipment after they are refined at the user equipment or by the service sequence daemon, or both. The service sequence daemon then sends  to the plurality of user equipment  the refined service connectivity sequences and in case a failure prevents access to a service the daemon receives  from a user equipment a report about a broken service sequence based on the last correct connectivity in the broken service sequence. In one embodiment the same report is also received, , by the service monitor .","In a preferred embodiment the daemon  is adapted to aggregate the information from the refined service connectivity sequences of the same type received from a plurality of user equipment. If the daemon  performs the aggregation then the aggregated service connectivity sequences are sent  to the user equipment. The operation of aggregation allows for capturing in one sequence more than one service connectivity sequence that can be used to obtain the same service. For example, if a connectivity c of the sequence S has different server IP address compared with the corresponding connectivity c\u2032 of the sequence S, and both are for the same service, then both IP addresses are recorded in the final service sequence (i.e. two servers providing the same functions).",{"@attributes":{"id":"p-0091","num":"0097"},"figref":"FIG. 5","b":["508","508","500","502","500","502","508","522","508","518","508","502"]}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention will be understood and appreciated more fully from the following detailed description taken in conjunction with the drawings in which:",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
