---
title: Method and apparatus for continuing to provide processing on disk outages
abstract: A system and method for continuing to provide processing in a processing system is disclosed. In one embodiment, a processing system is provided comprising a secondary storage device, a memory, a processor, an operating system, and a plurality of processes stored in the secondary data storage device. The plurality of processes comprise a first group of processes and a second group of processes. The first group of processes is adapted to be swapped between the secondary data storage device and the memory for execution. The second group of processes is adapted to be locked into the memory of the processing system during operation. The request to lock and unlock a process is affected by a watchdog process unrelated to the process being locked. Configuration information for the watchdog process identifies the processes in the first and/or second groups.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07467324&OS=07467324&RS=07467324
owner: Ayaya Inc.
number: 07467324
owner_city: Basking Ridge
owner_country: US
publication_date: 20041206
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application claims priority from U.S. Provisional Patent Application No. 60\/615,304 filed Sep. 30, 2004, which is hereby incorporated by reference.","The present invention is related to a system, method and apparatus for continuing to provides processing upon a disk outage.","Telecommunication systems process telephone services. A call processing server may be used, for example, to process calls for call center operations. Reliability of such telecommunication systems is often critical. One way of achieving reliability and fault tolerance in telecommunication systems is by duplication of call processing servers, which can be expensive. For reasons of cost, call processing servers often include simplex servers (i.e., single processor\/single disk servers).","When access is lost to a disk drive (or other secondary data storage device) in simplex servers, it can lead to server failure and complete loss of telecommunication access. The server failure causes the server to stop call processing and may lead to an entire call center being shut down until the server is repaired and placed back into service. Loss of call processing services at inopportune times can have dire consequences on a call processing center. During high call volume periods, a loss of service can result in irritated customers and lost sales opportunities.","A processor may lose access to a disk drive as a result of any number of conditions that affect the chain of functional units involved in accessing a disk. For example, the disk itself may become faulty, its controlling disk file controller may fail, the channel connecting the disk memory subsystem to the processor may fail, or the direct memory access controller or disk driver that is attempting the access may fail. The failure of access may be either total failure or just an unacceptably high error rate.","U.S. Pat. No. 4,608,688 issued to Hansen et al. discloses protecting against a loss of access to both duplicated system-essential disk drives in a duplex processing system in which processes are swapped between a main memory and a pair of duplicated disks. After one of the duplicated (redundant) disks fails, the system identifies processes designed as essential to the operation of the system that are not resident in the main memory and swaps these processes into the main memory from the second duplicated disk. The system then locks all essential processes into the main memory so that they will not be swapped out of memory. In the event that the second duplicated disk also fails, the essential processes remain accessible to the processing system even upon the loss of access to both of the disks. The processing system kills non-essential processes and the system continues processing using only the essential processes. Where both of the duplicated disks of the system disclosed in the '688 patent fail simultaneously or near simultaneously, however, the essential processes are not locked into memory and the system would fail to operate.","The architecture of Hansen et al. fails to address a number of problems.","For example, it can fail to lock into memory processes that are critical or essential to providing continued call processing functionality. As will be appreciated, the difference between critical and noncritical processes is that the server is capable of continuing to provide specified features\/services without access to noncritical processes but is incapable of providing the specified features\/services without access to critical processes. Telecommunication software includes not only the primary call processing software, such as Avaya Inc.'s Communication Manager\u2122, but also various software products from multiple vendors providing some of the same or a number of additional telephony features. Although the vendor of the primary call processing software can designate the processes critical to the continued provision of call processing capabilities in the event of a disk failure, determining which the criticality of processes in software of other vendors can be difficult at best. Such software often is not configured to identify which of its component processes are critical. In the event of a disk-related failure, the operating system, using first party locking techniques (in which the application or component process seeking to be locked requests the operating system to place it in a lock state), can typically lock into memory each of the critical processes in the primary call processing software but is typically unable (without alteration of source code) to determine the set of critical processes for software of other vendors.","It can fail to effect locking in a simplex server configuration. In Hansen et al., locking does not occur until loss of at least one duplicated secondary data storage devices. Upon loss of access to one of the devices, processes designated as essential to the system's operation and not resident in the main memory are swapped into the main memory from the other, still accessible, secondary data storage device. All essential processes are then locked into the main memory to prevent their removal therefrom. In contrast, a simplex server configuration commonly has only one secondary data storage device. It is not duplicated. Waiting until the device is inaccessible to effect critical process swapping and locking into main memory could prevent the system from remaining operational when the secondary data storage device is no longer accessible.","It can fail to prevent a process from becoming \u201chung\u201d in the event of loss of secondary data storage disk access. As will be appreciated, a process makes read and write requests to an Integrated Device Electronics (IDE) driver for secondary disk access, and the IDE driver provides the request to the secondary disk. If the secondary disk is inaccessible, the IDE driver will futilely wait for an acknowledgment from the disk that the request is completed and thereby fail to respond to the process making the read or write request. As a result, the requesting process will be hung indefinitely and cannot be terminated.","These and other needs are addressed by the present invention. The present invention provides for continued call processing functionality during a disk outage by preserving selected call processing processes in primary memory.","In one embodiment, third party locking is used to effect locking of critical processes. Unlike first party locking in which the process to be locked or unlocked itself requests locking or unlocking, respectively, third party locking is effected by a first or \u201cwatchdog\u201d process determining that a second unrelated process is critical or no longer critical to a desired operation or set of operations and requesting the operating system to lock or unlock, respectively, the second process in primary memory. When a process is locked in memory, it is not eligible to be swapped to the secondary data storage device. Third party locking permits critical processes of software applications of different vendors to be identified and locked without alteration of source code. The critical processes are identified in a configuration file(s) for the watchdog process. As needed, the list of critical processes in the configuration file(s) can be readily updated or otherwise modified by system administrators.","In another embodiment, an image file is used to maintain particularly critical call processing processes in primary memory. As will be appreciated, image files are typically used to preserve critical operating system processes. Expanding image files to include processes of applications other than simply processes of the operating system, such as call processing, ensures call processing survivability in the event of a disk outage.","The image file can be maintained in a RAM disk. The RAM disk is a portion of the primary memory that is allocated for use as a disk partition and is locked in memory (not swapped). The RAM disk contents are defined to support the operating system without disk access and with the necessary call processing processes locked in memory. The RAM disk contents include a set of critical binaries, scripts, and libraries in directories to support the processes locked in memory. The noncritical binaries, scripts and libraries are referenced off of the secondary data storage device. When locking occurs, all Dynamic Random Access Memory or DRAM pages that are mapped into the calling process' address space are disabled. This includes the memory pages process' text, data, stack, shared libraries, user kernel space data, and shared memory. As will be appreciated, another technique for effective locking and unlocking is to a kernel module set (or unset) the bits necessary to lock the process in the memory.","The RAM disk configuration can provide greater system reliability and continued call processing functionality notwithstanding a disk outage, even for a simplex server configuration. In the event of failure of the secondary data storage device, non-critical processes are killed and the system continues processing using only the critical processes. Unlike a duplex server configuration having replicated secondary storage, the simplex server configuration of the present invention locks critical processes in primary memory during boot up and maintains the lock status of the processes at all times during operation to ensure availability of this information to the system should access to secondary storage be lost. In contrast, in a duplex server configuration having replicated secondary storage, critical processes are locked only when one or more of the replicated secondary storage devices has failed. Otherwise, the critical processes are not locked in memory.","In yet another embodiment, a driver is configured to identify when a secondary data storage device is defective or starting to be defective (i.e., in the process of going down) and thereafter failing device access (read and\/or write) requests to avoid hanging a process. A potential storage device accessibility problem is assumed by the driver to be imminent or already in existence when the driver does not receive an acknowledgment within a predetermined time after providing the corresponding request to the storage device. In that event, a device failure flag is set and all future device access requests received from processes are failed by the driver without ever sending the access request to the storage device.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 1","FIG. 1","FIG. 1"],"b":["10","12","14","14","10","16","16","12"]},"During operation, the processor  operates under the control of an operating system (e.g., Linux, Unix or Windows) to execute processes assigned for execution to the processing system . A process comprises an instance of running an executable file. A process or task may be, for example, a user written program, or it may have a dedicated function, such as the control of an input and output device or the creation and detection of other processes. A process is generally considered to include a private data space and register values, and a set of code (i.e., program instructions) that it possibly shares with other processes. In performing its operations, the processor  communicates with the remaining hardware components, such as the secondary data storage device  and memory , over a bus .","The processing system  stores processes and related files in the secondary data storage device  and swaps them in and out of the faster, but limited, memory  as needed during operation. Where the secondary data storage device  fails, however, the processing system  is limited to processing operations that are loaded in the memory  at that time.","The present invention locks important process(es) and their related file(s) and\/or directory structure(s) in the memory . A portion of the memory  is used as a virtual data storage device for storing important file(s) and\/or directory structure(s) related to the processes locked in memory. For the purposes of the present invention, a file may comprise one or more file(s) and\/or directory structure(s). Examples of a related file include executable files, binaries, scripts, libraries, data files, directory structures (e.g., \/bin, \/sbin\/, \/lib, \/etc., \/dev, etc.), and file(s) related to the operation of the important process(es) can be accessed from the virtual data storage device in the event that the secondary data storage device  fails.","In the embodiment of the invention shown in , for example, a portion of the memory  comprises a RAM disk . A RAM disk is a portion of memory that is allocated for use as a disk partition and is locked in memory (or is not eligible to be swapped). In one embodiment, the RAM disk  is mapped to the processing system  as the main secondary data storage device (i.e., the boot\/root disk for the system ), with the secondary data storage device  mapped to the processing system  as an alternative secondary data storage device. In another embodiment, however, the RAM disk  is mapped to the processing system  as an alternative secondary data storage device and the secondary data storage device  (or another secondary data storage device) is mapped to the processing system  as the main secondary data storage device (i.e., the boot\/root disk for the system ).","Critical process(es) and any related file(s) for operations important to the operation of the system are stored in the memory  (e.g., in the RAM disk  or another portion of the memory ) and are locked into the memory  (e.g., in the RAM disk  or another portion of the memory ) so the processor  will not swap them out to the secondary data storage device . Thus, if the secondary data storage device  fails, the critical process(es) and any related file(s) are still available to the processor  via the memory  (e.g., via the RAM disk  or another portion of the memory ) and the processor  can continue to run those process(es) and access any related file(s) until the secondary data storage device  is repaired and placed back into service. For example, in one configuration the RAM disk contents are defined to support a limited running Linux operating system with no disk access and with the necessary call processing (e.g., Communication Manager\u2122) processes locked in memory .",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 2","b":["30","10","10","10"]},"In a call processing server providing call processing operations for a telecommunications call center, for example, process(es) and\/or file(s) that are necessary to allow call processing operators to continue to originate and\/or receive telephone calls as well as to process those calls may be defined as critical process(es) and\/or file(s) for that particular operation. For example, processes and files related to specified telecommunication features, such as abbreviated dialing enhanced list, audible message waiting, vectoring, answer supervision by call classifier, ATM trunking, agent states, dial by name, DCS call coverage, echo cancellation, multifrequency signaling, wideband switching, Digital Communication System or DCS call coverage, audible message waiting, attendant vectoring, Asynchronous Transfer Mode or ATM WAN spare processor, ATM, dial by name, echo cancellation, multimedia call handling, multiple call handling, caller identification, multifrequency signaling, Integrated Services Digital Network or ISDN network call redirection, centralized attendant, remote office, enhanced Direct Inward Dialing or DID routing, survivable remote processor, time of day routing, tenant partitioning, Vector Directory Number or VDN of origin announcement, wideband switching, wireless, logged-in agents, offer category, maximum numbers of concurrently registered IP stations, administered IP trunks, ports, and concurrently administered remote office stations\/trunks, call center release, logged-in automated call distribution or ACD agents, maximum currently registered IP stations, maximum administered IP trunks, offer category, maximum number of ports, maximum number of administered remote office trunks, and maximum number of mobile stations, may be designated as critical processes and files. In the same call processing server, however, processes and applications not critical to call processing operations may be designated as non-critical and allowed to cease (or may be killed) upon a disk outage or failure. For example, any process such as system administration, error logging and the like that relies upon disk access should be designated as non-critical. In addition, other processes and files related to SNMP traps, environmental functions and the like may be designated as non-critical for such a call processing server.","Once a process and\/or file is determined to be critical to a function of the processing system , the process or file is identified as such. In one embodiment, for example, an indicator is stored in the processing system and identifies that one or more particular process(es) and\/or file(s) are critical. For example, the process control information for each process may include a field for designating whether or not a process is critical.","When the system is installed or the software is upgraded, an install script is run in operation . The install script is used to create an image file for use each time the system is booted after the software is installed. The install script loads software into the processing system  and generates a RAM disk . Generating a RAM disk , for example, may comprise generating an image file on the secondary data storage device . An image file comprises a file system (e.g., directory tree) within a file. Next, the installation script prepares the image file by mounting the file as if it were a file system. The installation script also copies one or more critical process(es) and\/or file(s) along with its own associated metadata and other information. Then, the installation script unmounts the image file as a file system and compresses the image file. The installation script also instructs the boot loader to use the compressed image file when the system boots. The compressed image file may comprise the operating system image file to which the application-specific critical process and file information are added or may comprise a separate image file that is to be used during the boot process subsequent to the image file of the operating system. Simply put, the image file(s) include not only processes critical for the operating system but also processes critical to call processing.","After the image file is created during the installation or upgrade process, the system boots in operation  based on the RAM disk  generated by the install script in operation . During the system boot, the image file generated by the install script is decompressed. The decompressed image file is then loaded and locked into the memory  forming the RAM disk  in operation . In one embodiment, for example, any file critical to the system  (e.g., an executable file, a binary, a script, a library, a data file, directory structure or the like) may be loaded and locked within the RAM disk  of the memory .","Next, the system  locks the critical process(es) into the memory  (e.g., within the RAM disk  or another portion of the memory ) in operation . Generally, smaller highly critical files not only for the operation of the operating system but also for call processing are contained in the RAM disk  while larger and\/or less critical files are locked into other portion(s) of the memory . By locking the critical process(es) into memory, the process(es) remain locked in memory  (e.g., within the RAM disk  or another portion of the memory ) and are accessible by the processor  in the event that the secondary data storage device  fails. A critical process may be locked in the memory  in any manner. In one embodiment, for example, one or more process(es) may themselves request the kernel to lock the first party process into memory (i.e., a first party locking procedure) into the memory  when they are initiated (e.g., during the booting of the system). A kernel is a central module of an operating system that loads first, stays in memory and is responsible for tasks such as memory, process, task and disk management. In this embodiment, for example, a process running in a Linux environment may call the mlockall( ) Application Programming Interface or API call when booting up to lock itself in or unlock itself from memory . When this API is called for locking, it disables paging for all DRAM pages that are mapped into the calling process' address space. This includes the memory pages process' text, data, stack, shared libraries, user kernel space data, and shared memory. As will be appreciated, another technique for effecting locking and unlocking is to request that the IDE driver in the kernel set (or unset) the bits necessary to lock the process in main memory.","In another embodiment, the system  may lock one or more critical process(es) into memory  (i.e., a third party locking procedure). Thus, where a process, such as a first party process, cannot be or is not modified to request the kernel to lock itself into the memory , a third party process or application in the system  may request the kernal to lock the first party process into the memory . In a Linux environment, for example, a Linux kernel may be modified to support a third party locking process in which a first process in the Linux operating system can request the operating system to lock another second process in memory to prevent it from being swapped out to the secondary data storage device .","In the embodiment shown in , for example, a process  for a third-party locking procedure (i.e., a process other than the process to be locked requests the process to be locked in memory) is provided. In this embodiment, two new Linux virtual memory flags or state or condition indicators (e.g., VM_LOCK_REQ and VM_UNLOCK_REQ) are added to the operating system in operation . The virtual memory flags are then set in operations  and . In operation , for example, the virtual memory flag VM_LOCK_REQ is set for all critical processes of the system. As noted, a critical process (or non-critical process) is indicated by an indicator in the process code itself, in RAM disk , or otherwise stored in data structures in the memory . The virtual memory flag VM_UNLOCK_REQ is set for all non-critical processes of the system in operation . The flags may be set by a process during the boot of the system or may be set during the operation of the system after the boot process is complete. In one embodiment, for example, a flag for a critical process that is to be locked at all times during the operation of the system may be set during the boot of the system. A flag for a process that is only critical in certain instances (e.g., where required only if another process is operating) may be set when needed (e.g., when the other process is dispatched). Thus, a process may be given access to bit(s) of the virtual memory flag(s) such as via an (IDE) device driver using a standard system call (e.g., a Linux ioctl( ) system call).","When the process is to be dispatched by the system (e.g., by a Linux scheduler) in operation , the Linux scheduler may be further modified to examine the bit(s) of the virtual memory flags for a process in operations  and  when that process is being dispatched. If the process had bit(s) set in a \u201clock\u201d virtual memory flag (e.g, the VM_LOCK_REQ virtual memory flag) in operation , the scheduler locks the task in main memory before dispatching it in operation . Similarly, if a task had bit(s) set in an \u201cunlock\u201d virtual memory flag (e.g., the VM_UNLOCK_REQ virtual memory flag) in operation , the scheduler unlocks (or does not lock) the task from main memory in operation  before dispatching it. In another embodiment, one or more bits of a single virtual memory may be set for a first configuration (e.g., lock (do not allow swapping of) the process in memory) and not set for a second configuration (e.g., unlock (allow swapping of) the process from memory). In yet another embodiment, one or more bits of a single virtual memory may be set for a first configuration (e.g., unlock (allow swapping of) the process in memory) and not set for a second configuration (e.g., lock (do not allow swapping of) the process from memory).","The ability of the system  or a process to lock another process into memory allows for locking processes of other vendors into memory without having to alter the party process or source code for the process itself. For example, where source code to a process is not available or where it is undesirable to modify the process (e.g., where future versions would require repeated modification of the third party processes), the process may still be locked into memory without having to alter the process itself. In this embodiment, only a single application process needs to be maintained in order to lock processes of other vendors. In addition, the single application process needs only the Process ID of the other vendor's application in order to lock it into memory. In one embodiment, for example, critical process(es) native to the system  may lock themselves into the memory  when they are initiated, and the system  may lock critical process(es) into the memory  without having to alter the process(es) themselves.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 4","FIG. 5","FIG. 4","FIG. 5","FIG. 4"],"b":["52","122","52","54","124","54","126","54","54","56","56","128"]},"The applications initiated by the watchdog process (e.g., the global maintenance manager (GMM) process  and the process manager (PM) process ) start up and begin sending regular handshakes to the watchdog process (e.g., as an \u201cI'm alive\u201d signal or a \u201cheartbeat\u201d signal) in operations  and . The process manager (PM) process  initiates the critical (e.g., call processing) processes in operation  and initiates first party locking of those processes in main memory. The process manager (PM) process  also controls the initialization of the critical processes and invokes recovery actions in response to the errors reported by the processes to keep the critical processes alive in operation .","The global maintenance manager (GMM) process  provides alarm reporting services for platform and maintenance. The global maintenance manager (GMM) process , for example, implements a maintenance process. Upon initiation, the global maintenance manager (GMM) process  accesses one or more rule file(s) (e.g., an alarm rules file) located on disk drive  (or elsewhere in the processing system ) in operation . The global maintenance manager (GMM) process  further implements a pipeline  between the syslog_d daemon  and the global maintenance manager (GMM) process  in operation  so that events to the syslog file  are also immediately sent to the global maintenance manager (GMM) process  for analysis in operation . The global maintenance manager (GMM) process  compares each event to a list of alarms read in from an alarm rules file in operation , and if matched, reports the alarm in operation .",{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 6","b":"160"},"In this embodiment, the Linux kernel IDE driver code is altered to use a failure flag to indicate that the processing system has detected the disk drive  to have failed. In operation , the method first initializes a counter or flag (e.g., a disk_failure counter or a disk_failure flag) for determining whether a disk failure has been detected. When a request for access to the disk is made, the kernel IDE driver receives the request in operation . The kernel IDE driver then determines whether the disk_failure counter is greater than or equal to a predetermined threshold (e.g., one) or whether a disk_failure flag has been set (or a disk_fully_operational flag has been unset) in operation . If the disk_failure counter is greater than or equal to the predetermined threshold (e.g., one) or the disk_failure flag has been set (or the disk_fully_operational flag has been unset), the method proceeds to operation  discussed below. If, however, the disk_failure counter is not greater than or equal to the predetermined threshold (e.g., one) or the disk_failure flag has not been set (or the disk_fully_operational flag has not been unset) in operation , the kernel IDE driver submits the request to accesses the disk in operation  and waits for a response. If a response is not received within a predetermined period of time (such as 10 milliseconds), for example, the IDE driver determines that a disk failure or malfunction has occurred. Where no disk failure has been detected (and the disk access has completed successfully), the method reverts to operation  to wait for the next disk access request. Where a disk error is detected in operation , however, the Linux kernel IDE driver code logs the error (e.g., \u201ccommand given to failed disk\u201d) to the syslog_d daemon process  in operation  and sets a disk_failure flag (or unsets a disk_fully_operational flag) and increments the disk_failure counter in operation . The current disk access request is terminated in operation , and control is returned to the process that is currently blocked from accessing the disk input\/output (I\/O) in operation . Then, the method returns to operation , where the kernel IDE driver waits for the next disk access request.","In this manner, the process that attempted to access the disk drive  does not remain blocked. By returning control to the process, this embodiment provides a significant advantage over the standard Linux operating system, where the IDE driver would indefinitely block the I\/O request from the process and thereby effectively hang the process. In a high-availability system, it can be critical for certain real-time processes to not block on the I\/O for an indefinite period of time so that they can continue processing their real-time task.","In one embodiment, for example, the global maintenance manager (GMM) process  utilizes a Linux IOCTL interface to set a flag when the processing system has detected the disk drive  to have failed. In this embodiment, the global maintenance manager (GMM) process  uses the Linux IOCTL interface to access the following values in the kernel IDE driver.","#define HDIO_GET_FAIL 0x0338","#define HDIO_SET_FAIL 0x0339","When the HDIO_GET_FAIL command is used, the command returns the value of the disk failure flag. The HDIO_SET_FAIL command allows the process to set the failure value. In one embodiment, the HDIO_SET_FAIL command may be used in testing the system by setting the disk failure flag to simulate a disk failure.","When the error is logged to the syslog process , the global maintenance manager (GMM) process  receives the error log from the pipeline  (described above) between the global maintenance manager (GMM) process  and the syslog process . When the error is received by the global maintenance manager (GMM) process , a set of rules is used to generate a set of recovery actions including informing the watchdog process  to shut down various non-critical processes. Thus, any errors reported by the Linux kernel IDE driver can be determined by the global maintenance manager (GMM) process  to be an indication of a disk failure, and the global maintenance manager (GMM) process  can take a recovery action in order to continue providing service in the event of the failure.","Although the present invention has been described in conjunction with its preferred embodiments, it is to be understood that modifications and variations may be resorted to without departing from the spirit and scope of the invention as those skilled in the art readily understand. Such modifications and variations are considered to be within the purview and scope of the invention and the appended claims.","For example, although examples of the present invention have been described with reference to a Linux operating system and for a simplex server having a single secondary data storage device, the present invention is not limited to this particular implementation. The system may operate under an operating system such as Linux, Unix, Windows or the like. Further, the system may comprise a simplex server, a duplex server or other system architectures. In addition, although system of the present invention has been described with reference to a call processing system for maintaining call processing operations when a data storage device such as a disk drive fails, the present invention is also applicable to other applications as would be readily recognized by one of ordinary skill in the art."],"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
