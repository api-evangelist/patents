---
title: Systems, methods, and computer program products to optimize serialization when porting code to IBM S/390 UNIX system services from a UNIX system
abstract: Systems, methods, and computer products that determine how to optimize serialization code that has been ported from other computer systems to the OS/390 UNIX system. General-purpose UNIX systems may not provide sufficient facilities; such as compiler run-time APIs like the Compare and Swap C Run-Time Library API, to accommodate the performance-related features of serialized code in complex applications. When porting a high-performance application from other UNIX platforms to IBM OS/390 UNIX, serialized code performance of the application may be limited. The present invention may be implemented by advantageously determining when substitution of the Compare and Swap C Run-Time Library API calls for pthread_mutex calls will improve the execution of serialized code on the IBM OS/390 UNIX system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06938054&OS=06938054&RS=06938054
owner: International Business Machines Corporation
number: 06938054
owner_city: Armonk
owner_country: US
publication_date: 20021125
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DESCRIPTION OF THE INVENTION","Trademarks"],"p":["1. Field of the Invention","The present invention is directed to the field of porting computer code. It is more particularly directed to optimizing serialization code when porting high-performance applications to IBM S\/390 UNIX System Services from other UNIX systems.","2. Description of the Background Art","Typically complex computer applications, such as a database, are ported to a variety of computer systems. The porting process often includes special changes to the application to enable efficient and complete operation of the application on different computer systems. Serialized code operations are a significant factor in the overall performance of a complex computer application. High-performance computer applications, such as a database, may require serialization of the code used to access data to ensure that certain data access operations are performed before others are subsequently performed. Such serialization may not be supported by efficient techniques on the target system. A \u201ctarget computer system\u201d as used herein refers to a computer system environment consisting of one or more specific programming languages, such as the C programming language, and the application programming interfaces (APIs) available in the programming languages. Therefore, changes to serialization operations may be made during the porting of an application to ensure efficient operation of the application on the target computer system. Such a target computer system may include the products sold under the trademarks IBM S\/390\u00ae that includes the IBM OS\/390\u00ae (OS\/390) operating system, the z\/OS operating system, and the UNIX System Services for the IBM OS\/390\u00ae (OS\/390 UNIX).","On systems sold under the trademark UNIX, serialization is typically implemented using C program run-time APIs such as pthread_mutex_lock, pthread_mutex_trylock, and pthread_mutex_unlock. These mutex serialized operations and other such C program run-time APIs will be referred to herein as \u201cpthread_mutex calls.\u201d The OS\/390 UNIX provides a \u201cCompare and Swap\u201d C Run-Time Library API that requires less computer instructions to execute than standard UNIX run-time APIs, such as the pthread_mutex calls, and which may sometimes be used in their place. It will be understood that the terms \u201cCompare and Swap C Run-Time Library API\u201d and \u201cCompare and Swap API\u201d will be used interchangeably herein. Under certain circumstances, the Compare and Swap API serialized operations may perform more than one hundred times faster during computer program execution than the standard pthread_mutex calls. It would be advantageous to be able to determine when serialization operations on the OS\/390 UNIX will perform faster by using the Compare and Swap API instead of the standard pthread_mutex calls. Therefore when appropriate, it would be advantageous if serialized operations on the OS\/390 UNIX system could take advantage of the highly efficient Compare and Swap API.","From the foregoing it will be apparent that there is still a need to improve the techniques of serialization on the OS\/390 UNIX systems over the past. More particularly, existing systems have not been able to determine when taking advantage of the Compare and Swap API of the OS\/390 UNIX would improve performance of serialization code that has been ported from other computer systems to the OS\/390 UNIX target computer system.","An embodiment of the present invention relates to systems, methods, and computer products that optimize serialization code when porting high-performance applications to an OS\/390 UNIX computer system from other UNIX computer systems. The preferred embodiment of the present invention determines whether the Compare and Swap API would improve performance of serialization code that has been ported from other computer systems to the OS\/390 UNIX target computer system. More particularly, the preferred embodiment of the present invention determines when to take advantage of the dramatically shorter instruction path of the Compare and Swap API of the OS\/390 UNIX over typical UNIX serialization management operations such as the pthread_mutex calls. It will be appreciated that programmatically invoking code is typically referred to as \u201ccalling\u201d program code. Moreover and when appropriate, the preferred embodiment of the present invention novelly uses C program function calls to the Compare and Swap API of the OS\/390 UNIX, for improvement of the performance of certain serialization code in high-performance applications that have been ported to the OS\/390 UNIX system.","Typically, serialization programming is associated with managing instances of threads of program code that require access to at least one common computer resource. A thread of program code typically has an execution state, maintains execution context when not executing, and has access to computer resources that enable execution of the program code thread. When a function call to a C program pthread_mutex call is made, a lock of the data area associated with access to a common computer resource is accessed and execution of the thread of program code that accesses or manipulates that resource is permitted and continues until reference to or manipulation of that resource is complete, at which time the operation of the program code will typically relinquish the lock of the data area. During the period of time that the lock is held by a particular program thread, other threads that have also attempted to acquire the lock will be in what is sometimes referred to as a \u201csuspended state.\u201d It will be appreciated that the term \u201clock\u201d herein refers to a lock of the data area that is associated with the common computer resource.","By means of comparison, the Compare and Swap API of the OS\/390 UNIX does not operate by managing program code locks, and instead uses a test to determine if a simple unit of program storage has a particular value indicating whether a process thread has control of a resource. The preferred embodiment of the present invention uses the value determined by the test of the Compare and Swap API as a lock mechanism that enables synchronization of serialized code.","In the preferred embodiment of the present invention the simple unit of program storage is a small area of contiguous computer storage four bytes in length. In an alternative embodiment of the present invention the simple unit of program storage may be any number of bytes in length. For example, a Compare and Swap Double API operates on an eight-byte area, and while the Compare and Swap API may be used to update singly linked lists safely the Compare and Swap Double API may safely update doubly linked lists. Those skilled in the art will appreciate the operation of singly linked lists and doubly linked lists. Further, by means of example the Compare and Swap Double may be used instead of the Compare and Swap API in the operation of the present invention. Typically, the Compare and Swap API links the following operations into a single, atomic operation: (i) determine the current value of the data area to be locked; (ii) compare the current value of the data area to be locked to a previously-acquired copy of the value in the data area to be locked; and (iii) if the current value and the previously-acquired value of the data area to be locked are equal, then store a new value into the data area to be locked. It will be appreciated that a data area may contain an aggregation of associated data and is not constrained as to format. If the Compare and Swap API is called simultaneously from two or more invoking program code routines that point to the same data area to be locked, at most one call to the Compare and Swap API will succeed in updating the data area.","In the preferred embodiment of the present invention, the operation of testing the state of a four-byte area of program code storage is an efficient operation that ensures that the associated thread of program code is immediately executed. The operation of the Compare and Swap API of the OS\/390 UNIX requires many fewer program code instructions than the typical pthread_mutex calls. The preferred embodiment of the present invention determines when to use the Compare and Swap API to support efficient execution of serialized program code.","When porting program code that uses pthread_mutex calls, it is not always advantageous to replace those calls with functionally equivalent Compare and Swap API calls when they are coupled with simple program code loops that attempt to modify program storage as a locking mechanism. Since the execution of such loops does not yield control of the computer system, the loop execution consumes computer system resources from the time the acquisition of a lock is attempted until it succeeds. pthread_mutex calls, by contrast, may yield control of the computer system resources if a lock is unavailable even when coupled with simple loop program code. Therefore, programs employing these calls generally stop consuming computer resources until the lock is available. Because of the complexity of the computer system code required to implement pthread_mutex API calls, it is possible to iteratively call the Compare and Swap API hundreds of times without consuming as many computer system resources as a single pthread_mutex call. When the use of computer system resources during the execution of a serialized code segment is small by comparison the use of computer system resources required during the execution of pthread_mutex calls, it may be advantageous to substitute locking mechanisms employing the Compare and Swap API for locking mechanisms of the pthread_mutex call. Based on comparison of computer resource execution time of the pthread_mutex calls to the Compare and Swap APIs, the preferred embodiment of the present invention enables the determination of whether the use of Compare and Swap APIs is more efficient than the use of standard UNIX run-time APIs, such as pthread_mutex calls, when porting high-performance applications to OS\/390 UNIX from other UNIX systems.","An embodiment of the present invention is achieved by systems, methods, and computer products that improve the performance of certain serialized program code that is ported from other computer systems to an OS\/390 UNIX system. The preferred embodiment of the method of the present invention comprises: (a) building a Serialization Test and Comparison (STAC) Tool if it is advantageous to use such a tool to analyze serialized code execution results, the STAC Tool includes: (i) incorporating a workload code fragment into the STAC Tool code, and (ii) compiling and linking the STAC Tool; (b) initiating the execution of the STAC Tool that may include iterative examination of the results of prior execution of the STAC Tool with the workload code fragment, and subsequent adjustment of input parameters used during execution of the STAC Tool; (c) executing the STAC Tool and analyzing the execution results, including: (i) obtaining and evaluating run-time parameters associated with the execution of the STAC Tool, (ii) determining the amount of computer resource time required to execute the workload code fragment, (iii) executing both a set of mutex threads and a set of Compare and Swap threads in association with the workload code fragment, (iv) reporting a set of mutex thread statistics and a set of Compare and Swap thread statistics, (v) and comparing the results of the mutex thread statistics and the Compare and Swap thread statistics that are the results of the execution of the set of threads.","Other aspects and advantages of the present invention will become apparent from the following detailed description, taken in conjunction with the accompanying drawings, illustrating by way of example the principles of the invention.","As shown in the drawings and for purposes of illustration, the preferred embodiment of the present invention determines when use of the Compare and Swap C API would improve performance of serialization code that has been ported from other computer systems to the OS\/390 UNIX target computer system. Existing systems have not been able to adequately improve the performance of serialization code in high-performance applications that are ported to the OS\/390 UNIX system from other UNIX systems.","When porting a high-performance application from other UNIX platforms to IBM OS\/390 UNIX, serialized code performance of the application may be limited. The present invention may be implemented by advantageously determining when substituting Compare and Swap API calls for pthread_mutex calls will improve the execution of serialized code on the IBM OS\/390 UNIX system.","More particularly and when appropriate, the preferred embodiment of the present invention takes advantage of the dramatically shorter instruction path of the Compare and Swap API of the OS\/390 UNIX as compared to typical UNIX serialization management operations such as the pthread_mutex calls. The preferred embodiment of the present invention determines when to use C program function calls to the Compare and Swap API of the OS\/390 UNIX, for improvement of the performance of certain serialization code in high-performance applications that have been ported to the OS\/390 UNIX system. The preferred embodiment of the present invention novelly determines when to use the test of the Compare and Swap API as a lock mechanism that enables efficient synchronization of serialized code.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 1","FIG. 1A","FIG. 1B","FIG. 1C","FIG. 1D","FIG. 1E"],"b":["1","1","101","164","160"]},"Information may be communicated to the STAC Tool  via the user interface . Through such communication, input parameters  may be specified for execution of the STAC Tool  and for analysis of the results of the execution of threads , such as sets of mutex threads  and Compare and Swap threads . The user interface  may communicate with the preferred embodiment of the present invention, either via batch input  or user input .","The computer system, embodied in the present example as a target computer system  may include computer resources . By means of example such computer resources  may include, computer processor  execution time, counters, queues, program code, memory, data structures, and files. Element  is described with reference to FIG. .","Further, the STAC Tool  may be configured and stored in the memory  of the target computer system . Alternatively, the STAC Tool  may be configured in computer storage such as that of a disk . Data  used during the execution of the STAC Tool  may be stored on the disk . The high-performance applications  using serialized code  may reference data  represented in a database . Application code  may be stored as source code on a disk  or other data storage device. Element  is described with reference to FIG. .","The user of the STAC Tool  incorporates a workload code fragment  that is extracted from application source code , into the STAC Tool  program code and then compiles and links the STAC Tool . The workload code fragment  is a type of serialized code , and serialized code  is included in the broader category of non-serialized code . Serialized code  is typically used to access data  so that certain data access operations are performed before others are subsequently performed and in the preferred embodiment of the present invention is included in threads , and in application code .","By iteratively invoking the STAC Tool  the results  obtained during its execution may be examined so that it may be determined whether use of the pthread_mutex calls  or the Compare and Swap API  would be most efficient. The Compare and Swap API  uses values , such as an old pointer , a current pointer , and a new value . The Compare and Swap API  compares values  stored at the location of both the old pointer  and the current pointer . If the new value  associated with the current pointer  is the same as the value  in the location associated with the old pointer , then the value  in the location associated with the old pointer  is replaced by the new value . Those skilled in the art will appreciate the use of pointers that identify the location of computer data . Element  is described with reference to FIG. D.","Upon examination of the execution results , run-time parameters  associated with the execution of the STAC Tool  may be defined, and subsequently changed during iterative execution of the STAC Tool . Run-time parameters  are further described with reference to FIG. D. During the execution of the STAC Tool  the STAC Results Tracking Module  is executed and results tracking data structures  are propagated with execution results . The results tracking data structures  are described in detail with reference to FIG. C.","The STAC Tool  analyzes the results of its execution and may generate STAC reports  via the use of the STAC report module . The STAC Reports  may be stored in computer storage, such as a disk , or in the STAC Tool  that operates during execution of the computer system . Element  is described with reference to FIG. .","The analysis of the results  of the execution of the STAC Tool  includes determining the amount of computer processor  execution time, a computer resource , and that is required to execute a workload code fragment . The workload code fragment  is computer program code that is representative of the ported code that is to be serialized by pthread_mutex calls  or the Compare and Swap API . In the preferred embodiment of the present invention the computer processor  time required to execute both a set of mutex threads  and a set of Compare and Swap threads  is determined. Therefore, the execution time of the computer processor  that is associated with the pthread_mutex threads  may be described as \u201cmutex execution time,\u201d and the execution time of the computer processor  that is associated with the Compare and Swap threads  may be described as \u201cCompare and Swap execution time.\u201d The set of mutex threads  is a serialized computer resource  and includes pthread_mutex calls  that, among other elements, contain the location of mutex objects . Mutex objects  provide a locking mechanism that is typically used by a computer operating system to synchronize execution between simultaneously executing mutex threads .","The set of Compare and Swap threads  includes a Compare and Swap API  that is used by the present invention to simulate the operation of a mutex object . Therefore, the preferred embodiment of the present invention uses a Compare and Swap lock word  to synchronize execution between simultaneously executing threads , which contain the serialized workload code fragment .","During the determination of the computer execution time, program control is given to the system dispatcher  for a short time to allow the operating system to update the computer processor  execution time associated with a particular thread . Those skilled in the art will appreciate the use of a system dispatcher . A stop flag  is set typically in the main( ) routine (as described with reference to ) and is used to terminate execution of the threads  containing the workload code fragment  as appropriate.","The STAC Reports  may include values  that are comparison results , such as a set of mutex thread statistics and a set of Compare and Swap thread statistics that are compared by the STAC Tool  to determine whether serialized application code  should be executed using the pthread_mutex calls  or the Compare and Swap API .",{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 1B","b":["113","112","106","107","112","105","105","125","125","107","106","111","125","125","107","106","107","111","112","1"]},{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 1C","FIG. 1C"],"b":["172","169","112","111","113","114","130","131","172","130","131","1","111","112","113","114","169","1"]},"In the preferred embodiment of the present invention an array of per-thread statistics structures for pthread_mutex threads  is provided in the results tracking data structures . Also, an array of per-thread statistics structures for Compare and Swap threads  is provided in the results tracking data structures . These arrays are used to store statistics that are gathered during the execution of the STAC Tool  and in the preferred embodiment of the present invention the arrays are populated with data  from the per-thread statistics data structure . Element  is described with reference to FIG. A.","The per-thread statistics data structure  contains data  that is gathered during the execution of the STAC Tool , including: the number of successful attempts to acquire serialization resources that are computer resources , as shown in element , the number of failed attempts to acquire serialization resources , the number of times a workload code fragment  is executed , and the computer processor  execution time used by this thread . Element  is described with reference to , and element  is described with reference to FIG. .",{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 1D","FIG. 1A"],"b":["130","130","139","140","111","141","355","113","142","130","109","143","109","144","111","145","355","146","109","111","113","355","3"]},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 1E","b":["131","115","107","106","131","147","148","149","150","151","111","113","111","114","131","130","132","105","106","107","111","115","1"]},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 1F","b":["170","170","170","2209","116","131","2","131","147","148","151","111","113","111","114","111","113","114","1"]},"The global counters  are also listed, including: the total number of successful pthread_mutex_trylock acquisitions , the total number of times the workload code fragment  is executed under mutex serialization , and the total computer processor  execution time used by the mutex threads  in the set of mutex threads as shown in element , the total number of successful Compare and Swap lock word  acquisitions as shown in element , the number of times the workload code fragment  is executed under Compare and Swap serialization as shown in element , and the total computer processor  execution time used by the Compare and Swap threads in the set of threads as shown in element . Elements ,  and  are described with reference to , and element  is described with reference to FIG. .","Also the report  includes a summary  used to compare the efficiency of the computer processor  execution time used by the set of Compare and Swap threads  to the computer processor  execution time used by the set of mutex threads . Further, the report  includes the computer processor  execution time expended for failed Compare and Swap instructions  that is also discussed with reference to FIG.  and element . The report  includes the performance advantage or disadvantage of using the Compare and Swap API versus pthread_mutex calls  that is also discussed with reference to FIG.  and element .",{"@attributes":{"id":"p-0059","num":"0058"},"figref":["FIG. 2","FIG. 2A","FIG. 2B","FIG. 2C","FIG. 2D","FIG. 2E","FIG. 2F","FIG. 2G","FIG. 2H"],"b":["2","2","200","164","107","125","111","200","125","105","106","107","106","106","107","106","164","164","202","111","164","164","203","105","106","107","111","125","164","1"]},"FIG. B and element  illustrate initiating the execution of the STAC Tool , which is performed according to the preferred embodiment of the present invention after the STAC Tool is built  (as shown in FIG. A). The execution of the STAC Tool  may include iterative examination of the results  of prior execution of the STAC Tool  with a workload code fragment , and subsequent adjustment of input parameters  used during execution of the STAC Tool . More particularly, and according to the preferred embodiment of the present invention, initiating the execution of the STAC Tool  includes: creating a script that executes the STAC Tool  with a set of systematically varied input parameters , as shown in element ; executing the STAC Tool  and the workload code fragment  and obtaining results , as shown in element ; and examining the results , as shown in element . Systematically changing the input parameters  enables analysis of a variety of program code scenarios so that it may be determined if serialized application code  will be more efficiently executed using the Compare and Swap API  or pthread_mutex calls . Elements , , , , , and  are described with reference to FIG. .","The operation of examining the results  novelly includes making a decision whether using the Compare and Swap API  is more efficient than using pthread_mutex calls , as shown in element . Optional adjustment of input parameters  may be performed if the determination of the test as shown in element  is that different input parameter values  may be appropriate. Therefore, if the result of the test of element  is YES, then the method of the present invention loops back to element . If the result of the test of element  is NO, then a test as shown in element  of whether optional change of the workload code fragment  is performed. If the result of the test of element  is YES, then the method of the present invention loops back to element , as shown in FIG. A. If the operations of elements  and  are bypassed, then the method of the present invention moves to element  as shown in FIG. C. Element  is described with reference to FIG. .","FIG. C and element  illustrate the preferred embodiment of the present invention of executing the main( ) routine of the STAC Tool  and analyzing execution results . Those skilled in the art will appreciate the use of a main( ) routine in computer program code. The global counters  are initialized, as shown in . The run-time parameters  are obtained and evaluated, as shown in element . Element  is described in detail with reference to FIG. D. The amount of computer processor  execution time required to execute the workload code fragment  is determined, as shown in element . In the preferred embodiment of the present invention operations associated with mutex threads  are executed. It will be appreciated that operations associated with the Compare and Swap API  could alternatively be executed next without departing from the spirit of the invention. Elements , , , , , and  are described with reference to , and element  is described with reference to FIG. .","A set of mutex threads  are created and initialized, as shown in element . The execution of the set of mutex threads  is started, as shown in element . Element  is described in detail with reference to  sleep command is executed that includes a specific number of seconds to sleep, as shown in element . It will be appreciated that the operation of executing a sleep command to effectively delay execution of another program code command for a specified time period is well known to those skilled in the art. According to the operation of the preferred embodiment of the present invention the main( ) routine of the STAC Tool  that invokes the sleep( ) function eventually resumes execution and sets a stop flag , as shown in element , that terminates the execution of the set of mutex threads , as shown in element . In the preferred embodiment of the present invention the execution results  associated with each thread  in the set of mutex threads  is tallied and reported, as shown in element . Elements , , , and  are described with reference to FIG. A and element  is described in detail with reference to FIG. F.","Before the set of Compare and Swap threads  is executed, the lock word for the Compare and Swap set of threads  is initialized, as shown in element . The execution of the set of Compare and Swap threads  is started, as shown in element . Element  is described in detail with reference to  sleep command associated with the set of Compare and Swap threads  is executed that includes a specific number of seconds to sleep, as shown in element . According to the operation of the preferred embodiment of the present invention the main( ) routine of the STAC Tool  that invokes the sleep( ) function eventually resumes execution and sets the stop flag , as shown in element , that terminates the execution of the set of Compare and Swap threads , as shown in element . In the preferred embodiment of the present invention the execution results  associated with each thread  in the set of Compare and Swap threads  are tallied and reported, as shown in element . Finally, the results  of the execution of the set of mutex threads  and the set of Compare and Swap threads  are compared, as shown in element . Elements ,  and  are described with reference to , element  is described in detail with reference to , and element  is described in detail with reference to FIG. .","FIG. D and element  illustrate the method of obtaining and evaluating runtime parameters . The run-time parameters  include the number of threads  that execute concurrently and that will contend for serialization resources that are computer resources , as shown in element . In the preferred embodiment of the present invention the default value for element  is four. Also the run-time parameters include the number of seconds to allow contending threads  to execute, as shown in element . In the preferred embodiment of the present invention the default value for element  is ten. Finally, the run-time parameters include the number of workload code fragment  iterations that will be executed each time a thread  gains control of its serialization resource, as shown in element . In the preferred embodiment of the present invention the default value for element  is one. Elements , , , and  are described with reference to FIG. A.",{"@attributes":{"id":"p-0066","num":"0065"},"figref":["FIG. 2E","FIG. 1A"],"b":["355","111","113","220","121","106","260","121","185","261","121","121","134","267","268","106","121","263","111","106","111","113","121","134","185","355","3"]},"If the test of element  succeeds then the data structure, \u201cnumber of successful attempts to acquire serialization resource\u201d  is incremented, as shown in element . The workload code fragment  is executed for a specific number of iterations, as shown in element . The specific number of iterations may be communicated programmatically, typically via batch input , or it may be communicated via user input . The number of workload iterations for a particular thread is added to the data structure, \u201cnumber of times workload code fragment executed\u201d , as shown in element . The mutex object  is released, typically by using the pthread_mutex_unlock call API , as shown in element . Elements , , , , and  are described with reference to FIG. A.","There is a test to determine whether the stop flag  is set, as shown in element . Recall that the stop flag  is set typically in the main( ) routine of the STAC Tool , as shown in element  of FIG. C. If the stop flag  is not set, the preferred embodiment of the present invention loops back to element  and attempts to acquire the mutex object . Alternatively, if the result of the test of element  is YES then execution control is given to the system dispatcher  for a short time to cause an update of the computer processor  execution time charged to the thread , as shown in element . The operation of the system dispatcher  will be appreciated by those skilled in the art. Then the per-thread statistics  are saved in a statistics array, as shown in element . In the preferred embodiment of the present invention, the statistics array for this technique is the array of per-thread statistics structures for pthread_mutex threads, as shown in element  of FIG. C. Then the execution of the mutex thread  is exited, as shown in element . Elements , , , , , and  are described with reference to FIG. .",{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 2F","b":["113","228","112","13","275","113","121","276","276","113","121","280","281","112","113","121","1"]},"Alternatively, if the result of the test of element  is YES, then a message is created indicating the number of mutex acquisition successes, mutex acquisition failures, and the number of successfully executed workload code fragment iterations, as shown in element . Typically, the number of mutex acquisition successes and mutex acquisition failures are determined by use of the pthread_mutex_trylock API . Then as shown in element , the information acquired in the per-thread statistics data structure  that was stored in the array of per-thread statistics structure for pthread_mutex threads  is added to the mutex totals in the global counters . More particularly, the mutex global counters  include: the total number of successful pthread_mutex_trylock acquisitions , the total number of failed pthread_mutex trylock acquisitions , the total number of times the workload code fragment is executed under mutex serialization , and the total computer execution time used by mutex threads in the set of mutex threads . The program then exits, as shown in element . Elements , , , , , , , and  are described with reference to FIG. .",{"@attributes":{"id":"p-0071","num":"0070"},"figref":["FIG. 2G","FIG. 1"],"b":["355","111","114","232","131","109","180","285","182","109","181","286","131","114","287","114","134","291","292","103","112","289","111","103","109","111","112","114","134","180","181","182","355","3"]},"If the test of element  succeeds then the data structure, \u201cnumber of successful attempts to acquire serialization resource\u201d  is incremented, as shown in element . The workload code fragment  is executed for a specific number of iterations, as shown in element . The number of workload iterations is added to the data structure, \u201cnumber of times workload code fragment executed\u201d  for a particular thread , as shown in element . The lock word  is released, typically by setting the lock word  to zero, as shown in element . It will be appreciated that any value  may be used as a flag to identify that the lock word  is released. Element  is described with reference to FIG. .","There is a test to determine whether the stop flag  is set, as shown in element . Recall that the stop flag  is set, as shown in element  of FIG. C. If the stop flag  was not set, the preferred embodiment of the present invention loops back to element  and attempts to execute. Alternatively, if the result of the test of element  is YES then execution control is given to the system dispatcher  for a short time to cause an update of the computer processor  execution time charged to the thread , as shown in element . Then the statistics associated with this thread  are saved in a statistics array, as shown in element . In the preferred embodiment of the present invention, the statistics array for this technique is the array of per-thread statistics structures for Compare and Swap threads, as shown in element  of FIG. C. Then the execution for the thread  is exited, as shown in element . Elements , , , and  are described with reference to FIG. B.",{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 2H","b":["114","240","112","114","2201","114","109","2202","2202","114","109","2203","2204","109","112","114","1"]},"Alternatively, if the result of the test of element  is YES, then a message is written to the STAC Report  indicating the number of Compare and Swap lock word  acquisition successes, lock word  acquisition failures, and the number of successfully executed workload code fragment  iterations, as shown in element . Then as shown in element , the information acquired in the per-thread statistics data structure  that was stored in the array of per-thread statistics data structure for Compare and Swap threads  is added to the Compare and Swap totals in the global counters . More particularly, the Compare and Swap global counters  include: the total number of successful Compare and Swap instructions , the total number of failed Compare and Swap instructions , the total number of times the workload code fragment is executed under Compare and Swap serialization , and the total computer processor  execution time used by Compare and Swap threads in the set of Compare and Swap threads . The reporting module execution for the current thread  then exits, as shown in element . Elements , , , , , , , , and  are described with reference to FIG. .",{"@attributes":{"id":"p-0076","num":"0075"},"figref":["FIG. 2I","FIG. 1E","FIG. 1"],"b":["115","242","170","2208","130","131","170","170","113","111","355","111","2209","170","114","109","111","355","112","111","2210","191","2211","170","125","105","2212","149","150","170","2212","190","2213","105","106","107","109","111","112","113","114","115","125","130","131","170","190","191","355","3"]},{"@attributes":{"id":"p-0077","num":"0076"},"figref":["FIG. 3","FIG. 1A"],"b":["300","300","300","307","315","320","355","358","122","341","340","330","335","345","325","340","355","341","340","300","300","122","345","346","300","160","345","346"]},"The central storage , the expanded storage , and the data storage device  are storage components that store data  (as shown in ) and instructions for controlling the operation of the central processor , which may be configured as a single processor or as a plurality of processors. The central processor  executes a program  to perform the methods of the present invention, as described herein. Before processing occurs, a program  and its data  must reside in central storage . Input\/Output operations result in the transfer of information between the central storage  and the user-input device .","While the program  is indicated as loaded into the memory , it may be configured on storage media  for subsequent loading into the data storage device  or the memory  via an appropriate storage media interface . Storage media  can be any conventional storage media such as a magnetic tape or an optical storage media. Alternatively, storage media  can be another type of electronic storage, located on a remote storage system.","Generally, the computer programs  and operating systems are all tangibly embodied in a computer-readable device or media, such as the memory , the data storage device , or the data transmission devices , thereby making an article of manufacture, such as a computer program product, according to the invention. As such, the terms \u201ccomputer program product\u201d as used herein are intended to encompass a computer program accessible from any computer-readable device or media.","Moreover, the computer programs  and operating systems are comprised of instructions which, when read and executed by the exemplary computer system , such as the target computer system , perform the steps necessary to implement and use the present invention. Under control of the operating system, the computer programs  may be loaded from the memory , the data storage device , or the data transmission devices  and networking connections  into the memory  of the exemplary computer system , such as the target computer system .","The user-input device  is a device, such as a keyboard or speech recognition subsystem, for enabling a user to communicate information and command selections to the central processor . The user can observe information generated by the system  via the display  or the printer . The user-input device  may also be a mouse, track-ball, or joy stick that allows the user to manipulate a cursor on the display  for communicating additional information and command selections to the central processor .","When operating in accordance with one embodiment of the present invention, the exemplary computer system  determines when use of the Compare and Swap API  would improve performance of serialized code  that has been ported from other computer systems to the OS\/390 UNIX system. The central processor  and the program  collectively operate to implement an embodiment of the present invention. It will be appreciated that the present invention offers many advantages over prior art techniques. Elements  and  are described with reference to FIG. A.","The present invention is typically implemented using one or more computer programs, each of which executes under the control of an operating system and causes the exemplary computer system , such as the target computer system , to perform the desired functions as described herein. Thus, using the present specification, the invention may be implemented as a machine, process, method, system, or article of manufacture by using standard programming and engineering techniques to produce software, firmware, hardware or any combination thereof.","It should be understood that various alternatives and modifications may be devised by those skilled in the art. However, these should not be viewed as limitations upon the practice of these teachings, as those skilled in the art, when guided by the foregoing teachings, may derive other suitable characteristics of a similar or different nature. The present invention is intended to embrace all such alternatives, modifications and variances that fall within the scope of the appended claims","IBM, S\/390, OS\/390, and z\/OS are trademarks or registered trademarks of International Business Machines Corporation in the United States and other countries. UNIX is a trademark or a registered trademark of Unix System Laboratories, Inc."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["In the following detailed description and in the several figures of the drawings, like elements are identified with like reference numerals.",{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 1","FIG. 1A","FIG. 1B","FIG. 1C","FIG. 1D","FIG. 1E","FIG. 1F"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1C"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1D"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1E"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1F"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 2","FIG. 2A","FIG. 2B","FIG. 2C","FIG. 2D","FIG. 2E","FIG. 2F","FIG. 2G","FIG. 2H","FIG. 21"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 2C"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 2D"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 2E"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 2F"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 2G"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 2H"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 2I"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 3"}]},"DETDESC":[{},{}]}
