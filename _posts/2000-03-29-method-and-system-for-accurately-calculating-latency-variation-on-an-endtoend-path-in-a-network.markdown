---
title: Method and system for accurately calculating latency variation on an end-to-end path in a network
abstract: A high-resolution, per-packet measurement tool for analyzing a computer network that operates by sending a predetermined number of packets from a sender machine to a receiver machine with measurement information inserted into the packet. The system kernel at the sending machine stamps a sequence number and the sender's local time into the data section of each packet. When packets arrive at the receiver machine, they are similarly stamped by the receiving machine's kernel with the receiving machine's local time. The maintained packet information serves as the basis for latency analysis. For example, one set of latencies can be obtained with QoS mechanisms turned on, and another set with QoS mechanisms turned off, whereby the benefits of the QoS mechanisms can be accurately determined. To analyze the latencies, the present invention normalizes each time and each latency into relative latency information. Clock skew and timer jumps may be handled as part of the normalization.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06975656&OS=06975656&RS=06975656
owner: Microsoft Corporation
number: 06975656
owner_city: Redmond
owner_country: US
publication_date: 20000329
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT EXEMPLARY OPERATING ENVIRONMENT"],"p":["The present invention relates generally to computer networks, and more particularly to an analysis tool for measuring latencies in a computer network.","Networks interconnect hosts using a variety of network devices, including host network adapters, routers, switches and hubs, each of which include network interfaces for interconnecting the various devices via cables and fibers. Applications send data over a network by submitting it to an operating system, after which it becomes network traffic. Network devices generally use a combination of hardware and software to forward network traffic from one network interface to another. Each interface can send and receive network traffic at a finite rate, and if the rate at which traffic is directed to a network interface exceeds the rate at which the network interface can forward the traffic onward, congestion occurs. Network devices may handle this condition by queuing traffic in the device's memory until the congestion subsides. In other cases, network equipment may discard some excess traffic to alleviate congestion.","As a result, applications sending network data experience varying latency or traffic loss. Applications generate traffic at varying rates and generally require that the network be able to carry traffic at the rate at which they generate it. In addition, applications differ in how tolerant they are of traffic delays in the network, and of variation in traffic delay. For example, certain applications can tolerate some degree of traffic loss, while others cannot. As a result, different applications have different requirements regarding the handling of their traffic in the network.","Network Quality of Service (QoS) refers to the ability of the network to handle network traffic such that it meets the service needs of certain applications. To this end, network QoS requires fundamental traffic handling mechanisms in the network, the ability to identify traffic that is entitled to these mechanisms and the ability to control these mechanisms. The fundamental traffic handling mechanisms that comprise a QoS-enabled network include the capacity of interfaces to forward traffic, the memory available to store traffic in network devices, (until it can be forwarded), and mechanisms internal to network devices that determine which traffic gets preferential access to these resources.","Because network resources are finite, there are parts of the network wherein resources are unable to meet demand. QoS mechanisms work by controlling the allocation of network resources to application traffic in a manner that meets the application's service requirements. Devices that provide QoS support do so by intelligently allocating resources to submitted traffic. For example, under congestion, a network device might choose to queue traffic of applications that are more latency tolerant (or did not specify their latency tolerance to the network) instead of traffic of applications that are less latency tolerant. As a result, the traffic of applications that are less latency tolerant can be forwarded immediately to the next network device. In this example, interface capacity is a resource which is granted to the latency-intolerant traffic, while device memory is a resource that has been granted to the latency-tolerant traffic.","In order to allot resources preferentially to certain traffic, it is necessary to identify different traffic and to associate it with the resources it requires. This is accomplished by recognizing separate traffic flows within the network and by defining traffic handling parameters which apply to these flows. Devices identify packets as belonging to one flow or another. In order to invoke QoS mechanisms, it is necessary to communicate to network devices the information necessary to associate packets with flows, and a description of the handling that should apply to traffic on each flow. This is achieved through various signaling means and device configuration.","While the benefits of QoS are generally acknowledged, the benefits with respect to latency have not heretofore been quantified. Indeed, although general attempts have been made to attempt to measure how QoS actually helps transmission of data over a network, existing tools are inadequate for quantifying the benefit of QoS. For example, one such tool reports results at a very coarse level, by sending an amount of data and determining how long it took to receive that data. As a result, relatively little information is obtained with this technique, and indeed, other factors such as non-network related delays are factored into the transmission time. Other tools such as \u201cPing\u201d provide more information, but do so at relatively low resolution, (e.g., ten millisecond bins are provided, whereby packets less than this amount are placed into the less-than-ten millisecond bin regardless of how fast they were actually transmitted), and\/or merely provide average latency information.","Further, there are also methods for calculating Round Trip Time (RTT) estimates. RTT helps transport level protocols in estimating the congestion in the network, but because the congestion is measured, the technique is limited to round trip measurements even though the latency estimate is not the same in both directions. However, network QoS provides benefits in solving latency problems in just one direction as well as in both. As a result, measurement of latency in one direction is an important part of proving the benefits of QoS, but has heretofore been unavailable.","Still other tools are complex, relying on devices such as radios, satellite receivers or modems to attempt to synchronize the clocks at the sender and receiver so that send and receive times are in synchronization whereby the actual latency can be measured to an extent. For example, Network Time Protocol (NTP) is one such method for synchronizing clocks on computers, but has drawbacks in that it requires the machines to communicate with an NTP server either via a radio, satellite receiver or modem. Regardless of the device used, the resulting synchronization is only approximate because synchronizing the clocks on any two machines is virtually impossible. At present, a modem connection to the NTP server provides synchronization within a range on the order of a few tens of milliseconds, while radio and satellite receiver connections may be synchronized to within approximately a millisecond range. Although such ranges may provide better resolution than other existing methods, the abovementioned devices are not easily accessible, and moreover, the modem case is too loosely bounded for use in accurate measurements of latency.","Briefly, the present invention provides a method and system including a high-resolution, per-packet measurement tool that operates by sending a predetermined number of packets from a sender machine to a receiver machine with measurement information inserted into the packet. The sending machine associates a sequence number and the sender's local time (to a precision of 100 ns) with each packet, such as by stamping the information into the data section of each packet via a timestamp component running in the system kernel. When a packet arrives at the receiver machine, it is similarly associated with a receiver-relative time. For example, the packet is timestamped by a component in the receiving machine's kernel, at a different offset in the data section than the offset at which the sender timestamped it. The stamping at both the sender and receiver is preferably performed in the kernel, below other kernel components, to render irrelevant any delays caused by higher drivers and components and thereby increase accuracy.","Once the packets are received, a list of the received packets including the packet sequence number, the time sent and the time received is maintained, and serves as the basis for latency (the difference between time sent and received) analysis. For example, one set of latencies can be obtained with QoS mechanisms turned on, and another set with QoS mechanisms turned off, whereby the benefits of the QoS mechanisms can be accurately determined on a per-packet basis. To facilitate the analysis of the latency information, the present invention normalizes each time and each latency, e.g., by finding the lowest latency and subtracting that value from each of the latencies. As long as the lowest latency is either calibrated during a low-noise calibration phase, or enough packets are sent that at least one of the packets will likely end up in a very short (or zero length) queue, the other normalized latencies will have relative values that represent the variable delay resulting from queuing and congestion.","The method and system also solve a relative-time stamp problem that results from a deviation between the sender clock and the receiver clock, i.e., the receiver clock gains time or loses time relative to the sender clock, referred to as clock skew. To compensate for clock skew, statistical mechanisms are used to determine a constant variation, by which the received (or sent) timestamps, or the resultant latencies, are adjusted in order to determine a corrected latency for each packet. The latencies may then be normalized from the minimum of the corrected latencies.","The present invention also adjusts for a problem with a hardware timer chip which occasionally jumps forward a determinable jump amount. A test is employed to determine whether a latency value that appears suspect is (at least to a high likelihood) a result of the timer problem. If so, that latency value and those that are timestamped after it are adjusted by subtracting the jump amount therefrom. Again, the latencies may be normalized from the minimum of the latencies after such corrections are performed.","Other advantages will become apparent from the following detailed description when taken in conjunction with the drawings, in which:",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 1"},"Generally, program modules include routines, programs, objects, components, data structures and the like that perform particular tasks or implement particular abstract data types.","Moreover, those skilled in the art will appreciate that the invention may be practiced with other computer system configurations, including hand-held devices, multi-processor systems, microprocessor-based or programmable consumer electronics, network PCs, minicomputers, mainframe computers and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote memory storage devices.","With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a conventional personal computer  or the like, including a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. The system memory includes read-only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within the personal computer , such as during start-up, is stored in ROM . The personal computer  may further include a hard disk drive  for reading from and writing to a hard disk, not shown, a magnetic disk drive  for reading from or writing to a removable magnetic disk , and an optical disk drive  for reading from or writing to a removable optical disk  such as a CD-ROM or other optical media. The hard disk drive , magnetic disk drive , and optical disk drive  are connected to the system bus  by a hard disk drive interface , a magnetic disk drive interface , and an optical drive interface , respectively. The drives and their associated computer-readable media provide non-volatile storage of computer readable instructions, data structures, program modules and other data for the personal computer . Although the exemplary environment described herein employs a hard disk, a removable magnetic disk  and a removable optical disk , it should be appreciated by those skilled in the art that other types of computer readable media which can store data that is accessible by a computer, such as magnetic cassettes, flash memory cards, digital video disks, Bernoulli cartridges, random access memories (RAMs), read-only memories (ROMs) and the like may also be used in the exemplary operating environment.","A number of program modules may be stored on the hard disk, magnetic disk , optical disk , ROM  or RAM , including an operating system , (such as Windows\u00ae 2000), one or more application programs , other program modules  and program data . A user may enter commands and information into the personal computer  through input devices such as a keyboard  and pointing device . Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner or the like. These and other input devices are often connected to the processing unit  through a serial port interface  that is coupled to the system bus, but may be connected by other interfaces, such as a parallel port, game port or universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video adapter . In addition to the monitor , personal computers typically include other peripheral output devices (not shown), such as speakers and printers.","The personal computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be another personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the personal computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) . Such networking environments are commonplace in offices, enterprise-wide computer networks, Intranets and the Internet.","When used in a LAN networking environment, the personal computer  is connected to the local network  through a network interface or adapter . When used in a WAN networking environment, the personal computer  typically includes a modem  or other means for establishing communications over the wide area network , such as the Internet. The modem , which may be internal or external, is connected to the system bus  via the serial port interface . In a networked environment, program modules depicted relative to the personal computer , or portions thereof, may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Calculating Latency Variation","The present invention is directed to measuring latency variation on networks, including production networks and controlled networks that may be artificially congested. Note that as described below, the actual latency between sender and receiver is not measured, but rather the variable delay component, that is considered indicative of queuing delays and network congestion effects, may be determined on a per-packet basis. Moreover, the measurement may be conducted on devices in the network under test that are providing quality of service through any number of QoS mechanisms, or may be conducted on devices that are not providing quality of service at all. As will be understood, this enables the benefits of QoS to be quantified in a manner relative to non-QoS systems.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 2","FIG. 2"],"b":["60","62","64","60","66","66","68","68"],"i":["p ","p ","m "],"sub":["1","1","n "]},{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 3","FIG. 2","FIG. 3"],"b":["70","62","64","70","70","60","70","62","64","72","74","72","74","72"],"sub":["C ","C ","C ","C "]},"In accordance with one aspect of the present invention, the measurement tool of the present invention may be used to measure, on a per-packet basis, end-to-end network integrity and service quality for the verification of QoS. To this end, the measurement tool on a sender  sends a sequence of test packets through its network to the corresponding receiver , and then reports on the queuing delay experienced by each packet. Packets are marked with a sequence number at the sender such that packets that do not arrive at the respective receiver are recorded as dropped packets. The sequence numbers are thus unique, at least per session.","As generally represented in , the measurement tool comprises a session portion in a sender , including a user-mode test application  along with a kernel mode timestamp component , and a session portion in a receiver  including a user-mode test application  along with a kernel mode timestamp component . The network  shown in  may be a production network or a controlled network, or possibly some hybrid of both.","To run the session, a measurement tool session is invoked on both a sending host  and a receiving host  via the applications , . By default, the measurement tool invokes network QoS and is useful for evaluating QoS mechanisms, and various parameters are adjustable. For example, the measurement tool can be varied to simulate traffic flows for a range of user selectable packet sizes, and can simulate traffic flows shaped to a range of token bucket parameters.","Upon invocation, the measurement tool uses the GQoS application programming interface (API), which is part of Winsock2, to invoke QoS from local traffic control and from the network . One QoS signaling protocol is RSVP (Resource Reservation Protocol), which works over TCP\/IP. RSVP applications can use RSVP messages to request quality of service from the network and to indicate QoS requirements to the network and to peer applications. RSVP is suited for use with IP (Internet Protocol) traffic. As currently defined, RSVP uses Integrated Services (Intserv) semantics to convey its QoS requirements to the network.","RSVP messages follow the path of the traffic for which resources are being requested, whereby messages arrive at the devices whose resources will be utilized by a successful reservation, i.e., by admission of a flow. This provides admission control based on the current resources available in the affected devices, that is, RSVP-aware devices understand the applicability of RSVP requests to their specific media, and are able to accept of reject the messages based on their resources and ability to support the requests. Standard RSVP messages typically carry a quantitative description of the relevant QoS traffic in parameters referred to as token-bucket parameters (in Intserv semantics). RSVP is well-documented and is not described in detail herein for purposes of simplicity.","The measurement tool sender application  begins by causing an RSVP PATH message to be sent by the sender  towards the receiver  and waits until a response is received from the measurement tool receiver application . When received, the measurement tool receiver , which is awaiting an RSVP PATH message from the sender , responds by transmitting an RSVP RESV message back to the sender application .","Receipt of the RESV message at the sender application  triggers the measurement phase in accordance with one aspect of the present invention. To this end, the sender begins submitting one or more buffers (e.g., the buffer  of ) to kernel mode components  for transmission. Such components  typically include a sockets driver , a TCP\/IP driver , and a packet scheduler . The kernel paces the transmission of traffic according to the token bucket parameters and service type selected by the user via the measurement tool application  (e.g., entered by a user via a command line).","In accordance with one aspect of the present invention, as packets are transmitted, the timestamp component  associates a sequence number and a sender-relative (local) time (e.g., to a precision of 100 nanoseconds) with each packet. More particularly, as represented in , a typical packet includes some header information  and a data section . The timestamp component  modifies the packet by writing a sequence number (\u201cS\u201d in ) e.g., into a data field , and by writing the send timestamp (shown in  as the simplified whole number ten (10), but in actuality the current system tickcount) at one predetermined offset, e.g., in a send time data field . In keeping with the invention, the timestamp component  is installed below the other kernel mode components , which as will be understood, eliminates from consideration any transmission delay caused by higher components, thereby providing a more accurate time of actual send. If the timestamp component is not installed, the measurement tool may use a user mode timestamp component, (e.g., in the test application ), however this is less accurate than having the kernel mode component . Further, note that in one alternative, instead of actually stamping the packets, the sender can associate the timestamps with each packet locally, such as in a file or the like, and then later send the file to the receiver , from which the receiver application  can match the timestamp information with received packets, (e.g., by sequence number).","When each packet is received at the receiver , the receiver timestamp component  associates the packet with the local time therein. Thus, as shown in , when received, the receiving host  stamps the packet at a different data offset, e.g., at a received timestamp field , with the receiver's local timestamp (shown in  as the simplified whole number thirteen (13)). The stamped packet is then passed through other kernel drivers  up to the receiving measurement tool peer application , e.g., via a buffer  (). Again, the receive timestamp component  is preferably installed below the other receiver kernel mode components , to eliminate from consideration any transmission delay caused by higher components and thereby provide a more accurate (local) time of actual receipt. Also, as with the sender timestamp, the receiver timestamp component  can associate the timestamps with each packet in another way, such as by writing the local receiver timestamp in a file, and then later matching the timestamp information in the file to each appropriate received packet.","As represented in , the receiving measurement tool application  adds each received packet to a log  of all received packets, including the packet sequence number, the time sent and the time received. The test terminates on the sending side when the sender  has sent a predetermined number of packets (a default number of packets is 2,048, however the default number may be overridden, e.g., via a command line that runs the measurement tool). The sender  and receiver  may negotiate this number.","Following transmission of the last packet, the sender  sends a terminating sequence of (e.g., ten) \u2018termination\u2019 packets. The test terminates on the receiving side upon receipt of a termination packet or upon receipt of the required number of packets. Note that, on particularly congested links, the receiver  may never receive the required number of packets and the termination packets may be dropped. In this case, the receiver application  may be terminated by some other mechanism, e.g., a \u2018DONE\u2019 message received via a TCP control channel, or terminated manually.","Upon termination, the receiver application  parses and processes the log  of received packets. Note that after collecting the raw packet data , the receiver application  may perform this parsing\/processing, and other post-processing operations described below, or alternatively, some or all of these actions may be performed by separate components (as logically represented in ). In any event, parsing and processing preferably provides summary statistics, for example, the total number of packets received and the sequence number of each dropped packet, and these statistics are maintained in one or more files of packet information . Also preferably maintained in the file or files  is detailed information for each packet including a send time and receive time, which may be normalized, the latency (difference between sent and received time), which also may be normalized, the packet size and sequence number. Normalization is described below.","In this manner, the measurement tool generates detailed result logs, and is able to report very precise delay variations, on the order of microseconds or better.","In accordance with another aspect of the present invention, after the packets have been transmitted and received (that is, those not dropped), a second phase of the measurement tool processes the list of sent and received times to perform normalization. A clock correction mechanism  may first be employed to correct for certain hardware anomalies, described below, in which event corrected packet data  is used. A normalizer process  is then employed to normalize the data as desired.","To normalize, the lowest sent timestamp (which should be the first) is located, along with the lowest difference between sent time and received time across all pairs of timestamps, i.e., the lowest latency. These values are recorded. The lowest send time is then subtracted from other send times. Note that in the examples described herein, simplified (whole number) timestamps are used, and the received timestamps are always later than sender timestamps, (although straightforward logic is implemented to allow for the case in which the receiver's timestamps are actually earlier than the sender's timestamps).","By way of example, consider the following table of timestamps, also shown in the table of :",{"@attributes":{"id":"p-0055","num":"0054"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"center"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["TimeSent","TimeReceived","Latency"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["10","13","3"]},{"entry":["11","19","8"]},{"entry":["12","18","6"]},{"entry":[".",".","."]},{"entry":[".",".","."]},{"entry":[".",".","."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Upon parsing these records, it is determined that the lowest send time is ten (10) and the lowest latency is three (3). The lowest send time of ten is then subtracted from all sent timestamps, which has the effect of normalizing the first packet's send timestamp to zero and each following packet's timestamp to the difference between the time that the first packet was sent and the time the following packet was sent. After the first normalizing step, the table looks as follows (as also shown in table of ):",{"@attributes":{"id":"p-0057","num":"0056"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"center"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["TimeSent","TimeReceived","Latency"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","13","3"]},{"entry":["1","19","8"]},{"entry":["2","18","6"]},{"entry":[".",".","."]},{"entry":[".",".","."]},{"entry":[".",".","."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"During the next normalizing step, the lowest send time is subtracted from all received time stamps, yielding the following results (as also shown in table of ):",{"@attributes":{"id":"p-0059","num":"0058"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"center"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["TimeSent","TimeReceived","Latency"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","3","3"]},{"entry":["1","9","8"]},{"entry":["2","8","6"]},{"entry":[".",".","."]},{"entry":[".",".","."]},{"entry":[".",".","."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"In a last normalizing step, the lowest latency is subtracted from the received time stamps and each latency is updated to reflect the difference between the normalized send and receive timestamp pairs. Note that this corresponds to subtracting the lowest latency from each latency. This yields the following results (as also shown in table of ):",{"@attributes":{"id":"p-0061","num":"0060"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"center"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["TimeSent","TimeReceived","Latency"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","0","0"]},{"entry":["1","6","5"]},{"entry":["2","5","3"]},{"entry":[".",".","."]},{"entry":[".",".","."]},{"entry":[".",".","."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Note that the first packet shows a latency of zero, however this does not mean that the transmission delay is zero. Rather, it means that this packet's delay represents the best case or fixed delay that occurs between sender and receiver. Normalized latencies that are greater than zero indicate the amount of delay beyond the fixed delay or beyond the minimum delay. As such, these latencies represent the variable delay component that results from queuing and congestion, which as can be readily appreciated, is ordinarily more interesting than the fixed delay component from the perspective of network congestion analysis.","As is understood from above, no attempt is made to determine the actual latency between sender and receiver, only relative latencies, i.e., the variable delay component is determined, which is indicative of queuing delays and network congestion effects. Note that this approach will not always yield valid results, as it is based on the assumption that there is one latency that is indicative of the fixed delay component of the network. This can be accomplished by a calibration phase if the network under test is a controlled (isolated) network. More particularly, if the network is controlled exclusively by the tester, then the lowest latency can (and should) be calibrated. To this end, during the calibration phase, no noise should be generated on the network. This assures that queues in network devices will be empty and that the minimal latency logged will indeed be indicative of the fixed delay component of the network. Noise is introduced following the calibration phase.","Alternatively, if a large enough number of packets is sent during a test run, then it is statistically very likely (even in production networks) that at least one of the packets will end up in a very short (or zero length) queue, and will not be subjected to congestion delay. The minimum delay used in the calculation will be the delay experienced by this \u201cbest case\u201d packet. This assumption fails on a heavily congested network in which queues never drop to zero length, however.","Once the various sets of information have been normalized, analysis is simplified, and the data may be manipulated as desired to determine, for example, what happened to each packet on the network, the benefits of QoS, and so forth. For example, the various latencies may be plotted against the send times, for tests with and without QoS enabled. Note that once the raw packet data  is logged, the manipulation and\/or analysis of the data need not be performed at the receiver, and can be performed at any time, and\/or by some other process, as indicated in  by the dashed line separating the post-packet collection components \u2013.","Two examples of sample data for test trials measured via the present invention are shown in . Both trials were run across an isolated network consisting of two RSVP-capable routers connected by a 128 Kbps serial line. Each router was also equipped with an Ethernet interface. The sender was connected to one of the router's Ethernet interfaces, and the receiver was connected to the other. In addition, the sending port of a \u2018Smartbits\u2019 noise generator was connected to the same Ethernet network as the sender. The receiving port of the noise generator was connected to the same Ethernet network as the receiver. The noise generator was programmed to send 100 Kbps of noise traffic from sending port to receiving port such that the traffic generated by the noise generator would compete with the traffic generated by the test session for resources on the 128 Kbps link. The noise generator was programmed to generate a mix of packet sizes that simulated the typical load on a real corporate WAN link. The test session was invoked in a manner intended to simulate a telephony traffic flow. The parameters were set to result in a test traffic flow of 64-byte packets sent at a rate of 24 Kbps.","The purpose of the test was to examine the utility of RSVP in protecting the signal flow on a WAN link driven to near saturation. To this end, the first trial (which resulted in ) was run without RSVP enabled on the routers. The second trial (which resulted in ) was run with RSVP enabled on the routers. In both cases, RSVP signaling was used between the sender and receiver. The X-axis represents the packet sequence number, while the Y-axis represents the normalized latency in units of 100 nanoseconds.","Note that  are not the same scale, as the y-axis of  ranges from zero to 1.8 seconds, while the y-axis of  ranges from zero to 0.12 seconds (indeed, the entire display of  would fit below approximately halfway of the 2,000,000 label of ). As can be appreciated, the measurement tool provides detailed information that quantifies the benefits of QoS.","Clock Skew and Other Hardware Anomalies","As mentioned above, the raw latency data may be subject to hardware problems, which if left uncorrected, would adversely influence the results. One such problem results in a \u201cbug\u201d in a commonly used timer chip, wherein the HAL timer in a machine jumps forward in certain scenarios. As represented in the simplified graph of latencies against sent times of , the bug that causes jumps in a clock can lead to jumps in the relative latencies that do not accurately reflect the true latency differences. Indeed, the detailed information provided by the present invention was originally responsible for detecting this bug (subsequently diagnosed as an incorrectly set bit) in the particular timer chip. The detection and correction of the timer jump problem is described below with respect to , which essentially detects and subtracts the jumps, leading to the simplified graph of latencies versus sent times of .","Another hardware-related problem is clock skew, in which crystal oscillator-based personal computer clocks are often subject to deviation from their nominal frequency. The deviation is on the order of several parts per million, and as a result, clock skew measured between two contemporary personal computers may be on the order of ten microseconds per second.","As a consequence of clock skew, send timestamps and receive timestamps are generated based on clocks running at slightly different speeds. This leads to a result as generally represented in the simplified graph of , wherein the later in time that a packet is received, the greater (if the receiver clock is losing time with respect to the sender clock) the corresponding raw relative latency will be. Conversely, if due to clock skew the receiver's clock is gaining on the sender's clock, the later a packet is received in a session the shorter the relative latency will appear to be, resulting in a negatively-sloped line (not shown). When measuring queuing delays on the order of milliseconds over a period of seconds or minutes, the skew between the sending oscillator's rate and the receiving oscillator's rate is negligible. However, when measuring queuing delays that are much lower (such as on a high speed LAN) or when measuring delays over a long period of time, the clock skew may become significant.","To compensate for the clock skew, the timestamps are first normalized by factoring out the increase or decrease in slope over time. This step is based on the assumption that the clock skew is constant, while queuing delay is variable. In order to normalize for the effects of clock skew, the latency reports are fitted to a constant slope line. There are multiple possible statistical methods for this clock skew normalization. In one method, the sum of squared error as the goodness of fit measure is fit to a straight line (which makes an implicit assumption that latency is normally distributed). Another method uses absolute deviation as the goodness of fit measure, (wherein the assumption is that latency is more like a double exponential about the mean). As can be readily appreciated, other statistical methods provide acceptable results. Once the slope is determined, any constant variation in latency is removed from the resulting timestamps, which if then plotted, would generally result in the simplified, essentially zero-slope graph of . Note that this slope normalization should be performed after correction for any timer jumps, otherwise timer jumps would affect the slope.","Turning to an explanation of the operation of the present invention with particular reference to the flow diagrams of , a session operates as generally represented in step , by transmitting timestamped packets, stamping those packets on receipt, and then logging the information in those packets as described above. At step , the packets are arranged by sequence number (which should generally correspond to time sent). When transmission and receipt is complete, some time later at step  the post-collection process begins by continuing to step  of  to check for timer jumps. Of course, timer jump checking need not be performed for sessions wherein it is known that neither the sender nor the receiver includes a faulty timer chip.","Step  determines the amount of timer jump. This is accomplished in a Windows\u00ae 2000\/Windows NT\u00ae system from the operating system kernel by calling an API known as the QueryPerformanceCounterFrequency API. At step , the interpacket gaps on both the sender and receiver are determined. Also, note that latencies which are at least a fixed number of standard deviations away from the mean are referred to as \u201ctimer jumps.\u201d Step  selects the first latency to begin walking through the latencies to look for timer jumps.","Step  checks to determine if any \u201ctimer jump\u201d points are unpaired, that is, a suspected timer jump point in the set of sending timestamps is not matched with an equally suspect point in the set of receiving timestamps. If not, step  branches ahead to step , which selects the next latency at step  (or branches to  if no more) to repeat the test on the next latency.","If the suspected timer jump point is unpaired, step  instead branches to step  wherein it is determined whether the \u201ctimer jump\u201d unpaired point is solitary (that is, it is not surrounded by other suspect points). If so, this indicates a likely timer jump, otherwise it is likely an isolated incident. Via the last test at step , if a point if found that meets the above criteria, it is labeled as a timer jump point and added it to a list of \u201ctimer jump\u201d points. When the points have been evaluated, step  branches to step  of .","Step  begins walking through the timer jump point list built via . If any point is listed, the point is selected at step , and checked to see if the suspect timer jump point is approximately equal to the amount of timer jump returned via the QueryPerformanceCounterFrequency API. If not, this suspect point is discarded at step , otherwise step  branches to step  wherein the jump amount is subtracted from the point, and all points after them (since once the timer jumps it counts further ticks relative to the jump amount). Step  repeats the process until the timer-jump list is exhausted. As can be understood, by correcting for timer jumps, the \u201cstepped\u201d latencies represented in the simplified graph of  are thus brought back into alignment as generally represented in the simplified graph of .","Returning to step  of , the slope is calculated using an appropriate statistical mechanism as described above, and the calculated slope is then used to correct the latencies for clocks skew. For example, the raw received times can be appropriately raised or lowered based on a factor determined from the calculated slope. At step , the lowest latency is determined from the corrected values, essentially providing a truly-lowest latency value. Note that if the lowest send time has not yet been determined, it also may be determined at step . At step , the lowest latency is used to normalize the other latencies as described above, and if necessary, the lowest send timestamp may be used to normalize the send and receive times as also described above. At this time, the per-packet information may be analyzed in a straightforward manner.","As can be seen from the foregoing detailed description, there is provided a method and system for accurately calculating latency variation on an end-to-end path in a network. The method and system include a measurement tool that provides high resolution, per packet reporting, is capable of measuring of latency in one direction on networks including production and controlled networks, and does not require synchronization of system clocks.","While the invention is susceptible to various modifications and alternative constructions, certain illustrated embodiments thereof are shown in the drawings and have been described above in detail. It should be understood, however, that there is no intention to limit the invention to the specific form or forms disclosed, but on the contrary, the intention is to cover all modifications, alternative constructions and equivalents falling within the spirit and scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIGS. 6\u20139"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIGS. 16 and 17"}]},"DETDESC":[{},{}]}
