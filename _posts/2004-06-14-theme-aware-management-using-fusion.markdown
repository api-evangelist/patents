---
title: Theme aware management using fusion
abstract: A system and method are described that use theming functions of a theme manager to render graphical components in a themed fashion. The theme manager uses a theme file that has theme properties for graphical components of all types. When an application is started a system is provided that determines whether the application supports theming. If the application supports theming a dynamic link controls library that supports theming is linked to the application. If the application does not support theming, the non-theming controls library is linked. If an application supports themes, application user controls and shell common controls are rendered with themes by using the functions of the theming controls library that interact with functions of the theme manager. Non-client window components are rendered using themes by intercepting render messages to windows and sending the messages to the theme manager. Non-client window components are also measured and rendered using a theme property file when appropriate in response to certain application program interface calls.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06992681&OS=06992681&RS=06992681
owner: Microsoft Corporation
number: 06992681
owner_city: Redmond
owner_country: US
publication_date: 20040614
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATION","TECHNICAL FIELD","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This application is a continuation of application Ser. No. 09\/827,842, filed Apr. 5, 2001 Now U.S. Pat. No. 6,762,767 titled THEME AWARE MANAGEMENT USING FUSION, which was a continuation-in-part application of U.S. patent application Ser. No. 09\/670,791, filed Sep. 27, 2000 Now U.S. Pat. No. 6,873,337 and entitled \u201cApplication Programming Interface For Changing The Visual Style\u201d which claims the benefit of U.S. Provisional Application No. 60\/195,593, filed Apr. 6, 2000 and Provisional Application No. 60\/195,512, filed Apr. 6, 2000.","The present invention relates to a computer system and, more particularly, to theme aware management using fusion when rendering system components.","Computer users in both the business and home environment have become accustomed to using a computer with a graphical operating system. For example, many users operate computers having a Microsoft Corporation \u201cWINDOWS\u201d operating system thereon. Certain components of these graphical operating systems are known as \u201ccontrols.\u201d For example, a control may be an \u201cOK\u201d button, which is generally a rectangular button with \u201cOK\u201d written in it. By moving the cursor over the button and clicking on the mouse, a known operation will begin that is associated with the control. Many other controls exist, with examples including scroll bars, dialog boxes and sliders. Beyond controls, the graphical operating systems also draw, or render, other graphical components as needed on the display of the computer, such as the frame, the minimize box and the close box.","There are two general kinds of controls in WINDOWS: standard and custom. Standard controls are provided by the operating system. The code to create, draw and operate standard controls is contained in the common control library (DLL), a part of WINDOWS. Custom controls are all other controls. Custom controls may be created by the manufacturer of the operating system or by third parties. The code for custom controls is contained in a corresponding separate library (DLL) or within an application.","Currently, when a graphical user interface component, such as a control, is used by an application, the application requests that an instance of the component be created. Following this, the operating system transmits a generic message to the component, instructing the component to render itself. The application plays a role in routing the message from the main window to the targeted control, but the control code performs the drawing. The application uses application programming interfaces (API's) to create and interact with the control. An API serves as a software interface to be used by other programs, much as the keypad serves as an interface to a calculator. An API is a fundamental concept of high-level programming. In high-level programming, a program often does not execute tasks by itself. Instead, the program asks some other program to execute these tasks. For example, programs frequently delegate various tasks to the underlying operating system. Continuing with the above example, an application delegates the rendering of a control to the control's code.","In the prior art environment, when a generic rendering message is received by a control to draw itself, the control will draw itself using its own drawing software code. In this prior art environment, the control knows what it is supposed to look like, how it is supposed to behave, and can effectuate such a display on the user interface of the computer. Thus, the application may delegate all aspects of visual rendering to the controls, avoiding the need to contain software code to support the visual rendering of the control within the host application itself.","By utilizing the standard controls defined and rendered by the operating system, all controls will have the same appearance, regardless of the application. Users of graphical operating systems can change only a limited number of characteristics of the controls. In the \u201cWINDOWS\u201d operating system, a user can change the color scheme used to display the various controls and components on the monitor. The user can also select a small set of fonts to be used by the controls and components. Thus, the colors, fonts and a limited set of sizes of the controls and components may be changed. However, the basic appearance of the controls and components is dictated by the rendering software code within the control library containing the particular graphical component or control. In the prior art environment, to change the appearance of the controls or graphical components, the rendering software code must be altered. For example, if it is desired to change the appearance of the \u201cOK\u201d button, the rendering software code within the operating system DLL file containing the button control must be altered and the DLL file reconstructed at the binary level. If it were desired to render the button as an oval, rather than as the traditional rectangle, the software code would have to be changed accordingly. Such an approach makes it difficult, if not impossible, for a computer user and for software manufacturers, to easily alter the appearance of the controls and graphical components.","In order to enhance the user experience of the computer, it would be desirable for the user to have the ability to change the overall \u201clook and feel\u201d of the graphical display by changing the overall visual appearance or \u201ctheme\u201d of the various graphical components. In other words, it would be desirable if the user could change not only the color and font of the graphical components appearing on the monitor, but to change the appearance of those graphical components as well. For example, it would be desirable to be able to alter and direct the layout of the parts of a control, and to define the shape of a control or its parts. It would also be desirable to control all aspects of how a control or its parts are drawn. Because the controls and graphical components existing within the DLL file in the prior art environment are \u201chard coded\u201d with their own rendering software code, it is difficult and cumbersome to change the appearance of all of the controls and components. To do so would require recoding each of the controls to achieve the desired appearance. If multiple visual styles were required, they would each have to be predefined and each \u201chard coded\u201d into every control. Moreover, the controls must also be recoded if a different rendering technology is to be used. For example, if the controls are rendered using a bitmap and it is desired to utilize a vector-based renderer, each control must be altered.","Certain prior art approaches exist that attempt to address the above situation. However, these solutions do not allow all of the controls and graphical components of the entire system to be changed. Instead, the prior art approaches address only limited portions of the set of displayed components. This allows the appearance of some controls and graphical components to be altered, leaving the remainder unaltered. Such an approach leaves an appearance that is not as coordinated as may be desired.","The prior art approaches are further limited by the techniques they employ to implement control of the appearance characteristics of visual elements of the graphical user interface. Prior art appearance modifiers operate by intercepting the generic rendering signals transmitted to the control, and, using low-level operating system graphical APIs, substitute their own rendering code for that of the control. However, only a portion of the visual elements in the graphical user interface is interceptible. Because the prior art approaches depend exclusively on the interception of operating system signals, not only are they themselves incapable of controlling the appearance of visual elements that do not function according to this protocol, they are incapable of providing a standard means for the author of the visual element to modify the rendering code to accommodate external control.","Similarly, prior art approaches for rendering non-client windows components, such as window frames and the minimize box, have shortcomings. The prior art approach requires the user to buy a separate software package in order to support theming of these components. The prior art approaches are incomplete because they allow only a fixed subset of controls to be themable. Furthermore, their implementation architecture relies solely on interception of standard window messages without any control or USER32 knowledge of the theme drawing.","In the traditional operating system, non-client window components have been rendered by a default windows procedure in Windows Kernel Mode in response to a complex set of Windows messages and API calls. It would be impractical to put all the variations of themes into the single default windows procedure. Adding theme properties to default windows procedure would require more complicated code, complete recompilation of the code, and rigorous testing to determine if the code update functions properly and doesn't break any existing applications.","Further, it is not possible to intercept all relevant signals transmitted by the operating system to a control in the course of rendering. Still further, in neither the traditional operating system nor the theming methods of separate software packages is it always possible to reproduce complex visual behavior implemented by a control, such as animated sequences. Thus, the prior art approaches, including operating system approaches and approaches taken by separate software packages, are prone to functional incompatibilities, visual flaws, and performance problems.","Moreover, the prior art techniques are limited in the manner in which software developers can design controls to accommodate versatility in visual appearance. Using traditional \u201cOwnerdraw\u201d and \u201cCustomdraw\u201d routines, application developers have been able to render controls with only a limited set of options. The prior art approaches do not involve an architecture that allows a control author the flexibility to design a control that is \u201ctheme aware.\u201d Control authors are therefore not allowed the freedom needed in authoring controls to create controls that can be easily and cleanly visually altered.","Furthermore, a system that provides theme aware controls should accommodate both legacy applications and new applications that are capable of working with theme aware controls. Legacy applications have been developed and tested to work with the traditional controls that are not theme aware. New applications have been developed and tested to work with theme aware controls. A theme aware architecture must allow for both types of applications to operate on the same computer system.","For example, if a system that offers themes requires all the applications to use the theming controls even if they haven't been tested with the new controls, the application controls will not be rendered as the application developer expects. Therefore, the controls may appear inconsistent with the application's look or will be in the wrong place with respect to the application or may stop functioning altogether. Application writers should be able to control whether their applications use the new themed controls or continue using the traditional controls.","Yet another problem is that of new applications being unable to operate on traditional systems that are not theme aware. New applications will be developed and tested for new systems that provide themes. When these new applications are loaded onto old systems that are not theme aware, not only will the applications' controls not be themed, but also in many cases, the applications will fail. Therefore, there is not a way for theme aware applications to operate on non-theme aware systems.","In accordance with this invention, the above and other problems are solved by creating a theme aware version of controls and applying a software component selection technology called \u201cfusion\u201d to choose the theme aware version for theme capable applications. The invention includes a hook function to divert window rendering and sizing requests from the default window rendering function to a theme aware window rendering function.","One aspect of the present invention is a system and method for linking one of two sets of controls functions into an application's memory map after a determination is made whether the application supports theming capability or not. The system determines if the application has a manifest file indicating use of the theming set of controls functions. The theming set of controls is able to interact with the functions of the theme manager to render graphical components in a themed fashion.","The system and method also include an intercepting hook that intercepts render messages to windows. The intercept hook routes the render message from the default window rendering routine and sends the message to theme manager functions that render window graphical components in a themed fashion. Application program interface calls are also routed to the theme manager so that window non-client graphical components can be measured or rendered using a theme in response to the application program interface. The system and method also include methods of rendering user controls and shell common controls by using a set of theming controls functions that interact with functions of the theme manager that renders the controls in a themed fashion.","The invention may be implemented as a computer process, a computing system or as an article of manufacture such as a computer program product or computer readable media. The computer program product may be a computer storage media readable by a computer system and encoding a computer program of instructions for executing a computer process. The computer program product may also be a propagated signal on a carrier readable by a computing system and encoding a computer program of instructions for executing a computer process.","The present invention mitigates application compatibility risks and is faster than previous approaches. In addition to isolation of controls from rendering technologies, the present invention also provides for isolation of controls from individual themes. The present invention allows a user to pick from a variety of different themes that may be pleasing to the user and enhance the user's computing experience.","Additional advantages and novel features of the invention will be set forth in part in a description which follows, and in part will become apparent to those skilled in the art upon examination of the following, or may be learned by practice of the invention.","In one embodiment of the present invention illustrated in , operating system  is a graphical operating system having graphically displayed controls and components associated therewith. Controls include, but are not limited to, such things as scroll bars, push buttons and sliders. Other controls are within the scope of this invention, and are known to those of skill in the art. Other graphically displayed components are also within the scope of this invention. These components include, but are in no way limited to, non-client sections of the windows in the display, such as the frame surrounding an application display on the user interface, the minimize box, and the close box.","In , the basic architecture used in this embodiment of the present invention is illustrated. If the reader is already familiar with the operations of the theming system due to familiarity with the related patent application identified above, then it is suggested that the reader proceed to the description of  to understand embodiments of the present invention related to a theme aware architecture for theming system components. The architecture is illustrated with example applications  and  that are open and running on the computer . As an application, such as APP1  is running it often requires a control or graphical component to be rendered, or displayed, on the monitor  of the computer .","In , libraries ,  and  are linked to the applications  and  through a fusion module . Fusion module  enables the theming of controls in applications without needing to change the applications themselves to request the themable version of the controls. Fusion module  enables applications  and  to load the specific version of the DLL ,  or  at run time through the use of a manifest . The fusion manifest  specifies the environment in which an application will run, which allows multiples versions of a DLL to exist on one machine. Thus, fusion module  will map the request for a component so that it is rendered as a themable element in DLL  instead of a non-themable element from DLL . This allows an existing application to be themed without changing code of the application. Fusion module  also allows the new themable controls to be placed in a different DLL from the existing DLL, which simplifies implementation and minimizes compatibility risks.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 2","b":["100","100","100","100"]},"The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers, server computers, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like.","The invention may be described in the general context of computer-executable instructions, such as program modules, being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.","With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus also known as Mezzanine bus.","Computer  typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer  and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can accessed by computer . Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs  and , other program modules , and program data .","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk  such as a CD ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through an non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in , provide storage of computer readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs  and , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices such as a keyboard  and pointing device , commonly referred to as a mouse, trackball or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . In addition to the monitor, computers may also include other peripheral output devices such as speakers  and printer , which may be connected through a output peripheral interface .","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Although many other internal components of the computer  are not shown, those of ordinary skill in the art will appreciate that such components and the interconnection are well known. Accordingly, additional details concerning the internal construction of the computer  need not be disclosed in connection with the present invention.","Those skilled in the art will understand that program modules such as the operating system , application programs  and , and data  are provided to the computer  via one of its memory storage devices, which may include ROM , RAM , hard disk drive , magnetic disk drive  or optical disk drive . Preferably, the hard disk drive  is used to store data  and programs, including the operating system  and application programs  and .","When the computer  is turned on or reset, the BIOS , which is stored in the ROM  instructs the processing unit  to load the operating system from the hard disk drive  into the RAM . Once the operating system  is loaded in RAM , the processing unit  executes the operating system code and causes the visual elements associated with the user interface of the operating system  to be displayed on the monitor . When an application program, such as application  is opened by a user, the program code and relevant data are read from the hard disk drive  and stored in RAM .","An example display of graphical components having a variety of appearances is seen in . As shown in , the controls may take the form of an OK button , a Cancel button  and an Apply button . The present invention allows the appearance of the controls and other components to be visually changed to better suit the desire of the computer user. The invention allows the appearance of the controls to be altered beyond color and font selection. For example, the layout of the parts of a control can be defined as desired. For example, a scroll bar could be rendered with the up and down arrow buttons adjacent to each other at the bottom of the scroll bar, instead of the up arrow and the top and the down arrow at the bottom. Further, the shape of the control and its parts may be defined. As shown in , four different overall appearances are shown for each of the buttons ,  and . Each different appearance setting is coordinated and is called a \u201ctheme.\u201d Each theme is represented by one of the rows of buttons in . While only four themes are shown in , an unlimited variety of themes may be created for selection by the computer user. The theme is a collection or set of appearance characteristics relating to a particular subject or desired visual environment. As described below, the present invention allows the user of the computer to specify which of a number of predefined themes is to be applied to the controls and other components of the visual display. Moreover, the present invention allows new visual themes to be added to the system without the need of changing the software code of the controls and other graphical components. Still further, the present invention allows addition of new rendering technologies or modification of existing rendering technologies without changing the software code of the controls and other graphical components.","As an application, such as APP2  in , is running it often requires a control or graphical component to be rendered, or displayed, on the monitor  of the computer . For example, with reference to , the display of an OK button  may be needed by the application on the monitor. Application  requests that an instance of button  be created. Following this, the operating system transmits a generic message to the control instructing it to draw itself. This request would be routed to the dynamic link library (DLL) that contained the particular control. As an example, the DLL in the WINDOWS operating environment would be called User32.dll or ComCtl32.dll(V5), shown as  and , respectively, in . Libraries  and  exist within graphical operating system . Libraries  and  are typically linked by default with application . As will be discussed later, the lilnking of libraries  and  can be overridden by use of fusion . The defined control within libraries  and  contains the drawing code needed to render the control on the monitor. Therefore, to change the appearance of controls in libraries  and , the software drawing code must be changed for each control within libraries  and .","An additional library DLL, shown as  in , is similar to library , in that it contains a number of predefined controls and graphical components that may be used by application . Broadly, DLL  contains a number of components that are to be graphically displayed. In library , however, the controls are defined differently, making them \u201ctheme aware.\u201d Rather than containing all of the software code needed to render the control in multiple visual styles, the controls are defined with certain basic information or values about the control, for example, the location, parts and states of the controls.","The location is the position on the user interface where the control is desired. Parts are the different items that make up the control. As an example, a scrollbar control has an elongated rectangular shaft part, a smaller thumb part that slides within the shaft part, and an arrow part at each end of the shaft part. The state of a control describes the current appearance, which reflects the functional state of that part. For example, a button can be active, pressed, hot (when the mouse is over the control), disabled or inactive.","The controls within DLL  also contain the drawing code needed to render the controls if no themes are selected, as well as the theme-aware paths through the code. DLL  requests rendering or drawing services from a theme manager DLL . Theme manager  provides the requested rendering services and draws the control on the display at the indicated location, with the indicated parts in the indicated states.","Theme manager  contains a series of APIs that allow library  to interact and communicate with the theme manager. The APIs allow a control author to define a control within DLL  as a series of parts and states without the need for software rendering code. These APIs are generally divided into three types: drawing APIs , information APIs  and utility APIs . Drawing APIs  are generally used to render and assist in the layout of the needed control parts and other components. Information APIs  are generally used to obtain information about the current defined appearance of the controls to allow controls to be individually customized. Utility APIs  are those APIs used by parts of the operating system other than the controls, to control theme selection. Utility APIs  include functions that can be used to enumerate installed themes and load one of them.","Drawing APIs  are a collection of theme-aware drawing services. Each individual API within the set of drawing APIs  is used to perform a different drawing service. Generally, each API requires a specified part and state of the graphical component at hand. An API called \u201cDrawThemeBackground\u201d is provided that draws the theme-specified border and fill for the specified part and state at the desired location. Similarly, an API called \u201cDrawThemeText\u201d is provided that draws the specified text using the theme-specified color and font for the specified part and state.","As an example, if an OK button  () was requested by an application , the control within DLL  would pass the part, state and location information to drawing APIs  through a function call, such as DrawThemeBackground, or DrawThemeText. As is more fully described below, this part and state information is matched with appearance characteristics and theme manager  draws the control on the monitor. Drawing APIs  further include an API called \u201cGetThemeBackgroundContentRect.\u201d This API allows the control to obtain the size of the content for the theme-defined background. Usually, this is the area inside the borders or margins. By using this API a control can determine the available area within the background in which items may be placed. When using this API, the control within DLL  is requesting information regarding a graphical component with a specified part and state. This information is obtained by the theme manager  and returned to the control. A similar API called \u201cGetThemeBackgroundExtent\u201d is provided that calculates the size and location of the theme-specified background for the specified part and state given a content rectangle. This API may be used when the content is known, and based upon that content, the outer boundary for the theme background needs to be determined. Another API called \u201cGetThemePartSize\u201d is provided to retrieve the theme author specified minimum and normal sizes of a control part.","Drawing APIs  further include an API entitled \u201cGetThemeTextExtent.\u201d This API is used to calculate the size of a specified text when rendered in the theme font. This API can therefore be used to determine the width and height of a given text string. The control author can thus specify a part and state having text associated therewith and use this API to obtain information from theme manager  regarding the size of the text string. Similarly, another API entitled \u201cGetThemeTextMetrics\u201d is available that can be used to obtain size information about the font being used. Therefore, this API may be used to obtain information such as the width of an average font character. In other words, this API is used to obtain from theme manager  information that the control needs regarding the size of a theme-specified font.","An API entitled \u201cGetThemeBackgroundRegion\u201d is also provided within drawing APIs . Within some operating systems, a region is a way to describe a non-rectangular shape. A region can also be thought of as an image with transparent parts. This API is used to compute the region for a regular or partially transparent theme-specified background. In other words, this API may be used to determine what is transparent and what is opaque within the framed background for a specified part and state. Thus, this API supports the definition of non-rectangular shapes of controls and parts. Similarly, an API entitled \u201cHitTestThemeBackground\u201d is provided. This API is used to determine whether the point within the background for the specified part being clicked is in a transparent or an opaque area. This API is used by a control within DLL  to obtain information from the theme manager . If the click is within a transparent area, no action may be needed. Conversely if the click is within an opaque area, an action may be required.","Another API contained within drawing APIs  is entitled \u201cDrawThemeLine.\u201d This API allows a theme to define a generic style of a line. This generic style may be accessed and used for a specified part by calling the \u201cDrawThemeLine\u201d API. Similarly, an API entitled \u201cDrawThemeBorder\u201d is provided that allows a theme-defined border to be specified. The theme-border may be drawn for a specified part utilizing this API.","An API entitled \u201cDrawThemeIcon\u201d is provided that allows a theme-defined icon to be rendered that may include theme-specified special effects. For example, a theme-icon may have a different appearance when the mouse is directly over the icon, such as a glowing appearance.","Drawing APIs  also contain an API entitled \u201cIsThemePartDefined\u201d that may be used to determine if the theme has defined parameters for the specified part and state. If the part is not defined within the theme the control can draw this part itself. If the part is theme defined, theme manager  will render the part according to the theme defined information. Another API is provided entitled \u201cIsThemeBackgroundPartiallyTransparent.\u201d This API is used to determine whether or not the background is a rectangle or region that has a transparent part. This API may be used to simplify the control code. If there is no transparency within the background, then there is no need to conduct any hit testing through the use of the \u201cHitTestThemeBackground\u201d API.","Importantly, drawing APIs  further include an API entitled \u201cOpenThemeData.\u201d This API is used to obtain the handle for a list of class names. A class name list identifies a set of graphical components, and may be divided into parent class names and one or more child class names. For examiner, a parent class name might be button. A child class name for that parent class might be \u201cstart button.\u201d A handle is a reference to an internal structure detailing various information and properties of the object. Theme manager  will search for each class name in the list and use the first matching theme information found. For example, if the class names included both start button and button, the start button theme information would be used if it existed. If start button theme information did not exist, the theme information for a button would be used. If no value is found the old code will be used to render the control. If any non-0 value is returned, a valid theme handle is established. This theme handle will be returned to DLL  and used for all of the theme drawings.","Similarly, another API provided is entitled \u201cCloseThemeData.\u201d This API is used when the control is closed, such as a button no longer being needed, or when the theme is changed, as is more fully described below.","Another API provided is entitled \u201cIsThemeActive.\u201d This API allows a control within DLL  to obtain a true or false answer as to whether there is a current theme in effect. This API can thus be used to determine whether to call the \u201cOpenThemeData\u201d API or merely use the existing drawing code where the controls will render themselves.","As described above, theme manager  also contains a set of information APIs . These information APIs  allow controls to be individually customized. In other words, these APIs are utilized in only certain instances and may be used to obtain information about specific controls. These information APIs are used to query theme manager  for defined theme information regarding specified properties of the theme. Each API  thus requests information, which is provided by theme manager .","Within information APIs  is an API entitled \u201cGetThemeColor.\u201d This API utilizes the specified part and specified state along with a specified color property identifier to obtain information about the theme color. The property identifier is the color property number that is desired. In other words, the color API is used to ask for the color value corresponding to the property desired, such as the background color. Another API called \u201cGetThemeMetric\u201d is provided that requests and receives a size value for a specified property identifier. This size value will be an integer. An API entitled \u201cGetThemeString\u201d is also provided within information APIs . This API is used to obtain the string for a specified property identifier. The string will include information regarding the number of characters in the string and where the string is terminated.","Another API is provided within information APIs  entitled \u201cGetThemeBool\u201d that will return an integer that is either 0 or 1 for a given part, state and property. The 0 and 1 correspond to a false or true state for that part, state and property. Another API provided is entitled \u201cGetThemelnt.\u201d That will return an integer value for a specified part, in a specified state with a specified property identifier. Similarly, an API is provided entitled \u201cGetThemeEnumValue\u201d that will return the theme-enum for the specified part, state and property identifiers. An enum is merely a variable that holds numeric values which correspond to symbolic information. For example, an enum for alignment might be left, middle, right corresponding to the numbers 0, 1, 2.","Another API entitled \u201cGetThemePosition\u201d is provided that will return two integer values, corresponding to an x-location and a y-location for a specified part in a specified state with a specified property identifier. Another API provided within information APIs  is entitled \u201cGetThemeFont.\u201d This API is used to obtain a logical description of the font theme used, given a specified part, state and property identifier.","Yet another API provided within information APIs  is entitled \u201cGetThemeRect.\u201d This API will return four integers representing the left, right, top and bottom of the specified part, state and property identifier. Similarly, an API entitled \u201cGetThemeMargins\u201d is provided that will return four integers representing a left space, right space, top space and bottom space given a specified part, state and property identified. There is also an API entitled \u201cGetThemeIntList\u201d which returns the value of a specified property whose type is a list of integer values. Finally, an information API entitled \u201cGetPropertyorigin\u201d is provided that returns the location from which the property originated. This API allows the control author to obtain information for the property origin. In other words, the API allows the control author to determine whether the property was specified on the state, part, class, global or was the property not found. This is needed because theme properties are specified by the theme author in a hierarchical fashion. For example, if a property is not specified at the \u201cstate\u201d level, the theme manager will search the \u201cpart\u201d level, \u201cclass\u201d level, and finally the \u201cglobals\u201d level for the property. Sometimes it is important for the control to know if a property was explicitly defined for the part\/state it is processing. There is also an API entitled \u201cGetThemeFilename\u201d which returns the string value of the specified filename property.","Another API provided within information APIs  is entitled \u201cSetWindowTheme.\u201d This API allows a control author to redirect a control window to use a different set of theme information than its class would normally use. In other words, this API allows a control to be used while giving the control a special look other than the standard look defined by the theme for that class. This API may use additional parameters to identify a particular application and class name. This allows a theme author to use the specified class but to change the appearance of that class. For example, a button may be defined that has a given button appearance. Utilizing this API, this button can be redirected to a different class name. For example, \u201cOKButton\u201d may be specified. The theme author will then be able to use a class called \u201cOKButton\u201d and the \u201cOKButton\u201d will have a different appearance from the standard button appearance.","There is also a subset of theme metrics APIs within the information API group that parallel the WINDOWS system metrics, but which are specific to a theme. Unlike normal control-based properties, these properties are available to and shared by all controls. \u201cGetThemeSysColor\u201d returns the theme-specified color value of the specified system color index. \u201cGetThemeSysColorBrush\u201d returns a handle to a drawing brush that is the color of the specified system color index. \u201cGetThemeSysSize\u201d returns the integer size of the specified theme size index. \u201cGetThemeSysBool\u201d returns a boolean (0 or 1) value for the specified theme boolean index. \u201cGetThemeSysFont\u201d returns a logical font structure for the specified theme font index. \u201cGetThemeSysString\u201d returns a string value of the specified theme string index.","There are also some application-oriented API's within the information API group . \u201cIsAppThemed\u201d returns a boolean (0 or 1) value indicating if the application is being themed by the operating system. \u201cGetWindowTheme\u201d returns the most recent theme handle, if any, opened for the specified window. \u201cGetThemeAppProperties\u201d returns the flags that control which parts and types of windows are themeable within the application. \u201cSetThemeAppProperties\u201d allows the application to set these same flags.","Finally, there are information API's  for error handling. \u201cGetThemeLastErrorContext\u201d returns the error context (including error code, error code parameters, filename and source line) associated with the last reported theme error on the current thread of execution. \u201cFormatThemeMessage\u201d returns the error string for the specified error context in the specified language.","Theme manager  includes not only drawing APIs  and information APIs , but also a set of utility APIs . These APIs may be used to achieve a variety of results.","Drawing APIs  and information APIs  allow the author or creator of controls within DLL  to define the controls as a series of parts and states. The defined control is therefore abstracted from the rendering process of theme manager  and is also abstracted from the theme-defined appearance information or characteristics, as is more fully described below. Using APIs  and  the control author can create controls that are \u201ctheme-aware\u201d and that are equipped to communicate with theme manager . This communication involves passing basic information or values to theme manager  that allow the theme manager to render the desired control, having the needed parts in the desired states.","Theme manager  also contains the renderers needed to execute the drawing instructions. For example, a border-fill renderer  could be used that allows different color themes to be applied to the controls. As another example, a bitmap renderer  could be used that defines the control parts as images. Other examples of renderers include using a vector definition language, portable network graphics (PNG) files, or portable document format files (PDF). It should be understood that the present invention is not limited to a particular rendering technology. If a different renderer is desired or needed, the drawing code of theme manager  is revised to add the renderer to theme manager . The controls within DLL  are therefore isolated or abstracted from the rendering technology within theme manager . This allows different renderers to be added to theme manager  without having to revise the controls within DLL , as is more fully explained below.","The renderer within theme manager  renders the requested control according to an appearance theme that has been selected by the user of the computer. For example, appearance themes  and  are shown in . As shown, theme  may be a consumer theme and theme  may be a business theme. It should be understood, however, that other themes could be used and that the invention is in no way limited to the particular theme. For example, other themes could include a cartoon theme, a children's theme or a golf theme. As seen in , business theme  has been selected by the user, as represented by the solid line . Consumer theme  is available for selection, as represented by the broken line .","Each theme  and  has similar architecture. As seen in , business theme  includes a series of image files . Image files  are the image files that will be used by the particular theme. In this case, image files  are the image files that will be used by business theme . Business theme  also includes a themes.ini file . File  is a text file and can be created in either ANSI or UNICODE character sets. File  specifies the available color schemes and sizes available for the theme. In the case of theme , file  specifies the available color schemes and sizes available for business theme . File  therefore represents all of the variations of the theme to which it applies.","Theme file  consists of one or more sections. The sections within theme file  include a documentation section , a size section , a color scheme section  and a file section . Documentation section  is optional and may contain any property name. Size section  specifies the size name, such as \u201cdefault size,\u201d \u201cvery small\u201d or \u201cvery large.\u201d Color scheme section  is used to specify a simple color scheme name and an optional color scheme transformation associated with the color scheme name. File section  is used to specify a unique name for the class data file. The file section  will include a file name, a color scheme (from color scheme section ) for that file name, and the sizes (from the size section ) that the file will support.","Theme  includes a second .ini file labeled  in . File  is a class data file that contains the theme data for a specific size and color theme. File  may also contain defining sections. For example, file  may contain a globals section that defines the properties of the particular class of control. File  may also contain a section that allows the system metrics to be obtained and used. Finally, file  may contain a group of class sections. Each class section name contains a class name, an optional part name, and an optional state name. Within the section are the property\/value pairs that define the appearance of the specified part or control. For example, a class name would be \u201cslider\u201d for the slider control. A part specified for the slider would be \u201ctrack.\u201d States defined for the track part would be \u201cnormal,\u201d \u201cdisabled,\u201d and \u201chot.\u201d The class section name can also include an application (or \u201cgroup\u201d) name, which specifies that the section only applies to a specific application (or \u201cgroup\u201d name, as specified by the SetWindowTheme API).","Image files , theme file , including file  are broadly grouped together to make up theme directory . Theme directory  and a system schema file located within the theme manager  are used to load business theme . The system schema file is the file that defines property numbers for all of the properties involved in a particular theme and is basically a master definition file that allows the themed properties to be assigned a number corresponding to a defined appearance.","Theme directory  thus contains a theme.ini file , a class data file  and all of the image files  used by the theme. The contents of theme directory  can be packaged into a DLL file by packthem tool . Packthem tool  processes the theme.ini file by parsing it against the schema file for syntax errors and adding the .ini file to the package being built. Recognized properties from documentation section  are written to a package string table. Color scheme information from color scheme section  and size information from size section  is also written to a package string table. Each class data file  is also processed. As the class data file is processed, the file is parsed against the schema file for syntax errors. The class data file is also added to the package being built.","The DLL file produced by packthem tool  is business theme file . File  contains the theme data and this theme data is isolated from control library . This allows different themes to be created and selected without changing the controls defined within library . Thus, control authors can create and define controls independently of the appearance or theme data. File  is in binary format and is passed into a shared theme data file  when business theme  is selected by the computer user, as best seen in . File  is a shared memory map file that can be accessed by all processes. Thus, when a theme is selected by the computer user, theme manager  will read the information for a defined theme file, such as file , and will place that information in a binary format in file  where all running processes have access to the binary information.","As best seen in , a theme-switching control panel  is provided that is in communication with theme manager . Panel  cooperates with a user interface that displays the available themes from which the user can select. As shown in , control panel  would allow a user to select business theme  or consumer theme . If, as has been discussed above, business theme  is selected and the user of the computer switches to select consumer theme , theme  will be loaded into shared memory map file  as binary data. Theme manager  also sends a message to each theme-aware control within DLL file  that the theme has changed. Each theme-aware control knows how to respond to this message.","When the theme-aware control receives a message that the theme has changed, the control will close the current theme handle that was received via the OpenThemeData API. The control will then attempt to open a new theme handle, again using the OpenThemeData API. If a new theme handle cannot be opened, the control knows that the theme has been switched off for that control and that the old drawing code is to be used by the control to draw itself. If a new theme handle is opened, theme manager  will look at the theme binary data and will start a new drawing routine so that all of the theme-aware controls are redrawn utilizing the newly selected theme, such as consumer theme . Any information that was cached regarding the previously selected theme is invalidated and that information must be recalculated.","In operation, as is best seen in , an application  or  will request a graphic, such as a control, to be rendered on the user interface, as represented at . This graphical request is routed through fusion . As represented by , the fusion process will determine if the requested control is a theme-aware control. If the control requested is not theme-aware, the old code is used and the control will draw itself using a control from DLL  or , as represented by  in . If the control is theme aware, the graphical request is processed in DLL , as is represented by . The controls within DLL  will pass basic information for the graphical request, such as the part, state and location for the requested control to the theme manager  in a request for rendering services, using APIs ,  and . Thus, the graphical request is processed in DLL  without application of the appearance characteristics that are found by theme manager . Theme manager  will then determine or apply the theme-specific appearance characteristics for the given control part and state, as shown by . This appearance data is retrieved from the shared memory map data file . Using the retrieved appearance data, for the requested control part and state, along with the location, the theme manager will render the control on the display of the computer, as represented by .","Referring to , another embodiment of the logical operations implemented in fusion  () is illustrated. In this embodiment the fusion operation is performed when the application is loaded rather than routing application requests through fusion as in . Fusion allows for older non-theming applications to operate as intended in a theming environment by linking the older non-theming controls to the older applications. Older, non-theming controls are provided in User32.dll and ComCtl32.dll Version 5 (V5). User32.dll provides user controls such as buttons, scroll bars, and list boxes. ComCtl32.dll V5 provides shell common controls, such as toolbars, list views, and tree views. Fusion  links the theming control file, ComCtl32.dll version 6(V6), to new applications that have been developed and tested in a theming environment.","In  operation flow begins at loading operation  wherein an application begins running on the system. Part of the start-up processing is dynamic linking of controls libraries. Linking is the process of uniting references between program modules and libraries of subroutines to create a load module that is ready to run on the computer. After loading operation , control transfers to the manifest detection operation  wherein it is determined whether the application has a manifest associated with it. If there is not a manifest, control transfers to linking operation  wherein the traditional controls, User32.dll and ComCtl32.dll V5, are linked into the application's memory map. As mentioned earlier, the traditional controls are not theme aware.","If, on the other hand, there is a manifest, such as manifest , in manifest detection operation , control transfers to the theming module searching operation , wherein it is determined whether ComCtl32.dll V6 is listed in the manifest. If the manifest does not list ComCtl32.dll V6, control transfers to the linking operation , wherein the traditional controls are linked into the application's memory map. If, on the other hand, ComCtl32.dll V6 is listed in the manifest, transfer controls to linking operation  wherein the theme aware controls of ComCtl32.dll V6 are linked into the application's memory map.",{"@attributes":{"id":"p-0089","num":"0088"},"figref":["FIG. 5","FIG. 5"],"b":"502"},"In the first situation, when a non-client window message  is generated, the non-client area of a target window may need to be rendered. The non-client area of the window typically has one or more non-client graphical components, such as a minimize box, window frame, and close box. The non-client window message  can be any message sent to the window, including, but not limited to, measurement or rendering messages. For example, when a computer user resizes a target window, a non-client window message  is sent to the window, requesting that the window be re-rendered at the new size. A non-client window message  is typically received by an application that is using the target window, such as APP2 . The application, such as APP2 , may perform an action, such as adjusting the appearance of its GUI, based on the non-client window message . The non-client window message  is then intercepted by a UserAPIHook , which routes the message to the theme manager . UserAPIHook  may be a part of the theme manager . The theme manager  interprets the non-client window message . Depending on the non-client window message , the theme manager  may make measurements regarding the dimensions of the non-client window components, and may use theme properties in the shared theme data  to render the non-client area of the window.","Continuing with the example of , when an application, such as APP2 , or a control of an application, makes an API call, the result may affect the non-client area of the window. In this case, the non-client window area may be re-rendered using theme properties. For a theme aware application, such as application , an API call, such as API call , may be made to USER32 . The API call  may be any API call, including, but not limited to any of the API functions discussed previously. For example, the \u201cMoveWindow( )\u201d API call can change the size, location, and z-ordering of the window, requiring the window frame to be redrawn. When a theme is active, USER32 , upon receiving the API call , will route the API call  to UserAPIHook . UserAPIHook  then routes the API call  to the theme manager . The theme manager  interprets the API call  and makes measurement calculations regarding the dimensions of the window frame. The theme manager  then uses the shared theme data  to render the non-client window area with theme properties, if necessary.","In the embodiment of , USER32  handles non-client APIs and messages for both themed applications, such as APP1  of , and non-themed applications, such as APP2 , as shown in . The message flow shown in  is the same for non-themed applications and themed applications. Thus, the non-client graphical components of windows are themed regardless of whether the application is theme aware or not.","Importantly, UserAPIHook operation  redirects rendering requests to the theme manager  that is able to use the shared theme data  to render the non-client area of the window with theme properties. As discussed earlier, theme property data can be added easily for window components by adding the property to the \u201c.msstyles\u201d file. This allows for a large variety of themes for non-client window components with no change to the control software.","The logical operations of the various embodiments of the present invention are implemented (1) as a sequence of computer implemented acts or program modules running on a computing system and\/or (2) as interconnected machine logic circuits or circuit modules within the computing system. The implementation is a matter of choice dependent on the performance requirements of the computing system implementing the invention. Accordingly, the logical operations making up the embodiments of the present invention described herein are referred to variously as operations, structural devices, acts or modules. It will be recognized by one skilled in the art that these operations, structural devices, acts and modules may be implemented in software, in firmware, in special purpose digital logic, and any combination thereof without deviating from the spirit and scope of the present invention as recited within the claims attached hereto.","Alternative embodiments of the present invention will become apparent to those skilled in the art to which it pertains upon review of the specification, including the drawing figures. Accordingly, the scope of the present invention is defined by the appended claims rather than the foregoing description.","Although the invention has been described in language specific to computer structural features, methodological acts and by computer readable media, it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific structures, acts or media described. As an example, other decision methods may be included in the fusion process in combination with the control rendering modules. Therefore, the specific structural features, acts and mediums are disclosed as exemplary embodiments implementing the claimed invention.","The various embodiments described above are provided by way of illustration only and should not be construed to limit the invention. Those skilled in the art will readily recognize various modifications and changes that may be made to the present invention without following the example embodiments and applications illustrated and described herein, and without departing from the true spirit and scope of the present invention, which is set forth in the following claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
