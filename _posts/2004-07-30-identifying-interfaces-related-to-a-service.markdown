---
title: Identifying interfaces related to a service
abstract: A method in a computing device for identifying interfaces related to a service provider includes receiving a call identifier as an explicit parameter in a call or as an implicit parameter contained within input data to request a service provided by the service provider, the call identifier representing a version of the service.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07406520&OS=07406520&RS=07406520
owner: SAP Aktiengesellschaft
number: 07406520
owner_city: Walldorf
owner_country: DE
publication_date: 20040730
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The present invention relates to identifying interfaces related to a service provider.","A simple Web service scenario typically includes a Web service provider and a Web service client. The Web service provider implements and exposes some functionality to Web service clients. This functionality is described in an implementation independent format, e.g., using the Web Service Description Language (WSDL). Before a Web service client can access a remote Web service at runtime, the Web service client typically has to get the WSDL file from a Web server, and generate and deploy a local proxy for the remote Web service. Usually a commercial Web service has a long lifetime. Due to, for example, changing requirements, the remote Web service needs to be adjusted from time to time. Often it happens that the remote Web service is changed in an incompatible way without changing the Web service client accordingly at the same time.","There are generally two ways to change Web services incompatibly. The first way is that the syntax of an application programming interface (API) has changed. For example, the number of non-optional input or output parameters, the formal parameter types, or the parameter domain values have changed. The second way is that the semantics of the API has changed. For example, the API implementation expects some database entries (e.g., customer or material entries) as its input data and internally calls some other functionality (not necessary a Web service or an API implementation) to, for example, generate additional documents. If the API implementation performs some security checks, then deleting parts of checks for some security constraints would be semantic changes.","Typically, to handle incompatible changes, the changed Web service implementation is regarded as a new Web service. Web service clients that would like to access the changed Web service need to be updated. Often the old and the new Web service are used in parallel. Old Web service clients can call the old Web service and new Web service clients can call either the new Web service or, deliberately, its older version.","The document describes methods and apparatus, including computer program products, for identifying interfaces related to a service provider.","In general, in one aspect, the invention features a method for identifying interfaces related to a service provider, the method including, in a computing device, receiving a call identifier as an explicit parameter in a call to request a service provided by the service provider, the call identifier representing a version of the service.","In embodiments, the call identifier can be received as an implicit parameter contained within input data. The version of the service can represent a syntax version and a semantic version. The call can represent implementations of a service, and the version of the service can represent a particular implementation requested from the service provider.","The method can include receiving the call to request the service, and determining the particular implementation requested using the call identifier. The call can represent functionalities and the version of the service can represent a particular functionality requested from the service provider.","The method can include detecting a mismatch between a service client and the service provider using the call identifier. The method can include providing a corrective action in response to the detected mismatch between the service client and the service provider using the call identifier. The corrective action can include converting the call based on the call identifier.","The method can include defining functionality associated with the call identifier in an implementation independent format. The implementation independent format can include a service description in an appropriate language (e.g., Web Service Description Language (WSDL) version 1.1).","The method can include publishing the call identifier to a service registry. The service registry can comply with versions of Universal Description, Discovery, and Integration (UDDI) specifications.","The method can include generating a proxy including the call identifier.","The method can include defining a document including the call identifier, and passing the document in the parameter in the call.","Implementations can realize one or more of the following advantages. API descriptions and API implementations can evolve over time more easily because the techniques described herein provide a facility for dealing with such changes.","Interface changes can include changes in the syntax and semantic of interfaces, because in either case, they will be detectable. Providers can easily identify each version of API descriptions and API implementations. Providers can easily detect if clients are built against valid API descriptions and API implementations. If a call identifier does not match between a client and a provider, the provider can react in any of many different manners (e.g., abort, warn, convert request, inject functions, wrap service, delegate to specific implementation, and so forth).","Clients can easily identify each version of API descriptions and API implementations. Clients can be sure that providers are able to detect mismatches in interface provisioning and usage. Providers can hide different functionality behind a single service interface. In such cases, the call identifier helps to identify which functionality is requested.","Clients can use a single interface signature and therefore the same call code to request different functionalities. In this context, an interface signature is understood as the syntactical part of an interface definition. This mechanism also overcomes the burden of re-publishing a Web service again and again, which is especially annoying in case of minor changes or bug fixes. Therefore the techniques described herein enable a very versatile variant facility. A client calls a specific functionality variant by just choosing a specific call identifier. Providers delegate to specific implementations through change identifier analysis. This additionally allows a type of \u201chandshake protocol\u201d between clients and providers. The handshake protocol can deal with very different topics, e.g., device types, client geographical location and locale, time zones, time-dependent legal requirements (e.g., change of tax rates) and the like. Even load balancing can be handled with a call identifier (e.g., requests with specific call identifier sets are delegated to specific servers). One implementation of the invention provides all of the above advantages.","The details of one or more examples are set forth in the accompanying drawings and the description below. Other features and advantages of the invention are apparent from the following description, and from the claims.","Like reference numbers and designations in the various drawings indicate like elements.","As shown in , an exemplary system  can be used in identifying interfaces related to a service provider. The system  includes a service client  and a service provider . The service client  is a computer program and\/or computing device that requests a service  from the service provider . The service  can be any functionality that the service provider  provides, such as searching for particular data in a storage device, modifying particular data in a storage device, performing a specific calculation using particular data, accessing a backend device, and so forth.","To make a request for the service , the service client  transmits a call to the service provider . The call has a particular signature that is defined by the service provider . The signature includes one or more parameters needed to successfully invoke the service  and obtain the desired results. For example, the service  can be a service that provides details of orders that are stored in an order database. To obtain an order, the service client  has to provide to the service provider  the order number and the customer number. A call to request this service can be, for example, \u201cgetOrder(callIdentifier, orderNumber, customerNumber).\u201d","As illustrated in this example, the call includes \u201ccallIdentifier\u201d as one of its parameters. The call identifier represents a version of the service  to which the call corresponds. The call identifier is defined when the service is established. By using a call identifier within the call itself, a call identifier module  can determine a version of the service  to which the call corresponds. This means that the call identifier module  can determine both syntax and semantics to which the call corresponds. The call identifier can be, for example, a hash value or a Universal Unique Identifier (UUID). Items associated with the call (e.g., name of API, name of the service , parameters of the call, and so forth) can be used to generate a UUID.","For example, the call identifier \u201c1234\u201d was defined when the customer number of the \u201cgetOrder\u201d call was represented by a ten digit number, where the first three digits represented a company, the next three digits represented a division of the company, and the last four digits represented a building to which the order was being delivered. The call identifier \u201c1235\u201d was defined when the customer number format of the \u201cgetOrder\u201d call was changed to be the first four digits represented a company, the next three digits represented a division of the company, and the last three digits represented a building to which the order was being delivered. With this simple example, it can be seen that even though both formats use ten digits, the call identifier advantageously enables the call identifier module  to identify what format the customer number is in and whether that particular call is compatible with the current version of the service  provided by the service provider .","As shown in , a process  for identifying interfaces related to a service provider is illustrated. In one particular example, the description of the process  includes components illustrated by system . A software developer implements () a first version of the service . To inform unit  (the service client) about the Web services exposed by the service provider , each Web service is described in an implementation independent format, such as in the Web Service Description Language (WSDL). In addition, the service provider  publishes () that Web service description, e.g., a WSDL document, in a service registry. The service registry can, for example, comply with the Universal Description, Discovery, and Integration (UDDI) specification. The service provider  also publishes () the call identifier that corresponds to the version of the service  that was developed ().","Using the WSDL description, the service client  obtains () the published description and call identifier (e.g., from a registry). Using the description and call identifier, the service client  can generate () a proxy that includes a call to request the service . When the service client  wants to request the service , the service client  transmits () the call to the service provider . As described above, the call has a call identifier as one of its parameters. The service provider  receives the call and verifies () the call identifier against the version of the service . For example, the call identifier module  can read a table that defines the call identifier for the current version of service  to be \u201c1234.\u201d If the call identifier in the call matches this table entry, then the call identifier module  has verified () that the call is appropriate for the current version of the service  and transmits the call to the service  for processing. In this portion of process , the call was generated using the first version of the service  and that first version is still in use, so the call identifier does match and the service provider  provides () the requested service.","Later, for any of many reasons, a second version of the service  is developed (). As described above, the description and the call identifier for the second version of the service  are published (, ). The service client  is unaware that a second version of the service  has been published. In many cases, the service provider  does not know the identity of its clients and cannot notify its clients of service API changes or service implementation changes. Also, the API descriptions, e.g., WSDL documents, focus on syntactical descriptions. They do not describe the semantics of the API or the behavior of the API implementation and often cannot express changes in semantics.","The service client , unaware of the change, transmits () another call to the service provider  to request the service  again. Because the service client  is unaware of the new second version of the service , the call identifier used is the call identifier corresponding to the first version of the service  (e.g., \u201c1234\u201d). The service provider  receives the call and verifies () the call identifier. In this case, the call identifier module  reads that the call identifier in the call is \u201c1234\u201d but the call identifier for the second version should be \u201c1235.\u201d Upon detecting this mismatch between the service client  and the service provider , the service provider  provides () a corrective action to the service client . The corrective action can include, for example, aborting the request, transmitting a warning, converting the request and injecting functions as needed, wrapping the service, delegating the request to a specific implementation, and so forth.","For example, with the customer number format example described above, in the first version with the call identifier \u201c1234,\u201d the first three digits represented a company, the next three digits represented a division of the company, and the last four digits represented a building to which the order was being delivered. In the second version with the call identifier \u201c1235,\u201d the first four digits represented a company, the next three digits represented a division of the company, and the last three digits represented a building to which the order was being delivered. Using this example with process , when the second request is received (), the format of the customer number is ten digits. Without anything more (e.g., without a call identifier), the second version of the service  would take that ten digit number and process it, even though the service client  was formatting the number according to the first version of the service (e.g., only the first three digits represented the company). Without the call identifier, the service client  would receive a different result than expected, with no explanation of the error.","With the call identifier (e.g., \u201c1234\u201d), the call identifier module  can determine () that the call is based on the first version of the service . Because the service  is at a second version and there is a mismatch, the call identifier module  can determine the corrective action to take, and if applicable, provide () the corrective action to the service client . In one example, the call identifier module  can initiate a reply to the call that delivers a message to the service client  that the service  has changed and that an update to the service client is necessary to continue to use the service . In another example where a lookup table is used to track the associations of service versions to call identifiers, the call identifier module  can determine the corrective action by using the same lookup table as the version numbers. Such a lookup table could include a row for each version number, with one or more columns representing prioritized corrective action instructions that the call identifier module  can process.","The call identifier module  can convert the call for the new version of the service . For the ten digit customer number example, the call identifier module  or the service itself  can use a table to convert the ten digit customer number of the first version to the second version, if the changes are compatible. If not compatible, the service provider  can transmit a message to the service client  that the versions are not compatible. If the versions are not compatible, the call identifier module  can also initiate a download to the service client  with the information needed to upgrade the service client . For example, the service provider  can transmit the WSDL description and the call identifier associated with the second version of the service  to the service client .","The examples above describe a different version of the service  due to a change that is implemented subsequent to publishing information about the service . Different versions of a service are not limited, however, to subsequent changes. As shown in , an exemplary system  is illustrated in which a service provider  provides n different parallel implementations , , . . . , referred to generally as the service . When the service client  wants to select a particular service implementation (e.g., , , . . . or ), the service client  uses a call identifier that corresponds to that particular service implementation. For example, a call identifier \u201c1236\u201d can correspond to the first service implementation , a call identifier \u201c1237\u201d can correspond to the second service implementation , and a call identifier \u201c1249\u201d can correspond to the nth service implementation . In such an example, a service provider facade module  can process all incoming calls and direct each call to the appropriate service implementation , , . . . based on the call identifier. In one example, the service provider facade module  can use a lookup table to determine which call identifier corresponds to which service implementation , , . . . ","In a particular example, the service  can provide an optimization of data. In this example, each service implementation , , . . . provides a different optimization algorithm to optimize the data. Depending on the type of problem, the service client  can call a particular optimization algorithm best suited for that problem using the respective call identifier for the desired service implementation. In other examples, the different service implementations , , . . . can represent different functionalities all together. In other words, different services are provided by different service implementations. In such examples, the call identifier is used to identify which functionality the service client  is requesting. For example, instead of having different calls for different methods, there can be one universal call, and the method is selected and identified using the call identifier.","The call identifier can be used for static proxies (e.g., proxies developed or generated at development time), for dynamic proxies (e.g., proxies generated at run time), and for calling the service without any proxy (e.g., using \u201craw\u201d or low-level functionalities). The call identifier can have some attributes, e.g., predecessor-successor relationships and shared closures thereof (versioning), and tracking of version status (active, outdated, and so forth). Changes of these attributes may be published in registries, along with the call identifier. The examples described above are applicable to both remote calls and to local calls (e.g., calls between or within the same address space). The call identifier can be used for many types of communications (e.g., RPC\/RFC ) and for different kinds of messaging.","The above-described techniques can be implemented in digital electronic circuitry, or in computer hardware, firmware, software, or in combinations of them. The implementation can be as a computer program product, i.e., a computer program tangibly embodied in an information carrier, e.g., in a machine readable storage device or in a propagated signal, for execution by, or to control the operation of, data processing apparatus, e.g., a programmable processor, a computer, or multiple computers. A computer program can be written in any form of programming language, including compiled or interpreted languages, and it can be deployed in any form, including as a stand alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A computer program can be deployed to be executed on one computer or on multiple computers at one site or distributed across multiple sites and interconnected by a communication network.","Method steps can be performed by one or more programmable processors executing a computer program to perform functions of the invention by operating on input data and generating output. Method steps can also be performed by, and apparatus can be implemented as, special purpose logic circuitry, e.g., a field programmable gate array (FPGA) or an application specific integrated circuit (ASIC). Modules can refer to portions of the computer program and\/or the processor\/special circuitry that implements that functionality.","Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer. Generally, a processor will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a processor for executing instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks. Information carriers suitable for embodying computer program instructions and data include all forms of non volatile memory, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in special purpose logic circuitry.","To provide for interaction with a user, the above described techniques can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer (e.g., interact with a user interface element). Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input.","The above described techniques can be implemented in a distributed computing system that includes a back-end component, e.g., as a data server, and\/or a middleware component, e.g., an application server, and\/or a front-end component, e.g., a client computer having a graphical user interface and\/or a Web browser through which a user can interact with an example implementation, or any combination of such back-end, middleware, or front-end components. The components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (\u201cLAN\u201d) and a wide area network (\u201cWAN\u201d), e.g., the Internet, and include both wired and wireless networks.","The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.","It is to be understood that the foregoing description is intended to illustrate and not to limit the scope of the invention, which is defined by the scope of the appended claims. Other embodiments are within the scope of the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3"}]},"DETDESC":[{},{}]}
