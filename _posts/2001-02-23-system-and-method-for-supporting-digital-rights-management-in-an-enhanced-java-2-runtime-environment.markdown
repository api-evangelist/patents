---
title: System and method for supporting digital rights management in an enhanced Java™ 2 runtime environment
abstract: A digital rights management (DRM) system and methodology for a Java client implementing a Java Runtime Environment (JRE). The JRE comprises a Java Virtual Machine (JVM) and Java runtime libraries components and is capable of executing a player application for presenting content that can be presented through a Java program (e.g., a Java application, applet, servlet, bean, etc.) and downloaded from a content server to the client. The DRM system includes an acquisition component for receiving downloaded protected contents; and a dynamic rights management layer located between the JRE and player application for receiving requests to view or play downloaded protected contents from the player, and, in response to each request, determining the rights associated with protected content and enabling viewing or playing of the protected contents via the player application if permitted according to the rights. By providing a Ad DRM-enabled Java runtime, which does not affect the way non-DRM-related programs work, DRM content providers will not require the installation of customized players. By securing the runtime, every Java™ player automatically and transparently becomes a DRM-enabled player.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07308717&OS=07308717&RS=07308717
owner: International Business Machines Corporation
number: 07308717
owner_city: Armonk
owner_country: US
publication_date: 20010223
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["1. Field of the Invention","This invention relates generally to Java Digital Rights Management (DRM) systems, and particularly, to a dynamic rights management layer for enhancing the runtime behavior of a Java\u2122 2 Runtime Environment by enforcing users rights with respect to and preventing unauthorized uses of downloaded digital content.","2. Discussion of the Prior Art","With the advent of the Internet, the possibility to easily sell and rapidly distribute high-value digital contents has become a reality. There is a risk in this approach, though. Once downloaded to a client system, digital content can be misappropriated and illegally redistributed. While this problem has affected copyright material for centuries, the exposure with digital content is greater. A photocopy of a paper book is less valuable than the original, whereas a copy of an HTML book is identical to the original. Similarly, a copy of an analog audiotape has lower fidelity than the original; a copy of a digital audio file maintains its audio fidelity. Digital copies are perfect copies. With the prevalence of Internet access, it is possible for an unscrupulous entity to duplicate and distribute any number of unlicensed copies of an original. In fact, this can be done internationally, including from a server in a country with less restrictive intellectual property laws.","In the past few years, a number of Digital Rights Management (DRM) products have attempted to address the issue of licensing and controlling distribution of digital content. In general, all DRM systems allow the distribution of digital contents in an encrypted form. A set of rights is associated with the content, and only after acquiring the rights to access a protected piece of digital content will a user be allowed to decrypt it. Examples for such systems include IBM's EMMS, ContentGuard originally from Xerox, and the Metatrust system from Intertrust.","In a sophisticated DRM system, users are prevented from directly decrypting the contents. The decrypting key is hidden in the player. Therefore, they cannot decrypt the contents, save them, and distribute them in a decrypted form, unless they use a certified and tarnper-resistant DRM software, which will allow such operations only if those users have acquired the rights to do so. However, the general approach adopted by the DRM systems commonly available on the market requires the use of a specific player, which can either be a totally new player (such as a new browser, media player, etc.) or a modified version of an existing player (such as a DRM-enabled version of an existing browser or media player). Users must install such a player in order to access any form of protected content that is downloaded on their machines. This approach may be secure enough to protect copyrighted material, but is highly intrusive, and lacks flexibility. In fact, the major problems associated with this solution are:","Platform Dependency","Tamper-resistant DRM software targeted to client systems will work only on the specific platform to which it has been written (typically, one of the Microsoft Windows\u2122 flavors). However, nowadays, a substantial number of end users are starting to use PC platforms different from Windows\u2122, such as Linux\u2122 and Macintosh\u2122. Moreover, even the Windows\u2122 platforms present substantial differences that often require modification in the code. Therefore, the distribution across the Internet of high-value digital content will be successful only if a version of the DRM client code is written to each target platform.","In addition, even server machines can be DRM client systems. A Web server or Web application server machine may need to become DRM-enabled client to, say, acquire high-value digital contents and then disclose it only to specific users, or only under certain time- or price-related conditions. For server systems, the platform-dependency issue is even more important. In fact, for many servers the operating system belongs to the UNIX\u2122 family.","In addition to this, many market analysts predict that DRM content distribution will be extremely successful as soon as small devices (such as cellular telephones and handheld computers) will become DRM-enabled. In other words, a version of the DRM client code should be provided for such devices too.","Application Dependency","When a DRM system is based on a particular application that is distributed to all the DRM clients, the major problem is that users will be allowed to use only that application if they want to access those contents. Other applications, even if they support that particular type of contents, will not work, because they will be unable to access or calculate the secret decrypting key, and decrypt the contents. This creates a limitation. Many users may want to use their preferred application (such as their favorite browser, with the plug-ins that they have installed on it, or their favorite media player, etc.). Existing applications may be more sophisticated than a DRM player, and end users may experience annoyance from the usage of an imposed application that they may not like.","Content Type Dependency","In the scenario just described, the set of content types that may be DRM-protected is limited by the number of content types supported by the DRM player. Let's assume, for example, that the DRM application is a browser. This could be a brand new browser, specific to DRM applications, or a modified version of an existing browser (such as Netscap\u2122 Navigator\u2122 or Microsof\u2122 Internet Explorer\u2122). In such a situation, the set of contents that can be displayed by the DRM player is limited to HTML, GIF, JPEG, and a few other formats. If the digital publisher wanted to distribute MP3 music files in a protected fashion, a new DRM-enabled MP3 player should be written, or the browser should be enhanced to support the MP3 format, since common browsers do not support the MP3 format.","It is clear, then, that in order to be successful on the market, a DRM system should be flexible and minimally intrusive, and should not put any conditions on the type of the contents that need to be delivered, nor on the applications used to access such contents.","It would be further highly desirable to provide a DRM system for platform-independent computing system that implements a Java\u2122 Virtual Machine (JVM) and provides a Java\u2122 Runtime Environment (JRE).","Since its inception, Java\u2122 has shown that it was designed for the net. Java\u2122 brought about, for the first time on a large scale, the concept of dynamic loading of code from a source outside the system, i.e., \u201capplets.\u201d Though this is very powerful, and adds several features to the system using it, it is also a grave security threat. That is, there could be several risks associated with loading and running remote code. For instance, the remote code could steal memory, or CPU time; it could throw in a virus; it could read files on a local system and transmit them to another machine, etc. However, Java\u2122 is not just for applets any more. Developers now use Java to build stand-alone, enterprise-class applications to enable disparate clients, such as workstations, PCs or Java\u2122-based network computers to access legacy databases and share applications across the network.","It is immediately clear, then, why unlike other programming languages and systems, security mechanisms are an integral part of Java\u2122. In fact, Java\u2122 was designed to offer the following basic security measures: 1) Language design features\u2014such as type safe conversions only, no pointer arithmetic, bounds checking on arrays\u2014for providing strong memory protection; 2) a flexible sandbox mechanism for limiting what a Java\u2122 program is permitted to do; and, 3) encryption and digital signatures which may be used by code providers to sign their Java\u2122 application classes. In this way, the end user can ascertain who the owner of the code is and whether the class file was altered after having been signed by the provider's digital certificate. Java\u2122 security additionally builds upon three fundamental components of the Java\u2122 Runtime Environment (JRE): a ClassLoader that is responsible for locating and loading classes, ensuring that system-level components within the run-time environment are not replaced; a class file verifier that ensures proper formatting of downloaded code and verifies that the bytecode does not violate the type safety restrictions of the JVM, that internal stacks do not over\/underflow, and that the byte code instructions will have correct typed parameters; and a SecurityManager that performs run-time access controls on attempts to perform file I\/O, network I\/O, create a new ClassLoader, manipulate Threads\/ThreadGroups, start processes on the underlying operating system, terminate the JVM, load non-Java\u2122 libraries (native code) into the JVM, perform certain types of windowing system operations and load certain types of classes into the JVM. For example, the Java\u2122 applet sandbox, a function of the SecurityManager, severely constrains untrusted applets to a limited set of functions that are considered to be safe.","The focus of early versions of security in Java\u2122 has been greatly on applets, and how to protect the client machine from malicious applets. For example, the first release of the Java\u2122 Development Kit (JDK), called JDK V1.0, addressed the problem of protecting client machines from malicious applets by running all non-local code inside a sandbox. All local code (applications and applets) was by default trusted, and all non-local code, by default was untrusted. This initial limitation was partially solved in JDK V 1.1, when signed remote applets were permitted access to several of the system resources that were off limits for those applets without signatures on them. The security scenario in the newer version of the JDK, called Java\u2122 2 SDK, extends the concept of signed code to local code as well. With the new security model, all code, whether loaded remotely or locally, signed or unsigned, will get access to system resources based on what is mentioned in one or more policy files. Now, two local codes no longer have the same access to system resources if one of them is considered trusted, and the other is not. The whole thing can be specified in the policy files as to what permission a user wishes to grant to code residing in which code source, or what permission a user wishes to grant to code signed by whom.","It would additionally be highly desirable to provide a platform-independent and application-independent DRM system obtained by enhancing the Java\u2122 2 security model that provides protection for digital contents once these have left a DRM server machine to reach a Java\u2122 client.","It would further be highly desirable to provide an enhanced Java\u2122 Runtime Environment (JRE) that is provided with a DRM that enables any Java\u2122 player running on the JVM to become a DRM-enabled player in a manner that is transparent to the player\/viewer application running on the host system.","It is an object of the present invention to provide a flexible, minimally-intrusive, platform-independent and application-independent Digital Rights Management (DRM) system that does not require specialized players.","It is another object of the present invention to provide a new security paradigm to enable support of a DRM system in a platform-independent and application-independent operating environment such as provided in a Java\u2122 platform whereby, in addition to implementing Java\u2122 security mechanisms for achieving a level of protection by forbidding code downloaded from untrusted servers to perform malicious operations, implementing the same Java\u2122 security mechanisms for providing protection to DRM content providers so that they will not loose copyright control over the contents that clients have downloaded. In such a paradigm, the client is treated as untrusted, while the server, once authenticated, may be considered trusted.","It is a further object of the present invention to provide a platform-independent and application-independent DRM system obtained by augmenting the Java\u2122 2 security model without modifying the components of the Java\u2122 security architecture and without modifying or reducing the current Java\u2122 security mechanisms afforded thereby.","It is still another object of the present invention to provide an enhanced Java\u2122 Runtime Environment (JRE) that includes a DRM system and method that enables any Java\u2122 player running on the JRE to become a DRM-enabled player in a manner that is transparent to the player\/viewer application running on the host system.","It is yet still another object of the present invention to provide a DRM system and method for implementation in a Java Virtual Machine (JVM) that hides, within the JVM itself, the logic to access or calculate a secret decrypting key and turns on a digital rights management mechanism only when contents require it.","It is still a further object of the present invention to provide a DRM-enabled JRE that extends the fine-grained security model of the Java\u2122 2 platform that is designed to protect client systems against malicious users.","It is a further object of the present invention to provide a DRM-enabled JRE that permits DRM server systems to exercise access control restrictions on protected contents even after such contents have been downloaded to client systems. That is, the solution presented in accordance with the invention ensures that there is no way for the content to be saved unencrypted on the local file system, or printed, or distributed to another machine through a TCP\/IP connection, because the JRE on which a Java\u2122 Player or viewer runs will prevent these operations from happening.","Thus, according to the principles of the invention, there is provided a digital rights management (DRM) system and methodology for a Java client implementing a Java Runtime Environment (JRE). The JRE comprises a Java Virtual Machine (JVM) and Java runtime libraries components and is capable of executing a player application for presenting content that can be presented through a Java program (e.g., a Java application, applet, servlet, bean, etc.) and downloaded from a content server to the client. The DRM system includes an acquisition component for receiving downloaded protected contents; and a dynamic rights management layer located between the JRE and player application for receiving requests to view or play downloaded protected contents from the player, and, in response to each request, determining the rights associated with protected content and enabling viewing or playing of the protected contents via the player application if permitted according to the rights.","Advantageously, the system is minimally intrusive, i.e., the DRM component implemented in the JRE does not affect the way the JRE itself works for non-DRM-related contents. On this JRE, users will still be able to run all the Java\u2122 programs that they were able to run before. Furthermore, the system is platform independent because Java\u2122 is a platform-independent programming language and is fully portable across the platforms, and there are no operating system limitations. In addition, the system is application independent. That is, as long as the player used is a Java\u2122 program capable of running on the Java\u2122 2 platform, there are no player limitations or restrictions. Every Java\u2122 player will automatically and transparently become a DRM player by the virtue of running on the DRM-enabled JVM. This allows end users to play DRM-protected contents with their favorite Java\u2122 players. The system does not put any limitation to the type of contents that can be displayed. Since there are no player limitations or restrictions, there are no limitations or restrictions on the types of contents that can be displayed. Therefore, as soon as digital publishers feel the need to sell their contents in a new format, they may do it as long as a Java\u2122 player for that format exists. Moreover, a user will additionally be able to use the enhanced JRE for those contents that do not require any DRM control, since the DRM component in this JRE is activated only when DRM-protected contents need to be played.","Until now, Java\u2122 security was all about protecting client systems against malicious servers. In order to support DRM in Java\u2122, it is necessary to introduce a new security paradigm: client systems still have to be protected against malicious servers, but now server systems also are protected against malicious clients that, once downloaded high-value contents, may steal and distribute illegal copies.","The current Java\u2122 2 introduces a number of security features, which make it easier to enforce access control of protected resources. Particularly, the Java\u2122 2 permission model is a flexible model that even permits application-defined resources to be added to the access control system. Java\u2122 programs now have the ability to define access restrictions on sensitive resources without requiring the writing of a new SecurityManager or modifying the underlying platform. This means that applets downloaded into a browser, or servlets loaded into a Java\u2122-enabled Web server or application server, can add resource access controls to a JVM without having to modify the underlying browser or server implementation.","One of the notable features of the current Java\u2122 2 security model is that most of the access control implementation is contained in the Java security subsystem. Typically, Java\u2122 programs (such as applications, applets, and servlets) and components\/libraries (such as packages and beans) do not need to contain any access control code. When a program wants to add protected resources to the JVM, a method call may be added that will check whether the restricted operation is permissible. The general technique employed in the Java\u2122 2 security model is to create a guarded object, whereby access to an object, or operations on an object, is restricted by an access control call.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 1","FIG. 1","FIG. 1"],"b":["10","15","20","25","18","28","22","11","20","22","19","24"]},"As mentioned, the three legs of JVM security are the ClassLoader, class file verifier, and the SecurityManager. Prior to Java\u2122 2, each application had to write its own subclasses of SecurityManager and ClassLoader. Java\u2122 2 simplified the development process by creating a subclass of ClassLoader called SecureClassLoader  as shown in . SecurityManager no longer is abstract, and can be instantiated or subclassed. Most of its methods now make calls to methods in a class called AccessController, which provides the access control function on the Java\u2122 2 platform. Since most of the SecurityManager methods call AccessController, this greatly simplifies the writing of new SecurityManager subclasses.","To automatically invoke the new security subsystem, a Java\u2122 application is started from a native operating system's command line with a special argument to indicate that the new access control features should be used. The Java\u2122 runtime creates an instance of SecureClassLoader , which in turn is used to locate and load the application's class file. A subclass of SecurityManager is created and installed in the Java\u2122 runtime. The application's main() method is then called with the command line arguments.","The purpose of the change in the Java\u2122 runtime for starting Java\u2122 applications is two fold. First, a simple SecurityManager is installed in the system that uses the new Java\u2122 security access control subsystem. Second, the SecureClassLoader  () is used to safely and correctly load classes into the Java\u2122 runtime and, particularly, functions to: 1) make sure that searching for classes is done in the correct order; and, 2) to create and set the ProtectionDomain information for classes loaded into the JVM.","With respect to the first purpose, the SecureClassLoader  operates as follows:\n\n","As shown in , with respect to the second purpose, the SecureClassLoader  operates as follows: when the SecureClassLoader  loads a class into the JVM, the code base URL  and the digital certificates  used to sign the class file (if present) are used to create a CodeSource . The CodeSource  is used to locate (or instantiate) the ProtectionDomain  for the class which includes the Permissions  that have been granted to the class. Once the class file has been loaded into the JVM, the SecureClassLoader  assigns the appropriate ProtectionDomain to the class. This ProtectionDomain information, and in particular the Permissions in the ProtectionDomain, is used in determining access control during runtime.","Once a Java program starts to run, SecureClassLoader assists the JVM in loading other classes required to run the program. These classes are also assigned the appropriate ProtectionDomains, based on their CodeSource.","At this point, the Permissions granted to each single class are enforced by the SecurityManager currently in effect. The SecurityManager class in Java\u2122 2 relies on java.security.AccessController for any access control decision. AccessController is responsible for verifying that all the classes involved in any executing thread are granted the Permission to perform any security-sensitive operation. That is, starting with Java\u2122 2, the SecurityManager may defer access control decisions to the AccessController. Determining security policies is much more flexible now since the policy to be enforced by the SecurityManager may be specified in a policy file. The AccessController provides a simple procedure for giving specific permissions to specific code. The Java\u2122 API still calls the check methods of the SecurityManager to enforce system security, but most of these methods call the checkPermission() method in AccessController. The checkpermission() method is then responsible for walking back through the thread stack, obtaining the ProtectionDomains for all the classes on the stack, and verifying that the permission to check is granted.","The present invention is directed to the addition of new components that extends the Java\u2122 2 security architecture to provide fine-grained protection to the digital contents that users have downloaded from a DRM server. That is, according to the invention, the base Java\u2122 2 security architecture is customized to employ a DRM SecurityManager or DRM Policy Object that enables enforcement of rights acquired by the user. The concepts relating to a transparent Digital Rights Management system as described in commonly-owned, co-pending U.S. patent application Ser. No. 09\/667,286 entitled TRANSPARENT DIGITAL RIGHTS MANAGEMENT FOR EXTENDIBLE VIEWERS, the whole contents and disclosure of which is incorporated by reference as if fully set forth herein, are applicable to the system of the present invention as now described.",{"@attributes":{"id":"p-0048","num":"0050"},"figref":["FIG. 2","FIG. 2"],"b":["50","50","51","60","65","50","70","74","75","60","80","90"]},"Acquisition Tool","More particularly, client systems must be provided with an Acquisition Tool  (which could be a Java\u2122 program as well as a native program), by which end users can connect with a remote DRM content server, depicted as content server (e-Store) , and download protected contents previously encrypted by a Content Preparation Tool , and eventually buy the rights to access such contents. The Acquisition Tool interacts with the Content Server (e-Store)  and a Clearing House  in order to download the encrypted contents and get the decrypting keys respectively. This technology does not differ in Java\u2122 from what it has already been demonstrated and implemented on other DRM platforms (see, for example, the IBM EMMS system). That is, according to known techniques, content is downloaded to the client's local disk, encrypted with a symmetric key. The symmetric key itself is downloaded together with the content. However, this key is encrypted with the Clearing House's public key, so that only the Clearing House  can decrypt the symmetric key by using its own private key. The purchased rights associated with content are also stored encrypted on the local disk . As soon as they are downloaded, encrypted contents may stay on the local disk of the client machines, and may be distributed around without any legal restriction. Decryption of these contents is prohibited until the end user acquires the ability to access them. In this case, contents will become accessible through the trusted DRM-enabled JVM of the invention. As shown in , the acquisition tool  will communicate with the clearinghouse, pass the encrypted symmetric key to the clearinghouse , and ultimately receive a copy of the key that it can decrypt. This communication is performed securely in order to avoid main-in-the-middle or \u201csniffer\u201d attacks. Once the symmetric key is obtained, the trusted acquisition tool decrypts the content, immediately re-encrypts it with a new symmetric key, and stores it encrypted on the Java client system. The new symmetric key is generated on the fly by the system  based on some secret features found on the client machine hardware.","Launcher","In addition to the additional security mechanisms implemented in the JVM to ensure proper DRM support, the DRM-enabled JVM  of the present invention is provided with a trusted, tamper-resistant Launcher application  for activating the JVM .","Specifically, at JVM startup, the launcher application preserves the integrity of the JVM, its DLLs, all the Java\u2122 libraries, and verifies all of the security configuration files. To provide this functionality, the Launcher employs a standard means of message digest verification. In addition, it verifies that only trusted packages are installed in the extension framework. In order to avoid an instance of malicious users replacing JVM components after their verification but before their loading, the loading and verification of all the JVM components is forced at JVM startup. Preferably, the Launcher trusted application  is written in native code and properly obfuscated, and must be installed on client systems in order for these to be DRM-enabled. In fact, if the JVM is not started through the Launcher, it will still work as a traditional JVM, but will refuse to activate its DRM component, making it impossible to access DRM-protected contents.","Protocol Handler","Once started by the launcher, the DRM-enabled JVM  works as a regular JVM until the end user indicates that they want to access some protected contents. Typically, Java\u2122 players, as well as native players, offer the option to access contents by specifying the URL at which such contents reside. This option can be specified in a text box as well as within the <APPLET> tag of an HTML page. Therefore, a possible way to indicate to the JVM that some contents are DRM-protected is to extend the JVM with a Java\u2122 DRM Protocol Handler . Particularly, the DRM Protocol Handler is responsible for checking the rights that the user has acquired. If the user has acquired the right necessary to access protected contents, the DRM Protocol Handler will access the contents. Otherwise, the DRM Protocol Handler  will immediately refuse to access the contents right away. In this case, it is likely that it will display a DRM JVM message to the user, saying that the rights to access the contents have not yet been acquired. If the right to access those contents has been acquired, the DRM Protocol Handler will activate its internal DRM Decrypting Component .","DRM Decrypting Component","The DRM Decrypting Component  is an internal component of the DRM Protocol Handler. It has the responsibility for accessing the contents, decrypting them, and serving them to the DRM Protocol Handler. In order for the Decrypting Component to work, it is necessary to install support for decryption in the JVM. By default, Java\u2122 offers support for message digests and digital signatures, but no support for encryption. Therefore, a DRM-enabled JVM must have been enhanced with the Java Cryptography Extension (JCE). By default, the JCE packages provided by Sun Microsystems\u2122 or IBM\u2122 includes a framework where Cryptographic Service Providers (CSPs) can be plugged in, as well as a CSP that supplies the implementation of some encryption\/decryption algorithms. There should be no restrictions in terms of the framework and the CSPs that can be installed on top of the JVM, as long as these packages are certified (as they must be recognized by the launcher) and they supply the implementation of the same encryption\/decryption algorithms used by the DRM server to encrypt the contents.","Digital rights (such as the right to print, copy and paste, etc.) in the DRM-enabled JVM  of the invention, are typically enforced by the DRM SecurityManager  and\/or the DRM Policy Object  after contents have been decrypted by the Decrypting Component  and passed on to the DRM Protocol Handler . However, the right to play protected contents should be enforced by the DRM Protocol Handler  itself. In other words, the Decrypting Component should be activated only if the right to display protected contents has been previously acquired.","End-user Registration","As mentioned, the only entity that is not trusted in this simplified system is the end-user. Therefore a client registration system must be established. Thus, after installing the DRM system on the client machine, and before the client can perform any transactions, the client has to register with the DRM server . Besides typical registration procedures to any online store, which result in the generation of a user ID, password, and possibly a client profile for accessing the Web site and ordering content, the DRM server  receives from the DRM client a unique public key certificate. This public key certificate is generated by a registration application, which is triggered on the client side. The counterpart private key of this public key is maintained securely protected by the client DRM system. The secret used to protect that key is generated based on unique features of the client machine, and is never stored on disk. The code that generates this secret and uses it is part of a DRM library, which is used by the different DRM client-side components, such as the trusted content handler, the launcher, and the registration application. The code of this DRM library is preferably obfuscated and well-protected against tampering or debugging attacks.","Any content directed to this client is protected using the public key which is stored on the DRM server. Preferable, public key encryption is applied only to metadata such as the rights files or the content map in order to avoid the overhead of asymmetric encryption\/decryption with each content download.","Fine-Grained Rights Specification For Large Protected File Sets","Rights specification for protected packages containing large numbers of individual content items\u2014e.g., courseware, photography collections, literature anthologies\u2014presents issues not addressed by existing rights management systems. First of all, there must be the ability to specify rights at a fine granularity. This is important in enabling content owners and distributors to offer consumers a variety of ways to purchase content in these large packages, and in giving consumers choice in how they purchase it. But rights specification must also be convenient\u2014it should not be necessary to specify rights individually for each item of content. Finally, there should be an efficient run-time mechanism, both in speed and in storage requirements, for associating a particular item of content with its corresponding set of rights. Meeting these requirements is achieved with the system described herein.","Rights Specification Files","A complete rights specification for a protected package is comprised of (1) one or more rights files, (2) a key-table file, and (3) a content-attributes-table file. These files are collected together in one directory, the directory having the same name as the package name.","Rights Files","Rights files are text files with the \u201c.ini\u201d extension. A package may have multiple rights files but must have at least one.","The format of a rights file is a series of lines, each line granting or denying one right.","Example:",{"@attributes":{"id":"p-0061","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":{"@attributes":{"id":"ul0002-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0003","list-style":"none"},"li":["Play: yes","Print: no","Save: no","Clip: no\n\nKey Tables\n"]}}}},"A key table is a text file with the name \u201ckeytable.ini\u201d as shown in the following example key table:\n\n","In the example above, keys and algorithm parameters are specified in binary format in separate files, key0.key, key1.key, key2.key, and param.par respectively. Alternately, keys and algorithm parameters could be specified in hexadecimal format, and stored for example into the key table itself. In either case, the packager may verify the number of digits of the keys and the parameters (both depending on the algorithm used) before using them.","Content-attributes (Content Map) Tables","A content-attributes table associates content items with rights files and decryption keys, in a compact and efficient way. Conceptually, it is structured as shown below:",{"@attributes":{"id":"p-0065","num":"0082"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"File",{},{}]},{"entry":[{},"specifier","Rights","Key"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"file1","RightsSetFile1","4EF872A349"]},{"entry":[{},". . . \/Section","Section1Rights","9B3DA89C01"]},{"entry":[{},"1\/*"]},{"entry":[{},". . . \/Section","Section2Rights","0F311D42BA"]},{"entry":[{},"2\/*"]},{"entry":[{},". . . ",". . . ",". . . "]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"A content-attributes table is a text file with the name contentattrs.ini. The role of the content-attributes table is to assign rights files and decryption keys to individual content items in a compact and efficient way. Following is an example content-attributes table:\n\n","The content-attributes table is a series of content-path specifiers (within \u2018[\u2018and \u2019]\u2019 brackets) followed by rights-file and key assignments. Content-path specifiers are relative to the parent directory of the course. Thus, for a file named \u201cD:\\packages\\RMHTTP_PACKAGE_ROOT_DB2Demo\\index.html,\u201d the content-path specifier in the content-attributes table is \u201cindex.html.\u201d","So that not every file in a package requires its own specification line, the content-attributes table allows hierarchical specification. In the sample above, \u201c[Andrew_Jackson_files\/*]\u201d specifies all the files in the directory \u201cAndrew_Jackson files.\u201d In this particular implementation, the \u201c*\u201d element is only used to indicate all files in a directory; it cannot be used as a general wildcard. That is, *.html cannot be used to indicate all files with the html extension.","It may be noted that the directory separator used is \u201c\/\u201d, following URL syntax. It can be seen in the sample above that a given a file path name may match more than one path specification. For example, Andrew_Jackson.html will match both [*] and [Andrew_Jackson.html]. The rule is that specification with the longest matching prefix is chosen. This makes it possible to assign a default rights file and then override it for selected files.","Key IDs refer to the index of the key in the key table. The index is zero-based.","Time Complexity of Rights-file and Key Lookup","Since prefix matching is strictly on the basis of whole path elements, the time complexity of any one rights-file and key lookup (i.e., given a file name, the time required to look up the associated rights file and decryption key) is linear in the length, in path elements, of the file name. For example, \u201c[index.html]\u201d has one path element, and \u201c[Andrew_Jackson files\/*]\u201d has two. Since the depth of a tree of n nodes is proportional to log(n), the time complexity of rights-file and key lookup in a package of n content items is O(lg n).","Packaging for Distribution","After the rights specification files\u2014the rights files, a key table, and a content attributes table\u2014have been prepared, a packaging tool encrypts the content files for distribution, using the keys specified in the key table and the content attributes table. The rights specification files are also encrypted with a secret key, and remain encrypted while on the user's system. (They may or may not undergo a transcription when they are first copied to a user's system.)","Because the names of the content files and rights specification files, and their organization in directories, is not protected against tampering, some users may attempt to circumvent the rights management system by renaming rights files and\/or content files. Seeing a file named \u201cNoRights.ini\u201d and a file named \u201cAllRights.ini\u201d, a user may be tempted to delete the NoRights.ini file, then make a copy of the AllRights.ini file and name it to NoRights.ini. The obvious intent would be that any content assigned the rights in NoRights.ini would effectively have the rights in AllRights.ini.","To prevent this, the packager may insert into each rights specification file and content file, at encryption time, its name. (For rights specification files, the name is relative to the package's rights-specification directory; for content files, the name is relative to the content root directory.) When one of these files is accessed, the name used to access the file is checked against the name embedded in the file itself. If the names do not match, the file is not decrypted.","Rights Enforcement\u2014DRM SecurityManager and the DRM Policy Object","Once contents have been decrypted by the Decrypting Component and passed on to the DRM Protocol Handler, the JRE implements a mechanism to enforce the rights acquired by the user. It has been demonstrated that this may be done in at least two different ways: by instantiating a DRM SecurityManager at run time, or by modifying the Policy object instantiation at JVM startup, requiring that a DRM Policy object be created.","The DRM SecurityManager","As shown in , the DRM SecurityManager component  is an extension of the default SecurityManager that is part of the standard Java\u2122 API and is responsible for enforcing the digital rights acquired by the user, except the right to play, which is enforced by the DRM Protocol Handler itself. The DRM SecurityManager  is invoked by the DRM Protocol Handler as soon as protected contents have been accessed by the DRM Protocol Handler and decrypted by the Decrypting Component. Should the JVM refuse the installation of the DRM SecurityManager, accessing the protected contents will abort. Thus, the main function of the DRM SM component is to enforce the rights associated with protected content by disallowing players from performing any operations that may lead to a rights violation. This Java class subclasses the original security manager of the JRE, and prevents any further subclassing of itself, so it cannot be overridden. By default, all security sensitive operations, such as input\/output, opening sockets to communicate with external entities, etc., are trapped to be authorized by the security manager.","The DRM SecurityManager is capable of understanding the rights acquired by the user. Typically, such rights are encoded on the local file system and encrypted with a secret key. Therefore, the DRM SecurityManager must be able to access or calculate the decrypting key, and use the decrypting functions of the JCE to access the rights.","Rights are, associated with pieces of contents, and it must be possible to have different pieces of contents with different rights loaded at the same time. Therefore, as soon as a piece of content is accessed, rights must be calculated for it, and must be enforced by the DRM SecurityManager.","With Java\u2122 2, the DRM SecurityManager  is a fully functional resource level access control facility with only one method call, checkpermission(),which takes a java.security.Permission object as a parameter. For compatibility, the other check methods are still available, but now answer the question using the new Permission and policy file model by turning the request into a Permission and calling checkpermission(). All of the check methods can still be overridden, if necessary.","As depicted in , in order to enforce rights, the DRM SecurityManager  breaks the connections with the AccessController  for every Permission that is relevant to a digital right. In other words, the SecurityManager  checks methods relevant to a digital right will be overwritten by the DRM SecurityManager subclass, and the AccessController.checkPermission() method will not be invoked for that particular Permission. This way, AccessController.checkPermission() will not walk through the stack frames of the current Thread , obtaining the ProtectionDomains for every class in the stack.","In an example scenario, the following piece of code illustrates how the DRM SecurityManager component  may override the checkPermission() method of its superclass, SecurityManager, and use the following DRM logic to establish if the permission to print is granted or not:",{"@attributes":{"id":"p-0082","num":"0112"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public void checkPermission(Permission perm)"},{"entry":"{"},{"entry":"\u2003if (perm instanceof RuntimePermission &&"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"perm.getName( ).equals(\u201cqueuePrintJob\u201d) && !printRight)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\u2003{"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"String message = \u201cUNABLE TO PRINT!\\n\\n\u201d +"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u201cPlease, purchase the adequate rights\\n\u201d +"]},{"entry":[{},"\u201cbefore attempting to print these contents again.\u201d;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"new Messages( ).showInfoDialog(message);"]},{"entry":[{},"throw new SecurityException(\u201cPrinting is not allowed\u201d);"]},{"entry":[{},"}"]},{"entry":[{},"\/\/ code for other permissions go here..."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"With this behavior, the DRM server is protected against malicious clients. In fact, in order to print protected contents, a user on a client system will modify one of the policy configuration files by adding a grant entry similar to the following:",{"@attributes":{"id":"p-0084","num":"0114"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"grant {"},{"entry":"\u2003permission java.lang.RuntimePermission \u201cqueuePrintJob\u201d;"},{"entry":"};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"However, the way the DRM SecurityManager overwrites the checkPermission() method grants that the security policy will not be consulted when a print operation is attempted. All the DRM logic resides in the DRM SecurityManager, and any changes and permissions granted in the policy files will not have any effects when the DRM SecurityManager is in place. Thus, as  conceptually depicts, even if the right to print has not been acquired, the DRM SecurityManager  will deny it, no matter what the Policy object \u2032 currently in effect recommends.","Notice that this security configuration would be entirely compromised if the end user were able to instantiate a new SecurityManager and replace the existing DRM SecurityManager. Therefore, the DRM SecurityManager's checkpermission() method must also take care of forbidding the creation of a new SecurityManager. Similar care should be taken for other permissions, which at first sight might not appear relevant to a DRM scenario. For example, it is advisable to forbid opening socket connections, since through a socket connection decrypted contents could be easily transferred to another machine and illegally copied. In addition, the DRM SecurityManager should prevent changing the JVM security configuration, creating of a new ClassLoader (which could be as dangerous as granting AllPermission), invoking native methods, etc.","Pros and Cons of the DRM SecurityManager Solution","Enforcing digital rights with a customized DRM SecurityManager allows the JVM to be used as a regular JVM as well as a DRM-enabled JVM according to the needs. In fact, a new DRM SecurityManager instance is created only when DRM-protected contents is invoked. Before that, a default SecurityManager instance (or another user-defined SecurityManager) is active, and the security of the entire JVM is imposed by that SecurityManager. Only when protected digital contents are loaded into the JVM will the DRM SecurityManager be instantiated to enforce the rights.","However, extreme care must be taken against all the possible attacks that could be run against this solution. For example, many permissions that at a first sight do not look like DRM-related permissions are potentially very dangerous if the DRM SecurityManager does not prevent them. For example, the permission to create and set a new SecurityManager would compromise the security of the entire system if a malicious user could instantiate a new SecurityManager that replaces the DRM SecurityManager. Similarly, it is possible to bypass any SecurityManager control by running native code. While a DRM SecurityManager may implement a very strict security policy that prevents all these possible attacks from being run, it is likely that the capabilities of programs running on the resulting JVM will be very limited.","A limitation in this approach may occur if the SecurityManager currently in effect when DRM protected content is going to be loaded prevents a new SecurityManager from being installed. In this situation, the DRM SecurityManager cannot be instantiated, and the DRM Protocol Handler will typically refuse to activate its Decrypting Component. In this case, protected content will not be displayed on the client system until the current SecurityManager will allow the DRM SecurityManager to replace it.","The DRM Policy Object","Another way the DRM-enabled JVM may enforce the digital rights that the end user has acquired is by using a customized Policy object  as shown in . As described herein, the default Policy implementation in Java\u2122 2 is file based. However, the Java\u2122 2 API offers an abstract Policy class that application developers may overwrite to provide their own Policy implementation.","A known problem in the Java\u2122 platform is that ProtectionDomains are cached as soon as they are created. Therefore, changing the Policy and refreshing will not take any effect over ProtectionDomains that have already been instantiated. For this reason, the DRM-enabled JVM that chooses to enforce rights through a DRM Policy Object will have to instantiate the DRM Policy Object at JVM startup.","Enforcing the rights by using a DRM Policy Object is an enhancement based on the Java\u2122 2 security architecture. In fact, as soon as a class is loaded into the JVM, a ProtectionDomain is assigned to that class based on the class' CodeSource. The ProtectionDomain information is then retrieved by the AccessController when its checkpermission() method, walking back though the stack frames of the current Thread, makes sure that every ProtectionDomain on the Tread's stack implies the necessary Permission. By forcing the ProtectionDomain information to reflect the rights that the user has acquired, the DRM-enabled JVM will prevent unscrupulous users from misappropriating high-value digital contents.","Instantiating a customized DRM Policy Object  requires the presence of a DRM Policy Object Instantiator hidden within the JVM and obfuscated. The DRM Policy Object Instantiator must be capable of understanding the rights acquired by the user. Typically, such rights are encoded on the local file system and encrypted with a secret key.","Therefore, the DRM Policy Object Instantiator must be able to access or calculate the decrypting key, and use the decrypting functions of the JCE to access the rights.","Along with enforcing the rights, the DRM Policy Object will have to impose some other security restrictions that at first sight might not appear relevant to a DRM scenario. As already noted, the security configuration would be entirely compromised if the end user were able to instantiate a new SecurityManager, since a new SecurityManager could forbid any Policy consultation. Therefore, the DRM Policy Object must also take care of forbidding the creation of a new SecurityManager. Similar care should be taken for other permissions. For example, it is advisable to forbid opening socket connections, since through a socket connection decrypted contents could be easily transferred to another machine and illegally copied. In addition, the DRM Policy Object should prevent changing the JVM security configuration, creating of a new ClassLoader (which could be as dangerous as granting AllPermission), invoking native methods, etc.","Pros and Cons of the DRM Policy Object Solution","The DRM Policy Object solution represents a very robust way to enforce digital rights in a DRM-enabled JVM. In fact, its action is concentrated at a very low level in the Java\u2122 2 permission architecture. In general, the SecurityManager currently in effect relies on AccessController for any access control decisions, and in turn, AccessController is responsible for getting the ProtectionDomains of all the classes on the thread stack to verify that the Permission to check is actually implied by every ProtectionDomain. Since ProtectionDomains are instantiated based on the Policy object currently in effect, a DRM Policy object may drive the security of the entire JVM in such a way that DRM-protected contents cannot be accessed illegally.","The DRM Policy Object is still responsible for preventing any new SecurityManager from being instantiated, since a malicious SecurityManager might disregard any Policy configuration currently in effect. Similarly, the creation of new ClassLoaders should be avoided, and native code invocations should be forbidden","In addition, the aforementioned known problem in the JVM implementation\u2014the ProtectionDomain caching\u2014forces the DRM Policy Object to be instantiated at JVM startup. A flexible approach where the DRM Policy Object is invoked on demand when DRM-protected contents are loaded will not be a secure solution until a ProtectionDomains refreshing mechanism is implemented.","Therefore, the approach of imposing rights management with a DRM Policy Object currently lacks the flexibility of a DRM-on-demand solution. Nonetheless, once solved the general problem of the ProtectionDomain information caching, this solution will present the best advantages since it allows merging rights with policy file information.","Out-of-Process Code Identity Verification","Returning to , the DRM Protocol Handler  is a fundamental component in the DRM-enabled JVM. One risk is that this component is misappropriated by a malicious user, and placed inside a compromised JVM that does not obey to the rights enforcement. Another risk is that the JVM is started (deliberately or otherwise) without using the Launcher , which is responsible for verifying the integrity of the JVM itself. In both these scenarios, the DRM Protocol Handler and its Decrypting Component would run inside a JVM whose integrity could not be ascertained.","This kind of problem is solved by the Out-of-Process Code Identity Verification, a sophisticated security mechanism described in commonly-owned, co-pending U.S. patent application Ser. No. 09\/667,286, the whole contents and disclosure of which is expressly incorporated by reference as if fully set forth herein. Simply stated, this mechanism makes sure that the DRM Protocol Handler  and the Launcher  exchange a secret every time the DRM Protocol Handler is invoked. This secret is computed independently by each of the launcher and the protocol handler applying the same scrambling algorithm to JVM process-specific information, e.g., process Id or process creation time, which cannot be forged without compromising the operating system. If the secret held by the DRM Protocol Handler is different from the secret held by the Launcher , and in particular if the secret held by the Launcher  does not exist at all (which is the case if the JVM was started without the Launcher), then the DRM Protocol Handler will refuse to activate its Decrypting Component, and contents will be displayed encrypted.",{"@attributes":{"id":"p-0102","num":"0132"},"figref":["FIGS. 5(","FIG. 6","FIG. 5("],"i":["a","b","b"],"b":["5","100","101","103","105","106","108","110","112","150","120","122","125","127","128","130","135"]},"As described above with respect to step , ), the DRM Ph loads the rights set associated with the protected content. A detailed description of this process  is now provided with respect to . As shown in , a first step  is to ensure that the Launcher has authenticated the JRE with the process terminating at step  if the JRE could not be authenticated as described above. Then at step , the DRM PH resolves the resource URL in order to determine the protected resource, and particularly, the content filename CF and the content map CM of that resource. Then, at step , the content map is decrypted using a hidden private key (it should be understood that the corresponding public key is at the server side content provider). Particularly, the private key is re-generated from pieces of information that are hidden and are unique to the client. The key table also can only be decrypted using the hidden private key, and hence the symmetric keys are re-generated for decrypting the content from pieces of information that are hidden and are unique to the client. Next, at step , the CM is used to map the CF into a corresponding rights file (RF) and key ID such as described above with regard to the content-attributes table, and the RF is decrypted using the hidden private key at step . Finally, at step , the decrypted RF is parsed and the particular rights set is loaded for the security manager to enforce in the manner as described herein. It should be understood that the process described herein with respect to )-() is repeated for every URL or link having protected content to be accessed.","While the invention has been particularly shown and described with respect to illustrative and preformed embodiments thereof, it will be understood by those skilled in the art that the foregoing and other changes in form and details may be made therein without departing from the spirit and scope of the invention which should be limited only by the scope of the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Further features, aspects and advantages of the apparatus and methods of the present invention will become better understood with regard to the following description, appended claims, and accompanying drawings where:",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 2","b":"50"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIGS. 5(","i":["a","b"],"b":"5"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
