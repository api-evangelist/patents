---
title: Network application performance enhancement using speculative execution
abstract: A speculative web browser engine may enable providing transmission of content between a server and a client prior to a user-initiated request for the content hidden in imperative code (event handlers), which may reduce user-perceived latency when the user initiates the imperative code. In some aspects, a speculative browser state may be created from an actual browser state and used to run the event handlers. The event handlers may be modified to direct actions of the event handler to update the speculative browser state. Speculative content may be transmitted between the server and the client in response to an execution of the modified code. The speculative content may be stored in a cache and made readily available for use when the user initiates the event handler and finds that the desired content has already been fetched.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08140646&OS=08140646&RS=08140646
owner: Microsoft Corporation
number: 08140646
owner_city: Redmond
owner_country: US
publication_date: 20090604
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION","CONCLUSION"],"p":["Early web content was primarily displayed as static content that only enabled limited user interaction, if any at all. For example, early web content was typically characterized by large amounts of text and images that were formatted in a layout using various Hyper Text Markup Language (HTML) formatting operations. Pages included static links to other pages and\/or content, and user interaction was typically limited to clicking on these links. In contrast, modern web pages often include rich Internet applications (RIA) that support large amounts of user interaction with dynamically created content.","Prefetching is an act of extracting (fetching) network-based content from a server prior to an actual request instantiated by a user. For example, suppose that a user is currently viewing page X in a web browser, and page X links to a different page Y. The user's client computer may prefetch the content associated with page Y, downloading it as the user views the original page X. Later, when the user requests the linked page Y, the content will already be on the user's machine, thus reducing perceived delays (e.g., network transmission latency) for accessing the content. Prefetching early website content was relatively straightforward because a page could be quickly analyzed by a server or client computer to identify items that could be prefetched. HTML code, for example, could be searched for tags that indicated the presence of a link, image, or other content that could be prefetched by the client. However, with the introduction of more complex web pages that hide content behind imperative JavaScript event handlers (executable programs), additional challenges have been introduced to traditional prefetching implementations.","A modern website often includes dynamic (rich) features that allow a user to interact with the website. When the user generates an interaction event, e.g., by clicking on a particular feature, the browser executes an event handler that the page has associated with that feature. The event handler is executable code run by the client computer to create an effect for the user to experience. Execution of the event handler, which is typically initiated by the user, may then require additional transfer of content between the server and the client, and may create transmission latency that is perceived by the user.","A speculative web browser engine may enable a reduction of user-perceived latency when a user navigates a web page that includes rich Internet applications (RIA). The speculative engine may provide for transmission of content between a server and a client prior to a user-initiated request for the content hidden in imperative code (event handlers), which may reduce user-perceived latency when the user initiates the imperative code.","In some aspects, speculative browser state may be created from actual browser state and used to run event handlers. The event handlers may be modified to update the speculative browser state instead of the foreground, user-visible state. Speculative content may be transmitted between the server and the client in response to an execution of the modified event handlers. The speculative content may be stored in a cache and made readily available for use when the user initiates the event handler and requests content that has already been fetched.","In additional aspects, the speculative engine may generate a speculative layout using the speculative content to reduce user-perceived latency when the browser must display the speculative content. In addition, the speculative engine may speculatively upload content from the client to the server in anticipation of a user-triggered upload of the speculative content.","Overview","As discussed above, the web includes rich Internet applications (RIA) that enable large amounts of user interaction on the web. The introduction of RIAs that include event handlers (or other imperative code) has complicated traditional approaches to prefetching content that can be used to reduce user-perceived latencies associated with a transmission of web content between a server and a client. Event handlers are program statements that are executed in response to user-initiated events such as a keystroke or a mouse movement. An illustrative generic speculative engine (speculative engine) is disclosed herein that simplifies providing low user-perceived latency when a user interacts with RIAs. In some embodiments, the speculative engine may take preexisting, non-speculative event handlers and create speculative versions which are run in a cloned browser context that is not visible to the user.","The speculative engine may reduce user-perceived latency when content is hidden behind imperative code (e.g., JavaScript code, etc.) by performing speculative execution of the imperative code. The speculative execution may reveal content that may then be prefetched from the server to the client to reduce user-perceived latency. The speculative engine may also reduce user-perceived latency by speculatively uploading content from the client to the server. The speculative engine may further generate speculative layouts of prefetched content.","In addition, the speculative engine may analyze user events (inputs) to determine possible outcomes and avoid speculating on outcomes that have already been speculated upon. In addition, the speculative engine may be used to spread peaks in server load over other time segments to further reduce user-perceived delays. The server loads may be smoothed by immediately servicing speculative requests if server load is low, and deprioritizing speculative requests if server load is high.","The processes and systems described herein may be implemented in a number of ways. Example implementations are provided below with reference to the following figures.","Illustrative Environment",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1","b":["100","100","102","104","102","104"]},"The host  may communicate with users , each having one or more associated client devices  (or simply \u201cclients\u201d). A network(s)  may facilitate transfer of content between the servers  and the clients . The network(s)  may include one or more of wired or wireless networks including a non-exhaustive list of Wi-Fi, mobile telephone, Bluetooth\u00ae or other network types.","The clients  may be any type of computing device that is enabled to send and receive content , via the network , with the servers . A non-exhaustive list of possible clients ()-() may include a personal digital assistant (), a personal computer (), a mobile computer (), and a music player (). In accordance with embodiments, the clients  may include a browser  to process, format, and present to the users  any content () that is received from the servers .","The content () may include downloaded content (), which originates at the server  and is transmitted to at least one of the clients , and\/or uploaded content (), which originates at any one of the clients  and is transmitted to the server . In some embodiments, the downloaded content () may include imperative code (event handlers), such as JavaScript, which may be executed by the client . The imperative code may be speculatively executed by the server  and\/or the client  to reduce user-perceived latency due to network bandwidth or hardware processing. Thus, the downloaded content () may include speculative downloads of content that has not yet been initiated by the user , but when requested by the user , may reduce user-perceived latency often associated with network bandwidth limitations. In various embodiments, the downloaded content () is stored in a cache on the client , which is accessible by the browser  (i.e., browser cache).","In accordance with various embodiments, the uploaded content () may include speculative uploads, which are uploads that are transmitted from the client  to the server  in anticipation of a user action to initiate the upload. Speculative uploads may reduce user-perceived latency of the upload processing. If the user  does not initiate the transmission of the uploaded content (), such as by interacting with imperative code, then the server  may discard the uploaded content () at a later time.","As illustrated, the server  and\/or the clients ()-() may be equipped with various computing hardware  to enable the servers  and\/or the clients ()-() to provide speculative execution of rich Internet content. The computing hardware  may include one or more processors , memory , and cache . The memory  may include applications, modules, and\/or data. In some embodiments, the memory  may include a speculative engine .","The speculative engine  may include various software components that may include a prefetch tool , a speculative upload tool , a speculative layout tool , and a data transfer smoothing tool  (or simply \u201csmoothing tool\u201d). The speculative engine  may be used by the server  and\/or the clients ()-() to reduce user-perceived latency, and in some instances, reduce computing latencies.","In some embodiments, the prefetch tool  may execute imperative code and then initiate a speculative transfer of content (prefetch) prior to a user-initiated request for the content. The speculative upload tool  may enable a speculative upload of content from the client  to the server  prior to a user initiated-request for the upload of content. The speculative layout tool  may generate a speculative layout of content prior to a user-initiated request for the layout. In some embodiments, the speculative layout tool  may use content obtained by the prefetch tool  and\/or the speculative upload tool  to generate the speculative layout. Finally, the smoothing tool  may queue data requests to a server based on whether the request is for speculative content or content initiated by a user action, which may ultimately improve server response time to the client for user-initiated requests.","The browser  may include a browser state  of RIAs, HTML code, and so forth. The speculative engine  may run in one or more speculative browser states  that are copies of at least a portion of the browser state . In this way, speculative execution of event handlers by the speculative engine  may not be visible to the users , which would otherwise be disrupting to the browsing experience of the user.","In accordance with various embodiments, the cache  may include two types of illustrative content types: standard content  and speculative content . However, the cache  may not include an actual distinction (separation, identifier, etc.) between the standard content  and speculative content . The standard content  is content that is generated by a user-initiated request. The speculative content  is content that is generated by the prefetch tool , the speculative upload tool , and\/or the speculative layout tool , and thus is not generated directly from a user-initiated request.","In an example, the cache  may be browser cache implemented on any one of the clients ()-(), which is accessed by the browser  to reduce user-perceived latency by avoiding a network transfer of content with the server  when content (e.g., the standard content ) is obtainable from the cache on the client. The speculative content  may be accessed by the browser  (or other applications) in a similar manner as a browser access of the standard content .",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 2","b":["200","104","108","1","200","202","204","202","204","108","1","104","104","108","1"],"i":["n","n","n"]},"The dynamic content  may include a first piece of dynamic content  and a second piece of dynamic content  (among many possible pieces of dynamic content on a RIA web page). The first piece of dynamic content  may perform a first action when a user requests the dynamic content . For example, the user may click a button, hover over a space (e.g., with a cursor), or take some other action to initiate execution of the first piece of dynamic content . The second piece of dynamic content  may be executed via similar types of user input. The first and second pieces of dynamic content ,  (and other possible pieces of dynamic code) may be identified by the prefetch tool  and associated with prefetch code . The prefetch code  may enable speculative execution of the first and second pieces of dynamic content ,  to determine whether a further transfer of content may be initiated between the server  and the at least one of the clients ()-(). The content may then be prefetched and stored in the cache  as the speculative content .","A dynamic content uploader  may enable an upload of content from at least one of the clients ()-() to the server . The dynamic content uploader  may be identified by the speculative upload tool  and associated with speculative upload code . The speculative upload code  may enable speculative execution of the dynamic content uploader  to initiate the upload of content from at least one of the clients ()-() to the server  before a user-initiated request. Thus, the speculative upload code  may perform the upload prior to a user request to reduce a user-perceived latency after the user initiates the upload.","Finally, a layout  may be identified for each instance of the static content  and dynamic content . When the dynamic content  (e.g., the first or second pieces of dynamic content , , etc.) is requested by the user  and results in additional content being fetched, the layout  may be modified to create a new layout that contains content referenced by user requests for the dynamic content .","A layout configuration of the layout  may be identified by the speculative layout tool  and associated with speculative layout code . The speculative upload code  may enable creation of a speculative layout  which may include the additional content (speculative content)  retrieved from the server  after execution of the dynamic content  of the page . Thus, the speculative upload code  may generate the speculative layout  prior to a user action and thus reduce a user-perceived latency after the user takes an action that triggers user imperative code.","Illustrative Operation",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 3","b":["300","104","108","1","300","124","112"],"i":"n"},"The process  is illustrated as a collection of blocks in a logical flow graph, which represent a sequence of operations that can be implemented in hardware, software, or a combination thereof. In the context of software, the blocks represent computer-executable instructions that, when executed by one or more processors, cause the one or more processors to perform the recited operations. Generally, computer-executable instructions include routines, programs, objects, components, data structures, and the like that perform particular functions or implement particular abstract data types. The order in which the operations are described is not intended to be construed as a limitation, and any number of the described blocks can be combined in any order and\/or in parallel to implement the process . Other processes described throughout this disclosure, in addition to process , shall be interpreted accordingly.","At , the browser  may fetch a web page from the server  for display to the user  via any one of the clients ()-(). The speculative engine , using the prefetch tool , may identify instances of executable (imperative) code of the web page. For example, the speculative engine  may search the web page for calls to executable code or other indicators that enable identification of executable code.","At , the prefetch tool  may execute the imperative code to obtain a result of the event handler. The imperative code may be executed in the speculative browser state  such that the executed code does not disrupt a user experience (i.e., use of the browser ). Thus, the user may be unaware of the execution of the imperative code at . As shown in the process , multiple instances of executable code may be executed by the prefetch tool, such as at ()-(N).","At , the prefetch tool  may perform a speculative download based on the result identified at the operation . The executions of the imperative code at ()-(N) may be used to identify speculative content to perform a speculative download ()-(N), respectively. The speculative content may then be stored in the cache  (on any one of the clients ()-()) to enable reducing user-perceived latency when user input is received to initiate an instance of the imperative code.","At , the browser  may receive user input for an instance of the imperative code that has been executed at  and has had content speculatively downloaded at . The browser  may execute the user imperative code, determine content requested by the code, and then search the cache  for the speculative content, which may be present in the cache if it was downloaded at the operation .","At , the browser may cause the display of the content downloaded at , and thus reduce user-perceived latency by prefetching the content from the server .","As an example of process , a simple photo slide show or interactive map application may incur latency when transmitting (pulling) images through a low-bandwidth network connection from the server  to one or more of the clients ()-(). In another example, when the user  triggers the creation of a new tab in a tabbed browsing experience using a DHTML Goodies tab manager, new content is fetched over a potentially slow network link before it can be displayed in the new tab. Speculating on user operations (e.g., next photo, load new tab, etc.) can reduce user-perceived latency by identifying the content requests that are hidden inside imperative code. A speculative execution may fetch content (e.g., an image, etc.) at the operation  as speculative content that would incur high latency during network transmission of the content. The speculative content may be stored in the cache , and the speculative execution may be discarded. When the user click triggers a user operation at the operation  (e.g., clicks a button, etc.) associated with the speculative content, a fresh execution may complete with reduced user-perceived latency by extracting the speculative content from the cache .","In accordance with various embodiments, the speculative engine  may enable speculation of equivalence classes. Some applications, such as an autocompleting text box, may include several sequences of low-level events that lead to equivalent speculative opportunities. In some embodiments, the speculative engine  may speculatively fetch search results for potential autocompletions. For example, consider one user who types \u201cba\u201d into a text box, and another user who types \u201cbe,\u201d hits backspace once, and then types \u201ca.\u201d Both users eventually type \u201cba\u201d into the text box, which leads to an equivalent set of autocompletion suggestions. Speculating upon all input permutations that reach \u201cba\u201d may be an undesirable use of computing resources. Instead, the speculative engine  may only speculate on one instance of each equivalence class (e.g., \u201cba\u201d or another set of autocompletion prefixes), and then map equivalent user inputs to a canonical speculation. The instance of an equivalence class that the speculative engine  uses to trigger a speculation may be defined by a developer using speculation tags or the like, which are shown with the operation . Thus, speculation tags are markers that may be implemented by a developer to indicate equivalence classes, that when read by the speculative engine , trigger speculative actions (e.g., speculative download, upload, rendering, etc.).",{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 4","b":["400","402","403","404","406"]},"One objective to using speculative execution is to prevent disruption of a user experience with the browser . Thus, it is undesirable to disturb a foreground state on either the clients ()-() or the server  when the speculative engine  performs prefetching activities such as at the operations  and .","As an example, a webmail client may use Asynchronous JavaScript and XML (AJAX) to wrap calls to an Internet Message Access Protocol (IMAP) server. A fetchMessage( ) operation may update client-side metadata (e.g., a list of which messages have been fetched) and server-side metadata (e.g., which of the fetched messages should be marked as read). To speculate on such a read\/write operation, the application developer  may explicitly separate the operations into a read portion and a write portion. The application developer  may split the fetchMessage( ) operation into a read-only downloadMessage( ) operation and a metadata-writing markMessageRead( ) operation. The read-only operation may then download an email from the server, but specify in the IMAP request that the server should not mark the message as read. The markMessageRead( ) tells the server to update this flag, effectively committing the message fetch on the server-side. Inside fetchNewMessage( ), the call to markMessageRead( ) is conditioned on whether the message fetch is speculative. Although downloadMessage( ) may be read-only with respect to the server, it may update client-side JavaScript state. So, when speculating on fetchNewMessage( ), the speculative engine  may run downloadMessage( ) in a speculative execution context. In speculative or non-speculative mode, downloadMessage( ) places AJAX responses into a new cache provided by the speculative engine . Later, when downloadMessage( ) runs in non-speculative mode (after a user request), the cache  is checked to see if it contains the message, which if present in the cache will avoid a refetch from the server  and reduce user-perceived latency.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 5","b":["500","108","1","104","500","124","112"],"i":"n"},"At , the browser  may fetch a web page from the server  for display to the user  via any one of the clients ()-().","At , the speculative engine , using the speculative upload tool , may identify instances of executable code of the web page that cause content to be uploaded from one of the clients ()-() to the server .","At , the speculative upload tool  may execute imperative code. The imperative code may be executed in an environment that does not disrupt a user experience (use of the browser ), such that the user is unaware of the execution of the imperative code at . As shown in the process , multiple instances of executable code may be executed by the speculative upload tool , such as at ()-(N).","At , the speculative upload tool  may perform a speculative upload. The executions of the imperative code at ()-(N) may be used to identify speculative content to perform a speculative upload ()-(N), respectively. The speculative content may then be stored in the cache  (on the server ) to enable reducing user-perceived latency when user input is received to initiate an instance of the imperative code.","At , the browser  may receive user input for an instance of the imperative code that has been executed at  and has had content speculatively uploaded at . The browser  may execute the user imperative code, determine content requested by the code, and then trigger the server  to search the cache  for the speculative content, which may be present in the cache  if it was downloaded at the operation .","At , any additional data maybe uploaded that is identified by the user, but not uploaded by the speculative engine  at the operation . For example, when a user adds an addition file to upload and then immediately clicks a submit button, the additional file may be uploaded at the operation  when it has not been speculatively uploaded in advance by the speculative engine  at the operation .","At , the speculative engine may delete non-selected results from the cache  which were speculatively uploaded but not requested by the user (via a user input) prior to an expiration of a timeout threshold.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 6","b":["600","108","1","600","124","112","600","300","300"],"i":"n"},"In some web applications, when the user performs an action, a rich web page dynamic content set replaces most of the page's content. This update requires the processor(s)  of the client  to perform work for layout and rendering. Layout latency occurs when the browser  traverses a Document Object Model (DOM) tree of the new content and determines the spatial arrangement of the elements. Rendering latency occurs when laid-out content must be drawn to the screen. While a speculative cache loading can reduce user-perceived latency of the download operations, it does not reduce user-perceived latency of layout and rendering.","In one or more embodiments, at , the speculative layout tool  may generate a layout for a speculative page that includes the speculative download. Layouts may be generated at ()-(N) that correspond to the operations ()-(N). For example, a speculative download at () may include speculative content of an image. The generated layout at () may be generated by laying out the web page by adjusting borders, reformatting text, inserting the image, or other necessary actions to generate a layout that accommodates the speculative content. The layout may be hidden from the user in the speculative browser state  until the browser  receives a user input at the operation . For example, the speculative engine  may speculatively execute an event handler and load speculative content in a hidden browser <iframe>. Rather than discarding the speculative domain when the execution finishes, the speculative layout tool  may save the already laid-out content the cache  (or another suitable storage location).","At , the speculative engine  may enable a speculative layout at  which was generated at the operation . For example, the second layout generated at the operation () may be enabled at , and thus made visible to the user while reducing user-perceived latency due to computing (client) processing time that would otherwise exist had the layout not been generated at the operation . A result may be a visibly smoother transition from a first layout (prior to the operation ) to a second layout that is enabled at the operation  after the user interaction at .","At , the speculative engine , via the speculative layout tool , may optionally remove non-selected result(s) of the generated layouts from the operation . For example, a first and last layout from the operations (), (N), respectively, may be discarded at  to free up the cache  or the memory . Alternatively, the non-selected layouts may be kept in the cache for potential use by later user requests.",{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 7","b":["700","104","108","1","124","132","104"],"i":"n"},"At , the smoothing tool  may determine the load of the server . At a decision point at , when the load is determined to be high, the smoothing tool  may advance to  and reject or deprioritize speculative content requests at . However, when the load is not determined to be high at the decision operation , the smoothing tool may advance to  and implement speculative requests earlier in time at . At , the server  may perform download\/upload server activities based on the prioritizations resulting from the operations , , and thus the associated load of the server  may remain more constant over a period of time.","Illustrative Implementation",{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 8","b":["800","136","108","1","104"],"i":"n"},"At , the speculative engine  may copy a portion of the browser state of the browser . For example, the event handlers and other code of a web page read by the browser  (such as the web page read at the operation ) are duplicated.","At , the speculative engine  rewrites the event handlers. The event handlers are rewritten to direct any action (outcome of the event handler) to occur in the speculative browser state  and not disrupt the user's experience in the actual (viewed) browser state.","At , the speculative engine  runs the modified code in the speculative browser state  to determine whether additional content may be downloaded as speculative content from the server  to at least one of the clients ()-() to reduce user-perceived latency.","At , the speculative content may be presented in the foreground (actual) browser state as viewed by the user to reduce user-perceived latency which may occur when any one of the clients ()-() attempts to obtain content from the server  that has not previously been transmitted to the client.","The following sections discuss further implementation details for each of the operations described in the process .","Making Event Handlers Speculative","Implementation of the speculative engine  may consist of a client-side rewriting library and an application program interface (API) to invoke that library to control speculation. The speculative engine  may also include a server-side library to facilitate speculative data uploads.","On any one of the clients ()-(), the speculative engine  may prepare a speculative execution by creating a trigger pair consisting of a user input element and an event handler for that element. When directed to speculate on a trigger, the speculative engine  may generate a shadow copy of the application state and an event handler rewritten to interact with the shadow state instead of the real state. The speculative engine  may invoke the new handler, and speculative execution may fetch data and update the shadow copy of the application state. The speculative engine  may store the completed speculation's shadow state in a table indexed by the trigger pair. Later, should the user actually generate the trigger event, the speculative engine  may commit the speculative state to the real domain.","To create a speculative version of an event handler attached to DOM node d, an application calls makeSpeculative(d, eventName). Table 1 (below) provides the HTML for a simple image viewer and demonstrates how makeSpeculative( ) is called. The makeSpeculative( ) step may accomplish two tasks. First, it creates a speculative browser context for the speculative computation. Second, it creates a new handler that performs the same computation as the original one, but reads and writes from the speculative context instead of the real one. Context cloning and function rewriting is described in detail below.",{"@attributes":{"id":"p-0074","num":"0073"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":[{"entry":[{},"a. TABLE 1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"b. <div id = \u201d dispDiv\u201d \u2019>"]},{"entry":[{},"\u2003\u2003\u2003\u2003i. Image will be displayed here."]},{"entry":[{},"c. <\/div>"]},{"entry":[{},"d. <buttontype = \u201cbutton\u201d id = \u201cclickButton\u201d>"]},{"entry":[{},"\u2003\u2003\u2003\u2003i. Next picture"]},{"entry":[{},"e. <\/button>"]},{"entry":[{},"f. <script>"]},{"entry":[{},"g. var imgUrls = [ \u201cpicX .jpg\u201d, \u201cpicY.jpg\u201d ];"]},{"entry":[{},"h. var imgIndex = 0;"]},{"entry":[{},"i. var b = document.getElementById(\u201cclickButton\u201d);"]},{"entry":[{},"j. b.onclick = function ( ) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003i. var d = document.getElementById(\u201cdispDi v\u201d);"]},{"entry":[{},"\u2003\u2003\u2003\u2003ii. d.innerHTML = \u201c<imgsrc =\u2018\u201d+"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u20031. imgUrls [++imgIndex % 2] +"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u20032. \u2019\u201d>\u201d;"]},{"entry":[{},"k. };"]},{"entry":[{},"l. makeSpeculative(b, \u201cnclick \u201d);"]},{"entry":[{},"m. <\/script>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The speculative engine  may clone different types of objects using different techniques. For primitive values, the speculative engine  may just return the value. For a built-in object like a String or a Date, the speculative engine  may call the relevant built-in constructor to create a semantically equivalent but referentially distinct object. These objects have native code implementations, meaning that their functionality is implemented by opaque browser code, not introspectable JavaScript.","Cloning functions, objects, and DOM nodes may require special logic. In JavaScript, calling a function's toString( ) function returns the source code for that function. To clone a function f, the speculative engine  calls eval(f.toString( )), using the built-in eval( ) routine to parse the source and generate a semantically equivalent function. Since JavaScript functions are firstclass objects, f may have properties. So, after cloning the executable portion of f, the speculative engine  uses a for-in loop to identify f's properties, deep-copying any properties that are found.","Cloning a user-defined object is similar to cloning a function. The speculative engine  may create an initially empty object with no properties. The speculative engine  finds the object's properties using a for-in loop and deep-copies any non-primitive values.","To clone a DOM tree with a root node n, the speculative engine  calls the native DOM method cloneNode(true), by which a boolean parameter indicates that n's DOM children should be deep-copied. The cloneNode( ) method does not copy event handlers or other application-defined properties belonging to a DOM node. Thus, speculative engine  copies these properties explicitly, traversing the speculative DOM tree in parallel with the real one and updating the properties for each speculative node. Non-event handler properties are deep-copied using the techniques described above. Since the speculative engine  rewrites handlers and associates special metadata with each trigger pair, the speculative engine assumes that user-defined code does not modify or introspect event handlers. So, speculative engine  shallow copies event handlers by reference.","To clone the whole browser context, the speculative engine  may first copy the real DOM tree. The speculative engine  then creates an invisible <iframe> tag. IFrames are typically used to contain web content from external servers, but the speculative engine uses IFrames to hold speculative DOM contexts. The speculative engine  installs the cloned DOM tree as the root tree of the <iframe>'s document object.","Next, the speculative engine  copies the application heap, which is defined as all JavaScript objects in the global name space, and all objects reachable from those roots. The speculative engine  may identify the global properties using a for-in loop over window. The speculative engine  deep-copies each of these properties and inserts the cloned versions into an initially empty object called specContext. The specContext will later serve as the global name space for speculative executions. Cloning may preserve tag structure, so the speculative engine  uses a table of visited objects to ensure that clone requests for an already-visited object return the preexisting clone.","Global variables can be referenced with or without the window.prefix. For example, assuming that a function has not defined a local variable name globalVar, its uses of names window.globalVar and globalVar refer to the same property. To prevent window.globalVar from falling through to the real window object, the speculative engine  adds a property to specContext called window that points to specContext. The speculative engine  also adds a specContext.document property, which points to the hidden <iframe>'s document object. This document object may force DOM requests in the speculative execution to touch the speculative DOM tree instead of the real one.","The speculative engine  may be unable to contain the side effects of some functions, and thus hides them from speculative executions. For example, window.open( ) creates a new browser window; this side effect is disallowed from speculative execution. Likewise, the array window.frames enumerates all of the frames on the page, both real and speculative engine 's hidden speculative frames. The speculative engine  may insert open and frames properties with null values into specContext; speculative code that accesses them will throw an exception and be terminated by the speculative engine.","Once the speculative browser context has been generated, the speculative engine  may create a speculative version of the event handler (i.e., one that is semantically equivalent to the original one but interacts with the speculative context instead of the real one). The speculative engine  may employ JavaScript's \u201cwith\u201d statement to accomplish this task. Within a with(obj) statement, properties of the object obj override global variables. For instance, if obj has a property p, then references to the variable p refer to obj.p rather than the global variable p.","Thus, the speculative engine  can create a speculative version of an event handler as follows. First, the speculative engine fetches the source code of the handler as a string by calling its toString( ) method. Then, the speculative engine alters the string by wrapping the function's source code in a with(specContext) statement. In so doing, the speculative engine turns references to global variables in the enclosed source into references to properties of specContext. Finally, speculative engine uses the eval statement to generate the compiled function object.","When the speculative engine  calls the new handler, each reference inside the function to a global property will be directed to the cloned property in specContext. In particular, whenever the function tries to manipulate the DOM through the document object, it will actually manipulate the specContext.document object, which is the speculative DOM tree inside the hidden <iframe>.","The with( ) statement binds lexically, so if the original event handler calls other functions, the speculative engine  may rewrite those as well. The speculative engine  does so \u201clazily.\u201d For every function (or method) call f( ) inside the original handler, the speculative engine  inserts a new variable declaration var rewritten f=rewriteFunction(f, specContext); and replaces calls to f( ) with calls to rewritten f( ). The speculative engine  does not rewrite function calls on the document object. These calls will be handled by the specContext.document object, which has already been set to refer to the speculative DOM tree.","If a speculative execution creates a new global property, the creation \u201cfalls through\u201d the \u201cwith\u201d statement and modifies the real global name space. Because JavaScript is single-threaded, the speculative engine  can inspect the global state after speculation terminates, and move the new globals into specContext before they are observed by the real execution. Likewise, a speculative execution can delete a global property from its specContext. The speculative engine  rewrites delete statements to collect a list of tombstones, and upon commit, removes the corresponding properties from the real global name space.","A complication to copying global state is JavaScript closures. Whenever a function object is created, it remembers its lexical scope in an activation record, and uses that scope for name resolution even if it is later invoked from a different scope. Unfortunately, these activation records are not introspectable. If they escape cloning, they become state shared with the real execution. To avoid this occurrence, the speculative engine  rewrites any code that returns a closure to use explicitly-managed activation objects, rather than the implicit scope created by the activation record. Then, when the speculative engine  creates a speculative context, it can clone this activation object using its standard techniques. Note that this rewriting is required of all code that might create a closure reachable from an event handler that may later be speculated upon; lazy application to the call graph visited by a particular handler is inadequate.","Committing Speculative State","The speculative engine  may update the DOM tree root in the non-speculative context, making it point to the DOM tree in the committing speculation's hidden <iframe>. Next, the speculative engine  updates the heap state. A for-in loop enumerates the heap roots in specContext and assigns the corresponding properties in the real global name space; this moves both updated and newly created roots into place. Finally, the speculative engine  deletes from the real global heap the properties named by the tombstones in specContext.deletedGlobals.","In some embodiments, the speculative engine  delays committing a speculative domain until its in-flight AJAX calls complete, to avoid triggering browser bugs when the calls return to a disappeared <iframe>. This rare occurrence momentarily stalls local interactivity in exchange for preserving the AJAX request's head start on network latency.","By default, the speculative engine  may re-speculate on a trigger pair whenever an associated speculation commits. For example, in the image viewer, this means that speculative engine speculatively fetches the next image as soon as the user requests the previously prefetched image. Applications can disable this behavior and explicitly call forceSpeculations( ) on the trigger pair as necessary.","Equivalence Classes","Each speculation may be bound to a trigger pair consisting of a general user interface (GUI) element and an event handler. When a user generates a real event for a trigger pair, the speculative engine  checks whether it has associated speculations that are appropriate for committing. In the simplest case, a trigger pair can only generate a single speculative outcome, and that outcome is always appropriate to commit. For example, in the tab manager, a particular \u201cload new tab\u201d button is always associated with a particular AJAX request, and it is always safe to commit the speculative fetching of the tab content.","Some applications can generate multiple outcomes for a single trigger pair, or outcomes that should not be committed in all circumstances. For example, the speculative autocompleter waits for the user to type a few characters and then speculatively fetches the query results for predicted input strings. When the user submits her actual query, the speculative engine  may be able to determine whether the trigger pair has a speculative context appropriate for committing, given the real state of the browser. If the user wants to search for \u201cfood\u201d but the speculative engine  speculatively fetched results for \u201cfool,\u201d the speculative outcome should not be committed.","Applications use mutators to generate multiple speculable outcomes for a trigger pair, and equivalence classes to determine whether a particular outcome is suitable for committing in response to a real user event. When an application calls makeSpeculative( ) upon a trigger pair, it can specify three additional arguments, a mutator function, a mutator argument vector, and a state hash function. The mutator specifies how a newly cloned browser context should be changed before a speculative execution begins. Each element in the argument vector is a set of arguments to pass to an invocation of the mutator function. The mutator function, with one of its argument lists, transforms a newly cloned application context into a start state for a speculation. For example, in the autocompletion application, the mutator function assigns its sole argument to the query text field of the speculative context2; the mutation vector [[\u201cblue book\u201d],[\u201cblue cross\u201d]] would instruct the speculative engine  to speculate on these two search strings.","The state hash function takes a speculative or real global name space as an argument, and returns an application specific object which is equivalent for a speculative context and a real context only if the speculation is a realizable outcome of the current browser state. In our running example, the state hash( ) simply returns the search field text, so that the \u201cblue book\u201d speculation is eligible to commit if that is what the user has typed. If no hash-equivalent speculation is available, the speculative engine  invokes the original non-speculative event handler.","For input elements like text boxes with a combinatorial number of outcomes, mutators are a natural way to constrain the speculation space. State hashes also allows applications to map semantically equivalent but bitdifferent browser states to a single speculable outcome (e.g., by canonicalizing the search strings blue\\tbook and blue\\t\\tbook to the same speculable outcome).","AJAX Caching","To support the caching of AJAX results, the speculative engine  may call a function cacheAdd(key, AJAXresult) and cacheGet(key). These functions may provide the expected functionality, allowing applications to associate AJAX results with arbitrary cache identifiers. The cache-warming code is still speculative code so event handling routines which call cacheAdd( ) are rewritten and executed in a speculative context.","Speculative Uploads","Upload forms typically consist of a file input text box and an enclosing submit form. After the user types a file name into the input form, the input element generates an onchange event. However, the file is not uploaded to the server until a user triggers the onsubmit event of the enclosing form, typically by clicking a button inside the form. The application can specify an onsubmit handler to validates the file names. If no such handler is defined, or it returns true, the browser posts the form to the server. The server's HTTP response to the post is sent to the target of the form. By default, the target is the current window, causing the browser to load a new page representing the server's response.","The speculative engine  may implement speculative uploads using a simple client\/server protocol. On the client side, the developer specifies which file input should be made speculative by calling prePost (fileInput,callback). Inside prePost( ), the speculative engine  may first save a reference to any user-specified onsubmit form-validation handler, since the speculative engine may supply its own onsubmit handler shortly. The speculative engine  then installs an onchange event handler for the file input which will be called when the user selects a file to upload. The handler creates a cloned version of the upload form in a new invisible <iframe>, with all file inputs removed except the one representing the file to speculatively upload. If, in the speculative execution, the application's original onsubmit validator function succeeds, the speculation posts the speculative form to the server to a URL that accepts only speculative file uploads. The server component caches the uploaded file and its filename, and the client component records that the server has the file cached.","In the real domain, prePost( ) installs an onsubmit handler that lets the speculative engine  introspect the form before a user's real click posts the form. If the speculative engine finds a file input that has been cached at the server, speculative engine  replaces the file input tag with an ordinary input field with the value ALREADY UPLOADED:filename. Upon receipt, the server  inserts the cached file contents before passing the form to the application's server-side component.","The interface above may be least invasive to the application, but a speculation-aware application can provide upload progress feedback to the user by registering a progress callback handler with the speculative engine . The speculative engine  invokes this handler in the real domain when the speculative upload completes, so that the application can update its GUI.","Illustrative Optimizations","Lazy Cloning","For complex web sites, cloning the entire application heap can be unacceptably slow. The speculative engine  may offer an alternative lazy heap cloning implementation. The set of objects actually touched by a speculative execution is typically much smaller than the set of all heap objects, so lazy cloning often produces significant savings.","In lazy mode, the speculative engine  initially copies only the DOM tree and the heap variables referenced by DOM nodes. As the speculative computation proceeds, the speculative engine  rewrites functions on-the-fly as before. However, object cloning is now performed as a side effect of the rewriting process. The speculative engine's lexical analysis identifies which variable names refer to locals, parameters, and globals. Locals do not need cloning, nor do parameters since top-level event handlers take no arguments and cannot introduce global state through them. If the global has not yet been cloned, its object tree is cloned into specContext, and then the function is rewritten using the techniques already described.","Lazy cloning may introduce problems at commit time. Suppose that global objects X and Y both reference object Z. If the speculative execution touches X.Z, the speculative engine  clones X and Z. Y is not cloned because it is not reachable from the object tree rooted by X. Suppose that the speculative execution modifies Z and later commits. The speculative engine  updates the real X to point to the object tree at specContext.X. Now global names X and Y refer to distinct objects, one fresh and one stale. To solve this problem, the speculative engine  may have a checked lazy mode. Before the speculative engine  issues any speculative computations, it traverses every JavaScript object reachable from the global scope or the DOM tree, and annotates each object with parents, a list of parent pointers. A parent pointer identifies the parent object and property-name pair that refer to the given object. The speculative engine  copies parents by reference when cloning an object. When a lazy speculation commits, the speculative engine  uses the parents list to update stale child references in the original heap. Building the parent mapping may be slower than making a full heap copy. However, the parent mapping overhead amortizes across multiple speculations, whereas cloning the entire heap is a per-speculation overhead.","The speculative engine  also has an unchecked lazy mode in which the speculative engine clones lazily but assumes that stale child references never occur, thereby avoiding the construction and checking of the parent map. This assumption may seem overly presumptuous, but for modular applications, it is often valid. For example, the autocompletion widget is a stand-alone piece of JavaScript code. When a developer inserts a speculative version of it into an enclosing web page, the widget will not be referenced by other heap variables, and running in unchecked mode will not cause stale child references.","A developer can run the speculative engine  in checked mode with an assertion that reports when the assumption is violated. These reports enable the developer to refactor code into a form compatible with unchecked lazy mode. Full clone mode or checked lazy mode is adequately performant for many web sites and applications, but for some complex sites, unchecked lazy speculation is the only feasible mode, making checked mode refactoring a necessity.","Speculation Zones","Just as a typical speculative execution touches only a fraction of its object heap, it will often touch only a fraction of its DOM tree. For example, the autocompletion widget only modifies the <div> tag which will hold the fetched search results. DOM objects do not support adequate introspection to implement lazy cloning, thus checked lazy cloning is impossible. Instead, the speculative engine  provides for the DOM tree an analog of \u201ceager unchecked mode\u201d for the heap. The application may provide an optional speculation zone parameter to makeSpeculative( ) specifying the root of the DOM subtree that an event handler modifies. At speculation time, the speculative engine  will only clone the DOM nodes and JavaScript heap objects associated with this branch of the tree. Upon speculation commit, the speculative engine  splices in the speculative DOM branch but leaves the rest of the DOM tree undisturbed.","Speculation zones are also useful when the DOM tree contains rich objects with opaque internal state, such as a Flash movie or applet. The clone of such a node returned by cloneNode( ) would be initialized to its virgin state, which could be problematic. For instance, if a video were halfway through playing in the real display, when it was cloned and then spliced back into the real display, the user would observe the strange anomaly of the video player snapping back to the first frame. Speculation zones enable an application to avoid this phenomenon. By speculating around these objects, they avoid breaking user expectations about these objects' behavior.","Context Pools","The speculative engine  hides speculative computations within the \u201cthink time\u201d of a user. The shorter the think time, the faster the speculative engine has to launch speculations to reduce user-perceived latencies. For example, time pressure is comparatively high in the search term autocompletion widget, since a fast typist may generate her search string quickly.","To remove object cloning from the critical path of issuing new speculations, the application can call createContextPool(N, hash, DOMtreeRoot). This function generates and caches N clones of the current browser environment. Each clone is tagged with the specified state hash; between verifying with state hash( ) and updating with a mutator, the developer is responsible for ensuring that the pool domains accurately reflect the real domain.","Using context pools, the entire cost of eager cloning or the initial cost of lazy cloning is paid in advance. For example, when the autocompletion widget initializes, it creates a domain pool of size 3. Later, when the user begins typing \u201cfoo\u201d into the widget, the speculative engine  can use a mutator to rapidly specialize a domain from the pool and launch the relevant speculation.","Illustrative Computing System",{"@attributes":{"id":"p-0112","num":"0111"},"figref":["FIG. 9","FIG. 1","FIG. 9"],"b":["900","900","900"]},"In a very basic configuration, the computing device  typically includes at least one processing unit  and system memory . Depending on the exact configuration and type of computing device, the system memory  may be volatile (such as RAM), non-volatile (such as ROM, flash memory, etc.) or some combination of the two. The system memory  typically includes an operating system , one or more program modules , and may include program data . The operating system  includes a component-based framework  that supports components (including properties and events), objects, inheritance, polymorphism, reflection, and provides an object-oriented component-based application programming interface (API). The computing device  is of a very basic configuration demarcated by a dashed line . Again, a terminal may have fewer components but will interact with a computing device that may have such a basic configuration.","The computing device  may have additional features or functionality. For example, the computing device  may also include additional data storage devices (removable and\/or non-removable). Such additional storage is illustrated in  by removable storage  and non-removable storage . Computer storage media may include volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information, such as computer readable instructions, data structures, program modules, or other data. The system memory , the removable storage , and the non-removable storage  are all examples of computer storage media. The computing device  may also have input device(s)  (e.g., keyboard, etc.) and output device(s)  (e.g., display, etc.).","The computing device  may also contain communication connections  that allow the device to communicate with other computing devices  (e.g., the data server(s) , etc.), such as over the network . The network(s)  may include wired networks as well as wireless networks. The communication connections  are one example of communication media. The communication media may typically be embodied by computer readable instructions, data structures, program modules, etc.","It is appreciated that the illustrated computing device  is only one example of a suitable device and is not intended to suggest any limitation as to the scope of use or functionality of the various embodiments described. Other well-known computing devices, systems, environments and\/or configurations that may be suitable for use with the embodiments include, but are not limited to personal computers, server computers, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set top boxes, game consoles, programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and\/or the like. For example, some or all of the components of the computing device  may be implemented in a cloud computing environment, such that resources and\/or services are made available via a computer network for selective use by client devices.","The above-described techniques pertain to speculative execution of rich web content to enhance user-perceived and\/or actual network application performance. Although the techniques have been described in language specific to structural features and\/or methodological acts, it is to be understood that the appended claims are not necessarily limited to the specific features or acts described. Rather, the specific features and acts are disclosed as exemplary forms of implementing such techniques."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The detailed description is described with reference to the accompanying figures. In the figures, the left-most digit(s) of a reference number identifies the figure in which the reference number first appears. The same reference numbers in different figures indicate similar or identical items.",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 9","FIG. 1"]}]},"DETDESC":[{},{}]}
