---
title: Interaction between applications built on different user interface technologies
abstract: Various embodiments of systems and methods for interaction between applications built on different technologies are described herein. In one aspect, at least one action handler of a number of action handlers is associated with at least one application from a number of applications participating in the integrated scenario. In another aspect, at a first action handler that is associated with a source application, a request to access a target application is received. An identifier of the target application is retrieved and based on that identifier a second action handler associated with the target application is invoked, where the identifier of the target application is registered with the second action handler. The target application is launched by the second action handler in response to the received request.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08978046&OS=08978046&RS=08978046
owner: Business Objects Software Limited
number: 08978046
owner_city: Dublin
owner_country: IE
publication_date: 20110622
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["Almost every large enterprise uses various computer applications to automate its activities. Often, such different applications implement different User Interface (UI) technologies, e.g. eXtensible HyperText Markup Language (XHTML), Web Dynpro ABAP\u00ae developed by SAP AG, Flash\u00ae originally developed by Macromedia Inc., Flex\u00ae provided by Adobe Systems Inc., JavaScript\u00ae developed by Netscape Communications Corp., etc., running on different platforms, e.g., Java\u00ae Platform originally provided by Sun Microsystems Inc., .Net\u00ae Framework provided by Microsoft Corp, Adobe Integrated Runtime\u00ae cross-platform provided by Adobe Systems Inc., etc. In many cases, there is a need to integrate these applications for executing different tasks or business processes. Integration of applications may require integration on UI level to allow users to interact with the different applications.","Integration of applications based on different UI technologies would require employing different tools for communication between the applications. An example of such tools is a Flash\u00ae JavaScript\u00ae bridge for communication between Flex\u00ae-based and Hyper Text Markup Language (HTML) based applications, ActiveX\u00ae controls provided by Microsoft Corp, etc. Furthermore, when adding a new application built on different UI technology to a group of integrated applications, additional integration tools may need to be employed. Thus, the number of tools needed to build and support UI integration grows. Integration is performed in an unstructured manner, tools are deployed in an ad hoc basis, resulting in a disorganized grid that makes navigation and interaction between applications inefficient and difficult to maintain.","Various embodiments of systems and methods for interaction between applications built on different user interface technologies are described herein. In one aspect, at least one action handler is associated with an application from a group of applications. A request for accessing a target application is received at a first action handler associated with a source application. A target identifier of the target application is retrieved based on the request. In another aspect, a second action handler associated with the target application is invoked, where the target identifier is registered with the second action handler. The second action handler launches the target application in response to the request.","These and other benefits and features of embodiments of the invention will be apparent upon consideration of the following detailed description of preferred embodiments thereof, presented in connection with the following drawings.","Embodiments of techniques for interaction between applications built on different user interface technologies are described herein. In the following description, numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize, however, that the invention can be practiced without one or more of the specific details, or with other methods, components, materials, etc. In other instances, well-known structures, materials, or operations are not shown or described in detail to avoid obscuring aspects of the invention.","Reference throughout this specification to \u201cone embodiment\u201d, \u201cthis embodiment\u201d and similar phrases, means that a particular feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus, the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore, the particular features, structures, or characteristics may be combined in any suitable manner in one or more embodiments.","In an enterprise, a common use case is integration of several different applications in a given scenario to enhance the set of available services and functionalities. Typically, these applications are built on different platforms and UI technologies. For example, such integrated scenario may involve SAP Strategy Management (SSM) application part of the Enterprise Performance Management (EPM) framework, and Risk Management (RM) application part of the Governance, Risk and Compliance (GRC) application. On one hand, the SSM application may be developed in C\/C++\/C# or Visual Basic programming languages in the .NET\u00ae Framework, with Flex\u00ae or Excel\u00ae plug-ins based UI. On the other hand, the UI of the RM application may be based on Web Dynpro ABAP\u00ae. The RM application deals with management, identification and assessment of risks within a given organization. The SSM application enables organizations to define strategic goals, and then measures and manages performance (for example, by setting Key Performance Indicators (KPIs)) against those goals. A possible use case may involve defining KPIs for maintaining certain risk level below a given threshold. Integration of applications may allow users to manage risks within the RM application while monitoring the corresponding KPIs from the SSM application.","Navigation and interaction between applications built on different UI technologies requires interoperability at the UI level. In one embodiment, action handlers allow for navigation, access or other interaction between different UI technologies, thus ensuring interoperability. Functionalities provided by applications built on different UI technologies are accessible by a user through an integrated interface. A single point of access to multiple applications on UI level is enabled.",{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 1A","FIG. 1A","FIG. 1A"],"b":["100","100","110","120","130","150","160","110","120","130","150","160","110","115","120","125","130","135","150","155","160","165"]},"An action handler is associated with an application to implement the UI technology of the associated application. In one embodiment, action handlers may even be associated with separate UI components, e.g. browser windows, of a given application. In many cases, an action handler is associated with a UI exposed by an application. Alternatively, an action handler may also be associated with several applications built on the same UI technology. Thus, the association between action handlers and applications may be based on the UI technologies these applications implement. In one embodiment, an action handler may be implemented as a JavaScript\u00ae object within a browser. In other embodiments, action handlers may be created using other scripting or programming languages, such as, Java\u00ae, C\/C++, Delphi\u00ae, ABAP\u00ae, HTML, ActionScript\u00ae originally developed by Macromedia Inc, etc.","In this document, the term application is generally used to mean any software entity. The group of applications involved in a given integrated scenario may include, but is not limited to, applications such as enterprise software (e.g. Enterprise Performance Management (EPM), Governance, Risk and Compliance (GRC), Customer Relationship Management (CRM), Supply Chain Management (SCM) software, etc.), content access software (e.g. Web browsers, Media Players, etc.), data management software (e.g. Spreadsheets), etc.","In one embodiment, action handlers associated with a number of integrated applications are organized in a graph structure, where the nodes of the graph structure represent action handlers, and the edges of the graph represent relationships between the action handlers. In one embodiment, the graph structure may be a hierarchical tree. Action handlers may be linked with each other by parent-child relationships. There may be at least one root action handler at the top level of the hierarchy that does not have a parent action handler. In , action handler  of portal application  is at the top level of the hierarchy, while action handlers , , ,  and  are organized at lower levels.","In , each set of target identifiers (IDs) , , ,  and  is associated with a corresponding action handler from the group of action handlers , , ,  and . Target identifiers uniquely specify targets within a given integration scenario. In this document, the term \u201ctarget\u201d may refer to a UI component, to a group of UI components, to the whole UI of an application or to the UI of several applications. In one embodiment, a target identifier is represented as uniform resource locator (URL), however, other formats may be used as well. Once a target identifier is generated for a given target, the target identifier is registered with an action handler implementing the UI technology of the target. As a result of a registration process, the action handler stores or keeps reference to the target identifier. Thus, a correlation between the target identifier and the action handler is established. In one embodiment, an action handler may store or keep reference to a set of correlations between target identifiers and corresponding action handlers, e.g., a set of pairs, where one element of a pair is a target identifier specifying a target UI component and the other is an action handler correlated with that target. In , each action handler from the group of action handlers , , ,  and  stores or keeps reference to a set of target identifiers , , ,  and .","In one embodiment, a user triggers an access request from source application  to target , e.g, by clicking on UI control . The access request to a target application may be invoked by following a link in the source application to the target application, by clicking on a button, by activating other UI components, and the like. In one embodiment, access request means any type of contact between two applications built on different UI technologies. For example, an access request may be a request for navigation from one application to another, for accessing one application from another, for executing functions of one application from another or other types of interaction between applications.","Referring back to , target identifier  is stored by control , generated for  by  or defined at design time. It uniquely specifies target . The target identifier  is retrieved and passed to the source action handler  responsible for processing the request. Thus, the access request is dispatched to source action handler  associated with the source application . Then, the source action handler checks whether target identifier  is a member of the set of target identifiers  associated with source action handler .","As shown in , the target  is associated with source action handler . Respectively, the requested target  and the source application  are built on the same UI technology, and the target identifier  is a member of the set of target identifiers . Therefore, the source action handler  is responsible for implementing the UI technology of target , e.g., for launching the UI specified by target ID  of the requested target . In this document, the phrase \u201claunching a target\u201d may refer to executing, activating, bringing into focus, accessing or other types of actions with the target.","In one embodiment, the requested target application and the source application may have different action handlers associated with them. For instance, in , target  is not implemented using the same UI technology as source application  where the access request is triggered. The source action handler  does not implement the same UI technology as target  of target application . Therefore, target identifier  of target  is not registered with source action handler  and is not a member of set of target identifiers  associated with source action handler . Thus, the source action handler cannot launch the requested target .","When no match for target identifier  is found in set , the access request is dispatched to the parent action handler  of the source action handler . The source action handler  dispatches the request to the related action handler on a higher hierarchical level. The action handler  checks whether target identifier  is included in its set of registered target identifiers . In the scenario illustrated in , the UI technology of target  is different from the UI technology on which application  is built, and hence not associated with action handler . Therefore, target identifier  is not a member of set of target identifiers . Similarly, the request is dispatched upwards along the hierarchy of action handlers until a match is found. The request may reach the top level action handler , i.e. the root action handler. In one embodiment, the root action handler  stores or keeps reference to all target identifiers generated in system . In the integration scenario illustrated with , the target identifier  is registered as a member of set of target identifiers  of the root action handler .","Action handler  dispatches the request to the respective action handler correlated with target identifier . In one embodiment, action handler  keeps reference to a correlation between the target identifier  and the immediate child action handler . Next, action handler  keeps reference to a correlation between target identifier  and the next child action handler  and so on. Thus, action handler  continues to dispatch the request downwards along the hierarchy of action handlers to target action handler , where target identifier  is member of set of target identifiers (IDs) . Finally, target action handler  launches target . The action handlers  and  dispatch the access request downwards the hierarchy of related action handlers until the request reaches action handler directly correlated with the target .","In another embodiment, when the request reaches an action handler that keeps reference to the requested target identifier, instead of dispatching the request downwards along the hierarchy of action handlers, the action handler dispatches the request directly to the action handler implementing the UI technology on which the target is built on. For example, in , action handler  may store correlation between target identifier  and target action handler . Thus, the root action handler  may dispatch the request directly to target action handler  to launch target  of target application , skipping the dispatch of the request via action handler .","In yet another embodiment, the target identifier of the requested target application may not be correlated with any of the action handlers. In such a case, a negative response indicating access failure is delivered back to the action handler associated with the source application where the access request has been triggered. It could be a responsibility of the source application to manage the failure of the request.","In some cases, applications involved in a given integration scenario may be predefined and configured at design time. Alternatively, the involved applications are dynamically defined at run time. For example, the top level frame applications may be dynamically allocated by integration scenarios, while the organization of applications at lower levels of the hierarchy may be defined at design time.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 2","b":["200","210"]},"At , a target identifier of the target application is retrieved or generated based on the access request. The target identifier may be a URL. In one embodiment, a target URL consists of two parts\u2014a target unique identifier (UID) and parameters. The target UID is a non-changing part of the target identifier that uniquely specifies a target within a given integration scenario. For example, a target UID may be \u201chttp:\/\/uri.sap.com\/targets\/poa\/epm\/ssm\/planning\/dashboard?\u201d. The second part of a target URL is used to pass parameters. For example, the parameters part of the target URL may be \u201cclient=200&mashup=budgeting\u201d. The target URL may be a concatenation of the target UID followed by the parameters, e.g. \u201chttp:\/\/uri.sap.com\/targets\/poa\/epm\/ssm\/planning\/dashboard?client=200&mashup=budgeting\u201d. In one embodiment, target identifiers that are represented by URLs may identify distinct entities within a given integration scenario.","At , in one embodiment, a second action handler that is associated with the target application is invoked, where the target identifier, retrieved at , is registered with the second action handler. A target identifier is associated with an action handler because the respective target can be launched by the action handler. Finally, at , the second action handler launches the target application in response to the request.","In one embodiment, the target identifier may be registered with the source action handler. Thus, the source action handler implements the UI technology of the requested target. As a result, instead of invoking a second action handler, the source action handler launches the target.","In one embodiment, the second action handler implementing the UI technology of the target application is invoked by a third action handler. In one embodiment, action handlers are organized in a hierarchical structure. The third action handler is at a higher level than the second action handler in the hierarchy of action handlers and stores or keeps reference to a correlation between the target identifier of the requested target and the second action handler. Before the request reaches the second action handler, it is first dispatched to the third action handler. For example, in , the third action handler may be action handler  parent of the second action handler, i.e. target action handler . In yet another embodiment, the third action handler may be the root action handler, e.g. in  that is action handler  at the top level of the hierarchy of action handlers. The third action handler may be either parent, child, or not directly related to the first action handler, according to one embodiment.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 3","b":["300","310","320","330","340","350","360","370","350"]},"In one embodiment, at , not only the target identifier is registered with the current action handler, but also the correlation between the target identifier and its respective action handler associated with the target application. For example, in , when target  is created and the target registration process  is started (), firstly, target action handler  registers the correlation between itself and target identifier . Next, the correlation between target action handler  and target identifier  is registered with action handler . Similarly, this process continues until the correlation between target action handler  and target identifier  is registered with the root action handler .","In one embodiment, apart from registering the target identifier with the action handler of the target application at , the correlation between the target identifier and the last action handler the target identifier has been registered with is stored. Thus, track of the registration process is kept by a sequence of action handlers. Organizing action handlers in a hierarchy allows for a simplified launch of the target, e.g., by invoking action handlers one by one from the sequence of action handlers with which the target identifier has been registered.","For example, in , the correlation between target identifier  and target action handler  is registered with target action handler . Then, the correlation between target identifier  and target action handler  is registered with action handler . Finally, the correlation between target identifier  and action handler  is registered with action handler . Upon completion of the registration process, parent action handlers store information about target identifiers that are associated with their child action handlers. Moreover, parent action handlers store information about correlations between their child action handlers and the target identifiers. Target identifiers are distributed along the hierarchy of action handlers, where only root action handlers, at the top of the hierarchy, store information about all available target identifiers.","In one embodiment, the information may be stored in a hash table, where the key is the target identifier and the corresponding value for that key is the action handler associated with the target identifier. In another embodiment, an action handler may store the information in two-dimensional array of strings.","The target registration process  illustrated in  may be static, i.e. the registration of target identifiers may be performed at design or configuration time. For example, references to the relevant target identifiers may be embedded into action handlers at design time. Target identifiers may be stored locally by action handlers and predefined based on the technological limitations of the underlying platforms. Furthermore, action handlers may be organized in a hierarchy at design time as well.","In the same time, or alternatively, registration process may be dynamic. In other words, upon start-up of a scenario where the UIs of participating applications require integration, one or more of the applications involved in the scenario perform an initial process for registration of target identifiers. For example, in one embodiment, a bottom-up registration process is performed along the tree hierarchy of action handlers by action handlers associated with target applications. As a result, target identifiers are stored and distributed across sub-trees of the hierarchical tree structure of action handlers, where only root action handlers keep reference to all target identifiers and their correlated action handlers. In case when a new target is presented in, or an existing target is removed from an application involved in the integrated scenario, the corresponding action handlers may dynamically register the newly created or remove the obsolete target identifiers.","In one embodiment, a target identifier refers to an already existing target that is already created and present in a given integration scenario. However, the functionality of the applications involved in an integration scenario, may allow dynamic creation of objects, e.g., dynamically created business objects, application windows, etc. For example, a dynamically generated browser window, displaying an instance of an object may be generated in response to an instantiation of the object. Thus, new targets might be dynamically created at run time. Target identifiers for such new targets may not be necessarily generated or assigned to those targets. In other words, the introduction of new targets into the system may not be automatically reflected into the hierarchy of action handlers by respective target identifiers distributed across the hierarchy. Furthermore, there may be requests for accessing, or navigating to targets, which are not yet created or present in the hierarchy of action handlers.","In one embodiment, a target identifier is constructed to identify not only a specific target, but also the host application of that target (i.e. the application within which the target is generated or present). As mentioned before in paragraph [0033], a target identifier may be URL string with two parts\u2014a target UID and parameters. Based on the target UID, the host application of the requested target may be identified. The parameters part of the URL may be used to specify a particular entity to be accessed within the host application. In other words, the combination of a host application identifier and an identifier of a particular application object requested may represent a target identifier. The advantage is that upon receiving an access request, only the identifier of the host application is sufficient for action handlers to dispatch the request appropriately. Thus, a request to a target not yet created is dispatched to the appropriate host application based on the target identifier. Once the request is dispatched to the respective host application, the host application dynamically creates the target based on the parameters passed with the target identifier. This is how requests for navigation to, or other interactions, with dynamically generated objects are enabled, according to one embodiment.","For example, in , an access request to a specific object (for instance with an object identifier \u201cKPI8\u201d) within target application  is received upon activating UI control . Consequently, target identifier  is retrieved from the request, for example, \u201chttp:\/\/sap.com\/application\/150?objectid=kpi8\u201d. In case the requested target  is not yet created, the generated target identifier  is not present in the system yet, e.g., the retrieved target identifier  is not registered with any action handler yet. Nevertheless, the request is dispatched along the chain of action handlers until it reaches the root action handler .","In one embodiment, a general reference to target application  and the objects thereof may be registered with action handlers ,  and . For example, the reference may be a URL string with wildcards or placeholders, such as \u201chttp:\/\/sap.com\/application\/150?objectid=*\u201d. Thus, once the request reaches the top level action handler  and set of target identifiers  is searched for target identifier , a match between the target identifier  and the reference to the host application  would be found. Consequently, the top level action handler dispatches the request accordingly first to action handler  and then to the target action handler  responsible for launching the specific object, i.e. target .",{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 4A","FIG. 4B"],"b":["400","410","420","430","440","470","450","460","400","430","400","475"]},"At , a check is performed whether the current action handler is the same as the action handler correlated with the target identifier of the requested target. If the check is confirmed, at , the current action handler launches the target and the process ends. Alternatively, if the current action handler and the correlated action handler are different, at , the current action handler invokes the action handler correlated with the target identifier. At , the invoked correlated action handler becomes current action handler and the process continues at .",{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 5","b":["500","500","525","570","520","510","570","510","525","570","510","520","525","550","560","520","525","550","530","580","560","540","590"]},"As mentioned above in the background, communication bridges enable bi-directional communication between two different UI technologies. The method and system for navigation across applications built on different technologies described in  and  necessitate communication between action handlers in both directions. Thus, once a communication bridge is employed between two action handlers associated in a parent-child relationship, both action handlers may initiate communication.","On the other hand, the method for target registration illustrated in , in one embodiment, may require communication in one direction only. For example, bottom-up communication, i.e. child action handlers initiate registration with parent action handlers.","Several advantages are added by the method and system described herein. Firstly, communication bridges do not automatically allow navigation and interaction between UIs of two applications built on different technologies. Dispatching access requests and managing distribution of target identifiers is enabled by action handlers and their organization into a hierarchy.","Secondly, navigation, access or other interaction requests from one application to another are facilitated by dispatching the requests along parent-child associations of action handlers. In one embodiment, in the hierarchy, the path from one action handler to another action handler is unique. Thus, the method for accessing the UI of one application from another is simplified and improved compared with the association of each application with every other application from the integration scenario, where multiple paths may be used to navigate between the applications.","The embodiments of methods and systems for interaction between applications built on different UI technologies described herein further enable management of several instances of the same application. Each parent action handler keeps track of running instances of child action handlers. Thus, upon receiving an access request, an action handler may launch a new instance or an already existing running instance of an application. Depending on applications' functionalities several windows with different instances of a same object may be launched. Alternatively, only one window with one instance of a same object may be launched in parallel.","Some embodiments of the invention may include the above-described methods being written as one or more software components. These components, and the functionality associated with each, may be used by client, server, distributed, or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as, functional, declarative, procedural, object-oriented, lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively, the components maybe implemented in server and client applications. Further, these components may be linked together via various distributed programming protocols. Some example embodiments of the invention may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example, a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level (e.g., a graphical user interface). These first and second computer systems can be configured in a server-client, peer-to-peer, or some other configuration. The clients can vary in complexity from mobile and handheld devices, to thin clients and on to thick clients or even other servers.","The above-illustrated software components are tangibly stored on a computer readable storage medium as instructions. The term \u201ccomputer readable storage medium\u201d should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term \u201ccomputer readable storage medium\u201d should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store, encode, or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described, represented, or illustrated herein. Examples of computer readable storage media include, but are not limited to: magnetic media, such as hard disks, floppy disks, and magnetic tape; optical media such as CD-ROMs, DVDs and holographic devices; magneto-optical media; and hardware devices that are specially configured to store and execute, such as application-specific integrated circuits (\u201cASICs\u201d), programmable logic devices (\u201cPLDs\u201d) and ROM and RAM devices. Examples of computer readable instructions include machine code, such as produced by a compiler, and files containing higher-level code that are executed by a computer using an interpreter. For example, an embodiment of the invention may be implemented using Java, C++, or other object-oriented programming language and development tools. Another embodiment of the invention may be implemented in hard-wired circuitry in place of, or in combination with machine readable software instructions.",{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 6","b":["600","600","605","655","600","640","655","610","615","610","615","605","615","600","625","630","600","625","630","600","635","600","650","650","600","645","600","620","660","660","660","650","660"]},"A data source is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases, such as, relational, transactional, hierarchical, multi-dimensional (e.g., OLAP), object oriented databases, and the like. Further data sources include tabular data (e.g., spreadsheets, delimited text files), data tagged with a markup language (e.g., XML data), transactional data, unstructured data (e.g., text files, screen scrapings), hierarchical data (e.g., data in a file system, XML data), files, a plurality of reports, and any other data source accessible through an established protocol, such as, Open DataBase Connectivity (ODBC), produced by an underlying software system (e.g., ERP system), and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams, broadcast data, and the like. These data sources can include associated data foundations, semantic layers, management systems, security systems and so on.","In the above description, numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize, however that the invention can be practiced without one or more of the specific details or with other methods, components, techniques, etc. In other instances, well-known operations or structures are not shown or described in details to avoid obscuring aspects of the invention.","Although the processes illustrated and described herein include series of steps, it will be appreciated that the different embodiments of the present invention are not limited by the illustrated ordering of steps, as some steps may occur in different orders, some concurrently with other steps apart from that shown and described herein. In addition, not all illustrated steps may be required to implement a methodology in accordance with the present invention. Moreover, it will be appreciated that the processes may be implemented in association with the apparatus and systems illustrated and described herein as well as in association with other systems not illustrated.","The above descriptions and illustrations of embodiments of the invention, including what is described in the Abstract, is not intended to be exhaustive or to limit the invention to the precise forms disclosed. While specific embodiments of, and examples for, the invention are described herein for illustrative purposes, various equivalent modifications are possible within the scope of the invention, as those skilled in the relevant art will recognize. These modifications can be made to the invention in light of the above detailed description. Rather, the scope of the invention is to be determined by the following claims, which are to be interpreted in accordance with established doctrines of claim construction."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The claims set forth the embodiments of the invention with particularity. The invention is illustrated by way of example and not by way of limitation in the figures of the accompanying drawings in which like references indicate similar elements. The embodiments of the invention, together with its advantages, may be best understood from the following detailed description taken in conjunction with the accompanying drawings.",{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4A"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4B"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
