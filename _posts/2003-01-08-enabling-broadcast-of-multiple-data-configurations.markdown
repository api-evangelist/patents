---
title: Enabling broadcast of multiple data configurations
abstract: A broadcast data server enables broadcast of multiple data configurations. The broadcast data server maintains configuration definitions that define how broadcast data may be configured for presentation to a viewer. The broadcast data server also maintains region definitions that identify regions that may be associated with client devices for receiving broadcast data. The configuration definitions are mapped to region definitions, enabling a client device in a particular region to selectively receive broadcast data according to any one of multiple data configurations that are associated with the particular region.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07546383&OS=07546383&RS=07546383
owner: Microsoft Corporation
number: 07546383
owner_city: Redmond
owner_country: US
publication_date: 20030108
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","CONCLUSION"],"p":["This invention relates to data broadcasting and, in particular, to enabling broadcast of multiple data configurations.","Digital television networks generally devote most of their available bandwidth to broadcasting audio and video information. In addition, other information that does not encode video and audio is generally sent in parallel using a small amount of the available bandwidth, typically referred to as an out-of-band network. This other information often includes, but is not limited to, electronic program guide data, conditional access instructions, layout information for a user interface to be displayed, and advertising data. Usually, set-top boxes are designed to gather out-of-band data in parallel with decoding and rendering video and audio data, so that a viewer is free to watch programming while the set-top box accumulates programming data and other information. For example, a cable television broadcast company may broadcast program content over a broadband cable network and broadcast additional related data over a separate smaller band of the same cable network. In this way, a viewer using a client that has at least two tuners can change channels using a first tuner while the client continues receiving the additional data using a second tuner. Alternatively, multiple data streams may be broadcast in parallel over the same channel, allowing a client device with only one tuner to simultaneously receive broadcast program content and broadcast data over the same channel. Because both the quality and number of television channels is a major business point for digital television operators, the amount of bandwidth reserved for the secondary information is usually extremely limited compared to the amount of bandwidth used for broadcasting the video and audio data.","Furthermore, set-top boxes are typically pre-configured to download and display additional data, such as programming data, in a particular language and according to a particular layout. The particular language and layout to be supported is initialized when the set-top box is provisioned, and the user is not given the ability to select another language or layout.","Enabling broadcast of multiple data configurations is described. A broadcast data server maintains multiple configuration definitions that are mapped to region definitions. Region definitions may represent geographical regions in which client devices may be implemented or other groupings of client devices based on parameters other than geographical location. Configuration definitions define data groupings according to various languages and\/or display formats. The region\/configuration mappings are broadcast along with broadcast data, allowing each client device within a region to selectively receive portions of the broadcast data according to any of a number of data configurations associated with the region. In this manner, a single data broadcast can be received by a client device according to any one of multiple configurations, each of which results in a different presentation of the data to a viewer.","The following discussion is directed to enabling broadcast of multiple data configurations in a broadcast television system. Program content (e.g., broadcast television programs, video-on-demand programs, etc.) and data (e.g., electronic program guide data, video-on-demand data, advertisements, etc.) are broadcast from a headend system, such as a cable television company to multiple client devices, such as cable television set-top boxes. In addition to broadcasting program content and associated data, the headend also broadcasts data that defines data configurations that are available to client devices receiving the broadcast data. A client device presents a viewer with a list of available configurations through a user interface that is associated with the client device. When a viewer selects an available configuration, the client device selectively receives portions of the broadcast data according to the selected configuration definition. A client device can selectively receive data according to any one of multiple configurations based on a region identifier that is associated with the client device. In one implementation, the region identifier may be assigned to the client device by a client device manufacturer. For example, digital video disc (DVD) players typically have a region identifier built into each unit that identifies a particular geographic region (e.g., North America) for which the unit is designed. In an alternate implementation, a client device may be assigned a region identifier during a cable company setup process. For example, the cable company may send a packet of data to the client device identifying the region that is associated with the client device. In another alternate implementation, an algorithm on the client device may be used to determine an appropriate region identifier based, for example, on a list of available channels. A region identifier may be based on a geographic region within which the client device is implemented or may be based on other parameters, for example, a channel lineup that may be available to a group of client devices. The region identifier can then be used by the client device to determine multiple data configurations that are available. For example, a television set-top box that is configured to receive broadcast television programs and data from a cable company in San Francisco may be able to selectively receive broadcast data based on an English configuration or based on a Spanish configuration. Alternatively, a set-top box that is configured to receive broadcast television programs and data from a cable company in New York City may be able to selectively receive broadcast data based on an English configuration, a German configuration, or a French configuration. Additional configurations may also be supported that may or may not be based on a language. For example, a child-friendly configuration may be designed to provide a simplified user interface and to allow access to a limited number of broadcast channels. In another example, alternate configurations may be designed that provide themed user interfaces based, for example, on professional sports teams or other viewer interests. Furthermore, configurations may be defined that are based on a combination of one or more themes and a language, such as an English baseball configuration, a Spanish baseball configuration, and an English\/child-friendly\/baseball configuration. Advertisements may also be targeted based on a chosen configuration.","Exemplary System Architecture",{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 1","b":["100","100","100","102","104","106","108","110","1","110","2","110","108","112","114"]},"Content providers  distribute stored program content such as movies, television programs, music, and similar audio and\/or video content from content providers  to headend . Additionally, content providers  control distribution of live content (e.g., content that was not previously stored, such as live feeds) and\/or content stored at other locations to headend .","Data providers  provide additional data to be broadcast such as advertisements, electronic program guide (EPG) data, video-on-demand (VOD) data, and so on, to broadcast data server .","Broadcast data server  receives data from data providers , arranges the data according to multiple data configuration definitions, and delivers the data to headend . Broadcast data server  includes data collectors  and configuration management system . Data collectors  gather and cache data from data providers . Configuration management system  maintains configuration definitions that are used to determine how the data that is gathered by the data collectors  is to be delivered to headend , and in turn, broadcast to client devices .","Headend  includes a data carousel , a broadcast transmitter , and may also optionally include a content carousel . Data carousel  is a storage area from which broadcast data (received from data providers  via broadcast data server ) can be broadcast over out-of-band (OOB) network  to the multiple client devices . Broadcast transmitter  controls the transmission of program content over in-band network  and data over OOB network . Program content may be streamed directly from content providers  or may be received and stored in optional content carousel  before it is broadcast to client devices . Because both the quality and number of television channels is a major business point for digital television operators, the amount of bandwidth reserved for OOB network  is typically extremely limited compared to the amount of bandwidth reserved for the in-band network .","Client devices  are implemented to receive broadcast program content and broadcast data from headend  via in-band network  and OOB network . Furthermore, each client device is configured to receive a region configuration file that contains data configuration definitions that are available to the client device based on a region identifier that is associated with the client device. The client device presents a viewer with a list of available configurations using a user interface component. When a user selects a configuration, the client device then selectively receives broadcast data according to the definition of the selected configuration.","Client devices  can be implemented in any number of ways. For example, a client device implemented as a satellite receiver coupled to a television receives broadcast content and data from a satellite-based transmitter, and the received content and data is rendered on the television screen. A client device implemented as a cable television set-top box receives broadcast content and data over a cable network. Other example client devices include digital video recorders, TV-enabled personal computers, and so on, and may include any client device configured to receive broadcast data over a one-way, one-to-many broadcast network. Select components of an exemplary client device are described in more detail below, with reference to .","Exemplary Broadcast Data Server",{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 2","b":["106","106","202","204","206","116","118","206","202"]},"Data collectors  receive data from data providers  and store the received data in data cache . In the illustrated implementation, data collectors  include an ad data collector  for receiving advertisement data, a video-on-demand (VOD) data collector  for receiving data that describes available on-demand video titles, and an electronic program guide (EPG) data collector  for receiving EPG data. Each data collector may receive data from one or more data providers . Furthermore, data collectors  are not limited to ad data collector , video-on-demand (VOD) data collector , and EPG data collector , which are merely representative examples of specific data collectors that may be implemented.","Configuration management system  includes a configuration repository , a configuration interface , a region configuration file generator , and a data configuration module . Configuration repository  stores data that defines regions, configurations, and mappings between the defined regions and configurations. An exemplary configuration repository structure is described in more detail below with reference to . Configuration interface  provides access to configuration repository , providing a mechanism for system administrators to create and maintain region definitions, configuration definitions, and region\/configuration mappings. In one implementation, the region definitions are typically generated by a headend (e.g., a cable company), and entered into the configuration repository  using the configuration interface .","Region configuration file generator  generates, for each region defined in configuration repository , a formatted region configuration file that specifies how a client device  can selectively receive broadcast data according to each configuration associated with the defined region. In the described implementation, each region configuration file specifies file directory structures associated with each configuration. In one implementation, region configuration file generator  is implemented as a data collector  that gathers data from configuration repository  instead of from data providers .","Data configuration module  copies data from data source  (which is the cache memory location where the data was stored when it was received from data providers ) to data carousel  according to the file directory structures specified in each region configuration file. After the data is copied to data carousel , the data is broadcast over OOB network  and client devices  are able to selectively receive data associated with one of many data configurations based on a region identifier that is associated with each particular client device . For example, a particular client device may be associated with a region identifier that is in turn associated with multiple configurations (in configuration repository , and thus in a region configuration file). A viewer using the client device can then select one of the multiple available configurations, causing client device  to selectively receive portions of broadcast data according to the selected configuration. The amount of data that is broadcast is minimized by the fact that each particular piece of data is broadcast only once, even though a particular piece of data may be applicable to multiple configurations. In such an instance, multiple client devices each having a different configuration selected may all receive the data that is common among the selected configurations. Region configuration files are described in more detail below with reference to .","Exemplary Configuration Repository Structure",{"@attributes":{"id":"p-0063","num":"0062"},"figref":["FIG. 3","FIG. 2"],"b":["214","106","214","302","304","302","110","302"]},"Each region definition  identifies a region that can be associated with a set of client devices. In the described implementation, each client device  is assigned a region identifier when the client device is provisioned by a broadcast provider. The client device region identifier corresponds to a region definition  maintained by configuration repository . A region may be defined based on a geographic region, or may be based on any other parameters. For example, a first cable company may acquire a second cable company that services client devices within the same geographical region, but because the client devices were originally serviced by different cable companies, they may be associated with different region identifiers. In an alternate implementation, a region may be based on a channel lineup that is available to a group of client devices.","Configuration repository  also stores region\/configuration mappings  that define which of the defined configurations  are available to client devices associated with each of the defined regions . In an exemplary implementation, each defined configuration is identified by a configuration ID and each defined region is identified by a region ID. In such an implementation, region\/configuration mappings  are defined in terms of region ID\/configuration ID pairs.","Exemplary Configuration Definition Structure",{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 4","b":["302","402","404","402","406","408","406","410","406"]},"Table 1 illustrates the structure of an exemplary configurations table .",{"@attributes":{"id":"p-0069","num":"0068"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["FIELD NAME","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Configuration","Unique identifier used to identify each particular"]},{"entry":["ID","configuration."]},{"entry":["Configuration","Descriptive name of the configuration. This name"]},{"entry":["Name","can be displayed to viewers in a menu of available"]},{"entry":[{},"configurations. Examples may include, English,"]},{"entry":[{},"Espan\u00f5l, Deutsch, Child Appropriate,"]},{"entry":[{},"Seattle Mariners, Baseball Child, etc."]},{"entry":["Culture","Indicates a language associated with the configuration."]},{"entry":["Name","In one implementation, International Organization for"]},{"entry":[{},"Standardization (ISO) language codes are used."]},{"entry":[{},"Examples may include en-US, es-MX, etc. In the"]},{"entry":[{},"described implementation, each culture name value maps"]},{"entry":[{},"to a value in language table 404."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Tags table  records details associated with each defined configuration, and stores one record for each data type that may be associated with a particular configuration. Table 2 illustrates the structure of an exemplary tags table .",{"@attributes":{"id":"p-0071","num":"0070"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["FIELD NAME","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Client","Indicates a type of client device for which the defined"]},{"entry":["Type ID","tag is supported. In the described implementation,"]},{"entry":[{},"each client type ID value maps to a value in client"]},{"entry":[{},"type table 408. Example client type IDs are described"]},{"entry":[{},"below with reference to client type table 408."]},{"entry":["Configuration","The unique identifier of a particular configuration,"]},{"entry":["ID","and indicates which configuration definition the tag is"]},{"entry":[{},"associated with. Each configuration ID value maps to"]},{"entry":[{},"a configuration ID in configurations table 402."]},{"entry":["Tag Value","Specifies a source location associated with a particular"]},{"entry":[{},"data type. In the described implementation, the tag"]},{"entry":[{},"value specifies a directory name in data carousel 120"]},{"entry":[{},"where data of the type specified in this particular"]},{"entry":[{},"record is to be stored and broadcast from."]},{"entry":["Data Type","Specifies a data type that is associated with the"]},{"entry":["Name","specified tag. In the described implementation, each"]},{"entry":[{},"data type name value maps to a value in data types"]},{"entry":[{},"table 410. Example data types are described below"]},{"entry":[{},"with reference to data types table 410."]},{"entry":["Order In","Stores an integer value that specifies a relative"]},{"entry":["Configuration","order of tags associated with the specified"]},{"entry":[{},"configuration."]},{"entry":["Source","Specifies a location in data source 204 where data of"]},{"entry":["Directory","the type specified is stored. For some data types, such"]},{"entry":[{},"as targeted advertisements, a source directory may not"]},{"entry":[{},"be specified, and other mechanisms may be"]},{"entry":[{},"implemented to enable the system to locate the"]},{"entry":[{},"corresponding data."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Client type table  stores data that identifies types of client devices that may be capable of supporting one or more configurations. Table 3 illustrates the structure of an exemplary Client type table .",{"@attributes":{"id":"p-0073","num":"0072"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["FIELD NAME","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Client","Unique identifier used to identify each particular"]},{"entry":["Type ID","type of client device."]},{"entry":["Client","Stores a descriptive name of each identified client"]},{"entry":["Type","device type. In the described implementation, the"]},{"entry":[{},"client type is based on a name and a version"]},{"entry":[{},"associated with a client software application that is"]},{"entry":[{},"implemented on the client device. In one"]},{"entry":[{},"implementation, the client software application is"]},{"entry":[{},"installed on the client device by a cable operator."]},{"entry":[{},"Example client types may include, but are not limited"]},{"entry":[{},"to, BASIC1.0 (name = \u201cBASIC\u201d, version = \u201c1.0\u201d) and"]},{"entry":[{},"IPG1.5 (name = \u201cIPG\u201d, version = \u201c1.5\u201d). A wildcard"]},{"entry":[{},"value (e.g., \u201c*\u201d) may be used to indicate that a"]},{"entry":[{},"particular data tag is supported by all client types."]},{"entry":[{},"In one implementation, a client device first looks for"]},{"entry":[{},"configurations in which the client type value matches"]},{"entry":[{},"both a name and a version associated with the client."]},{"entry":[{},"If none are found, the client then looks for"]},{"entry":[{},"configurations in which the client type value matches"]},{"entry":[{},"the name associated with the client. If none are"]},{"entry":[{},"found, the client then looks for configurations in"]},{"entry":[{},"which the client type value is a wildcard."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Data types table  stores a list of data types that may be associated with one or more configurations. Table 4 illustrates the structure of an exemplary data types table .",{"@attributes":{"id":"p-0075","num":"0074"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["FIELD NAME","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Data Type","Stores the name of a data type that may be associated"]},{"entry":["Name","with one or more configurations. Examples may"]},{"entry":[{},"include bootstrap, language, pages, ad, and so on. A"]},{"entry":[{},"data type may be used to define any logical grouping"]},{"entry":[{},"of data."]},{"entry":["Default","Stores an integer value that indicates a priority to be"]},{"entry":["Priority","associated with the designated data type. A tag type"]},{"entry":[{},"field (described below) indicates whether a particular"]},{"entry":[{},"data type is required or optional. The default priority"]},{"entry":[{},"field may be used to define a priority order of data"]},{"entry":[{},"types within a particular tag type. A client device 110"]},{"entry":[{},"may be implemented to selectively receive broadcast"]},{"entry":[{},"data according to the priority order of data types"]},{"entry":[{},"associated with a selected configuration. In one"]},{"entry":[{},"implementation, a data rate allocated on data carousel"]},{"entry":[{},"120 to a particular data type may be determined based"]},{"entry":[{},"on the default priority value."]},{"entry":["Tag Type","Stores a value that indicates a category associated"]},{"entry":[{},"with the designated data type. Example values"]},{"entry":[{},"include MET (metadata), REQ (required), and OPT"]},{"entry":[{},"(optional). In the described implementation, metadata"]},{"entry":[{},"tags are used to identify descriptive data types,"]},{"entry":[{},"required tags are used to identify required data types,"]},{"entry":[{},"and option tags are used to identify optional data"]},{"entry":[{},"types."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Exemplary Region Definition Structure",{"@attributes":{"id":"p-0077","num":"0076"},"figref":"FIG. 5","b":["304","502","504","504","502"]},"Table 5 illustrates the structure of an exemplary regions table .",{"@attributes":{"id":"p-0079","num":"0078"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["FIELD NAME","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Region ID","Unique identifier used to identify each particular"]},{"entry":[{},"region. In one implementation, the region ID is"]},{"entry":[{},"an integer number between 0 and 65535."]},{"entry":["OM Group","Identifies a group of out-of-band modulators that"]},{"entry":["ID","are configured to send data associated with the"]},{"entry":[{},"specified region. The values in the OM group ID"]},{"entry":[{},"field map to values in the OM groups table 504."]},{"entry":["Listing","Identifies a channel lineup associated with the"]},{"entry":["ID","defined region and matches a listing ID provided"]},{"entry":[{},"by an EPG data provider. For example, an EPG"]},{"entry":[{},"data provider may provide listing data for"]},{"entry":[{},"multiple regions (particularly geographic"]},{"entry":[{},"regions, such as multiple time-zones)."]},{"entry":[{},"Associating a listing identifier with a region"]},{"entry":[{},"definition ensures that a client device"]},{"entry":[{},"associated with the specified region obtains"]},{"entry":[{},"listing data that is appropriate according"]},{"entry":[{},"to the region associated with the client device."]},{"entry":["OOB VCN","Defines a virtual channel number that is"]},{"entry":[{},"associated with OOB network 114."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Table 6 illustrates the structure of an exemplary OM groups table . As described above, an OM group is a group of out-of-band modulators that are implemented to broadcast the same data over multiple frequencies.",{"@attributes":{"id":"p-0081","num":"0080"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 6"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["FIELD NAME","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["OM Group","Unique identifier used to identify particular OM"]},{"entry":["ID","group."]},{"entry":["Name","A unique name assigned to an OM group."]},{"entry":["Data Rate","The total data rate that is available on OOB network"]},{"entry":[{},"114 for broadcasting data. In one implementation,"]},{"entry":[{},"the total available data rate may be divided among"]},{"entry":[{},"data based on the priorities assigned to each data"]},{"entry":[{},"type. (Default Priority is described above with"]},{"entry":[{},"reference to Table 4.)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Exemplary Region Configuration File Format","As described above with reference to , region configuration file generator  of configuration management system  generates a formatted region configuration file for each region defined in configuration repository . Each formatted region configuration file specifies a file directory structure to be implemented in data carousel  for each configuration associated with the defined region. In one implementation, the region configuration file is formatted as an XML file. Other formats that may be used for a region configuration file may include, but are not limited to, a custom flat file format. In one implementation, each generated region configuration file is named as xxxx.rgncfg where xxxx is a four byte hexadecimal representation of an integer region ID associated with the region, prepended with zeros, as necessary. In the described implementation, each xxxx.rgncfg file is stored in a \\regionconfig directory in data carousel .",{"@attributes":{"id":"p-0084","num":"0083"},"figref":"FIG. 6","b":["218","600","602","602","304"]},"One or more configuration entries (), (), . . . , (N) are associated with each region entry . Each configuration entry  corresponds to a particular configuration definition . Furthermore, in region\/configuration mappings , each configuration definition  that corresponds to a configuration entry  is mapped to the region definition  that corresponds to region entry .","Data tags based on data stored in the tags table  are then associated with each configuration entry . For example, metadata tags (), required data tags () and optional data tags () are associated with configuration entry (); metadata tags (), required data tags () and optional data tags () are associated with configuration entry (); and metadata tags (N), required data tags (N) and optional data tags (N) are associated with configuration entry (N). The order of the tag entries associated with each configuration entry is determined based on the order in configuration field in tags table . The order of the tags may also determine the order in which a client device  the data associated with a particular configuration.","Metadata tags  are used to specify information about each particular configuration. In the described implementation, metadata includes an ID and a description. The ID metadata value is stored in the tag value field of a record in tags table  in which the data type field value is ID. In one implementation, the ID metadata is a decimal unsigned integer between 0 and 65535, and is the same as the configuration ID field value in the configurations table. This implementation allows a client device to conveniently store a default configuration ID so that a viewer does not have to select a configuration every time the client device is powered on. When the client device is powered off and then back on, the last selected configuration is displayed (based on the configuration ID stored in memory) until a viewer selects a different configuration. Storing a configuration identifier on the client device is also an improvement over implementations that may instead store an index that indicates the position of a selected configuration in the region configuration file. For example, a client device may receive a region configuration file that lists English, Spanish, and German, in that order, as the available configurations. If the viewer selects Spanish, the client device may store an index value of \u201c2\u201d, indicating that the viewer selected the 2available configuration. If the region configuration file is later modified to contain English, French, and Spanish, in that order, then the next time the client device is powered on, the French configuration will automatically be selected because it is now the 2available configuration. Accordingly, storing an identifier, rather than just an index, associated with a selected configuration ensures consistent configuration selection even if the region configuration file structure changes.","In one implementation, if a configuration ID is not stored in memory (e.g., a viewer has never selected a specific configuration), the client device automatically selects the first configuration listed in the region configuration file.","The description metadata represents a string that can be presented to the viewer in a menu of available configurations. The value of the description metadata corresponds to the value of the configuration name field in configurations table .","Required tags  are used to specify data that is central to the operation of a client device, and may vary according to client device type. In the described implementation, required data types include:\n\n","Bootstrap data is that data which is necessary to support displays associated with basic client device functions such as channel browsing, volume display, unlocking of locked programs, and so on.","Bootstrap_language data contains resource files and language fonts used in conjunction with the bootstrap data described above.","Pages data includes a base set of display files that the client uses, containing such things as fonts, page descriptor files, bitmaps, style descriptor files, and so on. Pages data may also contain script files, which may be executed at load time to set environment variables, customizable strings, and so on. In one implementation, individual files may be concatenated into carousel blobs, which carry the extension \u201c.blb\u201d.","Language data contains statically displayed strings, which provide a consistent page display layout across configurations. In one example, different strings may be loaded to display different languages. Language data may also contain layout overrides to be used, for example, when a string's translation into another language is too large to fit into the standard layout, necessitating an override layout.","By dividing data among the bootstrap, bootstrap_language, pages, and language data types, two important data divisions are made. First, taken together, the data of types bootstrap and bootstrap language make up the minimal set of data necessary to provide basic functionality of a client device. Taken together, the pages and language data types, make up the additional data that may be displayed in association with other functionality of the client device. Second, the bootstrap and pages data types both contain layout data, while the bootstrap_language and language data types both contain specific text data that can be displayed using the layouts described by the data in the bootstrap and pages data types. If several different language configurations are made available to a client device, it is likely that the layout data may be the same, and only the actual text differs between the different configurations. Accordingly, only one set of layout data needs to be broadcast while several sets of text data needs to be broadcast. In other words, the same bootstrap and\/or pages data may be associated with multiple configurations, each having different bootstrap_language and language data. Furthermore, the layout data is typically more complex than the text data, so being able to send only one set of layout data to support multiple configurations can save a considerable amount of bandwidth.","In some situations, layout data may differ slightly across different configurations, for example in a situation where a particular word or phrase in one language is significantly longer than in other languages, necessitating a larger button or text frame for the one language. To support such a situation while minimizing the amount of data that is broadcast, override layout data may be included in an appropriate text datatype associated with a particular configuration. For example, as the client receives data, the bootstrap data is received first (which includes layout data), followed by the bootstrap_language data (which includes text that applies to the layouts defined by the bootstrap data). Accordingly, any layout data received in the bootstrap_language data overrides any layout data first received in the bootstrap data. Similarly, override layout information can be included in the language or config data type to override layout information specified in the pages data type. As received data that is maintained by the client is re-synchronized with data that is currently being broadcast, the updated broadcast data is acquired in the order specified in the region configuration file. However, when an application (e.g., a user interface) requests a particular broadcast data file, the client searches locations associated with the data types defined in the selected configuration definition in reverse order, so as to encounter an override file before encountering the standard file, in an instance where the requested file exists in both a standard location (e.g., layout data in the bootstrap data type location) and in an override location (e.g., layout data in the bootstrap_languages data type location).","Ad data consists of a collection of advertisements. In addition, it may also contain an ad digest file, depending on the client device type. An ad digest file lists the advertisements that are currently available for broadcast and data that indicates when particular advertisements should be displayed. The ad digest file typically includes a title, bitmap name, and click-through data associated with each available advertisement. The ad digest file may be used, for example, to implement targeted advertisement based on viewer interests. In one implementation, an ad digest for a client device of type IPG1.5 is contained in a file named \u201cmetadata.ads\u201d. An ad digest for a client device of type BASIC1.0 is contained in a file called \u201cAdDigest.gz\u201d, which is a compressed XML file.","Config data potentially contains anything that can be in the pages data type, and indicates small tweaks to the overall pages directory. For example, config data may include an override bitmap to be loaded for display in place of a default bitmap on a menu page. A local helpdesk number is another example of data that may be included using config data.","Lcl_epg_base data includes basic EPG data. In one implementation, lcl_epg_base contains two directories, data00 and data01, while data00 contains detailed EPG data for the current time slice. Data01 contains less detailed EPG data for the next time slice. In one implementation, a time slice is defined as a 12 hour period, but it is recognized that any segment of time may be implemented as a time slice. Files stored in the data00 and data01 directories are in a format that is understood by an EPG application implemented in the client device. The contents of both of these directories are preferably small enough for any client device type assigned to this region to store. In one implementation, the sizes of the data00 and data01 directories are configurable.","The appdisc data type can be used to communicate an application and services catalog. The application and services catalog contains information that describes additional applications and services that may be available for a client device to download. In the described implementation, the appdisc data type can be targeted for specific client types based, for example on name\/version, name, or \u201c*\u201d (to indicate applicability to all client types). (Client type is described above with reference to Table 3.)","In one implementation, required data types may also be further grouped according to how the different data types are related. For example, the bootstrap and bootstrap_language data types may be grouped together and the pages and language data types may be grouped together. As a client receives data, no data of a particular data type will be displayed until all of the data in the same group is also successfully received. For example, if a client receives bootstrap data, but does not receive bootstrap language data, then page layouts may be displayed, but they would have no text, and would thus be useless. By grouping related data types, the client is ensured of receiving all necessary data before attempting to display any of the received data. In one implementation, data type groups may be defined in terms of how the data types are named. For example, all data types that begin with \u201cbootstrap\u201d may be considered one group. In an alternate implementation, a group ID field may be added to tags table  and to each entry in the region configuration file, identifying which group each data type belongs to.","Optional tags  are used to specify data that can be optionally downloaded by a client device as resources allow. In the described implementation, optional data includes extended EPG listing data (data type lcl_epg_ext), which contains some number of subdirectories, numbered data02-dataYY, where YY is the highest numbered directory, formatted as a two-digit decimal number. Client devices with sufficient memory available may selectively receive data from these directories after receiving all other types of data on startup, and\/or when a change in guide data is detected. Each higher-numbered directory contains EPG data associated with a later time slice. The client device continues reading data from subsequent directories until the client device reaches a specified memory limit or has read all of the directories.","An example region configuration file may be formatted as follows:",{"@attributes":{"id":"p-0104","num":"0112"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<rgn>"},{"entry":"\u2003<cfg>"},{"entry":"\u2003\u2003<met name=\u201cid\u201d ver=\u201c*\u201d val=\u201c1\u201d\/>"},{"entry":"\u2003\u2003<met name=\u201cdescription\u201d ver=\u201c*\u201d val=\u201cEnglish\u201d\/>"},{"entry":"\u2003\u2003<req name=\u201cbootstrap\u201d ver=\u201cIPG\u201d val=\u201cipg_en_bootstrap\u201d\/>"},{"entry":"\u2003\u2003<req name=\u201cbootstrap\u201d ver=\u201cBasic\u201d val=\u201cbasic_en_bootstrap\u201d\/>"},{"entry":"\u2003\u2003<req name=\u201cbootstrap_language\u201d ver=\u201c*\u201d"},{"entry":"\u2003\u2003val=\u201cbootstrap_en_US\u201d\/>"},{"entry":"\u2003\u2003<req name=\u201cpages\u201d ver=\u201cIPG\u201d val=\u201cipg_en_pages\u201d\/>"},{"entry":"\u2003\u2003<req name=\u201cpages\u201d ver=\u201cBasic\u201d val=\u201cbasic_en_pages\/>"},{"entry":"\u2003\u2003<req name=\u201cconfig\u201d ver=\u201cIPG\u201d val=\u201cipg_en_contig\u201d\/>"},{"entry":"\u2003\u2003<req name=\u201cconfig\u201d ver=\u201cBasic\u201d val=\u201cbasic_en_config\u201d\/>"},{"entry":"\u2003\u2003<req name=\u201clanguage\u201d ver=\u201c*\u201d val=\u201cen_US\u201d\/>"},{"entry":"\u2003\u2003<req name=\u201clcl_epg_base\u201d ver=\u201c*\u201d val=\u201cenglish_baseguide\u201d\/>"},{"entry":"\u2003\u2003<req name=\u201cad\u201d ver=\u201cIPG\u201d val=\u201cipg_en_ads\u201d\/>"},{"entry":"\u2003\u2003<req name=\u201cad\u201d ver=\u201cBasic\u201d val=\u201cbasic_en_ads\u201d\/>"},{"entry":"\u2003\u2003<req name=\u201cappdisc\u201d ver=\u201cBasic\u201d val=\u201cbasic_appdisc\u201d\/>"},{"entry":"\u2003\u2003<opt name=\u201clcl_epg_ext\u201d ver=\u201c*\u201d val=\u201cenglish_extguide\u201d\/>"},{"entry":"\u2003<\/cfg>"},{"entry":"\u2003<cfg>"},{"entry":"\u2003\u2003<met name=\u201cid\u201d ver=\u201c*\u201d val=\u201c2\u201d\/>"},{"entry":"\u2003\u2003<met name=\u201cdescription\u201d ver=\u201c*\u201d val=\u201cEspan\u00f5l\u201d\/>"},{"entry":"\u2003\u2003<req name=\u201cbootstrap\u201d ver=\u201cIPG\u201d val=\u201cipg_es_bootstrap\u201d\/>"},{"entry":"\u2003\u2003<req name=\u201cbootstrap\u201d ver=\u201cBasic\u201d val=\u201cbasic_es_bootstrap\u201d\/>"},{"entry":"\u2003\u2003<req name=\u201cbootstrap_language\u201d ver=\u201c*\u201d"},{"entry":"\u2003\u2003val=\u201cbootstrap_sp-MX\u201d\/>"},{"entry":"\u2003\u2003<req name=\u201cpages\u201d ver=\u201cIPG\u201d val=\u201cipg_es_pages\u201d\/>"},{"entry":"\u2003\u2003<req name=\u201cpages\u201d ver=\u201cBasic\u201d val=\u201cbasic_es_pages\u201d\/>"},{"entry":"\u2003\u2003<req name=\u201cconfig\u201d ver=\u201cIPG\u201d val=\u201cipg_es_config\u201d\/>"},{"entry":"\u2003\u2003<req name=\u201cconfig\u201d ver=\u201cBasic\u201d val=\u201cbasic_es_config\u201d\/>"},{"entry":"\u2003\u2003<req name=\u201clanguage\u201d ver=\u201c*\u201d val=\u201csp-MX\u201d\/>"},{"entry":"\u2003\u2003<req name=\u201clcl_epg_base\u201d ver=\u201c*\u201d val=\u201cspanish_baseguide\u201d\/>"},{"entry":"\u2003\u2003<req name=\u201cad\u201d ver=\u201cIPG\u201d val=\u201cipq_sp_ads\u201d\/>"},{"entry":"\u2003\u2003<req name=\u201cad\u201d ver=\u201cBasic\u201d val=\u201cbasic_sp_ads\u201d\/>"},{"entry":"\u2003\u2003<req name=\u201cappdisc\u201d ver=\u201cBasic\u201d val=\u201cbasic_appdisc\u201d\/>"},{"entry":"\u2003\u2003<opt name=\u201clcl_epg_ext\u201d ver=\u201c*\u201d val=\u201cSpanish_extguide\u201d\/>"},{"entry":"\u2003<\/cfg>"},{"entry":"<\/rgn>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The <rgn> tag indicates the beginning of a region definition, and the <\/rgn> tag indicates the end of a region definition. Each <cfg> and <\/cfg> tag pair indicates the beginning and end of a configuration definition.","Each tag between a <cfg> and <\/cfg> tag pair corresponds to a record in the tags table  and has the following format:","<tag type name=\u201cdata type name\u201d ver=\u201cclient type\u201d val=\u201ctag value\u201d> where \u201ctag type\u201d is the tag type field value of the corresponding record in data types table ; \u201cdata type name\u201d is the data type name field value of the corresponding record in tags table ; \u201cclient type\u201d is the client type field value of the corresponding record in client type table ; and \u201ctag value\u201d is the tag value field value of the corresponding record in tags table . The order of the tag entries between a <cfg> and <\/cfg> tag pair may be determined based on the values of the order in configuration fields of each tag record in tags table .","In the described implementation, each data type and value specified in the region configuration file corresponds to a directory in the data carousel . Accordingly, the example region configuration file shown and described above assumes the following directory structure on data carousel :",{"@attributes":{"id":"p-0109","num":"0117"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/"]},{"entry":[{},"\u2003regionconfig"]},{"entry":[{},"\u2003bootstrap"]},{"entry":[{},"\u2003\u2003ipg_en_bootstrap"]},{"entry":[{},"\u2003\u2003basic_en_bootstrap"]},{"entry":[{},"\u2003\u2003ipg_es_bootstap"]},{"entry":[{},"\u2003bootstrap_language"]},{"entry":[{},"\u2003\u2003bootstrap_en-US"]},{"entry":[{},"\u2003\u2003bootstrap_sp-MX"]},{"entry":[{},"\u2003pages"]},{"entry":[{},"\u2003\u2003ipg_en_pages"]},{"entry":[{},"\u2003\u2003basic_en_pages"]},{"entry":[{},"\u2003\u2003ipg_es_pages"]},{"entry":[{},"\u2003config"]},{"entry":[{},"\u2003\u2003ipg_en_config"]},{"entry":[{},"\u2003\u2003basic_en_config"]},{"entry":[{},"\u2003\u2003ipg_es_config"]},{"entry":[{},"\u2003language"]},{"entry":[{},"\u2003\u2003en-US"]},{"entry":[{},"\u2003\u2003sp-MX"]},{"entry":[{},"\u2003appdisc"]},{"entry":[{},"\u2003\u2003basic_appdisc"]},{"entry":[{},"\u2003ad"]},{"entry":[{},"\u2003\u2003ipg_en_ads"]},{"entry":[{},"\u2003\u2003basic_en_ads"]},{"entry":[{},"\u2003\u2003ipg_sp_ads"]},{"entry":[{},"\u2003\u2003basic_sp_ads"]},{"entry":[{},"\u2003lcl_epg_bas"]},{"entry":[{},"\u2003\u2003english_baseguide"]},{"entry":[{},"\u2003\u2003spanish_baseguide"]},{"entry":[{},"\u2003lcl_epg_ext"]},{"entry":[{},"\u2003\u2003english_extguide"]},{"entry":[{},"\u2003\u2003spanish_extguide"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Method for Enabling Broadcast of Multiple Data Configurations","As described above, broadcast data server  maintains multiple data configuration definitions and provides those definitions to headend system  for broadcast to multiple client devices . Each client device  is associated with a region, and broadcast data server  maintains mappings of the configuration definitions to the regions, so that client devices associated with different regions may have access to different combinations of data configurations.","Enabling broadcast of multiple data configurations as performed by broadcast data server  may be described in the general context of computer-executable instructions, such as application modules, being executed by a computer. Generally, application modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. A broadcast data server that enables a headend to broadcast multiple data configurations may be implemented using any number of programming techniques and may be implemented in local computing environments or in distributed computing environments where tasks are performed by remote processing devices that are linked through various communications networks based on any number of communication protocols. In such a distributed computing environment, application modules may be located in both local and remote computer storage media including memory storage devices.",{"@attributes":{"id":"p-0113","num":"0121"},"figref":["FIG. 7","FIG. 7","FIGS. 1 and 2"],"b":"700"},"At block , broadcast data server  receives and stores broadcast data. For example, data collectors  gather data from data providers  and store the data in data cache . The gathered data may include, but is not limited to, advertisements, VOD data, and EPG data.","At block , broadcast data server  receives and stores one or more configuration definitions. In the described implementation, configuration definitions are submitted by a system administrator through configuration interface  and stored in configuration repository .","At block , broadcast data server  receives and stores one or more region definitions. In the described implementation, region definitions are submitted by headend  through configuration interface  or through an initialization process that establishes a relationship between broadcast data server  and headend . The region definitions are stored in configuration repository .","At block , broadcast data server  receives region\/configuration mappings and stores the mappings in configuration repository . At block , region configuration file generator  generates a region configuration file for each region definition stored in configuration repository . In the described implementation, each region configuration file identifies one or more configurations associated with a region and includes formatted XML tags that indicate data carousel  directories from which data associated with each configuration can be downloaded. The region configuration files are written to a directory location on data carousel  where they can be downloaded by client devices .","At block , data configuration module  copies the data that was received from data providers  and stored in data cache  into directories on data carousel , based on the defined data configurations stored in configuration repository .","Although illustrated sequentially, the operations shown in  do not necessarily execute in the order shown. For example, configuration definitions, region definitions, and region\/configuration mappings may be established first, followed by numerous iterations of gathering data and copying data to the data carousel.","Exemplary Client Device",{"@attributes":{"id":"p-0121","num":"0129"},"figref":["FIG. 8","FIG. 1"],"b":["110","110","802","114","120","802"]},"Client device  also includes one or more processors  that process various instructions to control the operation of client device  and to communicate with other electronic and computing devices. Client device  can be implemented with one or more computer-readable memory components, examples of which include a random access memory (RAM) , a disk drive , a mass storage component , and a non-volatile memory  (e.g., ROM, Flash, EPROM, EEPROM, etc.). The memory components (e.g., RAM , disk drive , storage media , and non-volatile memory ) store various information and\/or data such as received content, EPG data, configuration information for client device , and\/or graphical user interface information. Non-volatile memory  is also configured to maintain an identifier associated with the last selected configuration definition so that the same configuration can be selected if the client device  is powered off and back on again.","Alternative implementations of client device  can include a range of processing and memory capabilities, and may include more or fewer types of memory components than those illustrated in . For example, full-resource clients can be implemented with substantial memory and processing resources, including the disk drive  to store content for replay by the viewer. Low-resource clients, however, may have limited processing and memory capabilities, such as a limited amount of RAM , no disk drive , and limited processing capabilities of processor .","An operating system  and one or more application programs  may be stored in non-volatile memory  and executed on processor  to provide a runtime environment. A runtime environment facilitates extensibility of client device  by allowing various interfaces to be defined that, in turn, allow application programs  to interact with client device .","One-way broadcast carousel file system (BCFS)  is configured to interact with OOB network  to synchronize data maintained by client device  with data that is being broadcast over OOB network . As illustrated, BCFS  is implemented as a software application that is stored in non-volatile memory  and executed on processor . Alternatively, (BCFS)  may also be implemented as one or more hardware components or as part of operating system . In each particular implementation, BCFS  is associated with (or is at least configured according to) the particular data carousel  from which the client device  receives broadcast data.","BCFS  is typically configured to perform a seek directory operation, a seek file operation, a sync directory operation, and a sync file operation. Alternatively, BCFS  may be configured to perform more basic operations, and the operations listed above are available through an interface to BCFS  implemented, for example, as part of operating system .","The seek directory operation is called (with a directory as a parameter) to determine whether data associated with a particular local directory is synchronized with data being broadcast over OOB network  from a directory of the same name on data carousel . The seek directory operation returns an indicator of whether or not the specified local directory is synchronized with the directory being broadcast and a size of the data that is being broadcast from the specified directory (e.g., in bytes).","The seek file operation is called (with a file name as a parameter) to determine whether a locally maintained copy of the particular file is synchronized with the same file being broadcast over OOB network . The seek file operation returns an indicator of whether or not the specified file is being broadcast, an indicator of whether or not the locally maintained version of the file matches a copy of the file that is currently being broadcast, and a file size associated with the file that is being broadcast (e.g., in bytes).","The sync directory operation is called (with a directory as a parameter) to synchronize data associated with a particular local directory with data being broadcast over OOB network  from a directory of the same name on data carousel . The sync directory operation deletes any local data in the specified directory, and acquires the data that is being broadcast from the specified directory.","The sync file operation is called (with a file name as a parameter) to acquire a file of the specified name that is currently being broadcast over OOB network .","In the illustrated example client device , an EPG application  is also stored in memory  to operate on received EPG data and generate a program guide. The application programs  that may be implemented at client device  can include a browser to browse the Web (e.g., \u201cWorld Wide Web\u201d), an email program to facilitate electronic mail, and so on. A user interface component  is also stored in memory  and executed on processor  to provide user interaction with the client device.","Client device  also includes data configuration module  stored in memory  and executed on processor . Data configuration module  includes a client object  and multiple task objects . Client object  is responsible for obtaining the appropriate region configuration file, scheduling the order in which task objects  should be serviced and revisited, making available the details of the selected configuration to task objects  and to user interface  (and possibly application programs  and\/or EPG application ), and verifying over time that the region configuration file has not changed. Each task object  is responsible for obtaining data for a particular data type associated with a selected configuration by issuing asynchronous commands to BCFS  to obtain the data. In the described implementation, client object  and task objects  are implemented as state machines, and are each discussed in further detail below. It is also recognized that a data configuration module may be implemented in any number of ways to provide similar functionality, and the described implementation is merely one example of such a data configuration module.","Client device  may be implemented to include other components pertaining to a television entertainment system which are not illustrated in this example. For instance, client device  can include user interface lights, buttons, controls, and the like to facilitate additional viewer interaction with the device.","Illustrated client device  also includes a decoder  to decode a broadcast video signal, such as an NTSC, PAL, SECAM or other TV system video signal. Client device  may also include any combination of a wireless interface , a network interface , a serial and\/or parallel interface , and a modem . Wireless interface  allows client device  to receive input commands and other information from a user-operated input device, such as from a remote control device or from another IR, Bluetooth, or similar RF input device.","Network interface  and serial and\/or parallel interface  allow client device  to interact and communicate with other electronic and computing devices via various communication links. Although not shown, client device  may also include other types of data communication interfaces to communicate with other devices. Modem  facilitates client device  communication with other electronic and computing devices via a conventional telephone line.","Client device  also includes an audio output  and a video output  that provide signals to a television or other device that can process, present, or otherwise render audio and video data. Although shown separately, some of the components of client device  may be implemented in an application specific integrated circuit (ASIC). Additionally, a system bus (not shown) typically connects the various components within client device . A system bus can be implemented as one or more of any of several types of bus structures, including a memory bus or memory controller, a peripheral bus, an accelerated graphics port, or a local bus using any of a variety of bus architectures. By way of example, such architectures can include an Industry Standard Architecture (ISA) bus, a Micro Channel Architecture (MCA) bus, an Enhanced ISA (EISA) bus, a Video Electronics Standards Association (VESA) local bus, and a Peripheral Component Interconnects (PCI) bus also known as a Mezzanine bus.","Method for Enabling Viewer Selection of a Data Configuration","As described above, client device  receives broadcast programs and associated broadcast data from headend . In addition, client device  receives a broadcast region configuration file that indicates one or more data configurations that are available to the client device based on a region identifier. Client device  is configured to present a list of available data configurations to a viewer through a user interface, and selectively receive the broadcast data according to a viewer-selected data configuration.","Enabling viewer selection of a data configuration as performed by client device  may be described in the general context of computer-executable instructions, such as application modules, being executed by a computer. Generally, application modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. A client device that is configured to selectively receive broadcast data according to any one of multiple data configurations may be implemented using any number of programming techniques and may be implemented in local computing environments or in distributed computing environments where tasks are performed by remote processing devices that are linked through various communications networks based on any number of communication protocols. In such a distributed computing environment, application modules may be located in both local and remote computer storage media including memory storage devices.",{"@attributes":{"id":"p-0140","num":"0148"},"figref":["FIG. 9","FIG. 9","FIGS. 1"],"b":["900","2","8"]},"At block , client device  acquires a region configuration file that is appropriate for the particular client device. For example, in one implementation, each region configuration file is named based on a region identifier that is also associated with multiple client devices. When headend  broadcasts the region configuration files, each particular client device acquires the region configuration file whose name is based on a region identifier associated with the client device. As described above, the region identifier associated with the client device may be assigned in any number of ways, including when the client device is manufactured, or by a cable provider during a client device setup process.","At block , client device  selects a configuration from the received region configuration file. The configuration may be selected based on a previously selected configuration or a default configuration (e.g., the first configuration listed in the region configuration file) may be selected. An exemplary method for selecting an initial configuration is described in more detail below with reference to .","At block , client device  begins selectively receiving data being broadcast from data carousel  according to the initially selected configuration definition in the region configuration file. Client device  acquires data that is broadcast from file directories on data carousel  in the order specified in the region configuration file.","At block , client device  displays a list of available data configurations that are available, based on the received region configuration file. For example, in response to a viewer request, user interface  displays a list of values from the region configuration file that correspond to the configuration name field in the configurations table in configuration repository .","At block , client device  receives (through user interface ) a viewer selection of a configuration. An exemplary method for switching to a viewer-selected configuration is described below with reference to .","At block , client device  selectively receives data being broadcast from data carousel  according to the viewer-selected configuration definition in the region configuration file. Client device  acquires data that is broadcast from file directories on data carousel  in the order specified in the region configuration file. The acquired data provides client device  with a sufficient data set for displaying data according to the selected configuration.","Client device  operation may continue at block , as described above, in an event that another viewer request to select a configuration is received.","Client device  operation may continue at block , as described above, in an event that the region identifier associated with client device  changes or in an even that the broadcast region configuration file that is appropriate for client device  is modified.","Exemplary Client Object Implementation",{"@attributes":{"id":"p-0150","num":"0158"},"figref":"FIG. 10","b":["824","824","826","110","826","820","816","818","824"]},"Client object  includes states , task list , operations , application programming interface (API) functions , a task idle timer , and a region idle timer . Client object  transitions between states  according to functions that it performs. Client object  state transition is described in more detail below, with reference to .","Task list  is an ordered list of task objects  maintained by client object  to facilitate execution of functions associated with task objects  based on the order of the task objects in task list . The order of the task objects in task list  is based on a next activity time property of each task object , which is described in more detail below with reference to .","Operations  is a basic set of operations that allow client object  to navigate between task objects  and perform operations associated therewith. Operations  may include, but are not limited to, select configuration , prepare task list , get first task , and invalidate all . Select configuration  is executed by client object  to determine a default or previously selected configuration. An exemplary select configuration operation  is described in more detail below with reference to .","Prepare task list  is executed by client object  to initialize task list . An exemplary prepare task list operation  is described in more detail below with reference to .","Get first task  is executed by client object  to determine the next task to be executed. An exemplary get first task operation  is described in more detail below with reference to .","Invalidate all  is executed by client object  to invalidate each task object in task list  when either the client device region identifier changes (e.g., a new region identifier is received from the headend) or when current region configuration file changes. An exemplary invalidate all operation  is described in more detail below with reference to .","Application programming interface (API) functions  may be called from outside of client object . Select API calls  may include, but are not limited to add task , choose configuration , find specific file , and find file in default path .","A call to add task  causes client object  to create a new task object invalidate each task object . An exemplary add task function  is described in more detail below with reference to .","A call to choose configuration  causes client object  to update task list  upon viewer selection of an available configuration. An exemplary choose configuration function  is described in more detail below with reference to .","A call to find specific file  causes client object  to locate a specified file associated with a specified data type. An exemplary find specific file function  is described in more detail below with reference to .","A call to find file in default path  causes client object  to locate a specified file by searching in reverse order through the data types associated with the currently selected configuration. An exemplary find file in default path function  is described in more detail below with reference to .","Task idle timer  is used by client object  to determine when to execute a task object . Task idle timer  is reset according to the current state and what tasks are currently being executed. The use of task idle timer  is described in more detail below with reference to task execution.","Region idle timer  is used by client object  to determine when to verify that the current region configuration file is still synchronized with the current broadcast region configuration file and when to check the client device region identifier to determine whether or not it has changed.","Exemplary Task Object Implementation",{"@attributes":{"id":"p-0165","num":"0173"},"figref":"FIG. 11","b":["826","826","815","826","1102","1104","1106"]},"Properties  are the components that define a particular task object . Properties  may include, but are not limited to:\n\n","The user task flag property indicates whether or not the task object is a user task (described below with reference to ). The data type property stores the name of the data type with which the task object is associated. The files to synchronize property specifies a set of files associated with the specified data type that are to be selectively received using the defined task object. The re-check interval property specifies a how often the data should be checked for change. The next activity time property is used to indicate intervals at which operations associated with a task object are to be executed. The handler function property stores a pointer to a handler function associated with task object . The handler function argument property stores an argument to be passed to the handler function when it is called. The data size limit property specifies the maximum data size to be held for the specified data type. The in default path flag property indicates whether or not data associated with the specified data type is to be included in a search that is initiated by an API call to the find file in default path function . The subdirs flag property is used to indicate that the location from which data of the specified data type is broadcast includes subdirectories. The files flag property is used to indicate that the location from which data of the specified data type is broadcast includes files. (The subdirs flag property and the files flag property are mutually exclusive.) The last synced data type location stores the value from the tag in the region configuration file that specifies the location from which data associated with the task object is broadcast. The last synced data type location value is used to determine whether or not a data type needs to be re-synchronized when a new configuration is selected. The directory index property stores an integer that indicates which subdirectory is currently being operated on. The directory count property stores an integer that indicates the number of directories that have currently been synchronized. Use of the directory index and directory count properties is described in more detail below with reference to .","States  represent multiple states that task object  (implemented as a state machine) may be in at a given time. Each task object  transitions between states  according to functions that it performs. Task object state transition is described in more detail below, with reference to .","Operations  represent operations that may be performed by or in reference to a particular task object . Operations  may include, but are not limited to, reset , shelve , check invalidate , and default dir list maintenance .","Reset operation  is performed when the state of a task object changes and data acquisition for the data type associated with the task is to be restarted from the beginning. An exemplary reset operation  is described in more detail below with reference to .","Shelve operation  is performed when a task has been created by a user (i.e., a user task), but is not used by the currently selected configuration. An exemplary shelve operation  is described in more detail below with reference to .","Check invalidate operation  is performed to clear from task list , a task object  that is not associated with a newly selected configuration. An exemplary check invalidate operation  is described in more detail below with reference to .","Default directory list maintenance operation  is performed when a new directory in the default path is synchronized or has its contents deleted. For example, when a task object is synchronized, task object  may check to see if the data type associated with the task belongs to a data type group. If so, a list of which data type groups are available may be updated (based on whether or not all of the data types in the group are synchronized). If all of the data associated with a particular data type group is found to be synchronized, then a set of initialization operations may be performed to prepare the data to be accessed. For example, a script file received in association with a particular data type may be executed during the initialization. Such script files may be used to, for example, enable a set of fonts. Another example initialization that may be performed is the generation of an ordered list of resource files. Resource files that are received may contain specific text strings to be displayed according to a defined layout. In one implementation, the list of resource files is ordered based on the order of data types specified in the region configuration file. When a string value is requested, the resource files can be searched in reverse order to ensure that the last received data is searched first. (This allows data types specified later in the configuration definition to contain data that overrides data associated with a data type listed earlier in the configuration definition.)","Exemplary Client Object State Transition",{"@attributes":{"id":"p-0175","num":"0197"},"figref":["FIG. 12","FIG. 13"],"b":["1002","824","822","824","1202","824","1202","826","824","1202","818"]},"After any user tasks are added, client object  enters getting region config file state . During this state, an appropriate broadcast region configuration file is acquired and a configuration is selected, as described in more detail below with reference to .","After acquiring a region configuration file and selecting a configuration, client object  then enters and remains in main state  until a new region identifier is assigned to client device  or a new region configuration file is detected. While in main state , client object  manages task objects , as described in more detail below with reference to .","Exemplary Client Object Add Task API Function",{"@attributes":{"id":"p-0179","num":"0201"},"figref":"FIG. 13","b":["1022","824","826"]},"In the described implementation, arguments that may be passed to add task method  include:\n\n","The data type value indicates a data type that the task is associated with. This value corresponds to the name entry in a tag that may exist in the region configuration file.","The files to synchronize value specifies a set of files associated with the specified data type that are to be selectively received using the defined task object. In one implementation, a wildcard value (e.g., \u201c*\u201d) can be used to indicate that all files associated with the specified data type are to be synchronized.","The re-check interval value specifies a how often the data should be checked for change. In one implementation, the argument is an integer value that specifies a number of seconds between each data check. A negative value may be used to indicate that the data is only to be checked once, and a positive value may be used to indicate the number of seconds to wait after a successful sync operation before re-checking the data.","The handler function value stores a pointer to another function that is to be associated with the created task object. In an exemplary implementation, handler functions are call-back functions that are used when special data handling is desired. For example, a handler function may be implemented in association with a task object that is responsible for EPG data. The handler function may be responsible for controlling what actions are taken when it is discovered that the local EPG data is not synchronized with the currently broadcast EPG data. Because out-of-date EPG data is useless to a viewer, the handler function may cause the out-of-date EPG data to be deleted regardless of whether or not updated EPG data has been successfully received. Similarly, a handler function may be implemented in association with a task object that is responsible for advertising data. In this scenario, because out-of-date advertisements may still be relevant to a viewer, the handler function may cause out-of-date advertisement data to be maintained until updated data is successfully received.","The handler function argument stores an argument that is to be passed to the specified handler function.","The data size limit value specifies the maximum data size to be held for the specified data type. This argument can be used to ensure that client device memory resources are not consumed with extraneous data.","The in default path flag property indicates whether or not data associated with the specified data type is to be included in a search that is initiated by an API call to the find file in default path function .","The subdirs flag property is used to indicate that the location from which data of the specified data type is broadcast includes subdirectories.","The files flag property is used to indicate that the location from which data of the specified data type is broadcast includes files. (The subdirs flag property and the files flag property are mutually exclusive.)","At block , client object  compares the received data type argument with the task objects  currently in task list  to determine if there is already a task object  for the specified data type. If an existing task object  is found for the specified data type (the \u201cYes\u201d branch from block ), then at block , add task  returns an error. Otherwise (the \u201cNo\u201d branch from block ), add task  continues at block .","At block , client object  creates a new task object  based on the received parameters.","At block , client object  adds the new task object  to task list .","At block , client object  sets the new task object's next activity time property to the current time so that the task will be a candidate for processing the next time that task idle timer  signals.","Exemplary Client Object Getting Region Config File State",{"@attributes":{"id":"p-0195","num":"0226"},"figref":"FIG. 14","b":["1400","824","1204"]},"At block , client object  constructs a region configuration file name based on a region identifier associated with client device . For example, in one implementation, the region identifier associated with a client device is an integer number between 0 and 65535 and region configuration files are named \u201cxxxx.rgncfg\u201d where \u201cxxxx\u201d is a four byte hexadecimal representation of the region identifier, prepended with zeros as needed. Accordingly, in such an implementation, client object  constructs a region configuration file name by converting the region identifier associated with the client device to a four-digit hexadecimal value, appended with the string, \u201c.rgncfg\u201d.","At block , client object  issues a sync file call to BCFS , passing the constructed region configuration file name as a parameter.","At block , client object  determines whether or not the requested region configuration file has been received. If the region configuration file has not been received (the \u201cNo\u201d branch from block ), then client object  re-issues the sync file call at block .","At block , when the region configuration file is successfully acquired (the \u201cYes\u201d branch from block ), client object  selects a configuration that is specified in the received region configuration file by executing select configuration operation  (described in more detail below with reference to ).","At block , client object  sets the client object region idle timer  to a future time (e.g., 10 minutes from the current time).","At block , client object  sets the task idle timer  to the current time so that the first task in task list  will be executed as soon as possible.","At block , client object  enters main state . Operations performed by client object  while in main state  are described in more detail below with reference to .","Exemplary Client Object Select Configuration Operation",{"@attributes":{"id":"p-0204","num":"0235"},"figref":"FIG. 15","b":["1014","824","1014","824","1204"]},"At block , client object  identifies a list of available configurations according to the received region configuration file.","At block , client object  determines whether or not a configuration value, which indicates a previous viewer-selected configuration, is stored in memory. In the described implementation, the client device region identifier and a configuration identifier are stored together as a configuration value when a viewer selects a configuration. In this way, client object  does not attempt to selectively receive data based on an invalid configuration in an event that the region identifier associated with the client device changes or if a previously selected configuration is no longer available. If it is determined that there is no configuration value stored in memory (the \u201cNo\u201d branch from block ), then select configuration  continues at block . Otherwise (the \u201cYes\u201d branch from block ), select configuration  continues at block .","At block , client object  determines whether or not the region identifier stored as part of the stored configuration value matches the region identifier currently associated with the client device. If it is determined that the stored region identifier does not match the current client device region identifier (the \u201cNo\u201d branch from block ), then select configuration  continues at block . Otherwise (the \u201cYes\u201d branch from block ), select configuration  continues at block .","At block , client object  determines whether the stored configuration identifier matches a configuration identifier in the received region configuration file. If it is determined that the stored configuration identifier does not match an available configuration (the \u201cNo\u201d branch from block ), then select configuration  continues at block , described below. Otherwise (the \u201cYes\u201d branch from block ), select configuration  continues at block .","At block , client object  selects as the current configuration, the configuration definition in the received region configuration file that matches the stored configuration identifier.","At block , if it is determined that a valid configuration value is not stored (the \u201cNo\u201d branch from any of blocks , , or ), client object  selects as the current configuration, the first configuration listed in the received region configuration file.","Exemplary Client Object Main State",{"@attributes":{"id":"p-0212","num":"0243"},"figref":"FIGS. 16-19","b":["1600","824","1206"]},"At block , client object  executes prepare task list operation  to initialize task list  according to the currently selected configuration. An exemplary prepare task list operation  is described in more detail below with reference to .","At block , client object  determines whether or not task idle timer  has signaled. If task idle timer  has signaled (the \u201cYes\u201d branch from block ), then main state processing continues at step , described below with reference to .","At block , client object  determines whether or not it has received a response from BCFS . If client object  has received a response from BCFS  (the \u201cYes\u201d branch from block ), then main state processing continues at step , described below with reference to .","At block , client object  determines whether or not region idle timer  has signaled. If region idle timer  has signaled (the \u201cYes\u201d branch from block ), then main state processing continues at step , described below with reference to .","At block , client object  determines whether or not an API call to choose configuration  has been received. If an API call to choose configuration  has been received (the \u201cYes\u201d branch from block ), then main state processing continues at step .","Main state processing continues until one of the above-described conditions is met.","At block , client object  executes choose configuration , as described below with reference to .","At block , client object  re-enters main state .",{"@attributes":{"id":"p-0221","num":"0252"},"figref":"FIG. 17","b":["1700","824","1206","1010"]},"At block , client object  executes get first task operation  to determine the next task object  to call. An exemplary get first task operation  is described in more detail below with reference to .","At block , client object  examines the next activity time property of the first task object  in task list . If the next activity time is equal to or before the current time (the \u201cNo\u201d branch from block ), then at block , client device  sets task idle timer  to signal at a time equal to the next activity time property of the first task object in task list . Main state processing then continues at block .","At block , client object  calls the first task object  in task list , causing the task object to execute.","At block , client object  re-enters main state .",{"@attributes":{"id":"p-0226","num":"0257"},"figref":"FIG. 18","b":["1800","824","1206","815"]},"At block , client object  forwards the received BCFS response to the first task object in task list .","At block , client object  receives a response from the task object.","At block , client object  determines whether the response from the task object indicates that the task is synced. If the task is synced (the \u201cYes\u201d branch from block ), then at block , the task object  is pushed to the end of task list .","At block , client object  determines whether the response from the task object indicates that the task operation executed successfully. If the response indicates success (the \u201cYes\u201d branch from block ), then at block , client object  sets task idle timer  to the current time.","Otherwise, if the response indicates failure (the \u201cNo\u201d branch from block ), then at block , client object  sets task idle timer  to an upcoming future time (e.g., five seconds from the current time).","At block , client object  re-enters main state .",{"@attributes":{"id":"p-0233","num":"0264"},"figref":"FIG. 19","b":["1900","824","1206","1012"]},"At block , client object  determines whether or not the client device region identifier has changed since the current configuration was selected. In one implementation, client object  compares the current client device region identifier to a region identifier portion of a stored configuration value associated with the currently selected configuration. If the client device region identifier has changed (the \u201cYes\u201d branch from block ), main state processing continues at block .","At block , client object  determines whether or not the current region configuration file is synchronized with the region configuration file of the same name that is currently being broadcast. If the region configuration file is not synchronized (the \u201cNo\u201d branch from block ), main state processing continues at block .","At block , client object  sets region idle timer  equal to a future time (e.g., 10 minutes from the current time).","At block , client object  re-enters main state .","If a discrepancy is found with either the client device region identifier (the \u201cYes\u201d branch from block ) or the region configuration file (the \u201cNo\u201d branch from block ), then at block , client object  executes an invalidate all operation  to prevent the task objects currently in task list  from executing. An exemplary invalidate all operation  is described in more detail below with reference to .","At block , client object  enters getting region config file state .","Exemplary Client Object Prepare Task List Operation",{"@attributes":{"id":"p-0241","num":"0272"},"figref":"FIG. 20","b":["1016","824","1016","824","1204","1004"]},"At block , client object  identifies the first non-meta tag associated with the currently selected configuration in the region configuration file.","At block , client object  examines task list  to determine whether or not there exists a task object  associated with the data type indicated by the non-meta tag identified at block . If there is not a matching task in task list  (the \u201cNo\u201d branch from block ), prepare task list  continues at block . Otherwise, if there is a matching task in task list  (the \u201cYes\u201d branch from block ), prepare task list  continues at block , described below.","At block , client object  determines whether or not the tag identified in block  is a required tag. As described above with reference to the example region configuration file, the first entry in a data tag indicates whether the tag specifies metadata (meta), required data (req), or optional data (opt). If it is determined that the identified tag is not required (the \u201cNo\u201d branch from block ), then client object  takes no action, and prepare task list  continues at block , described below.","At block , when it is determined that the identified tag is required (the \u201cYes\u201d branch from block ), client object  creates a non-user task object  and adds the task to the end of task list . A non-user task object may be created by calling the add task API function  with a default set of parameters. In an alternate implementation, input parameters for add task  may be included in the region configuration file, for example, as additional entries in a tag associated with task object . Prepare task list  then continues at block , described below.","At block , when it is determined that a task matching the identified tag already exists in task list , client object  pushes the existing task object to the end of task list . Furthermore, if it is the first task object to be pushed to the end of the task list, client object  also flags the task as the first one pushed to the end of task list .","At block , client object  examines the region configuration file to determine whether or not there are additional non-meta tags associated with the definition of the selected configuration. If there are additional non-meta tags (the \u201cYes\u201d branch from block ), then prepare task list  loops through blocks - until there are no remaining non-meta tags associated with the selected configuration. Prepare task list  then continues at block .","At block , client object  examines task list  to determine whether or not the first task in the list is flagged as the first task pushed to the end of the task list (as described above with reference to block ). If it is determined that the first task in task list  is flagged as the first task pushed (the \u201cYes\u201d branch from block ), then client object  takes no further action, and prepare task list  terminates. On the other hand, if the first task in task list  is not flagged as the first task pushed (the \u201cNo\u201d branch from block ), then prepare task list  continues at block .","At block , client object  examines the first task in task list  to determine whether or not the task is a user task. (User tasks are those task objects created while client object  is in adding tasks state , as described above with reference to .) If the first task in task list  is a user task (the \u201cYes\u201d branch from block ), prepare task list  continues at block . Otherwise (the \u201cNo\u201d branch from block ), prepare task list  continues at block .","At block , client object  shelves the first task in task list . When a task is shelved, the task remains in the task list, but has a next activity time property set to the most future representable date and time to ensure that the task will not execute. An exemplary method for shelving a task is described in more detail below with reference to .","At block , client object  deletes the first task in task list .","Prepare task list  then loops back to block , repeating blocks - until the first task in task list  is the task that was flagged in block  as the first task pushed to the end of task list .","Exemplary Client Object Choose Configuration API Function",{"@attributes":{"id":"p-0254","num":"0285"},"figref":"FIG. 21","b":["1024","824","1024","820","820","1024"]},"At block , client object  performs any application-specific shutdown procedures that may be required to put the client device into a safe mode that does not rely on any data files. For example, the client device may enter a special state that allows a viewer to continue viewing broadcast programs, but does not allow access to any of the additional broadcast data, such as the data needed to perform operations such as pay per view purchasing, channel locking, configuration selection, etc.","At block , client object  stores a configuration identifier associated with the previously selected configuration within the client object. For example, client object  sets a local variable that holds the current configuration identifier. This value will be used to compare the new configuration with the previous configuration to clear out any unnecessary task objects.","At block , client object  calls check invalidate task operation  for each task in task list . Check invalidate  is used to free data that is not associated with the newly selected configuration. An exemplary check invalidate task operation  is described in more detail below with reference to .","At block , client object  executes prepare task list  (as describe above with reference to ) to initialize task list  to correspond with the newly selected configuration.","At block , client object  stores the current client device region identifier and the currently selected configuration identifier as a configuration value in non-volatile memory . As described above, storing the current region identifier and the currently selected configuration identifier allows client device  to reload the last selected configuration on startup, and prevents client device  from attempting to reload a previously selected configuration in an event that the client device region identifier has changed or the previously selected configuration is no longer available.","Exemplary Client Object Get First Task Operation",{"@attributes":{"id":"p-0261","num":"0292"},"figref":"FIG. 22","b":["1018","824","1018","824","1010"]},"At block , client object  identifies the first task in task list .","At block , client object  compares the next activity time property of the first task in task list  with the current time. If the next activity time property is equal to or before the current time (the \u201cYes\u201d branch from block ) then get first task  terminates. Otherwise (the \u201cNo\u201d branch from block ), get first task  continues at block .","At block , client object  stores a task identifier and the next activity time associated with the current task object, identifying it as the task with the earliest next activity time.","At block , client object  determines whether or not there are more tasks in task list . If there are more tasks in task list  (the \u201cYes\u201d branch from block ), then get first task  continues at block . Otherwise (the \u201cNo\u201d branch from block ), at block , get first task  moves the task object  associated with the stored task identifier to the first position in task list , and terminates.","At block , client object  identifies the next task in task list .","At block , client object  compares the next activity time property of the task with the current time. If the next activity time property is equal to or before the current time (the \u201cYes\u201d branch from block ) then get first task  continues at block . Otherwise (the \u201cNo\u201d branch from block , get first task  continues at block .","At block , client object  moves the current task object  to the first position in task list , and get first task  terminates.","At block , client object  compares the next activity time property of the currently selected task with the next activity time property that was stored as described with reference to block . If the next activity time of the current task is before the stored next activity time (the \u201cYes\u201d branch from block ), then get first task  loops back to block . Otherwise (the \u201cNo\u201d branch from block ), get first task  loops back to block , as described above.","Exemplary Client Object Invalidate All Operation",{"@attributes":{"id":"p-0271","num":"0302"},"figref":"FIG. 23","b":["1020","824","1020","824","1206","1020","1004","824","1204"]},"At block , client object  performs any application-specific shutdown procedures that may be required to put the client device into a safe mode. For example, the client device may enter a special state that allows a viewer to continue viewing broadcast programs, but not access any of the additional broadcast data, such as the data needed to perform operations such as pay per view purchasing, channel locking, configuration selection, etc.","At block , client object  calls a reset function associated with each task in task list . For example, client object  loops through task list  and calls task object reset operation  for each task object in task list . An exemplary task object reset operation  is described in further detail below with reference to .","At block , client object  determines whether its current state is getting region config file . If the current state is getting region config file (the \u201cYes\u201d branch from block ), then invalidate all  continues at block . Otherwise (the \u201cNo\u201d branch from block ), invalidate all  continues at block .","At block , client object  cancels any outstanding BCFS requests.","At block , client object  frees the current region configuration file. In the described implementation, the broadcast data that is received is maintained in RAM by the task objects . In an alternate implementation, the received broadcast data may be stored on a hard drive or other memory device. Depending on the implementation, client object  frees the current region configuration file by freeing the RAM in which the region configuration file is maintained, by deleting the region configuration file stored on a hard drive, or by any other method for making storage space available.","At block , client object  enters getting region config file state .","Exemplary Task Object State Transition","In the described implementation, depending on how it is created, a task object  may be responsible for monitoring the contents of a single directory, or the task object  may be responsible for monitoring the contents of all subdirectories under a particular directory. A task object  that is created with the files flag property set is responsible for monitoring the contents of a single directory, while a task object  that is created with the subdirs flag property set responsible for monitoring the contents of all subdirectories under a particular directory. In the described implementation, only one level of subdirectories is supported, but it is recognized that support for additional subdirectory levels may also be similarly implemented.","A task object  can receive two types of messages from client object . The first indicates that task idle timer  has signaled, which causes the task object  to determine the next appropriate BCFS command to execute based on the task object's current state. The second type of message that can be received is a response from BCFS .","State Transition in Task Object Responsible for Files",{"@attributes":{"id":"p-0282","num":"0313"},"figref":["FIG. 24","FIG. 34","FIG. 25"],"b":["1104","826","826","1022","1108","826","2402","826","2402","826","2404","826"]},"While in syncing state , task object  attempts to synchronize locally maintained data associated with task object  with data of the same data type that is being broadcast. Task object  remains in syncing state  until the data is successfully synchronized (at which point task object  enters synced state ) or until the task object is invalidated, for example, when a viewer selects a new configuration (at which point task object  re-enters new state ). Task object  syncing state processing is described in more detail below with reference to .","While in synced state , task object  verifies that the synchronized data remains synchronized. If task object  determines that the data is no longer synchronized, then task object  re-enters syncing state . If task object  is invalidated, for example, when a viewer selects a new configuration, then task object  re-enters new state . Task object  synced state processing is described in more detail below with reference to .",{"@attributes":{"id":"p-0285","num":"0316"},"figref":"FIG. 25","b":["2500","826","2402"]},"At block , task object  waits to receive a signal to process from client object .","At block , task object  receives a signal to process from client object .","At block , task object  issues a seek directory call to BCFS , specifying the directory associated with the data type of the task (as indicated by the tag value of the tag in the configuration definition that is associated with current task object ).","At block , task object  waits for a response from BCFS  to be received.","At block , task object  waits for a response from BCFS  to be received.","At block , task object  determines (based on the received response) whether the BCFS seek directory call was successful.","If the BCFS seek directory call was successful (the \u201cYes\u201d branch from block ), then task object new state processing continues at block . On the other hand, if the BCFS seek directory call failed (the \u201cNo\u201d branch from block ), then task object new state processing continues at block .","At block , task object  examines the received BCFS response to determine whether a data size limit property value associated with task object  is exceeded by the broadcast data of the specified type.","If the data size limit is exceeded (the \u201cYes\u201d branch from block ), then task object new state processing continues at block . On the other hand, if the data size limit is not exceeded, or a data size limit is not specified (the \u201cNo\u201d branch from block ), then at block , task object  enters syncing state .","At block , task object  sets the next activity time property to a future time (e.g., five minutes from the current time), and task object  remains in new state , continuing processing at block .",{"@attributes":{"id":"p-0296","num":"0327"},"figref":"FIG. 26","b":["2600","826","2404"]},"At block , task object  waits to receive a signal to process from client object .","At block , task object  receives a signal to process from client is object .","At block , task object  issues a sync directory call to BCFS , specifying the directory associated with the data type of the task (as indicated by the tag value of the tag in the configuration definition that is associated with the current task object ).","At block , task object  waits for a response from BCFS  to be received.","At block , task object  waits for a response from BCFS  to be received.","At block , task object  determines (based on the received response) whether the BCFS sync directory call was successful.","If the BCFS sync directory call was successful (the \u201cYes\u201d branch from block ), then task object syncing state processing continues at block . On the other hand, if the BCFS sync directory call failed (the \u201cNo\u201d branch from block ), then task object syncing state processing continues at block .","At block , task object  examines the received BCFS response to determine whether a data size limit property value associated with task object  is exceeded by the broadcast data of the specified type.","If the data size limit is exceeded (the \u201cYes\u201d branch from block ), then task object syncing state processing continues at block . On the other hand, if the data size limit is not exceeded, or a data size limit is not specified (the \u201cNo\u201d branch from block ), then task object syncing state operation continues at block , described below.","At block , task object , sets the next activity time property to a future time (e.g., five minutes from the current time).","At block , task object  frees (by deleting or freeing memory) any data received in association with the current task object, and remains in syncing state , looping back to block .","At block , task object  sets the next activity time property to the current time plus the value of the re-check interval property.","At block , task object  determines whether a handler function is associated with the task object (as indicated by the task handler function property of task object ). If a handler function is specified, then, at block , the handler function is called.","At block , task object  enters synced state .",{"@attributes":{"id":"p-0311","num":"0342"},"figref":"FIGS. 27","i":["a ","b "],"b":["27","2700","826","2406"]},"At block , task object  sets the last synchronized data set property of the task object to the name of the tag value from the tag in the configuration definition that is associated with the task object. The tag value indicates the location from which the received data was broadcast. This value is stored when the task object is synchronized to enable client object  to determine which task objects need to be re-synchronized when a new configuration is selected.","At block , task object  waits to receive a signal to process from client object .","At block , task object  receives a signal to process from client object .","At block , task object  issues a seek directory call to BCFS  to determine whether or not the locally maintained data associated with task object  is still synchronized with the data that is being broadcast.","At block , task object  waits for a response from BCFS  to be received.","At block , task object  waits for a response from BCFS  to be received.","At block , task object  determines (based on the received response) whether the BCFS seek directory call was successful.","If the BCFS seek directory call was successful (the \u201cYes\u201d branch from block ), then task object synced state processing continues at block . On the other hand, if the BCFS seek directory call failed (the \u201cNo\u201d branch from block ), then task object synced state processing continues at block .","At block , task object  examines the received BCFS response to determine whether specified directory is still synchronized. If the data is synchronized (the \u201cYes\u201d branch from block ), then task object synced state processing continues at block . Otherwise (the \u201cNo\u201d branch from block ), task object synced state processing continues at block .","At block , task object  examines the received BCFS response to determine whether a data size limit property value associated with task object  is exceeded by the broadcast data of the specified type.","If the data size limit is exceeded (the \u201cYes\u201d branch from block ), then task object synced state processing continues at block . On the other hand, if the data size limit is not exceeded, or a data size limit is not specified (the \u201cNo\u201d branch from block ), then task object synced state processing continues at block , described below.","At block , task object , sets the next activity time property to the current time plus the value of the re-check interval property, and task object  remains in synced state , looping back to block .","At block , task object  determines whether a handler function is associated with the task object (as indicated by the task handler function property of task object ). If a handler function is not specified, then at block , task object  enters syncing state . On the other hand, if a handler function is specified, then, at block , the handler function is called to determine when synchronization is to occur, and processing continues at block , illustrated in ","At block , task object  determines, based on a response from the handler function whether synchronization is to be performed immediately. If so, then at block , task object  enters syncing state .","Otherwise, at block , task object  determines, based on the response from the handler function, whether synchronization is to be performed in a short time. If so, then at block , task object  sets the next activity time property to a short time in the future (e.g., the current time plus five seconds), and task object synced state processing continues at block  (as illustrated in ).","If the response from the handler function indicates that synchronization is to be performed later (the \u201cNo\u201d branch from block ), then at block , task object  sets the next activity time property to the current time plus the value of the re-check interval property. Task object synced state processing then continues at block  (as illustrated in ).","State Transition in Task Object Responsible for Subdirectories",{"@attributes":{"id":"p-0329","num":"0360"},"figref":["FIG. 28","FIG. 28","FIG. 24"],"b":["1104","826","826","826","826"]},"When a task object  is created (e.g., through an API call to add task ) or has just been reset (an exemplary task reset operation  is described below, with reference to ), the task object  enters new state . When task object  receives a signal that it is to be processed (or executed) while in new state , task object  enters validating state . Task object  new state processing in this context is described in more detail below with reference to . Task object  re-enters new state  from any other state if the task object is invalidated (such as when a viewer selects a new configuration with which task object  is not associated).","Validating state  is used by task object  to control the synchronization of each subdirectory associated with task object . Task object  validating state processing is described in more detail below with reference to . When task object , while in validating state , determines that a particular subdirectory is not synchronized, task object  enters syncing state . When task object , while in validating state , determines that all of the subdirectories associated with the task are synchronized, then task object enters synced state .","While in syncing state , task object  attempts to synchronize locally maintained data from a particular subdirectory associated with task object  with data that is being broadcast. Task object  syncing state processing in this context is described in more detail below with reference to . When the subdirectory is successfully synchronized, task object returns to validating state .","After all of the subdirectories associated with task object  are synchronized, task object  remains in synched state  until a signal to process is received from client object . When processed while in synced state , task object  determines the subdirectories that are being broadcast that are associated with task object , and then moves to validating pre-synced state . Task object  synced state processing in this context is described in more detail below with reference to .","While in validating pre-synced state , task object  verifies that previously synchronized data in each subdirectory associated with task object  is still synchronized. If task object  determines that the data is no longer synchronized, then task object  re-enters syncing state . Task object  validating pre-synced state processing is described in more detail below with reference to .",{"@attributes":{"id":"p-0335","num":"0366"},"figref":"FIG. 29","b":["2900","826","2802"]},"At block , task object  waits to receive a signal to process from client object .","At block , task object  receives a signal to process from client object .","At block , task object  issues a seek directory call to BCFS  specifying the top-level directory associated with the task (which is given by the tag value of the tag in the currently selected configuration definition that is associated with data type of task object ).","At block , task object  waits for a response from BCFS  to be received.","At block , task object  waits for a response from BCFS  to be received.","At block , task object  determines (based on the received response) whether the BCFS seek directory call was successful.","If the BCFS seek directory call was successful (the \u201cYes\u201d branch from block ), then task object new state processing continues at block . On the other hand, if the BCFS seek directory call failed (the \u201cNo\u201d branch from block ), then task object new state processing continues at block .","At block , task object  sets the next activity time property to a future time (e.g., five minutes from the current time), and task object  remains in new state , continuing processing at block .","If the BCFS seek directory call was successful (the \u201cYes\u201d branch from block ), then BCFS  returns a list of subdirectories associated with the specified top-level directory and a count of the subdirectories.","At block , task object  stores the returned list of subdirectories. In one implementation, the list is stored (and later processed) in alphabetical order.","At block , task object  stores the count of subdirectories returned by the BCFS .","At block , task object  sets the value of the directory index property to zero.","At block , task object  sets the value of the directory count property to \u22121.","At block , task object  enters validating state .",{"@attributes":{"id":"p-0350","num":"0381"},"figref":"FIG. 30","b":["3000","826","2804"]},"At block , task object  waits to receive a signal to process from client object .","At block , task object  receives a signal to process from client object .","At block , task object  issues a seek directory call to BCFS  for a subdirectory that was found while task object  was in new state . The directory index property is used to select a subdirectory from the stored list of subdirectories.","At block , task object  waits for a response from BCFS  to be received.","At block , task object  waits for a response from BCFS  to be received.","At block , task object  determines (based on the received response) whether the BCFS seek directory call was successful.","If the BCFS seek directory call was successful (the \u201cYes\u201d branch from block ), then task object new state processing continues at block . On the other hand, if the BCFS seek directory call failed (the \u201cNo\u201d branch from block ), then task object new state processing continues at block .","At block , task object  sets the next activity time property to a future time (e.g., five minutes from the current time), and task object  remains in validating state , continuing processing at block .","At block , task object  examines the received BCFS response to determine whether the specified subdirectory is synchronized. If the response from BCFS  indicates that the current subdirectory is not synchronized (the \u201cNo\u201d branch from block ), then at block , task object  enters syncing state . Otherwise (the \u201cYes\u201d branch from block ), task object validate state processing continues at block .","At block , task object  increments the directory index property by one.","At block , task object  compares the value of the directory index property with the count of subdirectories that was previously returned by BCFS . If the values are equal (indicating that all of the subdirectories are synchronized), then at block , task object  is set to synched state . On the other hand, if the values are not equal (indicating that there is at least one subdirectory that is not synchronized), then task object validating state processing continues at block .",{"@attributes":{"id":"p-0362","num":"0393"},"figref":"FIG. 31","b":["3100","826","2808"]},"At block , task object  waits to receive a signal to process from client object .","At block , task object  receives a signal to process from client object .","At block , task object  issues a sync directory call to BCFS  specifying the current subdirectory (as determined by the directory index property). In one implementation, because some data (e.g., pages that display EPG search results) may require pointers to other data in other directories, task object  may call a handler function that controls when the sync directory call is made.","At block , task object  waits for a response from BCFS  to be received.","At block , task object  waits for a response from BCFS  to be received.","At block , task object  determines (based on the received response) whether the BCFS sync directory call was successful.","If the BCFS sync directory call was successful (the \u201cYes\u201d branch from block ), then task object new state processing continues at block . On the other hand, if the BCFS seek directory call failed (the \u201cNo\u201d branch from block ), then task object new state processing continues at block .","At block , task object  sets the next activity time property to a future time (e.g., five minutes from the current time), and task object  remains in syncing state , continuing processing at block .","At block , task object  examines the received BCFS response to determine whether a data size limit associated with task object  is exceeded by the data in the subdirectories that have been synchronized.","If the data size limit is exceeded (the \u201cYes\u201d branch from block ), then at block , task object  frees the data associated with the last subdirectory in the list of subdirectories, and continues at block .","At block , task object  determines whether or not a handler function is associated with task object  (as indicated by the handler function property). If there task object  has an associated handler function (the \u201cYes\u201d branch from block ), then at block , task object  calls the handler function.","At block , task object  increments the directory index property by one.","At block , task object  increments the directory count property by one.","At block , task object  re-enters validating state .",{"@attributes":{"id":"p-0377","num":"0408"},"figref":"FIG. 32","b":["3200","826","2806"]},"At block , task object  sets the last synchronized data set property of the task object to the name of the tag value from the tag in the configuration definition that is associated with the task object. The tag value indicates the top-level directory from which the received data was broadcast. This value is stored when the task object is synchronized to enable client object  to determine which task objects need to be re-synchronized when a new configuration is selected.","At block , task object  determines whether a signal from client object  to process is received. Task object  continues looping back at block  until a signal to process is received.","At block , task object  sets the directory index property to 0.","At block , task object  enters validating pre-synced state .",{"@attributes":{"id":"p-0382","num":"0413"},"figref":"FIGS. 33","i":["a ","b "],"b":["33","3300","826","2810"]},"At block , task object  waits to receive a signal to process from client object .","At block , task object  receives a signal to process from client object .","At block , task object  issues a seek directory call to BCFS  for a subdirectory that was found while task object  was in new state . The directory index property is used to select a subdirectory from the stored list of subdirectories.","At block , task object  waits for a response from BCFS  to be received.","At block , task object  waits for a response from BCFS  to be received.","At block , task object  determines (based on the received response) whether the BCFS seek directory call was successful.","If the BCFS seek directory call was successful (the \u201cYes\u201d branch from block ), then task object new state processing continues at block . On the other hand, if the BCFS seek directory call failed (the \u201cNo\u201d branch from block ), then task object new state processing continues at block .","At block , task object  sets the next activity time property to a future time (e.g., five minutes from the current time), and task object  remains in validating pre-synced state , continuing processing at block .","At block , task object  examines the received BCFS response to determine whether the specified subdirectory is synchronized. If the response from BCFS  indicates that the current subdirectory is not synchronized (the \u201cNo\u201d branch from block ), then task object validate state processing continues at block . Otherwise (the \u201cYes\u201d branch from block ), task object validate state processing continues at block .","At block , task object  increments the directory index property by one.","At block , task object  compares the value of the directory index property with the count of subdirectories that was previously returned by BCFS . If the values are equal (indicating that all of the subdirectories are synchronized), then at block , task object  is enters synched state . On the other hand, if the values are not equal (indicating that there is at least one subdirectory that is not synchronized), then task object validating state processing continues at block .","If at block , it is determined that the specified subdirectory is not synchronized, then at block , task object  determines whether or not a handler function is associated with task object  (based on the handler function property). If it is determined that there is not an associated handler function, then at block , task object  enters syncing state . Otherwise, task object validate pre-synched state processing continues at block .","At block , task object  calls the associated handler function to determine when the subdirectory is to be synchronized, and processing continues at block , as illustrated in ","At block , task object  determines, based on a response from the handler function whether the subdirectory is to be synchronized immediately. If so, then at block , task object  enters syncing state .","Otherwise, at block , task object  determines, based on the response from the handler function, whether the subdirectory is to be synchronized in a short time. If so, then at block , task object  sets the next activity time property to a short time in the future (e.g., the current time plus five seconds), and task object validating pre-synced state processing continues at block , as illustrated in ","If the response from the handler function indicates that the subdirectory is to be synchronized later (the \u201cNo\u201d branch from block ), then at block , task object  sets the next activity time property to the current time plus the value of the re-check interval property. Task object validating pre-synced state processing then continues at block , as illustrated in ","Exemplary Task Object Reset Operation",{"@attributes":{"id":"p-0400","num":"0431"},"figref":"FIG. 34","b":["1108","826","1108","826"]},"At block , task object  cancels any outstanding requests to BCFS .","At block , task object  deletes all data files that are stored on client device  and associated with the data type of task object .","At block , task object  sets the directory count property to \u22121, indicating that no directory synchronizations have been attempted.","At block , task object  sets the directory index property to 0.","At block , task object  sets the next activity time property to the current time to ensure that the task will be executed in the near future.","At block , task object  enters new state  (or new state ).","At block , task object  determines whether or not data associated with the task is in the default path (based on the in default path flag). If the data associated with the task is not in the default path (the \u201cNo\u201d branch from block ), then reset operation  terminates. Otherwise (the \u201cYes\u201d branch from block ), reset operation  continues at block .","At block , task operation  performs default dir list maintenance operation  to update the list of available directories.","Exemplary Task Object Shelve Operation",{"@attributes":{"id":"p-0410","num":"0441"},"figref":"FIG. 35","b":["1110","826","1110","826"]},"At block , task object  performs the reset operation  (as described above with reference to ).","At block , task object  sets the next activity time property to the latest representable date\/time. This enables the task to remain on task list , but ensures that it will not be called because the next activity time property will never be sooner than another task's next activity time property.","Exemplary Task Object Check Invalidate Operation",{"@attributes":{"id":"p-0414","num":"0445"},"figref":"FIG. 36","b":["1112","826","1112"]},"At block , task object  determines its current state. If task object  is in synced state  (or synced state ) (the \u201cYes\u201d branch from block ), then check invalidate  continues at block . Otherwise (the \u201cNo\u201d branch from block ), check invalidate  continues at block .","At block , task object  examines the last synced data set property. If the source location of the data type currently associated with task object  (as indicated by the tag value in the configuration definition in the region configuration file) matches the last synced data set property (the \u201cYes\u201d branch from block ), then no action is taken and check invalidate  terminates. (This situation indicates that the data of the data type associated with task object  for the previously selected configuration is the same for the newly selected configuration.)","At block , task object  performs the reset operation  (described above with reference to ) to clear out any data associated with the task.","Exemplary Client Object Find Specific File API Function",{"@attributes":{"id":"p-0419","num":"0450"},"figref":"FIG. 37","b":["1026","824","1026","1026"]},"At block , client object  receives a full path file name.","At block , client object  parses the received path to determine the task object  responsible for maintaining a local copy of the requested file. In the described implementation, a first portion of the path identifies the data type associated with the file; a second portion of the path identifies a source location of the file that is broadcast; and a third portion of the path identifies the file name.","At block , client object  searches a task object identified by the first and second portion of the received path for the requested file.","At block , client object  determines whether or not the file was found.","If the file is not found (the \u201cNo\u201d branch from block ), then at block , client object  returns a file not found error to the requesting application.","If the file is found (the \u201cYes\u201d branch from block ), then at block , client object  returns the size of the file and a pointer to the file.","Exemplary Client Object Find File in Default Path API Function",{"@attributes":{"id":"p-0427","num":"0458"},"figref":"FIG. 38","b":["1028","824","1028","1028"]},"At block , client object  receives a file name.","At block , client object  identifies a task object  that is associated with the last tag listed in the currently selected configuration definition.","At block , client object  determines whether the identified task object  is in the default path (as indicated by the in default path flag associated with the task object). If the identified task object  is not in the default path, then find file in default path  continues at block .","At block , client object  determines whether or not the data associated with the identified task object is synchronized. In one implementation, in which task objects are grouped, for example according to a data type group identifier that may be specified as part of the configuration definition, determining whether or not the data associated with the identified task object is synchronized also includes determining whether or not all of the data associated with the task objects of the same group are also synchronized. If any of the task objects associated with the group are not synchronized, then the current task object is determined to not be synchronized. In this way, other applications (such as a user interface) are not give access to any of the received data associated with a particular data type group until all of the data associated with data types in the group are is successfully received. If the identified task object  is not synchronized, then find file in default path  continues at block .","At block , client object  searches the data maintained by the identified task object  for the requested file.","At block , client object  determines whether or not the file has been found.","If the file is found (the \u201cYes\u201d branch from block ), then at block , client object  returns the size of the file and a pointer to the file.","If the file is not found (the \u201cNo\u201d branch from block ), then at block , client object  determines whether or not all of the task objects associated with the currently selected configuration have been checked. If there are more task objects to search (the \u201cNo\u201d branch from block ), then find file in default path  continues at block .","If there are no more task objects to search (the \u201cYes\u201d branch from block ), then at block , client object  returns a file not found message.","At block , client object  identifies a task object  that is associated with the next previous tag listed in the currently selected configuration definition. The task objects are searched in reverse order to insure that any override data (which is downloaded after the default data that it overrides) will be found before the default data that it overrides is found.","Although the systems and methods have been described in language specific to structural features and\/or methodological steps, it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or steps described. Rather, the specific features and steps are disclosed as preferred forms of implementing the claimed invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The same numbers are used throughout the drawings to reference like features and components.",{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0009","num":"0008"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0010","num":"0009"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 5","FIG. 3"]},{"@attributes":{"id":"p-0012","num":"0011"},"figref":["FIG. 6","FIG. 3"]},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 8","FIG. 1"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 10","FIG. 8"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 11","FIG. 8"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 12","FIG. 10"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 13","FIG. 10"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 14","FIG. 10"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 15","FIG. 10"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 16","FIG. 10"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 17","FIG. 10"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 18","FIG. 10"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 19","FIG. 10"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 20","FIG. 10"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 21","FIG. 10"]},{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 22","FIG. 10"]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 23","FIG. 10"]},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 24","FIG. 11"]},{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 25","FIG. 11"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 26","FIG. 11"]},{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 27","FIG. 11"],"i":"a "},{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 27","FIG. 11"],"i":"b "},{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 28","FIG. 11"]},{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 29","FIG. 11"]},{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 30","FIG. 11"]},{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 31","FIG. 11"]},{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 32","FIG. 11"]},{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 33","FIG. 11"],"i":"a "},{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 33","FIG. 11"],"i":"b "},{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 34","FIG. 11"]},{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 35","FIG. 11"]},{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 36","FIG. 11"]},{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 37","FIG. 10"]},{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 38","FIG. 10"]}]},"DETDESC":[{},{}]}
