---
title: Distributed cache arrangement
abstract: Systems and methods that aggregate memory capacity of multiple computers into a single unified cache, via a layering arrangement. Such layering arrangement is scalable to a plurality of machines and includes a data manager component, an object manager component and a distributed object manager component, which can be implemented in a modular fashion. Moreover, the layering arrangement can provide for an explicit cache tier (e.g., cache-aside architecture) that applications are aware about, wherein decision are made explicitly which objects to put/remove in such applications (as opposed to an implicit cache wherein application do not know the existence of the cache).
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08943271&OS=08943271&RS=08943271
owner: Microsoft Corporation
number: 08943271
owner_city: Redmond
owner_country: US
publication_date: 20090130
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application claims the benefit of U.S. Provisional Application No. 61\/061,017 filed on 12 Jun. 2008 entitled \u201cDISTRIBUTED CACHE\u201d, and the entirety of this application is hereby incorporated by reference.","Increasing advances in computer technology (e.g., microprocessor speed, memory capacity, data transfer bandwidth, software functionality, and the like) have generally contributed to increased computer application in various industries. Ever more powerful server systems, which are often configured as an array of servers, are often provided to service requests originating from external sources such as the World Wide Web, for example.","Typically, a continuing problem in computer systems remains handling the growing amount of information or data available. The sheer amount of information being stored on disks or other media for databases in some form has been increasing dramatically. While files and disks were measured in thousands of bytes a few decades ago\u2014at that time being millions of bytes (megabytes), followed by billions of bytes (gigabytes)\u2014now databases of a million megabytes (terabytes) and even billions of megabytes are being created and employed in day-to-day activities.","Moreover, various forms of storage devices allow information to be held over relatively a long period without information degradation. A common storage medium is flash memory; specifically, flash memory is a non-volatile form of storage that retains information without drawing upon a constant source of power. Such type of memory is often employed in a variety of consumer electronic devices such as memory cards, universal serial bus (USB), flash drives, personal data assistants (PDAs), digital audio players, digital cameras, mobile phones, and so forth.","Another common type of non-volatile storage medium is a magnetic disk, which enables information to be recorded according to a magnetization pattern. Similar to other storage media, magnetic disks can be configured in a variety of manners (e.g., Magneto resistive Random Access Memory) as well as employed in many different applications. This type of storage device is commonly used in connection with databases and analog recordings. Likewise, volatile forms of storage exist that provide certain benefits that may also be accompanied by particular disadvantages. For example, retrieval times for volatile media are generally faster than that for non-volatile media, and many operations have increased uniformity due to well-established standards.","Moreover, today applications run on different tiers, in different service boundaries, and on different platforms (e.g. server, desktop, devices). For example, in a typical web application, many applications reside on a server supporting a large number of users; however, some client components of the application may run on desktops, mobile devices, and web browsers, and the like. Furthermore, advances in connectivity and cheap storage combined with the complexity of software management facilitate on-line services and software-as-a-service. In such services models, applications (and associated data) are typically hosted in central data centers (also sometimes referred to as the \u2018cloud\u2019) and are accessible and shared over the web.","The distributed applications require support for large number of users, high performance, throughput and response time. Such services orientation also requires the cost of service to be low, thereby requiring the scalability and performance at low cost.","A further challenge in implementing storage systems is support for distribution and heterogeneity of data and applications. Applications are composing (e.g. mashups) data and business logic from sources that can be local, federated, or cloud-based. Composite applications require aggregated data to be shaped in a form that is most suitable for the application. Data and logic sharing is also an important requirement in composite applications.","As explained earlier, data and applications can reside in different tiers with different semantics and access patterns. For example, data in back-end servers\/clusters or in the cloud tends to be authoritative; data on the wire is message-oriented; data in the mid-tier is either cached data for performance or application session data; data on the devices could be local data or data cached from back-end sources. With the costs of memory going down, considerably large caches can be configured on the desktop and server machines. With the maturity of 64-bit hardware, 64-bit CPUs are becoming mainstream for client and server machines. True 64-bit architectures support 64-bit CPUs, data or address buses, virtual addressability and dramatically increase memory limits (to 2bytes). Operating systems (e.g. Windows, Linux) are also upgraded to support and take advantage of 64 bit address-space and large memories. For example, desktops can be configured with 16 GB RAM, and servers can be configured with up to 2 TB of RAM. Large memory caches allow for data to be located close to the application, thereby providing significant performance benefits to applications. In addition, in a world where hundreds of gigabytes of storage is the norm, the ability to work with most data in memory (large caches) and easily shift from tables to trees to graphs of objects is the key to programmer productivity for next generation applications.","The following presents a simplified summary in order to provide a basic understanding of some aspects described herein. This summary is not an extensive overview of the claimed subject matter. It is intended to neither identify key or critical elements of the claimed subject matter nor delineate the scope thereof. Its sole purpose is to present some concepts in a simplified form as a prelude to the more detailed description that is presented later.","The subject innovation enables aggregating memory capacity of multiple computers into a single unified cache, which can be scalable (e.g., a dynamic scaling) to a plurality of machines via a layering arrangement. Such layering arrangement can cache any serializable Common Language Runtime (CLR) object and provide access through simple cache application programming interface (API). The layering arrangement includes a data manager component, an object manager component and a distributed object manager component, which can be implemented in a modular fashion. In one aspect, the data manager component supplies basic data functions (e.g., hash functions), and the object manager component implements object facade thereon including cache objects\u2014while the distributed object manager provides distribution of the data in the distributed cache. As such, the object manager component can map regions to containers and manage data eviction thresholds and supply policy management for cached data. Such regions can represent cache containers that typically guarantee co-locations of the object placed\/inserted in the container (e.g., co-locations of objects in same node). Additionally, the object manager component can raise notifications (e.g., due to changes made to cached data) for various regions or objects of the distributed cache. Likewise, the distributed object manager component can dispatch requests to various nodes associated with different regions of the distributed cache. Moreover, such distributed object manager interfaces with partition maps of the distributed cache for a given request; and facilitates abstraction of the aggregated cache in the distributed environment, to a single unified cache. In one aspect, the distributed object manager component is positioned on top of the object manager component, which itself is placed on top of the data manager component. Moreover, tight integration can be provided with ASP.NET to enable cache ASP.NET session data in the cache without having to write it to source databases, for example.","Such provides for pluggable features that can readily adapt to a user's need (e.g., replacing a data manger component with another type thereof, based on user requirements.) Likewise, the object manager component can be replaced with another object manager component, wherein plugging different models in the layering arrangement is enabled by enabling a call back mechanism with holding locks during call back throughout the stack.","In a related aspect, the layering arrangement of the subject innovation provides for a modular arrangement that facilitates operation on different levels and communication substrates (e.g., TCP\/IP), and which can be implemented in two topology models, namely as an independent separate tier model or an embedded application model. In the independent and separate tier model the caching layer functions as an independent separate tier by itself, (which can be positioned between application servers and data servers). For example, in such configuration the distributed cache runs as a service hosted either by Windows Activation Services (WAS) or windows service and runs separate from the application. The applications can either employ the client stubs provided by the distributed cache to talk thereto, or through Representational state transfer (REST) API directly into the service.","Alternatively, in the embedded application model the cache can be embedded with the application itself (e.g., connecting the applications together to form a cluster\u2014such as embedding caches in ASP.net instances to form a cluster of ASP.net machines, wherein upon storing an item in a local cache it can be viewed from other machines.) Such can further enable tagging and Language Integrated Query (LINQ) queries on the objects from a functionality perspective. LINQ queries can then be run natively on stored objects; and (can be embedded in .Net applications)","To the accomplishment of the foregoing and related ends, certain illustrative aspects of the claimed subject matter are described herein in connection with the following description and the annexed drawings. These aspects are indicative of various ways in which the subject matter may be practiced, all of which are intended to be within the scope of the claimed subject matter. Other advantages and novel features may become apparent from the following detailed description when considered in conjunction with the drawings.","The various aspects of the subject innovation are now described with reference to the annexed drawings, wherein like numerals refer to like or corresponding elements throughout. It should be understood, however, that the drawings and detailed description relating thereto are not intended to limit the claimed subject matter to the particular form disclosed. Rather, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the claimed subject matter.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 1","FIG. 1"],"b":["100","100","131","133","100","110","112","114","114","112","110","110","112","114","112","110","114"]},"As explained earlier, the data manager component  (e.g., in memory) provides primitive high performance data structures such as hash tables, Btrees, and the like. Since such data manager  is memory bound and all operations of the distributed cache of the subject innovation are atomic, it can typically implement highly concurrent hash tables. Such further facilitates creating the infrastructure for supplying containers and indexes on containers. In addition it provides simple eviction and expiration on these hash structures. It is to be appreciated that due to pluggable features supplied by the layering arrangement , users can plug in different types of data managers tailored to users' requirements such as; a transaction data manager or a disk paged data manager, and the like. Likewise, the object manager component  provides the object abstraction and implements the concept of named caches and region by employing data structures provided by the data manager.","Similarly, the distributed object manager component  employs the local object manager and integrates with the Distributed Components  to provide the abstraction of the distributed cache. Core to the distributed cache of the subject innovation is the Distributed Components\/availability substrate  which provides the transport and data consistency operations to make the system scalable and available. The object distribution component can optionally be implemented as part of a client tier to facilitate dispatching requests (e.g., directly) to the nodes associated with the single unified cache.","In one particular aspect, the distributed object manager component  can further include a Dispatch Manager component  and a distributed Manager component . The Dispatch Manager component  can further look up the routing table to dispatch the requests to a primary node (e.g., where a region is located) as part of dynamically scalable distributed cache. Moreover, such dispatch manager component  can be also present in the client so that the client can directly dispatch requests to the primary node. For example, the distributed object manager  on the receiving node can interact with the partition map to check if the node is indeed designated as the primary node as part of a plurality of nodes associated with the distributed cache, and calls the Object Manager component  to perform the operation. In the case of write operations, such distributed object manager component  can also communicate with a replicator to replicate the data to the secondary nodes. It can also interact with the failover manager systems (not shown) to clone regions to create new secondary or primary nodes during reconfiguration procedures subsequent to possible failures.","The object manager component  can further include a notification management component  that tracks changes to regions and objects and relays notifications to delegates listening to those events. Moreover, applications can also register delegates for notifications on any node which may be different from the primary node on which the object resides. The distributed object manager component  can further manage the propagation of notifications in a distributed fashion including providing high availability for such notifications when the primary node fails. For example, such can be handled by maintaining a local lookup table indexed by delegate id on the node where the application registers the delegate. The primary node that stores the object maintains the delegate id and the originating node information. When such object changes in the distributed object manager component , the primary node can notify all the originating nodes passing along the delegate id.","Similarly, the distributed object manager component  associated with the receiver can employ the lookup table to call the appropriate delegate, thus providing the change information to the application in a distributed fashion. For example, notifications can be asynchronous and can further be backed up using the same secondary nodes. Accordingly, in the event of failures, the secondary nodes attempt to deliver the pending notifications, wherein during the primary node failure notifications can be resent\u2014since the primary may not have synchronized the information regarding the delivered notifications before failure. Since all notifications carry the region, key and version information, application can use the version to ignore duplicate notifications.","Example\u2014Region Level Callback",{"@attributes":{"id":"p-0035","num":"0034"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public delegate CacheCallback"]},{"entry":[{},"elec_cbk = new CacheCallback( myclass.handler );"]},{"entry":[{},"catalog.addCallback(\u201cElectronicsRegion\u201d, elec_cbk);"]},{"entry":[{},"Callback called for any updates to region"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Example\u2014Object Level Callback",{"@attributes":{"id":"p-0037","num":"0036"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public delegate CacheItemRemovedCallback"]},{"entry":[{},"elec_cbk = new CacheItemRemovedCallback( );"]},{"entry":[{},"\/\/ Add the callback to the object ; the elec_cbk delegate"]},{"entry":[{},"will be called"]},{"entry":[{},"\/\/ whenever the object changes regardless of where the"]},{"entry":[{},"object is present"]},{"entry":[{},"catalog.Add(\u201cElectronicsRegion\u201d, \u201ckey\u201d, object,"]},{"entry":[{},"elec_cbk);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Likewise, the Availability Substrate  provides scalability and availability to systems that contain a storage component associated with the distributed cache of the subject innovation. For example, the availability substrate can include load balancers, fail over managers, replicators and the like. Interacting with such availability substrate  is the communication substrate  that provides for failure detection of nodes and reliable message delivery therebetween. Moreover, the communication substrate  provides the communication channels and cluster management. Such communication substrate  can provide callbacks whenever a new node joins the cluster or when a node dies or fails to respond to exchanged messages (e.g., heart beat messages). Moreover, the communication substrate  can provide efficient point-to-point and multicast delivery channels, and can further provide reliable message delivery that is required for implementing the replication protocols. For example, the communication substrate  supports notifications by maintaining delegate information in cache items and triggering the notification when items are modified. Such component also triggers eviction based on policies defined at the region or named cache level.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 2","FIG. 3","FIG. 2"],"b":["220","201","203","205"]},"Alternatively, in the embedded application model the cache can be embedded with the application itself as illustrated in . Such can occur by connecting the applications , ,  (1 to k, k being an integer) together to form a cluster; for instance as embedding caches in ASP.net instances to form a cluster of ASP.net machines, wherein upon storing an item in a local cache it can be viewed from other machines. For example, the distributed cache runtime dlls are compiled with the application and the application acts as the Cache Host for the distributed cache runtime. All the thread pools and memory come from the application's container.","In a related aspect, the Load Balancer  can dynamically redistribute load across the cluster in the event that one or more nodes are inundated. For example, data can be repartitioned to spread it to nodes that have less loads. All such nodes can periodically send their load status as part of the configuration metadata. The load balancer  also periodically queries the configuration to determine which nodes are overloaded and need to be balanced. For example, to distribute the load is to repartition the hot partition of data on the primary node and spread it to one (or more) of its secondary nodes. This requires a change in the configuration data (partition map) and no data movement (since the secondary nodes already have the data). In other scenarios, it may be required to distribute the data to other non-secondary nodes since the secondary nodes themselves might be loaded and cannot handle the additional node. In such cases, either the data partitions on the secondary nodes (for which this node is the primary) need to be further load balanced; or non-secondary nodes can be chosen to distribute the load, in which case in addition to the changes in the partition map, data will need to be moved.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 4","b":["400","410","411","412","410","411","412","422","423","433","433"]},"The following is a code example that shows the creation of a named cache and region.",{"@attributes":{"id":"p-0044","num":"0043"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ CacheFactory class provides methods to return cache objects"]},{"entry":[{},"\/\/ Create instance of cachefactory (reads appconfig)"]},{"entry":[{},"CacheFactory fac = new CacheFactory( );"]},{"entry":[{},"\/\/ Get a named cache from the factory"]},{"entry":[{},"Cache catalog = fac.GetCache(\u201ccatalogcache\u201d);"]},{"entry":[{},"\/\/-------------------------------------------------------"]},{"entry":[{},"\/\/ Simple Get\/Put"]},{"entry":[{},"catalog.Put(\u201ctoy-101\u201d, new Toy(\u201cthomas\u201d, .,.));"]},{"entry":[{},"\/\/ From the same or a different client"]},{"entry":[{},"Toy toyObj = (Toy)catalog.Get(\u201ctoy-101\u201d);"]},{"entry":[{},"\/\/ ------------------------------------------------------"]},{"entry":[{},"\/\/ Region based Get\/Put"]},{"entry":[{},"catalog.CreateRegion(\u201ctoyRegion\u201d);"]},{"entry":[{},"\/\/ Both toy and toyparts are put in the same region"]},{"entry":[{},"catalog.Put(\u201ctoyRegion\u201d, \u201ctoy-101\u201d, new Toy( .,.));"]},{"entry":[{},"Catalog.Put(\u201ctoyRegion\u201d, \u201ctoypart-100\u201d, new ToyParts(...));"]},{"entry":[{},"Toy toyObj = (Toy)catalog.Get(\u201ctoyRegion\u201d, \u201ctoy-101\u201d);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 5","b":["500","510","520","530","540"]},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 6","b":["600","610"]},"At , the data manager component supplies basic data functions (e.g., hash functions). Likewise, and at  the object manager component implements object facade thereon including cache objects with the distributed object manager component providing the distribution. As such, the object manager component and data manager component can act as local entities, wherein the distribution manager performs the distributions at .",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 7","b":["720","700"]},"Typically, there tends to be single authoritative source for any data instance. Most data in the mid-tier, being operated by the business logic can tends to be copy of the authoritative data. Such copies are suitable for caching. As such, Understanding the different types of data and their semantics in different tiers defines the different degrees of caching that is possible.","Reference Data","Reference data is a version of the authoritative data. It is either a direct copy (version) of the original data or aggregated and transformed from multiple data sources. Reference data is practically immutable\u2014changing the reference data (or the corresponding authoritative data) creates a new version of the reference data. That is, every reference data version is unique. Reference data is a candidate for caching; as the reference data does not change, it can be shared across multiple applications (users), thereby increasing the scale and performance. For example, a product catalog application aggregating product information across multiple backend application and data sources can be considered. Most common operation on the catalog data is read (or browse); a typical catalog browse operation iterates over a large amount of product data, filters it, personalizes it, and then presents the selected data to the users. Key based and query based access is a common form of operation. Caching is a critical requirement for catalog access. If not cached, operations against such an aggregate catalog require the operations to be decomposed into operations on the underlying sources, invoke the underlying operations, collect responses, and aggregate the results into cohesive responses. Accessing the large sets of backend data for every catalog operation can be prohibitively expensive, and can significantly impact the response time and throughput of the application. Caching the backend product data closer to the catalog application can significantly improve the performance and the scalability of the application. Similarly, aggregated flight schedules are another example of reference data. Referenced data can be refreshed periodically, usually at configured intervals, from its sources, or refreshed when the authoritative data sources change. Access to reference data, though shared, is mostly read. Local updates are often performed for tagging (to better organize the data). To support large scale, reference data can be replicated in multiple caches on different machines in a cluster. As mentioned above, reference data can be readily cached, and can provide high scalability.","Activity Data","Activity data is generated by the currently executing activity as part of a business transaction. Such data originates as part of the business transaction and eventually at the close of the business transaction, it is retired to the backend data source as historical (or log) information. For example, the shopping cart data in an online buying application can be considered. There is one shopping cart, which is exclusive, for each online buying session. During the buying session, the shopping cart is cached and updated with products purchased, wherein the shopping cart is visible and accessible only to the buying transaction. Upon checkout, once the payment is applied, the shopping cart is retired (from the cache) to a backend application for further processing. Once the business transaction is processed by the backend application, the shopping cart information is logged for auditing (and historical) purposes.","While the buying session is active, the shopping cart is accessed both for read and write; however it is not shared. This exclusive access nature of the activity data makes it suitable for distributed caching. To support large scalability of the buying application, the shipping carts can be distributed across the cluster of caches. Since the shopping carts are not shared, the set of shopping carts can be partitioned across the distributed cache. By dynamically configuring the distributed cache, the degree of scale can be controlled.","Resource Data","Both reference (shared read) and activity (exclusive write) data can be cached. It is to be appreciated that not all application data falls into these two categories. There is data that is shared, concurrently read and written into, and accessed by large number of transactions. For example, considering inventory management application, the inventory of an item has the description of the item and the current quantity. The quantity information is authoritative, volatile, and concurrently accessed by large number of users for read\/write. Such data is known as the resource data; the business logic (e.g. the order application logic) runs close to the resource data (e.g. quantity data). The resource data is typically stored in the backend data stores. However, for performance reasons it is cached in the application tier. While caching the quantity data in memory on a single machine can provide performance improvements, a single cache cannot provide availability or scale when the order volume is high. Accordingly, the quantity data can be replicated in multiple caches across the distributed cache.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 8","b":["830","830"]},"The AI component  can employ any of a variety of suitable AI-based schemes as described supra in connection with facilitating various aspects of the herein described invention. For example, a process for learning explicitly or implicitly how or what candidates are of interest, can be facilitated via an automatic classification system and process. Classification can employ a probabilistic and\/or statistical-based analysis (e.g., factoring into the analysis utilities and costs) to prognose or infer an action that a user desires to be automatically performed. For example, a support vector machine (SVM) classifier can be employed. Other classification approaches include Bayesian networks, decision trees, and probabilistic classification models providing different patterns of independence can be employed. Classification as used herein also is inclusive of statistical regression that is utilized to develop models of priority.","As will be readily appreciated from the subject specification, the subject innovation can employ classifiers that are explicitly trained (e.g., via a generic training data) as well as implicitly trained (e.g., via observing user behavior, receiving extrinsic information) so that the classifier is used to automatically determine according to a predetermined criteria which answer to return to a question. For example, with respect to SVM's that are well understood, SVM's are configured via a learning or training phase within a classifier constructor and feature selection module. A classifier is a function that maps an input attribute vector, x=(x1, x2, x3, x4, xn), to a confidence that the input belongs to a class\u2014that is, f(x)=confidence(class). Moreover, a rule based mechanism can further be employed for interaction of a routing manager and a routing layer associated therewith (e.g., load balancing, memory allocation and the like)","The word \u201cexemplary\u201d is used herein to mean serving as an example, instance or illustration. Any aspect or design described herein as \u201cexemplary\u201d is not necessarily to be construed as preferred or advantageous over other aspects or designs. Similarly, examples are provided herein solely for purposes of clarity and understanding and are not meant to limit the subject innovation or portion thereof in any manner. It is to be appreciated that a myriad of additional or alternate examples could have been presented, but have been omitted for purposes of brevity.","Furthermore, all or portions of the subject innovation can be implemented as a system, method, apparatus, or article of manufacture using standard programming and\/or engineering techniques to produce software, firmware, hardware or any combination thereof to control a computer to implement the disclosed innovation. For example, computer readable media can include but are not limited to magnetic storage devices (e.g., hard disk, floppy disk, magnetic strips . . . ), optical disks (e.g., compact disk (CD), digital versatile disk (DVD) . . . ), smart cards, and flash memory devices (e.g., card, stick, key drive . . . ). Additionally it should be appreciated that a carrier wave can be employed to carry computer-readable electronic data such as those used in transmitting and receiving electronic mail or in accessing a network such as the Internet or a local area network (LAN). Of course, those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.","Furthermore, all or portions of the subject innovation can be implemented as a system, method, apparatus, or article of manufacture using standard programming and\/or engineering techniques to produce software, firmware, hardware or any combination thereof to control a computer to implement the disclosed innovation. For example, computer readable media can include but are not limited to magnetic storage devices (e.g., hard disk, floppy disk, magnetic strips . . . ), optical disks (e.g., compact disk (CD), digital versatile disk (DVD) . . . ), smart cards, and flash memory devices (e.g., card, stick, key drive . . . ). Additionally it should be appreciated that a carrier wave can be employed to carry computer-readable electronic data such as those used in transmitting and receiving electronic mail or in accessing a network such as the Internet or a local area network (LAN). Of course, those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.","In order to provide a context for the various aspects of the disclosed subject matter,  as well as the following discussion are intended to provide a brief, general description of a suitable environment in which the various aspects of the disclosed subject matter may be implemented. While the subject matter has been described above in the general context of computer-executable instructions of a computer program that runs on a computer and\/or computers, those skilled in the art will recognize that the innovation also may be implemented in combination with other program modules.","As used in this application, the terms \u201ccomponent\u201d, \u201csystem\u201d, \u201cengine\u201d are intended to refer to a computer-related entity, either hardware, a combination of hardware and software, software, or software in execution. For example, a component can be, but is not limited to being, a process running on a processor, a processor, an object, an executable, a thread of execution, a program, and\/or a computer. By way of illustration, both an application running on a server and the server can be a component. One or more components can reside within a process and\/or thread of execution, and a component can be localized on one computer and\/or distributed between two or more computers.","Generally, program modules include routines, programs, components, data structures, and the like, which perform particular tasks and\/or implement particular abstract data types. Moreover, those skilled in the art will appreciate that the innovative methods can be practiced with other computer system configurations, including single-processor or multiprocessor computer systems, mini-computing devices, mainframe computers, as well as personal computers, hand-held computing devices (e.g., personal digital assistant (PDA), phone, watch . . . ), microprocessor-based or programmable consumer or industrial electronics, and the like. The illustrated aspects may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. However, some, if not all aspects of the innovation can be practiced on stand-alone computers. In a distributed computing environment, program modules may be located in both local and remote memory storage devices.","With reference to , an exemplary environment  for implementing various aspects of the subject innovation is described that includes a computer . The computer  includes a processing unit , a system memory , and a system bus . The system bus  couples system components including, but not limited to, the system memory  to the processing unit . The processing unit  can be any of various available processors. Dual microprocessors and other multiprocessor architectures also can be employed as the processing unit .","The system bus  can be any of several types of bus structure(s) including the memory bus or memory controller, a peripheral bus or external bus, and\/or a local bus using any variety of available bus architectures including, but not limited to, 11-bit bus, Industrial Standard Architecture (ISA), Micro-Channel Architecture (MSA), Extended ISA (EISA), Intelligent Drive Electronics (IDE), VESA Local Bus (VLB), Peripheral Component Interconnect (PCI), Universal Serial Bus (USB), Advanced Graphics Port (AGP), Personal Computer Memory Card International Association bus (PCMCIA), and Small Computer Systems Interface (SCSI).","The system memory  includes volatile memory  and nonvolatile memory . The basic input\/output system (BIOS), containing the basic routines to transfer information between elements within the computer , such as during start-up, is stored in nonvolatile memory . By way of illustration, and not limitation, nonvolatile memory  can include read only memory (ROM), programmable ROM (PROM), electrically programmable ROM (EPROM), electrically erasable ROM (EEPROM), or flash memory. Volatile memory  includes random access memory (RAM), which acts as external cache memory. By way of illustration and not limitation, RAM is available in many forms such as synchronous RAM (SRAM), dynamic RAM (DRAM), synchronous DRAM (SDRAM), double data rate SDRAM (DDR SDRAM), enhanced SDRAM (ESDRAM), Synchlink DRAM (SLDRAM), and direct Rambus RAM (DRRAM).","Computer  also includes removable\/non-removable, volatile\/non-volatile computer storage media.  illustrates a disk storage , wherein such disk storage  includes, but is not limited to, devices like a magnetic disk drive, floppy disk drive, tape drive, Jaz drive, Zip drive, LS-60 drive, flash memory card, or memory stick. In addition, disk storage  can include storage media separately or in combination with other storage media including, but not limited to, an optical disk drive such as a compact disk ROM device (CD-ROM), CD recordable drive (CD-R Drive), CD rewritable drive (CD-RW Drive) or a digital versatile disk ROM drive (DVD-ROM). To facilitate connection of the disk storage devices  to the system bus , a removable or non-removable interface is typically used such as interface .","It is to be appreciated that  describes software that acts as an intermediary between users and the basic computer resources described in suitable operating environment . Such software includes an operating system . Operating system , which can be stored on disk storage , acts to control and allocate resources of the computer system . System applications  take advantage of the management of resources by operating system  through program modules  and program data  stored either in system memory  or on disk storage . It is to be appreciated that various components described herein can be implemented with various operating systems or combinations of operating systems.","A user enters commands or information into the computer  through input device(s) . Input devices  include, but are not limited to, a pointing device such as a mouse, trackball, stylus, touch pad, keyboard, microphone, joystick, game pad, satellite dish, scanner, TV tuner card, digital camera, digital video camera, web camera, and the like. These and other input devices connect to the processing unit  through the system bus  via interface port(s) . Interface port(s)  include, for example, a serial port, a parallel port, a game port, and a universal serial bus (USB). Output device(s)  use some of the same type of ports as input device(s) . Thus, for example, a USB port may be used to provide input to computer , and to output information from computer  to an output device . Output adapter  is provided to illustrate that there are some output devices  like monitors, speakers, and printers, among other output devices  that require special adapters. The output adapters  include, by way of illustration and not limitation, video and sound cards that provide a means of connection between the output device  and the system bus . It should be noted that other devices and\/or systems of devices provide both input and output capabilities such as remote computer(s) .","Computer  can operate in a networked environment using logical connections to one or more remote computers, such as remote computer(s) . The remote computer(s)  can be a personal computer, a server, a router, a network PC, a workstation, a microprocessor based appliance, a peer device or other common network node and the like, and typically includes many or all of the elements described relative to computer . For purposes of brevity, only a memory storage device  is illustrated with remote computer(s) . Remote computer(s)  is logically connected to computer  through a network interface  and then physically connected via communication connection . Network interface  encompasses communication networks such as local-area networks (LAN) and wide-area networks (WAN). LAN technologies include Fiber Distributed Data Interface (FDDI), Copper Distributed Data Interface (CDDI), Ethernet\/IEEE 802.3, Token Ring\/IEEE 802.5 and the like. WAN technologies include, but are not limited to, point-to-point links, circuit switching networks like Integrated Services Digital Networks (ISDN) and variations thereon, packet switching networks, and Digital Subscriber Lines (DSL).","Communication connection(s)  refers to the hardware\/software employed to connect the network interface  to the bus . While communication connection  is shown for illustrative clarity inside computer , it can also be external to computer . The hardware\/software necessary for connection to the network interface  includes, for exemplary purposes only, internal and external technologies such as, modems including regular telephone grade modems, cable modems and DSL modems, ISDN adapters, and Ethernet cards.  is a schematic block diagram of a sample-computing environment  that can be employed for distributing cache according to an aspect of the subject innovation. The system  includes one or more client(s) . The client(s)  can be hardware and\/or software (e.g., threads, processes, computing devices). The system  also includes one or more server(s) . The server(s)  can also be hardware and\/or software (e.g., threads, processes, computing devices). The servers  can house threads to perform transformations by employing the components described herein, for example. One possible communication between a client  and a server  may be in the form of a data packet adapted to be transmitted between two or more computer processes. The system  includes a communication framework  that can be employed to facilitate communications between the client(s)  and the server(s) . The client(s)  are operatively connected to one or more client data store(s)  that can be employed to store information local to the client(s) . Similarly, the server(s)  are operatively connected to one or more server data store(s)  that can be employed to store information local to the servers .","What has been described above includes various exemplary aspects. It is, of course, not possible to describe every conceivable combination of components or methodologies for purposes of describing these aspects, but one of ordinary skill in the art may recognize that many further combinations and permutations are possible. Accordingly, the aspects described herein are intended to embrace all such alterations, modifications and variations that fall within the spirit and scope of the appended claims. Furthermore, to the extent that the term \u201cincludes\u201d is used in either the detailed description or the claims, such term is intended to be inclusive in a manner similar to the term \u201ccomprising\u201d as \u201ccomprising\u201d is interpreted when employed as a transitional word in a claim."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
