---
title: Hierarchical arrangement for spooling job data
abstract: A hierarchical spooling data structure includes a plurality of nodes. In accordance with certain aspects, the plurality of nodes include at least four nodes: a first node representing a fixed page of the job; a second node representing a fixed document of the job, the second node including a reference to the first node; a third node containing data representing a fixed sequence of documents of the job, the third node including a reference to the second node; and a fourth node containing data representing a root of the job, the fourth node including a reference to the third node.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08243317&OS=08243317&RS=08243317
owner: Microsoft Corporation
number: 08243317
owner_city: Redmond
owner_country: US
publication_date: 20050324
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application is a continuation-in-part of U.S. patent application Ser. No. 10\/938,476, entitled \u201cSpooling Strategies Using Structured Job Information,\u201d filed on Sep. 10, 2004, which is incorporated herein by reference in its entirety.","This application claims the benefit of the following U.S. Provisional Applications, all filed on May 3, 2004, and each of which is incorporated by reference herein in its respective entirety: U.S. Provisional Application No. 60\/567,890; and U.S. Provisional Application No. 60\/567,920.","The present application is also related to co-pending and commonly assigned U.S. patent application Ser. No. 10\/794,669, entitled \u201cMultilevel Ticket-Based Job Management Architecture for Computing Devices,\u201d filed on Mar. 5, 2004, which is incorporated herein by reference in its entirety.","The present application is also related to co-pending and commonly assigned U.S. patent application Ser. No. 10\/836,327, entitled \u201cDocument Mark Up Methods and Systems,\u201d filed on May 1, 2004, which is incorporated herein by reference in its entirety.","This subject matter relates to a format used for producing and consuming job information.","Computing devices commonly render documents using spooling techniques (where \u201cspool\u201d is an acronym for Simultaneous Peripheral Operations On-Line). In a typical spooling technique, an application on the computing device generates a document and a spooler on the computing device stores it in a spool storage. The spool storage can be implemented using memory (such as RAM memory), or, more commonly, using disk storage. When the device is ready to process the document, the device can then access the document from the spool storage and convert it to a format that is compatible with the format expectations of an output device (such as a format defined by the Page Description Language). The device can then forward the converted document to the output device, whereupon the output device prints the document, or performs some other processing with respect to the document. Storing a document in a spool storage (rather than directly outputting the document to the printer) is generally advantageous because it allows the application that generated the document, as well as the spooler, on the computing device to perform other tasks while the document is being processed for printing. Generally, a print job refers to the task of processing an identified document using a spooling strategy. The print job specifies job information to be processed by the spooling strategy.","Conventional strategies commonly generate and consume job information in a variety of proprietary and narrowly tailored formats. The lack of versatility, sophistication and uniformity in these formats can prevent the device from rendering job information in an efficient manner. Further, known conventional strategies do not provide versatile techniques for associating metadata with the job information. Known conventional strategies may suffer from yet additional unspecified deficiencies.","There is accordingly an exemplary need for more efficient strategies for using a spool storage.","A hierarchical spooling data structure is described herein.","In accordance with certain aspects, job information stored in a spool storage has a plurality of nodes organized into a hierarchical arrangement representing the job information. The plurality of nodes include a first node representing a fixed page (a fixed layout, static content page) of the job, and a second node representing a fixed document (a fixed layout, static content document composed of fixed pages) of the job, the second node including a reference to the first node. The plurality of nodes further includes a third node containing data representing a fixed sequence of documents of the job (a fixed layout, static content sequence composed of fixed documents), the third node including a reference to the second node. The plurality of nodes may also include a fourth node containing data representing a root of the job, the fourth node including a reference to the third node.","The following description sets forth an example hierarchical structure to be used in the generation and\/or consumption of job information. In a production phase, the structured job information can be created and stored in a spool storage. In a consumption phase, the job information can then be retrieved from this storage for processing.","The term \u201cjob\u201d used herein refers to a task in which one or more actions are performed to process a consolidated grouping information. For instance, a print job may entail printing job information that defines one or more documents. More generally, reference to \u201cprocessing\u201d job information can refer to any performing of operations using or based on such job information, such as any kind of rendering of the job information (e.g., printing or displaying the job information), distributing the job information to a target destination (with or without modifying it), archiving the job information, altering the job information based on metadata associated with the job information, making decisions regarding how to render or otherwise process the job information, or some other form of processing. The term \u201cjob information\u201d refers to any kind of information used to specify the nature of the job, such as the actual information to be rendered, and\/or information that defines how the job is to be rendered, and so on.","A \u201cpackage\u201d is a logical concept that refers to a collection of job information that comprehensively specifies an entire job. The package can contain multiple parts, also referred to as \u201celements\u201d or \u201cfeatures\u201d herein. In the case where the job information defines a hierarchical tree of nodes, such nodes may define respective elements in the package. Collections of elements can be treated as a single unit. For instance, a package may specify multiple documents, and each of these collections can contain multiple elements (e.g., image resources, font resources, etc.).","The term \u201cdocument\u201d as used herein refers to any unit of any kind of information. For example, a document may pertain to information created by a text editing application, a spreadsheet processing program, a drawing program, and so on. Each document can have multiple associated parts, each of which can itself be considered a component document in its own right. A job can specify documents that originate from multiple different sources.","The term \u201cspool storage\u201d represents storage for storing job information implemented using any physical storage medium. In one case, the spool storage may be implemented using RAM memory. In another case, the spool storage may be implemented using disk storage, solid state memory, or another type of physical storage medium. The spool storage can be fixed or removable. The spool storage may define a single file, a collection of associated files, or some other storage strategy. A unit of spool storage (such as a single file) that stores an entire package defining a job is also referred to as a \u201ccontainer.\u201d","More generally, any of the functions described herein can be implemented using software, firmware (e.g., fixed logic circuitry), manual processing, or a combination of these implementations. The terms \u201cmodule,\u201d \u201cfunctionality,\u201d and \u201clogic\u201d as used herein generally represent software, firmware, or a combination of software and firmware. In the case of a software implementation, the terms \u201cmodule,\u201d \u201cfunctionality,\u201d or \u201clogic\u201d represent program code that performs specified tasks when executed on a processing device or devices (e.g., CPU or CPUs). The program code can be stored in one or more fixed and\/or removable computer readable memory devices.","The above-mentioned processing device(s) can be implemented in different ways. For example, the processing device(s) can be implemented using semiconductor transistor-based computing mechanisms (e.g., by electronic integrated circuits (ICs) or fixed electronic logic circuitry). Alternatively, the processing device(s) can be implemented, in whole or in part, using quantum computing mechanisms, optical computing mechanisms, mechanical computing mechanisms, biological computing mechanisms, and so forth.","Certain discussions in this disclosure are framed in the exemplary context of an object-oriented programming paradigm. By way of background, in such an approach, an application implements program modules as respective objects. Objects can include properties which convey attributes of the objects (e.g., the characteristics or traits of the objects). Objects can include methods associated therewith that provide functions that can be performed by the objects. Objects interact by passing messages to each other. The object-oriented programming paradigm commonly organizes objects in parent-child hierarchies. A child inherits the properties of its parent. A class refers to a general \u201cblueprint\u201d which describes a collection of objects. However, the principles described herein are not to be construed as limited to an object-oriented programming paradigm.","This disclosure includes the following sections. Section A describes an exemplary system for producing and consuming structured job information. Section B describes an exemplary flowchart which explains the operation of the system of Section A. Section C describes an exemplary computer environment for implementing the system of Section A.","A. Exemplary System","A.1. Overview of System",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 1","b":["100","102","102","104","102","106","102","108"]},"This Section (i.e., Section A.1) provides an overview of the system  used to produce and consume the structured job information . The next Section (i.e., Section A.2) delves into greater detail regarding the organization of the job information  itself.","By way of overview, the system  includes an application module  coupled to a spool storage  via interface functionality  (which can be implemented, in one example, as an application programming interface (API)). The spool storage  stores the job information . This chain of components implements the production aspects () of the processing of the job information . The system  also includes a spooling module  that is configured to retrieve the job information  from the spool storage  and then perform some kind of processing on it to provide an output result. This chain of components implements the consumption () aspects of the processing of the job information . As noted above, processing can refer to any kind of action performed on the job information , which may or may not modify the content of the job information . The processing may comprise printing the job information , displaying the job information , routing the job information  to a target location (with or without modifying it), archiving the job information , and so on. In any case, the recipient of the output result generated by the spooling module  can comprise one or more of the target entities (, , , . . . ) associated with different usage cases . A variety of the usage cases  will be discussed below.","The modules, logic and storage units shown in the system  can be implemented by any variety and grouping of physical mechanisms and devices. In one exemplary case, a computing device (not shown) implements the application module , interface functionality , spool storage  and spooling module . More specifically, the various logic and modules (, , , ) can be implemented by machine readable code stored in the memory of the computing device and executed by the processing unit(s) of the computing device. The spool storage  can be implemented by a storage medium (e.g., a hard disk) provided by the computing device. The computing device can operate using any kind of platform (e.g., as defined by the operating system and\/or other software configuration of the computing device). More specifically, in one implementation, the functionality and associated formats to be described below are specifically configured to operate using different computing platforms, thus defining a standard approach that has wide applicability to different technical environments and which thus serves to facilitate interaction among different technical environments and associated users.","In one case, the target entities (, , , . . . ) can be implemented as devices that are separate from the computing device which implements the other components (-) of the system . The computing device can be communicatively coupled to the target entities (, , , . . . ) via any kind of communication channel, such as is USB coupling, parallel coupling, network coupling of any kind, manual transport of removable media, and so forth. In a common case, for instance, one or more of the target entities (, , , . . . ) can comprise printers for printing documents fed to them by the spooling module . The computing device can be communicatively coupled to the printer(s) via any kind of hardwired and\/or wireless links using any kind of communication protocol. Or the spool storage  can be implemented as a removable media and transported to the printer. The target entities (, , , . . . ) can alternatively represent display devices, storage devices, other computing devices, and so on.","The above allocation of system  functions to devices is only exemplary. In other implementations, different aspects of the system  can be implemented by separate computing devices. For instance, a first computing device can implement the application module  and a separate computing device can implement the spooling module . In other implementations, the spool storage  can also be implemented as a separate unit which couples to the computing device which implements the application module  and\/or the spooling module . In other implementations, the target entities (, , , . . . ) can be integrated into the same computing device which implements the application module  and\/or the spool module . Still other configurations are possible.","In any event, where one or more computing devices are used to perform aspects of the system , those computing devices can correspond to any type of computing devices, such as general purpose computing devices, application-specific computing devices (e.g., game consoles such as Xbox\u00ae video game systems produced by Microsoft Corporation of Redmond, Wash.), portable computing devices (such as a personal digital assistants, mobile phones, etc.), and so on. , to be discussed below in turn, shows one exemplary computer environment for implementing aspects of the system .","Further details regarding each of the above-identified components of the system  will follow. Beginning with the production aspect () of the system , the system  can use any kind of application module  to generate any kind of document. Common types of application modules  include text processing programs, spreadsheet processing programs, graphics processing programs, markup language processing programs, database search and retrieval programs, and so on. There is no constraint on the type of application program that can be used to supply job information  to be processed using the system . The application module  can represent a program implemented in any programming environment; for example, the application module  can be implemented as a managed program within the Microsoft Corporation's NET programming environment.","The interface functionality  formats the output of the application module  into the structure  of the job information . Generally, exemplary and non-limiting functions performed by the interface functionality  can include: (1) persisting the job information  in the spool storage  having the desired structure ; (2) submitting job information  to the spooling module  for scheduling and printing; (3) monitoring different stages of the job production and hooking up to back end notifications to inform any interested listening entities; (4) monitoring different stages of the job consumption and hooking up to back end notifications to inform any interested listening entities; (5) enabling the spooling module  to send output data to the target entities (, , , . . . ), and so on. The interface functionality  also provides functionality for retrieving information regarding the job information , and for enabling the generation of notifications for various events pertaining to the production and consumption of the job information .","In one implementation, interface functionality  produces the same uniform structure  regardless of the nature of the application module  which supplies the job data. For instance, the same interface functionality  can transform the output of a text editing application, spreadsheet application, graphics processing program, and so forth into the uniform structure . In another implementation, each application module  may include specifically tailored software to work in conjunction with the interface functionality  to provide the uniform structure . In such implementations, each application module  produces the uniform structure . Alternatively, or in addition, the spooling module  can play a role in the generation of the job information  having the uniform structure .","With respect to the consumption () aspect of the system , the system  retrieves the job information  from the spool storage  and supplies it to the spooling module  for processing. The spooling module  itself can represent a software program implemented by the same computing device that provides the application module . It includes processing logic  for processing the job information . The processing logic  can also be viewed as a printer driver. This processing logic , in turn, can include management logic  for governing various operations performed by the processing logic .","The processing logic  can include filter logic  for actually performing the required processing on the job information . As will be described in greater detail below, the filter logic  can include one or more filters (, , . . . ) for performing different processing functions on the job information  to generate an output result or gather information regarding the job information or the target entities (, , , . . . ). The spooling module  then feeds the final output result to one or more of the target entities (, , , . . . ) via device port logic . In the common case of printing, one or more of the target entities (, , , . . . ) can comprise a printer which receives the output result and prints the document(s) specified by the output result. Finally, the spooling module  can also include generically-labeled other logic  for performing other functions that are not pertinent to the focus of this disclosure and therefore will not be described further herein.","Further details regarding the filter logic  are provided as follows. In one implementation, the job information  that is processed by one or more of the filters (, , . . . ) retains the same format structure  as the job information  stored in the spooler storage . Thus, in this exemplary implementation, the filter logic  does not require that the job information  be converted into an intermediary form in order to process it. This, in turn, enables the spooling module  to process job information  in an efficient manner. This also yields a uniform approach compared to other techniques which resort to a complicated assortment of disparate and ad hoc processing techniques to deal with different proprietary formats.","The functions performed by the individual filters (, , . . . ) can be generalized in the following manner. A first class of filters accepts job information  which conforms to the structure , performs some kind of processing on this information  (which may or may not modify the information ), and then generates an output result which also conforms to the structure . A second class of filters accepts job information  which conforms to the structure , performs some kind of processing on this information , and then generates an output result which does not conform to the structure  (or which only partially conforms to the structure ). A third class of filters accepts job information  which has already been converted into a non-structured format, and provides yet further modification or processing of such non-structured information.","More specifically, for example, one or more initial filters of the first class can be set up to modify the job information  in various ways (such as by adding a watermark, etc.), but does not otherwise change its basic format structure . A terminal filter (or multiple terminal filters) of the second class can be set up to modify the job information  by changing its format, such as by either completely removing its format structure  or at least partially modifying its format structure . More specifically, the terminal filter n (e.g., filter n ) (or plural terminal filters) can be used to convert job information  having the format structure  into a non-structured form that can be interpreted by an identified target entity (, , , . . . ). In effect, the terminal filter n  (or filters) thus serves the role of a rendering module of a printer driver. For instance, filter n  may convert the job information  having the structure  into a page description language (PDL) format that can be fed to a printer which accepts such format. In another case, a filter n- can convert the job information  into a printer-interpretable format, and filter n  can perform post-processing on this format, such that the combination of filter n- and filter n can be considered as the printer driver.","Suppose, as explained above, that the terminal filter n  is a filter of the first class which generates an output result having job information  which still conforms to the structure . A target entity  represents an appropriate device to receive such an output result. This target entity  is referred to as \u201cstructure-aware\u201d because it receives job information  conforming to the structure  and thus provides necessary processing functioning to recognize such information  and process it appropriately.","Suppose, alternatively, that the terminal filter n  is a filter of the second class or third class which generates job information which no longer conforms to the structure . A target entity  represents an appropriate entity to receive such an output result. This target entity  is referred to as \u201cstructure-unaware\u201d because it receives job information  that no longer conforms to the structure , and thus the entity  does not need to devote any specialized functionality for processing information expressed in this structure ; indeed, the target entity  need not, and generally will not, be aware that the job information  its receives (e.g., in an appropriate PDL format) was ever originally expressed using the structure .","There is a third case where the terminal filter n  generates an output result which modifies the structured format  to some extent, but still maintains some vestiges of the structure . Target entity  is an example of the kind of entity that can receive and process this output result.  identifies this kind of entity  as being \u201cpartially structure-aware\u201d because it should include at least some processing functionality for interpreting whatever remnants of the structure  that still remain in the output result.","Some filters may not alter the job information, but rather gather information regarding the job information or the target entities (, , , . . . ). Such filters may generate an output result of job information that is the same as the job information that is input to them, or alternatively may not output any job information. Rather than (or in addition to) outputting job information, such filters may output the information they have gathered. For example, a filter may be used to count the consumables the job uses and report to the usage back to an accounting application running on the same computing device as spooling module .","Different jobs may require that different filtering operations be performed on the associated job information . A filter configuration module (not shown) can be used to define what filters (, , . . . ) are to be invoked in processing a particular job, how the individuals filters (, , . . . ) are to be configured, and how the filters (, , . . . ) are to be chained together. In other words, the spooling module  can chain the filters (, , . . . ) together in different ways to produce different net effects. In a series configuration shown in , for example, filter A  feeds its output result into the input of filter B , and filter B  feed its output result into to the input of filter C (not shown), and so on.","More specifically, the type of processing that the filter logic  performs on the job information  can be controlled, in element, by one or more \u201cprint tickets\u201d associated with the job information . The print tickets include attribute information that defines the operations that should be performed on the job information  as it passes through the filter logic . Different print tickets can be associated with different elements of the structure  of the job information , as will be described in the next subsection (A.2).","The system  can also function in a client-server mode of operation, where the spooling module  responds to requests from a client module (which may comprise one of the target entities). In a client-server implementation, a server-side application (not shown) creates document content \u201con-the-fly\u201d in response to a client request. A server process generates parts of the job information , one at a time; while a separate process, at the same time, pulls parts from the job information , one at a time, to send \u201cdown\u201d to the client module.","A.2. Overview of Structured Job Information Format","As shown in , the job information  generally includes a structure  defined by a plurality of nodes coupled together according to a set of established rules. The same general rules can apply to the construction and consumption of the structure  regardless of the application and application platform used to produce and consume the job information . The strategies described below therefore provide a standardized mechanism for sharing job information among participants within different programming environments.","The job information  uses a hierarchical scheme to connect its nodes together. A hierarchical scheme couples the nodes together using parent-child relationships. That is, a \u201ctop-most\u201d node defines a so-called root node. The root node includes one or more child nodes, and the child nodes, in turn, can include one or more of their own respective child nodes, and so on. The child nodes can optionally inherit methods, properties, metadata, etc. associated with their respective parent\/ancestor nodes.","Generally, the structure  is a logical concept that may or may not map to actual elements of a document to be rendered. That is, each node may be considered an object. Certain objects may represent actual elements of a document to be rendered (such as various image resources and font resources). Other objects may not have a one-to-one relationship with elements of the documents to be rendered. These latter types of nodes are therefore analogous to folders in a file hierarchy; that is, the folders may store individual files that contain content that maps to actual elements of the document, but the folders themselves may not have a one-to-one relationship with actual elements of the document.",{"@attributes":{"id":"p-0055","num":"0054"},"figref":["FIG. 2","FIG. 1"],"b":["200","102","108","200","102","110","110","108","114","110","116","108"]},"The top level of the hierarchy specifies job-related information  that identifies the entire job itself. For instance, the job may pertain to the printing of multiple books, each book including multiple chapters, and each chapter, in turn, can include multiple pages, and each page, in turn, can include font resources and image resources. It should be noted that although resources are associated with job level , resources can be referenced or used by other levels in schema . In this example, the top level of the hierarchy identifies the logical package which encapsulates the entire job, that is, the entire book. The next level of the hierarchy specifies information  that identifies the document sequences associated with the job. In the example of the multiple books, the document sequence level might specify individual ones of the multiple books.","The next level of the hierarchy specifies information  that identifies the documents associated with the job. In the example of the multiple books, the document level might specify individual chapters in the books. Or this level of the hierarchy may specify different kinds of documents to be printed in a single print job, such as a first document created using a text editor, and a second document created using a spreadsheet program, and so on, where these two documents together comprise a report of some kind.","The next level of the hierarchy specifies information  that identifies different pages within the documents identified in the proceeding level.","Resources can be associated with the root level of the hierarchy defined by schema , which is job level . Although resources are associated with the root level of the hierarchy, other levels in the hierarchy can reference resources, as discussed in more detail below. This allows resources to be shared by the different levels of the hierarchy, even though they are associated with the root level of the hierarchy. Particular types of resources can include an image resource , a font resource , or some other resource .","Further, metadata  can be associated with any of the levels of the hierarchy of the schema . For instance, exemplary metadata  can be associated with the job level , the document sequence level , the document level , and\/or the page level . Metadata  specifies any supplemental information pertaining to the job information , such as an author who created a document contained in the job, a time when the document was created, various keywords pertaining to the content, a summary of the content, and so on. There are no restrictions on the type of, and meaning assigned to, metadata that can be appended to different elements of the schema . A particular kind of metadata is a print ticket . The print ticket  can also be associated with any level of the hierarchy of the schema . For instance, exemplary metadata  can be associated with the job level , the document sequence level , the document level , and\/or the page level . A print ticket defines the types of processing operations that should be performed on associated elements of the hierarchy of the job information . For instance, a print ticket associated with the job package level  will apply to the entirety of the package defined by the job information . A print ticket associated with an individual page  of the job information  will have a localized effect by only affecting that page . Further details regarding exemplary print tickets are provided in the above-captioned co-pending U.S. patent application Ser. No. 10\/794,669.","Further, inheritance may optionally apply to the methods, properties, metadata, etc. in the job information . If inheritance is used, to determine what print instructions apply to any given node, the spooling module  can \u201cwalk\u201d the tree from a child node to its root (or vice versa), aggregating any print instructions that may apply along the way. This aggregation allows general instructions to be uniformly inherited by all children. A print instruction of a child node may override the general instructions of a parent node.","In summary, the schema  shown in  provides a powerful, uniform and versatile mechanism for representing complex job information, particularly for those jobs that involve multiple document sequences and\/or multiple documents. Traditional techniques provide no provisions for representing these kinds of complex scenarios in spool storage; therefore, these traditional techniques suffer from inefficiencies, which may be significant.","In one implementation, the hierarchy of the job information  is set to provide defined levels corresponding to jobs, document sequences, documents, and pages. In another implementation, the hierarchy can be varied in one or more respects.","To further clarify the exemplary schema ,  shows one exemplary instantiation  of the schema . The entire collection of nodes shown in  defines a package. The package includes a root node  associated with the entire package, e.g., the entire job. These different nodes in the package are also referred to herein as different \u201cparts\u201d of the package or job.","Some of the nodes in the package are also referred to as being \u201cfixed\u201d, such as the fixed document sequence nodes and the fixed document nodes. A fixed node refers to a node that is already laid out properly for rendering and that has static content. A fixed page node or fixed page refers to a fixed layout, static content page. A fixed document node or fixed document refers to a fixed layout, static content document composed of fixed pages. A fixed document sequence node or fixed document sequence refers to a fixed layout, static content document sequence composed of fixed documents. For example, a fixed document node refers to a document that is already laid out properly for printing on a particular size of paper (e.g., letter size, A4 size, legal size, postcard size, etc.)\u2014the organization of text and\/or graphics on the page has already been determined for the particular size of paper on which the job is to be printed. This layout for the job is determined when the structured job information  is created, and is typically created by the same component or module as creates the structured job information  (e.g., the interface functionality  or the application module  of ).","An index can be associated with the package, and hence with the root node . This index can be used to locate the package in the spool storage .","The job defined by the root node  includes a number of fixed document sequences, as identified by fixed document sequence node  and fixed document sequence node . Also, a metadata node  is associated with the root node . If so configured, the metadata node  associated with the root node (job node)  defines properties which apply to the job as a whole.","Each of the fixed document sequences associated with nodes  and  can include multiple fixed documents associated therewith. For example, the fixed document sequence represented by node  includes at least two fixed documents identified by nodes  and .","In addition to fixed document nodes (, ), node  also includes nodes  and  associated therewith. Node  specifies metadata associated with node  and node  specifies a print ticket associated with node .","Each fixed document includes one or more fixed pages associated therewith. Nodes  and , for example, represent fixed pages associated with fixed document node . Metadata node  indicates that metadata can be associated with the document level of the hierarchy (as it can for any level). Print ticket node  indicates that resource information can be associated with the document level (as it can for any level).","Finally, each fixed page can include page data associated therewith as well as metadata and a print ticket. For example, fixed page node  includes page data node  and metadata node  associated therewith, indicating that page data and metadata can be associated with this page. Page node  includes print ticket node  and page data node  associated therewith, indicating that a print ticket and page data can be associated with this page.","The package associated with root node  can also include a collection of resources. These resources are associated with root node , but can be referenced or used by different nodes in the job. Such collection of resources thus defines a shared library of resources that can be applied at different points within a document represented by the package. However, this shared library of resources remains associated with a single node, and thus all resources can be maintained in a single location (e.g., a single folder or directory) associated with the single node, even though they are referenced by different nodes in the job. Nodes , , and , for example, represent resources associated with job node . Resources can be, for example, image resources, font resources, or other types of resources. Image resources are images that can be used or referenced by different nodes in the job, while font resources are fonts that can be used or referenced by different nodes in the job. A metadata node  depends from the resource node , which represents metadata that applies the resource node .","Metadata can be associated with individual nodes in the hierarchical structure  in different ways. For instance, individual nodes can provide linking information that points to associated metadata, or the nodes themselves can embed such metadata as integral parts of the nodes, and so forth.","As discussed above, the different nodes in a package are also referred to as parts of the package or job. An individual part includes common properties (e.g., name and content type) and a stream of bytes. Part names are organized into a hierarchy, similar to paths on a file system. This hierarchy is composed of segments delineated by slashes. The last segment of the name is similar to a filename in a traditional file system. The segments of the names of all parts in a package form a tree.","Alternatively, the job () may be collapsed into the fixed document sequence so that the fixed document sequence (e.g., node  or ) is the root of the hierarchy. In such situations, job node  would not be included in the hierarchy, and resource nodes would be associated with the fixed document sequence node that is the root of the hierarchy (although the resource nodes could be referenced by other non-root nodes of the hierarchy).","Parts can reference or be related to other parts using Uniform Resource Identifiers (URIs) or other linking mechanisms. In certain exemplary embodiments, three different types of references or relations are defined: spines, references, and relationships. A spine (or spine reference) refers to a reference from a source part that identifies a target part, where both the source and target parts are fixed (e.g., references from a fixed document sequence to fixed documents, and references from fixed documents to fixed pages). Spines are indicated in  by a solid line. The source part of the spine is typically made up of only spine references to other parts\u2014there is typically no additional text and\/or graphic data associated with the source part. Spines can be represented using the Extensible Markup Language (XML).","A reference is similar to a spine, but the source and target parts need not be fixed and the target part is a resource. Any document-related node in the package can reference any resource node, indicating that a particular element or aspect of the document is referencing a particular resource for use thereat. This reference can be made even though the resources are associated with only the root nodes. For instance, in the exemplary case of , fixed page node  references resource node . This reference is indicated in  with a dashed line terminating with an arrow head. This means that the resource represented by node  is used in the page represented by fixed page node . Further, fixed page node  references resource nodes  and , indicting that the resource associated with node  and the resource associated with node  are used in the page associated with node . These references are indicated by two respective dashed lines. References can be represented using XML.","Relationships provide a way to associate nodes with metadata. Any node can be a source node, and a metadata node is the target node. Relationships allow this association to be represented without modifying the parts. As such, relationships make the connections between parts directly \u201cdiscoverable\u201d without examining the content in the parts. This makes the connections independent of content-specific schema, and also allows the connections to be resolved more quickly. Relationships are indicated in  by an alternating dot-dash line.","Relationships can be represented using XML using relationship parts. Namely, each part in the job information  that is the source of one or more relationships has an associated relationship part. This relationship part holds the list of relationships for the source part (e.g., expressed in XML using a content type application\/vnd.ms-metro.relationships+xml).","Different strategies can be used to link the elements together to form the hierarchies shown in . In one technique, the individual elements can be modified so that they point to linked objects (e.g., parent and child objects). Linking can be provided by pointers, Uniform Resource Locators (URLs), or some other referencing mechanism. Alternatively, or in addition, separate relationship information can be defined that specifies how separate elements are linked together. This separate relationship information thus serves as a blueprint for linking together separate objects in the job information. Among other implementations, the Extensible Markup Language (XML), or other markup language, can be used, in whole or in part, to specify the elements in the hierarchies shown in  and the relationships among these elements.","Specific examples of XML code that specify elements in the hierarchies shown in  are illustrated in Tables I through IV below.","Table I illustrates an example of XML code that specifies a fixed document sequence node. Fixed document nodes are child nodes of a fixed document sequence node. These child nodes are referenced from the fixed document sequence node as spine references. Fixed document nodes are referenced using a <DocumentReference> element and a source attribute that specifies the URI of the fixed document part being referenced.",{"@attributes":{"id":"p-0083","num":"0082"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE I"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"1\u2003\u2003<FixedDocumentSequence xmlns="]},{"entry":[{},"\u2002\u2003\u2003\u201cschemas.microsoft.com\/metro\/2005\/02\/rp\u201d>"]},{"entry":[{},"2\u2003\u2003\u2003<DocumentReference Source=\u201cFixedDoc1\u201d\/>"]},{"entry":[{},"3\u2003\u2003\u2003<DocumentReference Source=\u201cFixedDoc2\u201d\/>"]},{"entry":[{},"4\u2003\u2003<\/FixedDocumentSequence>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"As seen in line 1 of the example XML of Table I, the fixed document sequence node identifies a namespace that is used to specify the elements of the hierarchies shown in . Lines 2 and 3 each include a <DocumentReference> element that identifies a particular fixed document that is part of the fixed document sequence (\u201cFixedDoc1\u201d in line 2, and \u201cFixedDoc2\u201d in line 3).","Table II illustrates an example of XML code that specifies a fixed document node. The fixed document node identifies one or more fixed page nodes. The fixed document node can include one or more <FixedDocument> elements as well as one or more <PageContent> elements. The <FixedDocument> element logically binds an ordered sequence of pages together into a single multi-page document.","The <PageContent> element is the child element of the <FixedDocument> element. Each <PageContent> element refers to the source of the content for a single page (that is, to a fixed page node). Each <PageContent> element may optionally include a height and width attribute reflecting the size of a single page. The required page size is specified in the fixed page part; the optional size on <PageContent> is advisory only. The <PageContent> size attributes allow applications such as viewers to make visual layout estimates for content quickly, without loading and parsing all of the individual fixed page parts.",{"@attributes":{"id":"p-0087","num":"0086"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE II"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"1\u2003\u2003<FixedDocument"]},{"entry":[{},"\u2002\u2003\u2003xmlns=\u201chttp:\/\/schemas.microsoft.com\/metro\/2005\/02\/rp\u201d>"]},{"entry":[{},"2\u2003\u2003\u2003\u2003<PageContent"]},{"entry":[{},"\u2002\u2003\u2003Source=\u201c..\/FixedPages\/FixedPage_1.xaml\u201d><\/PageContent>"]},{"entry":[{},"3\u2003\u2003\u2003\u2003<PageContent"]},{"entry":[{},"\u2002\u2003\u2003Source=\u201c..\/FixedPages\/FixedPage_2.xaml\u201d><\/PageContent>"]},{"entry":[{},"4\u2003\u2003\u2003\u2003<PageContent"]},{"entry":[{},"\u2002\u2003\u2003Source=\u201c..\/FixedPages\/FixedPage_3.xaml\u201d><\/PageContent>"]},{"entry":[{},"5\u2003\u2003\u2003\u2003<PageContent"]},{"entry":[{},"\u2002\u2003\u2003Source=\u201c..\/FixedPages\/FixedPage_4.xaml\u201d><\/PageContent>"]},{"entry":[{},"6\u2003\u2003\u2003\u2003<PageContent"]},{"entry":[{},"\u2002\u2003\u2003Source=\u201c..\/FixedPages\/FixedPage_5.xaml\u201d><\/PageContent>"]},{"entry":[{},"7\u2003\u2003\u2003\u2003<PageContent"]},{"entry":[{},"\u2002\u2003\u2003Source=\u201c..\/FixedPages\/FixedPage_6.xaml\u201d><\/PageContent>"]},{"entry":[{},"8\u2003\u2003<\/FixedDocument>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"As seen in line 1 of the example XML of Table II, the fixed document node identifies a namespace that is used to specify the elements of the hierarchies shown in . Lines 2-7 each include a <PageContent> element that identifies a particular fixed page that is part of the fixed document (e.g., \u201cFixedPage1 in line 2, \u201cFixedPage2\u201d in line 3, and so forth).","Table III illustrates an example of XML code that specifies a fixed page node. Each fixed page node represents the content of a page in a <FixedPage> element with <Path> and <Glyphs> elements, using the <Canvas> element to group them. The <Path> and <Glyphs> elements are together the base for all marks rendered on a FixedPage. The <Path> element has a region and a fill. A path is described by specifying a Geometry.Data child element and the rendering attributes, such as fill or opacity. The <Glyphs> element is used to represent a run of text, all from the same font. The <Glyphs> element provides information for accurate rendering, as well as supporting search and selection features in viewers.","The <Canvas> elements, <Path> elements, and <Glyph> elements include references to a brush or brush element. A brush can be used, for example, to paint the interior of geometric shapes defined by a <Path> element, to fill the character outlines rendered with a <Glyphs> element, and to define the alpha-transparency mask in opacity mask attributes. Examples of brush elements include a <SolidColorBrush> element, an I<ImageBrush> element, a <VisualBrush> element, a <LinearGradientBrush> element, and a <RadialGradientBrush> element.","The <SolidColorBrush> element fills defined geometric regions with a solid color. The <SolidColorBrush> element can include one or more of an opacity attribute, a transform attribute, and a color attribute. The opacity attribute specifies uniform transparency of the brush fill, for example ranging from 0 (fully transparent) to 1 (fully opaque). The transform attribute describes a matrix transform applied to the brush's coordinate space. The transform property on a brush is concatenated with the current effective render transform to yield an effective render transform local to the brush. The color attribute specifies a color for filled elements, such as an sRGB color value specified as 6-digit hexadecimal number or an sARGB color value specified as 8-digit hexadecimal number.","The <SolidColorBrush> element can have a transform element as a child The transform element specifies the transformation that is applied to the brush. This transformation is applied after the brush's output has been mapped and positioned.","The <ImageBrush> element can be used to fill a space with an image. The <ImageBrush> element can include one or more of an opacity attribute, a transform attribute, a view box attribute, a view port attribute, a stretch attribute, a tile mode attribute, a view box units attribute, a view port units attribute, and a bitmap source attribute. The opacity attribute specifies uniform transparency of the brush fill, for example ranging from 0 (fully transparent) to 1 (fully opaque). The transform attribute describes a matrix transform applied to the brush's coordinate space. The transform property on a brush is concatenated with the current effective render transform to yield an effective render transform local to the brush. The view box attribute specifies a new coordinate system for the contents\u2014it redefines the extent and origin of the view port. The view box is expressed as a list of four \u2018unitless\u2019 (real) numbers <min-x>, <min-y>, <width> and <height>, separated by commas. The dimensions specified in the view box attribute are relative to the image's physical dimensions (e.g., expressed in units of 1\/96 of an inch). The image's physical dimensions are calculated by dividing the image's horizontal dimension in pixels by the horizontal image resolution and the image's vertical dimension in pixels by the vertical image resolution.","The view port attribute specifies a coordinate system in which to position contents. The view port is expressed as a list of four real numbers <min-x>, <min-y>, <width> and <height>, separated by commas. The rectangle defined by the view port is specified in user coordinates and defines the brush tile that is repeatedly applied to fill a Path. The stretch attribute specifies how the contents of a view box are mapped to a view port. The tile mode attribute specifies how contents will be tiled in the filled region. The view box units attribute specifies the relation of view box coordinates to coordinates of the image as absolute. The view port units attribute specifies the relation of view port coordinates to current user coordinates as absolute. The bit map source attribute specifies the URI of an image resource that can be used as the image to fill the space.","The <ImageBrush> element can have a transform element as a child. The transform element describes a matrix transform applied to the brush's coordinate space. The Transform property on a brush is concatenated with the current effective render transform to yield an effective render transform local to the brush. The view port for the brush is then transformed using that local effective render transform.","The <VisualBrush> element can be used to fill a space with a vector drawing. The drawing can be specified as a child element of the <VisualBrush> element, or as a resource reference. The <VisualBrush> element can include one or more of an opacity attribute, a transform attribute, a view box attribute, a view port attribute, a stretch attribute, a tile mode attribute, a view box units attribute, and a view port units attribute. These attributes are analogous to those discussed above with respect to the <ImageBrush> element.","The <VisualBrush> element can have a transform element and\/or a visual element as a child. The transform element describes a matrix transform applied to the brush's coordinate space. The Transform property on a brush is concatenated with the current effective render transform to yield an effective render transform local to the brush. The view port for the brush is then transformed using that local effective render transform. The visual element is a generic definition of an element that could be displayed on a surface.","The <LinearGradientBrush> element can be used to fill a region with a linear gradient. The <LinearGradientBrush> element can include one or more of an opacity attribute, a transform attribute, a color interpolation mode attribute, a spread method attribute, a mapping mode attribute, a start point attribute, and an end point attribute. The opacity attribute specifies uniform transparency of the linear gradient, for example ranging from 0 (fully transparent) to 1 (fully opaque). The transform attribute describes a matrix transform applied to the coordinate space of the linear gradient.","The color interpolation mode attribute specifies the gamma space for color interpolation for non-extended sRGB colors. For extended colors, only linear color interpolation (no gamma) is typically used. The spread method attribute specifies how the brush should fill the content area outside of the primary, initial gradient area. The mapping mode attribute specifies an absolute interpretation of the coordinates specified by the start point and end point attributes. The start point attribute specifies a start point of the linear gradient. The end point attribute specifies the end point of the linear gradient. The linear gradient brush interpolates the colors from the start point to the end point (e.g., where the start point represents offset 0 and the end point represents offset 1). The offset attribute value specified in a gradient stop element relates to the offsets defined by the start point and the end point.","The <LinearGradientBrush> element can have a gradient stops element as a child. The gradient stops element holds a sequence of gradient stop elements that are sorted in ascending order by an offset attribute value, maintaining the relative order of GradientStops with the same Offset attribute value.","The <RadialGradientBrush> element can be used to fill a region with a radial gradient. The <RadialGradientBrush> element is similar to the <LinearGradientBrush> element, however, whereas the linear gradient has a start and end point to define the gradient vector, the radial gradient has an ellipse along with a gradient origin to define the gradient behavior. The ellipse defines the end point of the gradient\u2014in other words, a gradient stop at 1.0 defines the color at the circumference of the ellipse. The gradient origin defines the center of the gradient. A gradient stop at 0.0 defines the color at the gradient origin.","The <RadialGradientBrush> element can have can include one or more of an opacity attribute, a transform attribute, a color interpolation mode attribute, a spread method attribute, a mapping mode attribute, a center attribute, a gradient origin attribute, a radius X attribute, and a radius Y attribute. The opacity attribute specifies uniform transparency of the radial gradient, for example ranging from 0 (fully transparent) to 1 (fully opaque). The transform attribute describes a matrix transform applied to the coordinate space of the radial gradient.","The color interpolation mode attribute specifies the gamma space for color interpolation for non-extended sRGB colors. For extended colors, only linear color interpolation (no gamma) is typically used. The spread method attribute specifies how the brush should fill the content area outside of the primary, initial gradient area. The mapping mode attribute specifies an absolute interpretation of the coordinates specified by the center, gradient origin, radius X, and radius Y attributes.","The center attribute specifies the center of the radial gradient (e.g., the center of the ellipse). The radial gradient brush interpolates the colors from the gradient origin to the circumference of the ellipse. The circumference is determined by the center and the radii. The gradient origin attribute specifies the origin point of the radial gradient. The radius X attribute specifies the radius in the X dimension of the ellipse which defines the radial gradient. The radius Y attribute specifies the radius in the Y dimension of the ellipse which defines the radial gradient.","The <RadialGradientBrush> element can have a gradient stops element as a child. The gradient stops element holds a sequence of gradient stop elements that indicate a location and range of color progression for rendering a gradient.","The <Canvas> element is used to group elements together. Typically, elements of a fixed page node are grouped together in a <Canvas> element when they share a composed common attribute (e.g., opacity, clip, render transform, opacity mask, etc.). By grouping these elements together in a <Canvas> element, common attributes can often be applied to the canvas instead of to the individual elements.","The <Canvas> element can include one or more of a render transform attribute, a clip attribute, an opacity attribute, an opacity mask attribute, an ID attribute, and a navigate URI attribute. The render transform attribute specifies a new coordinate frame for the child elements of the <Canvas> element, such as another <Canvas> element. The clip attribute specifies the region to which a brush can be applied by the child elements of the <Canvas> element. The opacity attribute specifies uniform transparency of the canvas, for example ranging from 0 (fully transparent) to 1 (fully opaque).","The opacity mask attribute specifies a mask of alpha values that is applied in the same fashion as the opacity attribute, but allows different alpha value on a pixel-by-pixel basis. The ID attribute contains a string value that is used to identify the current element as a named, addressable point in the document for purposes of hyperlinking into the current document. The navigate URI attribute is used to associate a hyperlink URI with the element. This may be a relative or absolute URI addressing a resource external to the  package or internal to the package.","The <Canvas> element can have a resources element, a render transform element, a clip element, and\/or an opacity mask element as a child (children). The resources element specifies one or more resources for the <Canvas> element. The render transform element establishes a new coordinate frame for the children elements of the <Canvas> element. The clip element describes the region to which a brush can be applied by the children elements of the <Canvas> element. The opacity mask element specifies a mask of alpha value that is applied in the same fashion as the opacity attribute, but allow different alpha values on a pixel-by-pixel basis.","The <Path> element can include one or more of a data attribute, a fill attribute, a fill rule attribute, a render transform attribute, a pen attribute, a clip attribute, an opacity attribute, an opacity mask attribute, an ID attribute, and a navigate URI attribute. The data attribute specifies the geometry of the path. The fill attribute specifies the brush used to paint the geometry of the path. The fill rule attribute specifies how intersecting areas of geometric shapes are combined to form a region. The render transform attribute specifies a new coordinate frame for the children elements of the path, such as the geometry defined by Path.Data.","The pen attribute specifies a Brush used to fill the pixels of the stroke. The clip attribute specifies the region to which a brush can be applied by the path's geometry. The opacity attribute specifies uniform transparency of the filled path, for example ranging from 0 (fully transparent) to 1 (fully opaque). The opacity mask attribute specifies a mask of alpha values that is applied to the glyphs in the same fashion as the opacity attribute, but allows different alpha value for different areas of the surface. The ID attribute contains a string value that is used to identify the current element as a named, addressable point in the document for purposes of hyperlinking into the current document. The navigate URI attribute is used to associate a hyperlink URI with the element. This may be a relative or absolute URI addressing a resource external to the package or internal to the package.","The <Path> element can have a render transform element, a clip element, an opacity mask element, a fill element, a stroke element, and\/or a data element as a child (children). The render transform element establishes a new coordinate frame for the children elements of the path, such as the geometry defined by a data element. The clip element describes the region to which a brush can be applied by the path's geometry. The opacity mask element specifies a mask of alpha values that is applied in the same fashion as the opacity attribute, but allow different alpha values on a pixel-by-pixel basis. The fill element describes the brush used to paint the path's geometry. The stroke element specifies a brush used to fill the pixels of the stroke. The data element describes the path's geometry.","The <Glyph> element can include one or more of a bidi level attribute, a caret stops attribute, a device font ID attribute, a fill attribute, a font rendering size attribute, a font URI attribute, an origin X attribute, an origin Y attribute, a sideways attribute, an indices attribute, a Unicode string attribute, a style simulations attribute, a render transform attribute, a clip attribute, an opacity attribute, an opacity mask attribute, an ID attribute, and a navigate URI attribute. The bidi level attribute specifies the Unicode algorithm bidirectional nesting level, where numerically even values imply left-to-right layout, numerically odd values imply right-to-left layout. The caret stops attribute specifies the positions within the sequence of \u2018UnicodeString\u2019 characters at which a text-selection tool may place a text-editing caret. The device font ID attribute specifies an identifier (e.g., a globally unique ID or GUID) for a specific device font. The fill attribute specifies the brush used to paint the glyph outlines. The font rendering size attribute specifies the font size in drawing surface units (e.g., 1\/96 of an inch).","The font URI attribute specifies the physical font from which all glyphs in this run are drawn. The origin X attribute specifies the X coordinate of first glyph in the run (e.g., in 1\/96 of an inch). The origin Y attribute specifies the Y coordinate of first glyph in run (e.g., in 1\/96 of an inch). The sideways attribute is a flag specifying whether a glyph is turned on its side. The indices attribute specifies a series of glyph indices and their attributes representing this glyph run.","The Unicode string attribute specifies an array of characters represented by this glyph run. The style simulations attribute specifies the style simulation (e.g., italic, bold, bold italic, etc.). The render transform attribute specifies a new coordinate frame for the glyph run specified by the <Glyphs> element. The clip attribute specifies the region to which a brush can be applied to the outline of a glyph. The opacity attribute specifies uniform transparency of the filled glyph outlines, for example ranging from 0 (fully transparent) to 1 (fully opaque). The opacity mask attribute specifies a mask of alpha values that is applied to the glyphs in the same fashion as the opacity attribute, but allows different alpha value for different areas of the surface. The ID attribute contains a string value that is used to identify the current element as a named, addressable point in the document for purposes of hyperlinking into the current document. The navigate URI attribute is used to associate a hyperlink URI with the element. This may be a relative or absolute URI addressing a resource external to the package or internal to the package.","A fixed page node includes height and width attributes specifying the height and width of the page (e.g., in 1\/96 of an inch), as well as an xml:lang attribute specifying the language of the page (e.g., English, French, Japanese, etc.). A fixed page node may also reference one or more resources. A fixed page node may also optionally include a content box attribute, a bleed box attribute, and\/or a render transform attribute. A content box attribute specifies which area of the page contains imageable content that is to be fit on the imageable area when printing or viewing the page. A bleed box attribute specifies the area which includes printing-related crop-marks that may be outside of the physical page. A render transform attribute specifies a new coordinate frame for the children of the fixed page node.","The <Glyphs> element can have a render transform element, a clip element, an opacity mask element, and\/or a fill element as a child (children). The render transform element establishes a new coordinate frame for the glyph run specified by the <Glyphs> element. The clip element describes the region to which a brush can be applied to the outline of a glyph. Only portions of the <Glyphs> element that fall within the clip region, even partially clipped characters, produce marks on the page. The opacity mask element specifies a mask of alpha values that is applied to the glyphs in the same fashion as the opacity attribute, but allows different alpha values for the different areas of the surface. The fill element describes the brush used to paint the glyph outlines.",{"@attributes":{"id":"p-0118","num":"0117"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"thead":{"row":[{"entry":"TABLE III"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"1\u2002\u2003<FixedPage xmlns=\u201cschemas.microsoft.com\/winfx\/avalon\/2005\u201d"},{"entry":"\u2003\u2003xmlns:x=\u201cschemas.microsoft.com\/winfx\/xaml\/2005\u201d Width=\u201c816\u201d Height=\u201c1056\u201d"},{"entry":"\u2003\u2003Background=\u201c#FFFFFFE0\u201d>"},{"entry":"2\u2002\u2003FixedPage.Resources>"},{"entry":"3\u2002\u2003LinearGradientBrush x:Key=\u201cb0\u201d StartPoint=\u201c0.666666666666667,"},{"entry":"\u2003\u20030.666666666666667\u201d EndPoint=\u201c47.192, 24.1466666666667\u201d"},{"entry":"\u2003\u2003ColorInterpolationMode=\u201cSRgbLinearInterpolation\u201d MappingMode=\u201cAbsolute\u201d"},{"entry":"\u2003\u2003SpreadMethod=\u201cPad\u201d>"},{"entry":"4\u2002\u2003\u2003\u2003\u2003\u2003<GradientStopCollection>"},{"entry":"5\u2002\u2003\u2003\u2003\u2003\u2003\u2003\u2003<GradientStop Color=\u201c#20000000\u201d Offset=\u201c0\u201d \/>"},{"entry":"6\u2002\u2003\u2003\u2003\u2003\u2003\u2003\u2003<GradientStop Color=\u201c#00FFFFFF\u201d Offset=\u201c0.5\u201d \/>"},{"entry":"7\u2002\u2003\u2003\u2003\u2003\u2003\u2003\u2003<GradientStop Color=\u201c#80FFFFFF\u201d Offset=\u201c1\u201d \/>"},{"entry":"8\u2002\u2003\u2003\u2003\u2003\u2003<\/GradientStopCollection>"},{"entry":"9\u2002\u2003\u2003\u2003<\/LinearGradientBrush.GradientStops>"},{"entry":"10\u2003<\/LinearGradientBrush>"},{"entry":"11\u2003<LinearGradientBrush\u2003\u2003\u2003\u2003x:Key=\u201cb1\u201d\u2003\u2003\u2003StartPoint=\u201c58.8233333333333,"},{"entry":"\u2003\u200317.7633333333333\u201d\u2003\u2003\u2003\u2003EndPoint=\u201c58.8233333333333,\u2003\u2003\u200223.7633333333333\u201d"},{"entry":"\u2003\u2003ColorlnterpolationMode=\u201cSRgbLinearInterpolation\u201d\u2003\u2003MappingMode=\u201cAbsolute\u201d"},{"entry":"\u2003\u2003SpreadMethod=\u201cPad\u201d>"},{"entry":"12\u2003\u2003\u2003<LinearGradientBrush.GradientStops>"},{"entry":"13\u2003\u2003\u2003\u2003\u2003<GradientStopCollection>"},{"entry":"14\u2003\u2003\u2003\u2003\u2003\u2003\u2003<GradientStop Color=\u201c#00FFFFFF\u201d Offset=\u201c0.5\u201d \/>"},{"entry":"15\u2003\u2003\u2003\u2003\u2003\u2003\u2003<GradientStop Color=\u201c#35592F00\u201d Offset=\u201c1\u201d \/>"},{"entry":"16\u2003\u2003\u2003\u2003\u2003<\/GradientStopCollection>"},{"entry":"17\u2003\u2003\u2003<\/LinearGradientBrush.GradientStops>"},{"entry":"18\u2003<\/LinearGradientBrush>"},{"entry":"19\u2003<LinearGradientBrush\u2003\u2003\u2003\u2003x:Key=\u201cb2\u201d\u2003\u2003\u2003StartPoint=\u201c110.596666666667,"},{"entry":"\u2003\u200312.4066666666667\u201d\u2003\u2003\u2003\u2003EndPoint=\u201c116.596666666667,\u2003\u2003\u200212.4066666666667\u201d"},{"entry":"\u2003\u2003ColorInterpolationMode=\u201cSRgbLinearInterpolation\u201d\u2003\u2003MappingMode=\u201cAbsolute\u201d"},{"entry":"\u2003\u2003SpreadMethod=\u201cPad\u201d>"},{"entry":"20\u2003\u2003\u2003<LinearGradientBrush.GradientStops>"},{"entry":"21\u2003\u2003\u2003\u2003\u2003<GradientStopCollection>"},{"entry":"22\u2003\u2003\u2003\u2003\u2003\u2003\u2003<GradientStop Color=\u201c#00FFFFFF\u201d Offset=\u201c0.5\u201d \/>"},{"entry":"23\u2003\u2003\u2003\u2003\u2003\u2003\u2003<GradientStop Color=\u201c#28592F00\u201d Offset=\u201c1\u201d \/>"},{"entry":"24\u2003\u2003\u2003\u2003\u2003<\/GradientStopCollection>"},{"entry":"25\u2003\u2003\u2003<\/LinearGradientBrush.GradientStops>"},{"entry":"26\u2003<\/LinearGradientBrush>"},{"entry":"27\u2003<\/FixedPage.Resources>"},{"entry":"28\u2003. . ."},{"entry":"\u2003\u2003<Glyphs OriginX=\u201c0\u201d OriginY=\u201c32.59\u201d FontRenderingEmSize=\u201c36\u201d"},{"entry":"\u2003\u2003FontUri=\u201c\/Resources\/Fonts\/Font_1.ttf\u201d UnicodeString=\u201cTopLeft\u201d"},{"entry":"\u2003\u2003Fill=\u201c#00008B\u201d \/><!--System.Windows.Controls.TextBlock--><Glyphs"},{"entry":"\u2003\u2003OriginX=\u201c0\u201d OriginY=\u201c49.9033333333333\u201d FontRenderingEmSize=\u201c56\u201d"},{"entry":"\u2003\u2003FontUri=\u201c\/Resources\/Fonts\/Font_2.ttf\u201d UnicodeString=\u201cBottomRight\u201d"},{"entry":"\u2003\u2003Fill=\u201c#FFE4C4\u201d><Glyphs.RenderTransform><MatrixTransform"},{"entry":"\u2003\u2003Matrix=\u201c1,0,0,1,520,750\u201d \/><\/Glyphs.RenderTransform><\/Glyphs><!--"},{"entry":"\u2003\u2003System.Windows.Controls.TextBlock-->"},{"entry":"\u2003\u2003. . ."},{"entry":"\u2003\u2003<Path Fill=\u201c#FF0000\u201d><Path.RenderTransform><MatrixTransform"},{"entry":"\u2003\u2003Matrix=\u201c1,0,0,1,150,150\u201d"},{"entry":"\u2003\u2003\/><\/Path.RenderTransform><Path.Data><PathGeometry"},{"entry":"\u2003\u2003FillRule=\u201cEvenOdd\u201d><PathFigure><StartSegment Point=\u201c0,\u20020\u201d"},{"entry":"\u2003\u2003\/><PolyLineSegment Points=\u201c300,\u20020\u2002300,\u2002300\u20020,\u2002300\u201d\u2002\/><CloseSegment"},{"entry":"\u2003\u2003\/><\/PathFigure><\/PathGeometry><\/Path.Data><\/Path>"},{"entry":"\u2003\u2003<Canvas><Canvas.RenderTransform><MatrixTransform Matrix=\u201c1,0,0,1,80,250\u201d"},{"entry":"\u2003\u2003\/><\/Canvas.RenderTransform><!-- Microsoft.Windows.Themes.ThickChrome--"},{"entry":"\u2003\u2003><Canvas Clip=\u201cM 0, L 117.65, 0 117.65, 24.81 0, 24.81Z\u201d><Path"},{"entry":"\u2003\u2003Stroke=\u201c{StaticResource b0}\u201d StrokeThickness=\u201c1.3333333333\u201d"},{"entry":"\u2003\u2003StrokeMiterLimit=\u201c10\u201d Data=\u201cM 0.67, 3.67 C 0.67, 2.01 2.01, 0.67 3.67,"},{"entry":"\u2003\u20030.67 L 113.98, 0.67 C 115.64, 0.67 116.98, 2.01 116.98, 3.67 L 116.98,"},{"entry":"\u2003\u200321.15 C 116.98, 22.8 115.64, 24.15 113.98, 24.15 L 3.67, 24.15 C 2.01,"},{"entry":"\u2003\u200324.15 0.67, 22.8 0.67, 21.15Z\u201d \/><Path Fill=\u201cFFFFE0\u201d Data=\u201cM 0.75, 4.75"},{"entry":"\u2003\u2003C 0.75, 2.54 2.54, 0.75 4.75, 0.75 L 112.9, 0.75 C 115.11, 0.75 116.9,"},{"entry":"\u2003\u20032.54 116.9, 4.75 L 116.9, 20.06 C 116.9, 22.27 115.11, 24.06 112.9, 24.06"},{"entry":"\u2003\u2003L 4.75, 24.06 C 2.54, 24.06 0.75, 22.27 0.75, 20.06Z\u201d \/><Path"},{"entry":"\u2003\u2003Fill=\u201c{StaticResource b1}\u201d Data=\u201cM 1.05, 20.76 C 1.05, 19.11 2.84, 17.76"},{"entry":"\u2003\u20035.05, 17.76 L 112.6, 17.76 C 114.81, 17.76 116.6, 19.11 116.6, 20.76 L"},{"entry":"\u2003\u2003116.6, 20.76 C 116.6, 22.42 114.81, 23.76 112.6, 23.76 L 5.05, 23.76 C"},{"entry":"\u2003\u20032.84, 23.76 1.05, 22.42 1.05, 20.76Z\u201d \/><Path Fill=\u201c{StaticResource b2}\u201d"},{"entry":"\u2003\u2003Data=\u201cM 110.6, 5.05 C 110.6, 2.84 111.94, 1.05 113.6, 1.05 L 113.6, 1.05"},{"entry":"\u2003\u2003C 115.25, 1.05 116.6, 2.84 116.6, 5.05 L 116.6, 19.76 C 116.6, 21.97"},{"entry":"\u2003\u2003115.25, 23.76 113.6, 23.76 L 113.6, 23.76 C 111.94, 23.76 110.6, 21.97"},{"entry":"\u2003\u2003110.6, 19.76Z\u201d \/>"},{"entry":"\u2003\u2003. . ."},{"entry":"\u2003\u2003<\/Canvas>"},{"entry":"29\u2003<\/FixedPage>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"As seen in line 1 of the example XML of Table III, the fixed page node identifies a height and width of the page, a background for the page (e.g., background color and\/or pattern), as well as the namespace that is used to specify the elements of the hierarchies shown in . In lines 2-27, various different brushes are defined. In line 28, which is actually multiple lines, various glyphs, paths, and canvas elements are defined.","Table IV illustrates an example of XML code that specifies a print ticket node. Various different parameters can be included in a print ticket node to specify how the associated node (e.g., fixed document node, fixed page node, etc.) is to be processed. Examples of these are illustrated in the example XML code of Table IV.",{"@attributes":{"id":"p-0121","num":"0120"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE IV "},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"1\u2002\u2003<?xml version=\u201c1.0\u201d encoding=\u201cUTF-8\u201d?>"},{"entry":"2\u2002\u2003<psf:PrintTicket"},{"entry":"\u2003\u2003xmlns:psf=\u201cschemas.microsoft.com\/windows\/2003\/08\/printing\/printsc"},{"entry":"\u2003\u2003hemaframework\u201d xmlns:xsi=\u201cwww.w3.org\/2001\/XMLSchema-"},{"entry":"\u2003\u2003instance\u201d"},{"entry":"\u2003\u2003xmlns:xsd=\u201cwww.w3.org\/2001\/XMLSchema\u201d version=\u201c1\u201d"},{"entry":"\u2003\u2003xmlns:psk=\u201cschemas.microsoft.com\/windows\/2003\/08\/printing\/"},{"entry":"\u2003\u2003printschemakeywords\u201d>"},{"entry":"3\u2002\u2003. . ."},{"entry":"4\u2002\u2003\u2003<psf:Feature name=\u201cpsk:JobCollate\u201d>"},{"entry":"5\u2002\u2003\u2003\u2003<psf:Option name=\u201cpsk:Collated\u201d \/>"},{"entry":"6\u2002\u2003\u2003<\/psf:Feature>"},{"entry":"7\u2002\u2003\u2003<psf:Feature name=\u201cpsk:PageOutputColor\u201d>"},{"entry":"8\u2002\u2003\u2003\u2003<psf:Option name=\u201cpsk:Monochrome\u201d \/>"},{"entry":"9\u2002\u2003\u2003<\/psf:Feature>"},{"entry":"10\u2003\u2003<psf:Feature name=\u201cpsk:PageOrientation\u201d>"},{"entry":"11\u2003\u2003\u2003<psf:Option name=\u201cpsk:Portrait\u201d \/>"},{"entry":"12\u2003\u2003<\/psf:Feature>"},{"entry":"13\u2003\u2003<psf:Feature name=\u201cpsk:PageMediaSize\u201d>"},{"entry":"14\u2003\u2003\u2003<psf:Option name=\u201cpsk:NorthAmericaLetter\u201d>"},{"entry":"15\u2003\u2003\u2003\u2003<psf:ScoredProperty name=\u201cpsk:MediaSizeX\u201d>"},{"entry":"16\u2003\u2003\u2003\u2003\u2003<psf:Value xsi:type=\u201cxsd:integer\u201d>215900<\/psf:Value>"},{"entry":"17\u2003\u2003\u2003\u2003<\/psf:ScoredProperty>"},{"entry":"18\u2003\u2003\u2003\u2003<psf:ScoredProperty name=\u201cpsk:MediaSizeY\u201d>"},{"entry":"19\u2003\u2003\u2003\u2003\u2003<psf:Value xsi:type=\u201cxsd:integer\u201d>279400<\/psf:value>"},{"entry":"20\u2003\u2003\u2003\u2003<\/psf:ScoredProperty>"},{"entry":"21\u2003\u2003\u2003<\/psf:Option>"},{"entry":"22\u2003\u2003<\/psf:Feature>"},{"entry":"23\u2003. . ."},{"entry":"24\u2003<\/psf:PrintTicket>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"As seen in line 1 of the example XML of Table IV, the print ticket node identifies a version of XML and a data encoding format used by the print ticket node. Line 2 identifies the namespaces that are used to specify the elements of the hierarchies shown in . Lines 4-6 identify a job collate feature, indicating that the pages being printed should be collated. Lines 7-9 identify an output color feature, indicating that the pages should be printed in monochrome. Lines 10-12 identify a page orientation feature, indicating that the pages should be printed in portrait mode. Lines 13-22 identify a media size feature, indicating the size of the media on which the pages will be printed.","As noted above, the nodes shown in  are logical entities. Mapping rules define how the logical nodes map to parts of actual physical storage (e.g., in spool storage ). A logical package may be \u201cphysically\u201d embodied by a collection of loose files, a .ZIP file archive, a compound file, or some other format. In one case, some of the nodes directly correspond, in one-to-one fashion, to parts (e.g., files) stored in the spool storage , such as pages, image resources, font resources, etc. Other nodes may not map, in one-to-one fashion, to actual parts of the spool storage .",{"@attributes":{"id":"p-0124","num":"0123"},"figref":["FIG. 4","FIG. 4","FIG. 3","FIG. 4","FIG. 3","FIG. 3","FIG. 3"],"b":["400","402","404","402"]},"The second series of entries  includes separate folders for font resources, image resources, other resources, etc. As the resources are associated with the root node, the resources folder is in the \u201cSampleSpoolFile\u201d folder. The image folder is expanded to show an exemplary series of seven .jpg image files. These image files define shared image resources that can be referenced by any page-related node in the package. For example, the metadata information stored in the files can make reference to these resources, effectively linking specific nodes to specific resources.","Whatever the form of the physical media and file structure, information can be stored on this media in simple (direct) ordered fashion, in interleaved fashion, or some other fashion. Information can be retrieved from this physical media in sequential mode or random access mode or some other mode.","B. Exemplary Method of Operation",{"@attributes":{"id":"p-0128","num":"0127"},"figref":["FIG. 5","FIG. 1"],"b":"100"},"The procedure  includes generating the job information  having the structure  (act ). To perform this task, the application module  can generate job data, and the APIs  (and possibly the spooling module ) can produce the job information  having the format . This generated job information, having the format , is stored in the spool storage  (act ).","The job information  is subsequently retrieved from the spool storage  and consuming this job information  using the spooling module  (act ). Such consumption may entail applying different combinations of processing operations provided by individual filters (, , . . . ). Any such processing of job information  is represented generally by act . The processing may entail converting the job information  having the structure  to processed job information  that still maintains the structure . This output result would be appropriate to send to the \u201cstructure-aware\u201d target entity  which can interpret this structure . The processing may alternatively entail converting the job information  having the structure  into job information that no longer has any semblance to the structure . This output result would be appropriate to send to the \u201cstructure-unaware\u201d target entity . Or the processing may entail converting the job information  having the structure  to processed job information  that has some vestiges of the structure , but which deviates from the structure in one or more respects. This output result would be appropriate to send to the \u201cpartially structure-aware\u201d target entity .","Whatever the case, upon receipt of the job information, the target entities (, , , . . . ) can perform prescribed processing on the job information, such as by printing it, displaying it, archiving it, etc.","C. Exemplary Computer Environment","In one exemplary implementation, the application module , APIs , and spooling module  can be implemented by software executed by a computing device. In this case,  provides information regarding an exemplary computer environment  that can be used to implement this functionality. For a target entity that is implemented by a computing mechanism as well, such a computing mechanism can also be implemented using the type of computing environment  shown in , or using a related environment.","The computing environment  includes a general purpose type computer  and a display device . However, the computing environment  can include other kinds of computing equipment. For example, although not shown, the computer environment  can include hand-held or laptop devices, set top boxes, mainframe computers, etc. Further,  shows elements of the computer environment  grouped together to facilitate discussion. However, the computing environment  can employ a distributed processing configuration. In a distributed computing environment, computing resources can be physically dispersed throughout the environment.","Exemplary computer  includes one or more processors or processing units , a system memory , and a bus . The bus  connects various system components together. For instance, the bus  connects the processor  to the system memory . The bus  can be implemented using any kind of bus structure or combination of bus structures, including a memory bus or memory controller, a peripheral bus, an accelerated graphics port, and a processor or local bus using any of a variety of bus architectures.","Computer  can also include a variety of computer readable media, including a variety of types of volatile and non-volatile media, each of which can be removable or non-removable. For example, system memory  includes computer readable media in the form of volatile memory, such as random access memory (RAM) , and non-volatile memory, such as read only memory (ROM) . ROM  includes an input\/output system (BIOS)  that contains the basic routines that help to transfer  information between elements within computer , such as during start-up. RAM  typically contains data and\/or program modules in a form that can be quickly accessed by processing unit .","Other kinds of computer storage media include a hard disk drive  for reading from and writing to a non-removable, non-volatile magnetic media, a magnetic disk drive  for reading from and writing to a removable, non-volatile magnetic disk  (e.g., a \u201cfloppy disk\u201d), and an optical disk drive  for reading from and\/or writing to a removable, non-volatile optical disk  such as a CD-ROM, DVD-ROM, or other optical media. The hard disk drive , magnetic disk drive , and optical disk drive  are each connected to the system bus  by one or more data media interfaces . Alternatively, the hard disk drive , magnetic disk drive , and optical disk drive  can be connected to the system bus  by a SCSI interface (not shown), or other coupling mechanism. Although not shown, the computer  can include other types of computer readable media, such as magnetic cassettes or other magnetic storage devices, flash memory cards, CD-ROM, digital versatile disks (DVD) or other optical storage, electrically erasable programmable read-only memory (EEPROM), etc.","Generally, the above-identified computer readable media provide non-volatile storage of computer readable instructions, data structures, program modules, and other data for use by computer . For instance, the readable media can store the operating system , application modules  (e.g., for implementing the application module ), other program modules , and program data . The computer readable media  can also store, although not shown, logic for implementing the APIs  and spooling module . Any of the above-described storage media can be used to implement the spool storage , such as hard disk .","The computer environment  can include a variety of input devices. For instance, the computer environment  includes the keyboard  and a pointing device  (e.g., a \u201cmouse\u201d) for entering commands and information into computer . The computer environment  can include other input devices (not illustrated), such as a microphone, joystick, game pad, satellite dish, serial port, scanner, card reading devices, digital or video camera, etc. Input\/output interfaces  couple the input devices to the processing unit . More generally, input devices can be coupled to the computer  through any kind of interface and bus structures, such as a parallel port, serial port, game port, universal serial bus (USB) port, etc.","The computer environment  also includes the display device . A video adapter  couples the display device  to the bus . In addition to the display device , the computer environment  can include other output peripheral devices, such as speakers (not shown), a printer (not shown), etc. Any of these units can constitute the target entities (, , , . . . ) shown in .","Computer  operates in a networked environment using logical connections to one or more remote computers, such as a remote computing device . The remote computing device  can comprise any kind of computer equipment, including a general purpose personal computer, portable computer, a server, remote printer or archival device, etc. Any of these units can also constitute the target entities (, , , . . . ) shown in . Remote computing device  can include all of the features discussed above with respect to computer , or some subset thereof.","Any type of network  can be used to couple the computer  with remote computing device , such as a WAN, a LAN, etc. The computer  couples to the network  via network interface , which can utilize broadband connectivity, modem connectivity, DSL connectivity, or other connection strategy. Although not illustrated, the computing environment  can provide wireless communication functionality for connecting computer  with remote computing device  (e.g., via modulated radio signals, modulated infrared signals, etc.).","In closing, a number of examples were presented in this disclosure in the alternative (e.g., case A or case B). In addition, this disclosure encompasses those cases which combine alternatives in a single implementation (e.g., case A and case B), even though this disclosure may not have expressly mention these conjunctive cases in every instance.","More generally, although the invention has been described in language specific to structural features and\/or methodological acts, it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or acts described. Rather, the specific features and acts are disclosed as exemplary forms of implementing the claimed invention."],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 5","FIG. 1"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
