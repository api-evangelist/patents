---
title: Enterprise management system and method which includes a common enterprise-wide namespace and prototype-based hierarchical inheritance
abstract: A system and method for providing an improved namespace and object description system for enterprise management are disclosed. The system and method employ a hierarchical namespace with objects including prototypes and instances where an instance inherits traits from a prototype, such as attribute values and/or child objects.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06895586&OS=06895586&RS=06895586
owner: BMC Software
number: 06895586
owner_city: Houston
owner_country: US
publication_date: 20000830
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF SEVERAL EMBODIMENTS"],"p":["1. Field of the Invention","The present invention relates to computer software, and more particularly to agent-based management of a distributed or enterprise computer system.","2. Description of the Related Art","The data processing resources of business organizations are increasingly taking the form of a distributed computing environment in which data and processing are dispersed over a network comprising many interconnected, heterogeneous, geographically remote computers. Such a computing environment is commonly referred to as an enterprise computing environment, or simply an enterprise. As used herein, an \u201centerprise\u201d refers to a network comprising one or more computer systems. Managers of an enterprise often employ software packages known as enterprise management systems to monitor, analyze, and manage the resources of the enterprise. For example, an enterprise management system might include a software agent on an individual computer system for the monitoring of particular resources such as CPU usage or disk access. As used herein, an \u201cagent,\u201d \u201cagent application,\u201d or \u201csoftware agent\u201d is a computer program that is configured to monitor and\/or manage the hardware and\/or software resources of one or more computer systems. U.S. Pat. No. 5,655,081 discloses one example of an agent-based enterprise management system.","With data widely distributed over the many individual computer systems that comprise the enterprise, it is advantageous for the data to be organized and accessible throughout the enterprise. For example, in monitoring individual computer systems, software agents may generate and store data related to the monitoring. This data is often referred to as metric data. Metrics may include, for example, measurements relating to CPU usage, network usage, or memory usage. Other agents or applications on the same or other computer systems may desire to access this metric data. For example, a console application may desire to access the metrics from individual, monitored computer systems in order to graph or analyze potential bottlenecks in a network which links together the computer systems.","An enterprise-wide namespace is one way to make data available throughout an enterprise. A namespace provides efficient referencing and retrieval of information. The term \u201cnamespace\u201d generally refers to a set of names in which all names are unique. As used herein, a \u201cnamespace\u201d may refer to a memory, or a plurality of memories which are coupled to one another, whose contents are uniquely addressable. \u201cUniquely addressable\u201d refers to the property that items in a namespace have unique names such that any item in the namespace has a name different from the names of all other items in the namespace.","The internet is one example of a namespace. The internet comprises many individual computer systems which are linked together through an addressing system which guarantees that every server name is different from every other server name. The internet achieves the property of unique addressability through the use of a hierarchical name structure. For example, the top level of the hierarchy includes a limited number of high-level domain suffixes such as \u201c.com\u201d, \u201c.edu\u201d, and \u201c.org\u201d. Within a high-level suffix such as \u201c.com\u201d are many domains such as, for example, \u201cbmc.com\u201d. The domain administrator of \u201cbmc.com\u201d has the ability to designate lower levels of the hierarchy, such as division names, subdivision names, site names, server names, and so on. For example, the unique name of an individual server may take a form such as \u201ccomputer.site.division.bmc.com\u201d or \u201ccomputer.site.subdivision.division.bmc.com\u201d. This hierarchy helps ensure that each server has a unique name within the namespace.","A namespace is typically a logical organization and not a physical one. The namespace of the internet, for instance, is not related to physical interconnections. For instance, \u201cserver1.bmc.com\u201d and \u201cserver2.bmc.com\u201d could be physically located in the same room, in different countries, or anywhere in between. In other words, a namespace may be thought of as a plurality of distinct physical memories which are organized as a single, and possibly distributed, logical memory.","A directory service is another way of making data available throughout an enterprise. Typically, a directory service is a network service that identifies all resources on a network and makes them accessible to users and applications. Resources often include e-mail addresses, computers, and peripheral devices such as printers. Ideally, the directory service should make the physical network topology and protocols transparent so that a user on a network can access any resource without knowing where or how it is physically connected. A directory service is similar to a database in that it contains entries.","A directory service may be implemented in many different ways. For example, different implementations may allow different kinds of information to be stored in the directory. Often, entries may contain descriptive information relating to attributes of the resources. Different implementations may also place different requirements on how that information can be referenced, queried, updated, and protected from unauthorized access. Some directory services are local: they provide data only within a restricted context. For example, the \u201cfinger\u201d service which returns information on user accounts may be operable only on a particular network or machine. Other services are global: they provide data within a much broader context such as the entire internet. Global services such as those found on the internet are usually distributed. In other words, the data they contain is spread across many machines, all of which cooperate to provide the directory service. Typically, a global directory service defines a namespace which gives the same view of the data regardless of the location of the requesting machine or software relative to the data itself.","The Lightweight Directory Access Protocol (LDAP) is one example of a directory service. LDAP is both an information model and a protocol for querying and manipulating the information. The LDAP directory service model is based on entries. An entry is a collection of attributes having an unambiguous or unique name and often relating to information such as e-mail addresses and public encryption keys. LDAP's overall data and namespace model is essentially that of the more complex X.500 standard, and LDAP is also a set of protocols for accessing X.500 information directories. The X.500 standard defines basic object classes and a global, hierarchical directory structure. X.500 may be used to define a directory web in much the same way that the Hypertext Transport Protocol (HTTP) and Hypertext Markup Language (HTML) standards are used to define and implement the World Wide Web. Anyone with an X.500 or LDAP client may peruse the global directory just as they may use a web browser to peruse the global Web. Fundamentally, therefore, LDAP is a method for accessing information from a variety of directories, as long as vendors have implemented LDAP support in their directories. However, LDAP does not provide advanced features such as associations or the inheritance of attribute values and children from another entry in the namespace.","Another approach towards organizing information in an enterprise is taken by the Web-Based Enterprise Management (WBEM) initiative, managed by the Desktop Management Task Force (DMTF). The WBEM initiative is intended to prescribe enterprise management standards. One WBEM standard, the Common Information Model (CIM), is a platform-independent, object-oriented information model which allows for the interchange of management information between management systems and applications. CIM offers a single data-description mechanism for enterprise data sources from multiple vendors and frameworks. CIM provides a Meta Schema and a Schema. The CIM Meta Schema is a formal definition of the information model: it defines the terms used to express the model and the usage and semantics of the terms. The CIM Meta Schema also supports associations as types of classes. The CIM Schema provides the actual model descriptions. In other words, the CIM Schema supplies a set of classes with properties and associations that provide a conceptual framework for organizing the available information about a managed environment in an enterprise. Nevertheless, the Common Information Model merely provides the basic functionality to allow products from different vendors to exchange management data with one another; vendors must usually provide extensions to CIM in order to support product development. Furthermore, CIM does not specify how to implement its data description model in an enterprise-wide namespace.","For the foregoing reasons, there is a need for a system and method for an improved namespace and object description system for enterprise management.","The present invention provides various embodiments of a system and method for an improved namespace for an enterprise management system. In one embodiment, the system and method are used in a distributed computing environment, i.e., an enterprise. The enterprise comprises a plurality of computer systems, or nodes, which are interconnected through a network. At least one of the computer systems is a monitor computer system from which a user may monitor the nodes of the enterprise. At least one of the computer systems is an agent computer system. An agent computer system includes agent software that permits the collection of data relating to one or more metrics, i.e., measurements of system resources on the agent computer system. The agent software may comprise an agent application which is configurable to monitor the software and hardware of a computer system. The agent software may comprise one or more knowledge modules which are configurable to monitor or capture data from one or more of the computer systems and\/or their subsystems.","In one embodiment, a hierarchical namespace may be provided or created. The namespace comprises a logical arrangement of the objects, stored hierarchically. A plurality of objects may be added to the namespace, wherein the objects relate to software and hardware of the one or more computer systems. The plurality of objects may be distributed across the one or more networked computer systems of the enterprise. The plurality of objects may be shared with a plurality of the one or more computer systems. Consequently, data and\/or events may be shared with the one or more computer systems. The namespace and its objects (e.g., data and events) may be shared with the one or more computer systems of the enterprise by allowing the computer systems to mount both local and remote objects.","In one embodiment, at least one of the objects is a prototype and at least one of the objects is an instance. The instance inherits from the prototype traits such as attribute values and\/or child objects.","In one embodiment, one or more events in the hierarchical namespace may published. Each event may comprises an operation performed on one or more of a plurality of objects stored in the hierarchical namespace. One or more of the published events may be subscribed to. In subscribing to one or more of the published events, a criterion may be designated, and the published events which match the criterion may be subscribed to. In subscribing to one or more of the published events, a branch of the hierarchical namespace may be designated, and the published events which occur within the designated branch may be subscribed to.","In one embodiment, an association may be designated, wherein the association specifies a relationship between two or more of the objects. Each association may comprise an association object, wherein each association object comprises two or more attributes, wherein the two or more attributes comprise pathnames of the two or more objects whose relationship is specified in the association.","In one embodiment, one or more schemas may be designated, wherein each schema is a template which specifies one or more valid traits for a type of object. Each of the plurality of objects may follow at least one of the one or more schemas. Each object may include an identifier which indicates a type of the object, wherein the type of the object indicates one of the one or more schemas to be followed by the object. The schemas may be configured to support dynamic type checking of operations performed on the objects.","An application programming interface for managing the enterprise may be provided. In various embodiments, the application programming interface may enable applications such as agent applications to perform a variety of functions. The application programming interface may enable a first application to share a plurality of objects stored in a hierarchical namespace with a plurality of other applications. The application programming interface may enable the first application to designate a prototype, wherein the prototype is one of the plurality of objects. The application programming interface may enable the first application to designate an instance, wherein the instance is one of the plurality of objects, and wherein the instance inherits traits from the prototype. The application programming interface may enable the first application to publish one or more events, wherein each event comprises an operation performed on one or more of the plurality of objects. The application programming interface may enable the first application to subscribe to one or more of the published events. The application programming interface may enable the first application to designate an association, wherein the association specifies a relationship between two or more of the objects. The application programming interface may enable the first application to designate one or more schemas, wherein each schema is a template which specifies one or more valid traits for a type of object.","In various embodiments, the improved namespace for enterprise management may include the use of mid-level managers for scalability and flexibility. In one embodiment, a plurality of agents may be mounted, wherein the agents are configurable to gather a first set of information relating to a plurality of managed computer systems. The gathered information may comprise, for example, events and status information. The first set of gathered information may be received from the plurality of agents, pooled in a first mid-level manager namespace of a first mid-level manager, and presented in the first mid-level manager namespace to a management console. The first set of gathered information may be filtered by the first mid-level manager prior to presenting the first set of gathered information in the first mid-level manager namespace to the management console. The first set of information gathered by the agents may comprises individual events generated from the managed computer systems. Composite events, each comprising a plurality of the individual events, may be generated and presented in the first mid-level manager namespace to the management console. Correlated events, each comprising a correlation among a plurality of the individual events, may be generated and presented in the first mid-level manager namespace to the management console.","In one embodiment, additional mid-level managers may be used in multiple, hierarchical tiers. Presenting the first set of gathered information in the first mid-level manager namespace to the management console may comprise presenting the first set of gathered information in the first mid-level manager namespace to a higher-level mid-level manager, pooling the first set of gathered information in a higher-level mid-level manager namespace, and presenting the first set of gathered information in the higher-level mid-level manager namespace to the management console.","In one embodiment, additional mid-level managers may be used in the same tier as the first mid-level manager. A second set of gathered information may be gathered by and received from the plurality of agents. The second set of gathered information may be pooled in a second mid-level manager namespace of a second mid-level manager and presented in the second mid-level manager namespace to a management console. The first set and second set of gathered information may be received by the higher-level mid-level manager from the first mid-level manager and second mid-level manager, pooled in the higher-level mid-level manager namespace, and presenting the first set of gathered information in the higher-level mid-level manager namespace to the management console. The first mid-level manager namespace and the second mid-level manager namespace may comprise configuration information for the plurality of agents, such that the configuration information is stored and maintained in a distributed fashion.","While the invention is susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood, however, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents, and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.","FIG. \u2014A Typical Computer System",{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 1","b":["100","100","102","104","106","108","100","110","102","110","100"]},"FIG. \u2014Computing Hardware of a Typical Computer System",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 2","b":["102","100","102","122","122","122","124"]},"As used herein, the term \u201cmemory medium\u201d includes a non-volatile medium, e.g., a magnetic medium, hard disk, or optical storage; a volatile medium, such as computer system memory, e.g., random access memory (RAM) such as DRAM, SDRAM, SRAM, EDO RAM, Rambus RAM, etc.; or an installation medium, such as CD-ROM, floppy disks, or a removable disk, on which computer programs are stored for loading into the computer system. The term \u201cmemory medium\u201d may also include other types of memory and is used synonymously with \u201cmemory.\u201d The memory medium  may therefore store program instructions and\/or data which implement the improved enterprise management system and method described herein. Furthermore, the memory medium  may be utilized to install the program instructions and\/or data. In a further embodiment, the memory medium  may be comprised in a second computer system which is coupled to the computer system  through a network . In this instance, the second computer system may operate to provide the program instructions stored in the memory medium  through the network  to the computer system  for execution.","The CPU  may also be coupled through an input\/output bus  to one or more input\/output devices that may include, but are not limited to, a display device such as a monitor , a pointing device such as a mouse , a keyboard , a track ball, a microphone, a touch-sensitive display, a magnetic or paper tape reader, a tablet, a stylus, a voice recognizer, a handwriting recognizer, a printer, a plotter, a scanner, and any other devices for input and\/or output. The computer system  may acquire program instructions and\/or data for implementing the improved enterprise management system and method as described herein through the input\/output bus .","The CPU  may include a network interface device  for coupling to a network. The network may be representative of various types of possible networks: for example, a local area network (LAN), wide area network (WAN), or the Internet. The improved enterprise management system and method as described herein may therefore be implemented on a plurality of heterogeneous or homogeneous networked computer systems such as computer system  through one or more networks. Each computer system  may acquire program instructions and\/or data for implementing the improved enterprise management system and method as described herein over the network.","FIG. \u2014A Typical Enterprise Computing Environment",{"@attributes":{"id":"p-0048","num":"0047"},"figref":["FIG. 3","FIG. 3"],"b":["200","200","100","200"]},"One or more local area networks (LANs)  may be included in the enterprise . A LAN  is a network that spans a relatively small area. Typically, a LAN  is confined to a single building or group of buildings. Each node (i.e., individual computer system or device) on a LAN  preferably has its own CPU with which it executes computer programs, and often each node is also able to access data and devices anywhere on the LAN . The LAN  thus allows many users to share devices (e.g., printers) as well as data stored on file servers. The LAN  may be characterized by any of a variety of types of topology (i.e., the geometric arrangement of devices on the network), of protocols (i.e., the rules and encoding specifications for sending data, and whether the network uses a peer-to-peer or client\/server architecture), and of media (e.g., twisted-pair wire, coaxial cables, fiber optic cables, radio waves).  illustrates an enterprise  including one LAN . However, the enterprise  may include a plurality of LANs  which are coupled to one another through a wide area network (WAN) . A WAN  is a network that spans a relatively large geographical area.","Each LAN  comprises a plurality of interconnected computer systems or at least one computer system and at least one other device. Computer systems and devices which may be interconnected through the LAN  may include, for example, one or more of a workstation , a personal computer , a laptop or notebook computer system , a server computer system , or a network printer . An example LAN  illustrated in  comprises one of each of these computer systems , , , and  and one printer . Each of the computer systems , , , and  is preferably an example of the typical computer system  as illustrated in . The LAN  may be coupled to other computer systems and\/or other devices and\/or other LANs  through a WAN .","A mainframe computer system  may optionally be coupled to the enterprise . As shown in , the mainframe  is coupled to the enterprise  through the WAN , but alternatively the mainframe  may be coupled to the enterprise  through a LAN . As shown in , the mainframe  is coupled to a storage device or file server  and mainframe terminals , , and . The mainframe terminals , , and access data stored in the storage device or file server  coupled to or comprised in the mainframe computer system .","The enterprise  may also comprise one or more computer systems which are connected to the enterprise  through the WAN : as illustrated, a workstation and a personal computer . In other words, the enterprise  may optionally include one or more computer systems which are not coupled to the enterprise  through a LAN . For example, the enterprise  may include computer systems which are geographically remote and connected to the enterprise  through the Internet.","When the computer programs  are executed on one or more computer systems such as computer system , an enterprise management system may be operable to monitor, analyze, and\/or manage the computer programs, processes, and resources of the enterprise . Typically, each computer system  in the enterprise  executes or runs a plurality of software applications or processes. Each software application or process consumes a portion of the resources of a computer system and\/or network: for example, CPU time, system memory such as RAM, nonvolatile memory such as a hard disk, network bandwidth, and input\/output (I\/O). The enterprise management system and method of one embodiment permits users to monitor, analyze, and manage resource usage on heterogeneous computer systems  across the enterprise .","U.S. Pat. No. 5,655,081, titled \u201cSystem for Monitoring and Managing Computer Resources and Applications Across a Distributed Environment Using an Intelligent Autonomous Agent Architecture,\u201d which discloses an enterprise management system and method, is hereby incorporated by reference as though fully and completely set forth herein.","FIG. \u2014Overview of the Enterprise Management System",{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 4","b":["330","304","320","306","306","330","304","320","306","306"],"i":["a","c ","a","c "]},"In one embodiment, the improved enterprise management system provides the sharing of data and events, both runtime and stored, across the enterprise. Data and events may comprise objects. As used herein, an object is a self-contained entity that contains data and\/or procedures to manipulate the data. Objects may be stored in a volatile memory and\/or a nonvolatile memory. The objects are typically related to the monitoring and analysis activities of the enterprise management system, and therefore the objects may relate to the software and\/or hardware of one or more computer systems in the enterprise. A common object system (COS) may provide a common infrastructure for managing and sharing these objects across multiple agents. As used herein, \u201csharing objects\u201d may include making objects accessible to one or more applications and\/or computer systems and\/or sending objects to one or more applications and\/or computer systems.","A common object system protocol (COSP) may provide a communications protocol between objects in the enterprise. In one embodiment, a common message layer (CML) provides a common communication interface for components. CML may support standards such as TCP\/IP, SNA, FTP, and DCOM. The deployment server  may use CML and\/or the Lightweight Directory Access Protocol (LDAP) to communicate with the management console , the console proxy , and the agents , , and ","A management console  is a software program that allows a user to monitor and\/or manage individual computer systems in the enterprise . In one embodiment, the management console  is implemented in accordance with an industry-standard framework for management consoles such as the Microsoft Management Console (MMC) framework. MMC does not itself provide any management behavior. Rather, MMC provides a common environment or framework for snap-ins. As used herein, a \u201csnap-in\u201d is a module that provides management functionality. MMC has the ability to host any number of different snap-ins. Multiple snap-ins can be combined to build a custom management tool. Snap-ins allow a system administrator to extend and customize the console to meet specific management objectives. MMC provides the architecture for component integration and allows independently developed snap-ins to extend one another. MMC also provides programmatic interfaces. The MMC programmatic interfaces permit the snap-ins to integrate with the console. In other words, snap-ins are created by developers in accordance with the programmatic interfaces specified by MMC. The interfaces do not dictate how the snap-ins perform tasks, but rather how the snap-ins interact with the console.","In one embodiment, the management console is further implemented using a superset of MMC such as the BMC Management Console (BMCMC), also referred to as the BMC Integrated Console or BMC Integration Console (BMCIC). In one embodiment, BMCMC is an expansion of MMC: in other words, BMCMC implements all the interfaces of MMC, plus additional interfaces or other elements for additional functionality. Therefore, snap-ins developed for MMC will typically function with BMCMC in much the same way that they function with MMC. In other embodiments, the management console is implemented using any other suitable standard.","As shown in , in one embodiment the management console  may include several snap-ins: a knowledge module (KM) IDE snap-in , an administrative snap-in , an event manager snap-in , and optionally other snap-ins . The KM IDE snap-in  may be used for building new KMs and modifying existing KMs. The administrative snap-in  may be used to define user groups, user roles, and user rights and also to deploy KMs and other configuration files needed by agents and consoles. The event manager snap-in  may receive and display events based on user-defined filters and may support operations such as event acknowledgement. The event manager snap-in  may also support root cause and impact analysis. The other snap-ins  may include snap-ins such as a production snap-in for monitoring runtime objects and a correlation snap-in for defining the relationship of objects for correlation purposes. The snap-ins shown in  are shown for purposes of illustration and example: in various embodiments, the management console  may include different combinations of snap-ins, including snap-ins shown in FIG.  and snap-ins not shown in FIG. .","In various embodiments, the management console  may provide several functions. The console  may provide information relating to monitoring and may alert the user when critical conditions defined by a KM are met. The console  may allow an authorized user to browse and investigate objects that represent the monitored environment. The console  may allow an authorized user to issue and run application-management commands. The console  may allow an authorized user to browse events and historical data. The console  may provide a programmable environment for an authorized user to automate day-to-day tasks such as generating reports and performing particular system investigations. The console  may provide an infrastructure for running knowledge modules that are configured to create predefined views.","As used herein, an \u201cagent,\u201d \u201cagent application,\u201d or \u201csoftware agent\u201d is a computer program that is configured to monitor and\/or manage the hardware and\/or software resources of one or more computer systems. As illustrated in the example of , agents , , and may have various combinations of several knowledge modules: network KM , system KM , Oracle KM , and SAP KM . As used herein, a \u201cknowledge module\u201d (\u201cKM\u201d) is a software component that is configured to monitor a particular system or subsystem of a computer system, network, or other resource. A KM may generate an alarm at the console  when a user-defined condition is met. Network KM  may monitor network activity. System KM  many monitor an operating system and\/or system hardware. Oracle KM  may monitor an Oracle relational database management system (RDBMS). SAP KM  may monitor an SAP R\/3 system. Knowledge modules , , , and  are shown for exemplary purposes only, and in various embodiments other knowledge modules may be employed in an agent.","In one embodiment, a deployment server  may provide centralized deployment of software packages across the enterprise. The deployment server  may maintain product configuration data, provide the locations of products in the enterprise , maintains installation and deployment logs, and store security policies. In one embodiment, the deployment server  may provide data models based on a generic directory service such as the Lightweight Directory Access Protocol (LDAP).","In one embodiment, the management console  may access agent information through a console proxy . The console  may go through a console application programming interface (API) to send and receive objects and other data to and from the console proxy . The console API may be a Common Object Model (COM) API, a Common Object System (COS) API, or any other suitable API. In one embodiment, the console proxy  is an agent. Therefore, the console proxy  may have the ability to load, interpret, and execute knowledge modules.","FIG. \u2014Overview of an Agent in the Enterprise Management System",{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 5","b":["306","306","350","350","306","350"],"i":["a ","a ","a"]},"The agent namespace  may be one branch of a hierarchical, enterprise-wide namespace. The enterprise-wide namespace may comprise a plurality of agent namespaces as well as namespaces of other components such as console proxies. Each individual namespace may store a plurality of objects or other units of data and may comprise a branch of a larger, enterprise-wide namespace. The agent or other component that manages a namespace may act as a server to other parts of the enterprise with respect to the objects in the namespace. The enterprise-wide namespace may employ a simple hierarchical information model in which the objects are arranged hierarchically. In one embodiment, each object in the hierarchy may include a name, a type, and zero or more attributes.","In one embodiment, the enterprise-wide namespace may be thought of as a logical arrangement of underlying data rather than the physical implementation of that data. For example, an attribute of an object may obtain its value by calling a function, by reading a memory address, or by accessing a file. Similarly, a branch of the namespace may not correspond to actual objects in memory but may merely be a logical view of data that exists in another form altogether or on disk.","In one embodiment, furthermore, the namespace defines an extension to the classical directory-style information model in which a first object (called an instance) dynamically inherits attribute values and children from a second object (called a prototype). This prototype-instance relationship is discussed in greater detail below. Other kinds of relationships may be modeled using associations. Associations are discussed in greater detail below.","The features and functionality of the agents may be implemented by individual components. In various embodiments, components may be developed using any suitable method, such as, for example, the Common Object Model (COM), the Distributed Common Object Model (DCOM), JavaBeans, or the Common Object System (COS). The components cooperate using a common mechanism: the namespace. The namespace may include an application programming interface (API) that allows components to publish and retrieve information, both locally and remotely. Components may communicate with one another using the API. The API is referred to herein as the namespace front-end, and the components are referred to herein as back-ends.","As used herein, a \u201cback-end\u201d is a software component that defines a branch of a namespace. In one embodiment, the namespace of a particular server, such as an agent , may be comprised of one or more back-ends. A back-end can be a module running in the address space of the agent, or it can be a separate process outside of the agent which communicates with the agent via a communications or data transfer protocol such as the common object system protocol (COSP). A back-end, either local or remote, may use the API front-end of the namespace to publish information to and retrieve information from the namespace.",{"@attributes":{"id":"p-0071","num":"0070"},"figref":["FIG. 5","FIG. 5","FIG. 5"],"b":["306","360","306","360","362","356","360","306","352","350"],"i":["a","a","b "]},"Other agents and components may access the KM data and\/or objects in the KM branch of the agent namespace through a communications or data transfer protocol such as, for example, the common object system protocol (COSP) or the industry-standard common object model (COM). In one embodiment, for example, the other agent and the external back-end  publish or subscribe to data in the agent-namespace  through the common object system protocol. The KM objects and data may be organized in a hierarchy within a KM branch of the namespace of the particular agent . The KM branch of the namespace of the agent may, in turn, be part of a larger hierarchy within the agent namespace , which may be part of a broader, enterprise-wide hierarchical namespace. The KM back-end  may create the top-level application instance in the namespace as a result of a discovery process. The KM back-end  may also be responsible for loading KM configuration data.","In the same way as the KM back-end , other back-ends may manage branches of the agent namespace  and populate their branches with relevant data and\/or objects which may be made available to other software components in the enterprise. A runtime back-end  may process KM instance data, perform discovery and monitoring, and run recovery actions. The runtime back-end  may be responsible for launching discovery processes for nested application instances. The runtime back-end  may also maintain results of KM interpretation and KM runtime objects.","An event manager back-end  may manage events generated by knowledge modules running in this particular agent . The event manager back-end  may be responsible for event generation, persistent caching of events, and event-related action execution on the agent . A data pool back-end  may manage data collectors  and data providers  to prevent the duplication of collection and to encourage the sharing of data among KMs and other components. The data pool back-end  may store data persistently in a data repository such as a Universal Data Repository (UDR) . A script language (PSL) virtual machine (VM)  may execute scripts. The script VM  may also comprise a script language (PSL) interpreter back-end which is responsible for scheduling and executing scripts. A scheduler  may allow other components in the agent to schedule tasks.","Other back-ends may provide additional functionality to the agent and may provide additional data and\/or objects to the agent namespace . A registry back-end may keep track of the configuration of this particular agent and provides access to the configuration database of the agent for other back-ends. An OS command execution back-end may execute OS commands. A layout back-end may maintain GUI layout information. A resource back-end may maintain common resources such as image files, help files, and message catalogs. A mid-level manager (MM) back-end may allow the agent to manage other agents. The mid-level manager back-end is discussed in greater detail below. A directory service back-end may communicate with directory services. An SNMP back-end may provide Simple Network Management Protocol (SNMP) functionality in the agent.","The console proxy  shown in  may access agent objects and send commands back to agents. In one embodiment, the console proxy  uses a mid-level manager (MM) back-end to maintain agents that are being monitored. Via the mid-level manager back-end, the console proxy  accesses remote namespaces on agents to satisfy requests from console GUI modules. The console proxy  may implement a namespace to organize its components. The namespace of a console proxy  may be an agent namespace with a layout back-end mounted. Therefore, a console proxy  is itself an agent. The console proxy  may therefore have the ability to load KM packages, interpret, and execute them. In one embodiment, the following back-ends are mounted in the namespace of the console proxy : KM back-end , runtime back-end , event manager back-end , registry back-end, OS command execution back-end, PSL interpreter back-end, mid-level manager (MM) back-end, layout back-end, and resource back-end.","FIG. \u2014Hierarchical Organization of Information in the Namespace",{"@attributes":{"id":"p-0077","num":"0076"},"figref":["FIG. 6","FIG. 6"],"b":["402","404","406","404","408","410"]},"Objects in the tree may be referred to using paths. Paths may be formed by concatenating the object names encountered when traversing the path from the root of the tree to a given object. In one embodiment, the name of the root is not part of the path. For example, the \u201cSaturn\u201d object  is uniquely identified\u2014relative to the root\u2014by the following path: \u201chosts\/saturn\u201d. Objects contain one or more attributes. In one embodiment, an attribute is a name-value pair whose value is of a primitive type (e.g., integer, float, string), an array type (i.e., an array of primitives), or an object type (i.e., the attribute is a pointer to another object). In one embodiment, the type of an attribute may be specified as a reference to another object, as discussed in more detail below. Object attributes may be referred to using a path and an attribute name. For example, the \u201cvendor\u201d attribute of the \u201csaturn\u201d object  is referred to by: \u201chosts\/saturn vendor\u201d. Objects may have an associated string type-name to indicate the type of the object. In the example of , the type of the \u201csaturn\u201d object  and the \u201cneptune\u201d object  is \u201chost\u201d. The type of the \u201chost\u201d object is \u201chost-container\u201d.","In one embodiment, the namespace has conventions for object names. In one embodiment, three characters are reserved characters which cannot be used in object names: \u2018\/\u2019 is reserved as a path separator, \u2018*\u2019 is reserved as a wild card for queries, and \u2018.\u2019 is reserved for specifying relative paths. Twenty-three additional characters are prohibited characters which cannot be used in object names: \u2018!\u2019, \u2018#\u2019, \u2018%\u2019, \u2018^\u2019, \u2018&\u2019, \u2018$\u2019, \u2018?\u2019, \u2018(\u2018, \u2019)\u2019, \u2018[\u2018,\u2019]\u2019, \u2018{\u2018,\u2019}\u2019, \u2018\\\u2019, \u2018\u2032\u2019, \u2018|\u2019, \u2018\u2033\u2019, \u2018;\u2019, \u2018<\u2019, \u2018>\u2019, \u2018\u02dc\u2019, \u2018+\u2019, and \u2018=\u2019. Whitespace and newline characters may also be prohibited in object names.","Attributes in the namespace may be primitive-valued or array-valued. In one embodiment, the following attribute types are supported:\n\n","The datetime type may be represented as a string of the form: \u201cyyyymmddhhmmss.mmmmmmsutc\u201d, where yyyy is the year, mm is the month, dd is the day, mm is the minute, ss is the second, mmmmmm is the number of microseconds, s is a sign indicator (\u2018+\u2019 or \u2018\u2212\u2019), and utc is the offset from UTC in minutes (using the sign defined above).","FIG. \u2014Dynamic Inheritance","One object in the namespace may dynamically inherit attributes, values, and\/or children from another object in the namespace. As used herein, a \u201cprototype\u201d is an object in a namespace from which attributes, values, and\/or children are dynamically inherited by another object. As used herein, an \u201cinstance\u201d is an object in a namespace which dynamically inherits attributes, values, and\/or children from another object in the namespace.  illustrates an example of a namespace which includes a prototype-instance relationship. At the top of the sample namespace is the root object . In , there is dynamic inheritance link from object \u201cb\u201d  to object \u201ca\u201d ; the link is shown as a dashed arrow. Object \u201ca\u201d  functions as the prototype and object \u201cb\u201d  functions as the instance. Therefore, object \u201cb\u201d  dynamically inherits the attributes, values, and children of object \u201ca\u201d . As used herein, \u201cdynamic inheritance\u201d includes the ability to derive attributes, values, and\/or children from another object, where the attributes, values, and\/or children may change over time. In this example, object \u201cb\u201d  has an attribute called \u201cx\u201d of its own and also inherits the attribute \u201cy\u201d from object \u201ca\u201d . Object \u201cb\u201d  does not inherit the attribute \u201cx\u201d of object \u201ca\u201d  because object \u201cb\u201d  already has an attribute named \u201cx\u201d. Similarly, object \u201cb\u201d  has a child object  named \u201cc\u201d and also inherits the child object  \u201cd\u201d from object \u201ca\u201d . However, object \u201cb\u201d  does not inherit child object \u201cc\u201d  of object \u201ca\u201d  because object \u201cb\u201d  already has a child object  named \u201cc\u201d.","To resolve an attribute reference according to one embodiment, the target object (i.e., the instance) is searched first for the attribute. If the attribute is found locally, then the search ends. If the attribute is not found locally, then its prototype is searched. The prototype may also have a prototype of its own, and this chain of prototypes is traversed until either the attribute is found or an object with no prototype is encountered. As an example of attribute inheritance, the following attribute reference denotes the inherited \u201cy\u201d attribute of object \u201ca\u201d  whose value is 20: \u201cb y\u201d. To see how child inheritance works, consider how the following attribute reference is resolved: \u201cb\/d u\u201d. Because object \u201cb\u201d  does not have a child called \u201cd\u201d, the path \u201cb\/d\u201d actually refers to \u201ca\/d\u201d. Then \u201cb\u201d  inherits the child \u201cd\u201d  from \u201ca\u201d .","In one embodiment, an instance not only inherits the direct children of its prototype, but it may also inherit the entire descendant structure of its prototype. For example, \u201ca\/c\/e\u201d , a child of \u201ca\/c\u201d , is inherited by \u201cb\/c\u201d . As used herein, \u201cstructural inheritance\u201d is the inheritance of the entire structure beneath the prototype.","To further illustrate inheritance in the example namespace given in , the following attribute references would be resolved as follows: \u201ca x\u201d yields 10; \u201ca y\u201d yields 20; \u201cb x\u201d yields 12; \u201cb y\u201d yields 20; \u201ca\/c u\u201d yields 22.5; \u201ca\/c v\u201d yields 33.6; \u201ca\/d u\u201d yields 23.3; \u201ca\/d v\u201d yields 34.5; \u201cb\/c u\u201d yields 25.7; \u201cb\/c v\u201d yields 36.4; \u201cb\/d u\u201d yields 23.3; \u201cb\/d v\u201d yields 34.5; \u201ca\/c\/e z\u201d yields 14.2; and \u201cb\/c\/e z\u201d yields 14.2.","Associations","In one embodiment, associations may be defined for objects. As used herein, an \u201cassociation\u201d is an object or other piece of data which specifies a relationship between two or more objects. The relevant object paths may be string-valued attributes of the association object. For example, one might use associations to model an object graph. Each association object would act as a vertex and would have attributes such as \u201cto\u201d and \u201cfrom\u201d to specify the paths of connected objects.","In one embodiment, an association may specify a \u201cpart-of\u201d relationship. A \u201cpart-of\u201d relationship may be established by creating an attribute in an owner object and setting the reference to the \u201cpart\u201d object in the attribute. In one embodiment, an association may specify a \u201cparent-child\u201d relationship. A \u201cparent-child\u201d relationship may be established by specifying the parent object when creating the child object.","In one embodiment, several methods are available for association objects. A getAssociates( ) method may return a list of objects with which a given object is associated. The getAssociates( ) method may accept arguments such as \u201crole\u201d and type\u201d to restrict the results of the method by specifying the given object and the type of results, respectively. A getAssociations( ) method may return a list of all associations that refer to a given object. The getAssociations( ) method may accept arguments such as \u201crole\u201d and \u201ctype\u201d to restrict the results of the method by specifying the given object and the type of results, respectively.","FIG. \u2014Schemas","The hierarchical namespace according one embodiment may include schemas. As used herein, a \u201cschema\u201d may specify the valid attribute names and valid attribute types for a given type of object. Therefore, a schema may include an attribute name and an attribute type for each attribute of a type of object. In one embodiment, each object may have an associated schema. In one embodiment, every object may carry a string identifier that indicates the type. Objects of a given type share the same schema.","A schema is similar to the concept of a structure in a programming language such as C. For example, the following C structure might specify the schema for a data type called an employee:",{"@attributes":{"id":"p-0091","num":"0099"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"struct employee"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"char last_name[128];"]},{"entry":[{},"char first_name[128];"]},{"entry":[{},"char middle_initial;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In one embodiment, a schema is an object of a \u201cschema\u201d type. A schema  for an employee object might be as shown in FIG. . In the example, employee schema  is an object with the name \u201cemployee\u201d, an attribute named \u201clast_name\u201d of a string datatype, an attribute named \u201cfirst_name\u201d of a string datatype, and an attribute named \u201cmiddle_initial\u201d of a character datatype. The schema also stores a value for each attribute in addition to the attribute name and attribute type. The attribute value represents a default value for a newly instantiated object of the type governed by the schema.","In one embodiment, schema objects may be maintained under a \u201cschemas\u201d branch  off the root  of a local namespace. When a back-end is loaded, the back-end populates the schema branch  with the schemas for the object types that the back-end defines. The full path (relative to the root of the local namespace) of the \u201cemployee\u201d schema  might then be \u201cschemas\/employee\u201d.","In one embodiment, schemas comprise closed schemas and open schemas. A closed schema permits attributes to be set only if the attribute is already part of the schema. For a closed schema, an attempt to set an attribute whose name-type combination is not found in the schema will fail. An open schema is a schema that may be extended at runtime. For an open schema, an attempt to set an attribute whose name-type combination is not found in the schema will cause the schema to be extended. In this case, the schema becomes object-specific and is no longer shared by objects that were previously of the same type.","In one embodiment, schema objects may include the following methods:\n\n","In one embodiment, schemas may be used to support object type hierarchies. Schema objects may take advantage of prototype-instance relationships discussed above to model type hierarchy relationships. For example, a schema  for a \u201csalesman\u201d object type may maintain a prototype pointer to the \u201cemployee\u201d schema , thus inheriting the attribute definitions from the employee schema object . The salesman schema  would then be an instance of the employee schema  and would inherit the last_name, first_name, and middle_initial attributes.","Schemas may be used for several purposes. Schemas may be used to answer \u201cis-a\u201d queries relating to whether an object is a data type. Schemas may be used to support dynamic type checking of operations in the namespace. For example, schemas can be used to prevent setting an attribute to a type which is incompatible with the schema object. Schemas may be used to provide object-type information to generic object editors for automatically building object editing forms. Schemas may be used to validate that object instances conform to a proper object type.","In one embodiment, a schema object may maintain object traits for a particular object type. As used herein, \u201cobject traits\u201d are pieces of data that hold additional information about an object type. For example, to support generic object editors, it is advantageous to know the valid child types for a particular object when creating a child of that object. An object trait called \u201cchild-types\u201d may be defined to provide this information. The \u201cchild-types\u201d object trait may be an array of strings representing object types. The generic object editor may refer to the \u201cchild-types\u201d object trait to present a list of valid child types to the user of the generic object editor.","In one embodiment, a schema object may maintain attribute traits for a particular attribute. As used herein, \u201cattribute traits\u201d are pieces of data that hold additional information about one or more attributes. For example, an attribute trait called \u201cvalues\u201d may hold the set of valid values for a given attribute. An attribute trait called \u201cdisplay\u201d may hold the set of valid values as they would be displayed in a user interface. An attribute trait called \u201cread-only\u201d may be true if the attribute is read-only. An attribute trait called \u201cdescription\u201d may hold a description of the attribute as a string. An attribute trait called \u201cunits\u201d may hold the units of measurement in which the attribute is expressed. An attribute trait called \u201cvisible\u201d may be true if user interfaces should make the attribute visible. An attribute trait called \u201cpath\u201d may be used to indicate that the attribute contains a path to another object (i.e., the attribute is part of an association).","Publication and Subscription of Events","In one embodiment, the namespace may employ a publish-subscribe model for events. Clients such as agents or consoles may subscribe to events which occur on a particular object in the namespace. In a similar way, clients may publish events in the namespace. The publish-subscribe capability of objects in the namespace may include event propagation which permits clients to subscribe to all events within a particular branch of the namespace by subscribing to the root object of the branch. In one embodiment, clients may restrict the results of a subscription by specifying a criterion or criteria to be met by published events and\/or objects.","As used herein, \u201cpublishing\u201d includes sending and\/or making available to a software component one or more elements of data and\/or changes in the data over time. The elements of data may include events or objects. In one embodiment, a \u201cpublish( )\u201d method may be provided for objects. The publish( ) method may be used as illustrated by the following C++-style code fragment:\n\n","In this example, the given event is published on the object whose path is \u201ca\/b\/c\/d\u201d. Because the publish( ) method takes ownership of the event argument \u201ce\u201d in one embodiment, the client should not use the event \u201ce\u201d again or delete the event. The first argument is a context object \u201cc\u201d that carries contextual information. Contextual information may relate to security for the current user, data structures shared throughout the namespace, additional information about error conditions, and any other contextual information deemed necessary. In one embodiment, events propagate up the namespace hierarchy by default. Therefore, publishing an event on \u201ca\/b\/c\/d\u201d has the same effect as publishing the event on \u201ca\/b\/c\u201d, \u201ca\/b\u201d, \u201ca\u201d, and \u201c.\u201d. In one embodiment, this default event propagation may be suppressed by adding a fourth argument \u201cfalse\u201d to the method call for publish( ).","As used herein, \u201csubscribing\u201d includes expressing an interest in one or more elements of data and\/or receiving the data and\/or changes in the data over time. The elements of data may include events or objects. In one embodiment, a \u201csubscribe( )\u201d method may be provided for objects. The subscribe( ) method may be used as illustrated by the following C++-style code fragment:\n\n","After the subscribe( ) method is called in this example, a handle( ) method of the user's handler \u201ch\u201d may be invoked every time a \u201ccreate\u201d event is published on or below the \u201ca\/b\u201d object. In one embodiment, after calling subscribe( ), the handler object \u201ch\u201d belongs to an event manager and should be not be used again or deleted by the subscribing entity. The first argument is a context object \u201cc\u201d that carries contextual information. The fourth argument may be used to specify an event filter in one embodiment. In the example above, the \u201ccreate\u201d filter eliminates non-creation events from the subscription by subscribing only to object creation events. The fifth argument may be used to specify additional criteria for the filter in one embodiment. For example, in the case of the \u201cset\u201d event, which may be published whenever the value of an attribute is set, this fifth argument may be the name of the attribute whose set event is of interest. If the fifth argument is \u201c*\u201d, then all set events will be returned in one embodiment.","In one embodiment, a \u201ccancel( )\u201d method may be provided for objects. In one embodiment, cancel( ) uses the TaskID obtained from the subscribe( ) method. The cancel( ) method may be used as illustrated by the following C++-style code fragment, wherein the first argument is a context object \u201cc\u201d:\n\n","In one embodiment, a plurality of event filters are provided. A \u201ccreate\u201d filter may select object-creation events. A \u201cdestroy\u201d filter may select object-destruction events. An \u201cimplicit-destroy\u201d filter may select events in which an object is implicitly destroyed. A \u201cremove\u201d filter may select attrribute-removal events. A \u201cset\u201d filter may select events in which the value of an attribute is set for a particular attribute name or names (where \u201c*\u201d selects all attributes). An \u201csql-1\u201d filter may select events in which a Structured Query Language (SQL) statement is satisfied. An \u201call\u201d filter may select any event. Additional filters may be defined by deriving from a base class for event filters.","In one embodiment, an event-subscription table is utilized to map paths to event-filter\/event-handler pairs. When an event is published on an object, the subscription table is checked to determine if there are any subscribers for that object. If so, the filter is evaluated against the event. If the evaluation is true, then an event\/event-handler pair is formed and enqueued on an event queue. The event queue may be used to avoid re-entrancy problems which may be encountered when event handlers do further publications and subscriptions. When the event queue is flushed, the appropriate handlers are invoked.","FIG. \u2014An Example of an Enterprise-Wide Namespace",{"@attributes":{"id":"p-0108","num":"0130"},"figref":"FIG. 9","b":["801","811","812","813","814","811","812","814","813"]},"The MM branch  may include child entries for a plurality of agents. As illustrated by way of example in , the MM branch  may include agent A, agent A, and agent A. Each agent namespace may then include branches which are managed by back-ends in the agent. As shown in , for example, agent A may include a KM branch , a runtime branch , an MM branch , and a layout branch .","The same subagent may appear in MM branches of different master agents. For example, in , agent A may be configured in two MM branches  and . When organizing agents to construct enterprise-wide namespaces, the rule may apply that the enterprise-wide namespace is a tree structure, i.e., there are no loops in the hierarchy.","FIG. \u2014Enterprise Management System Including Mid-Level Managers","In one embodiment, the improved enterprise management system and method may also include one or more mid-level managers. In one embodiment, a mid-level manager is an agent that has been configured with a mid-level manager back-end. The mid-level manager may be used to represent the data of multiple managed agents.  illustrates an enterprise management system including a plurality of mid-level managers according to one embodiment. A management console  may exchange data with a higher-level mid-level manager agent . The higher-level mid-level manager agent may manage and consolidate information from lower-level mid-level manager agents and . The lower-level mid-level manager agents may then manage and consolidate information from a plurality of agents through . In one embodiment, the enterprise management system may include zero or more levels of mid-level manager agents and one or more other agents.","Advantages of Mid-Level Managers","The use of a mid-level manager may tend to bring many advantages. First, it may be desirable to funnel all traffic via one connection rather than through many agents. Use of only one connection between a console and a mid-level manager agent may therefore result in improved network efficiency.","Second, by combining the data on the multiple managed agents to generate composite events or correlated events, the mid-level manager may offer an aggregated view of data. In other words, an agent or console at an upper level may see the overall status of lower levels without being concerned about individual agents at those lower levels. Although this form of correlation could also occur at the console level, performing the correlation at the mid-level manager level tends to confer benefits such as enhanced scalability.","Third, the mid-level manager may offer filtered views of different levels, from enterprise levels to detailed system component levels. By filtering statuses or events at different levels, a user may gain different views of the status of the enterprise.","Fourth, the addition of a mid-level manager may offer a multi-tiered approach towards deployment and management of agents. If one level of mid-level managers is used, for example, then the approach is three-tiered. Furthermore, by supporting inter-communication between mid-level managers and other mid-level managers, the improved enterprise management system may support a multi-tiered architecture with an arbitrary number of levels. In other words, a higher level of mid-level managers may manage a lower level of mid-level managers, and so on. This multi-tiered architecture may allow one console to manage a large number of agents more easily and efficiently.","Fifth, the mid-level manager may allow for efficient, localized configuration. Without a mid-level manager, the console must usually provide configuration data for every agent. For example, the console would have to keep track of valid usernames and passwords on every managed machine in the enterprise. With a multi-tiered architecture, however, several mid-level managers rather than a single, centralized console may maintain configuration information for local agents. With the mid-level manager, therefore, the difficulties of maintaining such centralized information may in large part be avoided.","Mid-Level Manager Back-End","In one embodiment, mid-level manager functionality may be implemented through a mid-level manager back-end. The mid-level manager back-end may be included in any agent that is desired to be deployed as a mid-level manager. In one embodiment, the top-level object of the mid-level manager back-end may be named \u201cMM.\u201d As discussed with reference to , the agents managed by a mid-level manager are referred to herein as \u201csub-agents.\u201d The mid-level manager back-end may maintain a local file called a sub-agent profile to keep track of sub-agents. When a mid-level manager starts, it may read the sub-agent profile file and, if specified in the profile, connect to sub-agents via a \u201cmount\u201d operation provided by the common object system protocol. The profile may be set up by an administrator in a deployment server and deployed to the mid-level manager.","For each sub-agent managed by the mid-level manager, a proxy object may be created under the top-level object \u201cMM.\u201d Proxy objects are entry points to namespaces of sub-agents. In the mid-level manager, objects such as back-ends in sub-agents may be accessed by specifying a pathname of the form \u201c\/MM\/sub-agent-name\/object-name\/ . . . .\u201d The following events may be published on proxy objects to notify back-end clients: connect, disconnect, connection broken, and hang-up. The connect event may notify clients that the connection to a sub-agent has been established. The disconnect event may notify clients that a sub-agent has been disconnected according to a request from a back-end. The connection broken event may notify clients that the connection to a sub-agent has been broken due to network problems. The hang-up event may notify clients that the connection to a sub-agent has been broken by the sub-agent.","In one embodiment, the mid-level manager back-end may accept the following requests from other back-ends: connect, disconnect, register interest, and remove interest. The \u201cconnect\u201d request may establish a connection to a sub-agent. In the profile, the sub-agent may then be marked as \u201cconnected.\u201d The \u201cdisconnect\u201d request may disconnect from a sub-agent. In the profile, the sub-agent may then be marked as \u201cdisconnected.\u201d The \u201cregister interest\u201d request may have the effect of registering interest in a knowledge module (KM) package in a sub-agent. The KM package may then be recorded in the profile for the sub-agent. The \u201cremove interest\u201d request may have the effect of removing interest in a KM package in a sub-agent. The KM package may then be removed from the profile of the sub-agent.","The mid-level manager back-end may provide the functionality to add a subagent, remove a subagent, save the current set of subagents to the subagent profile, load subagents from the subagent profile, connect to a subagent, disconnect from a subagent, register interest in a KM package in a sub-agent, remove interest in a KM package in a sub-agent, push KM packages to subagents in development mode for KM development, and\/or erase KM packages from subagents in development mode.","The mid-level manager back-end may have two object classes: \u201cmmManager\u201d and \u201cmmProxy.\u201d An \u201cmmManager\u201d object may keep track of a set of \u201cmmProxy\u201d objects. An \u201cmmManager\u201d object may be associated with a subagent profile. An \u201cmmProxy\u201d object may represent a sub-agent in a master agent. It may be the entry point to the namespace of the sub-agent. In one embodiment, most of the mid-level manager functionality may be implemented by these objects.","The \u201cmmManager\u201d Object","In the mid-level manager backend of a master agent, multiple \u201cmmManager\u201d objects may be created to represent different domains of sub-agents, respectively. An \u201cmmManager\u201d object may be the root object of a mid-level manager back-end instance. In one embodiment, an \u201cmmManager\u201d class corresponding to the \u201cmmManager\u201d object is derived from a \u201cCos_VirtualObject\u201d class. The name of an \u201cmmManager\u201d object may be set to \u201cMM\u201d by default. In one embodiment, it may be set to any valid Common Object System (COS) object name as long as the name is unique among other COS objects under the same parent object. Attributes of an \u201cmmManager\u201d object may include the attributes shown in the table in FIG. . An attribute with access code \u201cC\u201d is set only during initialization. Access code \u201cG\u201d means that an attribute is readable by other back-ends using a COS \u201cget\u201d method. Access code \u201cS\u201d means that an attribute is settable by other back-ends using a COS \u201cset\u201d method.","A subagent may be added to a MM back-end by calling the \u201ccreateObject\u201d method of its \u201cmmManager\u201d object. This method may support creating an \u201cmmProxy\u201d object as a child of the \u201cmmManager\u201d object. In one embodiment, an \u201cmmProxy\u201d object should have a name that is unique among \u201cmmProxy\u201d objects under the same \u201cmmManager\u201d object. A subagent may be removed from an MM back-end by calling the \u201cdestroyObject\u201d method of its associated \u201cmmManager\u201d object.","After an \u201cmmManager\u201d object is created, the \u201cload\u201d method may be called to load the associated subagent profile. The \u201cload\u201d method may be available via a COS \u201cexecute\u201d call. In one embodiment, a subagent profile is a text file in MOF format with multiple MOF instances representing subagents. A subagent is represented as a MOF instance. A MOF instance has multiple attributes as shown in the table in , which is the class definition of the \u201cmmProxy\u201d object.","In one embodiment, if \u201c*\u201d is used in both the \u201cincluded KM packages\u201d and \u201cexcluded KM packages\u201d fields, the one in \u201cexcluded KM packages\u201d field takes precedence. That is, no KM packages will be of interest for that subagent.","In one embodiment, the \u201cmmManager\u201d object supports the \u201csave\u201d method to save subagent information to the associated subagent profile file. The \u201csave\u201d method may be available via a COS \u201cexecute\u201d call. When the \u201csave\u201d method is called, the \u201cmmManager\u201d object may scan children that are \u201cmmProxy\u201d objects. For each \u201cmmProxy\u201d child, a MOF instance may be printed as defined in the above table. The \u201cmmManager\u201d object may use a dirty bit to synchronize itself with the associated subagent profile.","The \u201cmmProxy\u201d Object","An \u201cmmProxy\u201d object may provide the entry point to the namespace of the subagent that it represents. The \u201cmmProxy\u201d object may be derived from the COS mount object. In one embodiment, the name of an \u201cmmProxy\u201d object is usually the name of the corresponding subagent. Attributes of an \u201cmmProxy\u201d object may be as shown in the table in FIG. .","After an \u201cmmProxy\u201d object is created, the \u201cconnect\u201d method may be called to connect to the subagent. The connection state attribute may be updated to reflect the progress of the connect progress. In one embodiment, when a non-zero heartbeat time is given, an \u201cmmProxy\u201d object will periodically check the connection with the subagent. If the subagent does not reply in the heartbeat time, the \u201cBROKEN\u201d connection state is reached. Setting this attribute to zero disables the heartbeat checking. The user name given in the user ID attribute is used to obtain an access token to access the subagent's namespace. The privilege of the master agent in the subagent is determined by the subagent using the access token. The \u201cdisconnect\u201d method may be called to disconnect from the subagent.","An \u201cmmProxy\u201d object keeps track of KM packages that are available in the corresponding subagent and are of interest to the master agent. The \u201cincluded KM packages\u201d and \u201cexcluded KM packages\u201d attributes are initialized when the \u201cmmProxy\u201d object is loaded from the subagent profile. They are empty if the \u201cmmProxy\u201d object is created after the subagent profile is loaded. The \u201ceffective KM packages\u201d attribute is determined based on the value of \u201cincluded KM packages\u201d and \u201cexcluded KM packages\u201d attributes. The rules may be as shown in the table in FIG. .","In one embodiment, the \u201cmmProxy\u201d object may support four methods for KM package management: \u201cregister\u201d, \u201cremove\u201d, \u201cinclude\u201d and \u201cexclude\u201d. These methods may be available via a COSP \u201cexecute\u201d call. Calling \u201cregister\u201d may add a KM package to the effective KM package list, if the KM package is not already in the list. The KM package may be optionally added to the \u201cincluded KM packages\u201d list. Calling \u201cremove\u201d may remove a KM package from the effective KM package list, and optionally add it to the \u201cexcluded KM packages\u201d list. In both methods, the KM package may be given as the first argument of the \u201cexecute\u201d call. The second argument may specify whether to add the KM package to the \u201cincluded\/excluded KM packages\u201d list. Calling \u201cinclude\u201d may add a KM package to the \u201cincluded KM packages\u201d list if it is not already in the list. Calling \u201cexclude\u201d may add a KM package to the \u201cexcluded KM packages\u201d list if it is not already in the list. In one embodiment, the KM package is given as the first argument of the \u201cexecute\u201d call. Optionally, a second argument may be used to specify whether a replace operation should be performed instead of an add operation. If the \u201cincluded\/excluded KM packages\u201d list is changed by a call, the \u201ceffective KM packages\u201d may be recalculated based on the mentioned rules. When the \u201ceffective KM packages\u201d list is changed, the \u201cmmProxy\u201d object may communicate to the KM back-end of the subagent to adjust the KM interest of the master agent, which is described below.","When an \u201cmmProxy\u201d object successfully connects to the corresponding subagent, it may register KM interest in the subagent based on the value of its \u201ceffective KM packages\u201d attribute. For each effective KM package, the \u201cmmProxy\u201d object may issue a \u201cregister\u201d COSP \u201cexecute\u201d call on the remote \u201c\/KM\u201d object, passing the KM package name as the first argument. Upon receiving this call, the KM back-end in the subagent may load the KM package if it is not already loaded and may initiate discovery processes.","The \u201cmmProxy\u201d object may have a class-wide event handler to watch the value of the \u201ceffective KM packages\u201d attributes of \u201cmmProxy\u201d objects. This event handler may subscribe to \u201cCos_SetEvent\u201d events on that attribute. Upon receiving a \u201cCos_SetEvent\u201d event, this event handler may perform the following actions. For each KM package that is included in the \u201cold value\u201d and is not included in the \u201cnew value\u201d of the attribute, the event handler may issue a \u201cremove\u201d COSP \u201cexecute\u201d call on the remote \u201c\/KM\u201d object. For each KM package that is not included in the \u201cold value\u201d and is included in the \u201cnew value\u201d of the attribute, the event handler may issue a \u201cregister\u201d COSP \u201cexecute\u201d call on the remote \u201c\/KM\u201d object.","MM Back-End Events","In one embodiment, the MM back-end may use standard COS events, as shown in the table in FIG. .","KM Development Console","The MM back-end may also serve as the gateway to development agents for a development console. The development console may include a KM IDE and production console. The KM IDE may provide editing functionality, and the production console may provide monitoring functionality. Combined, they may provide an integrated development and testing environment. The KM IDE may maintain a COS namespace and may mount the KM back-end and the MM back-end. KM packages under development may be maintained in the KM back-end, and development agents may be maintained in the MM back-end. Via the MM back-end, the KM IDE may have seamless access to KM namespaces of development agents.","The production console may include a GUI component and a namespace component. The namespace component may include a separate process supporting a console namespace. In one embodiment, a console namespace is an agent namespace with layout back-ends. The KM IDE may add the namespace component to its MM back-end to test KM packages such as KM that perform view consolidation and KM that implement specific views.","The KM IDE may mount the KM back-end in its namespace. KM data that is edited may be maintained in the KM back-end. GUI modules of the KM IDE may access KM data via the COS API, including the \u201ccreateObject\u201d, \u201cdestroyObject\u201d, \u201cget\u201d, and \u201cset\u201d methods. The KM IDE may save KM packages under development as files by serializing KM packages in the KM back-end. The KM IDE may load KM packages by decoding KM package files. The result may be downloaded to development agents for testing. The mechanism of downloading KM packages and keeping them synchronized between KM IDE and development agents is described below.","In one embodiment, it is necessary to download a KM package to appropriate development agents to test the KM package. In addition, it may be necessary to keep a KM package synchronized between the KM IDE and development agents. This synchronization may be achieved by a KM sync module in the KM IDE. When the KM IDE starts, event handlers may be created in the KM sync module, including a load handler and an unload handler.","The load-handler may subscribe to a \u201cKM_LoadEvent\u201d event on the \u201c\/KM\u201d object. When a KM package is loaded, the handler may receive the event and perform the following actions. For each MM back-end, iterate through each subagent, i.e., development agent. Test to see if the KM package is included in the \u201ceffective KM packages\u201d list of the subagent. If yes, issue a COS \u201cexecute\u201d call on the remote \u201c\/KM\u201d object in the subagent, calling the \u201cload\u201d method and passing the serialized KM package that is loaded in the KM IDE as the argument. The KM back-end in the subagent may then load the KM package, and the runtime back-end may then start running the KM package.","The unload-handler may subscribe to a \u201cKM_UnloadEvent\u201d event on the \u201c\/KM\u201d object. When a KM package is unloaded in the KM IDE, the handler may receive the event and perform the following actions. For each MM back-end, iterate through each subagent, i.e., development agent. Test to see if the KM package is included in the \u201ceffective KM packages\u201d list of the subagent. If yes, issue a COS \u201cexecute\u201d call on the remote \u201c\/KM\u201d object in the subagent, calling the \u201cunload\u201d method and passing the KM package name that is unloaded in the KM IDE as the argument. In one embodiment, runtime objects in the subagent will be destroyed, and the KM package will be unloaded in the subagent.","After a KM package has been downloaded to development agents, it may be necessary to keep it synchronized between the KM IDE and the development agents. This may be achieved as follows.","When the KM IDE creates a new object in the local KM back-end, the local KM back-end may perform a remote \u201ccreateObject\u201d operation in the KM back-ends of involved development agents. The same object is then created in KM back-ends of involved development agents. The KM back-end of a development agent then may publish a \u201cKM_CreateObjectEvent\u201d to notify the runtime back-end to pickup the new object.","When the KM IDE destroys an object in the local KM back-end, the local KM backend may perform a remove \u201cdestroyObject\u201d operation in the KM back-ends of involved development agents. The same object is then destroyed in KM back-ends of involved development agents. The KM backend of a development agent then may publish a \u201cKM_DestroyObjectEvent\u201d to notify the runtime back-end to destroy runtime objects that are instances of the destroyed KM object.","The KM IDE may launch a dialog window to perform editing of a KM object. When the \u201cOK\u201d or \u201cApply\u201d button of the dialog window is pushed, the KM IDE may change the corresponding KM data structure basing on values from the dialog window by calling the \u201csetAttributeValue\u201d COS function in the local KM back-end. The local KM back-end may perform \u201csetAttributeValue\u201d operations in the KM back-ends of involved development agents. The same changes are then applied to KM back-ends of involved development agents. The KM back-end of a development agent then may publish a \u201cKM_ModifyObjectEvent\u201d to notify the runtime back-end to pickup the change. This mechanism is summarized in the table in FIG. .","Various files may be referred in a KM package, such as PSL command files and OS command files. A \u201cpull\u201d approach may be used to reference these files and enable development agents to run the KM package. In one embodiment, files are not transferred until they are used. Instead, a KM attribute that is a filename may contain the last modified timestamp of the file. When a development agent uses such a file, it may match the modified timestamp of the local file with the timestamp sent by the development console. If the file is out of date, the development agent may publish an event to request the file from development console. The procedure is as follows.","The development agent may publish a \u201cKM_FileSyncEvent\u201d event on the object that owns the filename attribute to request file transfer. The attribute name may be included in the event to indicate which file to be transferred. The development agent may subscribe to the \u201cKM_FileSyncDoneEvent\u201d event on the object that owns the filename attribute. An operation in the development agent that needs the file may suspend and may continue when this event is received. The KM IDE may subscribe to the \u201cKM_FileSyncEvent\u201d event. Upon receiving the event, the KM IDE may start a COSP FTP (File Transfer Protocol) sequence to transfer the required file. When the file transfer is done, the client object of the COSP FTP sequence may publish a \u201cKM_FileSyncDoneEvent\u201d on the object that owns the file attribute to notify the development agent of the availability of the file.","In the development console, the production console may serve as the testing component. It may provide the functionality for a KM developer to test KM packages under development. The production console may share the development agents that are used by the KM IDE. It may monitor the KM packages that are on the \u201ceffective KM packages list\u201d lists of all subagents. The architecture for sharing KM data between a KM IDE component and a production console component in a development console according to one embodiment is specified below.","KM packages may be downloaded from the KM IDE to development agents via MM back-end for testing. To monitor KM packages that are running in development agents, an appropriate master agent and subagent topology hierarchy may be set up, starting from the production console. In one embodiment, the KM developer must have the right to modify the MM back-end in the agent component of the production console and in all development agents. In the KM IDE, KM packages that perform view consolidation and correlation may be developed as normal KM packages. To test such a KM package, the KM IDE may down load the KM package to master agents that are in higher layers of the topology hierarchy.","The Agent API and the MM Back-End","The MM back-end may also provide a programming interface for client access to agents. A client that desires to access information in agents may be implemented using the COS-COSP infrastructure discussed above. With a namespace established it then may mount MM back-ends into the namespace. If the mount operations are successful, then the client has full access to namespaces of subagents under security constraints.","In one embodiment, the API to access subagents is the COS API, including methods such as \u201cget\u201d, \u201cset\u201d, \u201cpublish\u201d, \u201csubscribe\u201d, \u201cunsubscribe\u201d, and \u201cexecute\u201d. Full path names are used to specify objects in subagents. Using \u201csubscribe\u201d, a client may obtain events published in the namespaces of subagents. Using \u201cset\u201d and \u201cpublish\u201d, a client may trigger activities in subagents. In one embodiment, performance enhancement may be achieved by introducing a caching mechanism into COSP.","In one embodiment, before this API is available to a client, the client must be authenticated with a security mechanism. The client must provide identification information to be verified that it is a valid user in the system. In one embodiment, the procedure for a client program to establish access to agents is summarized as follows. A COS namespace may be created. An access token may be obtained by completing the authentication process. MM back-ends may be mounted, and subagent profiles may be loaded. The client program may connect to subagents. The client program may then start accessing objects in subagents using the COS API.","Various embodiments further include receiving or storing instructions and\/or data implemented in accordance with the foregoing description upon a carrier medium. Suitable carrier mediums include storage mediums such as magnetic or optical media, e.g., disk or CD-ROM, as well as signals or transmission media such as electrical, electromagnetic, or digital signals, conveyed via a communication medium such as networks  and  and\/or a wireless link.","Although the system and method of the present invention have been described in connection with several embodiments, the invention is not intended to be limited to the specific forms set forth herein, but on the contrary, it is intended to cover such alternatives, modifications, and equivalents, as can be reasonably included within the spirit and scope of the invention as defined by the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["A better understanding of the present invention can be obtained when the following detailed description of several embodiments is considered in conjunction with the following drawings, in which:",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 16"}]},"DETDESC":[{},{}]}
