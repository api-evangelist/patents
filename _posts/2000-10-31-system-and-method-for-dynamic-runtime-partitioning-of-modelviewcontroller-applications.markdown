---
title: System and method for dynamic runtime partitioning of model-view-controller applications
abstract: Methods and apparatus for dynamic runtime partitioning of network-based client/server applications using a Model-View-Controller pattern are provided. Such dynamic partitioning is accomplished by requiring that the application specify: (i) that access to the Model be done through an application programming interface (API) which allows the system runtime to dynamically allocate and access Model storage on the client and/or server; and (ii) that access to the View be done through an API which allows the system runtime to dynamically allocate and access View components on the client and/or server. This enables applications written and tested in such a manner (referred to herein as the “canonical form”) to execute in a non-distributed mode or in a dynamically partitioned mode in which client/server issues are not a factor. This greatly facilitates development of the application. Furthermore, by specifying View components in an abstract, or “platform-independent” API, the application can run on multiple client devices without modifying the application. All that is required is a platform-specific implementation of the View components' API. Client platforms for the application can thus include, for example, applets, HTML browsers, and PDAs.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06950850&OS=06950850&RS=06950850
owner: International Business Machines Corporation
number: 06950850
owner_city: Armonk
owner_country: US
publication_date: 20001031
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS"],"p":["The present invention is related to network-based client\/server applications, for example, executing over the world wide web (e.g., Internet\/Intranet) and, more particularly, to methods and systems for dynamic runtime partitioning of network-based client\/server applications using a Model-View-Controller pattern.","Interactive applications (i.e., computer software programs written to perform particular functions in accordance with user interaction) can be usefully described as examples of the Model-View-Controller (MVC) design pattern. In this pattern, an interactive application is divided into three components. The \u201cModel\u201d contains data used by the application. The \u201cView(s)\u201d displays information about the data to the user. The \u201cController(s)\u201d handle user input to the application.","In the original MVC design pattern, Views and Controllers together comprise the user interface, and an event handling mechanism processes user interactions so as to ensure consistency between the user interface and the model.","More generally, the \u201clow-level Controller\u201d associated with a \u201clow-level View element\u201d (e.g., the software that processes the activation of a mouse button on a clickable on-screen button) can be combined into a single \u201cPresentation\u201d or \u201chigh-level View component.\u201d The term \u201cController\u201d is then used to denote \u201chigh-level\u201d software that connects the Model and View components so as to modify the Model as a function of user interaction and to modify the View as a function of the Model's state. We use the term MVC in this, more generalized, sense which actually corresponds more closely to the Presentation-Abstraction-Control (or PAC) architecture pattern. Although originally used to describe only the first pattern, the term MVC is commonly used to describe the more general pattern.","Deployed client\/server applications are partitioned so that one portion of the application runs on the server and the other portion on the client. In the case of an interactive (i.e., MVC) application, partitioning determines which portions of the Model, View, and Controller reside on the client and which reside on the server. For example, in HTML-based (HyperText Markup Language-based) browser environments, the entire Model, View, and Controller reside on the server and the client device is used only to render the View. Conversely, in so-called \u201cfat client\u201d applications, much of the Model, View, and Controller reside on the client with a small portion residing on the server.","Whatever the partitioning choice, currently, the choice must be made either in the application's design phase or, at the latest, during application implementation. Controller code is typically \u201clocation-dependent\u201d meaning that it is explicitly written to execute on the client or on the server. Even when the Controller is not location-dependent, current View technologies strongly determine a static partitioning of the application. For example, in the current state of the art, because an application's View components are tightly coupled with the manner in which the components are rendered, the choice of a given View technology strongly determines where code involving those components must execute. Thus, if the View consists of HTML components rendered in a web browser, the View components will typically reside on the server because it is non-trivial for a web browser to include code that generates HTML. Alternatively, if the View components are elements of Sun Microsystems\u2122 Swing libraries, the components must reside on the client because Swing components require local display media.","A similar situation applies with regard to the application's Model. Typically, the Model is statically partitioned because the data must physically reside either on the client or on the server. For example, allocating Model storage on either the client-side or the server-side of the application ties Controllers that access that Model to execute on only that side of the application.","Techniques exist in which Model storage is allocated on either the client or on the server but accessed by the Controller in a location-transparent way. These include database APIs (Application Programming Interfaces) such as ODBC (Open Database Connectivity) and JDBC (Java Database Connectivity). Although these techniques transparently make transient copies of portions of the data to the Controller, they require static partitioning of the Model, i.e., the database must reside on either the client or a server.","In other techniques, Controllers are statically partitioned between client and server. The client-side Controller handles initial event dispatching (e.g., button clicks), and the server-side Controller (which involves Model access) is co-located with the physical Model storage. The calling linkage between the partitioned Controller sections is achieved with a location-transparent runtime such as Remote Procedure Calls (RPC), Java Remote Method Invocation (RMI), and OMG CORBA (Object Management Group Common Object Request Broker Architecture). Such techniques also require static partitioning of the Model since persistent state is still located on a specific machine.","Writing applications in a location-dependent manner or in a statically partitioned manner has many disadvantages, some of which are now discussed.","First, application developers cannot defer partitioning decisions, both in terms of splitting function between the client and the server and in terms of selection of the client device, e.g., web browser, personal digital assistant or PDA, cellular phone. Deferring the decision is advantageous because it allows more accurate information about the deployment environment to be incorporated into the decision.","Further, remote Model access or Controller linkage to a remote Model incurs a performance penalty, since the data and parameters must be marshaled\/demarshaled and copied over a network.","Also, performance evaluation of the application can involve only a specific partitioning of the application rather than also examining alternative partitionings of the application. Often, it is too costly to independently implement different partitionings of an application. For example, under a dual-MVC architecture, as described in: U.S. patent application identified as Ser. No. 09\/500,208, filed on Feb. 8, 2000 in the name of Betz et al. and entitled: \u201cMethods and Apparatus for Reducing the Number of Server Interactions in Network-based Applications Using a Dual-MVC Approach,\u201d the disclosure of which is incorporated by reference herein; and in K. Betz, A. Leff and J. Rayfield, \u201cDeveloping Highly-Responsive User Interfaces with DHTML and Servlets,\u201d 19th IEEE International Performance, Computing, and Communications Conference\u2014IPCCC-2000, some controllers execute on the client rather than the server, thus offloading work from the server to the client and reducing network communication, potentially improving performance. However, dual-MVC only provides a framework for such partitioning, without allowing the examination of the implications of various partitions. Static partitioning does not allow developers to take full advantage of the possibilities of dual-MVC.","Still further, application developers prefer to concentrate on the application's \u201clook and feel\u201d and \u201cflow\u201d as opposed to focusing on partition-specific issues that are independent of the application's behavior.","Lastly, application development and testing are harder in a distributed environment because of the required infrastructure, e.g., a web server, network connectivity, debugger.","The MVC design pattern was first introduced in the Smalltalk-80 programming environment, see G. E. Krasner and S. T. Pope, \u201cA Cookbook for Using the Model-View-Controller User-Interface Paradigm in Smalltalk-80,\u201d Journal of Object-Oriented Programming, pp. 26\u201349, August\/September 1988, SIGS Publications 1988. PAC was first described in J. Coutaz, \u201cPAC, An Object-Oriented Model for Dialog Design,\u201d Human-Computer Interaction\u2014INTERACT 1987 proceedings, pp. 431\u2013436, Elsevier Science Publishers, 1987. See Buschmann et al., \u201cA System of Patterns,\u201d pp. 123\u2013169, John Wiley & Sons, 1996, for further background on the MVC and PAC design patterns. Unfortunately, the MVC and PAC design patterns are not concerned with issues associated with application deployment to a client\/server environment such as how an application is partitioned between the client and the server.","Deployment to multiple platforms from a single-source View description is not new, e.g., see IBM Corporation\u2122 VisualAge OpenClass libraries and Sun Microsystem\u2122 Java AWT (Abstract Window Toolkit) which already provide similar functionality.","The IBM Corporation\u2122 VisualAge for Java Ultra Light Client service offering (see http:\/\/www7.software.ibm.com\/vad.nsf\/Data\/Document3141?OpenDocument&p=1 &BCT=3&Footer=1, by Skyler Thomas and Pat Huff) provides server-side Swing-compliant View components which are transparently rendered on the client side by a lightweight client application. In contrast, as will be explained below, the present invention may use actual Swing components (in one embodiment) on the client side, and corresponding non-visual server-side components that can be converted to and from the client-side components.","The present invention provides methods and systems which enable Controllers to execute in a dynamically partitioned manner, meaning that decisions about where a Controller will execute or where a View or Model element will be instantiated occur after the application is written and without modification to the application. Dynamic partitioning may be done on a per-Controller basis, meaning that individual Controllers will execute on either the client or server but not on both. Alternatively, dynamic partitioning may be done on a per-Controller-invocation basis, meaning that the execution location of a Controller may change during runtime execution as conditions warrant (e.g., network congestion, cache contents).","In one aspect of the invention, such dynamic partitioning is accomplished by deploying one or more specific applications into a system runtime. Applications contain the necessary Model, View(s), and Controller(s) used to implement the application-dependent business logic and user interactions. It is to be understood that the \u201csystem runtime\u201d includes the application-independent logic, communications network, and CPU (central processing unit) infrastructure used by deployed applications to communicate the required state (such as, for example, the Controller to be executed, the arguments used in the Controller's execution, and updates to the Model and View state) between client and server. Dynamic partitioning is accomplished by requiring that the application specify: (i) that access to the Model be done through an API which allows the system runtime to dynamically allocate and access Model storage on the client and\/or server; and (ii) that access to the View be done through an API which allows the system runtime to dynamically allocate and access View components on the client and\/or server. This enables applications written and tested in such a manner (referred to herein as the \u201ccanonical form\u201d) to execute in a non-distributed mode or in a dynamically partitioned mode in which client\/server issues are not a factor. This greatly facilitates development of the application.","Furthermore, by specifying View components in an abstract, or \u201cplatform-independent\u201d API, the application can run on multiple client devices without modifying the application. All that is required is a platform-specific implementation of the View components' API. Client platforms for the application can thus include, for example, applets, HTML browsers, and PDAs.","These and other objects, features and advantages of the present invention will become apparent from the following detailed description of illustrative embodiments thereof, which is to be read in connection with the accompanying drawings.","The present invention provides a \u201ccanonical form\u201d to describe MVC applications. One aspect of the canonical form is that it is independent of, and does not involve, issues related to deploying the application in a distributed client\/server environment. The canonical form is therefore \u201csingle MVC\u201d because the MVC description of the application relates to a single or non-distributed platform.","As will be illustrated below, the canonical form of an application according to the invention may comprise: (i) View components; (ii) Model\/View APIs; (iii) Event Handlers (Controllers) and an Event Handler registration; and (iv) an Application lifecycle. As is known and as will be evident, the lifecycle of an application refers to the fact that objects or elements associated with the application can be created and deleted.","The inventive application form is \u201ccanonical\u201d in the sense that MVC applications can be developed and tested in this form with the assurance that when the application is deployed to a specific client\/server technology and\/or its Controllers are partitioned between the client and the server that the application will be functionally identical to that of the canonical form.","Further, as will be illustrated below, the View components and Model and View APIs enable dynamic runtime partitioning of the application by allowing the application's Controllers to execute without change on either the client or server side. The invention provides a methodology to deploy, dynamically partition, and execute the application without changing the canonical form. Specifically, as will be illustrated below, the invention provides a methodology that describes how: (i) the Model and Controller portion of the application can execute on the server, while the View is rendered on the client (e.g., a web browser, or PDA); (ii) portions of the application's Model and Controller components can execute on either the client or the server, while the View is rendered on the client; (iii) the manner in which the application is partitioned (i.e., which parts of the Controller and Model reside on the client) and can be configured dynamically; (iv) the Model can be dynamically moved between the client and the server; and (v) the View can be dynamically moved between the client and the server.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 1","FIG. 1"],"b":["10","10","1","10","10","3","10","2","10","1","20","20","1","20","30","30","10","2","20"],"i":["n","m"]},"A user interacts with the initial View  by typing the full or partial name of an employee into the input field. The View-generating Logic of the FWAPlication  creates a new View  that, for each employee in the result set, contains a row comprised of a clickable \u201cdetails\u201d button (-, - and -) and a label that displays the employee's name (- corresponding to -, - corresponding to - and - corresponding to -). The new View  is displayed to the user, who may then continue interacting with the application, e.g., by clicking on a \u201cdetails\u201d button to get more detailed information about an individual employee.","The high-level representation shown in  must be realized concretely as an application. Advantageously, as will be explained in detail below, applications written in the canonical form according to the present invention access the View through a View API and the Model through a Model API. The programming language and details of the APIs are not important, and those of ordinary skill in the art will realize that many alternatives are possible. The present invention requires only that a canonical form of an MVC application consistently access the View or Model through these APIs.","An example of a View API is shown in . Specifically,  shows an API  in the canonical form to access the View. The API comprises methods to create and delete View components (-, -), and to read and write or update the properties or state of individual View components (- through -).","It is to be appreciated that any programming model: (i) with a well-structured lifecycle API; and (ii) that requires that View elements have identity so that a View element can always be located through an associated key, can be used as the View API used in the present invention's canonical form to access the View. The Enterprise JavaBeans specification (http:\/\/java.sun.com\/products\/ejb\/) is one example of such an API.","An example of a Model API is shown in . Specifically,  shows an API  used in the canonical form to access the Model. The API comprises methods to locate ModelHomes (-), and once a ModelHome is located, methods to create (-), query or find (- and -), and delete (-) Model elements.","It is to be appreciated that any programming model: (i) with a well-structured lifecycle API; and (ii) that requires that Model elements have identity so that a Model element can always be located through an associated key, can be used as the Model API used in the present invention's canonical form to access the Model. The Enterprise JavaBeans specification (http:\/\/java.sun.com\/products\/ejb\/) is one example of such an API.","It is also to be understood that while the example of the View API above includes methods to create and delete View elements, and to read and write the properties or state of individual View elements, the Model API can also have the same or similar methods for performing the same or similar operations with respect to the Model elements. Likewise, while the example of the Model API above includes methods to locate, create, query and delete Model elements, the View API can also have the same or similar methods for performing the same or similar operations with respect to the View elements. Of course, the operations that can be performed by the APIs is not limited to these examples. That is, depending on the nature of application itself, other operations besides creating, finding (retrieving, querying), reading, updating and deleting of elements (Model elements and\/or View elements) can be employed.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 4","FIG. 1","FIG. 4","FIG. 4","FIG. 1"],"b":["30","11","12","30"]},"As shown in , statement - represents a FWAPlication Controller named ProcessSearchRequest, and consists of statements - through -. In statement -, the controller obtains a reference to a text-field view element with key inputKey. In -, the controller obtains the query string containing the name of the employee. In -, a reference to the employee Home is obtained. In -, a query is executed on the employee Home to find the set of employees matching the specified query string. In -, a call is made to a method which creates the new View from the query string and search result set.","Statement - represents view-generation logic which creates the initial View for the FWAPlication. In statement -, the enclosing frame is created. In -, the text-input field (to contain the search query string entered by the user) is created and inserted into the frame. In -, the logic specifies that the CHANGE event for the text-entry field (invoked when the user modifies the contents of the field) is associated with the Controller ProcessSearchRequest (-).","Thus, statements - and - reference the Model; statements - and - reference the View. Statements -, -, -, - and - contain logic that creates or modifies Views. The procedure - is thus a Controller, and the procedure - builds a View.","An application, in canonical form, is developed and tested through deployment to a non-distributed environment. This requires the selection of a specific technology to render View components and to construct Model elements. In one embodiment, View components wrap (encapsulate) Java Swing components; and Model elements wrap the EntityBeans of the Enterprise JavaBeans architecture. Those skilled in the art will realize that many View and Model technologies can be similarly utilized to deploy the canonical form to a non-distributed environment.","The canonical form is used to develop and test an application without regard to distribution and partitioning issues. The development and test activities thus exercise the application's Controller logic, View construction and Model access with respect to sample user interactions. In another portion of the present invention, the canonical form of an application is deployed to a specific client\/server environment; optionally, dynamically partitioned so that specific Controllers execute on the client and other Controllers execute on the server; and the deployed form of the application executes in a distributed client\/server environment.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 5","FIG. 5"],"b":["30","70","60","30","70","60"]},"In general,  illustrates a block diagram of an exemplary client\/server system suitable for employing the present invention. The system comprises a client computer system  which is configured to run web browser software. It is to be appreciated that any suitable web browser software may be employed and that the methodologies of the invention are not limited to any particular web browser software. Further, as shown in the client\/server system of , the web browser communicates over a network  with a web server . The network  may employ a HyperText Transport Protocol (HTTP), as is well known in the art and as is implemented in accordance with the world wide web, however, other suitable protocols and networks may be employed. For example, the client and server may alternatively be connected via a private network, a local area network, or some other suitable network. It is to be appreciated that an example of such a client\/server system as illustrated in  may include an arrangement wherein a user at a personal computer or workstation (client) accesses a particular application (e.g., help desk, life insurance underwriting, health insurance pre-certification for medical procedures, and automated teller machines) written in accordance with the present invention and associated with a particular server on the HTTP network in accordance with web browser software loaded and running on the client machine. The client device  may alternatively be a PDA or other client-side processing device.","In this \u201cthin-client\u201d deployment arrangement shown in , so-called because neither the Model nor the Controller reside on the client, the FWAPlication  executes \u201cas is.\u201d That is, the code executing on the server  is identical to the code executing under the canonical form deployment. In addition, a controller servlet  at the server  mediates interaction between the thin-client  and the executing FWAPlication . Moreover, the implementation of the View components  at the server  contains code that can render the component and its properties into HTML, which is assumed to be the rendering technology of the client platform . For example, a \u201cbutton\u201d View component is rendered, under thin-client deployment, as <INPUT TYPE=BUTTON NAME=buttonName . . . >. Those skilled in the art will readily recognize that the server-side View components can render any HTML component in this manner. The View implementation thus allows the Controller to access a fully-instantiated, but invisible, View that executes on the server-side. The server-side View can render itself in HTML in such a manner that it can be suitably displayed as the View on the client platform .","The client acquires the initial View  () by issuing a HTTP GET operation to the controller servlet , specifying that FWAPlication  begin execution on the server. The controller servlet asks the server-side FWAPlication to construct the initial View  and render it into HTML; the HTML is then returned to the client  and rendered (). As part of the HTML, for each event handler that the developer has associated with a View component (via the registerController API of ), the View component generates JavaScript code that is attached to the HTML defining the client-side component. The JavaScript associates a FWAPlication Controller with the named component. For example, the \u201cSearch\u201d button is associated with the ProcessSearchRequest Controller of .",{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 5","b":["10","50","300","30","310","315","320","80","340","330"]},"As a result of the server-side Controller execution, a new View containing the employee information is constructed on the server, and rendered into HTML in step . The controller servlet returns this HTML in step  as the result of the client's POST operation, and the new View  is rendered on the client platform . This generic execution cycle then repeats through the course of the user interacting with the deployed FWAPlication.","Thin-client deployment is one of several possible deployment strategies for a given canonical MVC application; the Model and Controller execute on the server, and the View is rendered on the client side. The present invention, however, also allows for the canonical form of an MVC application to be deployed to a dual-MVC architecture as described in the above-referenced U.S. patent application identified as Ser. No. 09\/500,208, filed on Feb. 8, 2000 in the name of Betz et al. and entitled: \u201cMethods and Apparatus for Reducing the Number of Server Interactions in Network-based Applications Using a Dual-MVC Approach;\u201d and in K. Betz, A. Leff and J. Rayfield, \u201cDeveloping Highly-Responsive User Interfaces with DHTML and Servlets,\u201d 19th IEEE International Performance, Computing, and Communications Conference\u2014IPCCC-2000. In the dual-MVC architecture, the Model and the Controller portions of the application can execute (serially) on both the client and the server, thus offering the maximum deployment flexibility. We now explain how, in a preferred embodiment of the present invention, the canonical form is deployed to a dual-MVC technology.","In order for the FWAPlication  to execute on the client, a suitable client platform that can both render a View, execute Controllers, and access the Model must exist. One example of such a platform is a web browser enabled with Sun Microsystem\u2122 Java Plug-in technology. Another example is a PDA with an embedded Java Virtual Machine. With such a platform available, deployment of the FWAPlication to the dual-MVC architecture must address two basic situations: one, in which a Controller executes only on the client; and a second, in which Controller execution may optionally begin on the client but complete on the server. Note that the issue of how the application deployer specifies whether a Controller should execute on the client or on the server is handled independently of the FWAPlication itself, e.g., through a file that maps the name of a Controller to a \u201cclient versus server\u201d directive.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 6","b":["35","60","30","70","400","420","20","70","60","420"]},"The client-side Model cache  is necessary for the Controllers to execute efficiently (i.e., without constantly communicating with the server) on the client. As shown in , Controllers typically access the Model in the course of their execution. If the Model elements are available in the client cache (i.e., a cache hit), the Controller executes entirely on the client. If required Model elements are not available on the client (i.e., a cache miss), the client-side FWAPlication must ask the server-side for those Model elements.","One of the tasks performed by a client-side FWAPlication Manager  is the rendering of the client-side View components . In the case of a preferred embodiment, this is done by maintaining a display panel inside an applet that is instantiated in the client browser. As the View changes, the display panel containing the previous View is replaced with another panel that contains the new View.","Various approaches are possible for processing the events that a FWAPlication developer associates (on a per-View-component basis) with a Controller. The developer creates this association via the registerController API of . In a preferred embodiment, the responsibility for event processing is assumed by the client-side FWAPlication Manager  in cooperation with the deployed client-side View components . This is accomplished by having the View component trap the event and then forward the name and arguments of the associated Controller to the FWAPlication manager. The FWAPlication Manager then determines whether the Controller should execute on the client or server, perhaps using a configuration file that specifies this information.",{"@attributes":{"id":"p-0062","num":"0061"},"figref":["FIG. 6","FIG. 6","FIG. 1","FIG. 4"],"b":["410","60","10","500","510","35","520","420","530","420"]},"Assuming that no Model cache miss occurs, in step , the new View  is constructed using the client-side implementation of the View library . Finally, the new View is passed to the FWAPlication Manager in step , and rendered on the client platform in step . This generic execution cycle then repeats through the course of the user interacting with the deployed FWAPlication. If a cache miss does occur, the scenario changes to that of dual-MVC, server-side, Controller execution discussed below.",{"@attributes":{"id":"p-0064","num":"0063"},"figref":["FIG. 7","FIG. 7","FIG. 1"],"b":["70","10","700","410","720","85","30","35","420","725","85","725","35","420","92","20"]},"Once the server-side FWAPlication  is synchronized with the current state of the application, it executes in step  the ProcessSearchRequest associated with the user's interaction with the \u201cSearch\u201d button. This involves the sub-steps of: accessing the server-side View components  in step ; accessing a Model cache  in step ; and, if necessary, accessing the persistent Model  itself in step . As a result of the server-side Controller execution, a new View containing the employee information is constructed on the server as a set of server-side View components . In step , the controller servlet  returns the new View as the result of the client's POST operation to the client-side FWAPlication Manager  which \u201creconstitutes,\u201d in steps  and , the server-side View as a client-side View whose components wrap a concrete View technology, such as Sun Microsystem\u2122 Swing library. In addition, in step , if the server-side Model has changed the state of elements in its persistent Model, these changes must be propagated to the client-side FWAPlication Manager  so that it can update the corresponding Model elements in its Model cache . Optionally, the server-side FWAPlication may have pre-fetched Model elements on behalf of the client-side FWAPlication and \u201cpiggybacked\u201d these elements in the response to the client's request for Controller execution. In step , the new View  is passed to the FWAPlication Manager, and rendered on the client platform  in step . This generic execution cycle then repeats through the course of the user interacting with the deployed FWAPlication.","Referring now to , a block diagram is shown illustrating a hardware implementation of a client computer system and\/or server computer system suitable for implementing the MVC applications methodologies of the present invention. As shown, both the client system and server system may be implemented in accordance with a processor , a memory  and I\/O devices . It is to be appreciated that the term \u201cprocessor\u201d as used herein is intended to include any processing device, such as, for example, one that includes a CPU (central processing unit) and\/or other processing circuitry. The term \u201cmemory\u201d as used herein is intended to include memory associated with a processor or CPU, such as, for example, RAM, ROM, a fixed memory device (e.g., hard drive), a removable memory device (e.g., diskette), flash memory, etc. In addition, the term \u201cinput\/output devices\u201d or \u201cI\/O devices\u201d as used herein is intended to include, for example, one or more input devices, e.g., keyboard, for entering data to the processing unit, and\/or one or more output devices, e.g., CRT display and\/or printer, for presenting results associated with the processing unit. It is also to be understood that the term \u201cprocessor\u201d may refer to more than one processing device and that various elements associated with a processing device may be shared by other processing devices. Accordingly, software components including instructions or code for performing the methodologies of the invention, as described herein, may be stored in one or more of the associated memory devices (e.g., ROM, fixed or removable memory) and, when ready to be utilized, loaded in part or in whole (e.g., into RAM) and executed by a CPU. For example, the functional elements of the client-side computing device  and the server computer system  shown in ,  and  may be respectively implemented in accordance with a hardware architecture as depicted in .","Although illustrative embodiments of the present invention have been described herein with reference to the accompanying drawings, it is to be understood that the invention is not limited to those precise embodiments, and that various other changes and modifications may be affected therein by one skilled in the art without departing from the scope or spirit of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
