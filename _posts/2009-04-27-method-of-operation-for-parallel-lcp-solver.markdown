---
title: Method of operation for parallel LCP solver
abstract: A method of operating a Linear Complementarity Problem (LCP) solver is disclosed, where the LCP solver is characterized by multiple execution units operating in parallel to implement a competent computational method adapted to resolve physics-based LCPs in real-time.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07937359&OS=07937359&RS=07937359
owner: NVIDIA Corporation
number: 07937359
owner_city: Santa Clara
owner_country: US
publication_date: 20090427
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","Field of the Invention","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT(S)"],"p":["This application is a continuation of U.S. patent application Ser. No. 10\/793,856, filed Mar. 8, 2004, which claims benefit of U.S. provisional patent application Ser. No. 60\/537,913, filed Jan. 22, 2004. Each of the aforementioned related patent applications is herein incorporated by reference.","The present invention relates to a method and apparatus for realistically animating the motion and interaction of objects in a display system. More particularly, the present invention relates to a circuit or subsystem having a parallel computational architecture and a method for using same within a system. The parallel hardware architecture allows real-time resolution of complex physics-based data problems, such as Linear Complementarity Problems (LCPs). Such problems arise, for example, during operation of a rigid body dynamics engine within a system having a visual display. The present invention finds application within systems such as a conventional Personal Computers (PCs) and game consoles, as well as recently proposed systems incorporating a hardware-based, physics processing unit.","Physics-based \u201canimations\u201d and \u201csimulations\u201d (hereafter these terms are used interchangeably regardless of application, specific method of display, or means of communicating related physics-based data) have been extensively investigated during the past three decades. Such animations are useful in a range of applications including virtual reality, electronic\/computer games, scientific simulations, and robotic motion planning. Game developers, for example, increasingly use real-time, physics-based animations to enhance the realism of game object interactivity. Integral to the development of real-time, physics-based animations is the dynamic simulation of rigid body movements and interactions.","The term \u201crigid body\u201d is used to describe animated objects that do not deform. They are said to be stiff even when colliding with other objects or with the environment defined by the animation. A rigid body simulation involves a complex sequence of computational steps causing animated bodies and related forces to interact in a realistic manner according to a set of defined physical rules, or so-called \u201cconstraints.\u201d One goal of a rigid body simulator is to minimize or prevent the penetration of objects. If a simulator were to allow large penetrations of objects, then the illusion of object rigidity would be lost.","The practical development of physics-based animations, including rigid body simulations, has proved quite difficult. For simple cases, continuous real life problems can be written using continuous mathematics and solved algebraically. This approach is to high school physics students. However, the set of cases which have algebraic solutions is very small and a rigid body simulator must be able to handle any configuration of contacting rigid bodies. For this reason, a discrete problem is chosen that approximates the continuous problem. A discrete problem can be represented with a finite amount of data and can be evaluated numerically (by a computer) at discrete time intervals. Given that frames of animation are only required at discrete time intervals, this is an acceptable limitation.","Selecting a discrete model that approximates a sufficiently large class of continuous problems and is solvable in real time by a computer is difficult. A poor choice of discrete model can result in behavior that diverges unacceptably from the original continuous problem. For example with a bad model, objects might jump around for no reason, penetrate unacceptably, fall through a floor, or fly off into infinity.","At least in the context of computer games, the accuracy of discrete approximations with respect to the continuous problem is not particularly important, within certain limits. This result arises because unlike simulations used in science and engineering, computer game animations need not be predictive. Any plausible discrete model will do. However, although this relaxed requirement makes it easier to meet the real-time constraint, it unfortunately doesn't make the mathematics any easier.","Numerous issues must be addressed when building a system adapted to run real-time, physics-based animations. For example, the geometry of objects plays an important role in determining the physics of motion, as well as the physics of contact between objects. An object may be a single rigid body such as a chair or house, or may consist of a number of connected (e.g., jointed) bodies, such as a human figure. Collision or contact between objects must be accurately determined. Solving the necessary equations of motion to realistically animate objects has proved to be a difficult problem since accuracy (i.e., realism) and computational speed are always at odds.","In addition to preventing object\/object or object\/environment penetration, a system visually displaying the dynamic movement and interaction of rigid bodies must take into account various physical properties of the objects. Mass is one example of a physical property. Physics-based animations must also faithfully track and account for forces upon the animated objects. Gravity is one example of a force. A rigid body simulator, or \u201cengine,\u201d associated with the display system must also create the illusion that simulated objects have certain surface properties, such as friction.","As one might expect, the modeling and simulation of the complexities arising from varied object geometries, interacting objects and forces, and changing object constraints requires a great deal of sophisticated mathematics. However, the mathematics implicated in the present invention are conventional in their general nature. That is, those of ordinary skill in the art will understand the mathematical bases upon which the present invention is predicated. It is neither appropriate nor required that this present description teach the entire body of implicated mathematics. Nevertheless, some discussion of mathematical model(s) is required in order to establish a common descriptive vocabulary.","The conventional resources typically available in a display system implementing physics-based animations are conceptually illustrated in . Those of ordinary skill in the art will recognize that the hardware\/software designations in this example are relatively arbitrary. For example, computational logic may be fully implemented in software, hardwired, or some combination of software and hardware according to a system designer's discretion. However, some logical distinction between hardware and software as exemplified by current best practices is useful in the description that follows.","In , a Central Processing Unit (CPU) , such as a Pentium\u00ae microprocessor, together with its associated drivers and internal memory, access data from an associated external main memory , and\/or one or more peripheral devices , typically including a display. The terms \u201cinternal\u201d and \u201cexternal\u201d are used to generally differentiate between various memories in relation to the other computational components in a system. Such differentiation is clearly relative, since most internal memory can be turned into external memory and vice verses. Generally speaking, however, an internal memory is typically co-located on the same integrated circuit (IC) chip as related computational component(s), while external memory is typically implemented on a separate chip or chip set.","A main application  is resident in main memory  and\/or peripheral  (e.g., a magnetic or optical disk, a solid-state memory device such as a PROM, EPROM, or EEPROM, a cartridge for a game console or similar device). Main program  typically uses one or more Application Programming Interfaces (APIs) to access blocks of specialty software associated with various program functions. An API is a well understood programming technique used to establish a lexicon of sorts by which one piece of software may \u201ccall\u201d another piece of software. The term \u201ccall\u201d as variously used hereafter broadly describes any interaction by which one piece of software causes the retrieval, storage, indexing, update, execution, etc., of another piece of software.","Data instructions, often in a prescribed packet form and referred to hereafter as \u201ccommands,\u201d are generally used to initiate calls between one or more software or hardware components. Execution (i.e., \u201crunning\u201d) of software, in any of its various forms including micro-code, occurs upon receipt of an appropriate command.","Conventional systems implementing physic-based animations routinely include or incorporate by functional \u201ccall\u201d a related piece(s) of specialty software referred to generically hereafter as a \u201cphysics engine.\u201d A physics engine may be thought of as an operative collection of resources, including specialized software, implementing physics effects within a main application.","With the recent and growing appetite for realism, physics engines have been added to the program code implementing, for example, PC games. Indeed, a market has emerged directed to the development physics engines or so-called \u201cphysics middleware.\u201d Companies like HAVOK, MathEngine, Criterion, and Meqon Research have developed specialty software that may be called by a main application to better incorporate natural looking, physics-based interactions into a main application.","Prior to the use of physics engines in games, objects were animated by hand. These animations were triggered in response to input from the user. For example, if the user pressed a punch key, the game would play a corresponding punch animation. If the user pressed the punch key while standing next to a pile of boxes, then an animation of the pile of boxes falling over might have been played. If the user pressed the punch key while standing next to a game character, an animation of that character falling to the floor might have been played.","Since the animated motion displayed by the game was specified by a set of pre-drawn animations, the punch, the falling boxes, and the falling character would each move in the same manner every time. As well as being quite boring for the user, the animation could not take into account the context of the action. For example, if the user pressed the punch key next to a wall, there would often be nothing to stop the player's arm going through the wall. If the user had previously parked a car behind the pile of boxes, the boxes would typically fall through the car. If the user punched a character next to a cliff, the punched character would typically fall flat and lie in midair over the cliff rather than falling over the cliff ledge.","These problems were overcome conventionally by limiting the user's actions, for example by not giving the user a car to drive, not allowing the user to walk within arm's length of a wall and not allowing fights next to cliffs. These restrictions were often frustrating to the user. Another way around the problem was to simply generate outcome animations for every possible combination of user actions. However, as the number of possible user actions grows, the number of outcome animations outcomes also grows. Thus, as game complexity increases the cost associated with the development of multiple animations becomes prohibitive.","Games designed using only pre-drawn animations start with a completely restricted environment where nothing unscripted can happen. This completely restricted environment is gradually made more interactive as an animator produces more and more animations. In contrast, games designed using physics-based approaches start from the opposite point of view, namely objects initially have complete freedom of motion. The game designer then, for example, designs a solid environment and adds a constraint that objects can still move with complete freedom, except that they must not fall through the solid environment. In a physics-based game, there is no reason why the user can't be given a car, or be allowed to punch a person next to a cliff, so those constraints are never introduced. As the game design progresses, some additional constraints are added, however, as most fun games have some set of defining rules.","Rather than supplying a set of animations for each object, the game designer specifies a set of physical properties for the object such as mass, friction, and in some cases even elasticity. The physics engine then uses the laws of physics to move the objects as if they had these properties, so long as the movement don't violate a specified constraint. A game designer incorporates physics-based effects by deciding what forces and torques to apply to object(s) in response to user input.","Of necessity, physics engines include a rigid body dynamics engine adapted to calculate the movement of rigid bodies within an animation. As will be appreciated by those of ordinary skill in the art, a rigid body dynamics engine will typically form one aspect of a larger physics engine. The exact programming and\/or resource boundaries between the rigid body dynamics engine and other effects engines within the physics engine are a matter of design choice, and it is expected that the rigid body dynamics engine will draw upon a library of functions and\/or a pool of common resources provided by the physics engine and\/or by the main application.","Unfortunately, contemporary physics engines have significant limitations as to the number of objects in an animated scene, and more particularly, the number of active (i.e., moving or interacting) objects. Realistic visual images of physics-based interaction must account for constraints placed upon many or all of the objects. As noted above, a constraint is a restriction on the possible movement or interaction of an object (e.g., a door hinge, a knee joint, a dog on a leash). Increasing complexity of terrain geometry greatly increases the difficulty of simulating object interactions with the terrain. The complexity of collision detection and resolution also increases with the complexity of an object's surface geometry (i.e., its surface detail).","Along with an increasing number of active objects, cutting edge animations and simulations demand an increased number of forces being applied to the objects. These aggregate demands are further aggravated by the increasing number of \u201ctime steps\u201d per second being used in animations (i.e., the frequency with which the animated world with all its objects and forces is updated in real time).","However, among the factors challenging the realistic, real-time animation of objects in a physics-based application, the definition and incorporation of constraints upon the animated rigid body objects has proved most difficult. Indeed, it the existence of numerous constraints that makes the underlying mathematical (numerical analysis) problem much more difficult to resolve, as compared with a simple application of Newton's laws of motion. In mathematical terms, it is constraints upon the movement of objects within a physics-base problem that gives rise to many of the difficulties associated with solving the LCPs expressing the physics-based problem.","Many attempts have been made to address the difficulty task of resolving complex bounded value problems, such as LCPs, in an accurate efficient manner. To date, however, these attempts have proved so slow that only relatively small physics-based problems have been successfully animated in real-time. Once the number of the objects, forces, and\/or constraints upon objects in a physics-based animation rises above a relatively small value, the mathematics underlying the animation simply can not be resolved in real-time using conventional computational methods and\/or conventional hardware platforms. The term \u201creal-time\u201d describes the quality of a visual display having a frame rate sufficiently fast to give a viewer the illusion of continuous, realistic-appearing movement.","As is also well understood by those of ordinary skill in the art, the mathematical resolution of LCPs in a digital computational environment, such as a PC, involve the execution of a numerous floating point operations. While general purpose processors, like the Pentium family of microprocessors, are capable of executing floating point operations, they are not able capable of executing the great number of floating operations typically required for the real-time animation of physics-based interactions.","Simply stated, the well-recognized and growing desire for real-time physics-based animations within next-generation applications remains unmet. This failure is really two-fold. First, conventional computational methods are too inefficient to solve complex LCPs in real-time. Second, conventional hardware platforms do not enable a the speed of data transfer and the number of mathematical operations required to animate complex physics-based interactions in real-time.","The present invention succeeds where all previous attempts have failed to accurately animate the physics-based interaction of objects in real-time. More particularly, the present invention provides a method of operation for a parallel LCP solver characterized by the presence of a plurality of execution units arranged in parallel. This architecture enables the rapid transfer of data and the numerous computational operations required to implement real-time, physics-based animations. The method of operation for the parallel hardware architecture described in the present invention is well suited to run projected iterative descent methods. Such computational methods are well adapted to resolve complex LCPs.","Thus, in one aspect the present invention provides a method of operating a LCP solver. The LCP solver comprising a plurality of Island Processing Engines (IPEs) arranged in parallel, each one of the IPEs further comprising a plurality of execution units arranged in parallel. The method comprises; defining a plurality island data sets from an initial data set defining a physics-based problem, wherein each one of the plurality of island data set defines at least one corresponding LCP, transferring each one of the plurality of island data sets to a corresponding one of the plurality of IPEs, and within each IPE, defining a plurality of data portions from the island data set, transferring each one of the plurality of data portions to a corresponding one of the plurality of execution units, and resolving the plurality of data portions in parallel.","In a related aspect, each data portion is analyzed to determine its nature, and a computational method is selected from a group of defined computational methods in accordance with the nature of the data portion. The selected computational method is used to resolve the data portion.","In another aspect, the present invention provides a method of operating a LCP solver in a system. The system comprising a CPU executing a main application, and a main memory storing an initial data set related to a physics-based problem arising from execution of the main application. The method comprises; generating at least one island data set corresponding to a rigid body island characterized in the initial data set, storing the island data set in a memory associated with the LCP solver, and executing a projected iterative descent method to resolve a LCP defined by the island data using a plurality of execution units arranged in parallel.","In one embodiment, the step of executing a projected iterative descent method is preferably implemented in a plurality of IPEs, wherein each IPE comprises a plurality of execution units and stores a corresponding island data set. This method step is further characterized by; defining a plurality of data portions from the island data set, transferring each one of the plurality of data portions to a corresponding one of the plurality of execution units, and resolving each one of the plurality of data portions in the corresponding one of the plurality of execution units.","In yet another aspect, the present invention provides a method of resolving LCPs in a system comprising a Central Processing Unit (CPU) executing a main application, a main memory associated with the CPU storing an initial data set related to a physics-based problem arising from execution of the main application, and a Physics Processing Unit (PPU) comprising an LCP solver. The method comprises the steps of defining a plurality island data sets, each island data set corresponding to a rigid body island defined in the initial data set; transferring the plurality of island data sets to the PPU, and within the LCP solver, selecting a computational method from a defined group of computational methods; and applying the selected computational method to resolve at least one LCP derived from the plurality of island data sets.","In one preferred embodiment, the PPU further comprises a PPU memory, a PPU Control Engine (PCE) controlling overall operation of the PPU, and a Data Movement Engine (DME) controlling the step of transferring the plurality of island data sets from the main memory to the PPU memory.","In still another aspect, the present invention provides a method of operating a LCP solver executing a projected iterative descent method adapted to resolve an LCP. The method comprising the steps of; storing in memory a data set related to a physics-based problem, wherein the data set comprises LCP data defining a whole gradient vector, and operating a plurality of execution units in parallel, such that each one of the plurality of execution units receives and resolves one of a plurality of subspaces, each subspace corresponding to a portion of the whole gradient vector.","In one embodiment, this method is further characterized transferring each one of the plurality of subspaces after their definition to a corresponding one of the plurality of execution units, and resolving each subspace within its corresponding one of the plurality of execution units, such that the whole gradient vector is resolved by parallel resolution of the plurality of subspaces.","In still another aspect, the present invention provides a method of resolving a LCP related to a physics-based, initial data set, comprising the steps of storing an island data set derived from the initial data set in memory, wherein the island data set comprises a plurality of constraint rows, sequentially distributing each one of the plurality of constraint rows to a corresponding execution unit selected from a plurality of execution units, and operating the plurality of execution units in parallel in order to solve the distributed constraint rows.","As presently preferred in one embodiment, these steps are iteratively repeated until all constraint rows are solved or skipped. Thereafter, data resulting from resolution of the distributed constraint rows is integrated.","Within this embodiment, the step of sequentially distributing each one of the plurality of constraint rows further comprises, for each constraint row; identifying objects associated with the constraint row, creating or updating an entry in an indexed memory for each identified object, and distributing the constraint row, such that all constraint rows related to a common object are distributed to the same corresponding execution unit.","In still another aspect, the present invention provides a method of resolving LCPs related to a physics-based, initial data set characterizing a plurality of objects and a plurality of constraints restricting movement of at least one object in the plurality of objects. The method comprises; storing an island data set derived from the initial data set in memory, wherein the island data set defines a whole gradient vector, defining a plurality of subspaces, wherein each one of the plurality of subspaces corresponds to a portion of the whole gradient vector, assigning each one of the plurality of subspaces to a corresponding execution unit, and resolving the plurality of subspaces in parallel.","In a first embodiment, the present invention is described in the context of a hardware architecture designed to efficiently run a computational method adapted to resolve LCPs using a plurality of parallel execution units. The term \u201crun\u201d (or \u201crunning\u201d) refers to any hardware\/software interaction, whereby one or more logic steps identified by the software are executed using the hardware. Any operative combination of hardware elements, comprising at least the plurality of parallel execution units, that enables execution of a competent computational method resolving LCPs will hereafter be referred to as a \u201cparallel LCP solver.\u201d","The parallel LCP solver of the present invention may take many physical forms, including, as examples, a stand-alone circuit, a circuit integrated with a general processor, a single integrated circuit (IC) chip, a set of IC chips, or a subsystem of a dedicated processor implemented on a PCI expansion board. Any one of a number of computational methods may be run on the parallel LCP solver proposed by the present invention. Indeed, certain conventional computational methods may be adapted to efficiently run on hardware designed in accordance with the present invention.","However, as presently preferred, the parallel LCP solver will run a computational method such as the one described in commonly assigned and concurrently filed U.S. patent application, \u201cMethod and Program Solving LCPs for Rigid Body Dynamics\u201d (application Ser. No. 10\/793,899). This application, the subject matter of which is hereby incorporated by reference, describes a novel computational method (hereafter, the \u201cimproved method\u201d) adapted to resolve complex LCPs without the disabilities associated with conventional computational methods. The improved method is described in the referenced application in the context of a projected iterative descent, namely a projected Gauss-Seidel method. A brief background discussion of this improved method will further illuminate the written description of the present invention that follows, and facilitate an understanding of the first embodiment.","The improved method is characterized in one aspect by the definition and use of data forms providing efficient resolution of LCPs derived from physics-based problems. Such physics-based problems necessarily arise when a display system such as a Personal Computer (PC) seeks to incorporate realistic physical qualities into a displayed animation or simulation. LCPs are a common way of mathematically expressing these physics-based problems, but there a variations in the type and quality of data forms used within the LCPS. Properly selected data forms are easier to store and transfer between the logic units executing operations associated with a computational method running on the parallel LCP solver.","In a related aspect, the improved method is also characterized by the use of simplified computational operations. Conventional computational methods often require large matrix\/vector multiplication operations. The improved method replaces such complex operations with more efficient ones, such as scaled vector additions. By reducing transactional overhead in the storage and transfer of data and by simplifying computational operations, the improved method is able to run in real-time while providing accurate resolution of LCPs.","The concept of \u201cparallelism\u201d is integral to the present invention. By running a competent computational method on a hardware platform having efficiently laid-out, parallel execution units, the present invention affords significant performance advantages over systems running the same computational method in a largely sequential manner, as is typical with conventional general processors.","While it is possible to modify existing general processors, such as the CPU shown in the exemplary system of , in accordance with the present invention, it is much more likely that the parallel architecture contemplated by the present invention will be provided through the use of a separate co-processor designed to work in conjunction with a general processor. Commonly assigned and pending U.S. patent application Ser. No. 10\/715,440 filed Nov. 19, 2003 describes a system incorporating a dedicated Physics Processing Unit (PPU). The subject matter of the application is hereby incorporated by reference.",{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 2","b":["10","1","2","3","9"]},"Exemplary interconnections to PPU  are shown in further detail in . Here, PPU  is connected to a dedicated external memory . Dedicated external memory  is preferred since the conventional memory  normally associated with CPU  is not configured to provide the data bandwidth and data throughput presently contemplated by the architecture of a system incorporating PPU . However, PPU  need not be universally configured with its own dedicated, external memory . It is very possible that PPU  might share an external memory with GPU  and\/or CPU .","Returning to , connections between PPU  and the other components in system , including CPU , comprise, for example, a USB2 connection , a IEEE 1394 (Firewire) connection , and\/or one or more of several PCI Interfaces , including as examples, PCI, PCI-X, and\/or PCI-Express. As presently contemplated, PPU  also includes an asynchronous serial interface  which allows debugging over an RS-232 link, additional general purpose I\/Os  provided for low level debugging and status reporting, and\/or an IEEE 1149.1 (JTAG) interface  provided for the debugging of software running on the PPU .","Physical incorporation of PPU  within system  may be accomplished using one of several approaches. First, PPU  may be incorporated using a standard PC Interface (PCI) card where system  is a PC, game console, or similar device having PCI expansion slots. Alternatively, a PCI-Express Interface card might be used. A USB2 or Firewire connection to an externally packaged PPU module might be used instead of an internally configured interface card. It is readily foreseeable that a PPU and a GPU will be combined on a single interface card. That is, both chips will be physically mounted on the same card (AGP or PCI-Express), but not directly interfaced with one another. Ultimately, a single interface card having a directly interfaced PPU-GPU combination is expected, but such a combination is probably a generation away. So too is a combination within a single chip of PPU and CPU functionalities.","Parallel execution of the presently preferred computational method poses some significant implementation challenges. The improved method is iterative in nature, i.e., sequentially computing on a working constraint row by working constraint row basis, where each working constraint row computation is predicated upon previously computed constraint row values. In other words, the projected, iterative descent method presently preferred requires the use of previously computed results as soon as they are available. Consider the following example, where an LCP is defined in terms of a system matrix A:\n\n","Different choices of the matrix splitting (B,C), where system matrix A=B+C, determine the particular computational method best suited to solve LCP(b,A). For example, a projected, iterative Gauss-Seidel method is preferred where splitting B is selected such that B=L+D, and where L and D are, respectively, the strictly lower triangular and diagonal parts of system matrix A, and the components of the iterate vector f, i.e., the candidate solution for a given iteration i, are given recursively by,",{"@attributes":{"id":"p-0065","num":"0067"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"msubsup":{"mi":["f","i"],"mrow":{"mi":"X","mo":"+","mn":"1"}},"mo":"=","mrow":{"mi":"max","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mn":"0","mo":",","mrow":{"msubsup":{"mi":["f","i","X"]},"mo":"-","mrow":{"msubsup":{"mi":["a","ii"],"mrow":{"mo":"-","mn":"1"}},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"b","mo":["+","+"],"mrow":[{"munder":{"mo":"\u2211","mrow":{"mi":["j","i"],"mo":"<"}},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msub":{"mi":["a","ij"]},"mo":"\u2062","msubsup":{"mi":["f","j"],"mrow":{"mi":"X","mo":"+","mn":"1"}}}},{"munderover":{"mo":"\u2211","mrow":{"mi":["j","i"],"mo":["\u2062","\u2062"],"munder":{"mo":">","mi":"_"}},"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msub":{"mi":["a","ij"]},"mo":"\u2062","msubsup":{"mi":["f","j","X"]}}}]}}}}}}}},{"mi":"i","mo":"=","mn":"1"},{"mi":"m","mo":"."}],"mo":[",",",","\u2062",","],"mi":"\u2026","mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}},{"mrow":{"mo":["(",")"],"mn":"1"}}]}}}}},"In order to compute fin equation (1) for a working constraint row i, all previously computed results f, where j<i will be used immediately instead of using f, as computed for all constraint rows j<i from the loop associated with time step increment x. This computational necessity would seem to prohibit the use of a hardware platform characterized by parallel execution units. However, a more careful observation of the improved method reveals that fdoes not depend on fas computed for all constraint rows j<i where a properly selected \u201ccoupling invariant\u201d is used to define an \u201cauxiliary variable\u201d v. Therefore, as long as f, for j<i, isn't coupled with fthrough the coupling invariant defining the auxiliary variable v, then fcan be calculated independent from fas computed for all constraint rows j<i. This computationally independent relationship allows for parallel execution.","This relationship may be expressed in mathematically terms as:\n\n{v,v}\u2229{v,v}\u2261\u03a6\u2003\u2003(2).\n","Stated more literally, there is no intersection between a set of auxiliary variables, {v, v}, defined in accordance with a selected coupling invariant for a working constraint row i and a corresponding set of auxiliary variables, {v, v}, for a previously considered constraint row j. That is, no common or shared elements exist for {v, v} and {v, v}. If equation (2) is expressed alternatively as {I(i,1), I(i,2)}\u2229{I(j,1), I(j,2)}\u2261\u03a6, a more intuitive physical meaning may be discerned, namely constraint row i and constraint row j are related to different object pairs.","Two important observations arise in relation to the parallel execution of a projected iterative descent method in accordance with this exemplary embodiment of the present invention. First, for any two constraint rows i\u2260j, fand fare calculated independently, as long as {I(i,1), I(i,2)}\u2229{(I(j,1), I(j,2)}\u2261\u03a6. Second, to maintain convergence of the projected iterative descent method, the most current values for {v, v} should be used to calculate f.","Of note here, the sequence of constraints influencing an island (i.e., a grouping) of objects (e.g., rigid bodies) is typically generated in a random manner by conventional collision detection routines. Collision detection is a common precursor step to the resolution of rigid body dynamics. Thus, a random order appearance (and subsequent random resolution) of constraints defining the LCP should not have a negative influence on convergence.","The term \u201crigid body island\u201d is used hereafter to refer to any set of rigid bodies directly or indirectly connected one to another by one or more constraints. The resulting collection of object-related data and constraint-related data is referred to as an \u201cisland data set.\u201d The dynamics of an individual rigid body island may be resolved using a separate LCP. In other words, an island data set defines a whole gradient vector expressed by the LCP. As will be seen hereafter, the island data set (whole gradient vector) will divided into multiple subspaces for resolution by the parallel hardware architecture of the present invention.","Recognizing the foregoing attributes of the preferred improved method, the problem of efficiently mapping or allocating the computational requirements of the method onto a hardware platform having parallel execution units remains.  is a functional block diagram illustrating an exemplary data transfer and logic control relationship between components within the PPU of . Overall control of PPU  may be directed from CPU . However, a primary reason PPU  is provided within system  is to reduce the computational burden placed on CPU . Accordingly, as presently preferred, PPU  will include a PPU Control Engine (PCE)  adapted to control most, if not all, PPU operations. Central to the efficient operation of PPU  is Data Movement Engine (DME) . In the exemplary embodiment, DME  is connected to system  and external memory . PPU  further comprises a plurality of Island Processing Engines (IPE). Each IPE is preferably a vector processor, but may take many other forms in accordance with particular design considerations. In the present example, only four IPEs , , , and  are illustrated for the sake of clarity. However, it is presently contemplated that more than four IPEs may be used within PPU .","Main application  (see, ) running on system  will generate an initial physics-based data set. This \u201cinitial data set\u201d will vary in size and composition according to the exact nature of the physics-based animation to be displayed. However, the initial data set will typically be derived from a body mass array defining the mass and\/or moment of inertia for objects in the animation, and a constraint data array defining constraints acting upon the respective objects.","Following definition of an initial data set, the CPU and\/or PPU calculates one or more LCP-related data components using conventional techniques. LCP-related data components include, as examples and without limitation, Jacobian(s) related to the initial data; initial forces, if any, acting on the objects; system matrix A, matrix splittings, diagonals, etc. Of note, the preferred improved method does not require explicit calculation and storage of system matrix A. This may not be true for other selected computational methods.","Where such calculations are performed by the CPU, the initial data set is augmented with the calculation results. Once finalized, the initial data set is transferred to the PPU via a competent physical connection by means of a conventional data transfer protocol. Transfer of the initial data set from one or more components in system  to PPU  may take place as a single block transmission, or as a sequence of related data block transmissions.","After receiving the initial data set, PCE  defines one or more island data sets from the initial data set, and thereafter distributes a island data set to each respective IPE. As presently preferred, this is the first moment at which LCP-related data components like the Jacobian are required to construct a LCP from each respective island set. Accordingly, many, if not all, of the LCP-related data components will be calculated in an IPE.","Alternatively, like calculation of one or more of the LCP-related data components, the definition of one or more island data sets may be performed by CPU .","The IPE in  is illustrated in some additional detail in . Here, IPE  comprises a conventionally constructed Island Control Unit (ICU)  communicating at least data transfer commands to\/from DME , and generally directing the transfer of data between an IPE memory  and a plurality of execution units. ICU  also directs the transfer of between external memory  and IPE memory . IPE  further comprises in this particular teaching example a Content Addressable Memory (CAM) , and a plurality of Vector Processing Units (VPUs), each having an associated VPU memory. As presently preferred, each VPU is formed from a combination of conventional elements including at least one circuit executing floating point operations.","Vector-type processors are presently preferred for the execution of mathematical operations, such as floating point operations, within an IPE. However, the parallel-arranged and computationally-related circuits within each IPE need not be vector type processors, and are generically referred to hereafter as a \u201cplurality of execution units.\u201d In general, each execution unit in the plurality of execution units will receive some portion of data from the island data set and resolve said \u201cdata portion\u201d in parallel with the other execution units.","In the example shown in , a single execution unit, VPU  and its associated VPU memory , are numerically identified. The choice of four VPUs in the current example is merely illustrative. As presently preferred, the plurality of execution units provided by the plurality of IPEs will perform a great majority of the mathematical computations inherent in the resolution of physics-based animations. Accordingly, PCE , and the associated plurality of ICUs do not need to provide a great deal of computational power.","Use of CAM  illustrates one presently preferred scheme by which successful parallel execution of a LCP computational method is accomplished. In this regard, CAM  is a conventional circuit that functions as a type of specialized memory. ICU  logically controls and arbitrates the distribution of constraint rows from IPE memory  to a selected one of the plurality of executions units in accordance with data stored in CAM . That is, an island data set is transferred to IPE memory  from external memory  or directly from system . The island data set comprises a large collection of constraint rows defining the rigid body island. By careful utilization of CAM , data corresponding to a selected group of constraint rows is transferred from IPE memory  to a selected execution unit memory, e.g., VPU memory . Thereafter, the grouping or \u201csubspace\u201d of constraint rows is resolved in the corresponding execution unit.","Appropriate constraint row distribution by ICU  in conjunction with CAM  ensures that for any two constraint rows i\u2260j, fand fare calculated simultaneously if they satisfy the relationship {I(i,1), I(i,2)}\u2229{I(j,1), I(j,2)}\u2261\u03a6, subject to certain exceptions explained hereafter. For ease of reference, this relationship will be referred to hereafter as \u201cthe first parallelization condition.\u201d Additionally, \u201ca second parallelization condition\u201d is also imposed, namely the most current values for {v, v} are used to calculate each f.","The inter-operation of ICU , CAM  and respective execution units is further illustrated in relation to the exemplary computational method illustrated in Pseudo-code example 1 below.",{"@attributes":{"id":"p-0084","num":"0086"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003","\u2003Pseudo-Code Example 1"]},{"entry":[{},"Initialize: f, v, x = 0, 0, 0 and new_v_tag = 1"]},{"entry":[{},"while (1)"]},{"entry":[{},"i = 0"]},{"entry":[{},"max_u = 0"]},{"entry":[{},"cur_v_tag = new_v_tag\u2003\u2003\/\/ Remember tags from last "]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003(i.e. previous) time step"]},{"entry":[{},"new_v_tag = 0\u2003\u2003\u2003\u2003\u2003\u2003\/\/ Clear tags for current time step"]},{"entry":[{},"\u2003do i \u2260 m"]},{"entry":[{},"\u2003\u2003if !(cur_v_tag[I(i,1)] \u2225 cur_v_tag[I(i,2)])\u2003\/\/ If both the "]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003two objects have"]},{"entry":[{},"\u2003\u2003continue to next i=i+1\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003small changes, "]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003skip this row"]},{"entry":[{},"\u2003\u2003end if"]},{"entry":[{},"\u2003u= b+ J\u2022 v+ J\u2022 v"]},{"entry":[{},"\u2003newf := med(lo, f\u2212 a * u,hi"]},{"entry":[{},"\u2003\u0394v = (newf \u2212 f)(J)"]},{"entry":[{},"\u2003\u2003if \u2225\u0394v\u2225 > Thres\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/ Check if object I(i,1)'s "]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003v has big change?"]},{"entry":[{},"\u2003\u2003new_v_tag[I(i,1)] = 1"]},{"entry":[{},"\u2003\u2003end if"]},{"entry":[{},"\u2003v:= v + \u0394v"]},{"entry":[{},"\u2003\u0394v = (newf \u2212 f)(J)"]},{"entry":[{},"\u2003\u2003if \u2225\u0394v\u2225 > Thres\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/ Check if object I(i,2)'s "]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003v has big change?"]},{"entry":[{},"\u2003\u2003new_v_tag[I(i,2)] = 1"]},{"entry":[{},"\u2003\u2003end if"]},{"entry":[{},"\u2003v:= v + \u0394v"]},{"entry":[{},"\u2003f:= newf"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/ Check the LCP boxing "]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003conditions"]},{"entry":[{},"\u2003if(f=lo u< 0) (f= hiA u> 0)((f< hi)(f> lo)"]},{"entry":[{},"\u2003(|u| > Thres))"]},{"entry":[{},"\u2003\u2003if (|u| > max_u)\u2003\u2003\u2003\/\/ If boxing conditions not satisfied, "]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003check max |u|"]},{"entry":[{},"\u2003\u2003max_ u = |u|"]},{"entry":[{},"\u2003\u2003end if"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/ Despite not satisfying conditions, "]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003calculate the row in next time step"]},{"entry":[{},"\u2003new_v_tag[I(i,1)] = 1"]},{"entry":[{},"\u2003new_v_tag[I(i,2)] = 1"]},{"entry":[{},"\u2003end if"]},{"entry":[{},"\u2003end do"]},{"entry":[{},"\u2003if (max_u < Thres)\u2003\u2003\u2003\/\/ If max_u is less than threshold, "]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003method converges"]},{"entry":[{},"\u2003\u2003break \/* algorithm ends *\/"]},{"entry":[{},"\u2003endif"]},{"entry":[{},"end while"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"In the context of this exemplary computational method, an index of data entries controlled by CAM  is defined in accordance with an unique object identifier (ID) attached to each object in the initial data set. As shown in Table 1, an exemplary data entry in CAM  is presently defined by one byte of data in which bits  and  indicate an associated execution unit (VPU), bit  is the \u201ccur_v_tag\u201d value, bit  is the \u201cnew_v_tag\u201d value, and bits , , , and  are used to indicate the number of constraints (joints and\/or contacts) that yet require the use of an auxiliary variable v associated with the object. This auxiliary variable is denoted V. This approach provides an internal counter of sorts that tracks whether a particular auxiliary variable, now stored in an execution unit's memory, is still required by an execution unit for some ongoing computation, or whether the auxiliary variable is no longer needed and may be transferred back to IPE memory  for future use.","To more readily understand the inter-operation of the units comprising exemplary IPE  in the assignment of constraint rows between parallel execution units, the working example will be further simplified for purposes of explanation. Simplification is made in three ways. First, an IPE comprising only two parallel execution units is assumed, instead of the four shown in . Second, all constraints are assumed to have only one constraint row. Third, the row filtering function provided in the exemplary computational method above is disabled. That is, \u201ccur_v_tag\u201d is assumed to be \u201c1,\u201d and all constraint rows will be processed.","It should be noted at this point that use of CAM  (e.g., an indexed memory) to track auxiliary variables and the use of a row filtering technique are independent from one another. Row filtering improves performance by avoiding numerous computational operations that do not contribute significantly during a given iteration to convergence. Row filtering increases the efficiency of a computational method whether it is executed using a single general processor (CPU), or a parallel computational architecture. Where row filtering is used, however, entries to CAM  are made for only those rows that survive the row filtering process. Given these simplifying assumptions, operation of CAM  will be described with reference to Tables 1 and 2. Table 1 lists several exemplary constraint rows.","Table 2 is a truth table describing all possible processing actions for any given CAM access. Truth table outcomes begin when ICU  fetches a working constraint row i, and uses an index function I(i;:) to identify the two objects (1 and 2) associated with working constraint row i, using the respective object IDs. That is, the truth table is accessed using first (\u201cA\u201d) and second (\u201cB\u201d) indices, respectively defined as A=I(i,1) and B=I(i,2).",{"@attributes":{"id":"p-0089","num":"0091"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":[{},"The first object ID","The second object ID"]},{"entry":["Constraint row number","A = I(i,1)","B = I(i,2)"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","2","1"]},{"entry":["2","1","3"]},{"entry":["3","5","4"]},{"entry":["4","5","6"]},{"entry":["5","1","4"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0090","num":"0092"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"49pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["(VPU ID,",{},{},{},{}]},{"entry":["cur_v_tag)","xx1","xx0","aa1","aa0"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"98pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["xx1","Forward ","Forward row","Forward vto VPU aa; Create a"]},{"entry":[{},"row to ","to least busy","CAM entry for body B"]},{"entry":[{},"least","VPU; Create",{}]},{"entry":[{},"busy ","CAM entries",{}]},{"entry":[{},"VPU;","for A & B",{}]},{"entry":[{},"Create",{},{}]},{"entry":[{},"CAM ",{},{}]},{"entry":[{},"entries",{},{}]},{"entry":[{},"for A & B",{},{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"49pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["xx0","Forward ","Skip","Forward vto","Skip constraint"]},{"entry":[{},"row","constraint row","VPU aa; Create","row until next"]},{"entry":[{},"to least ","until next","CAM entry for","iteration"]},{"entry":[{},"busy","iteration","body B",{}]},{"entry":[{},"VPU; ",{},{},{}]},{"entry":[{},"Create",{},{},{}]},{"entry":[{},"CAM ",{},{},{}]},{"entry":[{},"entries",{},{},{}]},{"entry":[{},"for A & B",{},{},{}]},{"entry":["bb1","Forward ","Forward vto","Skip constraint","Skip constraint"]},{"entry":[{},"vto","VPU bb,","row until next","row until next"]},{"entry":[{},"VPU bb;","Create CAM","iteration; Try","iteration; Try"]},{"entry":[{},"Create ","entry for body","in the same","in the same"]},{"entry":[{},"CAM","B","iteration if","iteration if"]},{"entry":[{},"entry for ",{},"aa! = bb;","aa! = bb;"]},{"entry":[{},"body",{},"Otherwise,","Otherwise,"]},{"entry":[{},"B",{},"forward to VPU","forward to VPU"]},{"entry":[{},{},{},"aa, i.e. bb.","aa, i.e. bb."]},{"entry":["bb0",{},"Skip","Skip constraint","Skip constraint"]},{"entry":[{},{},"constraint row","row until next","row until next"]},{"entry":[{},{},"until next","iteration; Try","iteration"]},{"entry":[{},{},"iteration","in the same",{}]},{"entry":[{},{},{},"iteration if",{}]},{"entry":[{},{},{},"aa! = bb;",{}]},{"entry":[{},{},{},"Otherwise,",{}]},{"entry":[{},{},{},"forward to VPU",{}]},{"entry":[{},{},{},"aa, i.e. bb."]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"Before initial operation, CAM  is cleared, and all memory entries are made available for storing an object ID. Thereafter, IPE  processes a collection of constraint rows according to a predefined sequence. The following example teaches CAM operation within this process.","Step 1: Constraint row  is checked. ICU  twice performs a look-up operation in CAM  using respectively the two object IDs A=\u201c2\u201d and B=\u201c1\u201d. Obviously, no CAM entries exist at this point following CAM initialization. Thus, according to the description of (xx1, xx1) in Table 2, where \u201cxx\u201d means no CAM entry exists for an object, constraint row  is forwarded to VPU , since both VPU  and VPU  are both idle and under such circumstances the first identified execution unit, VPU , is nominally selected. Two CAM entries are thereafter allocated\u2014one per object.","A first CAM entry is made for the first object having an ID value of \u201c2.\u201d Assuming the preferred, 8-bit CAM entry data structure described above, the first CAM entry looks like this:",{"@attributes":{"id":"p-0094","num":"0096"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"CAM Entry 1"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"8"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"7pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"28pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["7","6","5","4","3","2","1","0"]},{"entry":{"@attributes":{"namest":"1","nameend":"8","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"7pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"140pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["VPU ID = 00","1",{},"Number of constraints using v= 1"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"A second CAM for the second object having an ID value of \u201c1\u201d looks like this:",{"@attributes":{"id":"p-0096","num":"0098"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"CAM Entry 2"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"8"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"7pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"28pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["7","6","5","4","3","2","1","0"]},{"entry":{"@attributes":{"namest":"1","nameend":"8","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"7pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"140pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["VPU ID = 00","1",{},"Number of constraints using v= 1"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"Since row filtering has been disabled in the current working example, a value of \u201c1\u201d is written for bit  in each CAM entry. At this time, the first execution unit, VPU , has data corresponding to constraint row  stored in its associated memory, and VPU  is still idle.","Step 2: Constraint row  is checked. Object IDs A=\u201c1\u201d and B=\u201c3\u201d are obtained. A look-up operation is performed in CAM  for A. Since an object having an ID value of \u201c1\u201d is already stored in CAM as entry 2, a value of \u201c00\u201d is returned from bits  and  in CAM entry 2 and a value of \u201c1\u201d is returned from bit  in CAM entry 2. Since the object having an ID of \u201c3\u201d has not yet used, a table index value of \u201cxx1\u201d is used. Accordingly, Table 2 is accessed by index values aa1=001, and xx1. In response, ICU  will forward data corresponding to constraint row  to the first execution unit VPU , and update CAM entry 2 for object \u201c1\u201d, since the first execution unit VPU , will now use a common auxiliary value vin the calculation of constraint rows  and . Corresponding CAM entries for Step 2 are shown below.",{"@attributes":{"id":"p-0099","num":"0101"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"CAM Entry 2"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"8"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"7pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"28pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["7","6","5","4","3","2 ","1","0"]},{"entry":{"@attributes":{"namest":"1","nameend":"8","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"7pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"140pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["VPU ID = 00",{},{},"Number of constraints using v= 2"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0100","num":"0102"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"CAM Entry 3"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"8"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"7pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"28pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["7","6","5","4","3","2","1","0"]},{"entry":{"@attributes":{"namest":"1","nameend":"8","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"7pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"140pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["VPU ID = 00",{},{},"Number of constraints using v= 1"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"With the completion of step 2, VPU  has constraint rows  and  stored in its associated memory. VPU  remains idle. Of note, constraint rows  and  do not satisfy the first parallelization condition, {I(i,1), I(i,2)}\u2229{I(j,1), I(j,2)}\u2261\u03a6, since they share a common object \u201c1\u201d. However, this fact does not contradict the previous conclusion or recommendation regarding conditions placed upon the distribution of constraint rows between a plurality of execution units.","The reasoning behind this apparent exception becomes clear upon further consideration of execution unit functionality. All the constraint rows in VPU memory are processed sequentially. Thus, the so called first parallelization condition noted above does not apply to constraint rows commonly distributed to a VPU. Rather, the first parallelization condition is more properly considered a distribution condition applied to constraint rows stored in different IPEs and\/or different VPUs within an IPE. Thus, constraint rows resolved in different execution units should always satisfy the first parallelization condition, {I(i,1), I(i,2)}\u2229{I(j,1), I(j,2)}\u2261\u03a6, since they are processed in parallel.","In contrast, it is presently preferred that all constraint rows related to a common object be resolved within a single execution unit, wherever possible. Sequential processing of constraint rows within each execution unit also ensures faithful adherence to the second parallelization condition. The strategy of forwarding, wherever practical, a particular constraint row to an execution unit processing other constraint rows associated with a common object(s) will also reduce the amount of data being transferred between the ICU and the respective execution unit. In one sense, when used accordance with the prescribed parallelization conditions, each respective VPU memory forms a cache for auxiliary variable(s).","Step 3: Constraint row  is checked. Object IDs of A=\u201c5\u201d and B=\u201c4\u201d are returned. When performing a look-up operation in the CAM, no CAM entries are found for these two objects. This result in a truth table condition of (xx1,xx1), and constraint row  is accordingly distributed to the least busy execution unit, VPU . By forwarding constraint rows to a \u201cleast busy\u201d execution unit, the data loads distributed to the respective execution units are relatively balanced. Two new CAM entries,  and , are created as a result of step 3.",{"@attributes":{"id":"p-0105","num":"0107"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"CAM Entry 4"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"8"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"7pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"28pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["7","6","5","4","3","2","1","0"]},{"entry":{"@attributes":{"namest":"1","nameend":"8","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"7pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"140pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["VPU ID = 01",{},{},"Number of constraints using v= 1"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0106","num":"0108"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"CAM Entry 5"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"8"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"7pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"28pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["7","6","5","4","3","2","1","0"]},{"entry":{"@attributes":{"namest":"1","nameend":"8","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"7pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"140pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["VPU ID = 01",{},{},"Number of constraints using v= 1"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"At this time, VPU  stores constraint rows  and  in its memory, and VPU  stores constraint row .","Step 4: Constraint row  is checked. Object IDs of A=\u201c5\u201d and B=\u201c6\u201d are returned. When performing a look-up operation in the CAM, the existing CAM entry for the object having an ID \u201c5\u201d is updated, and a new CAM entry is generated for the object having an ID of \u201c6\u201d, as shown below.",{"@attributes":{"id":"p-0109","num":"0111"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"CAM Entry 4"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"8"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"7pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"28pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["7","6","5","4","3","2","1","0"]},{"entry":{"@attributes":{"namest":"1","nameend":"8","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"7pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"140pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["VPU ID = 01",{},{},"Number of constraints using v= 2"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0110","num":"0112"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"CAM Entry 6"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"8"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"7pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"28pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["7","6","5","4","3","2","1","0"]},{"entry":{"@attributes":{"namest":"1","nameend":"8","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"7pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"140pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["VPU ID = 01",{},{},"Number of constraints using v= 1"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}},"br":{},"b":["4","01","01","00","1","2","01","3","4","00","01"]},"Step 5: Constraint row  is checked. Object IDs of A=\u201c1\u201d and B=\u201c4\u201d are returned. When performing a look-up operation in the CAM, CAM entries  and  are identified for objects having these respective IDs. According to the description of (aa1=\u201c001\u201d, bb1=\u201c111\u201d) in Table 2, and due to the fact that (aa=\u201c00\u201d)!=(bb=\u201c11\u201d), constraint row  is skipped temporarily.","Constraint row , the only \u201cskipped\u201d constraint row in the simple working example, is processed in a subsequent iteration after all the constraints rows successfully distributed to execution units have been processed. Once these distributed constraint rows are resolved, it is highly likely that constraint row  will be able to be processed without difficulty. Stated in other terms, objects \u201c1\u201d and \u201c4\u201d, which are already stored in different execution units by the time the constraint row distribution process reaches constraint row , form a competing object pair for constraint row . With resolution of stored constraint rows  through , the corresponding CAM entries will be released, and constraint row  will accordingly be susceptible to proper distribution.","As will be seen hereafter, the function of \u201creleasing\u201d objects, and more significantly their corresponding auxiliary variable v, from the CAM is implemented using the \u201cnumber of constraints using v\u201d. This mechanism is one example of a strategy for successfully enforcing the first and second parallelization conditions. Otherwise, in the foregoing example, VPU  and VPU  would both contain constraint rows associated with one or more common objects.","The process of \u201creleasing\u201d objects from the CAM warrants some additional discussion. As presently contemplated, the respective execution units will begin processing data as soon as constraint row(s) are distributed by inter-operation of the ICU and CAM. As soon as a constraint row is processed, the execution unit notifies the ICU to update the corresponding CAM entries.","Thus, returning to the example above, update of the corresponding CAM entries decreases the \u201cnumber of constraints using v\u201d and \u201cnumber of constraints using v\u201d by 1, respectively. When a \u201cnumber of constraints using v\u201d value for a particular CAM entry reaches zero, the corresponding auxiliary variable is not needed (i.e., bound up with) the resolving execution unit. Accordingly, data corresponding to the auxiliary variable may be transferred from the execution unit to the IPE memory for subsequent transfer to another execution unit, as needed.","Thus, a mechanism is provided to ensure proper parallel resolution of constraint rows, while also ensuring resolution of all necessary constraint rows. In the foregoing example, constraint row  is readily resolved following resolution of constraint rows  and .","Of note, the foregoing scheme for the dynamic distribution and release of constraint rows does not require a CAM entry be made for every object in an island data set. The use of a CAM thus reduces overall memory requirements. Inferior alternatives to CAM use include the use of a linear table to assign table entries for all the objects in an island data set.",{"@attributes":{"id":"p-0118","num":"0120"},"figref":"FIG. 6","b":["60","61"]},"Typically, each VPU will thereafter calculate a corresponding Jacobian for the object or constraint (). Under the control of the ICU and using CAM indexing described above, constraint rows and associated Jacobians are distributed across the plurality of VPUs (), and thereafter solved (). The resulting calculations are changes to the velocities (u) and forces (f) influencing the movement of the objects defined in the island data group. Clearly, other computational approaches may be taken, but the present invention preferably calculates force changes. Strictly speaking, the \u201cforce\u201d calculations in the preferred embodiment are not real constraint force(s)\/torque(s), but Lagrange multipliers. The real constraint force(s)\/torque(s) are determined by the multiplying the calculated change in force \u201cf\u201d by a corresponding Jacobian. Once the constraint force(s)\/torque(s) are obtained, an integration process (i.e. an ordinary differential equation (\u201cODE\u201d) calculation) is performed to update the positions, orientations, linear velocities, and angular velocities for objects in an island data set.","As presently preferred, both the constraint force\/torque calculation(s) and ODE integration process(es) are performed in parallel in the PPU. This is especially true for the constraint force\/torque calculation(s) which are used in the CAM-based constraint row distribution scheme described above.","That is, once the velocity and force vectors are calculated, CAM entries are updated (). Consistent with the foregoing description, the appropriate values for \u201cnumber of constraints using vare decreased, and if zero, the corresponding vwill be read back from the resolving VPU to the IPE memory and the CAM entry will be clearly. The process of distributing (), and solving () constraint rows to yield updated velocities and forces vectors () continues until all rows are processed (=Yes). Thereafter, convergence is tested. Where convergence is found, data is integrated in a conventional Ordinary Differential Equation (ODE) solver (), as described above. Thereafter, the time step (i.e., LCP solver iteration) in incremented (), and the animation\/simulation continues. Of note, a conventional collision detection step is typically performed before each island generation and distribution step ().","The present invention is further illustrated in the following alternate embodiment. It begins with the selection of a computational method competent to solve physics-based LCPs, namely a steepest descent method. This method is routinely used to solve linear equations. The steepest descent method essentially finds a vector x that satisfies the base equation A\u00b7x=b, for an n by n system matrix A. The base equation may be expressed as a function:",{"@attributes":{"id":"p-0123","num":"0125"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":"x","mrow":{"mi":"nx","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}}}},{"mrow":[{"mfrac":{"mn":["1","2"]},"mo":["\u2062","\u2062","\u2062"],"msubsup":{"mi":["x","T"],"mrow":{"mi":"nx","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}},"msub":[{"mi":["A","nxn"]},{"mi":"x","mrow":{"mi":"nx","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}}]},{"msubsup":{"mi":["b","T"],"mrow":{"mi":"nx","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}},"mo":"\u2062","mrow":{"msub":{"mi":"x","mrow":{"mi":"nx","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}},"mo":"."}}],"mo":"-"}],"mo":"="}}},"br":[{},{}],"in-line-formulae":[{},{}],"i":["f","x","A","\u00b7x","\u2212b="],"sub":["n\u00d71","n\u00d7n","n\u00d71"]},"Thus, if for a selected vector x (i.e., a self-variant x), f(x) reaches a minimum (or its first derivative equals zero), then the selected vector x is a solution to the base equation.","The steepest descent method begins by making an initial guess at the solution vector x, and thereafter iteratively modifying x until f(x) can not be further reduced. At each iteration, the method seeks to move x linearly in a direction that provides the greatest reduction in the value of f\u2032(x). The direction of steepest descent may be expressed as \u2212f\u2032(x)=b\u2212A\u00b7x. Accordingly, for each iteration, x is moved linearly in this direction to a new position expressed as x=x\u2212\u03b1f\u2032(x). This process is repeated until f\u2032(x) is sufficiently close to zero.","When adapted and applied to a boxed LCP, the steepest descent method is said to be \u201cprojected.\u201d That is, the method proceeds as above, except following each iteration, the x vector is projected onto constraints. This computational step can be illustrated mathematically by the equation x=mid(lo, x\u2212\u03b1f\u2032(x), hi), where the \u201cmid\u201d function selects the median element for each constraint row.","To this point, the selection of a computational method and its projection over a boxed LCP can rightly be deemed conventional in nature. However, such conventional approaches, like the exemplary steepest descent method illustrated above, operate over the whole gradient vector (i.e., the \u201cwhole space\u201d) defined by the physics-based data set during each computational iteration. Thus, these approaches offer little, if any, opportunity for parallel resolution of the numerous computations required to resolve the boxed LCP.","The whole space may be thought of as a collection of data matrices defined from the physics-based data set. As illustrated in , for only an exemplary group of associated matrices defining the whole space, a row-wise association of data elements forms constraint row . Constraint rows influencing a common object are termed \u201cneighbored constraint rows.\u201d","The present invention avoids the computational difficulties associated with descending over the whole space by dividing the whole space into selected subspaces. Once selected subspaces have been defined, a competent computational method is applied and descends along each one of the selected subspace. Subspaces are selected at the beginning of each general iteration of the computational method based on the relative change (i.e., steepness) of each subspace during the current iteration. \u201cGreatest relative change\u201d may be determined in many ways, such as by locating the constraint row in the whole space having the highest velocity value, u. By sequentially selecting the \u201cnext\u201d subspace to-be-resolved during a particular iteration on the basis of its greatest relative change, the present invention effectively descends along (resolves) the subspace most likely to affect the physics-based animation.","For example, assume an island data set communicated to IPE  shown in  that corresponds to a number of objects in an animation, each object having during any given iteration from zero to m constraints affecting it. That is, each object may be affected by zero or more constraints during a particular iteration, where each constraint defines one or more constraint rows within the island data set.","With reference to , the island data set is subjected to an initial preprocessing step () once received in IPE memory . Preprocessing includes a definition of initial subspaces in accordance with object\/constraint connectivity relationships expressed in the island data set. In other words, subspaces are formed by grouping \u201cassociated constraint rows\u201d in relation to a common object. Associated constraint rows are preferably, but necessarily, grouped such that all constraint rows arising from the same constraint are placed in the same subspace. This is particularly true for all constraint rows arising from a frictional contact between objects.","Once defined, data associated with each initial subspace is pre-distributed to a corresponding VPU memory (). The corresponding VPU thereafter calculates corresponding Jacobian(s) for the initial subspace (). The subspace data and calculated Jacobians are stored in IPE memory  and\/or a selected VPU memory. Then, an iteration time step value of 0 is assumed ().","Following pre-distribution of the initial subspaces and calculation of Jacobians, a general iteration process begins (). In this process, for each subspace assigned to a VPU (i.e., an execution unit), the VPU calculates an \u201cobject steepness\u201d which is equal to the greatest relative change value for constraint rows associated with an object in the subspace (). Each respective object steepness is evaluated in ICU . Where the maximum object steepness falls below a defined minimum threshold, the general iteration process ends for that particular subspace (=Yes). Where this is not the case (=No), the general iteration process continues.","IPU  generates a number of subspaces, up to the maximum number of available execution units, to be resolved during a \u201ccurrent\u201d iteration (). Subspaces to-be-resolved are sequentially identified in accordance with a \u201cgreatest object steepness.\u201d Neighbored constraint rows associated with an object having the greatest object steepness are grouped into a common subspace wherever possible. The maximum number of grouped rows in a subspace will be determined by such factors as the rate of iteration time step, memory bandwidth capabilities, etc. During generation of the subspaces to-be-resolved in a particular iteration, it is preferred that each constraint row and object appear in only one subspace.","To better accomplish this preference, all constraint rows and objects are listed, using one of many conventional techniques, within each island data set, and marked off the list when grouped into a particular subspace. Each constraint row should be grouped with its neighbored constraint rows, unless a neighbored constraint row has already been marked off the list. However, an object associated with a constraint row may be included in a subspace only if it has not previously been included in another subspace. Omission of a constraint row or object from a particular subspace is usually not a problem since it is likely to be included in a subspace resolved during the next iteration.","Once subspaces have been generated and assigned to respective execution unit for resolution, Jacobian and Mass matrix data associated with the object(s) and constraint(s) in the subspace are also transferred from IPE memory  to a memory associated with the execution unit under the control of ICU  (). With this data appropriately distributed, the plurality of execution units solve in parallel the plurality of subspaces using a competent computational method ().","Following parallel resolution of the plurality of subspaces during an iteration \u201ci\u201d, ICU  collects from each one of the plurality of VPUs the calculated changes in velocity \u0394uand force \u0394d, and updates the overall velocity vector to be u=u+\u0394u, and constraint force vector f=f+\u0394d. ICU  thereafter distributes the updated velocity and constraint force vector information across the plurality of subspaces (). Following update, the method increments the iteration step () and loops back to the beginning of the general iteration process.","Thus, instead of seeking to resolve (i.e., descend over or minimize in the working example) all constraint rows for the whole space during each computational method iteration, the present invention seeks to simultaneously resolve multiple selected subspaces, where each selected subspace contains a sequentially determined greatest object steepness. This approach suggests two implementation considerations. First, respective subspaces should be defined by their constituent constraint rows so as to minimize inter-subspace influences. That is, wherever possible, resolution of a subspace should not depend upon the resolution of a constraint row included in another subspace. Second, where the foregoing consideration is observed, the parallel computational scheme afforded by the present invention will run in a linear manner. That is, the speed of LCP convergence will be increased with the number of parallel execution units applied to the problem.","LCP resolution by subspace, as compared with whole space resolution, affords some interesting processing options. Heretofore, LCP resolution has been assigned to one and only one computational method or algorithm. That is, a single computational method is selected and consistently applied regardless of the particular nature of the physics-based data set, or objects within the data set. Within the context of the present invention, it is possible to evaluate the nature of defined subspaces and thereafter resolve the subspace using a particular computational method selected from a group of competent computational methods. For example, if a subspace contains only object(s) without contact constraints, a specialized bilateral constraint solver, such as Baraff's linear time algorithm disclosed in D. Baraff, \u201cLinear-time dynamics using Lagrange multipliers,\u201d Tech Report CMU-RI-TR-95-44, Robotics Institute, Carnegie Mellon University, (January 1996), may be used to efficiently resolve the subspace. By rationally selecting a well-tailored computational method in relation to the actual nature of data associated with a subspace, LCP resolution speed may be further increased.","The present invention affords the designer of a parallel LCP solver with many advantages. For example, performance and accuracy may be traded-off by adjustments to the size of iteration steps and convergence thresholds. The parallel architecture of the present invention may be applied to single CPU platforms such as PCs, multiple CPU platforms such as game consoles, and systems incorporating a dedicated PPU running in cooperation with a system CPU.","Parallel resolution of subspaces derived from a whole gradient vector defining an LCP allow for real-time resolution of the LCP. Such real-time resolution provides enhanced visual effects to a main application incorporating physic-based animation features, such as rigid body dynamics.","The present invention has been taught in the context of several teaching examples. The scope of the invention is not limited to only the teaching examples, but extends to cover a scope defined by the attached claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["In the drawings, like reference characters indicate like elements. The drawings, taken together with the foregoing discussion, the detailed description that follows, and the claims, describe one or more preferred embodiment(s) of the present invention. In the drawings:",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 4","FIG. 2"]},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
