---
title: Real-time publish-subscribe system
abstract: A real-time protocol for real-time network programming applications is disclosed. The protocol is executable on a computer network having a plurality of nodes that include applications, a network stack, an operating system, and middleware capable of executing real-time operations. The protocol can use group objects to model physical and logical devices connected to the network wherein each group object comprises at least one variable. Changes in these variables are encapsulated in variable change messages which are propagated in the network using communication objects. Also described is a real-time messaging format useful for implementing the protocol.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07882253&OS=07882253&RS=07882253
owner: Real-Time Innovations, Inc.
number: 07882253
owner_city: Sunnyvale
owner_country: US
publication_date: 20020405
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","TECHNICAL FIELD","BACKGROUND","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This application is related to, and claims priority from, U.S. Provisional Patent Application No. 60\/282,321 filed on Apr. 5, 2001, which is hereby incorporated by reference in its entirety.","The invention described herein relates to network programming. In particular, the present invention pertains to the implementation of a real-time publish-subscribe (RTPS) protocol that can be used in real-time network programming applications.","A real-time system (such as a RTPS system) is defined as a system which operates within finite time boundaries. By finite time boundaries, what is meant is that responses to system queries must occur within some predictable time boundary or response time. For example, within two seconds of the query. Response within the predictable time boundary is the overriding parameter. So, the system is not real-time in the sense that transfer of information is instantaneous, but rather that the transfer of information is in accord with some set of time sensitive parameters. Thus, a real time system is not purely asynchronous nor is it strictly instantaneous. The time boundary conditions are flexible depending on the system. For example, a radar tracking system for an anti-aircraft missile requires extremely fast response time. Whereas, a mass production assembly line in a factory may require a much reduced response time on the order of tens of minutes. Both are considered real-time under the definition provided here. Examples of real-time systems can include, without limitation, command-control systems, sensor-actuator systems, network management systems, distributed real-time simulations or games, and the like.","In the field of network applications high level protocols such as DCOM, FTP, DHCP, DCE, RTP, HTTP, and CORBA have been used for constructing commercial applications. Each of these protocols fills a specific niche and are well designed for their specific purposes. However, such protocols are found to be lacking when applied to distributing data in real-time applications. Such protocols do not provide the right level of abstraction and for the most part lack certain key functionalities necessary to create and\/or implement real-time applications. In particular, such protocols do not include functionalities for achieving real-time attributes such as predictable communication, time-aware decisions and notifications, operation over unreliable transports, use of multicast, transparent hot swap substitution, or time and resource aware quality of service (QoS) controls.","The publish-subscribe communications model (also referred to herein as publish\/subscribe) is a new model of network programming, whereby a message sender does not explicitly specify the receiver. Instead, the sender publishes data with a topic, while receivers who are subscribing to the topic will receive the data and possibly an asynchronous notification that the data has changed. This model is quite different from the traditional request\/response programming wherein an application program explicitly indicates the service it wants and synchronously waits for a return from a blocked I\/O call. The publish\/subscribe model has some distinct advantages over typical server\/client networks. For example, there are no special server nodes. Thus, any node can send or receive information streams from any other node. As such, publish\/subscribe systems reduce the amount of system overhead required for the operation of a networked system.","Publish\/subscribe communications reduce network loading and simplify programming for one-to-many network communications. It reduces network loading because there is no need for request messages, and it eliminates for polling. Finally, publish\/subscribe also lets a developer make use of multicast technology where one message can be sent to many receivers. Importantly, publish\/subscribe simplifies network programming because publishers do not need to know where the subscribers are on the network, and subscribers do not need to know where the publishers are. Publishers simply declare a publication topic and start sending messages. Each subscriber simply declares an interest in that topic. The publish\/subscribe software takes care of all the packet addressing, data marshalling (serializing), de-marshalling, and packet-sending.","The publish\/subscribe model is a natural fit for the complex communications required in distributed real-time systems. However, there are limitations to ordinary publish\/subscribe systems. Ordinary publish\/subscribe systems do not provide the time and resource predictability, fault tolerance, robustness and data-delivery control that real time systems require.","Therefore, an improved communication protocol is needed for facilitating real-time communications in real-time computer networks and for implementing real-time network programming applications.","In accordance with the principles of the present invention, one embodiment of the present invention is a real-time protocol executable on a computer network having a plurality of nodes, wherein the nodes can include applications, a network stack, an operating system, and middleware capable of executing real-time operations. The protocol can use group objects to model physical and logical devices connected to the network wherein each group object comprises at least one variable. Changes in these variables are encapsulated in variable change messages which are propagated in the network using communication objects. The variables can be state variables which encapsulate the state of the variables and\/or objects the represent. Also, the variables can include sub-variables which represent portions or aspects of the variable.","Another embodiment comprises a real-time computer architecture that includes write objects, read objects, and a message interpreter. Also, the architecture includes variable reference tables which write objects use to track variable information and remote reader reference tables for each reader so that the writer can determine a message status for each reader. In this architecture, the write object writes variable change messages to associated read objects and a message interpreter receives and interprets the variable change messages so that they can be read by the read object.","In another embodiment, the invention includes a modular message format having a RTPS message header of a uniform length. The format also includes a variable number of RTPS submessages where each RTPS submessage includes a RTPS submessage header of uniform length and a RTPS submessage payload comprised of a variable number of RTPS submessage elements. Also, the message format provides a mechanism to extend the number and types of submessages in such way that the applications using this extended submessages remain backwards compatible with applications that were not aware of these submessages. Also the format provides a way to describe variable properties, encapsulated within submessages, such that new properties can be added in the future, in such way that the applications using this additional properties remain backwards compatible with applications that were not aware of these properties.","The invention includes a method embodiment for writing variable change message from a writer to a registered reader. The method comprises determining if there is a new reader, and where there is no new reader determining if there has been a change to a variable, saving the changes, and modifying the sequence number. Where there is a new reader, a remote reader process is activated to update the reader. Also, the method provides a way to propagate changes in the order they occurred, and to indicate that a set of variable changes should be interpreted by the receiving application in a coherent (indivisible or atomic) manner (i.e. either all the changes are available to the receiving application or no changes are available to the receiving application).","The invention also includes a method embodiment for a registered reader to read variable change messages sent by a writer using the steps of determining if there is a writer for which the reader is registered to receive variable change messages and where there is a suitable writer activating a remote writer process to update the registered reader. Also, a method for determining which changes are relevant to a particular remote application, coalesce (combine) changes in a way that the overall meaning is preserved, and propagate only the changes required to reconstruct a consistent view at the receiving end.","These and other aspects and advantages of the invention will become apparent from the following detailed description and accompanying drawings which illustrate, by way of example, the principles of the invention.","Reference numerals refer to the same or equivalent parts of the present invention throughout the several figures of the drawings.","The present invention has been particularly shown and described with respect to certain preferred embodiments and specific features thereof. The embodiments set forth herein below are to be taken as illustrative rather than limiting. It should be readily apparent to those of ordinary skill in the art that various changes and modifications in form and detail may be made without departing from the spirit and scope of the invention.","The protocol of the present invention is a real-time publish\/subscribe (RTPS) communications protocol that can be put to advantageous use in real-time applications. The RTPS protocol is more efficient than client-server protocols (e.g., DCOM or CORBA) in both latency and bandwidth, and particularly for periodic data exchange. By using subscriptions, occasional low bandwidth subscription requests replace the numerous high-bandwidth client requests, thereby substantially reducing the overhead required in a RTPS system. Latency is also reduced, as the outgoing request message time is eliminated. Additionally, a RTPS protocol is capable of supporting unicast and multicast messaging thereby supporting \u201cmany-to-many\u201d connectivity in group subscriptions. Thus, the RTPS protocol is ideal for building reconfigurable, robust applications that can be scaled to many participating nodes. The RTPS protocol can also take advantage of multicast technology to efficiently send real-time data to many subscribers. The present RTPS protocol can support high-performance real-time communication over standard IP networks. The advantage to this type of publication is that users need not specify computer addresses, routes, port numbers or any of the other identifying information generally required with message-based communications because this information has already been sent and is cached. The publication includes the data format(s) of updates for that publication. Communications occur in three simple steps: declaration of intent to publish by an information producer, declaration of interest in the subject by an information consumer, and delivery of information produced. Each time an information producer publishes a new sample, the communication real-time RTPS middleware operating on the network automatically routes the data from the information producer to all interested information consumers.","RTPS communications are event driven. This means that whenever new data is produced, subscribers are notified and provided with the new data. The subscribers may be notified asynchronously (i.e., interrupted) or synchronously (by polling). Such data transfer is initiated by the publisher.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 1","b":["100","100","100","110","111","110","111","113","111","121","122","121","121","131","131","141","100","131","132","133","131","151","152","153","154","155","151","160","161"]},"Many other arrangements and combinations of busses, hubs, switches and routers are possible. The key aspect is the connection of all the computing elements to a network that allows messages to be exchanged.","As previously stated, distributed real-time systems  can be distributed over vast distances (e.g., nationwide) or over much smaller distances (e.g., throughout a factory manufacturing floor or distributed throughout a ship). In reality, the principles of the present invention may be applied to many different types of a distributed real-time systems that use any number of real-time components (and non-real-time components) interconnected in a variety of ways. In addition to physical devices, the real-time nodes of the system can include logical devices (e.g., executable software capable of conducting real-time operations with respect to devices of the system).","The real-time computer nodes of the distributed real-time system  are capable of executing real-time operations and can include, without limitation, CPU's, embedded systems, robots, sensors, or a variety of other real-time devices.  is a block diagram of a network node  suitable for use as a real-time computer node of the distributed real-time system . The network node  includes an operating system (O\/S) with a network stack ). The network node  also includes real-time middleware  and application software . The real-time middleware  (also referred to herein as just \u201cmiddleware\u201d) accomplishes messaging and object management utilized to communicate with other network nodes of the distributed real-time computing system . The network node  is connected to the distributed real-time system  using a network connection . The network connection  can be a wired or wireless connection. In one embodiment, the network connection  is provided through an Ethernet\u2122 network link. Still further, the network node  includes one or more applications . The application  comprising software and\/or devices. The middleware  is in communication with the applications  and the O\/S  of the network node . Still further, the middleware  of the network node  also communicates with like middleware resident on other network nodes within the distributed real-time system .",{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 3","FIG. 1","FIG. 3"],"b":["300","310","320","320","310","320","330","310","320","320","303","303","303","302","302","302","301","301","301","310","320","320","306","301","301","301","303","303","303","301","301","301","302","302","302"]},"The use of variables with group objects allows the middleware to impose more controlled behavior in the propagation of changes that affect variables within the group. As a result, the application can specify whether certain changes need to be propagated causally (i.e. in the same logical sequence as they occurred) or atomically (i.e. either all available to the application of none available to the application). Moreover, a communication object can determine cases where multiple changes to the group can be combined without affecting the interpretation by the observers, and thus limit the amount of memory and network traffic needed to communicate the state of the group to the remote observers. These capabilities are also extensively described hereinbelow.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 4","b":["400","400","401","402","403","404","401","402","403","404","401","402","403","404","421","422","423","424","401","402","403","404","421","422","423","424","420","420"]},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 5","b":["500","500","510","520","500","500","511","521","500","500","512","522","513","523","500","500","514","500","524","515","500","500","516","526","500"],"sub":["1 ","N","1 ","N"]},"Additionally, the variable  can include a special parameter called a data parameter . The data parameter  is associated with a data value that represents the most current value  of the data parameter  identified by the variable . Changes to the data value  can be intermittent (as shown by the intermittent change values ) or can be a stream of sequential data values taken at regular intervals (as shown by the data stream ). The variable  provides the data values  that are sent to the middleware of the real-time system. The middleware is configured to transmit the data values to appropriate receivers or to store the data values in memory buffers until delivered to appropriate receivers.","Other parameters can be specified that identify and characterize other variables (sub-variables) that are subordinate to the depicted variable . For example, a variable can have a topic identified as \u201cboiler 1\u201d and also have three sub-variables, each pertaining to a separate sensor reading that supplies information concerning boiler 1.","The real-time communications protocol of the present invention is structured such that it can accommodate information produced and transmitted by both group objects and by individual variables. Communications can be grouped in two generalized categories \u201csporadic\u201d communications and \u201cstream\u201d communications.","\u201cSporadic\u201d communications include messages that can represent different (and in many cases only tenuously related) data items. Some characteristics of such \u201csporadic\u201d communications include messages that can have different formats, sizes, and semantics. As a consequence, successive data changes may pertain to completely different types of data. For example, if the system being modeled is an aircraft carrier, a first data message (update) can include information concerning changes to aircraft fuel status (i.e., current remaining fuel is 11,000 tons). The second data message (update) can be unrelated to fuel, for example, it can be a listing of the number and types of aircraft on the flight deck and ready for takeoff. Additionally, such sporadic messages can reflect changes in certain parameters of a variable. Another characteristic of such \u201csporadic\u201d communication is that the messages can be sent at irregular time intervals, rather than periodically or in a continuous stream of data updates. In \u201csporadic\u201d communications, data is generally sent only when there are changes to the preexisting \u201cstate\u201d of some data item. As a result, \u201creliable\u201d message delivery is frequently required in order to ensure that the receiver actually receives the message. Thus, reliability is an important QoS parameter for \u201csporadic\u201d communications. Such \u201creliable\u201d messages are generally transmitted requiring the receiver to acknowledge receipt of the message. This may in some case require the system to store a certain backlog of messages until receipt of the message is acknowledged. In the present invention \u201csporadic\u201d communications can optionally invoke the capability of maintaining the updates in a coherent logical order. This means that the receiver, if desired, can receive the messages in the order that the changes occurred even if the changes occurred to different data items. The invention also enables applications to group a set of changes into indivisible units so that receiving applications can view the entire set of changes, or none of the changes in the set.","Sporadic communications can easily accommodate data transmission concerning group objects. The details of how the real-time protocol of the present invention facilitates such sporadic communications will be described in greater detail hereinbelow.","Another type of data communication uses \u201cstream-based\u201d communications. \u201cStream-based\u201d communications include message streams of successive messages that have the same (or similar) format and size. Examples of such messages are data values pertaining to a data parameter. In such message streams, the format is identical (or selected from a small, well defined, set of formats and message sizes). Also, stream-based messages have similar semantics. For example, the messages may include data information that includes different data values, but all the data values pertain to the same data item. For example, the data information can relate to a temperature sensor reading (in degrees C.), but each successive data value can represent a different value for the temperature. Characteristically, stream-based communications are often repetitive or periodic in nature (e.g., a stream of stock prices over time, or a series of pressure readings from a pressure sensor taken at periodic intervals). Due to the repetitive or periodic nature of most stream-based messages, the message receiver is frequently interested in only the current value of the message stream. As a result, \u201cbest efforts\u201d message delivery is frequently a sufficient quality of service (QoS) parameter. Such \u201cbest efforts\u201d messages are commonly transmitted without the need for the receiver to acknowledge receipt of the message. Such \u201cstream-based\u201d messaging can be thought of as a simplified and less complicated version of the aforementioned \u201csporadic\u201d communications. The details of how the real-time protocol of the present invention facilitates such stream-based communications will be described in greater detail hereinbelow.","Changes in the state of group objects and\/or state variables are transmitted to appropriate receivers of these changes using specialized communication objects. These communication objects include \u201cread objects\u201d (which can include Readers and Subscribers which are collectively referred to herein as \u201cReaders\u201d) and \u201cwrite objects\u201d (which can include Writers and Publishers which are collectively referred to herein as \u201cWriters\u201d). The operation of these Readers and Writers is explained in later paragraphs.","As soon as a new application or device or other entity is connected to a network, Readers and Writers are generated that correspond to that new application or device or other entity. Writers are generated to communicate (or publish) information having certain topics to the rest of the network. Readers are generated by applications or devices or other entities that wish to receive (or subscribe to) information having a desired topic or attributes matching that of the Writers.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 6","b":["611","612","613","614","621","622","623","624","611","621","601","613","611","615","615","623","621","625","625","615","615","613","631","615","613","615","632","633","615","613","640","625","615","640","615","625","623","625","651","623","625","660","615","625","615","613","625","615"],"sub":["A","A"]},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 7A","b":["700","700"]},"The writer process  describes communications between writers mounted on nodes and associated readers (which can be mounted locally on the same node, or remotely on another node). System software and hardware track changes to variables and group objects (collectively referred to herein as \u201cvariables\u201d). Changes to variables are communicated by a Writer to registered Readers (i.e., readers that are registered to receive information about selected variables). The variable change information transmitted between Reader objects and Writer objects is transmitted using messages which will be referred to herein as \u201cchange messages\u201d or \u201cchanges\u201d. Generally, changes are received, put in sequence, and then stored until they can be communicated to registered readers.","When a Reader object is registered to receive changes a remote reader process is initiated (Step ) and the changes are transmitted to registered Reader objects in the form of change messages.",{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 7A","b":["700","700","701","700","711","713","715","700","701"]},"In one example, this process can be illustrated with respect to .  depicts a variable reference table  for a group object, after five change messages have already been saved. If the state is changed, for example, by adding another variable \u201cz\u201d, the table  is updated. This depicted by the updated of the variable reference table \u2032 shown in . Because the addition of \u201cz\u201d occurs after the previously saved change messages, the change message introducing the additional variable \u201cz\u201d is assigned a higher Seq. No., namely, Seq. No. \u201c6\u201d. In this way a sequence of changes can be tracked and maintained a logical sequence order.","Sequence Numbers can also be used to indicate to a Reader that a set of changes should be interpreted as a unit. This can be important in cases where other change interpretations can cause a Reader to make incorrect deductions about the state of the system. For example, variables can be used model the position of a ship using variables \u201cx\u201d and \u201cy\u201d to represent latitude and longitude, respectively. Assuming that these latitude and longitude variables are changed multiple times, resulting in a set of continuously updated variables. In one simplified example, successive \u201cx\u201d and \u201cy\u201d readings are depicted by the following set of change messages: {(x=1, y=1), (x=5, y=5), (x=10, y=10)}. These readings can represent the path followed by the ship. In order to correctly interpret the readings it is important that the change messages be interpreted correctly by the Reader. In some implementations, each change to a variable can be sent as a separate change (e.g.; (Seq. No. 1: \u201cx=1\u201d) which is separate from (Seq. No. 2: \u201cy=1\u201d), which is separate from (Seq. No. 3: \u201cx=5\u201d) and (Seq. No. 4: \u201cy=5\u201d), and so on). Where the readings are so separated, it is important that the order of the changes be preserved. In addition to maintaining sequential change order, it may be important to maintain the interrelationship between the changes. This is especially true where changes are not completely independent. Using the above example, change \u201cy=1\u201d (Seq. No. 2) and should not be grouped together with change \u201cx=5\u201d (Seq. No. 3) because the resulting interpretation by the Reader will result in an incorrect location (x=5, y=1). As can be imagined, this incorrect interpretation can cause the Reader to deduce that the ship is off-course or has collided with an obstacle. In this context, Seq. Nos. can be used to indicate to a Reader that the interpretation of a given change such as \u201cx=5\u201d (Seq. No. 3) must be associated with another change \u201cy=5\u201d (Seq. No. 4) in order to obtain a correct interpretation.","With continued reference to , if there are one or more registered Reader objects, a remote reader process is activated (Step ) for each Reader object. Each remote reader process can be operated sequentially or simultaneously with respect to other remote reader processes. Additionally, as new Reader objects are added to the system, remote reader processes are initiated as necessary for those Reader objects.","One embodiment of a remote reader process comprises the following operations described with respect to .",{"@attributes":{"id":"p-0057","num":"0056"},"figref":["FIG. 7B","FIG. 7A","FIG. 7C","FIG. 7D","FIG. 7E","FIG. 7F"],"b":["703","703","703","703","703"],"i":["a","b","c","d","e"]},"Before a detailed discussion of the remote reader process is completed, a brief discussion of \u201ctimers\u201d is in order. An advantageous feature of the invention is the use of \u201ctimers\u201d to improve the efficiency of message traffic flow in a real-time system. When a timer-regulated process is initiated, data is not sent immediately when directed by the system, instead the timer-regulated process starts a timer with a prescribed time-interval and continues with other tasks. When the timer \u201cfires\u201d the process stops the timer and the actions that initiated the starting of the timer (e.g. the sending of messages) are re-assessed and undertaken if they are still pertinent. Thus, in an interim period between timer initiation and timer firing, additional data and information requests to be sent are accumulated by the system. The timer-regulated process is aware of this additional data and information requests. To the extent such message traffic pertains to messages that are relevant to the timer-regulated process, the actions taken and the messages sent, can be altered. This best illustrated in by simple example.","A timer-regulated process has been requested to send a message (M) to a message receiver A. The timer starts, for example, having duration of two seconds. Rather then sending Mas soon as requested, the process waits two seconds. In the intervening two seconds, the process receives two further requests for sending message Mto receivers B, C, D, E, F, and G. So, when the timer \u201cfires\u201d at the end of two seconds, one multicast message Mis sent to receivers A, B, C, D, E, F, and G. In a non-timed process, six times the amount of message traffic would be generated (one message for each receiver A, B, C, D, E, F, and G). Additionally, the time periods of the timers can be adjusted by user configuration or by adaptive algorithms to manage message traffic and bandwidth. For example, for systems with less memory capacity (and thus less ability to store large volumes of messages accumulated during \u201cwait\u201d periods provided by the timers) shorter time periods can be used. By contrast, in systems where bandwidth is an issue, longer wait periods could be used to reduce the amount of message traffic. Additionally, adaptive algorithms can be used to dynamically adjust time periods throughout the system to continuously adapt to system and user needs.","The flow diagram of  describes a process embodiment whereby a remote reader process can send change messages to a registered Reader object. Initially, the remote reader process determines if all change messages have been sent to the registered Reader object (Step ). If there are any unsent changes, a first timer (a \u201cSEND_VARIABLE\u201d timer) is started (Step ), unless it was already running (Step ). Until the timer \u201cfires\u201d (i.e., until the time period of the timer elapses), the remote reader process defers any sending of unsent change messages and proceeds with the rest of the process (Step ). When it is determined that the timer has fired (Step ), the timer stops (Step ) and the next unsent change messages are sent to Reader objects registered to receive those messages (Step ). Typically such unsent change messages comprise unsent change messages having the lowest Seq. Nos. (i.e. the oldest remaining messages). Such messages can include changes to variables and \u201cGAP\u201d messages (the function of which is explained in greater detail below). The sent changes are then marked on a remote reader reference table as having been sent. Alternatively, if there are no unsent variable changes, the remote reader process proceeds to Step () of  (described in detail with respect to ) (Step ).","The operation of the flow diagram of  can be better understood with reference to .  depicts a variable reference table  (similar to that shown in ) and an associated remote reader reference table . Each Writer maintains a variable reference table  that tracks changes to variables for the Writer and the logical order in which those changes occurred. Also, one writer object can be associated with many different reader objects, each one having its own remote reader reference table. The remote reader reference table is used to track message traffic information. For example, a remote reader reference table can track message status information including, but not limited to, messages sent to that reader object, messages received by that reader object, messages acknowledged as received by that reader object, and messages requested by that reader object.","Referring to the remote reader reference table  depicted in , sent messages are tracked . Here, messages 1, 2, 3, and 4 have been marked as having been sent. Acknowledged messages can also tracked . Here, messages 1, 2, and 3 have been marked as acknowledged as having been received by the reader object. Other included message categories within the remote reader reference table  include messages requested  which tracks whether the reader object has requested that the remote reader process (for the writer object) send (resend) one or more messages.","Returning to , when the timer elapses (Step ) and the timer is stopped (Step ). Then at least one of the next unsent change messages is sent to the registered reader object. For example, consulting the variable reference table  of , the next unsent message (message \u201c5\u201d, \u201cy=99\u201d) would be sent to the reader object. Once sent, the message \u201c5\u201d box of the sent messages column  of the variable reference table  of  can be checked off.","Again returning to , if there are no unsent variable changes (e.g., change messages), the process continues by proceeding to  of  (Step ) where positive and negative acknowledgements can be processed.  describes processing for treating not only positive acknowledgement messages (ACK) but also for treating negative acknowledgement messages (NACK's). The processing depicted in  determines whether a positive acknowledgement message (ACK) has been received from a reader object (Step ). If an ACK has been sent by a reader object and received by the associated remote reader process, the remote reader reference table for that reader object is updated to reflect the acknowledgement (Step ). Once the remote reader reference table is updated, the process returns to point  of .","On the other hand, if it is determined (Step ) that no ACK has been received, it is determined whether a negative acknowledgement message (NACK) has been received from a reader object (Step ). A NACK is a request to resend unacknowledged change messages. If a NACK has been sent by a reader object and received by the associated remote reader process, the remote reader reference table for that reader object is updated to reflect the negative acknowledgement (Step ). Once the remote reader reference table is updated, the process returns to point  of . Alternatively, if it is determined that no NACK has been received (Step ), then the process proceeds to  of  (Step ).","The process of updating positive acknowledgement status may be better understood with reference to  which illustrates this process using an embodiment of a remote reader reference table . In the depicted embodiment, all change information (e.g., up to Seq. No. 4) has been sent. The highest number for a received ACK is Seq. No. 3. Then, if the reader object were to send an ACK message regarding Sequence No. 4 to the remote reader process (namely, writer object) and such ACK message were to be received, the remote reader process would cause the remote reader reference table  to be updated  to reflect the receipt of the ACK for Seq. No. 4. Alternatively, when a reader object sends an a NACK (negative acknowledgment) message regarding Sequence No. 4 to a remote reader process that is received, the remote reader process would cause the remote reader reference table  to be updated  to reflect the receipt of the NACK for Seq. No. 4.","After updating ACK or NACK status (Steps () and () of ), the process continues to Step () of . This is illustrated as Step  of .","Returning to , messages that are requested are resent (Step  ()). This process is illustrated in . The processing illustrated in  begins by determining whether any readers objects are requesting variable information (Step ). This step is commonly used by reader objects to request that missed variable change messages be resent. In one implementation a remote reader reference table can be consulted to determine if the corresponding reader object has requested that variable information (e.g., change message identified by Sequence No.) be resent. These requests can be made in the form of a NACK message from the reader object for a change message having a specific Seq. No.",{"@attributes":{"id":"p-0069","num":"0068"},"figref":["FIG. 10E","FIG. 10E"],"b":["1070","1070","1071","1072","1073","1075","1076"]},"Returning to , if there are no requests for variable change messages, the process continues to Step () of . This is reflected by activating the process illustrated in  (Step ). However, if there are pending requests for variable change information (Step ), and a second timer (a \u201creply to request\u201d timer) is not already started, then the second timer is started (Step ). The process continues to Step . However, if the second timer was already running the process checks if it has fired (Step ). If the second (\u201creply to request\u201d) timer has not fired then the process continues to Step . But, if the second timer has fired (Step ), then the remote reader reference table is consulted, and the pending requests for change messages are located and identified. Indicators  and  for such identified requests are shown in . The process then stops the timer (Step ) and sends at least one of the identified requested variable change messages to the requesting reader objects (Step ). In most cases the change messages sent will be those the identified requested variable change messages having the lowest Seq. Nos. (i.e. the oldest messages). Such messages can include changes to variables and GAP messages (GAP messages will be explained in greater detail below). At this point the processing returns to point  of  (Step ).",{"@attributes":{"id":"p-0071","num":"0070"},"figref":["FIG. 7F","FIG. 7F","FIG. 10F","FIG. 10F"],"b":["1080","1080","1081","1082"]},"Returning to , the process determines if there are unacknowledged variable change messages (Step ). As indicated, message 4 is an unacknowledged variable change message. This starts a third timer (\u201ctimer \u201d) (Step ). Until the time period of third timer elapses and the timer \u201cfires,\u201d the processing waits for the third timer to fire (Step ). When the third timer does fires, then a heartbeat is sent to the reader object (Step ). This heartbeat identifies the highest Seq. No. of a message sent, thus far, by the writer object (namely, the associated remote reader process). For example, using , the highest Seq. No. for a sent message is Seq. No. 5. Inherent in such heartbeat messages is a request for acknowledgement that the sent messages have been received. At this point the process returns to point  of  (Step ).","As shown in , the process determines if there are unacknowledged variable change messages (Step ). As indicated, message 4 is an unacknowledged variable change message. Where a third timer is not already running (Step ), this starts the third timer (\u201cheartbeat_timer1\u201d) (Step ). If the third timer is already started (Step ), or was started but it has not fired (Step ), the process goes back to point  of  (Step ). Once the \u201cheartbeat_timer1\u201d fires (Step ) the process stops the timer (Step ) and sends a heartbeat message to the reader (Step ). The heartbeat identifies the highest Seq. No. of the variable change message sent by the writer to the Reader process. For example, using , the highest Seq. No. for a sent message is Seq. No. 5. Inherent in such heartbeat messages is a request for acknowledgement that the sent messages have been received. At this point the process returns to point  of  (Step ).","Still referring to , if there are no unacknowledged variable change messages (in Step ), the processing continues by activating the portion of the process illustrated by Steps - and Step . If there are no unacknowledged variable changes in Step , then the process checks whether another fourth timer (\u201cheartbeat_timer2\u201d) has already been started (Step ). If it has not been started, the process starts the fourth timer (Step ) and then returns to point  of  (Step ). Where the fourth timer has been started but has not yet fired (Step ), the process also goes back to back to point  of  (Step ). However, when the fourth timer (\u201cheartbeat_timer2\u201d) fires (Step ), the process stops the timer (Step ). Then a heartbeat message stating that no confirmation is requested is sent to the reader object (Step ). At this point the processing returns to point  of  (Step ). Previous reference has been made to \u201cGAP\u201d messages. GAP messages can be used to provide a continually updated picture of a group object and can be used to limit the amount of memory required to store the history of changes the variables within the group have undergone. Furthermore, GAP messages can be used to present a different view of a group object to different remote readers that may only be interested in a subset of the variables within the group.","One implementation of such GAP messages can be explained with respect to , which depicts an embodiment of a variable reference table . As previously discussed, a variable reference table  includes a list of Seq. Nos.  and a list of variable change messages  associated with the Seq. Nos. . In this example, the variable reference table  illustrates a series of changes to the variable pertaining to a group object. Using the depicted table  as an example, a first message (having Seq. No. 1) tracks the addition of a new variable \u201cx\u201d to the group object. At some later time, new variables \u201cy\u201d and \u201cz\u201d have also been added to the group object (i.e., messages 4 and 7). Messages updating values for \u201cx\u201d (messages 2, 3, 6, and 8) have also been posted to the table , as have messages updating values for \u201cy\u201d (messages 5 and 9). If a reader object is interested in the current value of a variables, older information is not particularly relevant or important to the reader object. The \u201cGAP\u201d message is a convenient way of efficiently dealing with this situation. For example, if a new reader object is connected to a real-time network after message 9, GAP messages can be used to efficiently present the current state of the group object to the reader object. In an implementation where only the most current information is desired by the reader object, GAP messages replace all prior values for each variable. As an example, chart  shown in  depicts a list of the variable messages and GAP messages that represent the current state of the group object to the reader object (that is activated connected to the writer object after Sequence No. 9). Only the addition of new variables and their most recent values is presented. All other messages can be replaced with GAP messages. Thus, the Chart  depicts the following change messages and Seq. Nos.: 1: \u201cnew x\u201d; 2: GAP; 3: GAP; 4: \u201cnew y\u201d; 5: GAP; 6: GAP; 7: \u201cnew z\u201d; 8: \u201cx=12\u201d; 9: \u201cy=5\u201d. A more complete history of the previous values for variables can also be presented. In such cases GAP messages replace only the older messages (in one example, all changes except for the last three changes affecting each variable \u201cx\u201d, \u201cy\u201d, or \u201cz\u201d may be replaced with GAP messages).","In another example (explained with reference to table  of ), where a reader is only interested in variables \u201cx\u201d and \u201cz\u201d, the latest state of the group object with the sequence following sequence of messages is depicted. Table  which is only interested in variables \u201cx\u201d and \u201cz\u201d includes the following set of Seq. Nos. and values. Seq. Nos.: 1: \u201cnew x\u201d; 2: GAP; 3: GAP; 4: GAP; 5: GAP; 6: GAP; 7: \u201cnew z\u201d; 8: \u201cx=12\u201d; 9: GAP. Additionally, the format of the GAP submessage (described in greater detail hereinbelow) allows for consecutive GAP submessages (such as in ) to be grouped to further reduce the actual number of submessages sent by the system. For example, referring to table , the complete sequence of change information can be sent using five submessages (e.g.; Seq. No. 1 \u201cnew x\u201d; one GAP that includes Seq. Nos. 2 through 6; Seq. No. 7 \u201cnew z\u201d; Seq. No. 8 \u201cx=12\u201d; and a GAP for Seq. No. 9).The general mechanism for determining which changes are to be propagated to a remote reader and which changes which can be coalesced into combination of new GAP and modified changes is described hereinbelow. A writer propagates its most current state to readers associated with the writer. It is not necessary for the writer to propagate all the changes to a reader causing the reader goes though all the same states as the writer. Nor it is required that the writer maintain a record of all changes (and states) as long as the reader can recreate a valid subset of states of the writer, and as long as the logical order in which the subset of writer states experienced by the reader consistent with the order of states in the writer.","More formally, a writer can be considered to have a state \u201cS\u201d consisting of the values of all the data objects it contains. As these data objects are modified, the state of the writer also changes and thus we can see the writer as transitioning through a sequence of states S, S, S, etc. Any one of the states Scan be decomposed as a sequence of changes C, C, . . . C. Each of these changes typically represent changes (deltas) from the previous state (e.g.; the addition of new data objects, the removal of existing data objects, modifications to values for existing data objects, and numerous other changes). So a sequence of states (e.g.; S, S, S, S, . . . ) of a group object can be expressed as containing the sequence of changes (C, C, . . . C) as follows. S=C; S=C+C; S=C+C+C; S=C+C+C+C; and so on. A writer can ensure that each reader only sees a subset of the valid states (here, S, S, S, S) in the correct logical sequence. In other words a reader could be presented with states in order S, S, S, S, but not in order S, S, S, S, nor order where S, S, S, where state Sis not a valid state of the group object in the writer.","As previously mentioned each individual change in a sequence of the changes (C, C, . . . C) need not be preserved. For instance assume that the group of changes Crepresents the change sequence C+C. A writer can propagate C, C, and Cas changes. The receiving reader observes states S, S, S. Referring again to tables  and  in , example states are: S={x=<unset>}, S={x=5}, S={x=7}, S={x=7, y=<unset>}, S={x=7, y=10}, S={x=11, y=10}, S={x=11, y=10, z=<unset>}, S={x=12, y=10, z=<unset>}, S={x=12, y=5, z=<unset>}. In this same example change Crepresents the creation of the new \u201cx\u201d variable at Seq. No. 1. Change Crepresents the change occurring at Seq. No. 2 setting x=5 and change Crepresents the change at Seq. No. 3 that sets x=7, and so forth. Changes Cand Ccan be combined into the single change Cwhich simply sets x=7. A remote reader receiving the change messages in table  observes Cas new \u201cx\u201d; GAP for Seq. No 2, Cwill reconstruct the states S\u2032={x=<unset>}=S, S\u2032={x=<unset>}=S, S\u2032={x=}=Swhich is a proper subset of the sequence S, S, S, and so on.","Furthermore, with respect to a specific reader, a writer only needs to propagate the changes needed to reconstruct a projection of the state of the writer that includes only changes the reader is interested in. The projected state being defined as the state of the group object when only the values of the variables of interest to the reader are considered in the definition of the state. Again referring to the example in , table  depicts the projection of the writer onto a reader that is only interested in variables \u201cx\u201d and \u201cz\u201d and thus the only changes propagated are those pertaining to variables \u201cx\u201d and \u201cz\u201d. It is worthwhile to note that even though different variables are important to different readers, the writer preserves the logical sequence of changes for each reader. Additionally, change information can be selected by readers based on many different parameters, including, but not limited to identity (topic) of the variable, variable metadata, or the contents of the data itself.","The importance of, in some embodiments, grouping changes so that the reader does not misinterpret the state of the system was previously discussed. This means that each change in the state of a group object associated with the writer can involve changes to more than one variable of the group object. In other words, transitioning from one valid state of the group object to the next valid state of the group object may require multiple changes.","In one illustration, a simplified group object includes variables \u201cx\u201d and \u201cy\u201d. The simplified group object has a set of valid states S, S, S, comprising S={x=1, y=1}, S={x=5, y=5}, S={x=10, y=10}. To maintain a propagation of these valid states requires that the changes be aggregated in a particular way. For example, the above example can include six changes C, C, C, C, C, and C, where C=\u201cx=1\u201d, C=\u201cy=1\u201d, C=\u201cX=5\u201d, C4=\u201cy=5\u201d, C=\u201cx=10\u201d, C=\u201cy=10\u201d. Using these changes Cis aggregated with C, Cis aggregated with C, and Cis aggregated with C. This can be accomplished by the RTPS protocol by including an additional Seq. No. propagated with each change submessage. This additional Seq. No. is included in the change submessage thereby identifying the Seq. No. of the last change that belongs to the aggregation of changes. For example, a submessage containing Ccan also contain Seq. No. 2 (identifying the Seq. No. of the last change in this aggregation), and the submessage containing Calso contains Seq. No. 2 (identifying the Seq. No. of the last change in this aggregation, effectively ending the aggregation). In like manner, a submessage containing Ccan also contain Seq. No. 4 (identifying the Seq. No. for the last change in the aggregation) and the submessage containing Ccontains Seq. No. 4 (identifying the Seq. No. of the last change in this aggregation, thereby ending the aggregation). These approach can be used to aggregate all such groups of associated changes. Additionally, this approach is readily extended to groups of changes having several (more than two) changes as part of the same aggregation.","Working in conjunction with the above-described writer process and remote reader process is a corresponding reader process and a remote writer process.  is a general depiction of such a reader process  for receiving change information and heartbeat messages (requests for confirmation) from writers to the readers. Also, the reader process  facilitates the communication of acknowledgements (confirmations) and negative acknowledgements (requests) from the readers back to the writers. From the readers point of view, a writer is identified and a remote writer process is initiated (Steps -). The details of this reader process and associated remote writer process are described in greater detail herein below.","When viewed from a reader perspective, the processing begins with the reader determining if there are writers that have variables with topics the reader is interested in (Step ). This means that registered readers can determine if there are writers having variables pertaining to the topics that the reader is interested in. If there are no appropriate writers, the processing returns to point  until such a writer appears. If there are appropriate writers, then a remote writer process is initiated and executed (Step ).",{"@attributes":{"id":"p-0084","num":"0083"},"figref":["FIG. 9B","FIG. 9A","FIG. 9C","FIG. 9D","FIG. 9E"],"b":["905","905","905","905"],"i":["a","b","c"]},{"@attributes":{"id":"p-0085","num":"0084"},"figref":["FIG. 9C","FIG. 9A"],"b":["911","913","915","901","917"]},"Alternatively, if the reader object has not a received new variable change message, then the process goes to  of  to mark messages identified by heartbeat messages as confirmation requested (Step ).  depicts a portion of the remote writer process corresponding to () of . The process begins by determining whether any heartbeat messages have been received (Step ). As previously explained, a heartbeat message identifies the highest Seq. No. message sent by the writer object. If a heartbeat has not been received, confirmation requests are dealt with (Step ). This portion of the processing (namely, () of ) will be discussed in greater detail below with respect to . However, if a heartbeat has been received, the processing determines if the reader object has received all the variable change messages it should have (Step ). This can be accomplished by comparing the Seq. No. of the heartbeat with the Seq. No. of all messages received. For example, if a heartbeat sends Seq. No. 8 that means that messages having Seq. Nos. 1-8 have been sent. If the reader object has also received messages having Seq. Nos. 1-8 that means that the reader object has received all the variable change messages it should have and the process can then proceed to the next Step . However, if reader object has not received all the variable change messages, the unreceived change messages are marked as missing (Step ). This is because a standard heartbeat message informs the reader of the changes it should have received. Thus, the reader can determine that it has missed some of those messages. Once the change messages are marked as missing, the process returns to point  of . (Step ).","Where the reader has received all the changes indicated in the heartbeat (Step ), it is determined whether the heartbeat itself requires confirmation (Step ). If confirmation is not required, then the process returns to point  of  (Step ). On the other hand, if the heartbeat does require confirmation, then the variable change message having the highest Seq. No. is identified in the heartbeat message and marked as requesting confirmation. The process then returns to point  of . (Step ).",{"@attributes":{"id":"p-0088","num":"0087"},"figref":["FIG. 9E","FIG. 9A","FIG. 9A","FIG. 9A"],"b":["905","941","951","942","943","901","948","944","901","948","945","946","947","901","948"],"i":"c"},"Returning to Step , where no changes are marked as missing, the processing proceeds to Step  where it is determined if there are changes marked as confirmation requested. If there are no changes marked as confirmation requested, the processing goes to  of  (Step ). Where changes are marked as confirmation requested, the processing checks whether a sixth timer \u201cconfirmation_timer\u201d has been started (Step ). If the timer has not been started, the \u201cconfirmation_timer\u201d is activated (Step ) and the processing returns to  of  (Step ). If the \u201cconfirmation_timer\u201d is already activated, the processing determines whether the \u201cconfirmation_timer\u201d is activated has fired (Step ). In the case where the \u201cconfirmation_timer\u201d has not fired, the processing returns to  of  (Step ). In the case where the \u201cconfirmation_timer\u201d has fired, the processing stops the \u201cconfirmation_timer\u201d (Step ) and sends a confirmation message (ACK) back to the writer that requested the confirmation (Step ). At this point the status of messages is updated to reflect the fact that messages marked as \u201cconfirmation requested\u201d have now been sent confirmation messages (ACK's) (Step ). The processing returns to  of  (Step ).","The processing described hereinabove describes a process where a reader to sends confirmation messages for particular Seq. Nos. once they have been marked as confirmation requested. In different implementations, the middleware can operate differently. For example, when a change is marked as confirmation requested, the middleware can unmark all changes that were marked \u201cconfirmation requested\u201d that have smaller sequence numbers than the current ones. The state of the \u201cconfirmation\u201d timer is however preserved so the confirmation will be send on the same schedule as before but with a higher Seq. No. thus saving confirmation messages.","Another useful attribute of the present invention is its ability to self-configure network nodes or applications as soon as they are connected to the network. To this end, each node has a set of built-in Readers and Writers concerning topics useful to the configuration of the nodes. As soon as the node is connected to the network, the RTPS communication protocol automatically assumes the existence of certain built-in readers and writers in a preconfigured set of nodes (given individually as a list or in group manner using multicast or broadcast). It then creates remote readers for the assumed readers on those remote nodes, and uses the writer to reader communication to send and receive information regarding the properties of the node. Properties of the node include, but are not limited to protocol versions, vendor information, source and destination hostnames, IP addresses, pathnames, communication ports. The built-in readers and writers communicate also the existence of publications, subscriptions and other variables. Using this mechanism, and with the aid of built-in writers that have group objects containing the list of all subscription, publications, variables and other relevant information, the nodes inform each other of topics, readers, writers, and other things they can publish or subscribe to. This permits each node to set itself up without the need for a network administrator to do it manually.",{"@attributes":{"id":"p-0092","num":"0091"},"figref":"FIG. 11","b":["1101","1102","1103","1104","1103","1121","1101","1121","1122","1123","1124","1123","1124"],"sub":["A","A","A","A","A ","A","A "]},"In order to be correctly interpreted by the Message Interpreter  the messages should comply with some standardized format. Although many formats can be used, one message format embodiment will be detailed hereinbelow. Items like data must be encoded. In one suitable implementation data is encoded using OMG CDR (See, The Object Management Group \u201cCDR data representation\u201d, http:\/\/www.omg.org\/corba\/corbiiop.htm, August 1998). Such CDR data representation encapsulates data using the native order and the endianess of the sending machine and leaves correct interpretation up to the receiver. Seq. Nos. are encoded using 64 bits. Timestamp information uses standard NTP representations of time (Internet Engineering Task Force (IETF) RFC 1305 \u201cNetwork Time Protocol (Version 3) Specification, Implementation and Analysis\u201d. See, http:\/\/www.ietf.org\/rfc\/rfc1305.txt). The objects on the network can be uniquely identified using 12 octet Global Unique Object ID's (GUID). The GUID is built of three components (HostId, ApplicationId, ObjectId) each comprising a 4-octet data stream. Such identifiers can be constructed using the UUID specification from OSF\/DCE (See, The Open Call Group Document C706, \u201cCDR 1.1: Remote Procedure Call\u201d see, http:\/\/www.opengroup.org\/publications).","Using these formats, a modular message format can be constructed that allows the use of small set of well known and readily understood submessages to communicate information in accordance with the real-time communication protocol of the present invention.  illustrates a typical RTPS message suitable for use with the RTPS communication protocol of the present invention. In one implementation, when UDP\/IP is used, a RTPS message is the contents of one UDP\/IP Datagram. A RTPS message  includes an RTPS header  followed by a variable number of RTPS submessages , , . A more detailed view \u2032 of an RTPS submessage shows a RTPS submessage header  and RTPS submessage payload . The RTPS submessage payload  is comprised of a variable of submessage elements , . Each of these components of an RTPS message will be briefly explained.",{"@attributes":{"id":"p-0095","num":"0094"},"figref":"FIG. 12B","b":["1220","1221","1221","1222","1223","1224","1225"]},"Referring again to , the RTPS message  further includes a variable number of RTPS submessages , , . Each RTPS submessage includes a RTPS submessage header  and RTPS submessage payload  comprised of one or more RTPS submessage elements , .",{"@attributes":{"id":"p-0097","num":"0096"},"figref":"FIG. 12C","b":["1230","1231","1232","1231","1233","1234","1234","1235","1233","1233","1233","1231","1236"]},{"@attributes":{"id":"p-0098","num":"0097"},"figref":["FIGS. 12D-12G","FIG. 12D"],"b":["1240","1241","1242","1243"]},{"@attributes":{"id":"p-0099","num":"0098"},"figref":"FIG. 12E","b":["1250","1251","1252","1253","1254"]},{"@attributes":{"id":"p-0100","num":"0099"},"figref":"FIG. 12F","b":["1260","1261","1262","1263","1264","1265","1266","1267"]},{"@attributes":{"id":"p-0101","num":"0100"},"figref":"FIG. 12G","b":["1270","1271","1272","1272","1272","1273","1274","1275","1276","1277"]},"An advantage to the above-described message format is that a single submessage can be used to control the context of the interpreter and thus affect the interpretation of an entire stream of related submessages. Because this information is cached by the Message Interpreter, the information only needs to be sent once per message and does not need to accompany each submessage as is often conventionally required. Furthermore, the use of globally-unique object identifiers (GUID) to identify source and destination of many submessages, allows readers and writers to remember information previously conveyed by that same reader and writer. This information pertaining to, for example, the properties of the Reader or Writer does not need to be sent along with each message they exchange as is often conventionally required. These two attributes reduce message (and submessage) size having the result that network message traffic is reduced.","The present invention has been particularly shown and described with respect to certain preferred embodiments and specific features thereof. However, it should be readily apparent to those of ordinary skill in the art that various changes and modifications in form and detail may be made without departing from the spirit and scope of the invention as set forth in the appended claims. Although the disclosed system is particularly suitable for real-time applications, the inventors contemplate that its attributes and characteristics are also well suited for use with conventional publish-subscribe systems. Furthermore, the examples provided herein are intended to be illustrative rather than limiting. The inventions illustratively disclosed herein can be practiced without any element which is not specifically disclosed herein."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["For a fuller understanding of the invention, reference is made to the accompanying drawings in the following Detailed Description. In the drawings:",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIGS. 2 and 3"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIGS. 7A-7F"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIGS. 9A-9E"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIGS. 10A-10F"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIGS. 12A-12G"}]},"DETDESC":[{},{}]}
