---
title: Method for implementing fine-grained access control using access restrictions
abstract: Disclosed is a data processing system-implemented method, a data processing system and an article of manufacture for controlling access to data stored on a database having relational objects for which access restrictions are defined for elements of the relational objects The data processing system-implemented method includes receiving a user request to access one or more relational objects of the database, identifying any access restrictions defined for the one or more relational objects, determining whether any identified access restrictions are applicable to the user request, determining whether any determined applicable access restrictions are to be enforced for the user request, and allowing access to the one or more relational objects based on the determined enforceable access restrictions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07958150&OS=07958150&RS=07958150
owner: International Business Machines Corporation
number: 07958150
owner_city: Armonk
owner_country: US
publication_date: 20040430
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF THE EMBODIMENTS","EXAMPLE 1","EXAMPLE 2","EXAMPLE 3","EXAMPLE 4","EXAMPLE 5","EXAMPLE 6","EXAMPLE 7"],"p":["The present invention relates to database management systems, and more particularly to a method, a system and a computer program product for fine-grained access control of data, stored in a database, using access restrictions.","Access control for data and information contained in databases is of increasing importance for reasons relating to security and privacy. In a database management system (DBMS), data is stored in data containers made up of records having one or more data fields. In a relational database management system, the data container is a relational object made up of rows and columns wherein each row represents a record and the columns are fields in those records. A relational object may be, for example, a relational table or relational view.","Fine-grained access control (FGAC) has grown in importance to commercial and government users of relational databases especially with recent government initiatives to increase overall security. FGAC is typically defined as the ability to control the access to data by any user at the object level and lower levels. For example, FGAC can be used to limit user access to a specific set of rows in a relational table. This level of access control is desirable for all areas of relational data access such as utilities, but is particularly desirable for data manipulation language (DML) SQL statements such as SELECT, INSERT, UPDATE and DELETE.","Traditional methods of implementing FGAC within relational databases have relied upon the use of views. A view is a logical table which is derived from existing tables and can be queried by users in the same manner as a regular table. A view is defined by metadata known as a view definition. The view definition contains mappings to one or more columns in one or more tables stored on a database. Typically, the view definition is provided a priori by the user of the database in the format of a CREATE VIEW SQL statement.","Views provide one method for implementing FGAC that works well when the number of different restrictions is few or the granularity of the restrictions is such that it affects large, easily identified groups of users. When these conditions are not true, a number of issues arise with the use of views including: (1) view definitions may become quite complex in an effort to contain all the restrictions in one view, straining system limits and making maintenance of the view difficult; (2) if a large number of simple views is desired, each one implementing a unique view of a table based on the restrictions for a specific set of users, the routing of user requests becomes difficult with the solution often being resolved within the database application instead of the DBMS; and (3) if a user can bypass the view when accessing data, for example by having direct access to the underlying tables for query access, then restrictions may be not enforced.","Another known implementation of FGAC uses context attributes of a user session to modify SQL statements by adding a predicate into the query. A predicate is a condition that must be satisfied for the DBMS to return a value. In this approach, the context attributes of a user session (e.g. user identifier) are compared against a security policy defined within a procedure provided by the user on a table or view to make decisions regarding access to data. This approach allows row restrictions traditionally handled by views to be dynamically added to queries without requiring application modification, however this approach has several disadvantages. Firstly, this approach requires user programming of a strictly defined \u201cpredicate producing\u201d procedure in order to implement a security policy. The creation of user defined procedures for each policy is time consuming and error prone. Secondly, this approach does not provide access control at the column level. Thirdly, this approach interferes with dynamic SQL caching because the modified SQL statement will no longer match the original text from the request which makes statement matching problematic and thus, has an impact on the performance benefits of the caching. Cached SQL statements can not generally be shared because the result of the security policy applicable to cached statements (i.e. the predicate to be added to the query) is not known in advance.","Users of modern relational databases desire the following capabilities in an FGAC implementation:","(1) an implementation which solves the problem within the DBMS without application changes or application awareness of the implementation;","(2) a pervasive implementation that ensures that all users of the table being controlled are affected, regardless of how the table is accessed;","(3) an implementation that minimizes the complexity and maintenance of the fine-grained access control policies defined by the user;","(4) the ability to apply the implementation to both tables and views;","(5) the ability to control access to rows as well as columns as desired; and","(6) the ability to have unlimited granularity control within the implementation.","In view of the shortcomings of known FGAC implementations, there exists a need for an improved method of implementing fine-grained access control to a database.","The present invention obviates or mitigates the foregoing problems associated with the prior art by providing a method, a system and a computer program product for fine-grained access control of data, stored in a database, using access restrictions. In one example embodiment, access restrictions and exceptions thereto are used to provide fine-grained access control, specifically the ability to restrict both column and row access to relational objects, for example, a relational table or relational view.","In accordance with one aspect of the present invention, there is provided a data processing system-implemented method for directing a data processing system to control access to data stored on a database having relational objects for which access restrictions are defined for elements of the relational objects, the data processing system-implemented method including receiving a user request to access one or more relational objects of the database, identifying any access restrictions defined for the one or more relational objects, determining whether any identified access restrictions are applicable to the user request, determining whether any determined applicable access restrictions are to be enforced for the user request, and allowing access to the one or more relational objects based on the determined enforceable access restrictions.","In accordance with another aspect of the present invention, there is provided an article of manufacture for directing a data processing system to control access to data stored on a database having relational objects for which access restrictions are defined for elements of the relational objects, the article including a program usable medium embodying one or more executable data processing system instructions, the executable data processing system instructions including executable data processing system instructions for receiving a user request to access one or more relational objects of the database, executable data processing system instructions for identifying any access restrictions defined for the one or more relational objects, executable data processing system instructions for determining whether any identified access restrictions are applicable to the user request, executable data processing system instructions for determining whether any determined applicable access restrictions are to be enforced for the user request, and executable data processing system instructions for allowing access to the one or more relational objects based on the determined enforceable access restrictions.","In accordance with a further aspect of the present invention, there is provided a data processing system for controlling access to data stored on a database having relational objects for which access restrictions are defined for elements of the relational objects, the data processing system including a module for receiving a user request to access a relational object, a database catalog defining access restrictions for restricting user access to the database, wherein each access restriction identifies a row or column in a relational object to which the access restriction applies, a type of access which is restricted, and information concerning one or more users to which the access restriction applies, a restriction evaluation module including a component for identifying any access restrictions defined for the one or more relational objects, a component for determining whether any identified access restrictions are applicable to the user request, and a component for determining whether any determined applicable access restrictions are to be enforced for the user request, and a module for allowing access to the one or more relational objects based on the determined enforceable access restrictions.","Other aspects and features of the present invention will become apparent to those ordinarily skilled in the art upon review of the following description of specific embodiments of the invention in conjunction with the accompanying figures.","Similar references are used in different figures to denote similar components.","The following detailed description of the embodiments of the present invention does not limit the implementation of the embodiments to any particular computer programming language. The computer program product may be implemented in any computer programming language provided that the OS (Operating System) provides the facilities that may support the requirements of the computer program product. A preferred embodiment is implemented in the C or C++ computer programming language (or may be implemented in other computer programming languages in conjunction with C\/C++). Any limitations presented would be a result of a particular type of operating system, computer programming language, or data processing system and would not be a limitation of the embodiments described herein.","Reference is first made to , which shows a computer system  including a server  and clients  indicated individually by references , , . . . , interconnected by a network . The server  may be modeled as a number of server components including a database server or database management system , for example, a relational database management system such as the DB2\u2122 product from IBM\u2122 (International Business Machines) Corporation. The clients  may be computers, data processing systems, workstations, handheld portable information devices, or computer networks. The clients  may be the same or different. In one embodiment, the network  is the Internet or World Wide Web (WWW).","The computer system  further includes a database  and resources  connected to the network . The resources  may be storage media, databases, a set of XML (eXtensible Markup Language) documents, a directory service such as a LDAP (Lightweight Directory Access Protocol) server, and backend systems. In some embodiments, data may be stored across multiple databases. The interface between the server  and the database  and resources  may be a local area network, Internet, or a proprietary interface, or combinations of the foregoing. The database  and resources  may be accessed by the server  and the clients . Any of the server , the clients , the database  and the resources  may be located remotely from one another or may share a location. The configuration of the computer system  is not intended as a limitation of the present invention, as will be understood by those of ordinary skill in the art from a review of the following detailed description. For example, in other embodiments the network  may comprise a wireless link, a telephone communication, radio communication, or computer network (e.g. a Local Area Network (LAN) or a Wide Area Network (WAN)).","Reference is now made to , which shows a data processing system  in the computer system . The data processing system  comprises a bus  coupled to a processor , memory , display , and user input devices  such as a keyboard and a pointing device (e.g. mouse), and a communication interface  for communicating with the network . An operating system , database application , and other application programs  run on the processor . The memory  includes random access memory (\u201cRAM\u201d) , read only memory (\u201cROM\u201d) , and a hard disk . The data processing system  may be a client  or a server .","Referring now to , one embodiment of an information retrieval system  constructed according to the present invention will be described. In this embodiment, the information retrieval system  comprises a server , clients  coupled to the server  via a network, and a database . The server  includes a database management system (DBMS) , for example a relational database management system such as the DB2\u2122 product from IBM\u2122. The DBMS  includes an SQL compiler  comprising a parser module , a restriction evaluation module , a semantics module , an optimizer , and a code generation module . In some embodiments, the SQL compiler  also contains a query language rewrite module which manipulates the internal representation of an SQL statement to an equivalent but more efficient form. The SQL compiler  is coupled to a runtime manager module  which executes the output of the SQL compiler . The DBMS  is coupled to the database . The database  includes data  and a catalog . The catalog  includes dictionary functions and stores various schemas, mappings and other detailed information regarding the DBMS .","The parser module  receives SQL statements (queries) from clients  and information regarding the compilation environment (e.g. default schema name for any unqualified table reference(s)). When an SQL statement is received by the parser module , it converts the SQL statement into an internal compiler representation. The restriction evaluation module  evaluates any restrictions associated with the table(s) or view(s) referenced by the SQL statement. It then takes the relevant evaluated access restrictions to construct a dynamic pseudo-view representation of all of the restrictions. A pseudo-view is a view-like entity that includes the aggregate of the applicable column restrictions for the query in the select list, for example SELECT COL1, COL3 FROM T1, with all applicable row restrictions added to the definition via the WHERE clause in the form of joined (ANDed) predicates. The pseudo-view has the same or similar attributes as a predefined regular view, however it is dynamically created so does not exist in the catalog  and has no dependencies. The pseudo-view is not recognized for dependency recording or authorization purposes by the DBMS , however in other respects it would be handled by the SQL compiler  as a regular view definition. The pseudo-view definition text is translated to the internal representation format by the restriction evaluation module . These pseudo-view constructs are injected into the SQL statement representation immediately before the target object on which the restrictions are defined. The modified representation is then passed to the subsequent SQL compiler processing logic for normal processing. This means that normal query rewrite and optimization operations performed by the SQL Compiler  are not affected.","In some embodiments, views are stored by the SQL Compiler  as statement text and must be re-parsed by the semantics module  before injecting them into the internal representation. In other embodiments, views are stored in their internal representation and there is no need to re-parse the view definition text before adding them to the internal representation. The method by which normal view support is implemented determines whether the restriction evaluation module  has to produce an internal representation or can just provide the pseudo-view definition text.","Access restrictions that can be used to control access to the database  will be now explained. Access restrictions are defined in the database  for an object such as a table or view, for example a table T1 stored in the database . It will be apparent to those skilled in the art that the concept of an access restriction can also be applied to any object upon which a user could also define a normal view within an RDBMS. Typically, the access restrictions are stored in the catalog . Access restrictions defined within the database  on a specific table or view at either row or column level. Each restriction identifies the specific table or view which it affects, the specific actions which are affected by it, the level of restriction (either row or column), and the specific entities affected by the restriction (e.g. by authorization ID). For each access restriction, separate catalog entries are created. The aggregate of the applicable access restrictions for a particular table or view referenced by an SQL statement determines the data which can be accessed. Each subsequent restriction further restricts what is already restricted. It does not override what is already restricted.","Once access restrictions are defined on a table or view, any SQL statement that attempts to access that table or view will have the restrictions imposed on that access. Any changes to the access restrictions will result in the appropriate invalidations occurring to any static or cached dynamic SQL statements based on the appropriate information (for example restriction name, for DROP, or table name and type of access that the restriction affects, for CREATE). Exceptions to access restrictions may also be defined, for example, to allow a user or list of users with specific authorization ID(s) to bypass a-specific access restriction. Exceptions are defined within the database  on a specific access restriction Exceptions are stored in the catalog  and in addition to specifying the access restriction to which they apply, they also identify the entities to which the exception applies (i.e. which entities can bypass the specified access restriction).","Referring now to , a procedure  for implementing access restrictions to control access to the database  will be explained. In the first step , when a user of the DBMS  attempts to access a table or view using an SQL statement (e.g. INSERT, UPDATE, DELETE, MERGE, SELECT), the SQL compiler  receives the SQL statement and relevant compilation environment information (e.g. default schema name for use with any unqualified table reference(s)). Next, the parser module  breaks the SQL statement into components for compiling and converts them into an internal compiler representation (step ). For each reference to a table or view in the SQL statement, the restriction evaluation module  determines if any access restrictions have been defined (decision block ).","If no access restriction is defined, then the next reference is evaluated (decision block ). If an access restriction is defined, the restriction evaluation module  then determines whether the restriction applies to the present SQL statement (decision block step ). This decision is based upon a comparison between the restriction definition and the statement information with respect to the type of access being attempted and the entity (e.g. authorization ID) attempting the access. The access restriction applies to the SQL statement if the identified restriction matches the statements information.","If the restriction does not apply, then the next restriction is evaluated (decision block ). If the restriction does apply, the restriction evaluation module  then determines if an applicable exception has been defined for the present SQL statement (decision block ). Exceptions to the access restrictions allow the restrictions applicable to the particular table or view being referenced by the statement to be bypassed. However, access restrictions other than those specified by the exception(s) must still be obeyed by the SQL compiler . The use of exceptions allows global restrictions with limited exceptions to be easily defined upon a table or view (e.g. no one can read any data from this table except the person(s) granted the exception).","If an exception does apply, then the access restriction does not apply to the SQL statement and the next restriction is evaluated (decision block ). If an exception does not apply, then the access restriction applies to the SQL statement and must be enforced. Next, the restriction evaluation module  determines whether the restriction is a row or column restriction (decision block ). If the restriction is a column restriction, the access restriction is added to a column list (step ). If the restriction is a row restriction, then the access restriction is added to a predicate list (step ).","Once all access restrictions for a specific table or view reference have been evaluated, the restriction evaluation module  then constructs a dynamic pseudo-view definition using the column list and predicate list (step ). A pseudo-view definition may be of the following form:\n\n","Next, the restriction evaluation module  translates the dynamic pseudo-view definition into the internal format used by the SQL Compiler  and injects the result directly in front of the data object referenced in the original internal statement representation (step ). If there are other references to a table or view, steps  to  are repeated for each such reference (decision block ). Once all data object references have been evaluated for access restrictions and the resultant pseudo-view definitions, if any, injected into the internal statement representation, then normal SQL compiler processing continues (i.e. any query rewrite, semantics, optimization, and code generation modules are called) until it ends with the production of a section (step ). A section is a complied form of the SQL statement which is executable by the DBMS . A section contains the executable form of the optimized access plan for executing the SQL statement.","A partial pseudo-code implementation of an example embodiment of the present invention for a relational database management system (rDBMS) such as the DB2\u2122 product from IBM\u2122 will now be described.","Access restrictions are created using a CREATE RESTRICTION function defined in the catalog . A CREATE RESTRICTION statement creates either a column or row restriction on a table or view.\n\n","Examples 1 and 2 illustrate the operation of CREATE RESTRICTION statements.","CREATE RESTRICTION OWN_SALES\n\n","CREATE RESTRICTION PROTECT_SALARY\n\n","Access restrictions can be altered using an ALTER RESTRICTION function which would modify the contents of the catalogs . An ALTER RESTRICTION statement alters the restrictions and exceptions thereto for a column or row restriction on a table or view.",{"@attributes":{"id":"p-0048","num":"0083"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"An ALTER RESTRICTION statement may be defined as follows"},{"entry":"\u2003\u2003ALTER RESTRICTION <restriction name>"},{"entry":"\u2003\u2003\u2003\u2003ADD FOR <authorization name>"},{"entry":"\u2003\u2003\u2003\u2003DROP FOR <authorization name>"},{"entry":"\u2003\u2003\u2003\u2003ADD EXCEPTION FOR <authorization name>"},{"entry":"\u2003\u2003\u2003\u2003DROP EXCEPTION FOR <authorization name>"},{"entry":"\/*where"},{"entry":"<restriction name> is the name of the restriction to be altered."},{"entry":"The restriction name must be the same as a restriction name"},{"entry":"that already exists;"},{"entry":"ADD FOR <authorization name> adds the restriction for the"},{"entry":"specified authorization IDs. The authorization name lists one or"},{"entry":"more authorization IDs."},{"entry":"DROP FOR <authorization name> drops the restriction for"},{"entry":"the specified authorization IDs. The authorization name lists"},{"entry":"one or more authorization IDs."},{"entry":"ADD EXCEPTION FOR <authorization name> adds an exception"},{"entry":"to the restriction. The authorization name lists one or more authorization"},{"entry":"IDs. The restriction no longer applies for the specified"},{"entry":"authorization IDs."},{"entry":"DROP EXCEPTION FOR <authorization name> drops the exception"},{"entry":"to the restriction. The authorization name lists one or more"},{"entry":"authorization IDs. The restriction becomes applicable"},{"entry":"for the specified authorization IDs."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Examples 3 and 4 illustrate the operation of ALTER RESTRICTION statements.",{"@attributes":{"id":"p-0050","num":"0085"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ALTER RESTRICTION OWN_SALES"]},{"entry":[{},"\u2003DROP FOR LEE"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0051","num":"0086"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ALTER RESTRICTION PROTECT_SALARY"]},{"entry":[{},"\u2003ADD EXCEPTION FOR HAAS"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"In the foregoing implementation, the following conditions would apply: restriction name is a user-supplied name up to 128 bytes; authorization name is any valid form of authorization name such as one or more group names, user name, roles, or PUBLIC; column name is a list of one or more columns defined for the table or view; and search condition is a self-contained predicate list (e.g. WHERE clauses joined (ANDed) together).","Access restriction creation and alteration will now be further explained by way of examples 5 to 7 using a table t1. The table t1 is defined as follows:","CREATE TABLE t1 (col1 INTEGER, col2 CHAR(8), col3 INTEGER)",{"@attributes":{"id":"p-0055","num":"0090"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CREATE RESTRICTION r1"]},{"entry":[{},"\u2003TO COLUMNS (col1)"]},{"entry":[{},"\u2003RESTRICTING ALL ACCESS ON t1"]},{"entry":[{},"\u2003FOR PUBLIC"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"In this example, the restriction r2 is added. Restrictions r1 and r2 are both applicable. The restriction r2 is defined as follows:",{"@attributes":{"id":"p-0057","num":"0092"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CREATE RESTRICTION r2"]},{"entry":[{},"\u2003TO COLUMNS (col2, col3)"]},{"entry":[{},"\u2003RESTRICTING SELECT"]},{"entry":[{},"\u2003ON t1"]},{"entry":[{},"\u2003FOR GROUP ACCT, USER BOB"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"In this example, the restriction r3 is added. Restrictions r1, r2 and r3 are all applicable. The restriction r3 is defined as follows:",{"@attributes":{"id":"p-0059","num":"0094"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CREATE RESTRICTION r3"]},{"entry":[{},"\u2003TO ROWS WHERE (col2 = USER)"]},{"entry":[{},"\u2003RESTRICTING ALL PRIVILEGES"]},{"entry":[{},"\u2003ON t1"]},{"entry":[{},"\u2003FOR PUBLIC"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"If Fred were to be given access to all rows, the following exception would be defined:",{"@attributes":{"id":"p-0061","num":"0096"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ALTER RESTRICTION r3"]},{"entry":[{},"ADD EXCEPTION FOR FRED"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"Several different approaches for reuse or partial reuse of cached dynamic SQL statements having access restrictions may be used. According to one embodiment, partial reuse of cached dynamic SQL statements is provided by direct matching of relevant cached SQL statement information to determine that the exact same authorization information is in use as were in use for the cached query when it was compiled. An exemplary method of implementing partial reuse of cached dynamic SQL statements will now be described.","When an SQL statement is compiled, a dependency is added to the information gathered for that statement's compilation for every applicable restriction whether it is implemented or bypassed due to an exception. The dependency is added based on the restriction name and allows for specific invalidation of the final compiled SQL statement if the restriction is dropped or an exception to the restriction is added or dropped.","If a restriction or exception for a restriction for a specific user exists on any table or view referenced in the SQL statement, regardless of whether it is actually implemented into the section being compiled, then the specific user authorization ID that requested the compilation should be stored as part of the compilation environment used by the dynamic SQL caching logic to match user SQL queries. This value should be used to ensure that any future use of that cached SQL statement uses the same authorization ID; this would be enforced as part of the request matching logic implemented by the dynamic SQL cache mechanism. If the last user based restriction (of either row or column type) for a table is dropped, then all cached entries indicating that they were evaluated while user restrictions were in place should be invalidated. If the first user based restriction (of either type) for a table is added, then all cached entries indicating that they were evaluated while user restrictions were not in place should be invalidated.","If a restriction or exception for a restriction for a group exists on any table referenced in the SQL statement, regardless of whether it is actually implemented into the section being compiled, then the specific list of groups for the compiling user authorization ID should be stored as part of the compilation environment used by the dynamic SQL caching logic to match user SQL queries. This list should be used to ensure that any future use of that specific cached entry has the same list of group IDs. The entire list should be stored, as the section was evaluated on the whole group list, not just specific entries. A future user cannot assume that there is no restriction affecting them because they do not have the same group ID in their list for which the restriction was in place for the existing cached entry. If the last group based restriction (of either type) for a table is dropped, then all cached entries indicating that they were evaluated while group restrictions were in place should be invalidated. If the first group based restriction (of either type) for a table is added, then all cached entries indicating that they were evaluated while group restrictions were not in place should be invalidated.","If any additional or different authorization classifications are used, such as roles, then similar matching logic should be used.","The foregoing approach will not allow any incorrect reuse of cached dynamic SQL statements ensuring that access restrictions are enforced on all access attempts. However, it also prevents potential reuse of previously compiled SQL statements, referred to as cached SQL statements, when the relevant authorization information does not match exactly between the new request and the cached entry. Another possible approach to this problem of sharing cached SQL statements is to ensure that the list of restrictions that should be enforced are the same for the new user compared to the cached information.","According to another embodiment, cached dynamic SQL statements are reused by comparing restrictions that were implemented in a cached SQL statement and restrictions that apply to a new SQL query. The method includes the steps of storing access restrictions that are applied to cached SQL statements, determining which restrictions apply for the present SQL request, comparing the restrictions of the cached statement and the present SQL request, and if they match, the cached SQL statement can be reused. An exemplary implementing of this method will now be described.","When a SQL statement is compiled, a list of restriction names (A) that affect the resulting section is obtained. This list is independent of the dependency information. All restrictions for a table or view available are defined in a restriction packed descriptor (B) which can be cached for runtime performance reasons, for example in a catalog cache. When a request for the same SQL statement which matches the compilation environment of the cached dynamic SQL statement is received, the user authorization information associated with the new request is evaluated in the context of the set of cached restriction packed descriptors (there may be more than one object accessed by the cached entry) which have been identified as relevant by the cached entry to produce a list of applicable restrictions (C) and this list (C) is compared with the section list (A). If identical, the section can be used by the new user.","The above approach provides accurate reuse of cached dynamic SQL statements and may be performed at different times and intervals. When performed less often, for example only when first using a section or when restrictions change, any extra performance cost associated with comparing restrictions may be mortgaged over time resulting in minimal impact on system performance. Given the high overhead of compiling, the minimal impact created by evaluation of past and present access restrictions applicable to SQL queries has performance advantages if the possibility of sharing cached SQL statements exists.","For static SQL, the user authorization ID in use during the bind of the package is what is used in any applicable restriction. Dynamic SQL must be used to have the authorization ID of the person executing the package used in any applicable restriction.","When rerouting to a materialized query table (MQT), any applicable restriction on the base table will also apply to the data obtained from the MQT. If a restriction causes the ability to reroute to an MQT to fail, the query will simply access the base table for the result of the query.","The present invention provides a declarative process for easy creation and modification of access restrictions. Written procedures for defining access controls are not required. Further, access control is possible at the row and column level, and at least partial reuse of cached dynamic SQL statements is provided. The present invention may be used in most circumstances where a table or view may be applied, including most types of SQL statements. It can also be extended to apply to other data storage objects that act as access control points such as table nicknames used in federated systems.","Advantages of the present invention in its various embodiments include: there is no need for database application awareness of the restrictions and no application change is required; all users of the object (e.g. table or view) having restrictions defined thereon are affected by the restrictions regardless of how they access the object; all restrictions are defined and controlled from a central catalog definition and can be maintained on an individual basis; a restriction need only be defined once although it will affect many different sets of users; restrictions can be defined on any type of table or view; restrictions can be defined as affecting users at any granularity level, such as public, groups, roles, or individuals, or any combination of these; and exceptions to defined restrictions allows identified users to bypass specified restrictions.","Several variations of the present invention are known. For example, the authorization to access data in a table or view can be based on a number of factors including user authorization ID, group ID, department, role or another type of designation desired. In some embodiments, the restriction evaluation module  is included in the run time manager module  rather than the SQL compiler . In such cases, restriction evaluation would be incorporated into the section to produce a section \u201cneutral\u201d to the user authorization ID used to produce it but sensitive to the user authorization ID used to execute it. Restriction evaluation would be performed at runtime by the run time manager module . Runtime restriction evaluation reduces any impact on dynamic SQL caching caused by using access restrictions but increases the execution time of the runtime portion. In yet other embodiments, access restrictions are used to identify a row or column in table or view, the actions which are restricted, and the users that cannot access that row or column rather than the individuals or groups that can access that data. In these embodiments, access control may be implemented using negative logic in the pseudo-view definition and\/or conjunctive logic. In such cases, the complexity and ability of access restrictions is expanded by modifying how the pseudo-view definition is created. Access restrictions may also be used to deny access to a row indirectly by introducing a false predicate for the restriction (i.e. the restriction definition itself means that no row will qualify). For example, if a row restriction of \u201c1=0\u201d were applied to PUBLIC no user would get any rows back from the relevant table. Exceptions to the row restriction could then be created to allow selected users to access the rows.","The present invention may be embodied in other specific forms without departing from the spirit or essential characteristics thereof. Certain adaptations and modifications of the invention will be obvious to those skilled in the art. Therefore, the presently discussed embodiments are considered to be illustrative and not restrictive, the scope of the invention being indicated by the appended claims rather than the foregoing description, and all changes which come within the meaning and range of equivalency of the claims are therefore intended to be embraced therein."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Reference will now be made to the accompanying drawings which show, by way of example, embodiments of the present invention, and in which:",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
