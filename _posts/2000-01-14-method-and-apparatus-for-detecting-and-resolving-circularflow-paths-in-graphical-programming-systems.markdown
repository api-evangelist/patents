---
title: Method and apparatus for detecting and resolving circularflow paths in graphical programming systems
abstract: A system that detects and resolves circular paths within a graphical flow diagram that represents the logical operation of a corresponding application program. The flow diagram is formed by interconnecting symbolic representations that correspond to program objects configured to execute associated functions in response to corresponding triggering events. The functions of the program objects are called upon and executed by the application program at run-time. At the program objects, a busy indicator is established. When a program object is triggered by its respective event, the object first tests its busy indicator to determine whether it is already in the process of executing its associated function. If not, it proceeds to execute its associated function in response to an earlier triggering event. If, however, the object is already in the process of executing its associated function, then the object is blocked from re-executing in response to this new triggering event.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07082599&OS=07082599&RS=07082599
owner: Measurement Computing Corporation
number: 07082599
owner_city: Austin
owner_country: US
publication_date: 20000114
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF AN ILLUSTRATIVE EMBODIMENT"],"p":["This application is related to the following U.S. patent applications:","U.S. patent application Ser. No. 09\/483,123 entitled, A PROGRAM-DEVELOPMENT ENVIRONMENT FOR USE IN GENERATING APPLICATION PROGRAMS, filed Jan. 14, 2000, now U.S. Pat. No. 6,701,513 which issued on Mar. 2, 2004;","U.S. patent application Ser. No. 09\/483,760 entitled METHOD AND APPARATUS FOR RESOLVING DIVERGENT PATHS IN GRAPHICAL PROGRAMMING ENVIRONMENTS, filed Jan. 14, 2000, now U.S. Pat. No. 6,425,121 which issued on Jul. 23, 2002;","U.S. patent application Ser. No. 09\/483,122 entitled, REPEATING PROGRAM OBJECT FOR USE WITH A GRAPHICAL PROGRAM-DEVELOPMENT SYSTEM, filed Jan. 14, 2000, now U.S. Pat. No. 6,425,120 which issued on Jul. 23, 2002; and","U.S. patent application Ser. No. 09\/483,124 entitled, PROGRAM OBJECT FOR USE IN GENERATING APPLICATION PROGRAMS, filed Jan. 14, 2000, now U.S. Pat. No. 6,684,385 which issued on Jan. 27, 2004.","1. Field of the Invention","The present invention relates generally to the field of computer programming and, more specifically, to software development environments.","2. Background Information","To generate a software program that can be executed or run by a computer, a software developer or programmer typically chooses a programming language, such as BASIC (Beginner's All-purpose Symbolic Instruction Code), Fortran, C, etc., and writes source code using the keywords, syntax, variable names, data structures, etc. defined by the selected programming language. Each programming language typically defines its own unique syntax and keywords for performing various functions. After the source code has been written, it is typically converted by a compiler into a machine readable format that can be understood by the computer (e.g., object code). If the developer used incorrect keywords or syntax, the source code cannot by compiled successfully.","The source code is typically written with a text editor and organized into a series of lines of code. Although simple programs may only need a few lines of code, complex programs often consume hundreds, thousands or tens of thousands of lines of code. Significant portions of code, moreover, are often required just to generate displayable user interface images or forms, such as text boxes, command buttons, etc. that can be displayed by windows-based computer systems, such as personal computers running the Microsoft Windows\u00ae series of operating systems from Microsoft Corporation of Redmond, Wash. Furthermore, significant editing is often required to make even relatively minor adjustments to such user interface elements (e.g., moving, re-sizing, etc.).","In order to simplify the creation of such user interface images or forms, Microsoft developed and released a programming system known as Visual Basic\u00ae. Visual Basic includes a language engine for executing text-based programming statements, and a forms layout package having a plurality of objects or icons representing common user interface elements, such as text boxes, radio buttons, command buttons, scroll bars, etc. When a developer selects one of these objects from a tool palette and places it onto a form window, Visual Basic automatically creates corresponding code to support that object. By eliminating the need to write code just to display conventional interface elements, Visual Basic greatly simplified the creation of programs to be run on Windows-based platforms. These objects are typically stored in one or more dynamic link libraries (DLLs) that are loaded and run as necessary at application run-time. Since Visual Basic is an \u201copen\u201d programming languages, meaning that its syntax and command structures are known and available, third-parties have created and marketed a whole range of objects that can be added to a Visual Basic forms window to facilitate the creation of all sorts of different application programs.","With the release of Visual Basic 4.0, Microsoft extended Visual Basic to support software constructs that have certain object-oriented features by basing this release on its Component Object Model (COM). With Visual Basic 4.0, a new type of object, often referred to as a COM or ActiveX control or object was defined. A COM or ActiveX control is basically a component program object based on Microsoft's COM technologies, which can issue or raise events. With Visual Basic 4.0 and later releases, a developer similarly uses a forms layout package to drag and drop one or more ActiveX controls onto a form window. In addition, by double-clicking an ActiveX control on the form window, a code window is displayed. Inside this code window, the developer may insert text-based programming code to handle the events raised by the respective ActiveX control (i.e., an event handler). This code must comply with the syntactical and keyword constraints defined by Visual Basic in order for it to be properly executed at application run-time. By writing these event handlers, a developer can cause various ActiveX controls to share information and otherwise interact with each other greatly facilitating the creation of application programs.",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1","b":["100","100","102","104","104","106","108","104","102","106","110","102","112","102","110","112","110","114","100","144","116","110","112"]},"When this program is subsequently run, images for the vertical scroll bar  and the text label  will appear on the screen of the user as part of a user interface. The text label , moreover, will display the position of the vertical scroll bar  (e.g., \u201c2256\u201d). If the user moves the slider bar of the vertical scroll, the contents of text label change to display the scroll bar's new position (e.g., \u201c3891\u201d). As shown, with Visual Basic, the developer need not \u201cwrite\u201d any code to cause the vertical scroll bar image  or the text label image  to be displayed on the computer screen during run time. In addition, during the programming phase, the developer may move and re-size these user interface elements simply by manipulating their appearance on the Form window  (e.g., with a mouse) in a conventional manner. Due to the relative ease with which application programs having user interface elements can be created, Visual Basic has become a highly popular programming tool. However, in order to develop a meaningful application program (i.e., one in which there is some inter-relationship between the user interface elements), the developer must write, in a text-based format, one or more subroutines. Thus, the developer must learn and is limited by the syntax and keyword structures of Visual Basic.","In addition to Visual Basic and its related products (e.g., Visual C++, etc.), several companies have created software development tools that are almost entirely visually oriented. That is, using these tools, a developer can create an executable application program without having to write a single line of text-based code. For example, National Instruments Corporation of Austin, Tex. has created a programming tool called Lab-VIEW\u2122 for creating virtual instruments primarily for use in the instrumentation industry. Hewlett Packard Company of Palo Alto, Calif. has similarly created a programming tool called HP VEE for generating software programs for use in the electronic testing and data acquisition industries.","HP VEE provides a work area in which a developer can create a data flow diagram. The developer typically selects the objects for inclusion in his or her program from a pull-down menu. HP VEE provides a fixed number of these objects which have been tailored to provide functionality commonly used in the data acquisition industry. The developer may then \u201cdraw\u201d data lines between these objects in the work area. In response to drawing these lines, HP VEE creates program steps that transfer data or other information between the respective objects. The developer must perform all of this graphically within the work area.","Briefly, the invention relates to a system for detecting and resolving circular paths within a graphical flow diagram that represents the logical operation of an application program. The flow diagram is preferably formed by interconnecting a plurality of symbolic representations that correspond to program objects configured to execute associated functions in response to corresponding triggering events. The functions of the program objects are selectively called upon and executed by the application program at run-time. According to the invention, a busy indicator is established at a given program object. When the given program object is triggered by its corresponding event, the object tests its busy indicator to determine whether it is already in the process of executing its associated function in response to a previous triggering event. If the given program object is not currently executing, it proceeds to execute its associated function. If, however, testing of the busy indicator signifies that the given program is already in the process of executing its associated function, the object is blocked from executing in response to this subsequent triggering event. In this manner, circular paths defined within the flow diagram are ascribed a known and determinative implementation, thereby avoiding the generation of un-intended results by the application program and the possible overwhelming of the computer's resources.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 2","b":["200","210","214","218","212","216","214","210","200"]},"The I\/O circuitry  may be connected to a mass memory storage unit , such as a disk drive, via bi-directional bus . In the typical system , the memory storage unit  contains instructions that can be read by the CPU  in order to configure system  to provide the program-development features of the present invention. Cursor\/pointer control and input devices, such as a keyboard  and a mouse , connect to the I\/O circuitry  via cables  and , respectively. The mouse  typically contains at least one button or switch  that may be operated by a user of the computer system . A monitor  having a display screen  is also connected to the I\/O circuitry  via cable . A pointer or cursor  may be displayed on the screen  and its position can be controlled via the mouse  or the keyboard , as is well-known in the art. As described further herein, a window environment is displayed on the display screen  of the monitor . The window environment includes one or more windows . A speaker system  may also be connected to I\/O circuitry .","In general, the I\/O circuitry  receives information, such as control and data signals, from the mouse  and the keyboard , and provides that information to the CPU  for storage on the mass storage unit  or for display on the screen . The I\/O circuitry  preferably contains the necessary hardware, e.g., buffers and adapters, needed to interface with the mouse , the keyboard  and the display monitor .","A suitable computer system  for use with the present invention includes a personal computer, such as those manufactured and sold by International Business Machines Corp. of Armonk, N.Y., Compaq Computer Corp. of Houston, Tex. or Apple Computer, Inc. of Cupertino, Calif. The present invention may also be practiced in the context of other types of computers, including Unix-type workstations from Sun Microsystems, Inc. or Hewlett Packard. All of these computers have resident thereon, and are controlled and coordinated by, operating system software, such as Microsoft Windows\u00ae 95, 98 or NT, MAC OS or UNIX.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 3","FIG. 2"],"b":["200","302","304","200","302","302","200","302","306","302","302","306","235","232","200","308","308","235","232"]},"The lower-layers of the operating system  also include device drivers for interfacing directly with the computer hardware. For each physical device, such as the mass storage unit  (), a device driver is provided to accept requests, to read or write data or to determine the status of the devices. Communication between the physical devices and CPU  () may be effected either through polling of the device drivers or via interrupts.","In accordance with the present invention, a program-development environment  is also executing on the computer system . The program-development environment  includes an extensible visual programming system  and a graphical designer system . The visual programming system , in turn, may include an extensibility object , which provides an interface for communication between the programming system  and the graphical designer system  as indicated by arrows  and . Arrow  represents calls from the designer system  to the programming system , while arrow  represents calls from the programming system  to the designer system . Additionally, both the graphical designer system  and the visual programming system  may communicate directly with the operating system , e.g., exchange task commands and windows events, via API layer , as indicated by arrows \u2013.","In the illustrative embodiment, the extensible visual programming system  is Visual Basic 5.0 or higher (preferably 6.0) from Microsoft Corp., and the graphical designer system  is configured as a Visual Basic Add-In. Nonetheless, those skilled in the art will recognize that the present invention may also be advantageously used with other extensible visual programming systems, such as Visual C++, Visual J++, Visual Caf\u00e9, Visual InterDev, Delphi (for Pascal), etc. As described in more detail below, graphical designer system  allows the developer to switch the program-development environment  seamlessly between a graphical programming paradigm and a textual paradigm. The development environment  generates event handler procedures or program code for incorporation into the software program being developed, in response either to textual inputs or to graphical inputs from the developer.","To utilize the program-development environment , the developer first opens it in a conventional manner. For example, the development environment  may be represented by an icon on the user's desktop, which may be opened by \u201cclicking\u201d the icon using mouse button  () in a conventional manner. Alternatively or in addition, the development environment  may be listed as one of the available programs within a Programs folder of a Start menu or by using a Run command. The development environment  may be configured, upon opening, to launch the corresponding visual programming system  and graphical designer system .","Upon opening, the graphical design system  cooperates with the visual programming system  to present a unified and coherent graphical user interface (GUI) to the developer on display screen  of monitor .  shows a preferred representation of this GUI . The GUI  has several elements, including at least one toolbox  that contains a plurality of icons. Each icon represents a corresponding component control or program object class that is available for use by the developer in creating application programs. The application programs that are ultimately created by the development environment  can be considered component-oriented, since they, among other things, call upon class factories that allocate memory for object members and ensure that the respective class methods have been loaded. The GUI  further includes one or more form windows  and a designer window . The form window  represents a container application that can \u201chold\u201d instances of the control component or program object classes selected by the developer from the toolbox  for inclusion in the particular software program. By default, form window  includes a user form program object . The user form program object  basically provides an image of the user interface being developed for the application program. The GUI  may further include a menu bar  with a plurality of pull-down menu items and a toolbar  that is contains a plurality of buttons providing short-cuts to commonly used tasks or functions.","As described below, the designer window  is configured to display a corresponding symbol for each program object added to the form window . These symbols, moreover, may be graphically linked together in order to create a data flow or block diagram that logically represents the flow of data and\/or execution control of the application program that is being developed. The designer window  also includes its own toolbar , which may be divided into a plurality of sub-toolbars , each having a corresponding tab that may be labeled (e.g., Function, Core, User Interface, Data Acquisition, Math\/Logic and System). Disposed on each sub-toolbar are one or more icons. Each icon represents a corresponding control component or program object class, the symbolic representation of which may be caused to appear in the designer window .","Each control component or program object instantiated from a corresponding class represented by an icon on toolbox  and\/or toolbar  has pre-defined properties, methods and events. In addition, each program object typically performs some useful function, such as a Boolean operation (e.g., AND, OR, etc.), a mathematical operation, a data acquisition operation (typically from some transducer coupled to the I\/O circuitry  of the computer ), renders some comparison (e.g., less than, greater than, equal to, etc.), and so on. In the preferred embodiment, these control components or program objects are compatible with the ActiveX or Component Object Model (COM) technologies developed and made publicly available by Microsoft Corporation. The creation of ActiveX or COM objects is well-known to those skilled in the art and will not be described in detail here. For example, the creation of such objects is described in D. Appleman 6 (1999). The program objects and their classes may be stored in one or more dynamic link libraries (DLLs) within the memory  of the computer . The graphical designer system  and\/or the visual programming system  preferably includes a link (e.g., a pointer) to these DLLs so that the available program object classes may be displayed as icons on the tool-box  and on the designer toolbar .","The program objects intended for use with the program-development environment is  of the present invention are preferably pre-configured to have certain novel properties, methods and events. These additional properties, methods and events include the following:",{"@attributes":{"id":"p-0045","num":"0044"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"PROGRAM OBJECT PROPERTIES"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Name","Data Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["CancelBlock","Boolean","If set, prevents program object from"]},{"entry":[{},{},"executing or from completing execution of"]},{"entry":[{},{},"its function."]},{"entry":["ControlIn","Boolean","When used, controls when program object"]},{"entry":[{},{},"begins execution of its function."]},{"entry":["InvalidProperty","Integer","Invalidates an identified property of the"]},{"entry":[{},{},"program object in order to ensure orderly"]},{"entry":[{},{},"execution."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0046","num":"0045"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"PROGRAM OBJECT EVENTS"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["RunBlock","Occurs when program object is about to commence"]},{"entry":[{},"executing its corresponding function."]},{"entry":["InvalidateGroup","Occurs when program object is about to up-date one"]},{"entry":[{},"or more of its properties as a result of executing its"]},{"entry":[{},"corresponding function."]},{"entry":["DataReady","Occurs after program object has up-dated one or more"]},{"entry":[{},"of its properties as a result of executing its"]},{"entry":[{},"corresponding function."]},{"entry":["RateReady","Issued by program objects that perform scanning"]},{"entry":[{},"operations upon successful completion of a scan."]},{"entry":["StatusReady","For program objects that operate in one or more"]},{"entry":[{},"modes or states, this event occurs repeatedly while the"]},{"entry":[{},"program object executes its corresponding function."]},{"entry":["ControlOut","Occurs when program object has completed execution."]},{"entry":["ErrorOut","Occurs if program object generated an error during"]},{"entry":[{},"execution and may contain an identification of the type"]},{"entry":[{},"of error that was generated. It may also occur to"]},{"entry":[{},"indicate that no error condition was generated"]},{"entry":[{},"during execution."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"where Boolean means that the property may be set to True or False and Integer refers to any integer.","The GUI  may also include additional windows. For example, GUI  may include a project explorer window , which provides a hierarchical view of the current project. A project simply refers to the collection of files (e.g., form files, binary data files, class module files, etc.) and objects associated with the application program being developed. GUI  may also include a properties window  that displays the properties of a selected program object residing in the form window . The properties window  includes a pull-down object list , that contains a list of all of the program objects currently residing in the form window , and a property window , that is divided into two columns: a name column and a current value column . The name column identifies all of the properties associated with the program object selected in the object list , while the current value column shows the values that are currently associated with those properties.","To generate an application program, the developer selects one or more icons preferably from the designer toolbar  that perform requisite functionality for carrying out the tasks of the application program. In response, the program-development environment  places corresponding symbols in the designer window . The developer then graphically links these symbolic representations by drawing \u201cwires\u201d between them in order to create a data and\/or execution control flow diagram. He or she will typically do this by using the mouse  () or similar input device to cause the cursor  to move from one symbol to the next, although other graphical or even keyboard inputs may be used to perform the \u201cgraphical input\u201d. In response, the graphical designer system  of the program-development environment  generates an event handler procedure to be run as part of the application program being developed. In accordance with the invention, the development environment  also includes in the same resultant application program other event handlers, which the developer optionally specifies textually by entering commands and other information in a code window that the development environment  also provides on GUI . That is, the development environment  gives the developer the option of using textual inputs in order to specify event handlers that might otherwise be impossible or more difficult to represent graphically.","Suppose, for example, that the developer wishes to create a simple software program in which the position of a vertical scroll bar is displayed in a label. From the User Interface designer sub-toolbar , the developer first selects the vertical scroll bar icon . To select icon , the developer uses the mouse  () to position the pointer  over the vertical scroll bar icon  and activates (e.g., \u201cclicks\u201d) the mouse button . This mouse click is a conventional windows event that is received by the operating system  () in a conventional manner. Since the mouse click occurred over the designer window ; operating system  passes this window event to the graphical designer system  of the program-development environment  by a communication mechanism represented by arrow , and the designer system  treats the windows event as a selection of the vertical scroll bar class by the developer.","As shown in , in response to the selection of icon  from the User Interface designer toolbar , the graphical designer system  causes a symbolic representation  of the program object corresponding to the vertical scroll bar class to be displayed in the designer window . The designer system  also issues a call to the visual programming system  through its extensibility object  as represented by the communication mechanism of arrow . This call directs the visual programming system  to instantiate a program object from the vertical scroll bar class and add that program object to the container application represented by the form window . That is, form window  may maintain a linked list of pointers to program objects that are considered to \u201cbelong\u201d to the form, and in this list is placed a pointer to the vertical scroll bar program object that was instantiated. Since the vertical scroll bar is a user interface element, the visual programming system  also causes a vertical scroll bar image  to appear in the user form object . Vertical scroll bar image  basically corresponds to the way in which the vertical scroll bar user element will appear in the respective user interface at run-time of the application program being created. Vertical scroll bar image  may be moved and\/or re-sized by the developer in a conventional manner.","As part of the process of adding a program object to the form window , the visual programming system  also assigns a name to that program object. The name may consist of the object's class followed by an integer, e.g., VScrollBar1 for the first vertical scroll bar added to form window . The name uniquely identifies the program object within the form . Upon adding the program object to the form window , the visual programming system  preferably returns the assigned name to designer system  by a communication mechanism represented by arrow . The program-development environment  may then display a name as part of the symbolic representation  of the object in the designer window . The name displayed in designer window , e.g., Form1.VScrollBar1, may be derived by concatenating the name of the program object, e.g., VScrollBar1, with the name of the form window in which it resides, e.g., Form1.","As indicated, the symbolic representations appearing in designer window  are used by the developer to create a data and\/or execution control flow diagram that logically corresponds to the application program being developed. To facilitate the generation of such diagrams and the creation of corresponding event handlers by the program-development environment , each symbolic representation in designer window  preferably includes one or more terminals disposed about it. These terminals, moreover, are associated with some pre-defined combination of the properties, methods and\/or events of the respective program object that is symbolically represented. Vertical scroll bar , for example, has four terminals . In order to facilitate a generally left to right data flow direction and a top to bottom execution control flow direction, the terminals of all symbolic representations appearing within the designer window  preferably conform to the following general rules. Terminals on the left side of a given symbolic representation, such as terminal of vertical scroll bar , preferably correspond to a property used as an input by the respective program object. Terminals on the right side of a symbolic representation, such as terminal of vertical scroll bar , preferably correspond to (i) an optional property generated as an output and (ii) an event of the respective program object. Terminals on the top of a symbolic representation, such as terminal preferably correspond to a property which, when changed to a new value, triggers execution of the respective program object, and terminals on the bottom of a symbol, such as terminal of vertical scroll bar  preferably correspond to an event that occurs when the respective program object has completed execution of its respective function.","The vertical scroll bar program object, for example, has a plurality of pre-defined properties, methods and events. In particular, the properties of the vertical scroll bar program object include: Enabled, Height, Width, Minimum, Maximum, Value, etc. The methods associated with the vertical scroll bar program object include Move, Drag, SetFocus, ShowHelp, Refresh, etc. The events associated with the vertical scroll bar program object include RunBlock, DataReady, ControlOut, etc.","Terminal at symbol  is preferably associated with the vertical scroll bar's Value property. Terminal is associated with the scroll bar's ControlIn property. Terminal is associated with the vertical scroll's Value property and its DataReady event. Terminal is associated with the object's ControlOut event.","The association of properties and events to terminals is preferably maintained in a plurality of terminal data structures stored at memory  or . In particular, for each type or class of program object represented by an icon on the designer toolbar , there are one or more corresponding terminal data structures, depending on the number of terminals supported by the respective program object class.  is a highly schematic block diagram of a preferred terminal data structure . The terminal data structure  has at least four fields. A first field  preferably contains the name of the event, if any, that is associated with the particular terminal. A second field  preferably contains the name of the property, if any, that is associated with the particular terminal. If there is no event or property associated with the given terminal, then respective field  or  is set to null or de-asserted. A third field  preferably contains a code that identifies the particular type of terminal. In the illustrative embodiment, there are four types of terminals: data input, data output, control input and control output, and each type has a corresponding code. To the extent the data structure  corresponds to a data output type, a fourth field  is preferably used to store a group identifier. For a given type or program object class, the group identifier associates multiple data output type terminals whose corresponding properties are related to one another. For example, a joy stick object may have separate data output terminals for its \u201cx\u201d and \u201cy\u201d locations. Nevertheless, subsequent program objects should probably treat these two values as a single data point. Accordingly, the data output terminals associated with joy stick's \u201cx\u201d and \u201cy\u201d locations would preferably have the same group identifier. A fifth field  preferably contains a tool tip. A tool tip is a piece of descriptive text which is displayed to the developer when the cursor lingers over the respective terminal (e.g., \u201ccontrol input\u201d, \u201cerror output\u201d, and so on). The program-development environment  preferably maintains or otherwise has access to pointers to these various terminal data structures  within memory  () (e.g., as a linked list). The pointers, moreover, may be mapped by the program-development environment to the names of the corresponding object classes so that, given the name of some object class, the program-development environment  can access the terminal data structures for each control or program object that has been instantiated from that class.","Symbolic representations appearing in the designer window , including the terminals, are preferably generated by the program-development environment  from respective bit maps stored in one or more image files within memory  (). The program-development environment  preferably maintains an association of bit maps to icons on the designer toolbar  so that when a developer selects a particular icon, the program-development environment  can direct the window manager  to draw the corresponding image from the appropriate bit map. Symbolic representations can also be moved about the designer window  by dragging them around with the mouse .","The developer then selects the next program object or control for use in the application program being created. Suppose that the developer selects the label icon  () from the User Interface sub-toolbar . As shown in , the program-development environment , in response, causes a symbolic representation  of a label program object to appear in designer window . Symbolic representation  also includes a plurality of terminals . The program-development environment  additionally directs the visual programming system  to add a label program object to form window . Since the label program object is also a user interface element, like the vertical scroll bar, the visual programming system  additionally causes a label image  to be drawn on the user form object .","The label program object has its own pre-defined properties, methods and events. For example, the properties of the label program object include Height, Visible, Font, BackColor, Caption, ControlIn, CancelBlock, etc. Its events include RunBlock, ControlOut, etc. Data input terminal of symbol , moreover, is preferably associated with the label's Caption property. Terminal is associated with the ControlIn property, and terminal is associated with the ControlOut event. Note that symbol  does not have any data output terminals.","Generation of Event-Handler Code Through Graphical Inputs","At this point, the developer has two program objects residing in the form window . With the prior art systems, such as the Visual Basic\u00ae programming system from Microsoft Corporation, the developer would now have to write one or more textual event handlers in order to have the position of the vertical scroll bar displayed in the label. As described above, the need to learn the keywords and syntax governing such textual event handlers has been a drawback to the use of Visual Basic by non-programmers, including scientists and engineers. With the program-development environment  of the present invention, the developer may cause the development environment  to generate corresponding handler procedure by simply graphically linking the symbolic representations of the program objects in the designer window  with one or more novel wire constructs. The developer need not generate any text-based code at all. Unlike the prior-art systems that only enable the user to graphically provide event handlers, though, the program-development environment  of the present invention also affords the developer the ability to provide or modify event handlers textually. It thereby frees the developer of the constraints and limitations imposed by such prior-art graphical programming tools.","To cause the position of the vertical scroll bar image  to be displayed in the label image  at application run-time, the developer graphically links the symbolic representation  of the vertical scroll bar program object to the symbolic representation  of the label program object using a wire construct, rather than writing a textual event handler. To connect symbols ,  with a wire construct, the developer moves the cursor  () to terminal () at symbol  using the mouse . As described above, terminal is associated with both the DataReady event and the Value property of the respective vertical scroll bar program object, i.e., VScrollBar1, which resides on the form window . With the cursor  over terminal , the developer preferably executes a mouse click using mouse button . Since this mouse click occurred in the designer window , the operating system  () passes the respective windows event to the designer system  by the communications mechanism represented by arrow . In response, the designer system  directs the operating system  to switch the mouse  from \u201ccursor mode\u201d to \u201cline drawing mode\u201d through a call via arrow . In particular, designer system  directs the operating system  to modify the appearance of the cursor  and to begin tracing subsequent mouse  movement with a line, whose first end is anchored to terminal . Thus, as the developer drags the mouse  away from symbolic representation , a line emanates from terminal following the movement of the mouse .","The developer preferably extends this line to terminal of symbolic representation , which corresponds to label program object Label1 residing on form window . When the free end of this line reaches terminal , the developer preferably executes a second mouse click. Again, the corresponding windows event is passed by the operating system  to the designer system  and it, in response, causes the free end of the line to become attached to terminal . Designer system  also directs the operating system to stop tracing mouse movement with a line and to return the cursor  to its original appearance.  is an illustration of the GUI  with a wire construct  extending between the two symbolic representations , .","In response to graphically connecting or linking two symbols in the designer window , the program-development environment  creates event handler program code that sets the label object's Caption property to the value of the vertical scroll bar object's Value property when the vertical scroll bar object's DataReady event occurs. Clearly, there are several ways in which this can be accomplished. For example, Visual Basic code for handling the indicated event (e.g., DataReady) and affecting the designated property (e.g., Caption) could be generated and added to the application program, and that event handler program code could then be compiled or interpreted in the normal manner at run-time. Preferably, though, the program-development environment  instantiates a new control or program object, a wire program object, adds this new object to the form window  and sets its properties in a predetermined manner. The basic function of the wire program object is to retrieve the Value property from the vertical scroll bar object in response to the DataReady event and to set the Caption property of the label program object to that Value. That is, this new object basically provides event handler functionality for other program objects residing in the form window .","Specifically, the graphical designer system  directs the visual programming system  through calls to its extensibility object , as arrow  indicates, to instantiate a wire component control or program object from the wire object class and to add this object to the form window . That is, form window  adds a pointer to the wire program object to its linked list of controls. It should be understood that the wire construct  appearing in the designer window  is preferably just a symbolic representation of the wire program object added to the form window . The visual programming system  also assigns a name to this program object, e.g., Wire2, which it returns to the designer system . As described below, as part of its initialization procedure, designer system  preferably directs the visual programming system  to instantiate and add a wire program object, which may be named Wire1, to the form window . Thus, the \u201cfirst\u201d wire that is drawn on the designer window  by the developer actually corresponds to the second wire program object to be instantiated and added to the form window . Therefore, this wire program object is typically assigned the name Wire2.","The wire control or program object is itself a program module having its own predefined properties, methods and events. In the illustrative embodiment, each wire control or program object has the following properties, methods and events:",{"@attributes":{"id":"p-0067","num":"0066"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"WIRE CONTROL PROPERTIES"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Name","Data Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Name","Text","Specifies the name of the wire program"]},{"entry":[{},{},"object."]},{"entry":["Beep","Boolean","Determines whether the wire program"]},{"entry":[{},{},"object emits a \u201cclick\u201d sound whenever it is"]},{"entry":[{},{},"triggered."]},{"entry":["Cancel","Boolean","Determines whether the wire program"]},{"entry":[{},{},"object executes upon being triggered or"]},{"entry":[{},{},"invoked."]},{"entry":["Enabled","Boolean","Determines whether the wire program"]},{"entry":[{},{},"object executes in response to its"]},{"entry":[{},{},"triggering event."]},{"entry":["Index","Text","Distinguishes between two or more wire"]},{"entry":[{},{},"program objects having the same name."]},{"entry":["Left","Integer","Specifies the x-coordinate position of an"]},{"entry":[{},{},"image of the wire program object"]},{"entry":[{},{},"appearing on the user form object."]},{"entry":["OneShotEnabled","Boolean","If Enabled property is False, determines"]},{"entry":[{},{},"whether the wire program object should"]},{"entry":[{},{},"nonetheless execute one time."]},{"entry":["Sink","Text","The name of the sink program object and"]},{"entry":[{},{},"its respective property to which the wire"]},{"entry":[{},{},"program object is graphically connected."]},{"entry":["Source","Text","The name of the source program object"]},{"entry":[{},{},"and its respective property to which the"]},{"entry":[{},{},"wire program object is graphically"]},{"entry":[{},{},"connected"]},{"entry":["SourceGroup","Integer","Used to organize related properties"]},{"entry":[{},{},"of the source program object."]},{"entry":["Tag","Text","Assigns an additional identifier to the wire"]},{"entry":[{},{},"program object, typically for use by the"]},{"entry":[{},{},"application program."]},{"entry":["Top","Integer","Specifies the y-coordinate position of an"]},{"entry":[{},{},"image of the wire program object"]},{"entry":[{},{},"appearing on the user form object."]},{"entry":["Trigger","Text","The name of the program object and its"]},{"entry":[{},{},"respective event, the occurrence of which"]},{"entry":[{},{},"causes the wire program object to execute."]},{"entry":["Value","Variant","A data store, the contents of which can be"]},{"entry":[{},{},"copied from the source, modified, if"]},{"entry":[{},{},"desired, and passed to the sink by the wire"]},{"entry":[{},{},"program object."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0068","num":"0067"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"WIRE CONTROL METHODS"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["Run","Causes the wire program object to execute."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"WIRE CONTROL EVENTS"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Action(Value)","Occurs in response to the wire program being triggered"]},{"entry":[{},"or run. The argument corresponds to the current value"]},{"entry":[{},"of the wire's Value property prior to any event handling"]},{"entry":[{},"routines."]},{"entry":["Done","Occurs once the wire program object has finished"]},{"entry":[{},"propagating its Action event and setting the specified"]},{"entry":[{},"sink property, provided that the Cancel property is still"]},{"entry":[{},"false."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"where Boolean means that the property may be set to True or False, Text means that the property is an alpha-numeric string, Integer means that the property is an integer, and Variant means that the property can take any of the data formats specified by the corresponding variant structure definition.","After the visual programming system  has added the wire program object to the form window  and returned its name, the designer system  next sets the various properties of this wire program object. The wire's properties, moreover, may be displayed in the property window  () of property window , as indicated by rows , by selecting the wire program object, e.g., Wire2, from pull-down object list . The particular values to which the wire's properties are initially set depends on the particular program objects that have been logically connected by the wire construct  within designer window . For each wire control or program object, the designer system  identifies three corresponding program objects: a \u201csource\u201d program object, a \u201csink\u201d program object and a \u201ctrigger\u201d program object. Designer system  also examines the terminal data structures  that are associated with the graphically linked terminals and . Designer system  then uses this information to set the properties of the respective wire program object, i.e., Wire2.","It should be understood that attempts by the developer to wire a first input terminal to a second input terminal or a first output terminal to a second output terminal are rejected by the program-development system .","To identify the source, sink and trigger program objects, designer system  determines the names of the program objects that have been linked by the subject wire construct , the form window(s) on which those program objects reside, and the particular types of terminals that have been graphically linked by wire construct . As indicated above, information regarding the names of the graphically linked program objects and the form window(s) on which they reside is returned to the designer system  by the visual programming system  when system  adds those program objects to the form window . Thus, designer system  already has this information in its allocated portion of memory . Information regarding the types of terminals that have been linked is derived by the designer system  from the terminal type code fields  for the terminal type data structures  associated with the respective terminals, i.e., terminals and . The designer system  uses this terminal type information to determine which of the linked program objects should be considered the source object, which program object should be considered the sink object, and which program object should be considered the trigger object. In the preferred embodiment, the program object whose linked terminal is either a data output or control output type is treated as the source object, while the program object whose linked terminal is a data input or control input type is treated as the sink object. Here, linked terminal at symbolic representation  is a data output terminal, while terminal at symbolic representation  is a data input terminal. Thus, the designer system  considers the VScrollBar1 program object to be the source object and the Label1 program object to be the sink object for respective wire object, i.e., Wire2.","After identifying the source and sink control objects, the designer system  is ready to set the Sink, Source and Trigger properties , and of Wire2. The wire program object's Source property is preferably a concatenation of the following information: the name of the form window  on which the source program object resides, e.g., Form1, the name of the source program object, e.g., VScrollBar1, and the property associated with the linked terminal at the source program object, e.g., Value. The Source property may further be concatenated with the event associated with the linked terminal at the source program object, e.g., DataReady. The designer system  preferably obtains the source event and property parameters for use in setting the wire's Source property from the event field  and property field  from the terminal data structure  associated with linked terminal at the source program object, i.e., terminal . For data output type terminals, such as terminal , system  similarly obtains the SourceGroup property parameter from the group identifier field  from the corresponding terminal data structure .","The wire program object's Sink property is preferably a concatenation of the following information: the name of the form window  on which the sink program object resides, e.g., Form1, the name of the sink program object, e.g., Label1, and the property associated with the linked terminal at the sink program object, e.g., Caption. Again, the designer system  preferably obtains the sink property parameter from the property field  of the terminal data structure  associated with linked terminal at the sink program object, i.e., terminal . The wire program object's Trigger property is preferably a concatenation of the following information: the name of the form window  on which the source program object resides, e.g., Form1, the name of the source program object, e.g., VScrollBar1, and the event associated with the linked terminal at the source program object, e.g., DataReady. As described above in connection with setting the Source property, this information may be derived from the name of the source program object and also from the contents of the event field  of the terminal data structure  associated with linked terminal at the source program object, i.e., terminal . It should be understood that the designer system  may derive and set the Source property first and then strip off the specified property of the source (e.g., Value), which was obtained from field  of the corresponding terminal data structure , to set the Trigger property ","The wire program object preferably includes built-in functionality that automatically sets its Beep, Cancel and OneShotEnabled properties , and to FALSE, and its Enabled property to TRUE. The Value property is preferably set, at least initially, to null or is otherwise de-asserted.","In the preferred embodiment, wire program objects are not intended to appear in any of the user interfaces that may be generated at run-time of the application program being developed. Accordingly, the Left and Top properties ,  of all wire program objects, which specify where on the user form object  an image of the object should appear (and, hence, where on the run-time user interface those images should appear), are set to default values (e.g., \u201c20000\u201d) that are sufficiently high so as to \u201cplace\u201d the image of the wire program objects off of the user form object . Thus, at run-time, no image appears on the user interface corresponding to any wire program object that may nonetheless reside on the corresponding form window. Additionally, or alternatively, the wire object's Visible property may be set to FALSE.","Each wire program object instantiated and added to the form window  in response to graphical inputs of the developer includes at least some program code that may be called upon to execute when the respective application program is run. This program code, which is generated solely in response to the developer having graphically linked the symbolic representations of two program objects, basically causes the sink program object, e.g., Label1, to execute or otherwise take some action in response to an event generated by a trigger program object, e.g., VScrollBar1, and using some property of the source control object. That is, the wire object represents event handler procedures or code incorporated within the application program.",{"@attributes":{"id":"p-0078","num":"0077"},"figref":"FIGS. 6A and 6B","b":["310","442","442","602","604","442","606","442","608","442","442","606"],"i":["m","m","d ","d ","d ","d "]},"As indicated at block , the event handler procedure next retrieves the value of the property specified in the wire's Source property , e.g., Value, from the source object, e.g., VscrollBar1, also identified in the wire's Source property . To do this, a Get( ) method may be invoked on the source program object. A separate Get( ) method may be invoked for each readable property. The Get( ) method is a conventional method that is preferably supported by all of the component controls or program objects utilized by the program-development environment  of the present invention. As an argument to the Get( ) method, the code inserts the name of the property, e.g., Value, the value or setting of which is to be returned. Suppose the current setting of the VScrollBar1's Value property is \u201c15\u201d. Then, in response to the Get( ) method, the VScrollBar1 returns \u201c15\u201d to the wire program object. This value may be returned to the wire program object through either a Pass_By_Value or Pass_By_Reference communication method, both of which are well-known to those skilled in the art. The wire program object next copies this value, i.e., \u201c15\u201d to its own Value property , as indicated at block . Upon copying the value into its Value property the wire program object preferably issues its Action event, as indicated at block . Other elements or processes of the application program, including other component controls or program objects, may register as \u201cobservers\u201d with the wire program object using the Event_Advise_Notification method described above so as to be notified of the wire's Action event. These observers may respond to the wire's Action event in any number of ways. At decision block , the wire program object waits until all of these \u201cobservers\u201d have indicated that they have finished processing the wire's Action event.","Next, the wire program object queries whether its Cancel property () is FALSE, as indicated at block . As explained above, when the designer system  first sets the properties of a wire program object, it sets the Cancel property to FALSE. In response to the wire's Action event (or some other event), however, another process, control component or program object may change the wire's Cancel property from FALSE to TRUE. If the wire's Cancel property is TRUE, then execution stops as indicated by second end block . Assuming the wire's Cancel property is still FALSE, then the wire next up-dates the Sink property , i.e., Caption, with the current value of its own Value property , as indicated at block . This may be accomplished by invoking a Set( ) method on the sink control identified by the wire's Sink property , i.e., Label1. A separate Set( ) method may also be invoked for each settable property. The Set( ) method is another conventional method supported by all of the component controls or program objects utilized in the program-development environment  of the present invention.","After setting the sink's property, the code corresponding to the wire program object issues a Done event, as indicated at block . Observers may similarly register with the wire program object, again using the above-described Event_Advise_Notification method, so as to be notified of its Done event. These observers may be configured to take any number of different actions in response to the wire's Done event. At this point, the wire program object has finished executing as indicated by third end block .",{"@attributes":{"id":"p-0082","num":"0081"},"figref":"FIG. 7","b":["702","704","706","708"]},"Next, the program object determines whether its CancelBlock property is still FALSE as indicated at decision block . One or more of the observers could have set the program object's CancelBlock property to TRUE in response to processing the RunBlock event. If its CancelBlock property is still FALSE, the program object executes its corresponding functionality and up-dates its own corresponding properties as warranted as indicated by block . Upon up-dating its properties, the program object issues its DataReady event as indicated by block . To the extent a wire program object is connected to one of this program object's data output terminals, the issuance or occurrence of the DataReady event may trigger that wire program object to begin operation. After issuing its DataReady event, the program object next issues its ControlOut event as indicated by block . To the extent the program object's control output terminal is connected to a wire construct, the corresponding wire may begin operation. Execution of the program object is now complete as reflected by End block . If, in response to decision block , the program object's CancelBlock property is TRUE, then processing stops at that point as indicated by No arrow  leading from decision block  to End block .","It should be understood that a given program object may execute its corresponding functionality, as described at step , and then issue a RunBlock event, as described at step . This may be implemented by objects that perform mathematical operations, for example, and are thus less likely to cause erroneous data propagation problems in the corresponding application program. It should be further understood that, depending on the type of program object, other events besides DataReady may be issued. For example, program objects that operate in discrete or determinative modes or states, such as the For Loop, Do Loop and Wait objects, described below, or an Analog In Scan object, may issue one or more StatusReady events in place of the DataReady event. Program objects that perform scanning functions, such as Analog In Scan or Analog Out Scan, may issue a RateReady event in place of the DataReady event. Those skilled in the art, moreover, will recognize that other such events may be defined and implemented by the program objects utilized with the program-development environment .","Generation of Event-Handler Code Through Textual Inputs","A significant advantage of the present invention is its ability also to generate event handler procedures or code in response to textual inputs by the developer. In some circumstances, for example, it may be more efficient to specify an event handler textually rather than graphically. In particular, following the example of , suppose the developer wishes to have the background color of the label image  turn red during run-time whenever the value to be displayed exceeds 15000. Although the label object has a BackColor property, in the absence of a specific terminal on the corresponding symbolic representation  for the Label1 program object that is associated with this property, it would be difficult to specify this functionality graphically. Indeed, with the prior art graphical program languages, such as HP VEE and LabVIEW, it would be extremely difficult, if not impossible, to provide this functionality, because the graphical images for the label program object provided by these prior art systems do not have a terminal or pin for setting the object's background color in response to the value of its Caption property.","With the present invention, the program-development environment  allows the developer to switch to a textual programming paradigm in order to specify an event procedure or other functionality that is more easily described textually as opposed to graphically. To specify an event handler textually, the developer directs the program-development environment  to call-up and display a code window in which textual inputs may be entered by the developer. More specifically, the developer, using mouse , moves the cursor  () over the symbol of interest, e.g., Label symbol  (), as displayed in the designer window  and executes a double mouse click. Since the cursor  is over the designer window at the time of the mouse click, the operating system  () preferably passes the respective windows event to the graphical designer system . In response, the designer system  issues a call to the visual programming system , via arrow , causing it to display a code window on GUI  ().",{"@attributes":{"id":"p-0088","num":"0087"},"figref":["FIG. 8A","FIG. 4D"],"b":["400","800","800","802","404","802","800","804","802","804","804","800","806","806","224","806"]},{"@attributes":{"id":"p-0089","num":"0088"},"figref":"FIG. 8B","b":["400","808","806","800","804","808","312","808","438","808"],"i":["a\u2013g ","a\u2013g ","c\u2013g ","a\u2013b "]},"In response to entering one or more statements in the input area  of code window , the program-development environment  generates constituent program code for insertion in the corresponding application program. That is, at run-time, the statements are compiled or interpreted and executed as required, thereby implementing the functionality of the corresponding statements.","Those skilled in the art will understand that the code window  may be called-up in other ways. For example, the developer may choose the \u201cCode\u201d option (not shown) from the View command of menu bar .","It should be understood that a developer may also display and edit the properties of a wire program object, thereby causing the program-development environment  to modify the corresponding event handler procedure. As described above, the developer may cause the properties of a wire object, e.g., Wire2, to be displayed in the properties window  of GUI . By selecting one of the properties listed in the property window  of window , typically through a mouse click, the developer can edit the selected property. For example, although the wire program object preferably sets its Beep property to FALSE upon instantiation, the developer may re-set this property to TRUE through textual inputs entered in the property window . In response, the event-handler procedure generated by the program-development environment  causes the computer system  to sound a tone each time the wire program object executes.","The developer may also change a given wire object's trigger property to a different event and\/or a different program object. More specifically, as described above, the program-development environment  sets the trigger property of a wire program object based on the particular source terminal, e.g., terminal , to which the wire construct  of the corresponding wire program object, e.g., Wire2, is connected. The wire program object, moreover, executes in response to the occurrence of the event specified in its trigger property . By editing the trigger property , a developer may cause the program-development environment  to modify the corresponding event handler procedure such that the wire program object now executes in response to some newly identified event and\/or program object (e.g., an object other than the wire's source object). To prevent developer-induced errors, the program-development environment  may be configured to block the display (and thus the editing) of wire program object properties through property window .","Although the program development environment  of the present invention involves graphical event handler code generation, some implementations may not provide that capability for all available control components or program objects that may be incorporated into a given application program. Or, they may provide different toolbox icons or elements for the same control components, some of which enable the developer to program the control's event handlers graphically and others that do not. In such implementations, the toolbox  () may be divided into two areas. A first area contains a plurality of icons corresponding to program object classes that can only be used in the form window . The program objects corresponding to these icons do not have a corresponding symbolic representation for use in the designer window . A second area contains a plurality of icons that can be used in both the form window  and the designer window . That is, the program objects corresponding to these icons include symbolic representations capable of display in the designer window .","Detecting the Presence of Branches in the Data\/Control Flow Diagram and Ensuring Synchronous Execution of Program Objects at Run-Time","In creating the data\/control flow diagram within designer window  (), a developer may connect more than one wire construct to the same terminal of a given program object so that the same data or information may be provided to two different program objects in response to the same event. Similarly, the developer may connect two wire constructs to two separate but related or complementary output terminals of the same program object. The resulting data\/control flow diagram thus has a fork defining two or more \u201cbranches\u201d or \u201cstreams\u201d. If these two streams subsequently converge at some point downstream, e.g., some other program object, problems may arise if this downstream program object reacts (e.g., executes its associated function) in response to new data or information on only one stream.","More specifically, since many computer systems only include a single processor, the program steps corresponding to the branches must be executed in some order. That is, the steps of one branch are typically executed before the steps of another. Such serial execution can cause problems if a downstream object executes in response to new data or information from only one stream. That is, by executing when only part of its input data or properties have been up-dated, the program object and thus the application program in which it is incorporated may produce un-intended results. To avoid such problems, the program-development environment  of the present invention preferably includes a mechanism that causes such program objects to wait until the data or information from both streams has been up-dated before acting (e.g., executing its associated function).","In the illustrative embodiment, the wire program objects incorporated into an application program are further configured to detect the presence of such forks in the respective data\/control flow diagram, and to ensure that \u201cstale\u201d data or information is invalidated by the appropriate program objects. In general, an initialization process is run before run-time of the application. The initialization process determines which wire program objects are connected to the same output terminals of the same program objects and, therefore, exist at a fork in the data\/control flow diagram. The initialization process also identifies and informs those program objects that will be receiving control input information during run-time (i.e., those objects whose ControlIn properties may be changed).","At run-time, the wire program objects execute a branch-detection and data\/control flow coordination process. More specifically, when a wire program object is about to set the associated property of its corresponding sink program object, the wire first determines whether it exists at a fork of the data\/control flow diagram. If so, the wire program object causes its sink program object to first invalidate the current property that is about to be up-dated and directs all other wire program objects also located at the fork to do the same, and the sink objects cause the wire objects connected to their output terminals to invalidate their own sink objects and so on until the end of the flow diagram is reached. As a result, all of the program objects located downstream of the fork, invalidate the \u201cstale\u201d data currently associated with their data input terminals. After the downstream program objects have invalidated their input values, the wire program object then sets the sink property, thereby validating the sink property. Only when all of the data input terminals of the downstream program objects are validated do the program objects execute their associated functionality and up-date their output properties, thereby ensuring proper coordination.",{"@attributes":{"id":"p-0100","num":"0099"},"figref":["FIG. 9","FIG. 3"],"b":["400","310","900","406","900","902","904","906","908","910","912","904","906","902","912","404","914","916","902","918","906","920","916","902","922","904"]},"A third wire construct  connects a data output terminal  of the outdoor temperature symbol  to an \u201cx\u201d data input terminal  of the comparator symbol . A fourth wire construct  connects a data output terminal  of indoor temperature symbol  to a \u201cy\u201d data input terminal  of the comparator symbol . A fifth wire construct  connects a data output terminal  of comparator symbol  to a data input terminal  of the LED symbol . A sixth wire construct  also connects data output terminal  of comparator symbol  to a data input terminal  of the digital output symbol . Each wire construct , , , ,  and , moreover, corresponds to a wire program object residing on form window .","As shown, the data\/control flow diagram  includes several forks. In particular, a first fork exists at data output terminal  of button symbol  since both wire construct  and  are connected to this terminal. A second fork exists at data output terminal  of comparator symbol  since both wire construct  and  emanate from this terminal.","Furthermore, appearing within the user form program object  of GUI  are a button image , that has been labeled \u201cTake One Measurement\u201d, and an LED image  that has been labeled \u201cHeat Indicator\u201d.","In response to the developer having \u201cdrawn\u201d the wire constructs , , , ,  and , on the designer window , the program-development environment  generates corresponding event handler procedures or code in a manner as described above. The event handler procedures for wire constructs  and , for example, cause the indoor and outdoor temperature program objects of symbols ,  to acquire a temperature measurement in response to user selection of the button image , which measurements are then provided to the comparator program object of symbol . Preferably, however, the comparator program object of symbol  only executes when new temperature data has been received at both terminal  and terminal . If the comparator program object were to react when just one of its data input terminal  or  is up-dated (thus rendering the information associated with other data input terminal stale), it may be making an un-intended comparison. Since the program-development environment  () of the present invention may be running on a single processor computer system, such as computer  (), true parallel operation is not possible and thus only one of the data input terminals  or  will be up-dated at a time. To prevent such un-intended operating characteristics, the program-development environment  employs a novel synchronization process.","In particular, the program-development environment  preferably incorporates program instructions or code corresponding to one or more initialization processes into each application program that is developed. These initialization processes, which are executed at application run-time, first identify all wire program objects whose corresponding constructs reside at a fork of the corresponding data\/control flow diagram, e.g., diagram . To do this, the wire objects compare their respective source and SourceGroup properties , (). If two or more wire objects have the same Source and SourceGroup, then they are either connected to the same data output terminal and thus exist at a fork, or they are connected to different, but nonetheless related or complementary, output terminals of the same source object, and thus should be treated as if they exist at a fork.","Next, each wire program object invalidates its sink property to prevent unintended or spurious execution of the program objects of the application program. More specifically, each wire program object sets the InvalidProperty property of its sink program object, as identified in its respective sink property , to the particular identifier that is associated with the sink property. That is, each property of a program object, in addition to having a name and a value, also has an identifier, which may be a numeric or alpha-numeric string. Other program objects, including the wire program objects, can obtain these identifiers by querying the object (e.g., with a standard COM mechanism). In response to having its InvalidProperty set to the particular identifier for one of its properties, the corresponding sink program object sets a flag associated with the identified property to indicate that the value of this property is now invalid, and thus should not be used by the sink program object. In this way, program objects learn whether their control input terminals are connected to any wire constructs within the flow diagram, e.g., diagram  (). In other words, wire objects connected to control input terminals set the InvalidProperty of their sink objects to the identifier for the sink's ControlIn property. Thus, if a program object's InvalidProperty is set to the identifier for its ControlIn property, then the object \u201cknows\u201d that its control input terminal is connected to a wire construct, and that information may thus be received from this wire construct. At this point, the initialization process is preferably complete and the application program may be run.","It should be understood that the initialization process may also identify all root blocks within the data\/control flow diagram. A root block is any program object whose symbolic representation does not have a wire construct connected to either its data input or control input terminals. In addition, all variable program objects, which are described in detail below, are treated as root blocks even if one or more of their data or control input terminals are connected to corresponding wire constructs. In flow diagram  of , the object corresponding to command button symbol  is a root block. During run-time of the application program, data and\/or control flow typically begins at one or more of the root blocks of the corresponding flow diagram, and proceeds to flow down-stream of the root(s) (e.g., from source objects to sink objects). To identify the root block(s) of a flow diagram, the source and sink properties of each wire object may be examined. If a particular program object only appears as a source for one or more wire objects, and not as a sink for any wire object, then that program object is considered a root block.",{"@attributes":{"id":"p-0108","num":"0107"},"figref":["FIGS. 10A\u201310B","FIG. 9"],"b":["900","1002","1004","1006","1008","1009","1004","1008"]},"It should be understood that the program instructions or code that is incorporated into the application program is preferably configured such that steps \u2013 are completed at each of the downstream objects before resuming processing of (i.e., returning program control to) the wire object that was initially triggered and thus initiated the invalidation of the object input terminals.","Next, the wire object that was triggered in step  preferably runs its event handler procedure or code as indicated at block . This event handler procedure, which is generated by the program-development environment  and incorporated into the application program, preferably corresponds to the steps of  described above. Thus, the wire object sets the respective property of its sink object with the value of the property that the wire object retrieved from its source object. In response to having its data input property up-dated, the sink object preferably transitions the state of that property, which had previously been invalidated at step , to valid as indicated at block . Preferably, the sink object changes the flag associated with the up-dated property to valid.","In response to changing an input property from invalid to valid, the sink object next determines whether its control input terminal is connected to a wire construct as indicated by decision block  (). If it is, the sink object then determines whether or not the value of its ControlIn property has been changed (e.g., toggled) as indicated by Yes arrow  leading to decision block . That is, the sink object, which may maintain a particular flag for this purpose, determines whether or not its ControlIn property has been changed. If not, the sink object preferably returns program control to the previous wire or other program object as indicated by No arrow  leading to end block . Alternatively, the sink object may run a wait loop at decision block . If the sink object's ControlIn property has been toggled, it then determines whether all of its data input terminals are valid as indicated by Yes arrow  leading to decision block . If one or more input properties are still invalid, the sink object may wait until the remaining data input terminals are validated or, in the preferred embodiment, return program control to the previous wire or other program object as reflected by No arrow  to end block .","If the sink object's control input terminal is not connected to a wire construct, then processing moves from decision block  directly to block , by-passing block , as shown by No arrow .","If (or when) all of the sink object's data input terminals are valid, the sink object proceeds to execute its associated function as indicated at block . Execution of the sink object preferably proceeds as described above in connection with . Thus, the sink object up-dates the properties associated with its data output terminals and issues its DataReady event. This DataReady event is typically a triggering event for any wire object whose construct is connected to a data output terminal of this sink object. Accordingly, this wire object and its sink property proceed to execute the steps of \u2013. That is, this process is repeated by the remaining wire and program objects downstream of the fork, thereby ensuring that the program objects do not execute their particular functions until all of their data input terminals have received valid data and their control input terminals, if connected, have been triggered.","For example, consider operation of the program object for the comparator symbol  () of flow diagram . At run-time, a user interface corresponding to user form program object  is displayed on screen  () of computer  to the end user. When the end user selects (e.g., mouse clicks) the command button image , the corresponding program object issues its DataReady event, which is the triggering event for the wire objects of constructs  and . As described above with steps  and  (), whichever wire object first processes this DataReady event will set its sink property to invalid and direct the other wire object to do the same. The invalidation of data input terminals propagates throughout the flow diagram  as described above with steps  and . As a result, the \u201cx\u201d input property of terminal  and the \u201cy\u201d input property of terminal  at comparator  are invalidated. The wire objects of constructs  and  then process the DataReady event, thereby causing the objects of indoor and outdoor temperature symbols ,  to take a temperature measurement and pass these measurements via wire constructs ,  to the data input terminals ,  of comparator .","As each respective property at comparator  is up-dated with the new temperature measurement, comparator  changes the state of the property from invalid to valid as indicated by step  () described above. Since comparator  does not have a wire construct connected to its control input terminal, it simply waits until both of its data input terminals ,  have been up-dated (and thus validated) before executing, as indicated by blocks  and  (). That is, as each data input terminal is up-dated and transitioned to the valid state, comparator  determines whether all of its other data input terminals are valid. Only after the last data input terminal is up-dated and validated does the object run its comparison function, provide an output on terminal  and issues its DataReady event. As shown, the branch detection mechanism of the present invention prevents objects, such as comparator , from executing their respective functions until all of their data input terminals have been up-dated. Accordingly, the branch detection mechanism avoids the generation of un-intended results by the application program.","It should be understood that object properties associated with data input terminals that are not connected to any wire constructs preferably remain valid at all times.","Recursion Blocking Mechanism","In some programming situations, the developer may wish to create a data\/control flow diagram having one or more circular paths. Such circular paths typically represent corresponding loop-back or feed-back conditions within the data\/control flow diagram. Unless they are handled in a consistent and known manner, such loop-back or feed-back conditions can cause unintended consequences or results during execution of the corresponding application program. In addition, if left un-detected, circular paths, can also consume substantial computer resources, such as CPU and memory resources, even to the point of overwhelming the system. According to the present invention, a method is provided for efficiently handling circular paths specified within the data\/control flow diagram.",{"@attributes":{"id":"p-0119","num":"0118"},"figref":["FIG. 11","FIG. 3","FIG. 2","FIGS. 4A\u20134D"],"b":["1100","310","235","400","406","1102","1102","1104","1106","1108","1104","1108","1110","1112","1104","1114","1106","1116","1118","1106","1120","1108","1122","1124","1108","1126","1104","1102","408","404","1128","1130","1132","1104","1108"]},"Without some mechanism for handling the circular path of flow diagram , running of the corresponding application program may overload the computer's processing and memory resources. More specifically, suppose an end-user were to run the application and enter some information, e.g., \u201chello\u201d, into a user interface element (not shown) corresponding to image . As described above, the program object for symbol  would issue its DataReady event indicating the presence of new data associated with its data output terminal . In response, the program object for wire construct  passes this information to the object of symbol . The program object of symbol , in turn, issues its DataReady event causing wire construct  to pass the information to the object of symbol . The program object of symbol  then issues its DataReady event causing wire construct  to return the information to the object of symbol , thereby completing the circle. The object of symbol  assumes that it has just received \u201cnew\u201d data and, in response, issues its DataReady event, repeating the cycle described above until the computer's resources are eventually exhausted.","To avoid this problem, the program-development environment  of the present invention includes a novel method for efficiently handling circular paths specified within the data\/control flow diagram.  is a flow diagram of the preferred steps of the method that are preferably performed by each program object represented in the flow diagram. First, the object initializes a \u201cbusy\u201d indicator to some pre-determined value, as indicated at step . In the illustrated embodiment, the busy indicator is a counter that may be initialized to \u201c0\u201d. Specifically, each program object that is represented by a symbolic representation within a given flow diagram preferably establishes a busy counter (not shown) within memory  (). Next, the object waits to be triggered as indicated by decision block  which has a No arrow  that loops back on itself. As described above in connection with step  of , an object is triggered when one or more of its properties is up-dated typically by a connected wire object.","When the program object is triggered, it first increments the busy indicator (e.g., the counter), preferably by \u201c1\u201d, as indicated by block . The object then determines whether the value of its busy counter exceeds some predetermined threshold as indicated by decision block . In the preferred embodiment, the threshold is set to \u201c1\u201d. If the busy counter does not exceed the threshold, the object then executes its respective function as indicated by No arrow  leading to block , which preferably corresponds to steps \u2013 of  described above. That is, the object places its output data on its data output terminal and issues its DataReady and its ControlOut events. As described above, other objects, such as wire program objects, may respond to the DataReady and ControlOut events. As indicated at decision block  and No arrow  which loops back to block , the object waits until such \u201cobservers\u201d have returned from the DataReady and Control out events.","Specifically, upon issuing its DataReady event, program control (e.g., processing by the CPU  () shifts from executing the steps of the program object to executing the steps corresponding to the event handler procedure that is triggered by the object's DataReady event. When this event handler procedure is finished, program control then returns to the object so that its execution may be completed. So that program control may be returned to the appropriate location within the steps corresponding to the program object, a pointer to the location is typically pushed onto a stack within memory  (). When the event handler procedure or code has finished executing, this pointer is popped off of the stack and processing resumes at the appropriate location. As described above, execution of the event handler procedure or code may result in the issuance of one or more events (e.g., Action, Done, etc.) and it may be interrupted so that program instructions or code triggered by these events may be executed.","When the observers return from the object's DataReady and ControlOut events, the object then decrements its busy counter, preferably by \u201c1\u201d, as indicated by Yes arrow  leading to block . Upon decrementing the busy counter, processing is complete as indicated by End block .","Referring again to step  in which the busy indicator is tested, if the value of the busy indicator exceeds the threshold, then the object does not execute and, instead, simply decrements its busy counter, as indicated by Yes arrow  leading from decision block  to block . That is, if the busy indicator returns a busy indication, then execution of the corresponding object is by-passed (e.g., the object is short-circuited) and the object simply decrements its busy indicator. As described above, upon decrementing the busy counter, processing by the object is complete as indicated by End block . To avoid conflicts between the incrementing and testing of the busy indicator, the steps of blocks  and , are preferably performed by the computer system  () as an atomic operation. An atomic operation refers to some unitary action that is essentially indivisible (i.e., the steps are not interrupted). Those skilled in the art to which the present invention pertains are aware of techniques for ensuring that particular programming instructions or steps are treated as atomic operations.","For computer systems that support multiple threads, semaphores may be used to prevent a given object that was triggered by a first thread from being re-triggered by a different thread. Semaphores are well-known techniques for coordinating or synchronizing activities.","Returning to the example of , when information, e.g., \u201chello\u201d, is entered by the end user into the user interface element of image , the object of symbol , which corresponds to this user interface element, executes the steps of . In particular, the entry of information triggers the object as indicated by step . Accordingly, the object increments its busy counter, which was initialized to \u201c0\u201d at step , by \u201c1\u201d so that its busy counter is now set to \u201c1\u201d. Since the value of the busy counter does not exceed the threshold of \u201c1\u201d, the object of symbol  executes its functionality as indicated by steps  and . In particular, the object places the newly entered information on its data output terminal  and issues its DataReady event. The wire object of construct  responds to the DataReady event and passes this information to the data input terminal  of the object of symbol . As described above, this information is eventually returned to the object of symbol  at its data input terminal  by wire construct .","In response, the object of symbol  assumes it has been triggered, as indicated at step , and thus increments its busy counter (again by \u201c1\u201d) and tests it, as indicated at steps  and . Since the busy counter is now at \u201c2\u201d, exceeding the threshold of \u201c1\u201d, the object decrements the counter as indicated by Yes arrow  leading to step , instead of executing again as might otherwise occur without the recursion or reentry blocking mechanism of the present invention. As a result, program control returns first to the object of wire construct  so that it may complete its execution, and then to the object of image  so that it may complete its execution. Program control similar returns to wire construct , and then to object . Eventually, program control returns to the wire object of construct , which completes its execution, thereby returning control to the object of symbol  following the issuance of its DataReady event. In other words, the result of decision block  is now yes, and thus the object of symbol  can decrement its busy counter from \u201c1\u201d back to zero. As shown, with the method of the present invention, the re-triggering of the object of symbol  (i.e., triggering before the object has completed execution from an earlier triggering) does not result in an overloading of the processing or memory resources of the computer  ().","It should be understood that the steps of  may be executed by each of the wire program object's of the respective flow diagram as well.","Symbolic Representations for Repeating Steps","When creating application programs, developers often include certain programming steps that are to be repeated many times. Rather than entering such steps over and over again, many programming languages include command structures that automatically repeat certain identified steps. For example, with Visual Basic from Microsoft, developers can enter specific keyword commands within the code window to repeat certain statements. In particular, Visual Basic allows developers to create what are known as Do Loops and For Loops. A Do Loop executes certain code over and over again until some condition is met. Typically, the syntax of a Do Loop appears as follows:","Do","[statements]","Loop Until\/While condition.","where \u201c[statements]\u201d are the particular code statements that are to be repeated and condition refers to the condition that stops the loop. A Loop Until condition checks the condition after running through the loop and repeats only if the condition is FALSE. A Loop While condition also checks the condition after running through the loop but repeats only if the condition is TRUE. Do Loops may also be configured to check the condition before entering the loop.","A For Loop is used when the developer knows precisely how many times the loop should repeat. Unlike a Do Loop, a For Loop uses a variable called a counter that increases or decreases in value during each repetition of the loop. The syntax of a For Loop typically appears as follows:","For counter=start To end [Step increment]\n\n","Next [counter]","When executing the For Loop, the application program sets the counter equal to the specified start value and tests to see whether the counter is greater than the specified end value. If so, the loop is exited. If not, the statements are executed and the counter is incremented by the specified increment value (or by \u201c1\u201d if no value was specified). The loop then repeats again checking to see if the counter has surpassed the end value (in either direction).","According to the present invention, the program-development environment  () is further configured to incorporate program code within the application program being developed that repeats certain statements or steps (i.e., the program includes loop structures) in response to graphical, as opposed to textual, inputs from the developer. In particular, as described below, the program-development environment  includes a plurality of program objects having corresponding symbolic representations that may be caused to appear in the designer window  of the GUI . These symbolic representations may be connected with other symbols within the designer window  using one or more wire constructs in order to define a loop. However, in order to present a simplified and refined flow diagram within the designer window, the loop preferably appears as an acyclic branch of the flow diagram. That is, although the branch terminates (i.e., there is no wire construct from the end of the branch back to the main flow diagram), it nonetheless is repeatedly executed at application run-time. At the end of the branch may be a Break symbol as described below.",{"@attributes":{"id":"p-0141","num":"0141"},"figref":["FIG. 13","FIG. 3","FIG. 4A"],"b":["1300","310","235","400","414","406","414"],"i":["b ","a "]},"Within the designer window  are preferred symbolic representations of several program objects corresponding to icons of Core sub-toolbar each having one or more terminals for connecting one or more wire constructs. A For Loop symbol , for example, includes a start index data input terminal , an end index data input terminal , a step value data input terminal , a control input terminal , a loop index data output terminal , an error data output terminal and a control output terminal . The For Loop object of symbol  preferably incorporates the ControlOut, DataReady, ErrorOut and RunBlock events described above. The For Loop object of symbol  basically runs a branch of the flow diagram connected to its loop index output terminal repeatedly until the end index specified at input terminal is reached. In particular, starting with the start index specified at input terminal , which can be initialized to \u201c0\u201d each time the respective application program starts-up, the For Loop object issues its DataReady event and outputs the current loop index value from terminal (e.g., 1, 2, 3, etc.) using the step value specified at terminal (e.g., 1) to count up (or down) to the end index specified at terminal ","A Do Loop symbol  preferably includes a control input terminal , a loop index data output terminal , an error data output terminal and a control output terminal . The Do Loop object also incorporates the ControlOut, DataReady, ErrorOut and RunBlock events. The Do Loop object of symbol  basically runs a branch of the flow diagram connected to its loop index output terminal repeatedly until some condition, which is preferably specified graphically by one or more symbols connected to a Break symbol, which is described below, is met. In particular, with its loop index property preferably initialized to \u201c0\u201d each time the respective application program starts-up, the Do Loop object repeatedly issues its DataReady event and outputs its loop index value from terminal until the graphically specified condition is met and the Do Loop object is stopped.","A Timer symbol  preferably includes an interval data input terminal , a frequency input terminal , a control input terminal , a loop index data output terminal , an error data output terminal and a control output terminal . Like the Do Loop object, the Timer object of symbol  also runs a branch of the flow diagram connected to its loop index output terminal repeatedly until some specified condition is met. In particular, with its loop index property preferably initialized to \u201c0\u201d each time the respective application program starts-up, the Timer object issues its DataReady event and outputs its loop index value from terminal each time the value specified at its interval data input terminal (which may be in milliseconds) elapses. The Timer object then preferably increments its loop index property by \u201c1\u201d. The value specified at the frequency data input terminal preferably specifies the number of timer events per second.","A Break symbol  preferably has a control input terminal . As indicated above, a Break object is used to stop execution of a corresponding loop object (e.g., Do Loop, For Loop or Timer objects) upon satisfaction of some specified condition. The Break object preferably terminates the execution of the first up-stream loop object to which the symbolic representation  of the given Break object is connected when its control input property is triggered (e.g., changed). For example, a Break object can be used to stop execution of a loop when a particular value generated during the loop sequence exceeds some threshold. In this case, the control input terminal  of a Break object  may be connected to the data output terminal of a symbol whose corresponding object compares two values and outputs a TRUE indication on the connected data output terminal if the first value (the value generated within the loop sequence) is greater than the second value (the threshold). This loop will continue to run until the value exceeds the threshold. At this point, the comparison symbol will output a TRUE indication that is provided to the Break symbol by a corresponding wire construct. Upon having its control input property triggered, the Break object stops execution of the first up-stream loop object (i.e., Do Loop, For Loop or Timer objects).","The properties (or at least those properties that are declared public and thus may be changed by a developer) of the For Loop, Do Loop, Timer, and Break objects may each be selectively displayed by the program-development environment  () in the properties window  by selecting the desired object from the pull-down object list . The specific properties displayed within the corresponding properties window , moreover, may be modified and edited by the developer, thereby changing the properties of the respective object residing in the form window .","The use of the loop symbols and corresponding objects may best be understood through an example.  are preferred representations of a GUI having a flow diagram incorporating a loop. Suppose that a developer wishes to create an application (or a process thereof) for summing a sequence of numbers and stopping if the sum exceeds some specified value. Using the icons of designer toolbar , the developer preferably creates a data\/control flow diagram within the designer window  of the GUI  for performing such steps.",{"@attributes":{"id":"p-0148","num":"0148"},"figref":"FIGS. 14A\u2013D","b":["1400","400","406","1400","1402","1402","404","1404","1406","1408","1410","1410","1412","1414","1416","1418","1420","1422","1422","1422","1422","1402","1424","1426","1426","1426","1424","1426"],"i":["a ","b","a","b","c ","d","a","b","c ","d "]},"Flow diagram  further includes a text box symbol  having a data output terminal , and a variable symbol  having data input, control input, data output, error output and control output terminals . A Variable symbol, such as symbol , is typically used to read a new value on its data input terminal and, upon triggering of its ControlIn property (provided its control input terminal is wired) to pass that value to its data output terminal and issue a DataReady event. Thus, variable objects can save a data value for later use by the application program. Flow diagram  further includes a Break symbol  having a control input terminal . In response to adding the command button, labels and text box symbols , ,  and , which are all user interface components, the program-development environment  () places corresponding button, labels and text box images , , , and , respectively, in the user form program object  of the form window .","The symbolic representations within the designer window  are also interconnected by a plurality of wire constructs, thereby forming the data\/control flow diagram  of the corresponding application program. In particular, the data output terminal  of command button symbol  is connected to the control input terminal of For Loop  by a first wire construct . Loop index output terminal of For Loop  is connected to the data input terminal  of first label  by a second wire construct , and also to the \u201cx\u201d data input terminal of the addition symbol  by a third wire construct . Data output terminal at addition symbol  is connected to the data input terminal  of second label  by a fourth wire construct , to the \u201cx\u201d data input terminal of comparator  by a fifth wire construct , and to the data input terminal of variable  by a sixth wire construct .","The control output terminal of addition symbol  is connected to the control input terminal of variable  by a seventh wire construct , and the data output terminal of variable  is connected to the \u201cy\u201d data input terminal of the addition symbol  by an eighth wire construct . A ninth wire construct  connects the data output terminal  of text box  to the \u201cy\u201d data input terminal at the comparator . The TRUE data output terminal of comparator  is connected to the control input terminal  of the Break symbol  by a tenth wire construct .","The step value, end index and start index input terminals of For Loop  are not connected to any wire constructs. Nonetheless, the developer may edit the values for any of these properties prior to running the application program. To edit an object's properties, the developer may display the properties of the selected program object in the properties window  in the manner described above. The program-development environment , however, preferably supports at least one or more additional ways of editing an object's properties. In particular, as shown in , when the developer executes a \u201cright mouse click\u201d on a selected symbol, such as For Loop symbol , the program-development environment  causes a command pop-up menu  to appear on GUI . Command window  displays a series of commands that may be performed on the selected object symbol, e.g., For Loop . One of these commands is a Properties command .","As shown in , by selecting (e.g., clicking) the properties command  (), the developer causes the program development environment  to display a properties page dialog window  on GUI  for the For Loop . This properties page dialog window  includes a plurality of entry fields, such as start index field , an end index field and a step size field , for reviewing and editing one or more properties of the For Loop. Properties page dialog window  also includes OK, Cancel and Apply command buttons , respectively, for use in accepting, canceling and applying the values specified in fields to the respective object, e.g., For Loop . For example, the developer may set the start index of field to \u201c0\u201d, the end index to \u201c9\u201d, and the step size to \u201c1\u201d. He or she may alternatively accept the default values specified in one or more of these fields. It should be understood that these values are for illustrative purposes only.","Next, the developer may set the properties of the variable object of symbol . That is, the developer may \u201cright-click\u201d symbol  () causing the program-development environment  to display a command pop-up menu (not shown) for the variable object. The developer may then select the properties command from this pop-up menu. As shown in , the program-development environment  responds by displaying a properties dialog window  for the variable object. Properties dialog window  has only an initial value field , which the developer may set to an initial value of \u201c1\u201d. As shown, the properties displayed in the corresponding properties dialog windows for various program objects may be some sub-set of the properties defined by the respective object, rather than the entire set of properties for the object. This prevents developers from inadvertently editing certain object properties that may produce un-intended consequences during application run-time. Indeed, in a preferred embodiment of the present invention, the program-development environment  may suppress the display of properties window , and limit the editing of object properties through the respective dialog windows.","At this point, the developer is done and the application program may be run. Referring to , at run-time, a user interface similar to user form program object  is displayed on the screen of the computer. The end user may enter some limit number (e.g., \u201c12\u201d) in the text box  and then, to get the program going, \u201cpress\u201d the command button  (e.g., with a mouse click). This causes wire construct  to toggle the ControlIn property of the For Loop  causing it to place its first loop index (e.g., \u201c0\u201d) on its data output terminal and issue its DataReady event. In response, wire constructs  and  pass this index value to first label , and to the \u201cx\u201d input of addition symbol . The addition symbol  adds this \u201cx\u201d value to its \u201cy\u201d value, which may, by default, initially be set to \u201c0\u201d, places the sum on its data output terminal and issues its DataReady event. Wire constructs ,  and  respond to the addition symbol's DataReady event by passing the sum to second label , comparator  and variable , respectively. Addition symbol  then issues its Control Out event, which causes wire construct  to toggle the ControlIn property of variable . In response, variable  passes the sum received at its data input terminal to its data output terminal and issues its DataReady event. Wire construct , in turn, passes the data output value from variable  to the \u201cy\u201d data input terminal of addition symbol .","Before running its function again, addition symbol  waits for new data on its \u201cx\u201d data input terminal (e.g., the next loop index value). When the next loop index value (e.g., \u201c1\u201d) is received at the addition symbol , it adds the two values together and places the new sum on its data output terminal . These steps are repeated for each new \u201cx\u201d and \u201cy\u201d input received at the addition symbol . Meanwhile, the comparator symbol  is determining whether any sum from addition symbol  exceeds the value specified by the end user in text box  (e.g., 12). If so, comparator  places a TRUE indication on its output terminal and issues its DataReady event. In response, wire construct  toggles the ControlIn property of Break symbol . Upon being triggered, Break symbol  stops execution of the first \u201cup-stream\u201d loop-type object. In this case, the first up-stream loop symbol is For Loop . Accordingly, when Break symbol  is triggered it stops execution of For Loop , thereby stopping the application program. Within label images  and  will be the final loop index value from For Loop  and the final sum from addition symbol .","In addition to generating application program code having loop structures in response to graphical inputs by the developer, the program-development environment  of the present invention may also generate event handler procedures corresponding to the loop structures in response to textual inputs by the developer. More specifically, the developer may select a desired loop symbol from a given data\/control flow diagram and specify a corresponding event handler procedure through textual inputs.",{"@attributes":{"id":"p-0158","num":"0158"},"figref":["FIG. 15","FIG. 3","FIG. 2","FIGS. 4A\u20134D","FIG. 2","FIGS. 8A and 8B"],"b":["1500","310","235","400","406","1502","230","1502","1504","1504","1506","404","1504","1508","1506","1508","1504"]},"As described above, the Do Loop object includes the RunBlock, StatusReady and ControlOut events, among others. Accordingly, the developer can generate entry points within the code window  for each of these events. In particular, by selecting the StatusReady event from the procedures\/events box , the developer can cause the program-development environment  to generate an entry point  for this event within the code window . Below this entry point, the developer may insert, review and edit one or more statements that are compatible with the underlying programming language, e.g., Visual Basic. In response, the program-development environment  generates program code that runs in response to the occurrence of the respective event, e.g., StatusReady. The developer may similarly insert statements that are to be run in response to other events issued by the object of the Do Loop symbol . For example, a second insertion point  can be created within code window  for the Do Loop's RunBlock event, and a third insertion point  can be created for the Do Loop's ControlOut event. Unlike the prior art graphical programming systems which do not allow developers to specify event-handlers for loop related images textually, the program-development environment of the present invention allows developers to switch between graphical and textual programming paradigms for the specification of event handlers.","Other Program Object Classes Having Symbolic Representations","The program-development environment  () of the present invention preferably includes additional program object classes that may be used in creating application programs. Icons corresponding to these additional program objects may be included within the designer toolbar  (). Referring to , which is a preferred representation of a GUI  having similar elements and features as GUI  (), Core sub-toolbar also includes icons, in addition to those described above, for a Yield control, a Stop control, a User Function control, a Count control and a Wait control. Each of these icons, in a similar manner as described above, corresponds to an object class from which one or more program objects may be instantiated.","For example, as shown in designer window , a User Function symbol  preferably has at least two data input terminals , (e.g., corresponding to input variables \u201cx\u201d and \u201cy\u201d, respectively), a control input terminal , a data output terminal , an error data output terminal and a control output terminal . The User Function object of symbol  preferably incorporates the ControlOut, DataReady, RunBlock and StatusReady events described above. The User Function object is typically utilized by a developer to incorporate a custom event handler that occurs in response to the RunBlock event of the User Function object. The custom event handler is preferably defined through textual inputs entered in the code window  () at an insertion point corresponding to the RunBlock event of the respective User Function object. The custom event handler may or may not utilize the values of the \u201cx\u201d and \u201cy\u201d data input terminals , of the symbol . It also may or may not generate some new value that may be passed on its data output terminal . In the illustrative embodiment, the custom event handler complies with the syntax and command structure of Visual Basic.","A Count symbol  preferably has a control input terminal , a data output terminal , an error data output terminal and a control output terminal . The Count object of symbol  performs a count operation preferably starting at \u201c0\u201d and incrementing by \u201c1\u201d each time its ControlIn property is triggered by a wire construct connected to its control input terminal ","A Wait symbol  preferably has a control input terminal , a busy data output terminal , an error data output terminal and a control output terminal . The Wait object of symbol  is used to pause the execution of the corresponding application program for a specified time interval, which is useful in slowing down visual up-dates, for example. The Wait object preferably has Interval and CancelBlock properties, among others, and incorporates the ControlOut, DataReady, ErrorOut and RunBlock events. When the Wait object's control input terminal is triggered (i.e., changed), the object counts off the value of its Interval property. When the time corresponding to its Interval property elapses, the Wait object issues its DataReady event. While it counts off the interval, the object may repeatedly pass (e.g., fire) a busy value on data output terminal ","A Yield symbol  preferably includes a control input terminal . When added to a loop branch of a flow diagram, the Yield object of symbol  pauses the execution of the respective loop upon each iteration (e.g., before each new DataReady event and loop index are issued by a For Loop object) so that other processes of the application program can be executed, as necessary. When these other processes have finished executing, processing continues with the next loop iteration. The Yield object preferably pauses the execution of the first up-stream loop object (e.g., Do Loop, For Loop or Timer objects) to which the symbolic representation of the given Yield object is connected.","A Stop symbol  preferably has a control input terminal . The Stop object corresponding to symbol  stops the execution of the corresponding application program (not just the looping branch within which it may be located) when its control input property is triggered (e.g., changed). A comparison or any other object may be arranged within the corresponding flow diagram to trigger a Stop object upon the occurrence of some condition defined by the developer. It should be understood that a Stop object may be used in the flow diagram corresponding to any application program, not just one that includes a loop.","Those skilled in the art will recognize that other program objects with corresponding symbolic representations may be generated for use with the program-development environment  () of the present invention. For example, program objects and constituent symbols may be created for reading text, data or arrays from a specified storage file and making that information available as an output to the data\/control flow diagram, or for writing text, data or arrays received as an input from the data\/control flow diagram to a specified file. Another object and symbol may be designed to retrieve the current time from the computer system and make it available, in one or more formats, as an output to the data\/control flow diagram. A still further object and symbol placed within the data\/control flow diagram may run a specified executable program upon being triggered. This object may have a property that, upon starting the executable program, allows the application program of the flow diagram to continue running substantially simultaneously with the execution of the specified executable program, or delay continued running of the application program until the specified executable program is finished executing.","The foregoing description has been directed to specific embodiments of this invention. It will be apparent, however, that other variations and modifications may be made to the described embodiments, with the attainment of some or all of their advantages. Therefore, it is the object of the appended claims to cover all such variations and modifications as come within the true spirit and scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The invention description below refers to the accompanying drawings, of which:",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIGS. 4A\u20134D"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIGS. 6A\u20136B","b":["7","10","10","12"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIGS. 8A and 8B"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIGS. 13 and 15"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIGS. 14A\u2013D"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 16"}]},"DETDESC":[{},{}]}
