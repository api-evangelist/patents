---
title: Shared object lock under state machine control
abstract: Embodiments relate to systems and methods for a shared object lock under state machine control. An operating system or virtual machine environment can host a set of multiple executing threads, and provide those threads with mutual access to one or more objects such as storage objects, memory objects, or others. The threads can independently request that the object be locked or unlocked, and the locked or unlocked state can be shared between the threads. Rather than communicate with the object(s) directly, in embodiments the threads communicate with a state machine that in turn controls the state of the object(s). When a request to change the state of the object(s) is received, the state machine can permit the object(s) to change between locked, unlocked, or other states based on the current state of the machine and the received message. Contention between threads can be reduced or eliminated.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08918798&OS=08918798&RS=08918798
owner: Red Hat, Inc.
number: 08918798
owner_city: Raleigh
owner_country: US
publication_date: 20080829
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD","BACKGROUND OF RELATED ART","DESCRIPTION OF EMBODIMENTS"],"p":["The present teachings relate to systems and methods for a shared object lock under state machine control, and more particularly to platforms and techniques for operating a state machine configured to communicate with and manage objects shared between multiple executing threads.","In the context of multi-threaded software execution, it is necessary to coordinate the access of executing threads to the resources of a system. For example, an operating system or virtual machine environment can manage multiple program threads or other executing processes, some of which may wish to access resources such as disk storage or network port access at the same time. The operating system or environment may as a result incorporate a thread scheduler to control the order in which threads can access the objects.","Serializing the access to objects can entail some drawbacks, however. Those include coherency or latency problems since one thread may gain access to an object only after another has modified that object, but each may depend on the current state of the object or its data. In some environments, such as certain versions of the Java\u2122 run-time environment, a mechanism is provided by which a shared lock can be placed on an object, such as a disk access object. In such implementations, one thread or process can place a lock on an object, but other threads can share access to that same object while it is locked. Similarly, one thread can unlock the object on behalf of all threads sharing control of the object, to restore access to other processes. However, even in platforms employing a shared-lock mechanism, there can be difficulties in the control of the shared object, including because there is no independent control mechanism to coordinate the locking and unlocking of the object, apart from the threads themselves. It may be desirable to provide methods and systems for a shared object lock operating under separate logical control.","Embodiments of the present teachings relate to systems and methods for operating a shared object lock under state machine control. More particularly, embodiments relate to platforms and techniques for generating a state machine coupled to one or more objects that are accessible to multiple executing threads. The threads can be applications or other programs running under an operating system or in a virtual machine environment. The multiple executing threads can share control of the one or more objects. Each thread can, for instance, transmit a message to the state machine requesting that the object take on a desired state. That state can be or include, for example, a locked state or an unlocked state. The remaining objects can for example share access to the object while it is locked. The requests for various states of the object or transitions from one state to another can all be communicated via the state machine. The state machine can receive those inputs from one or more threads, and based on a set of data including the requests, the state of the state machine, and\/or the state of the object, can generate a decision regarding the transition from a current state to a next state of the object. In cases, the state machine can cause the object to maintain a current state. In cases, the state machine can cause the object to change from a first state to a second or other state. In embodiments, each state of the state machine can be associated with or correspond to a defined object class. These and other embodiments described herein address the various noted shortcomings in known object sharing technology, and provide a programmer or other user with an enhanced ability to manage the execution of threads and ensure better coherency in the state of the object and\/or data generated by the object.","Reference will now be made in detail to exemplary embodiments of the present teachings, which are illustrated in the accompanying drawings. Where possible the same reference numbers will be used throughout the drawings to refer to the same or like parts.",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1","b":["100","102","102","106","110","102","106","106"]},"In embodiments as shown, virtual machine environment  can host or access a set of multiple threads , such as executing process threads of applications or other software. The set of multiple threads  can communicate with a state machine controller . The set of multiple threads  can, in general, share access to object  in a common or shared state of that resource. State machine controller  can in turn communicate with an object . Object  can represent a defined resource of virtual machine environment , such as a disk-access object, an input\/output (I\/O) object, a memory object, or other object or resource available under virtual machine environment .","Object  can exist in any one of a set of multiple states. Each state of object  can be defined by one class in a set of state-defining classes . For instance, a first state of object  can be a locked state. In embodiments where object  is or includes, for instance, a disk access object, a locked state of object  can indicate that the set of multiple threads  can access the underlying hardware disk or other storage and write or read data, whereas a set of other processes  running under virtual machine environment can not. A state of object  can similarly include an unlocked state, in which set of multiple threads  as well as set of other processes  can access object , including the underlying storage hardware. Other objects, states, and executing processes are possible. For example, states of object  can include a cached state or an uncached state, for instance related to the state of data stored in a database. In embodiments as shown, any thread in set of multiple threads  can transmit a request to state machine controller  to request that object  be placed or transitioned into a desired state, on a shared basis with the remaining threads of set of multiple threads .","More particularly, as illustrated in , any one or more thread in set of multiple threads  can transmit a state request  to state machine controller . For instance, a thread can request that object  be placed into a locked state. State machine controller  can then generate a transition decision  based on state request , a current state of object , and\/or a current state of state machine controller . According to embodiments, transition decision  can be for instance generated by state machine controller  using the following class definitions and associated logic, or others.","According to embodiments, a single state machine controller  can be set up for each object  to be controlled. In embodiments, a class can be defined called \u201cAtomicStateMachine\u201d, whose instances are used to manage the state of each controlled object . Every object class that is to be controlled by a state machine controller  in this way in one regard can have an associated enumerated type, which represents the list of possible states. This enumerated type can be used as the generic type parameter to AtomicStateMachine instance, which can then be used to hold the state machine controller  in a certain state (using for example a read lock internally), or can be used to transition to a new state (using for example a write lock internally).\n\n",{"@attributes":{"id":"p-0017","num":"0017"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"(General)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"* public static <T extends Enum<T> & State<T>>"]},{"entry":[{},"AtomicStateMachine<T> start(T initialState);"]},{"entry":[{},"\u2003Creates a new AtomicStateMachine instance and"]},{"entry":[{},"\u2003places it into an initial state."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0018","num":"0018"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"329pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"(Transition Methods)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"329pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"The methods ending in \u201cHold\u201d will acquire the shared (read) lock if successful. The methods ending in"},{"entry":"\u201cExclusive\u201d will acquire the exclusive (write) lock if successful. Failure to acquire the lock results in failure of the"},{"entry":"overall method."},{"entry":"* public boolean transition(T state);"},{"entry":"* public boolean transitionHold(T state);"},{"entry":"* public boolean transitionExclusive(T state);"},{"entry":"Acquire the write lock, and attempt to transition to the given state. If the state machine controller 112 is already"},{"entry":"in the target state, these methods return \u201cfalse\u201d and no locks are acquired. For all three methods, the exclusive"},{"entry":"lock is acquired to make a change to the state machine controller 112. The method chosen simply selects how"},{"entry":"(or whether) the lock is downgraded."},{"entry":"* public boolean transition(T fromState, T toState);"},{"entry":"* public boolean transitionHold(T fromState, T toState);"},{"entry":"* public boolean transitionExclusive(T fromState, T toState);"},{"entry":"Similar to the prior three methods, but these require that the state machine controller 112 be in the \u201cfromState\u201d"},{"entry":"before proceeding to the \u201ctoState\u201d. If not, \u201cfalse\u201d is returned and no locks are acquired."},{"entry":"* public void requireTransition(T state);"},{"entry":"* public void requireTransitionHold(T state);"},{"entry":"* public void requireTransitionExclusive(T state);"},{"entry":"* public void requireTransition(T fromState, T toState);"},{"entry":"* public void requireTransitionHold(T fromState, T toState);"},{"entry":"* public void requireTransitionExclusive(T fromState, T toState);"},{"entry":"These six methods are the same as the prior six. However in this case, rather than returning \u201cfalse\u201d on failure,"},{"entry":"an exception is thrown."},{"entry":"* public void requireHold(T state);"},{"entry":"This method requires that the state machine controller 112 be in a certain state. If so, the shared lock is"},{"entry":"acquired; if not, an exception is thrown."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0019","num":"0019"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"329pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"(Release Methods)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"329pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"* public void release( );"},{"entry":"* public void releaseExclusive( );"},{"entry":"* public void releaseDowngrade( );"},{"entry":"Release a lock. The release( ) method releases a shared lock (i.e. the current state is \u201cunpinned\u201d),"},{"entry":"releaseExclusive( ) releases an exclusive lock, and releaseDowngrade( ) atomically downgrades an exclusive"},{"entry":"lock to a shared lock. That is, a change has been made to object 108's stateful data, and now the object is to be"},{"entry":"made available to other threads in set of multiple threads 110, but the mechanism will still \u201cpin\u201d it or hold it in its"},{"entry":"current state without letting another intervening request in between releasing the exclusive lock and acquiring"},{"entry":"the shared lock."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0020","num":"0020"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"329pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"(Wait Methods)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"329pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"* public void waitFor(T state);"},{"entry":"* public void waitForHold(T state);"},{"entry":"Wait for a certain state. If a thread of execution requires object 108 to be at a certain state and it may or not be"},{"entry":"in that state yet, use one of these methods to \u201cpark\u201d the running thread until the state is reached. The \u201cHold\u201d"},{"entry":"variant acquires the shared lock once the state machine controller 112 has entered the target state. If the target"},{"entry":"state is unreachable from the current state or from a state that is entered while waiting, an exception is thrown"},{"entry":"(and no lock is acquired). This is significant because these methods allow, for example, the initiation of a"},{"entry":"connect operation, followed by the performance of some other work, and then a wait period for the connection to"},{"entry":"become ready without risking entering a \u201cwait forever\u201d type of loop."},{"entry":"* public T waitForNot(T state);"},{"entry":"* public T waitForNotHold(T state);"},{"entry":"The same as the prior methods, except these methods wait for the state machine to exit the given state. Same"},{"entry":"locking semantics; returns the new state."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0021","num":"0021"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"(Informational Methods)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"* public T getState( );"]},{"entry":[{},"* public T getStateHold( );"]},{"entry":[{},"* public T getStateExclusive( );"]},{"entry":[{},"* public boolean inHold(T state);"]},{"entry":[{},"* public boolean in(T state);"]},{"entry":[{},"* public boolean in(T... states);"]},{"entry":[{},"These methods read the current state, or test for a"]},{"entry":[{},"certain state, optionally grabbing a lock."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0022","num":"0022"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"329pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 6"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"(State Interface)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"329pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"In embodiments, an additional interface that the enumerated state types can be implemented called \u201cState\u201d,"},{"entry":"which can be defined as:"},{"entry":"public interface State<T extends Enum<T> & State<T>> {"},{"entry":"\u2003boolean isReachable(T dest);"},{"entry":"}"},{"entry":"According to embodiments, the interface State takes a type parameter T which corresponds to an enumerated"},{"entry":"type that implements this interface. So if a class Banana is defined, methods can include:"},{"entry":"public class Banana {"},{"entry":"\u2003private enum MyState implements State<MyState> {"},{"entry":"\u2003\u2003GREEN,"},{"entry":"\u2003\u2003RIPE,"},{"entry":"\u2003\u2003PEELED,"},{"entry":"\u2003\u2003EATEN;"},{"entry":"\u2003\u2003\/\/ Used by AtomicStateMachine to detect when the process is waiting for a state that cannot be reached."},{"entry":"\u2003\u2003public boolean isReachable(MyState dest) {"},{"entry":"\u2003\u2003\u2003\/\/ EATEN is ultimately reachable from all states, PEELED is ultimately reachable from RIPE or GREEN,"},{"entry":"etc."},{"entry":"\u2003\u2003\u2003return compareTo(dest) < 0;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"\u2003private final AtomicStateMachine<MyState> state = AtomicStateMachine.start(MyState.GREEN);"},{"entry":"\u2003...and later on, in some method:..."},{"entry":"\u2003if (state.transitionHold(MyState.PEELED, MyState.EATEN)) try {"},{"entry":"\u2003\u2003System.out.println(\u201cDelicious banana\u201d);"},{"entry":"\u2003\u2003\u2009System.out.println(\u201cNo \u2009other \u2009process \u2009can \u2009modify \u2009the \u2009banana \u2009while \u2009occupied \u2009but \u2009can \u2009view \u2009banana \u2009if"},{"entry":"desired\u201d);"},{"entry":"\u2003} finally {"},{"entry":"\u2003\u2003state.release( );"},{"entry":"\u2003} else {"},{"entry":"\u2003\u2003System.out.println(\u201cBanana not peeled yet\u201d);"},{"entry":"\u2003}"},{"entry":"\u2003...etc..."},{"entry":"}"},{"entry":"Other classes, procedures, methods and parameters can be used."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0023","num":"0023"},"figref":"FIG. 3","b":["102","102","120","122","104","104","120","128","120","124","126","120","112","110","108","108","110","108","108","102"]},{"@attributes":{"id":"p-0024","num":"0024"},"figref":"FIG. 4","b":["402","404","110","102","110","102","104","106"]},"In step , object  can be instantiated on host machine , for example by instantiation from a set of state-defining classes  hosted or configured on host machine . In step , a state machine controller  can be instantiated on host machine  in an initial state. In embodiments, object  can be accessible to set of multiple threads  via state machine controller . In embodiments, state machine controller  can be associated with or correspond to a set of state machine controller classes , each class of which corresponds to a state of state machine controller . In step , the state of state machine controller  can be coupled to object  in an initial state. For instance, in embodiments, object  can be placed into an unlocked initial state, and state machine controller  can be instantiated initially from an object class for an unlocked state.","In step , a message can be received from one or more thread of set of multiple threads  in state machine controller  requesting a desired state of object . For instance, a thread can request that object  be placed into a locked state. In step , state machine controller  can generate a decision to transition object  to a new state, or to maintain object  in an existing state. State machine controller  can generate a decision regarding a transition of object  based on the request received from set of multiple threads , the existing state of state machine controller , and\/or the state or output of object . In step , the state of object  and\/or state machine controller  can be updated to reflect a new state, as appropriate. For example, object  can be placed in a locked state, in which object  can be assessed by other processes or software other than set of multiple threads . In step , set of multiple threads  can be provided shared access to object  in the case where object  is in a locked state, as appropriate. In step , as understood by persons skilled in the art, processing can repeat, return to a prior processing point, jump to a further processing point, or end.","The foregoing description is illustrative, and variations in configuration and implementation may occur to persons skilled in the art. For example, while embodiments have been described in which object  can be in a locked state or unlocked state, in embodiments object  can have other states, such as a sleep or power-saving state, an error correction state, an encryption state, or other states, modes or conditions. Also for example, while embodiments have been described in which a single state machine is configured to control one object, in embodiments a single state machine can be configured to control multiple objects. For further example, while embodiments have been described in which a single state machine is configured to control one object, in embodiments multiple state machines can be configured to control one object. In yet further embodiments, multiple state machines can be configured to control multiple objects, either independently or cooperate with two or more state machines cooperating with each other. For still further example, while embodiments have been described in which the set of multiple executing threads under control of the state machine are hosted on one host machine, in embodiments the set of multiple executing threads can be hosted on different machines or hosts. Other resources described as singular or integrated can in embodiments be plural or distributed, and resources described as multiple or distributed can in embodiments be combined. The scope of the present teachings is accordingly intended to be limited only by the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF THE DRAWINGS","p":["The accompanying drawings, which are incorporated in and constitute a part of this specification, illustrate embodiments of the present teachings and together with the description, serve to explain the principles of the present teachings. In the figures:",{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
