---
title: Programming with shared objects in a shared memory
abstract: A shared memory technology where shared objects can be used by any of multiple users, applications, or program sessions with programming language support during development and at runtime. The developer can declare shared memory behaviors at design time to cause one or more area classes to be generated for use at runtime. A shared objects memory is managed by the runtime environment. Content is stored at runtime in an area instance of an area class. Class methods to be generated that include methods for attaching and detaching a running session to and from an area instance, and for detaching a session from a change request on an area instance with a commit or a rollback. The runtime environment manages locks for area instances. There are programming language constructs for creating area instances and for creating data objects of arbitrary data type within area instances.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07451434&OS=07451434&RS=07451434
owner: SAP Aktiengesellschaft
number: 07451434
owner_city: Walldorf
owner_country: unknown
publication_date: 20040909
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","Embedding in Programming Language"],"p":["This application claims priority based on U.S. Patent Application No. 60\/509,053 for Application Programming with Shared Memory, filed Sep. 9, 2003.","The present invention relates to digital data processing, and more particularly to application programming with shared memory.","Computer program applications generally involve user requests to store and access data. Business applications commonly involve user and program sessions that need concurrent access to large amounts of data by multiple users, program sessions, or both.","The present invention meets this need by providing a framework for creating and managing shared objects in a shared memory.","The data objects stored in the shared memory are also referred to as shared objects in this description. The part of the shared memory that is used for the administration and storage of the shared objects is referred to as shared objects memory.","A shared memory is shared in the sense that it does not belong to any particular process, user, or task, although it need not be available to every user or to every task on a computer or application server. The invention also provides for the convenient definition of shared objects' properties in a declarative way at design time.","The invention features the concept of an area. An area is like a class. It has a constructor and it has properties that are inherited by area instances. The data objects of an area instance are actual shared objects. Corresponding to an area is a programming language class that is generated for use by programs at runtime. The runtime area class has access methods by which the class is accessed. Thus, the invention embodies a clear separation between the specification of area characteristics (done at design time) and the actual","The programming model of the invention is not designed for general purpose shared memory programming; rather, it is designed for particular application scenarios. An example of such a scenario is a product catalog implemented as a shared object (i.e., an object that exists in shared memory). The catalog in memory is created by operation of the constructor for the area of which the catalog is an instance. This object, the catalog, can exist as long as the underlying system (e.g., an SAP\u00ae Web Application Server) is running. The catalog in memory can be accessed by any number of users and any number of processes.","The invention can be used in a system where multiple program sessions can exist at one time for a user session (i.e., for application user logon), such as an SAP R\/3 system. Each program session, which will be referred to simply as a session when the meaning is clear from context, has its own separate context data, which includes what is will be referred to as its roll area. More particularly, each user session has its own separate context data that is not visible for other user sessions. Each program session has its own separate context data that is not visible for other program sessions. With an area instance, data can be shared across user and program session bounds on a specific application server.","In principle, any kind of data object, in particular, aggregated data types (for example, tables) and strings, can be instantiated directly in the shared memory. A class can be instantiated in shared memory if it is flagged as \u201cshared memory enabled\u201d. It is not necessary that the actual class definition be adapted for the class to be instantiated as a shared data object. It is also possible to store very large data objects, e.g., 15 gigabytes and larger, in the shared memory.","The language constructs used to create non-shared data objects are extended with runtime support to create shared data objects by the simple use of an additional parameter. For example, a shared object can be created in one system with a CREATE OBJECT statement executed with an AREA HANDLE parameter on an underlying class that is \u201cshared memory enabled.\u201d The area handle allows the program to access a shared object graph starting at the root object of the area.","In a typical code sequence, a running program first attaches itself to a shared memory area in order to gain a handle. Then, it creates an object in shared memory associated with that handle and makes it the root object for an area instance. From there, the program can manipulate the shared object as it would any other object. When the program detaches from the area instance, the shared object becomes unavailable, and the program can indicate whether it wants to commit or roll back any changes made to the area instance.","Thus, with shared objects, a developer can use objects that include references to several other objects, stemming from the root object. These objects allow a program to store variables of any kind in shared memory for copy-free read access, because objects are directly accessed in shared memory and can be shared among different user and program sessions.","The invention features a locking concept that ensures that there are no parallel change users of an individual area instance. This locking is enforced by the runtime environment and is not merely a programming convention. The system checks the exclusiveness of the change user, which check cannot be bypassed. The lock logic is simple and transparent for application developers.","Simultaneous access by multiple readers (i.e., program sessions reading shared memory) is managed through read locks. Shared objects can be written or updated with a change lock. When a writer wants to update or insert a shared object in an area instance, the entire area instance is locked.","Areas can be implemented with a number of useful and powerful properties. The existence of these properties and their support by the development and runtime framework are important advantageous features.","One such area property is declared versioning. If versioning is activated for an area, read requests can be performed even during an update of the area instance. For areas with versioning, modifying the contents involves making a deep copy of the original area contents, which any active readers can continue to read. This is important in cases where large amounts of data are stored in the area and a large number of read users access the area in high availability scenarios. For areas without versioning, however, the original data is modified. The simultaneous writing of more than one version is not supported by versioning.","Another such area property is the lifetime of an instance. A catalog, for example, can be derived from a database that changes during the day. Nevertheless, it may be desirable not to rebuild the catalog every time the database changes, but rather to rebuild it once a day. This can be done by the framework on the basis of static properties declared for the corresponding area. The framework can also manage multiple versions of the catalog, so that a user having started working with one version will continue to do so even though a second version has been built, while new users use only the second version.","Another such area property is declared binding of an area to a transaction context of database operations. With such a binding, the setup of an area instance\u2014i.e., the writing of data into the instance\u2014is completed with a commit or terminated by means of a rollback that is tied to corresponding database operations, and do not take effect until the corresponding database operations take effect. With this property, it is easy for a developer to have the framework ensure the consistency of shared memory and database data.","Another such area property is declared propagation of an area beyond application server limits, whether the application servers are running on one machine or on multiple machines. An area can be instantiated on multiple application servers. When an area instance on one server changes, with area propagation, the other servers are automatically informed when an area instance is invalidated such that the corresponding area instances can be rebuild again.","The invention also features a monitoring tool, by means of which the status of all areas can be monitored by an administrator. Information on the currently active area instances, their memory consumption, number and type of locks as well as the actual area contents can be monitored at any time. In particular, areas can be invalidated and locks can be released by an administrator.","The details of one or more embodiments of the invention are set forth in the accompanying drawings and the description below. Other features, aspects, and advantages of the invention will be apparent from the description and drawings, and from the claims.","Like reference numbers and designations in the various drawings indicate like elements.","The present invention provides a framework implementing a simple and elegant programming model for storing and accessing shared memory data. This is not, however, intended to be a general purpose model. Instead, it is designed to support the following two frequently occurring application scenarios. In the first, which may be called the shared buffer scenario, there is one change user and a possibly large number of parallel read users, and updates are relatively rare. In the second, which may be called the exclusive buffer scenario, there is exactly one change user and one read user. These scenarios are especially well supported by the present invention.","In a shared buffer scenario, data is stored that is rarely provided or updated (e.g., an update interval of once a day up to once an hour) and can be quite large. Usually, a large number of read users simultaneously access the data. Therefore, one version of the data should always be available. Storing and maintaining a large catalog is an example of this high availability scenario.","In an exclusive buffer scenario, usually only one user accesses an exclusive buffer. In rare cases, there can be two users, one who only writes while the other only reads. However, the data stored in the exclusive buffer should be available for a longer term. An application for the use of an exclusive buffer is the shopping basket. When a shopping basket is being filled, there is exactly one updating user, the buyer. On the other side, there is exactly one reader reading the entries the buyer made. Quite often buyer requests are processed in a separate transaction. If, after this transaction has been completed, the data is to be available for further transactions, it can be stored in a shared memory.","Thus, to support the implementation of data-intensive business applications, the invention makes it possible to store globally any kind of data object in a shared memory. In this description, the term \u201cdata object\u201d will be used to refer to any type of data and not only to objects in the object-oriented programming sense. Thus, a data object occupies memory and can be an instance of an object-oriented class; but it can also be an instance of an elementary data type, an aggregated data type, a string data type, a table, an array data type, a reference data type, or any other data type.","As illustrated in , an area can be defined at design time by a developer using programs or tools provided by a development environment . For convenience, these will be referred to as the shared memory maintenance program, or more simply, the maintenance tool . Using the tool, all characteristics of the shared objects memory can be defined and areas can be managed.","Each area ,  has a unique name. It is possible to create several area instances -, - for each area. All area instances of one area have the same characteristics. Within an area, each area instance has a unique name that is specified at runtime when the area instance is created.","As illustrated in , many data objects ,  can be stored in an area instance . The objects of an area instance are addressed by means of references. An area instance as such is self-contained; that is, once the area instance is set up, there are no pointers from the area instance to any data outside the area instance. The data objects within an area instance, on the other hand, may have references to each other.","Because areas are declared at design time, meaningful static type checking can be performed. For example, because the root data class of an area is statically known, a modification of the root data class automatically results in an invalidation of the area. The consistency of the data source (root class) for the area contents is thus ensured. Furthermore, static type checks can be carried out in cases where a shared memory area is used, whereas with other methods this is generally only possible at runtime.","Access to shared data objects is controlled by means of a simple lock logic that is managed as part of program operations for obtaining and releasing access to an area instance. A lock does not apply to individual data objects but to all objects in an area instance. A lock refers to exactly one area instance and does not affect other area instances. By default, a lock remains set until the end of the program session in which it was obtained. The two types of locks are for reading (read) and for changing. The latter are subdivided into locks for writing (write) and for updating (update). No parallel change users (write or update) are permitted on one and the same area instance; that is, there can only be a maximum of one change lock for each area instance at any point.","An area instance can be changed in two ways. Either the area instance is recreated (write) or the existing data in an area instance is modified (update).","With versioning, a new read lock is always set on the active version, and each version on an area instance passes through four life-cycle phases:\n\n","In an area with versioning, e.g. Area A , each area instance can have one or more area instance versions (which can be referred to simply as versions), e.g., the versions annotated - of instance J.","For the simplest case without versioning, e.g., Area B  no read accesses can occur until the current change user has completed his write operation. Change users are only granted access if no other lock is active.","During the creation of the second version, read accesses still refer to the active version. With the area commit of the version being built, the version being built becomes active and the previously active version becomes out of date.","If the area has more than two versions, parallel read users can read from more than two versions. For this purpose, the active version must have been replaced by a newly built version before another shared lock is set. In this case, several read users working on different out-of-date versions are involved.","In case of transactions with a long runtime it is helpful to be able to work with more than two versions. The number n of the required versions for an area instance depends on the relationship of the length of the shared locks (that is, the duration of the long-running program transaction) to the time interval between the request of two change locks (that is, the validity period of a version). If on average an exclusive lock is requested every s minutes and a read user on average needs r minutes for his read activity, the number n of the versions should not be less than r\/s+1.","If shared locks are on the versions 1 to n\u22121 of an area instance and if the last version n is the active version, it is not possible to set a change lock. The active version of an area instance is therefore never invalidated by a change lock being set.","The functionality of the invention is provided in the development and runtime environments of a programming language. In the following description, the implementation examples of an API (application programming interface) and other aspects of the invention will be based on the programming language ABAP, available from SAP AG of Walldorf (Baden) Germany.","An overview is illustrated in . A developer uses a development environment () to declare an area class at design time (). The developer declares shared memory behaviors in the area class declaration (, ). The area class declaration causes the area class to be generated for use by an application at runtime as an organizational unit for a shared objects memory (, ). The shared objects memory  is a region of memory managed by the runtime environment  that is available to be shared by multiple sessions of one or more applications running in the runtime environment. The declaration of the area class causes instance methods to be defined and generated, the instance methods including methods for attaching and detaching a running session of an application to and from an area instance, a method for detaching a session from a change request on an area instance with a commit, and a method for detaching a session from a change request on an area instance with a rollback (). Content is stored at runtime in area instances, e.g., instance , by applications ().","Code in the runtime environment manages locks for area instances (). Locks apply to individual area instances as a whole, and the runtime environment permits a particular area instance to be attached to by only (i) one or more readers, or (ii) exactly one changer, a changer being a writer or an updater, or (iii) no readers or changers. Code in the development and runtime environments  supports programming language constructs for creating area instances and programming language constructs for creating data objects within area instances, where the data objects can be of arbitrary data type including elementary data types, structures, and references ().","The developer can declare any programming language classes as having the attribute that they are shared memory enabled (). Every class that is shared memory enabled can be instantiated in an area instance. The runtime environment provides for the instantiation of arbitrary types of data objects in area instances. The class methods for attaching a session of an application to an area instance for reading, writing, and updating also request corresponding locks.","One build, area instances are self-contained (). The runtime environment does not permit content in any area instance to contain references pointing outside the respective area instance after commit\/rollback. Also, the runtime environment manages all references to content, providing type safety and complete control of references to content in area instances.","A developer can declare that an area instance can be automatically preloaded by an area class loader at server startup, at the initial (first occurring) read request, or after invalidation ().","A developer can declare that an area class has versioning for instances of the area class (). An area instance version can be in one of the following four states: under construction, active, out of date, or expired. The declaration of versioning allows the developer to define a maximum number of permitted area instance versions that can exist for a particular area instance at one time in the area class.","A developer can declare that an area class is transactional (). An area instance of a transactional area class has its commit and rollback behavior tied to commit and rollback language constructs provided by the programming language and the runtime environment for database commits and rollbacks, and an area instance that experiences a detach and commit becomes active with the next database commit.","A developer can declare that an area class is propagated (). An area instance of a propagated area class can be separately instantiated on several application servers, and whenever an area instance changes on one of the application servers, the runtime environment on that application server propagates to the other application servers an invalidation message, causing the other area instances to become out of date, which would cause them to be reloaded with current data.","A developer can declare that an area class has a life time (). The life time of an area instance can be restricted by specifying: a refresh time, invalidation time, or idle time. The life time can also be bound to a user or program session.","The runtime environment can establish hardware memory protection for an area instance that has no changer attached to it. (). This is possible on platforms that allow the runtime environment to set a hardware read-only status on areas that have no change locks.","Returning to , a maintenance tool  is used to create a shared objects memory . All attributes of the shared objects memory  can be defined using the maintenance tool. These attributes then apply to all area instances of the area. To use an area instance, the user needs the ability to create data in the area instance. In addition, it must be ensured that there are no conflicts between the different read users and change users. The already generally described locking concept serves this purpose. In addition, the user needs methods to access the data in the shared objects memory.","The optional keyword AREA HANDLE my_handle for the commands CREATE DATA and CREATE OBJECT enables the creation of new data in an area instance. The area handle to be specified after AREA HANDLE explicitly specifies the type of the lock (read, write, update) and the area including the area instance and area instance version, to which the lock was set. The system returns the area handle as a reference to an instance of the class generated for each area to the user when he sets a lock.","The setting and releasing of the locks for accessing the data of an area instance is supported by (class) methods. The corresponding classes are automatically generated with the definition of a shared objects memory area. The base class cl_shm_area contains the basic functionality for the access to area instances. For each area created at design time, a new class which inherits its functionality from cl_shm_area is generated automatically. The class name of the generated class corresponds to the specified area name.","The class CL_SHM_AREA_MODEL serves as a model for the generation of area classes. If this model class changes, all generated area classes should be regenerated using the new model class. All generated area classes are final.","When working with the shared objects memory, the relationships between session memory and the shared objects memory represented in  exist. The user of the shared objects memory has an area handle  for each area instance , on which the user holds a lock. This area handle allows the user to access the root object  of the area instance and thus the data in the area instance.","Most errors that occur during operations on the area instances are returned as exception of the type cx_static_check. For this reason, almost all statements for accessing the area instances should be included in TRY and ENDTRY. To allow for a better legibility of the following examples, the error handling is generally omitted.","In the following example, based on ABAP, the \u201c=>\u201d is notation for a class component selector, which allows access to a static component of a class without creating an instance.","The \u201c\u2212>\u201d is notation for an object component selector, which allows access to the instance and static components of an object. The \u201cREF TO\u201d is a type constructor for a reference type. Reference types are deep types, and data objects of these types only point to actual work data.",{"@attributes":{"id":"p-0064","num":"0067"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["DATA:",{}]},{"entry":["my_handle TYPE REF TO cl_my_area,","\u2033Area cl_my_area has"]},{"entry":"already been"},{"entry":[{},"\u2033created in maintenance tool;"]},{"entry":[{},"\u2033there the class cl_my_area"]},{"entry":[{},"\u2033was autmatically generated;"]},{"entry":[{},"\u2033cl_my_area is"]},{"entry":[{},"\u2033a non-transactional area"]},{"entry":["my_data \u2003TYPE REF TO cl_my_data.","\u2033root object (instance of"]},{"entry":[{},"\u2033root data classes) for storing"]},{"entry":[{},"\u2033data in the shared objects"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"memory"},{"entry":"* Setting an exclusive lock"},{"entry":"my_handle = cl_my_area=>attach_for_write ( )."},{"entry":"* Creating the root object in the shared objects memory"},{"entry":"CREATE OBJECT my_data HANDLE my_handle."},{"entry":"* Link to the root object"},{"entry":"my_handle->set_root ( my_data )."},{"entry":"* Storing a value in the root object"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["my_data->number = 4.","\u2033the class cl_my data includes the"]},{"entry":[{},"\u2033instance attribute number of the type i"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"* Release exclusive lock"},{"entry":"my_handle->detach_commit ( )."},{"entry":"* Set shared lock"},{"entry":"my_handle = cl_my_area=>attach_for_read ( )."},{"entry":"* Displaying the stored value"},{"entry":"WRITE my_handle->root->number."},{"entry":"* Release shared lock"},{"entry":"my_handle->detach ( )."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"This part of the description deals with the creation of data objects in the shared objects memory.","From the point of view of a change user, data objects are created in the shared objects memory with the help of the CREATE statement in connection with the specification of an area instance version after a change lock has been set. The version is specified by means of the area handle received when setting the change lock. Only dynamically generated data objects can be created in the shared objects memory.","The specification of the handles is done with the keyword HANDLE.","CREATE DATA dref HANDLE my_handle . . .","CREATE OBJECT oref HANDLE my_handle . . .","The keyword HANDLE must be specified directly after the data or object reference. The specification of TYPE, EXPORTING, and so forth, follows after the handle.","The following exceptions can occur when executing CREATE:\n\n","The first two exceptions have the common superclass cx_shm_general_error and should be dealt with locally (cx_dynamic_check). The memory errors do not force any local processing (cx_no_check). These memory errors can occur with every change access to the shared objects memory, for example, if an internal table contained in an area instance is extended with APPEND or INSERT. Memory errors in the shared objects memory do not result in runtime errors that cannot be caught. This behavior enables further access to the data contained in non-shared program memory and, following a memory release, a recreation of the area instance in the shared objects memory.","Each access to the contents of data objects must be performed by means of references, since only data objects can be created in the shared objects memory. In ABAP, two types for accessing the data accessible by means of references are available. One type is the dereferencing of the reference to the data object with each access. For data references, the type of the reference object must be specified completely. One can, however, also store the dereferenced reference in a field symbol and perform all accesses to the data object by means of the field symbol.","Generated Area Classes","Now the generated classes will be described. A class is generated for each area defined at design time. The name of this class corresponds to the specified area name.","Classes generated per area contain (class) methods that can be used to perform all functions for working with the shared objects memory, such as setting and removing locks. The generated area class inherits a lot of functions from the class cl_shm_area so that only very little source code must be generated. The user is not allowed to modify the automatically generated class.","The user must specify a root data class when he creates an area. The root object of every area instance of the area is an instance of the root data class. All data stored in an area instance must therefore be stored in instance attributes of the root object or must be accessible through references from the instance attributes of the root object.","A further class provides the area constructor for the automatic build of the area instances. The specification of an area constructor class is not necessarily required. If no area constructor class is specified, an automatic build of the area instances of this area is not possible. The constructor class can be used simultaneously as wrapper class for accessing the area instances. Because of the accesses being wrapped, the user of the wrapper class does not need an area handle nor must he worry about setting and removing locks. For the user of the wrapper class, accessing the shared objects memory is like accessing any other memory.","The following sections explain in detail the (class) methods implemented in the base class cl_shm_area and in the class generated for each area.","Setting a Lock","Setting a Shared Lock","Setting a shared lock is done with the help of the class method attach_for_read( ):",{"@attributes":{"id":"p-0082","num":"0093"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"CLASS-METHODS attach_for_read"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"IMPORTING","inst_name","TYPE shm_inst_name"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u2003DEFAULT"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"cl_shm_area=>default_instance"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"RETURNING","value (handle)","TYPE REF TO cl_my_area"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"RAISING","cx_shm_inconsistent"]},{"entry":[{},{},"cx_shm_no_active_version"]},{"entry":[{},{},"cx_shm_read_lock_active"]},{"entry":[{},{},"cx_shm_exclusive_lock_active."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"The method returns a reference to an object of the type cl_my_area, by means of which the contents of the area instance version can then be accessed. This object is referred to as an area handle.","The parameter inst_name specifies the name of the area instance. If only one area instance of the area is to be created, the parameter inst_name does not have to be passed when the method is called. In this case, the area instance name ($DEFAULT_INSTANCE$) entered in the class constant default_instance of the class cl_shm_area is used. This applies to all methods, for which the parameter inst_name can be specified.","To avoid programming errors when using several area instances of an area, one should specify a unique name for all area instances and not use the default name.","In a program session, there can be a maximum of one shared lock on each area instance. If it should be necessary for a program to access this area instance at different places\/points in time, there are two possibilities: (1) The shared lock is newly set prior to each access to the area instance and then released again. (2) The shared lock is set prior to the first access to the area instance and kept until the last access to the area instance.","The advantage of solution (1) is that it can be programmed easily. However, the newly requested shared lock is always set to the active version, that is, the consistency of the read data is not ensured with this procedure.","With solution (2), the once requested read handle must be available at every program location, where the area instance is accessed in read mode. For this purpose, the handle must be passed as a parameter to each modularization unit of the program or a factory class for the administration of the locks must be implemented.","The following exceptions can occur when attach_for_read( ) is called:\n\n","All listed exceptions are subclasses of the exception class cx_shm_attach_error.","If an exception occurs when a shared lock is set, the actual parameter that accepts the return code handle remains unchanged. This behavior also applies to the return codes of the methods describe below.","Setting an Exclusive Lock","The class method attach_for_write( ) sets an exclusive lock on an area instance:",{"@attributes":{"id":"p-0094","num":"0116"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"CLASS-METHODS attach_for_write"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"IMPORTING","inst_name","TYPE shm_inst_name"]},{"entry":[{},{},{},"\u2003DEFAULT cl_shm_area=>default_instance"]},{"entry":[{},{},"mode","TYPE shm_attach_mode"]},{"entry":[{},{},{},"\u2003DEFAULT"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"cl_shm_area=>attach_mode_default"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"wait_time","TYPE i"]},{"entry":[{},{},"\u2003DEFAULT 0"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"RETURNING","value(handle)","TYPE REF TO cl_my_area"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"RAISING","cx_shm_version_limit_exceeded"]},{"entry":[{},{},"cx_shm_exclusive_lock_active"]},{"entry":[{},{},"cx_shm_change_lock_active."]},{"entry":[{},{},"cx_shm_parameter_error."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},{"@attributes":{"id":"p-0095","num":"0117"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["cl_shm_area=>","All read users on this area instance may"]},{"entry":["\u2003attach_mode_default","continue with their reading activity. This"]},{"entry":[{},"is the default value."]},{"entry":["cl_shm_area=>","If setting an exclusive lock should not be"]},{"entry":["\u2003attach_mode_detach","possible because at least one read user is"]},{"entry":["read user","active on all versions, a removal of the"]},{"entry":[{},"shared locks on the oldest version is"]},{"entry":[{},"forced. All shared locks are therefore"]},{"entry":[{},"removed for area instances without"]},{"entry":[{},"versioning. Due to the removal of the"]},{"entry":[{},"shared locks, the oldest version is set to"]},{"entry":[{},"expired and a free version is available"]},{"entry":[{},"for setting up a new version."]},{"entry":["cl_shm_area=>","If setting the exclusive lock is not"]},{"entry":["\u2003attach_mode_wait","possible, the program waits a maximum"]},{"entry":[{},"of wait_time milliseconds. The queue"]},{"entry":[{},"activity is terminated early if setting the"]},{"entry":[{},"exclusive lock was successful. If the"]},{"entry":[{},"area instance does not have any"]},{"entry":[{},"versioning, no new read user can attach"]},{"entry":[{},"to the area instance during this wait"]},{"entry":[{},"time. Setting shared locks is still"]},{"entry":[{},"possible for area instances with"]},{"entry":[{},"versioning."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The following exceptions must be caught when the exclusive lock is set:\n\n","cx_shm_parameter_error: An erroneous parameter was passed.","Thus there are three situations in which setting a change lock is not possible:","(1) Shared locks are on all area instance versions.","(2) A change lock is already on the area instance.","(3) A change lock already exists on any area instance in a program session.","Situation (3) is to avoid deadlocks. In the following case, situation (2) and (3) occur simultaneously: In program session i, a change lock already exists on the area instance g. In i a second change lock for g is now requested. In this case, the second attach_for_write( ) returns the exception belonging to situation (3) (cx_shm_change_lock_active).","Setting a Change Lock","The class method attach_for_update( ) is available for updating the contents of an area instance:",{"@attributes":{"id":"p-0105","num":"0132"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"CLASS-METHODS attach_for_update"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2003IMPORTING","inst_name","TYPE shm_inst_name"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"\u2003DEFAULT cl_shm_area=>default_instance"]},{"entry":[{},"mode","TYPE shm_attach_mode"]},{"entry":[{},{},"\u2003DEFAULT cl_shm_area=>attach_mode_default"]},{"entry":[{},"wait_time","TYPE i"]},{"entry":[{},{},"\u2003DEFAULT 0"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"RETURNING","value(handle) TYPE REF TO cl_my_area"]},{"entry":[{},"RAISING","cx_shm_inconsistent"]},{"entry":[{},{},"cx_shm_no_active_version"]},{"entry":[{},{},"cx_shm_version_limit_exceeded"]},{"entry":[{},{},"cx_shm_exclusive_lock_active"]},{"entry":[{},{},"cx_shm_change lock_active."]},{"entry":[{},{},"cx_shm_parameter_error."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"The semantics of the parameters is equivalent to the one introduced for the method attach_for_write( ). If it is an area instance with versioning, the update implies making a copy (deep copy) of the active area instance version. The new version can then be updated.","The following exceptions must be caught when the method attach_for_update( ) is called:\n\n","cx_shm_parameter_error: An erroneous parameter was passed.","Simultaneous Setting of Several Locks","To avoid deadlocks within a program session, all exclusive locks (on different area instances of the same or another area) must be requested at the same time. Only shared locks can be set one after the other. If several change accesses to area instances are intended simultaneously, the class method multi_attach( ) has to be used:",{"@attributes":{"id":"p-0111","num":"0148"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["CLASS-METHODS","multi_attach"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"IMPORTING","ignore_errors","TYPE bool"]},{"entry":[{},{},{},"\u2003DEFAULT false"]},{"entry":[{},{},"wait_time","TYPE i"]},{"entry":[{},{},{},"\u2003DEFAULT 0"]},{"entry":[{},"EXPORTING","error_flag","TYPE bool"]},{"entry":[{},"CHANGING","attach_tab","TYPE shm_attach_tab."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},"The table type shm_attach_tab is defined as follows:","TYPES:\n\n",{"@attributes":{"id":"p-0114","num":"0158"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["client","Client of the area. When a lock is set on a"]},{"entry":["\u2003TYPE mandt","client-independent area, this entry must be"]},{"entry":[{},"initial, i.e., must have its type-specific initial"]},{"entry":[{},"value, which here indicates there is no client."]},{"entry":["area_name","Area name, corresponds to the name of the"]},{"entry":["\u2003TYPE shm_area_name","derived class."]},{"entry":["inst_name","Name of the area instance."]},{"entry":"\u2003TYPE shm_inst_name"},{"entry":["lock_kind","Access type:"]},{"entry":["\u2003TYPE shm_lock_kind","cl_shm_area=>lock_kind_read,"]},{"entry":[{},"cl_shm_area=>lock_kind_write or"]},{"entry":[{},"cl_shm_area=>lock_kind_update"]},{"entry":["attach_mode","Behavior with change accesses; can be"]},{"entry":["\u2003TYPE shm_attach_mode","different for each area instance; locks are"]},{"entry":[{},"internally requested one after the other"]},{"entry":["level","Internally the locks are set one after the other."]},{"entry":["\u2003TYPE I","The locks are set in the following sequence:"]},{"entry":[{},"if levelis smaller than level, then lock"]},{"entry":[{},"x is requested before lock y. If level= level"]},{"entry":[{},"and the table entry x was inserted before table"]},{"entry":[{},"entry y, lock x is requested before lock y. If"]},{"entry":[{},"all table entries have the same entry in the"]},{"entry":[{},"level column (for example, the default"]},{"entry":[{},"value 0), the sequence of the requests to lock"]},{"entry":[{},"corresponds to the insert sequence of the"]},{"entry":[{},"table entries."]},{"entry":["trade","A separate area handle is provided for each"]},{"entry":["\u2003TYPE REF TO cl_shm_area","area instance (table entry) entered in the"]},{"entry":[{},"table. It can be found in this column"]},{"entry":[{},"following a successful execution of"]},{"entry":[{},"multi attache( )."]},{"entry":["exception","If an exception is triggered when the lock is"]},{"entry":["\u2003TYPE REF TO cx_shm_attach_error","set, a reference to the instance of the"]},{"entry":[{},"corresponding error class is in this column."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The parameter wait_time specifies the total of all wait times for all requests of a change lock with attach_mode= cl_shm_area=>attach_mode_wait. A wait time of wait_time milliseconds is available for the first attach with the parameter wait. A wait time of wait_time minus the wait time required for the first attach is available for the second attach with the parameter wait. For all further requests for change locks with the parameter wait, the value wait_time is reduced by the already required wait time.","If the parameter ignoring_errors is set to false, the class method multi_attach( ) terminates with the request for the locks as soon as an error occurs when a lock is requested. In this case, the return parameter error_flag has the value true. The table entry, in which the error occurred, contains the exception object that belongs to the error in the column exception. In case of an error, the contents of the column handle (all rows) and the column exception (all rows except for the one) is initial after multi_attach( ) has been called, and all other columns of the table remain unchanged. (That a variable is initial means that it has a type-specific initial value, denoted INITIAL, that a variable also has when it is cleared; for a reference, in effect, the value is a null pointer value.) To increase the runtime of multi_attach( ), locks for which the request has a high probability of being rejected should be requested first, that is, they should contain a low value in the column level.","All area instances, to which a lock was set before the error occurred, are reset to the status they had prior to the multi_attach( ), that is, it acts as if an attach to the area instances never occurred.","If the parameter ignore_errors is set to true, the class method multi_attach( ) tries to set the remaining locks even after an error has occurred. In the rows, in which an error occurred, the area handle is set to INITIAL and the exception object is returned by means of the column exception. If the lock could be set successfully, the value INITIAL is entered in the column exception for the corresponding table entry.","Note that multi_attach( ) does return any of the exceptions specified for attach_for . . . ( ), but it indicates these errors through the return code error_flag. If error_flag=false is valid, all locks can be set successfully.","In addition to the exceptions specified for attach_for . . . ( ), the table column exception can also be filled with an object of the following exception class:","cx_shm_multi_attach_error with the text elements:\n\n","If a change lock is already active in a program session when multi_attach( ) is called, only shared locks can be successfully set with the multi_attach( ). In case a further change lock is requested, the column exception is filled with an exception object of the class cx_shm_change_lock_active.","The locks requested with multi_attach( ) can be released in any sequence.","A hash table is used for transferring data to the method multi_attach( ) since the insert operations are possible in constant time and at the same time a check for double entries is realized by means of the key fields.","Releasing a Lock","When explaining the functionality for releasing a lock, a distinction between transactional and non-transactional areas must be made. For transactional areas, all area instance changes become simultaneously active together with the database updates at the end of a database transaction, which is an inseparable sequence of database operations. In contrast to this, there are no dependencies between the database activities and the lock mechanism for the area instances for non-transactional areas.","Releasing a Shared Lock","A shared lock on an area instance can be explicitly released again with the help of the parameter-free instance method detach( ):","METHODS detach\n\n","A shared lock is automatically released with the termination of the program session, in which the lock was requested. If a new program session is opened, the shared lock still exists after returning from the new program session.","The following exceptions can occur with the release of a shared lock by means of detach( ):\n\n","Both exceptions are declared as a dynamic check and thus do not force any processing.","Should a lock be cleared as shown in the program segment below, the lock on the area is not released.","TRY.\n\n","ENDTRY.","CLEAR my_handle.","The read lock on the area instance can no longer be explicitly released with a detach( ) but instead remains set until the end of the current program session.","The following exceptions can occur with the release of a read lock by means of detach( ):","cx_shm_wrong_handle: with the text element:\n\n","cx_shm_already_detached: Each lock may be released only once.","Both exceptions are declared as a dynamic check and thus do not force any processing.","Releasing a Change Lock and Confirming the New Version","A change lock can be released with the instance method detach_commit( ).","METHODS detach_commit\n\n","If a detach_commit( ) is called for my_handle, the event shm_rollback_event of the area instance is automatically triggered and all methods registered for this event are performed in the order of registration.","After all the registered methods have run, it is determined whether the root object of the area instance is valid. If not, the exception cx_shm_root_object_initialis raised.","Once the validity of the root object has been checked, the garbage collector is started. It removes all objects that cannot be reached from the root object.","A check is then made of whether references from the area instance in the shared objects memory to other memory or to other area instances still exist. If this is the case, the user receives the exception cx_shm_external_reference.","With serializable area instances (displace_kind = cl_shm_area=>displace_kind_serializable), a test is also made of whether all classes instantiated in the area instance implement the tag interface if_serializable_object. If this is not the case for an instantiated class, the exception cx_shm_object_not_serializable is triggered.","For transactional area instances, the changes completed with an area commit only become active with the next database commit. The newly created version is therefore still being built until the database commit and becomes active only with the database commit. Thus for transactional areas with versioning, all shared locks requested between the area commit and the database commit are not yet on the just written version but on the version confirmed with a database commit. For transactional areas without versioning, a read access is therefore not possible between the area commit and the database commit. It is neither possible to set a new change lock between the area commit and the database commit for areas with versioning nor for areas without versioning. If an area rollback is carried out, a new change lock can be set immediately.","For non-transactional areas, the area instance changes become immediately active after the area commit, that is, all newly requested shared locks are immediately on the just written version.","Unlike shared locks, change locks must always be released explicitly. The following points in time are given, at which no change lock may be active anymore. Should a change lock nevertheless still be active at these times, a runtime error system_shm_change_lock_active occurs that cannot be caught;\n\n","If a runtime error occurs that cannot be caught while a change lock is active, the change locks are released and the changes are rejected.","The following exceptions can occur when detach_commit( ) is called:\n\n","The exceptions cx_shm_wrong_handle and cx_shm_already_detached are declared as a dynamic check and thus do not force any processing. The exceptions cx_shm_completion_error and cx_shm_secondary_commit are subclasses of the exception class cx_shm_detach_error and must always be dealt with (static check).","Releasing a Change Lock and Rejecting the New Version","To reject the made changes when releasing the lock, a program must call up the instance method detach_rollback( ):","METHODS detach_rollback\n\n","As with a detach_commit( ), upon the call of detach_rollback( ), the event shm_rollback_event is triggered and all methods registered for this event are started.","For an area instance without versioning, calling detach_rollback( ) results in no active version of the area exists anymore. For area instances with versioning, the previous version is still available for access. If a rollback frequently occurs when an area instance is changed, it is highly recommended to use versioning.","The following exceptions can occur when detach_rollback( ) is called:\n\n","The first two exceptions are declared as a dynamic check and thus do not force any processing. The third is static.","Releasing Several Locks","The class method detach_area( ) releases all locks in the same program session on all area instances of an area:","CLASS-METHODS detach_area\n\n","The class method detach_area( ) returns all error messages by means of the rc parameter. This has the following meaning:","cl_shm_area=>rc_done","All locks were released successfully.","cl_shm_area=>rc_nothing_to_be_done","No locks on the area instances of the specified area exist in the same program session.","Therefore, there are no locks to be released.","If a change lock is released with the class method detach_area( ), a rollback is carried out on the corresponding version of the area instance, that is, the not yet completely written or updated version is rejected.","detach_all_areas( ) is available as the most powerful method for the session-internal release of locks. With this method all locks that point to any area instance of any area in the same program session are released:","CLASS-METHODS detach_all_areas\n\n","The return parameter rc has the following meaning:","cl_shm_area=>rc_done","All locks were released successfully.","cl_shm_area=>rc_nothing_to_be_done",{"@attributes":{"id":"p-0175","num":"0000"},"ul":{"@attributes":{"id":"ul0044","list-style":"none"},"li":{"@attributes":{"id":"ul0044-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0045","list-style":"none"},"li":"No locks on the area instances in the shared objects memory exist in the same program session. Therefore, there are no locks to be released."}}}},"If a change lock is released with the class method detach_all_areas( ), a rollback is carried out on the corresponding version of the area instance, that is, the not yet completely written or updated version is rejected.","Invalidating an Active Version","To prevent that new read or update users attach to an area instance version, an area instance version can be flagged as out-of-date. Following the execution of invalidate_instance( ), an already attached read user can continue with their read session on the corresponding area instance version. However, it is not possible to set a new read or change lock on this area instance version. From a functional view point, invalidate_instance( ) only sets the active version of the area instance to out-of-date. This activity can also be referred to as soft deletion:",{"@attributes":{"id":"p-0179","num":"0257"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"CLASS-METHODS invalidate_instance"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"IMPORTING","inst_name","TYPE shm_inst_name"]},{"entry":[{},{},{},"\u2003DEFAULT"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"cl_shm_area=>default_instance"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"terminate_changer TYPE bool"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},{},"\u2003DEFAULT true"]},{"entry":[{},"RETURNING","value(rc)","TYPE shm_rc."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},"If a change lock is on the area instance when invalidate_instance( ) is executed, the change user is not affected by this class method in the case of terminate_changer = false. If terminate_changer = true applies, the change lock is released.","For the class method invalidate_instance( ), a distinction must again be made between non-transactional and transactional areas: For non-transactional areas invalidate_instance( ) is executed immediately. For a transactional area, the area instance is not invalidated before with the next database commit.","By execution the invalidate_instance( ) after the database commit, the area version created as follows is never active since it expires again immediately after the database commit:","cl_my_area=>invalidate_instance( terminate_changer = true ).","handle = cl_my_area=>attach_for_write( ).",". . . \u201d Code for area build","handle\u2212>detach_commit( )",". . . \u201d explicit or implicit database commit","The return parameter rc of the class method invalidate_instance( ) can assume the following values for non-transactional area instances.",{"@attributes":{"id":"p-0189","num":"0267"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["cl_shm_area=>rc_done","The active area instance version was"]},{"entry":["\u2003\u2003terminate_changer = true:","successfully set to out-of-date or a change"]},{"entry":[{},"lock was released."]},{"entry":["terminate_changer = false:","The active area instance version was"]},{"entry":[{},"successfully set to out-of-date."]},{"entry":["cl_shm_area=>rc_nothing_to_be_done","Neither an active area instance version nor a"]},{"entry":["\u2003\u2003terminate_changer = true:","change lock on the specified area instance"]},{"entry":[{},"exist in the shared objects memory."]},{"entry":["terminate_changer = false:","An active area instance version does not exist"]},{"entry":[{},"in the shared objects memory."]},{"entry":["cl_shm_area=>rc_instance_name_not_found","The specified area instance does not exist."]},{"entry":"\u2003\u2003terminate_changer = true:"},{"entry":["terminate_changer = false:","The specified area instance does not exist."]},{"entry":["cl_shm_area=>rc_done","is always returned for transactional area instances."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The class method invalidate_area( ) to perform a soft deletion of all area instances:",{"@attributes":{"id":"p-0191","num":"0269"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"CLASS-METHODS invalidate_area"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"IMPORTING terminate_changer","TYPE bool"]},{"entry":[{},{},"\u2003\u2003DEFAULT true"]},{"entry":[{},"RETURNING value(rc)","TYPE shm_rc."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"The same distinction between transactional and non-transactional areas that was made for invalidate_instance( ) has to be made for invalidate_area( ). In the case of a non-transactional area, the return parameter rc returns the following information:",{"@attributes":{"id":"p-0193","num":"0271"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"terminate_changer = true:","terminate_changer = false:"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["cl_shm_area=>rc_done","The active versions of all area","The active versions of all area"]},{"entry":[{},"instances of the area were","instances of the area were"]},{"entry":[{},"successfully set to out-of-date","successfully set to out-of-date."]},{"entry":[{},"and\/or all change locks were"]},{"entry":[{},"released."]},{"entry":["cl_shm_area=>","Neither an active version of an area","An active version of an"]},{"entry":["rc_nothing_to_be_done","instance nor a change lock exists","area instance does not exist"]},{"entry":[{},"in the shared objects memory.","in the shared objects memory."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"For transactional area instances, cl_shm_area=>rc_done is always returned.","Cross-server Synchronization of Area Instances","If an area instance is accessed from different servers, the change to the area contents on one server must be communicated to the other servers. The change information is forwarded by sending synchronization records. The receipt of a synchronization record results in the active version of the corresponding area instance being flagged as out-of-date. For this reason, the synchronization of an area instance is equivalent to calling the class method invalidate . . . ( ) with terminate_changer = true on all servers involved in the synchronization.","The class methods for synchronization are only generated if the area is flagged at design time as capable of being synchronized. Synchronization occurs with the next database commit.","The class method synchronize_instance( ) can be used for synchronizing an area instance:","CLASS-METHODS synchronize_instance\n\n","The parameter affecting_local_server can be used to control whether the synchronization records are also to be sent to the server, where the class method synchronize_instance( ) was called. If affecting_local_server = false is set, only all other servers execute invalidate . . . and not the calling server. The intention of this setting to preserve a version newly created on a server and to invalidate only the active versions on other servers. If affecting_local_server = true is set, the active versions of the area instance are invalidated on all servers. This setting can be used if, after changes to the database contents, the contents of the area instance are to be changed with the help of the area constructor. In addition, the use of this option simultaneously activates the area changes on all servers.","If all area instances of an area are to be synchronized, the class method synchronize_area( ) must be called.","CLASS-METHODS synchronize_area\n\n","The methods synchronize_instance( ) and synchronize_area( ) do not return any error messages.","Deleting Versions","In addition to the soft deletion of area instances on a server (invalidate . . . ( )), the option to hard delete an area instance locally on a server also exists. The hard deletion does not only prevent new read users from attaching to an area instance but also that all existing shared locks are released.","The class method free_instance( ) can be used for hard deletion:",{"@attributes":{"id":"p-0207","num":"0293"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CLASS-METHODS free_instance",{}]},{"entry":[{},"\u2003\u2003IMPORTING inst_name","TYPE shm_inst_name"]},{"entry":[{},{},"\u2003\u2003DEFAULT"]},{"entry":[{},"cl_shm_area=>default_instance"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"terminate_changer","TYPE bool"]},{"entry":[{},{},"\u2003\u2003DEFAULT true"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"RETURNING value (rc)","TYPE REF TO cl_shm_rc"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"RAISING\u2003\u2003cx_shm_parameter_error."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"As for the soft deletion with the class method invalidate_instance( ), free_instance( ) is immediately executed only for non-transactional areas. For transactional areas, the area instance is not hard deleted before with the next database commit. For non-transactional areas, the return parameter rc contains the following values:",{"@attributes":{"id":"p-0209","num":"0295"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"terminate_changer = true:","terminate_changer = false:"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["cl_shm_area=>rc_done","All area instance versions were","All area instance versions were"]},{"entry":[{},"successfully set to out-of-date","successfully set to out-of-date."]},{"entry":[{},"and\/or a change lock was released."]},{"entry":["cl_shm_area=>","Neither an active nor out-of-date","Neither an active nor an out-of-date"]},{"entry":["\u2003\u2003rc_nothing_to_be_done","area instance version nor a change","area instance version of the"]},{"entry":[{},"lock on the specified area","specified area instance exists"]},{"entry":[{},"instance exists in the shared","in the shared objects memory."]},{"entry":[{},"objects memory."]},{"entry":["cl_shm_area=>","The specified area instance","The specified area instance"]},{"entry":["rc_instance_name_not_found","does not exist.","does not exist."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"For transactional areas, the class method always returns cl_shm_area=>rc_done.","The class method free_area( ) can be used for the hard deletion of all area instances of an area:",{"@attributes":{"id":"p-0212","num":"0298"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"CLASS-METHODS free_area"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"IMPORTING terminate_changer","TYPE bool"]},{"entry":[{},{},"\u2003\u2003DEFAULT true"]},{"entry":[{},"RETURNING value (rc)","TYPE REF TO cl_shm_rc"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"RAISING\u2003\u2003cx_shm_parameter_error."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Only for non-transactional areas, the area instances are immediately hard deleted after free_area( ) is called. For transactional areas, the deletion is only carried out after with the next database commit.","For non-transactional areas, the return parameter rc returns one of the following values:",{"@attributes":{"id":"p-0214","num":"0300"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"terminate_changer = true:","terminate_changer = false:"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["cl_shm_area=>rc_done","All versions were successfully","All versions were successfully"]},{"entry":[{},"set to out-of-date or a change","set to out-of-date."]},{"entry":[{},"lock was released."]},{"entry":["cl_shm_area=>rc_nothing_to_be_done","Neither an active nor","Neither an active nor an"]},{"entry":[{},"out-of-date version nor a","out-of-date version exists in"]},{"entry":[{},"change lock exists in the","the shared objects memory."]},{"entry":[{},"shared objects memory."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"For transactional areas, the class method always returns cl_shm_area=>rc_done.","Note that free . . . ( ) only sets active and out-of-date versions to out-of-date. This is done by invalidation of the active area instance version and the detaching of all read users from all versions of the area instance. Optionally, a possibly active exclusive lock can also be released. In addition, free . . . ( ) can be used to explicitly displace area instances. The memory occupied by out-of-date versions is automatically released with the help of the garbage collector.","Determining the Area Instances","The class method get_instance_infos( ) returns all names of area instances being built, and of active and out-of-date area instances for the defined area. The return value provides the current status of the specified shared objects memory area, which can change any time.",{"@attributes":{"id":"p-0219","num":"0305"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"CLASS-METHODS get_instance_infos"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"RETURNING value(infos) TYPE shm_inst_infos."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"The back given table is of the row type shm_inst_info:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["TYPES:","BEGIN OF shm_inst_info,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"client","TYPE mandt,"]},{"entry":[{},"name","TYPE shm_inst_name,"]},{"entry":[{},"versions_in_build","TYPE i,"]},{"entry":[{},"versions_active","TYPE i,"]},{"entry":[{},"versions_obsolete","TYPE i,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"END\u2003\u2003OF shm_inst_info."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["TYPES:","shm_inst_infos TYPE TABLE OF shm_inst_info."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The first column of the table contains the actual client in the case of client-dependent areas; a blank client is provided otherwise. The second column contains all names (name) of the area instances. The following three columns contain the number of the versions of the area instance being built (versions_in_build), active versions (versions_active) or out-of-date versions (versions_obsolete). A version, for which an area commit has failed, but which has not yet been rejected with an area rollback, is also regarded as out-of-date. Logically, the columns versions_in_build and versions_active can only contain the values 0 or 1. In the column versions_obsolete the values 0 to n are possible. In this case, n is the version number of the area instance. Since out-of-date area instances are not listed, each table entry contains at least one value other than 0.","If the table is initial, no area instances exist. If the default area instance name stored in the constant cl_shm_area=>default_instance is used, a table entry contains the contents of this constant ($DEFAULT_INSTANCE$).","Handle Types","The instance method get_lock_kind( ) can be used to test whether an area handle was used for reading, updating or writing:","METHODS get_lock_kind\n\n",{"@attributes":{"id":"p-0225","num":"0312"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["cl_shm_area=>lock_kind_read","It is a read handle."]},{"entry":["cl_shm_area=>lock_kind_write","It is a write handle."]},{"entry":["cl_shm_area=>lock_kind_update","It is an update handle."]},{"entry":["cl_shm_area=>","A detach_commit ( ) was already"]},{"entry":["lock_kind_completion_error","called on this change handle."]},{"entry":[{},"However, an error occurred during"]},{"entry":[{},"the commit so that now only a"]},{"entry":[{},"rollback is allowed on this handle."]},{"entry":["cl_shm_area=>lock_kind_detached","The area handle was already"]},{"entry":[{},"released with detach."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"To enable session memory to be treated as a shared objects memory area when creating a data object with CREATE, a roll area handle exists. This roll area handle is an instance of the class cl_shm_roll_area and can also be specified as handle following the keyword AREA HANDLE for CREATE. In this case, the data object is created in the roll area (i.e., a part of session memory) as for CREATE without the keyword AREA HANDLE.","The instance method is_roll( ) can be used to distinguish whether it is an area handle or a roll area handle:","METHODS is_roll\n\n","If is_roll( ) is called on a handle already released with detach . . . ( ), the instance method returns false.","Status of the Handles","The instance method get_detach_info( ) allows one to determine the reason for an invalid area handle:","METHODS get_detach_info\n\n",{"@attributes":{"id":"p-0233","num":"0322"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["cl_shm_area=>","The area handle is still valid. This value is also"]},{"entry":["\u2003\u2003detach_info_not_detached","returned if a commit has failed on the area"]},{"entry":[{},"handle, but a rollback has not occurred yet. This"]},{"entry":[{},"value is also returned when"]},{"entry":[{},"get_detach_info ( ) was called on the roll area handle."]},{"entry":["cl_shm_area=>","The shared or change lock was explicitly released with"]},{"entry":["\u2003\u2003detach_info_handle","detach ( ), detach_commit ( ) or detach_rollback ( )"]},{"entry":["cl_shm_area=>","The shared or change lock was released through"]},{"entry":["\u2003\u2003detach_info_area","a detach_area ( ) or detach_all areas ( ) ."]},{"entry":["cl_shm_area=>","The shared lock was released through a"]},{"entry":["\u2003\u2003detach_info_attach","attach_for_write ( ) with attach_mode ="]},{"entry":[{},"cl_shm_area=>attach_mode_detach._read user."]},{"entry":["cl_shm_area=>","The change lock was released through an invalidate . . . ( )"]},{"entry":["\u2003\u2003detach_info_invalidate","with terminate_changer = true."]},{"entry":["cl_shm_area=>","The change lock was released through a"]},{"entry":["\u2003\u2003detach_info_synchronize","synchronize . . . ( ) ."]},{"entry":["cl_shm_area=>","The shared or change lock was released through"]},{"entry":["\u2003\u2003detach_info_free","a free . . . ( ) ."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The instance method is_valid( ) can be used to check whether a handle can be used to also access an area instance version:","METHODS is_valid\n\n","If the access is still possible, the method returns true. Otherwise false is returned. If is_valid( ) is called on the roll area handle, true is returned.","In addition to get_lock_kind( ) and get_detach_info( ), is_valid( ) provides a simple test regarding the validity of the handle.","The instance method is_active_version( ) can be used to check whether the handle still points to the active version of the area instance:","METHODS is_active_version\n\n","If the handle still points to the active version, the method returns true. If the handle is used to access an out-of-date version or the handle has already been released, false is returned. If the method is_active_version( ) is called on a change handle, it also returns false.","If is_active_version( ) is called on the roll area handle, true is returned.","The instance method has_active_attributes( ) can be used to check whether the current dynamic area attributes correspond to the attributes of the area instance:","METHODS has_active_attributes\n\n","The method has_active_attributes( ) is called from a handle, which points to the area instance version v of the area g. t is the point in time, at which the build of the version v was started. The method has_active_attributes( ) returns false if the dynamic area attributes of the area g were changed after the point in time t.","If has_active_attributes( ) is called on the roll area handle, true is returned.","Link to the Data Class","Before one can work with an area instance, one must assign an instance of the root data class to it. This object corresponds to the root object of the area. The assignment of the root object can be changed after every attach_for_write( ) or attach_for_update( ). The instance method set_root( ) can be used to change the assignment. This method changes the value of the read-only attribute root.","METHODS set_root\n\n","With the method set_root( ), only one other instance of the root data class can be specified. The specification, from which class the root object for this area instance must be created, is made using the maintenance tool at design time.","Note that prior to the detach_commit( ), the root object must have been set. In addition, all objects accessible from the root object must lie in the same area instance as the root object. Otherwise, an exception occurs with the area commit.","The following exceptions can result from executing set_root( ):\n\n","Both exceptions are declared as a dynamic check and thus do not force any processing.","To access the root object of an area instance, a program can directly access the read-only attribute root in the area class.","DATA root TYPE REF TO cl_my_data READ-ONLY.","If the area handle has already been released with detach, a runtime error that cannot be caught occurs when the attribute root is accessed.","The method get_root( ) for determining the root object should only be used in exceptional cases in which the program must generically deal with several area handles for different areas with different root data classes.","METHODS get_root\n\n","Area Constructor","The user can activate the automatic build of the area instance in the maintenance tool at design time using the parameters refresh time (refresh_time) and the autostart attribute (build_kind). It is therefore possible to regularly update the area instance, create the area instance\u2014if need be\u2014or to always hold it active in the shared objects memory. An area constructor is needed so that an area instance can be built automatically. If the automatic build of an area instance is activated, the area constructor must exist. If no automatic build of the area instance is to be carried out, the specification of the area constructor is voluntary.","The area constructor corresponds to the class method build( ) that must be implemented in its own class (for example, cl_my_area_constructor). The name of the area constructor class is defined at design time. The area constructor must be made available by means of the interface if_shm_build_instance:","CLASS-METHODS if_shm_build_instance-build\n\n","This class method is automatically called at the points in time specified at design time. It is also possible to call the area constructor directly by means of the class method build( ) lying in the generated area class (for example cl_my_area):","CLASS-METHODS build\n\n","When implementing the area constructor method build( ), one should adhere to the following framework:","CLASS cl_my_area_constructor IMPLEMENTATION.\n\n","The area constructor must set an exclusive lock on the area instance at the beginning, which is then released at the end of the area constructor again. With attach_for_write( ) it is necessary to pass the area instance name so that the area constructor does not only generate the area instance with the default name. Even with the automatically started area constructor it is not certain that it is possible to set the exclusive lock. For this reason, all exceptions should be caught and using cx_shm_build_failed be passed on to the caller of the constructor using the instance attribute previous. In an automatically started area constructor, exceptions are logged and the constructor is aborted.","As with every build of an area instance, the area constructor must create a root object.","If the area constructor is automatically started, for example, through an attach_for_read( ), the read request does not wait until the build of the area instance with the area constructor is completed, but immediately returns to the application program with an exception. The automatically called area constructor therefore runs parallel to the application program. A database commit must be carried out so that the version for transactional areas created by the area constructor is activated immediately after the end of the area constructor. However, this database commit must not have any influence on the database commit behavior of the application program. For this reason, the automatically called area constructor for transactional and non-transactional areas runs in a separate database transaction. The database commit, necessary for transactional areas, must be explicitly called in the area constructor since no automatic database commit occurs at the end of the transaction.","If the area constructor is called by means of the class method build( ), it does not run in a separate database transaction. It might not always be desired that the database commit is executed in the area constructor when the area constructor is started with the method build( ). Since the database commit in the area constructor is required for the automatic build of the area, the distinction must be made in the area constructor whether it was started automatically or explicitly by means of the method build( ). The parameter invocation_mode can be used to make this distinction. If the area constructor is started by means of the method build( ) and the parameter invocation_mode is not passed, it receives the default value cl_shm_area=>invocation_mode_explicit in the area constructor. If the area constructor is called automatically, the parameter invocation_mode receives the value cl_shm_area=>invocation_mode_auto_build. By means of a simply query for the parameter invocation_mode at the end of the area constructor, it is possible to execute the database commit only for an automatically called area constructor.","If the area constructor is started through a build( ) method, it runs under the current user. If the constructor is started automatically, it runs under a special system user. A developer can establish the attributes of the system user for an area using the development tool.","Client-Dependent Areas","The concept of client-dependent areas derives from client-dependent tables in SAP R\/3 databases. There are two types of tables in an R\/3 database: client-dependent and client-independent. In an R\/3 system, a client is a self-contained unit with separate master records and its own set of table data (in commercial, organizational, and technical terms). A table is client-dependent if the first field is of type CLNT. By convention, this field is always named MANDT. The logon client mechanism divides the rows within a client-dependent table into distinct groups. To access a different set of data, the user logs on and specifies a different client number.","With client dependency, shared objects memory areas behave in an analogous way. A developer can declare an area to be client-dependent or client-independent using the static area attribute is_client dependent. With client-dependent areas, two area instances are only the same if the instance name and client are the same.","When called from a client-dependent area, the methods attach_for_read( ), attach_for_write( ), attach_for_update( ), multi_attach( ), detach_area( ), detach_all_areas( ), invalidate_instance( ), invalidate_area( ), synchronize_instance( ), synchronize_area( ), free_instance( ), free_area( ) and get_instance_infos( ) always act on the current client area.","In addition, the client can be an explicit parameter to the following methods:","1) The methods attach_for_read( ), attach_for_write( ) and attach_for_update( ) have the optional importing parameter client of type mandt. This makes it possible to set a lock on an area for an arbitrary client. If the parameter client is not provided, the current client is used.","2) The method multi_attach( ) can in one call be called for both client-independent and client-dependent areas.","3) The methods detach_area( ), invalidate_instance( ), invalidate_area( ), synchronize_instance( ), synchronize_area( ), free_instance( ), free_area( ) and get_instance_infos( ) have an optional client parameter. If the methods are called with the parameter client, the methods operate only on areas of the indicated client. Otherwise, they operate only on the current client. For the methods to operate on all clients, the parameter client should be given the constant value cl_shm_area=>all_clients.","The method detach_all_areas( ) does not have an optional client parameter. It always operates on all locks of a program session, regardless of client status.","The method build( ) does not have an optional client parameter. With this method an area can only be constructed for the current client. For an automatic area construction, the current client is set so that the area is constructed for the desired client.","With client-dependent areas, user-specific area attributes can be established for each client.","Displacing an Area Instance","An area instance can only be displaced when there are not any readers left on this area instance. Only the active version of the area instance is then left (in case of displacement) in the shared objects memory.","If an area instance may be displaced from the shared objects memory because of a lack of memory, the developer can choose from two displacement types in the area attributes.","In the first case, the area instance is simply invalidated, that is, the active version expires. A new read access on the area instance is not possible until the area instance has been built again.","The second displacement type saves the contents of the area instance to disk. The area instance is loaded into the shared objects memory again with a new read or change access. To realize the storage and loading operations, it is necessary to implement the tag interface if_serializable_object in each class instantiated in the area instance. For this purpose, the methods serialize_helper( ) and deserialize_helper( ) may have to be implemented in the class.","Attributes of the Class cl shm roll area","So that programming using a shared objects memory area can be the same as programming using the roll area, a distinguished area class exists for the roll area. The class cl_shm_roll_area represents this distinguished area class for the roll area. An instance of the class cl_shm_roll_area thus represents a roll area handle. As all generated area classes, cl_shm_roll_area also inherits from the class cl_shm_area.","It does not make any sense, however, to call the instance methods made available by cl_shm_area for the roll area, except for is_roll( ), get_detach_info( ), is_valid( ), is_active_version( ) and has_active_attributes( ). For this reason, the following instance methods are redefined in the class cl_shm_roll_area so that calling these methods returns the exception cx_shm_roll_handle of the type cx_no_check: detach( ), detach_commit( ), detach_rollback( ), get_lock_kind( ), and get_root( ).","Unlike the generated area classes, the class cl_shm_roll_area does not contain any methods that are not contained in the class cl_shm_area.","Area Attributes","The generated area class inherits the following read-only instance attributes from cl_shm_area, which represent the area attributes set at design time. The area attributes are automatically filled with the help of the instance constructor during the creation of a new area instance version. The values of the attributes are stored in a database table.","The maintenance tool can be used to change the area attributes.","Static Area Attributes","Once static area attributes are changed, all area instance versions of the area are automatically flagged as out-of-date. If there are reading or changing users working on the versions, they are detached. After static area attributes have been changed, it is not possible to set a new shared or update lock on the area instances of the area.","A developer key is necessary for changing the static area attributes.","Area name:","CONSTANTS area_name TYPE shm_area_name VALUE . . .","This attribute contains the name of the area. The area name corresponds to the class name. After changing this attribute, the area class is regenerated.","This attribute is stored as a constant in the generated class and does not lie in the class cl_shm_area.","Name of the Root Data Class:","The name of the root data class is not directly stored in an attribute of the area class.","To ensure a type-stable access to the attribute root, ROOT is typed in the generated area class with REF TO cl_ . . . (name of the root data class). A change to the name of the root data class thus forces the regeneration of the area class.","Client dependency:","DATA is_client_dependent TYPE bool READ-ONLY.","The value of this flag is false if the area is client independent. This is the default value. If the value is true, there will be a client-dependent separation of area instance versions.","Active or Inactive Versioning:","This flag specifies whether the area in question is an area with or without versioning. The default value is false, that is, the area does not have a versioning. If has_versions is set to true, a maximum version number (attribute max_versions) must be defaulted.","Context for binding all area instances of an area:","DATA life_context TYPE shm_life_context READ-ONLY.","In the area administration a context determining visibility and lifetime is assigned to an area. Area name and area instance name are unique for each context. One of the following four binding contexts must be specified:",{"@attributes":{"id":"p-0310","num":"0449"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["cl_shm_area=>","The area instances of the area live just as"]},{"entry":["\u2003\u2003life_context_appserver","long as the application server does. This is"]},{"entry":[{},"the default value. Shared objects memory"]},{"entry":[{},"areas are logically attached to an applica-"]},{"entry":[{},"tion server instance and not to the host."]},{"entry":[{},"With several parallel application server"]},{"entry":[{},"instances on the very same host, the areas"]},{"entry":[{},"therefore exist, independent from one"]},{"entry":[{},"another, once per application server"]},{"entry":[{},"instance."]},{"entry":["cl_shm_area=>","The lifetime of the area instances of the"]},{"entry":["\u2003\u2003life_context_session","area depends on the lifetime of the user."]},{"entry":["cl_shm_area=>","The area instances of the area live just as"]},{"entry":["\u2003\u2003life_context_mode","long as the user session does."]},{"entry":["cl_shm_area=>","The lifetime of the area instances of the"]},{"entry":["\u2003\u2003life_context_memory","area depends on the lifetime of the"]},{"entry":[{},"respective program session."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Transactional areas:","DATA is_transactional TYPE bool READ-ONLY.","If the value of this flag is true, each change to the area instances of the area is only activated with the database commit. This ensures that the data in the shared objects memory and on the database is consistent. Otherwise, the user must take his own precautions regarding the consistency of the area contents with the database contents.","At design time, the value true is defaulted for the parameter is_transactional.","Synchronization of the area:","DATA sync_kind TYPE shm_sync_kind READ-ONLY.","This attribute specifies when and by whom the synchronization method synchronize . . . ( ) for sending the synchronization records is called:",{"@attributes":{"id":"p-0318","num":"0457"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["cl_shm_area=>sync_kind_none","No synchronization mechanism is"]},{"entry":[{},"available. In this case, the method"]},{"entry":[{},"synchronize . . . ( ) is not generated."]},{"entry":["cl_shm_area=>","The user calls the method"]},{"entry":["\u2003\u2003sync_kind_user_triggered","synchronize . . . ( ) himself."]},{"entry":["cl_shm_area=>","The synchronization method"]},{"entry":["\u2003\u2003sync_kind_automatic","synchronize_instance ( ) is"]},{"entry":[{},"automatically called with each change"]},{"entry":[{},"to one of the elements specified under"]},{"entry":[{},"dependencies. With the automatic call"]},{"entry":[{},"of the synchronization method, the"]},{"entry":[{},"synchronization record is sent to all"]},{"entry":[{},"servers (affecting_local_server ="]},{"entry":[{},"true). The user can also call the"]},{"entry":[{},"synchronization method explicitly as"]},{"entry":[{},"can be done with setting"]},{"entry":[{},"sync_kind_user_triggered."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Dynamic Area Attributes","If the dynamic attributes of an area are changed, this change is valid as of the next write operation in an area instance of this area. The version active at the time when the area attributes were changed and all out-of-date versions are not affected by the change. A shared lock can therefore be set on the area instances of this area also after the change of the dynamic area attributes.","A developer key is required for changing the dynamic area attributes.","The method has_active_attributes( ) allows the program to check whether the dynamic area attributes were changed after the area instance version was created.","If the changes of the dynamic area attributes are to be activated immediately, an invalidate . . . ( ), synchronize . . . ( ) or free . . . ( ) is to be executed on the area instances.","Area instance name:","DATA inst_name TYPE shm_inst_name READ-ONLY.","This attribute contains the area instance name. This may have a maximum of 80 characters.","Client:","DATA client TYPE mandt READ-ONLY.","This attribute contains the client name of the client for the area. In the case of client-independent areas, this attribute has a null value of space.","Automatic area structure:","DATA is_auto_build TYPE bool READ-ONLY.","If is_auto_build is set to false, no automatic build of the area instances of this area is possible.","The automatic area build is only possible for areas that are linked to the application server regarding their lifetime and visibility. In addition, a constructor class is needed for the automatic area build. The points in time, at which the automatic area build is to occur are set by means of the attribute build_kind.","The default value is true.","A refresh time not equal to 0 can only be specified for areas with is_auto_build = true.","Dependencies for area synchronization:","CLASS-DATA dependencies TYPE shm_dependencies READ-ONLY.","All elements, whose change should trigger the corresponding synchronization method to be started, must be entered in this table. This table is only generated if the attribute sync_kind was set to cl_shm_area=>sync_kind_automatic.","The names of the following elements can be stored in the table: programs, database tables, type group types, class pools, global types, local types, global classes and local classes. Every time the definition of an element contained in the table or the data stored in an element is changed, the synchronization method is triggered.","Name of the constructor class:","DATA auto_build_class_name TYPE shm_build_class_name READ-ONLY.","In this constant, the name of the class is specified which uses the interface","if_shm_build_instance to implement the constructor for the automatic build of the area instances.","Only if the auto_build_class_name is not INITIAL can the attribute is_auto_build assume the value true.","Attribute for displaceability:","DATA displace_kind TYPE shm_displace_kind READ-ONLY.","This attribute specifies whether the area instances of the area may be displaced. An area instance can be displaced only if no reader is attached to this area instance anymore. If an area is displaced with build_kind = cl_shm_area=>build_kind_due_to_invalidation or build_kind_startup, it is only automatically built after the displacement again when a new read request is made.",{"@attributes":{"id":"p-0347","num":"0486"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["cl_shm_area=>displace_kind_none","The area instances cannot be"]},{"entry":[{},"displaced. This is the default value."]},{"entry":["cl_shm_area=>","The area instances can be dis-"]},{"entry":["\u2003\u2003displace_kind_serializable","placed. Prior to displaclng, the area"]},{"entry":[{},"contents is written to the hard disk."]},{"entry":[{},"With a read or update access to the"]},{"entry":[{},"area instance, it is then loaded into"]},{"entry":[{},"the memory again."]},{"entry":["cl_shm_area=>","The area instances can be dis-"]},{"entry":["\u2003\u2003displace_kind_displaceable","placed. The area contents are lost"]},{"entry":[{},"with the displacement."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"User-Dependent Area Attributes","As the dynamic attributes, the user-dependent area attributes are valid only as of the next change of the area instances belonging to this area. Also no area instance version is invalidated with the change of the user-dependent area attributes.","The difference between user-dependent and dynamic area attributes is that user-dependent area attributes can be changed by a user without developer rights. Maximum version number:","DATA max_versions TYPE i READ-ONLY.","This figure provides the maximum number of versions that are simultaneously available for each area instance of this area. Expired areas are not considered with the specification of the version number. If the value 0 is entered, the version number is unlimited.","For areas without versioning (has_versions = false) this value always has the value 1.","If the area is an area with versioning (has_versions = true), max_versions can be set to any value other than 1.","Attribute for Autostart:","DATA build_kind TYPE shm_build_kind READ-ONLY.","This attribute can be used to control when the area instances of the area are to be built automatically with the help of the area constructor.",{"@attributes":{"id":"p-0357","num":"0496"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["cl_shm _area=>","An area instance is not built automatically. This value"]},{"entry":["\u2003\u2003build_kind_none","is assigned to the attribute build_kind if"]},{"entry":[{},"is_auto_build = false is valid. For areas with"]},{"entry":[{},"is_auto_build = true, this value cannot be"]},{"entry":[{},"assigned to the attribute build_kind."]},{"entry":["cl_shm_area=>","If no active version of the area instance exists, the area"]},{"entry":["\u2003\u2003build_kind_due_to_read_request","constructor is automatically called with a read-request."]},{"entry":[{},"This is the default value for areas with"]},{"entry":[{},"is_auto_build = true."]},{"entry":["cl_shm_area=>","The area constructor starts at the points in time described"]},{"entry":["\u2003\u2003build_kind_due_to_invalidation","under build_kind_due_to_read request. In addition,"]},{"entry":[{},"the area constructor is called when the active area"]},{"entry":[{},"instance version is set to out-of-date or expired, without a"]},{"entry":[{},"new active area instance version being created in this"]},{"entry":[{},"case. This setting ensures that an existing area instance is"]},{"entry":[{},"kept alive."]},{"entry":["cl_shm_area=>","The area constructor starts at the points in time described"]},{"entry":["\u2003\u2003build_kind_startup","under build_kind_due_to_invalidation. Area"]},{"entry":[{},"instances of the area are additionally created upon each"]},{"entry":[{},"restart of the system. The names of the area instances to"]},{"entry":[{},"be generated must be entered at design time. The area"]},{"entry":[{},"instance names are stored in the table startup_list."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"An area instance that was displaced is not immediately re-built in spite of the setting build_kind_due_to_invalidation or build_kind_startup. An automatic build only occurs with a further read access on this area instance.","If this attribute is changed to build_kind_due_to_invalidation or build_kind_startup and if no active version of the area exists at the point in time of the change, no automatic build of the area is triggered for the point in time when the area attribute is changed.","List of Area Instance Names for Automatic Area Build","DATA startup_list TYPE shm_inst_names READ-ONLY.","The type shm_inst_names is defined as follows:","TYPES:","shm_inst_names TYPE HASHED TABLE OF shm_inst_name\n\n","The table contains the names of all area instances that are to be automatically created for this area when the application server is started. If the default area instance is to be created automatically, the table must contain the value $DEFAULT_INSTANCE$. This value can be added and removed by means of a check box at design time. This table is not initial (i.e., it does not have its type-specific initial value, e.g., it has no rows) only if the area attribute build_kind has the value cl_shm_area=>build_kind_startup.","Refresh time for stored data:","DATA refresh_time TYPE i READ-ONLY.","This parameter specifies a time period in minutes, after which the build of a new version is started by means of area constructor. In case of active versioning, reading users can continue to attach to the area instance during the rebuild. The counter restarts after each detach_commit( ) on the area instance. The default value is 0 minutes, that is, the area instance is never rebuilt automatically. This parameter can be set to a value other than 0 only in the case if is_auto_build = true and invalidation_time = 0.","Expiration time for the stored data:","DATA invalidation_time TYPE i READ-ONLY.","This parameter specifies a time period in minutes, after which the stored data becomes out-of-date. Out-of-date data remains accessible for already attached reading users, that is, previously set shared locks remain set. The counter restarts after each detach_commit( ) on the area instance. The default value is 0 minutes, that is, the area instance is never invalidated.","A value other than 0 can be selected only of the refresh time is 0; that is, only one of the expiration time and the refresh time can be non-zero.","For the expiration time, unlike the refresh time, no active version exists after the expiration point in time. This is also valid if build_kind = cl_shm_area=>build_kind_due_to_invalidation or build_kind_startup applies. In this case, the area constructor indeed starts only after the area instance has expired.","For area instances without versioning, it does not make a difference whether refresh time or expiration time and automatic startup of the area constructor for expired area instances is used.","Memory limit:","DATA max_version_size TYPE i READ-ONLY.","The maximum permissible size of an area instance version in kilobytes is set by the attribute max_version_size. By default, no limit is predefined for the size of an area instance version.","DATA max_area_size TYPE i READ-ONLY.","The maximum permissible size of an area in kilobytes is set by the attribute max_area_size. The current size of the area corresponds to the total of the sizes of all versions of all area instances of this area.","If both attributes max_version_size and max_area_size are set to values other than 0, which indicates there is no limit, max_version_size \u2266 max_area_size must apply.","If the maximum size of an area instance version is reduced and if the active version is greater than the specified value, read accesses to the active version are possible, but setting a change lock results in a memory error.","The Data Class","This section explains how the data created with the help of the statement CREATE. AREA HANDLE . . . must be organized in the shared objects memory.","As already mentioned with the method set_root( ), instances of data classes can be generated in the shared objects memory. A data class distinguishes itself from any class by the fact that it implements the tag interface if_shm_enabled. Through the implementation of the interface, a class indicates that their instances are prepared for a storage in the shared objects memory.","A change to the definition of a class instantiated in the shared objects memory results in the invalidation of the area instance. Also all change locks on this area instance are cancelled in this case. The shared locks however remain.","For area instances with versioning, different reading users on the same area instance (but different versions) can access data objects with the same name but with different types.","Both locally and globally defined classes can be created in the shared objects memory. When using locally defined classes in the shared objects memory, consider that when program p changes, all classes defined in p are flagged as changed. This also applies if no change at all is made to the class definition. Since with every change of a class instantiated in the shared objects memory, the area instance is invalidated. The area instance is also invalidated with each program change when local classes are used.","Different programs p, . . . , pin exist that operate on an area instance g. In addition, a program q exists that defines the local class k. All operations on the local class k are executed in program q, that is, only program q needs to know the definition of the class k. Program q is called by different programs p. With these calls, q creates instances of the class k in the area instance g or accesses already created instances.","An example for the possible use of local classes is the exclusive buffer scenario. In this scenario, only one program that accesses the shared objects memory exists most of the time.","In the shared buffer scenario, a large number of different programs directly access the data available in the shared objects memory. For this case globally defined classes are useful.","If some data d lying in an area instance is accessed only from a program p, it is sufficient if the data types are defined by d locally in the program p. Prior to the first call of the program p, it must be loaded into the roll area. This dynamic program loading is carried out already with the call of the method attach_for . . . ( ) and not only with the actual access to the program p. This results in the program component LOAD-OF-PROGRAM of the program p being already executed with the attach_for . . . In addition, a consistency check is carried out with the attach_for_read\/update( ). The consistency check tests whether the types of data lying in the shared objects memory correspond to the types known in the program. The exception cx_shm_inconsistent is triggered in the case of an error.","In addition to programs with locally defined classes and types, all global types instantiated in the shared objects memory are reloaded with the attach_for . . . ( ).","Visibility of Area Changes","Transactional vs. Non-transactional Areas Generally the data stored in the area instances depends on database contents. To receive consistent data when accessing the database and the shared objects memory, one must link the writing to the database with the writing to the shared objects memory. This behavior of database and shared objects memory can be set by means of the area attribute is transactional.","Transactional areas","The basic concept of this model is the consistency of database and area changes. Thus, the changes to area contents must be activated at the same time as the database updates. Only this always enables a consistent view of the stored data in case of dependencies between the database and the shared objects memory.","If the changing user terminates his access to the shared objects memory with detach_commit( ), the area-committed data is only activated with the next database commit. For areas with versioning, shared locks requested between the detach_commit( ) and the database commit still point to the last version confirmed with a database commit. If it is an area without versioning, a read access to the area instance is only possible after the database commit. No new exclusive lock can be set between the area and database commit. If an exclusive lock is released with an area rollback, it is possible to set a new exclusive lock already before the next database commit.","The consistency of database contents and the contents of the shared objects memory also has a disadvantage, however: none of the transactional area instances must have an exclusive lock when the database commit is executed. If an open exclusive lock still exists, a runtime error occurs that cannot be caught. Accordingly, a writing user in a transactional area instance needs the control over the database commit.","In addition, it is not possible to leave an exclusive lock open when switching to another program session. In this case, a runtime error that cannot be caught also occurs. This restriction for calling up a database commit in a new program session was introduced so that a runtime error does not occur due to the exclusive lock of another program session that has not been released yet with an area commit or detach.","If the area contents depend on database updates, area changes should be made where the database updates occur. The database updates can be carried out online or with the update.","If the database updates are carried out online, two cases are to be distinguished:","(1) The change of the database contents is made directly in the source code. Then the change of the area contents should also be made directly in the source code.","(2) The change of the database contents is done ON COMMIT. Then the area changes should also be made ON COMMIT. Variant (2) is to be preferred over (1) since the database updates in the same program session become visible immediately; the area changes, on the other hand, only with the database commit.","For the case that the database updates occur with the update, the area changes should only be made upon completion of the database update and after returning from the update.","Instead of directly changing the area contents, it is also possible to invalidate the area instance. For this case, the area constructor should exist, which then rebuilds the area instance. When linking area and database changes, the behavior of the area instance depends on two commands: the command for releasing the area update lock and the following command for terminating the database transaction.",{"@attributes":{"id":"p-0404","num":"0544"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Command for","Command for",{}]},{"entry":["releasing the area","terminating the","Behavior of the shared"]},{"entry":["update lock","database transaction","objects memory"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["detach_commit ( )","Database commit","Area changes are activated"]},{"entry":[{},{},"with the database commit"]},{"entry":["detach_commit ( )","Database rollback","Area changes are never"]},{"entry":[{},{},"activated; for area instances"]},{"entry":[{},{},"with versioning, no new"]},{"entry":[{},{},"version is generated"]},{"entry":["detach_rollback ( )",{},"Area changes are rejected"]},{"entry":[{},{},"immediately"]},{"entry":["Lock not released","Database commit","Runtime errors that cannot be"]},{"entry":[{},{},"caught"]},{"entry":["Lock not released","Database rollback","Area changes are rejected"]},{"entry":[{},{},"immediately, the lock is"]},{"entry":[{},{},"implicitly released"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Non-Transactional Areas","With the non-transactional areas model, the changes of the area contents and the changes to the database are fully detached. If the area contents and the data lying on the database are to be kept consistent, the user is responsible for the possible simultaneous change of the data in the area instance and on the database.","The advantage of this model is the possibility to keep an exclusive lock active, ignoring a database commit. Accordingly, the writing user no longer needs the control of the database commit.","Cross-server Synchronization","Generally area instances lying in the shared objects memory will be created on several application servers. If the areas involved are local areas, independent of each other, there is no need for synchronization. If the area instances are shared by several servers, the usage of synchronization mechanisms is necessary. Note that the cross-server sharing of data can be achieved only by copying the data.","From the point of view of the application development, the following points should be considered in connection with the synchronization of area contents:","Is the buffer a local or synchronized buffer?","How are the database updates made, online or with the update?","Where are the buffers needed, only online, only with the update or online and with the update?","Are resulting inconsistencies accepted if database commits and the sending of synchronization records are carried out delayed?","With synchronization records are sent through the database, a database commit is necessary after the synchronization records have been created.","The sending of the synchronization records for the area synchronization should be based on the mechanism for writing database updates. Generally, synchronization records for area instances will depend on other synchronization records (for example, on DB buffer synchronization records). On principle, the synchronization records should be sent from where also the database updates are made. If the database updates are stored in an update module, the dependent area changes and the sending of the respective synchronization records should be carried out with the update. This simultaneously activates the database updates and area changes on all servers.","Due to the shipping of the synchronization records via the database, all area synchronization records expire, in addition to the database and area changes, with a database rollback.","For transactional areas, the user can use the area attributes (sync_kind) to choose between two synchronization modes. The first mode provides the user with synchronization methods (synchronize . . . A call of these synchronization methods results in the synchronization records being written to the database. In this case, a flag can be used to control whether the server, from which the synchronization records were sent, receives a synchronization record as well. The next database commit makes the synchronization records visible for all servers, which in turn results in the expiration of the area instance.","The second mode includes the automatic sending of the synchronization records via the database. The information which area instances must be synchronized is stored in the table dependencies. As with the first mode, the user is additionally provided with two synchronization methods he can use to send the synchronization records.","Consider two time example schedules for the synchronization of area instances. In both cases, the synchronization records from Server  are sent to all other servers, but, in the first case, not to Server  (affecting_local_server = false). After the database commit, some time elapses until the synchronization records can be read from the database and the area instance is invalidated. Assuming the area constructor is automatically triggered with the invalidation of the area instance, the version created by the area constructor is available for read accesses on Server  after a while. The version created by the area constructor does not have to correspond to version 2 on Server .","In the second case, the synchronization records are sent to all servers, thus also to the sending server (affecting_local_server =true). Note that after the database commit, version 2 on Server I is active for a short time in the upper part of the chart. The receipt of the synchronization records then results in the invalidation of the area instance on all servers. In this case as well, the area constructor is configured so that it automatically starts after the invalidation of the area instances. Assuming that the area contents depends only on database contents, the area instances created by the area constructor contain the same data on all servers.","Area Invalidation Through Transport Requests","If the contents of an area instance lying in the shared objects memory depends on data, which is transferred to a current system by means of a transport request, the import of the transport request must result in the invalidation of the area instance. In the absence of a synchronization method provided for this case, the following trick can be employed. If an area instance is to be invalidated from a transport request, this transport request must modify the type definition of the root data class of the corresponding area instance. The easiest way to do this is to implement a class constant that is increased with every new transport request. An exception is then triggered by the modification of the type of the root data class when a new shared or update lock is set on the area instance.","The invention and all of the functional operations described in this specification can be implemented in digital electronic circuitry, or in computer software, firmware, or hardware, including the structural means disclosed in this specification and structural equivalents thereof, or in combinations of them. The invention can be implemented as one or more computer program products, i.e., one or more computer programs tangibly embodied in an information carrier, e.g., in a machine-readable storage device or in a propagated signal, for execution by, or to control the operation of, data processing apparatus, e.g., a programmable processor, a computer, or multiple computers. A computer program (also known as a program, software, software application, or code) can be written in any form of programming language, including compiled or interpreted languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A computer program does not necessarily correspond to a file. A program can be stored in a portion of a file that holds other programs or data, in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub-programs, or portions of code). A computer program can be deployed to be executed on one computer or on multiple computers at one site or distributed across multiple sites and interconnected by a communication network.","The processes and logic flows described in this specification, including the method steps of the invention, can be performed by one or more programmable processors executing one or more computer programs to perform functions of the invention by operating on input data and generating output. The processes and logic flows can also be performed by, and apparatus of the invention can be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).","Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer. Generally, a processor will receive instructions and data from a read-only memory or a random access memory or both. The essential elements of a computer are a processor for executing instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks. Information carriers suitable for embodying computer program instructions and data include all forms of non-volatile memory, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.","To provide for interaction with a user, the invention can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input.","The invention can be implemented in a computing system that includes a back-end component (e.g., a data server), a middleware component (e.g., an application server), or a front-end component (e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the invention), or any combination of such back-end, middleware, and front-end components. The components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (\u201cLAN\u201d) and a wide area network (\u201cWAN\u201d), e.g., the Internet.","The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.","The invention has been described in terms of particular embodiments, but other embodiments can be implemented and are within the scope of the following claims. For example, the operations of the invention can be performed in a different order and still achieve desirable results. Other embodiments are within the scope of the following claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 3"}]},"DETDESC":[{},{}]}
