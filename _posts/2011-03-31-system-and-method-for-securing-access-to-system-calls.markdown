---
title: System and method for securing access to system calls
abstract: In one embodiment, a system for securing access to system calls includes a memory, an operating system configured to execute on an electronic device, and a below-operating-system security agent. The below-operating-system security agent is configured to identify one or more resources associated with a system call for which attempted accesses will be trapped, trap an attempted access of the one or more resources that originates from the operational level of the operating system, access one or more security rules to determine whether the attempted access is authorized, and operate at a level below all of the operating systems of the electronic device accessing the one or more resources associated with a system call.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08863283&OS=08863283&RS=08863283
owner: McAfee, Inc.
number: 08863283
owner_city: Santa Clara
owner_country: US
publication_date: 20110331
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF THE INVENTION"],"p":["The present invention relates generally to computer security and malware protection and, more particularly, to a system and method for securing access to system calls.","Native operating system services can prevent security software from installing arbitrary hooking within the kernel of operating systems. Security software is thus prevented from filtering all behaviors of an electronic device, including potentially malicious actions by malware. Malware may include, but is not limited to, spyware, rootkits, password stealers, spam, sources of phishing attacks, sources of denial-of-service-attacks, viruses, loggers, Trojans, adware, or any other digital content that produces malicious activity.","The filtering functionality provided by the operating system may be limited, and only available on timelines decided by the operating system vendor. Malware can operate and reside at the same level as security software, particularly in the operating system kernel and thus compromise both the operating system and the integrity of the security software itself.","Many forms of aggressive kernel mode malware tamper with user mode memory to accomplish malicious tasks such as injecting malicious code dynamically, modifying user mode code sections to alter execution paths and redirect into malicious code, and modify user mode data structures to defeat security software. Additionally, some malware may attack anti-malware applications and processes from the kernel by tampering with process memory code and data sections to deceive the detection logic.","Malware may also attack the system call table of an operating system by hooking a system call to execute malicious code. In this manner, when a system call is executed, the malicious code may be executed instead of the intended system call of the operating system. Hooking system calls in this manner may allow malware to modify the behavior of all software that utilizes a particular system call, including the operating system itself and\/or any security software executing on the system.","Kernel mode rootkits and other malware employ various methods to hide their presence from user mode applications and kernel mode device drivers. The techniques used may vary depending upon where the infection takes place. For example, malware may attack the kernel active process list of an operating system to delist or unlink a Rootkit or other malware process. Other malware may tamper with the code sections of process access and enumeration functions.","In one embodiment, a system for securing access to system calls includes a memory, an operating system configured to execute on an electronic device, and a below-operating-system security agent. The below-operating-system security agent is configured to identify one or more resources associated with a system call for which attempted accesses will be trapped, trap an attempted access of the one or more resources that originates from the operational level of the operating system, access one or more security rules to determine whether the attempted access is authorized, and operate at a level below all of the operating systems of the electronic device accessing the one or more resources associated with a system call.","In another embodiment, a method for securing access to system calls includes identifying one or more resources associated with a system call for which attempted accesses will be trapped, trapping an attempted access of the one or more resources that originates from the operational level of an operating system executing on an electronic device, and accessing one or more security rules to determine whether the attempted access is authorized. The trapping of the attempted access and determining whether the attempted access is authorized is conducted at a level below all of the operating systems of the electronic device accessing one or more resources associated with the system call.","In yet another embodiment, an article of manufacture includes a computer readable medium and computer-executable instructions carried on the computer readable medium. The instructions are readable by a processor. The instructions, when read and executed, cause the processor to identify one or more resources associated with a system call for which attempted accesses will be trapped, trap an attempted access of the one or more resources that originates from the operational level of an operating system executing on an electronic device, and access one or more security rules to determine whether the attempted access is authorized. The processor is configured to conduct the trapping of the attempted access and determining whether the attempted access is authorized at a level below all of the operating systems of the electronic device associated with the one or more resources.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 1","b":["100","100","104","108","104","106","103","104","108","108","114","102","108","103","108","104"]},"Below-O\/S trapping agent  may be implemented at a lower functional level than the operating systems in electronic device . For example, below-O\/S trapping agent  may intercept attempted accesses of resource  by an operating system , a driver , or an application . Below-O\/S trapping agent  may be running on a processor of electronic device  without use of an operating system. In one embodiment, below-O\/S trapping agent  may be operating on a bare-metal environment or execution level. In addition, below-O\/S trapping agent  may be running at a higher execution priority, as defined by a processor of electronic device , than all operating systems of electronic device . For example, in the context of a hierarchical protection domain model using protection rings, wherein a lower number represents a higher priority, operating system  may be operating at \u201cRing0\u201d while below-O\/S trapping agent  may be operating at \u201cRing \u22121.\u201d Drivers  and applications  may be operating at \u201cRing0\u201d or \u201cRing3.\u201d In some embodiments of processors, the concept of \u201cRing \u22121\u201d may be known as \u201cRing0 privileged mode,\u201d and the concept of \u201cRing0\u201d may be known as \u201cRing0 non-privileged mode.\u201d Operation in \u201cRing \u22121\u201d or \u201cRing0 privileged mode\u201d may entail additional overhead and expense than \u201cRing0\u201d or \u201cRing0 privileged mode.\u201d Operating systems of electronic device  may run at Ring0.","Below-O\/S trapping agent  may operate transparently to entities running at Ring0 or higher. Thus the attempted access of resource  may be requested by operating system  or another entity in the same manner whether below-O\/S trapping agent  is present or not. Below-O\/S trapping agent , when enforcing a received action, may allow the request to happen, may deny the request, or take other corrective action. To deny the request, below-O\/S trapping agent  may simply not pass the request to the resource  or processor, or may provide a spoofed or dummy reply to the request to convince operating system  that the action has occurred.","By running at \u201cRing \u22121,\u201d at a higher priority than the pertinent operating systems of electronic device , or below the pertinent operating systems of electronic device , below-O\/S trapping agent  may avoid much of the malware that plagues operating systems such as operating system . Malware may trick operating system  or even anti-malware software running at \u201cRing0,\u201d as malware may also be running at \u201cRing0\u201d priority. However, malware on electronic device  must still make requests of resource  if it is to carry out malicious activities. Thus, trapping operations linked to sensitive resources may be better accomplished by a trapping agent running below the level of operating systems in electronic device .","Below-O\/S trapping agent  may be implemented in any suitable manner. In one embodiment, below-O\/S trapping agent  may be implemented in a virtual machine monitor. Such an embodiment may operate below the level of operating systems as described for below-O\/S trapping agent . Descriptions of an example of such an embodiment may be found in, for example, discussions of , below, of a security virtual machine monitor . In another embodiment, below-O\/S trapping agent  may be implemented in firmware. Such an embodiment may operate below the level of operating systems as described for below-O\/S trapping agent . Descriptions of an example of such an embodiment may be found in, for example, discussions of , below, of a firmware security agent , , or PC firmware security agent . In yet another embodiment, below-O\/S trapping agent  may be implemented in microcode. Such an implementation may operate below the level of operating systems as described for below-O\/S trapping agent . Descriptions of an example of such an embodiment may be found in, for example, discussions of , below, of a microcode security agent . Below-O\/S trapping agent  may be implemented in a combination of these embodiments.","Triggered event handler  may be embodied by one or more event handlers or security agents communicatively coupled together. Triggered event handler  and below-O\/S trapping agent  may be implemented in the same security agent. In one embodiment, triggered event handler  may be operating at the same priority ring as below-O\/S trapping agent. In another embodiment, triggered event handler  may be operating at the same priority as operating system , driver , or application . In still yet another embodiment, triggered event handler  may be implemented by two or more triggered event handlers wherein at least one triggered event handler operates at the same priority ring as below-O\/S trapping agent, and at least one triggered event handler operates at the level of operating system , driver , or application . By running at the level of below-O\/S trapping agent , triggered event handler  may similarly avoid the problems of \u201cRing0\u201d or \u201cRing3\u201d malware infecting the agent itself. However, a triggered event handler  running at \u201cRing0\u201d or \u201cRing3\u201d with operating system , driver , or application  may be able to provide context information about an attempted access of resource  that may be unavailable from the viewpoint of \u201cRing \u22121\u201d agents.","Triggered event handler  may be implemented in any suitable manner. In one embodiment, triggered event handler  may be implemented in a virtual machine monitor or virtual machine monitor security agent. Such an embodiment may operate below the level of operating systems as described for triggered event handler . Descriptions of an example of such an embodiment may be found in, for example, discussions of , below, of a security virtual machine monitor  or security virtual machine monitor security agent . In another embodiment, triggered event handler  may be implemented fully or in part in firmware. Such an embodiment may operate below the level of operating systems as described for triggered event handler . Descriptions of an example of such an embodiment may be found in, for example, discussions of , below, of a firmware security agent , , or PC firmware security agent . Triggered event handler  may also be implemented in the below-O\/S agent  in , which may itself be implemented in such ways as in a virtual machine monitor, firmware, or microcode. In yet another embodiment, triggered event handler  may be implemented in microcode. Such an implementation may operate below the level of operating systems as described for triggered event handler . Descriptions of an example of such an embodiment may be found in, for example, discussions of , below, of a microcode security agent . Triggered event handler  may also be implemented in the below-O\/S agent  of , which may itself be implemented in such ways as in a virtual machine monitor, firmware, or microcode. Triggered event handler  may be implemented in a combination of these embodiments.","In one embodiment, below-operating system trapping agent  and\/or triggered event handler  may operate in a bare metal layer of electronic device . Below-operating system trapping agent  and\/or triggered event handler  may operate without use of an operating system between them and the resource  that they are configured to protect. The resource  may include a processor, features of the processor, memory, the entities residing in the memory such as data structures, or the entities residing in the memory for execution by the processor such as functions, processes, or applications. Below-operating system trapping agent  and\/or triggered event handler  may operate directly on the hardware of electronic device . Below-operating system trapping agent  and\/or triggered event handler  may not require the use of an operating system such as operating system  to execute nor gain full access to resource .","Other operating systems may exist on electronic device  which do not participate in the relationship between entities at the level operating system , below-operating system trapping agent  and triggered event handler , and resource . For example, a pre-boot operating system may securely launch portions of electronic device, but not participate in the normal operation of electronic device in terms of handling requests from application , driver , and operating system  made of resource . In another example, electronic device  may contain motherboard components, plug-in cards, peripherals, or other components which contain their own sets of operating systems and processors to perform functions outside of the relationship between entities at the level operating system , below-operating system trapping agent  and triggered event handler , and resource . These operating systems may be embedded operating systems. Any of these operating systems might not be used for the execution of below-operating system trapping agent  and triggered event handler . Further, any of these operating systems might not access the resource  protected by trapping agent  and triggered event handler .","System  may include any combination of one or more below-operating system trapping agents  and one or more triggered event handlers . Descriptions of the below-operating system trapping agents  and triggered event handlers  may be found in descriptions of trapping agents, event handlers, and security agents in the figures that follow.","Resource  may include any suitable resource of an electronic device. For example, resource  may include registers, memory, controllers, or I\/O devices. Descriptions of example embodiments of resource  may be found in descriptions of, for example, the system resources  of , components such as display  and storage  as shown in , or the system resources  of  below.","Security rules  may include any suitable rules, logic, commands, instructions, flags, or other mechanisms for informing below-O\/S trapping agent  about what actions to trap, or for informing triggered event handler  to handle an event based on a trapped action. Triggered event handler  may be configured to provide one or more of security rules  to below-O\/S trapping agent. Descriptions of example embodiments of some or all of security rules  may be found, for example, in descriptions of security rules  of , security rules , , ,  of , security rules  of , or security rules ,  of  below.","Kernel mode and user mode entities such as application , driver , and operating system  of system  may be implemented in any suitable manner. Descriptions of example embodiments of application , driver , and operating system  of system  may be found in descriptions of, for example, application , driver  and operating system  of ; application , driver , and operating system  of ; and application , driver , and operating system  of  below.","Electronic device  may be implemented in any suitable manner, such as in a computer, a personal data assistant, a phone, mobile device, server, or any other device configurable to interpret and\/or execute program instructions and\/or process data. Descriptions of example embodiments of electronic device  may be found in discussions of, for example, electronic device  of , electronic device  of , or electronic device  of .","System  may be implemented in any suitable system for trapping attempted access of resources at a level underneath the operating systems of electronic device . System  may also be implemented in any suitable means for handling the attempted access by consulting security rules to determine whether the attempted access is malicious or not. For example, system  may be implemented by the systems and methods , , , , , , and  as described in  below.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 2","b":["200","200","100","100","200","204","200","204","204","200","204"]},"In one embodiment, system  may include protection server  communicatively coupled to one or more in-O\/S security agents  and a security virtual machine monitor (\u201cSVMM\u201d) security agent . SVMM security agent  may reside in a SVMM . SVMM  may reside and operate upon electronic device . In-O\/S security agent  and SVMM security agent  may be communicatively coupled. Protection server , in-O\/S security agent , SVMM security agent  and SVMM  may be configured to protect electronic device  from infections of malware.","SVMM security agent  may be an example embodiment of the triggered event handler  of . SVMM  may be an example embodiment of the below-O\/S trapping agent  of .","Electronic device  may include a memory  coupled to a processor . Electronic device  may include one or more applications  or drivers  executing on electronic device for any suitable purpose. Electronic device  may include an operating system . Operating system  may be configured to provide access to system resources  of electronic device  to applications  or drivers . SVMM  may be configured to intercept such calls of operating system  of system resources . SVMM  and SVMM security agent  may operate below the level of operating system . For example, SVMM  and SVMM security agent  may operate directly on processor  in a privileged mode such as \u201cRing \u22121.\u201d","Processor  may comprise, for example a microprocessor, microcontroller, digital signal processor (DSP), application specific integrated circuit (ASIC), or any other digital or analog circuitry configured to interpret and\/or execute program instructions and\/or process data. In some embodiments, processor  may interpret and\/or execute program instructions and\/or process data stored in memory . Memory  may be configured in part or whole as application memory, system memory, or both. Memory  may include any system, device, or apparatus configured to hold and\/or house one or more memory modules; for example, memory  may include read-only memory, random access memory, solid state memory, or disk-based memory. Each memory module may include any system, device or apparatus configured to retain program instructions and\/or data for a period of time (e.g., computer-readable non-transitory media).","Protection server  may be operating on a network . Protection server  operating on network  may implement a cloud computing scheme. Protection server  may be configured to communicate with elements of electronic device  to update malware detection rules and information. Protection server  may be configured to receive information regarding suspicious activities originating from electronic device  and determine whether or not such suspicious activities are indications of malware infection. Operating system  may include one or more in-O\/S security agents . In-O\/S security agent  may be configured to receive monitoring and detection rules from protection server , such as in-O\/S security rules . In-O\/S security agent  may be configured to use the in-O\/S security rules  received by protection server  to monitor and prevent suspicious activities on electronic device . In-O\/S security agent  may be configured to report detected suspicious activities back to protection server . In-O\/S security agent  may be configured to prevent malware operations and to report such preventions to protection server . If more than one in-O\/S security agent  is present in system , each in-O\/S security agent  may be configured to perform a designated portion of the trapping, validating, or other tasks associated with in-O\/S security agent . Such portions may be defined by below-operating-system security agents. For example, one in-O\/S security agent  may validate or investigate MOV instructions, while another in-O\/S security agent  may validate or investigate JMP instructions. In-O\/S security agent  may be configured to determine the life cycle of a particular page in memory. For example, in-O\/S security agent  may know the processes and steps typically used by operating system  to allocate a page of memory. Similarly, in-O\/S security agent  may know the processes and steps typically used by operating system  to load an image of an application in its loader. Such processes may follow a static pattern of operation. Thus, in-O\/S security agent  may be configured to track the operation of operating system  to determine whether for a given action standard procedures were followed. In-O\/S security agent  may communicate with SVMM security agent  to determine whether or not an operation trapped by SVMM security agent  generated the corresponding expected actions observed by in-O\/S security agent . A discrepancy may indicate that malware has attempted to perform a system function outside of the normal operation of the operating system . Thus, for example in-O\/S security agent  and SVMM security agent  may determine whether a page in question was loaded in memory directly by malware or was loaded by the operating system loader. Such a behavior may cause in-O\/S security agent  or SVMM security agent  to report information to protection server , employ more aggressive trapping and checking, or take any other corrective measures.","In one embodiment, in-O\/S security agent  may be configured to provide contextual information by embedding itself within operating system . For example, in-O\/S security agent  may be configured to register itself or a subcomponent as a driver filter, and attach itself to a main driver to determine what the driver sees or does not see. By attached as a filter to NDIS.SYS, for example, in-O\/S security agent  may be configured to report the file I\/O operations seen by the operating system  drivers.","In another embodiment, in-O\/S security agent  may be configured to provide such information observed from within operating system  to SVMM security agent  or other below-O\/S security agents for comparison with information observed below the operating system. Discrepancies between the two sets of information may indicate a presence of malware attempting to hide itself. For example, in-O\/S security agent  may hook or filter NDIS.SYS, and monitor for file writes to a particular file. SVMM security agent  may monitor input and output commands. If SVMM security agent  determined more writes than should have been seen based on the list of function calls seen by in-O\/S security agent , then malware may be clandestinely writing to disk outside of the functions provided by operating system .","Network  may be implemented in any suitable network for communication, such as: the Internet, an intranet, wide-area-networks, local-area-networks, back-haul-networks, peer-to-peer-networks, or any combination thereof. Protection server  may use the reports submitted from various security agents  running on various electronic devices  to further detect malware by applying prevalence and reputation analysis logic. For example, a suspicious behavior identified on electronic device  may be synthesized into a rule for protection server  to proactively protect other electronic devices . Such a rule may be determined, for example, based on the number of times that a suspicious driver has been reported. For example, an unknown driver with a narrow or slow distribution pattern may be associated with malware. On the other hand, an unknown driver with a wide and fast distribution may be associated with a patch of a popular and widely available application. In another example, such a detected driver may have been determined by security software running on another electronic device to have accessed a website known to host malware. Such a driver may be determined to be associated with malware.","SVMM  may implement some or all of the security virtual machine monitoring functions of system . SVMM  may be configured to intercept access to system resources\u2014such as registers, memory, or I\/O devices\u2014to one or more operating systems running on an electronic device. The security virtual machine monitoring functions of system  may be implemented using SVMM , or any other virtual machine monitor configured to protect electronic device  according to the teachings of this disclosure. SVMM  may be configured to control and filter actions taken by operating system  while operating system  attempts to access system resources , on behalf of itself or on behalf of applications  running through operating system . SVMM  may run underneath operating system  on electronic device  and may have control over some or all processor resources made available to operating system  and application  or driver . Application  may comprise any application suitable to run on electronic device . Driver  may comprise any driver suitable to run on electronic device . The processor resources made available for control by SVMM  may include those resources designated for virtualization. In one embodiment, SVMM  may be configured to virtualize system resources  for access by operating system , application , or driver . As examples only, such system resources  may include input-output devices , system memory , or processor resources . As examples only, processor resources  may include conventional registers , debug registers , memory segmentation , memory paging , interrupts  or flags . I\/O devices  may include access to such devices such as keyboard, display, mice, or network cards.","SVMM  may be configured to trap the execution of operations originating from operating system  to access system resources . SVMM  may include a control structure configured to trap specific attempted accesses of system resources . Any suitable control structure may be used. In one embodiment, such a control structure may include virtual machine control structure (\u201cVMCS\u201d) . SVMM  may be configured to trap such execution by manipulating flags inside of VMCS . SVMM  may be configured to trap any suitable operation of operating system , application , or driver  involving an access of system resources . Such trapped operations may include, for example: reading, writing and execution of particular pages of memory in system memory ; loading and storing a value to or from a processor register ; or reading and writing to or from I\/O devices . Any such operations may cause a Virtual Machine Exit (\u201cVM Exit\u201d), which may be trapped by SVMM . SVMM  may be configured to trap the generation of interrupts , which may be generated by the processor  or initiated by elements of operating system . SVMM  may be configured to trap the attempted reading and writing to or from I\/O device  by trapping IN and OUT instructions. SVMM may be configured to trap such instructions by trapping access to mechanisms, for example, of Virtualization Technology Directed I\/O (\u201cVTd\u201d). VTd may allow I\/O device virtualization according to processor . By accessing VTd facilities, SVMM security agent  may be configured to determine devices connected by VTd, determine meta information from operating system , ports on the I\/O device, or other suitable information. SVMM security agent  may be configured to control or trap the operation of such virtualized device access. For example, SVMM security agent  may be configured to determine I\/O permission maps, containing I\/O assignments given to programmable I\/O ports. SVMM security agent  may be configured to trap access to such permission maps, which may be done by malware, or use such permission maps to determine the relationship of entities on operating system  and a request of an I\/O device.","In one embodiment, SVMM security agent  may be operating in SVMM . In another embodiment, SVMM security agent  may be operating outside of SVMM , but may be communicatively coupled to SVMM . In such an embodiment, SVMM security agent  may be operating below the level of operating systems of electronic device  such as operating system . SVMM security agent  may be operating at the same level and\/or the same priority of SVMM . SVMM security agent  may be configured to handle events triggered by or trapped by SVMM . SVMM security agent  may be configured to access contents of memory  or a disk at a level below the operating system  so as to examine the contents free of interference of kernel-level rootkits. Furthermore, some operations of SVMM security agent  may be implemented by SVMM , and some operations of SVMM  may be implemented by SVMM security agent .","SVMM security agent  may be configured to set the operation of SVMM  in terms of what actions will cause a trap or trigger. In one embodiment, SVMM  may be configured to communicate the detection of trapped actions to SVMM security agent . SVMM security agent  may be configured to consult security rules  to determine whether the trapped actions indicate malware or malicious activities, and based upon security rules  may provide indications to SVMM  about what subsequent action to take. Such subsequent action may include allowing the attempted action, disallowing the attempted action, or taking other corrective steps.","The operation of trapping the attempted access and execution of system resources  by SVMM  and SVMM security agent  may be coordinated through information gathered by in-O\/S security agent . In-O\/S security agent  may be configured to provide context to the trapping and handling operations of SVMM  and SVMM security agent . For example, a particular operating system data structure may normally only be written to by a specific application or service. In-O\/S security agent  may determine what applications or processes are currently visibly running on operating system  and communicate the information to SVMM security agent . If the specific application or service is not listed as visibly running, then the attempted write to the data structure may have come from an unauthorized application or process.","In-O\/S security agent  may be configured to communicate with SVMM  and\/or SVMM security agent  via hypercalls. Hypercalls may be implemented with a descriptor table defining available requests that may be used, as well as associated input and output parameters. Such a descriptor table may define one or more requests possible for in-O\/S security agent  to communicate with SVMM  and\/or SVMM security agent . Such a descriptor table may also define where input and output parameters for such a request may be located in memory.","In-O\/S security agent , SVMM security agent , and protection server  may be configured to authenticate each other. Each of security agent , SVMM security agent  and protection server  may be configured to not continue communications with each other unless each of the entities is authenticated. SVMM  may be configured to locate the in-O\/S security agent  image in memory , and use cryptographic signing algorithms to verify the in-O\/S security agent  image in memory . Authentication between protection server , in-O\/S security agent  and SVMM security agent  may use any suitable method, including cryptographic hashing and\/or signing algorithms. In one embodiment, such authentication may involve the exchange of a private secret key. In-O\/S security agent  may be configured to receive a secret key from protection server  to verify the instance of SVMM security agent .","In-O\/S security agent  may have contextual information regarding the operation of operating system . In-O\/S security agent  may be configured to communicate with SVMM security agent  to provide such contextual information. SVMM security agent  may instruct SVMM  on, for example, how to define certain pages of memory, or which registers to trap.","SVMM  may be configured to trap access attempts to system resources  defined by SVMM security agent . For example, for traps of memory access, SVMM  may be configured to trap operations such as read, write or execute. For trapping access to processor registers , SVMM  may be instructed to trap operations including load, store, or read register values. For trapping I\/O operations, I\/O devices , SVMM  may be instructed to trap operations such as input or output to keyboards, mice, or other peripherals. SVMM security agent  and\/or other below-operating system security agents in the figures below may, in conjunction with in-operating system security agents, may be configured to determine for an I\/O operation, the identity of a target I\/O device , target operation to be performed upon the I\/O device , and the data to be transferred.","SVMM security agent  may be configured to determine contextual information, such as what entity of operating system  has attempted to access a resource of electronic device , or to what entity of operating system  a resource may belong. SVMM security agent  may be configured to make such determinations through any suitable method. In one embodiment, SVMM security agent  may be configured to access contextual information for such determinations from in-operating system security agent . In another embodiment, SVMM security agent  may be configured to, directly or indirectly, access a call stack of operating system  and\/or an execution stack of processor  to determine the order of calls made by different processes or applications of operating system . An Execution Instruction Pointer may point to the instruction causing the trigger, while an Execution Stack Pointer and Execution Base Pointer may point to the stack frames. By walking through the Execution Base Pointer through the stack, previous function calls may be identified providing context for the operation at hand. Such stacks may indicate the operation that was attempted as well as a source memory location. In yet another embodiment, SVMM security agent  may be configured to use a memory map in conjunction with security rules  to determine whether an attempt is malicious or indicative of malware. Such a memory map may, for example, indicate the entity that made an attempted access of resources, given a memory location of the attempted access. Such a memory map may be defined, for example, in virtual memory page identifiers and\/or physical memory addresses. Such a memory map may, in another example, indicate the entity corresponding to the memory location of the target of the attempt. Using the memory map, SVMM security agent  may be configured to determine the identities of the source and targets, or entity owners thereof, of an attempted access. The memory map may be created in part by SVMM security agent  or other below-O\/S security agents in the figures below in conjunction with in-operating system security agents through monitoring the execution of the system. SVMM security agent  and\/or other below-operating system security agents in the figures below may, in conjunction with in-operating system security agents, determine for a given memory page or physical address whether such a location belongs to a particular code section or data section; to which module, process, application, image, or other entity it belongs; or whether it is associated with user mode or kernel mode entries. SVMM security agent  and\/or other below-operating system security agents in the figures below may, in conjunction with in-operating system security agents, determine metadata for the mapping of virtual memory and physical memory indicating the identification, location, and permissions of various entities running on the electronic device . Similarly, SVMM security agent  and\/or other below-operating system security agents in the figures below may use a mapping of sectors in a mass storage device to determine the location of images of such entities in the mass storage device. SVMM security agent  and\/or other below-operating system security agents in the figures below may, in conjunction with in-operating system security agents, determine for a given entity the sectors, files, directories, and volumes on which they reside.","SVMM security agent  may be configured to allocate memory such as system memory  as required for operation of in-O\/S security agent , SVMM security agent , and SVMM . SVMM security agent  may be configured to request that SVMM  secure such allocated memory against unauthorized read and write operations. SVMM  may be configured to initialize the allocated memory after protection of the memory is established to eliminate the opportunity for malware to add malicious code between the time when the memory is allocated by in-O\/S security agent  and the protection is established by SVMM .","SVMM security agent  may be configured to communicate with protection server  to securely receive SVMM security rules . SVMM security rules  may comprise instructions, logic, rules, shared libraries, functions, modules, or any other suitable mechanism for instructing SVMM  about what security policies to employ. SVMM security agent  may be configured to transfer information to protection server  regarding suspicious activities and detected malware from electronic device .","In-O\/S security agent  may be configured to communicate with protection server  to receive in-O\/S security rules . In-O\/S security rules  may comprise instructions, logic, rules, shared libraries, functions, modules, or any other suitable mechanism for in-O\/S security agent  to detect malware on electronic device . In-O\/S security agent  may be configured to transmit information to protection server  regarding suspicious activities and detected malware on electronic device .","In-O\/S security rules  and SVMM security rules  may each comprise protection rules for protecting electronic device  against malware infections, and for detecting suspicious activities that may comprise malware. In-O\/S security agent security rules may contain rules executed by and within in-O\/S security agent . SVMM security rules  may contain rules executed by and within SVMM  and\/or SVMM security agent .","SVMM security rules  may be configured to provide information to SVMM security agent  with definitions of how to observe and detect malware infections of electronic device . For example, SVMM security rules  may include categorizations of what types of function calls or behaviors from entities such as application  or driver  that SVMM security agent  may monitor for indications of malware. As another example, SVMM security rules  may include definitions of how SVMM security agent  may process such triggered function calls, including what parameters to use, how to extract values from such calls, or how to validate the operation of such calls. Furthermore, SVMM security rules  may include information for in-SVMM security agent  on how to monitor the behavior of entities electronic device such as application  or driver , as well as exceptions to such behavioral detection rules. As yet another example, SVMM security rules  may include information for SVMM security agent  on how to prevent and repair malicious behaviors detected by such behavioral detection rules. SVMM security rules  may include details of what data that SVMM security agent  should monitor, collect, and send to protection server .","Similarly, in-O\/S security rules  may be configured to provide information to in-O\/S security agent  with definitions of how to observe and detect malware infection of electronic device , as well as how to coordinate such activities with SVMM security agent .","SVMM security rules  may also include rules regarding what actions SVMM  will trap. SVMM security agent  may be configured to apply such rules to SVMM . For example, SVMM security agent  may be configured to convert the address for a function to be trapped into an identifiable virtual or physical page of memory, create a request for SVMM  to trap the execution of such a page, and subsequently call the security agent  after trapping the execution. SVMM security agent  may be configured to receive SVMM security rules  through its interface with the SVMM . Such an interface may comprise a hypercall-based interface. SVMM security agent  may be configured to push any resulting detections or reports to SVMM  through the same hypercall based interface.","In one embodiment, SVMM  may be configured to process triggered actions without consulting SVMM security agent . In such an embodiment, SVMM  may be configured to install additional triggers that are processed within SVMM  which might not be passed to SVMM security agent . Such additional triggers may be defined by SVMM security rules . In one embodiment SVMM security rules  may define memory pages scanning rules for SVMM . Such rules may include a listing of entities or modifications which are malicious and should not be allowed to reside in memory. Such rules may also include a whitelist, configured to include a listing of pages that are specifically allowed to exist within system memory . In another embodiment, SVMM security rules  may define to the SVMM  memory pages access rules. Such rules may include definitions of what code pages are allowed, or conversely, prohibited to access a given code or data page. Consequently, SVMM security rules  may be configured to instruct SVMM  to act as a memory scanner, and\/or control access to memory pages.","SVMM  may be configured to protect SVMM security agent , SVMM , and in-O\/S security agent  by preventing unauthorized read and write access to their respective code and data pages in system resources . For example, if application  or driver  make a request to a portion of system memory , processor registers  or I\/O devices  which would result in affecting the integrity or operation of SVMM security agent , SVMM , and in-O\/S security agent , then SVMM  may be configured to intercept such an attempted request, and subsequently re-route the request, deny it, or take other appropriate action. In another example, SVMM  may be configured to authorize read access for portions of system memory , processor registers  or I\/O devices  affecting SVMM security agent , SVMM , and in-O\/S security agent  for memory security software applications, such as SVMM security agent  itself, or other corresponding or affiliated programs. Such an authorization may be defined within SVMM security rules , which may define to SVMM  how to handle access to system resources  such as system memory . In one embodiment, SVMM security rules  may include a whitelist of trusted security programs, which may include SVMM security agent .","To communicate with protection server , SVMM  may include a secured network interface . Secured network interface  may be configured to provide secure access between a network server such as protection server  and an element of electronic device  such as SVMM  or SVMM security agent . SVMM  may include a logical TCP\/IP driver or other communication interface, which may implement secured network interface . The protection server  may be configured to communicate via secured network interface  to instruct SVMM  or SVMM security agent  to update itself, as well as provide protection rules such as SVMM security rules  or in-O\/S security rules . Protection server  may be configured to deliver customized rules for a particular electronic device , or a particular SVMM . Such customization may include the type of malicious activities that have been reported on electronic device , along with other protection mechanisms within electronic device  such as an anti-virus program, firewall, or other protection mechanism. In one embodiment, protection server  may be operated by an administrator of electronic device  on, for example, a local network. In such a case, the administrator may set global or personalized policies for handling suspicious behavior that may be implemented by rules received from protection server . SVMM  may include an update engine that informs SVMM  or SVMM security agent  how to update itself through a new image delivered securely via protection server .","In-O\/S security rules  and SVMM security rules  may each be configured to request that particular or classes of observed actions or operations on electronic device  be passed to protection server . There, protection server may examine and verify the observations before the action is allowed to proceed on electronic device . Protection server  may be configured to accept such an action to be examined synchronously or asynchronously. In one embodiment, in-O\/S security agent  may be configured to pass questionable activities, segments of code or data, or actions to SVMM  for verification by protection server . For example, in-O\/S security agent  may detect a suspected instance of malware by detecting an unsigned driver loaded within memory. SVMM  may receive the information about the suspicious software from in-O\/S security agent , and may provide it to protection server .","SVMM security rules  may be configured to allow or deny access to any suitable system resource of electronic device. Such resources available to be monitored may depend upon the resources exposed by processor . For example, in one embodiment SVMM security rules  may be configured to allow SVMM  to restrict access to system memory , I\/O devices , and interrupts . Such a restriction may prevent unauthorized access to I\/O devices such as keyboard displays or removable discs. In another embodiment, SVMM security rules  may be configured to allow SVMM  to restrict access to interrupt descriptor table entries, including entries in processor registers such as interrupt . In yet another embodiment, SVMM security rules  may be configured to allow SVMM  to restrict access to Extended Page Tables (\u201cEPT\u201d), or any other mechanism handling the mapping of virtual memory (real memory from the perspective of a guest operating system) to host physical memory.","If electronic device  contains one or more processors besides processor  that support virtualization, SVMM  or another instance of SVMM  may be configured to intercept attempts to access the virtualized resources of such other processors. If electronic device  contains, for example, a quad-processor containing processor , the resources of the quad-processor may be protected by SVMM . If the one or more other processors do not support virtualization, SVMM  might not be able to secure access to their resources. If the one or more other processors support a different virtualization technology from processor , SVMM  may be configured to secure access to their resources if SVMM , but in a different manner than as processor  is secured, since the manner in which resources are virtualized may differ.","In operation, protection server may be running on network . In-O\/S security agent  may be running on electronic device  to protect electronic device  from malware infections, by scanning electronic device  for malware, observing the behavior of entities such as application  and driver  on electronic device  for suspicious behavior, and by repairing any such infections that were found. In-O\/S security agent  may be running at the same priority or level as operating system , and may be running in operating system . SVMM  may be operating on electronic device  to protect electronic device  from malware infection by trapping the attempted access of system resources of electronic device . SVMM security agent  may be running on electronic device , or another suitable electronic device, to set the trapping operation of SVMM  and to handle some or all of the trapped attempted accesses of system resources. SVMM  and SVMM security agent  may be running below the operating system  with a priority of \u201cRing \u22121.\u201d SVMM security agent  may be running on SVMM .","Protection server  may send security rules, such as SVMM security rules  and in-O\/S security rules , to electronic device . Such rules may be received by SVMM security agent , which may provide in-O\/S security rules  to SVMM . Such rules may be received by in-O\/S security agent .","Protection server , security agent  and SVMM security agent  may each authenticate each other. SVMM security agent  may locate the image of security agent  in memory and use cryptographic signing algorithms to verify the image of security agent  resident in memory. Protection server  and SVMM security agent  may authenticate each other using cryptographic hashing and signing algorithms to correctly identify each other. SVMM security agent  and protection server  may also exchange a private secret key to authenticate the identity of each other. Security agent  may receive a secret key from protection server  to verify the instance of SVMM security agent . Communication between security agent , SVMM security agent , and  may not be fully established unless each of the agents is authenticated with each other. Similarly, SVMM security agent  and SVMM  may verify and authenticate each other if they are running as separate entities.","SVMM  and SVMM security agent  may be running underneath operating system  and all operating systems of electronic device . SVMM  may monitor access to system resources , including I\/O devices , system memory , and processor registers  by operating system , security agent , application , and driver . SVMM  may trap the execution of key operations requested by operating system , security agent , application , driver , or any other entity of electronic device . SVMM  may trap such execution by manipulating flags inside of VMCS . When VMCS  intercepts a request for a protected resource, operation may be handed off to SVMM  for further operation, diagnosis and repair. In one embodiment, operation may be subsequently handled by SVMM security agent . In another embodiment, handling of the trapped operation may be conducted by SVMM  itself. SVMM  may trap any necessary operation of electronic device  to provide protection against malware. Such operations may include, but are not limited to: reading, writing and execution of particular code or data pages in system memory ; loading and storing of value from a system register and processor registers ; or reading to or from I\/O devices . The specific operations which will be trapped by SVMM  may be defined by SVMM security rule .","Protection server  may communicate with SVMM security agent  or in-O\/S security agent  to provide security rules to each. In one embodiment, protection server  may deliver SVMM security rules  to SVMM security agent . In another embodiment, protection server  may deliver in-O\/S security rules  to in-O\/S security agent . In yet another embodiment, protection server  may deliver in-O\/S security rules  to SVMM security agent , which may then provide the rules to in-O\/S security agent .","Application , driver  or other entities operating an electronic device  may be observed by in-O\/S security agent . In-O\/S security agent  may use in-O\/S security rules  to observe the behavior of such processing entities to determine whether their behavior constitutes suspicious behavior indicating a possible infection of malware. Upon such a detection of suspicious activities, in-O\/S security agent  may provide the suspicious information to protection server  for further analysis and instruction. In-O\/S security rules  may indicate to in-O\/S security agent  that such behaviors are suspicious, as well as indicate corrective action. For example, application  may communicate with a network destination which is known to host malware. In-O\/S security agent  may notice the activity of application , and subsequently block the network access of application  to the network destination. In-O\/S security agent  may also scan electronic device  for malware. For example, in-O\/S security agent  may examine the contents of memory , or system memory  for patterns that correspond to signatures of malware. Such an examination may reveal that, for example, application  contains a block of code corresponding to a known segment of malware. In-O\/S security agent  may then clean electronic device  of the infection of malware by repairing application , removing application , or taking any other suitable action. In-O\/S security agent  may communicate with protection server  regarding any detected suspicious behaviors, or other indications of malware, and may receive instructions from protection server  on how to deal with such malware.","In one embodiment, SVMM security agent  may be configured to evaluate a trapped operation based on the origin of the entity that made the attempted operation. For example, if a driver was downloaded from an unknown domain, or has a certificate from an unknown guarantor, then the ability of the driver to subsequently operate may be limited. For example, a driver whose status is unknown may be denied the ability to attach itself to another driver. If the driver was downloaded from a domain known to host malware or contains fraudulent credentials, then the driver may be not permitted to even load. Similarly, if a driver is known to be from a particular domain or created by a particular author, then SVMM security agent  may be configured to recognize services in electronic device  authorized to update the driver, and to limit the ability to write or access the driver to those services. For example, a kernel driver from Company X may only be written to from Company X's update service software resident on electronic device . SVMM security agent  may be configured to validate the operation and integrity of the update service. In another embodiment, SVMM security agent  may be configured to evaluate a trapped operation based on the target of the attempt. For example, an attempt to update software from a service may be trapped for kernel drivers, but not for application software.","Once an entity has been determined to be suspicious, or an attempt determined to indicate malware, the process causing the attempt and the memory housing the process may be linked. Other processes accessing the same portion of memory may similarly be determined to be malware. A trapped attempt to access a resource may be stored, and a subsequent attempt to access a protected resource may be evaluated in light of the original event. For example, a malicious operation may require that code be written to a data segment then executed. Thus, SVMM security agent  may trap the original write access to the data segment, allow the write, but record the source of the write access. Subsequently, SVMM security agent  may trap a subsequent attempt to execute the data segment, and evaluate the malicious status of the attempt in light of the previously trapped operation, the entity which attempted it, or other suitable forensic information.","SVMM security agent  may instruct SVMM  concerning which of system resources  that SVMM  is to trap through a control structure such as VMCS . SVMM  may then trap access requests to system resources  originating from entities of electronic device  such as operating system , application  or driver . For example, if a request is made to read, write or execute portions of system memory , SVMM  may intercept such a request through a flag set for the designated portion of system memory in VMCS . In another example, access requests made of I\/O devices  may be intercepted by VMCS , such as input or output operations. In yet another example, requests of process registers , such as load or store commands, may be trapped by VMCS . Any such traps may result in the notification of SVMM  of the attempted access. Once SVMM  has trapped an attempted operation upon system resources , SVMM  may communicate such a trapped execution to SVMM security agent .","In-O\/S security agent  and SVMM security agent  may communicate to determine the context of operations conducted within operating system . For example, a trapped system call from operating system  to a particular resource of electronic device  may have originated from a particular part of memory. SVMM security agent  may communicate with in-O\/S security agent  to determine what application, process, or other entity resides within the particular part of memory.","Based on SVMM security rules , and the trapped operation and\/or contextual information from in-O\/S security agent , SVMM security agent  may then determine whether such an access constituted a suspicious action such as those indicative of an infection of malware. For example, an attempted change of system memory  of a protected memory space by an unauthorized application may be a suspicious activity, and thus such an attempted change detected by SVMM  may be interpreted by SVMM security agent  to be an operation of malware. Such an activity may be reported to protection server  for further instruction, or action may be directed by in-O\/S security rules . The result of such a detection may be to block the attempted change in system memory , or triggering additional cleaning operations upon the entity of electronic device  which generated the attempted change.","SVMM  may monitor additional calls to system resources  to protect the integrity of the SVMM , SVMM security agent  and\/or in-O\/S security agent . SVMM  may conduct scanning operations, defined by SVMM security rules , to scan portions of system memory  to determine whether portions of such memory have been modified by malware. SVMM  may make use of signatures, hashes, or other rules indicating that a given pattern of memory is known as unsafe or safe.","For example, SVMM  may protect in-O\/S security agent  by preventing unauthorized read and write access to code and data pages corresponding to in-O\/S security agent  in system memory . Some malware may attempt to attack in-O\/S security agent  by making memory modifications or other modifications to system resources  associated with system memory . SVMM  may read a whitelist contained in SVMM security rules  of authorized applications and other entities of electronic device  that may be permitted to alter the code or data or other system resources  corresponding to in-O\/S security agent . If a modification originates from an entity not contained within the whitelist, then SVMM  may determine that such a modification is associated with malware. Unauthorized access to system resources  corresponding to in-O\/S security agent  may be handled by SVMM in any suitable manner, including blocking access, creating a honeybot process, reporting violations to protection server , or any other suitable remedy.","SVMM  may also trap access to system resources  belong to other entities of electronic device . For example, a target memory page in system memory  may contain sample code or data belonging to a part of the kernel operation of operating system . SVMM  and SVMM security rules  may limit access to such a target page to only code sections that are authorized. Consequently, if a code page in system memory  attempts to read or alter the target memory page, and the code page belongs to a non-authorized entity of electronic device , such an access may be blocked by SVMM . Thus, SVMM  may act to control access to memory pages in system memory .","SVMM security agent  may be able to update SVMM security rules  or in-O\/S security rules  by contacting protection server  for updated rules. Protection server  may configure the rules to be delivered to SVMM security agent  based upon the particular malware observed, administrator settings, or other characteristics of electronic device . SVMM security agent  may update the rules of electronic device  upon demand by a user, periodically, or upon the occurrence of a significant event, such as the encounter of new suspicious activities that may be linked to malware.","SVMM security agent  may set flags in VMCS corresponding to compound conditions. Such flags may span across different types of resources to be trapped. For example, VMCS may be configured to trap the combination of a write of a certain value to page in memory, and a subsequent move of the page to a buffer of an I\/O device.","System  may contain one or more advantages over other implementations of anti-malware systems and software. For example, some anti-malware solutions may hook various portions of an operating system to trap and evaluate low-level operations of the applications. However, these solutions themselves may operate inside of the operating system, or in another operating system in the case of two guest operating systems. By operating within the confines of the operating system, even at a kernel-level priority, the anti-malware solution may be susceptible to malware attacks from malware also running on the same operating system, perhaps running at the same priority. If trapping or triggering upon certain events is conducted at the level of an operating system, such trapping or triggering may be phished, hooked, reverse engineered, compromised, or otherwise defeated by malware running at the same or lower priority for the operating system. For example, an anti-malware solution running on an operating system that detects and removes a malicious hook in the operating system may be observed by malware running at the same priority. In another example, an anti-malware solution registering as a filter driver to detect the operation of a certain routine may be defeated by malware that registers a malicious filter driver lower on the driver stack than the anti-malware solution. Similarly, if handling of certain trapped or triggered events occurs at the level of an operating system, malware may be able to affect the such handling. For example, the malware may undo the corrections of the anti-malware solution, or even disable the operation of the anti-malware solution.","In another example, hypervisors may work to virtualize access to system resources such as system memory , but may not conditionally guard access to the system resources and thus act as a security hypervisor. Such hypervisors may not have access to anti-malware rules, such as behavioral rules in security rules , to identify malicious activities, entities, or malicious attempted access of system resources. Such hypervisors may be running within an operating system themselves, which may be prone to malware running at the same priority level as the operating system. Such hypervisors may not be running in a \u201cRing0 privileged mode,\u201d because such a mode may require the hypervisor to intercept too many attempted accesses of system resources. The hypervisor may be tasked with virtualizing all aspects of a guest operating system, and the demands of such virtualization may be too expensive to simultaneously access security rules to check for malicious behavior.",{"@attributes":{"id":"p-0094","num":"0093"},"figref":"FIG. 3","b":["300","305","305"]},"In step , a protection server may be accessed to determine security rules. Such security rules may be used to make decisions in steps -. In step , the virtual machine monitor may be instructed to trap access to system resources. Such access may arise from applications, drivers, or operating systems running on the electronic device. The virtual machine monitor may be instructed as to what system resources of the electronic device are to be monitored. The virtual machine monitor may also be instructed as to what operations on the monitored system resources are to be trapped. For example, read, write or execute operations on system memory may be trapped. In another example, load or store operations on registers may be trapped. In yet another example, input or output actions on I\/O devices may be trapped.","In step , flags corresponding to such operations to be trapped may be set inside a control structure such as a virtual machine control structure. Such trapped operations may generate a VM exit, wherein a triggered event is created upon the access of the flagged resource. In step , as system memory is allocated for the virtual machine monitor, the in-O\/S security agent, and the below-O\/S security agent, such memory may be secured against unauthorized read and write operations.","The electronic device may operate and be protected by one or more of the trapping of access of system resources in steps -, scanning memory for the presence of malware in steps -, and scanning memory for attempted memory modifications in steps -. Each of trapping the access of system resources, scanning memory for the presence of malware, and scanning memory for attempted memory modifications may be conducted in parallel. Further, each of these may be repeated as necessary to protect the operation of the electronic device.","In step , the access of a system resource such as system memory, registers, or I\/O devices may be trapped. The access may be trapped using a VMCS flag generating a VM exit. Such trapping may be conducted below the level of operating systems running on the electronic device. In step , the access may be analyzed to determine whether the requesting entity has permission to access the requested resource. Contextual information associated with the attempted access may be accessed to make such a determination. Security rules may be accessed to make such a determination. An unauthorized access may be determined to be suspicious. Such handling and determinations may be made below the level of operating systems running on the electronic device. If the access is suspicious, then in step , a suspicious attempted access of the system resources may be blocked. Such an attempt may be reported to the protection server. If the access is not suspicious, then the access may be allowed in step .","In step , memory pages of the electronic device may be scanned for the presence of malware. While scanning the memory of electronic device, a whitelist may be used to determine whether patterns of memory, reflecting entities resident on electronic device, are known to be safe. If a pattern of memory known to be safe is encountered, then in step , the memory may be allowed to continue to have access to electronic device and may remain. While scanning the memory of electronic device, a blacklist may be used to determine whether patterns of memory are known to comprise or be associated with malware. The whitelist and blacklist may be accessed by accessing the security rules. In step , if a pattern of memory known to be associated with malware is found, then in step  the pattern of memory may be denied access to electronic device by being repaired, removed, or neutralized.","In step , memory may be scanned to determine whether modifications to memory have been or are being attempted. Such scanning may be conducted below the level of operating systems in the electronic device. Such memory may include kernel memory, system data structures, or any other portion of memory of the electronic device that may be modified by malware. For example, a list of active threads running on the electronic device may be modified to hide the presence of a malicious process. If a modification is detected, then in step  it may be determined whether such modifications are permissible. Whether such modifications are permissible may be defined by the security rules. For example, the code or data page of an anti-malware process may be protected against modification or access by any other process. If the memory modification is deemed as authorized, then in step , the modification may be allowed. If the memory modification is determined to be unauthorized and not allowed, then in step , the modification may be denied.","In step , if an access or modification is allowed, then the access or modification may be stored for later reference. Some detections of malware may utilize information regarding past accesses or modifications to determine whether such past access and a presently detected access together comprise a malicious access of a resource.","In step , if a modification, access, or other operation is denied, then such an event may be reported to the protection server in step . Such a report may include information regarding any associated malware or suspicious behavior.","The steps of method  may be repeated as necessary to protect the electronic device continuously, periodically, or upon demand.",{"@attributes":{"id":"p-0104","num":"0103"},"figref":["FIG. 4","FIG. 1"],"b":["400","404","400","100","100","400","404","400","404","404","404","404","404","106","400","400","404"]},"In one embodiment, the below-O\/S security agents of system  may be embodied only in firmware of components of electronic device , as described below and in the discussions of . In another embodiment, the below-O\/S security agents of system  may be embodied in firmware of electronic device  itself such as main PC firmware . In such an embodiment, main PC firmware  may be implemented on a motherboard of electronic device . In yet another embodiment, the below-O\/S security agents of system  may also be embodied in below-O\/S agent . Below-O\/S agent  may be implemented in any suitable manner for providing triggering of access of resources, or handling of such triggers, below the level of operating systems of electronic device  such as operating system . For example, below-O\/S agent  may be an embodiment of SVMM  or SVMM security agent  of . Below-O\/S agent  may include security rules .","Electronic device  may include one or more components for conducting input and output operations from electronic device . Electronic device  may include any suitable number of such components and types of components. Such components may be implemented by devices with their own processor, memory, and software embedded in firmware. An example embodiment of such a component may be the I\/O device  of .","Electronic device  may include, for example, display  and storage . Each such component ,  may include firmware , . Firmware ,  may each embody the firmware  of . As described above, each such component ,  may include a firmware-based security agent, such as firmware security agent , . Firmware security agents ,  may each partially or fully embody the firmware security agent  of . In one embodiment, each of firmware security agents ,  may be implemented in their respective firmware , . In another embodiment, each of firmware security agents ,  may be implemented outside of firmware ,  in each of their respective components , . Each of such device firmware security agents ,  may be communicatively coupled to a respective set of security rules , . Each such security rules ,  may embody the security rules  of .","Electronic device  may include firmware. In one embodiment, electronic device  may include main PC firmware . Main PC firmware  may be embodied by a Basic Input\/Output System (\u201cBIOS\u201d). In one embodiment, main PC firmware  may be configured as the BIOS of a computer. In such cases, main PC firmware  may be configured to initialize the operation of the processor  of the computer. Main PC firmware  may be configured to allow the main processor  to communicate with I\/O devices such as display  and storage . In such embodiments, the computer may also contain a programmable I\/O controller, which may be programmed by the firmware or BIOS, and communicates with the firmware of the I\/O devices such as  and storage .","Main PC firmware  may include a below-O\/S security agent. In one embodiment, main PC firmware  may include a PC firmware security agent . PC firmware security agent  may be configured to intercept requests of system resources . To accomplish such functionality, PC firmware security agent  may embody fully or in part the functionality of the SVMM security agent  or SVMM  of , and\/or firmware security agent  of . PC firmware security agent  may embody the functionality of SVMM security agent  or SVMM  of  to accomplish below-O\/S triggering and handling of access to system resources , verification and validation of below-O\/S agents and in-O\/S security agents such as in-O\/S security agent , and distribution of security rules such as security rules , . PC firmware security agent  may embody the functionality of firmware security agent  of  to accomplish below-O\/S triggering and handling in firmware, updating of security rules, and to evaluate IN and OUT commands sent to portions of electronic device .","Electronic device  may include security rules . Security rules  may be an example embodiment of the security rules  of . In one embodiment, security rules  may reside in main PC firmware . In another embodiment, security rules  may reside outside main PC firmware , and PC firmware security agent  may be coupled to security rules .","The security agents of system  may be configured to work together to prevent malware and its malicious operations. Attempted access of resources may be trapped, and subsequent events triggered for handling in firmware security agents in devices such as display  or storage , or in main PC firmware . The firmware security agents in such devices or firmware may be configured to handle the triggered events or to pass the triggered event to another security agent for handling. Due to limited execution and update capabilities, some firmware security agents may be limited in handling their own triggered events, and thus it may be advantageous to pass such triggered events to other security agents. The security agents to which firmware security agents may pass events may include, for example, in-O\/S security agents such as in-O\/S security agent , a below-O\/S security agent such as below-O\/S security agent , or another firmware security agent such as PC firmware security agent . These other security agents may be configured to receive the triggered event, consult security rules, contextual information, or permissions, and send back a resulting action to be implemented.","Accordingly, while  illustrates an example number of elements for conducting below-O\/S triggering and handling by firmware-based security agents, more or less elements may be used in various embodiments. As more or less elements are used, the functionality of each element and of system  may change accordingly. In one embodiment, the security agents of system  below the level of the operating system  may be limited to one or more in-O\/S security agents  and firmware security agents , . In such an example, the firmware security agents ,  may rely upon protection server  for updates to security rules , . Firmware security agents ,  may rely upon in-O\/S security agent  for updates or handling of triggered events, but the operation of the in-O\/S security agent  may be less secure unless a below-O\/S security agent validates in-O\/S security agent. Firmware security agents ,  may provide triggering based upon firmware security rules  established at installation, manufacture, or configuration. Such security rules may be relatively static. In such a case, firmware security agents ,  may be configured to provide relatively basic event triggering, with little analysis. Such firmware security agents ,  may nonetheless be useful, as such triggering is accomplished below the operating systems of electronic device , thus better detecting some malicious or suspicious operations.","In another embodiment, the security agents of system  may include either PC firmware security agent  or below-O\/S agent , but not both. In such a case, the functionality of PC firmware security agent  may be implemented by below-O\/S agent , and vice-versa. Either PC firmware agent  or below-O\/S agent  may be coupled to protection server  and configured to obtain information such as security rules , , , , , and to share such information with other security agents in system . Such security rules may be tailored to each respective security agent for the purposes of communication, update, or storage expense. Either PC firmware agent  or below-O\/S agent  may be configured to receive triggered events from other security agents such as firmware security agents , , apply security rules and other information, and take corrective action such as sending a resulting event to the firmware security agents ,  or information to protection server . Either PC firmware agent  or below-O\/S agent  may be configured to trap attempted accesses of system resources . Either PC firmware agent  or below-O\/S agent  may be configured to communicate with in-O\/S security agent  to determine the context of triggered events. If more than one in-O\/S security agent  is present in system , each in-O\/S security agent  may be configured to perform a designated portion of the trapping, validating, or other tasks associated with in-O\/S security agent . Such portions may be defined by below-operating-system security agents. For example, one in-O\/S security agent  may validate or investigate MOV instructions, while another in-O\/S security agent  may validate or investigate JMP instructions.","In yet another embodiment, security agents of system  may include both PC firmware security agent  and below-O\/S agent . Nevertheless in such an embodiment, some or all of the functionality of PC firmware security agent  may be implemented by below-O\/S agent , and vice-versa. The delineation of tasks between PC firmware security agent  and below-O\/S agent  may take into account several factors. For example, the operation of a security agent within firmware such as PC firmware security agent  may be more secure than the operation of another below-O\/S agent . However, updating the security rules and the software of below-O\/S agent  may be simpler and faster than in a PC firmware security agent .","In still yet another embodiment, one or more firmware security agents ,  may reside on system  independent of a PC firmware security agent  or a below-operating system agent . In such an example, the firmware security agents ,  may validate the instance of in-operating system security agent .","Each of firmware security agents , ,  may be configured to reside within firmware logic sufficient to be able to monitor and control firmware logic for external communication. Firmware security agents , ,  may thus be configured to trap and\/or the communication of specific information or with specific other entities. Firmware security agents , ,  may be configured to determine the operation request received, as well as the data to be sent or received. Furthermore, firmware security agents , ,  may be configured to control the data to be sent or received, and may be configured to cause additional operations on the data, such as encryption, compression, embedding of watermarks, or decoding of watermarks in the data. Other security agents of system  in communication with firmware security agents , ,  may be configured to embed watermarks in data to be trapped by firmware security agents , , , or to decode watermarks put into data by firmware security agents , , .","Communication with a firmware security agent ,  or PC firmware security agent  may be conducted, for example, through programmable input-output interrupts or programmable input-output registers. Such interrupts or registers may be defined and provided by the maker of the firmware or device in which the firmware security agent , ,  resides.","One or more of the below-O\/S security agents of system  may be configured to serve as a main security agent to coordinate the anti-malware activities of the firmware-based security agents of electronic device . In one embodiment, PC firmware security agent  may be configured as the main security agent of system . In another embodiment, below-O\/S agent  may be configured to serve as the main security agent. The security agent may be configured to handle triggered events from firmware security agents , . The main security agent may be configured to validate the operation of firmware security agents , , as well as other security agents such as in-O\/S security agent . The main security agent may be configured to notify other security agents about whether one of the security agents has noticed suspicious behavior or detected malware, whether the system  is under a malware attack, or whether an administrator of system  has changed preferences or settings affecting security. The main security agent may share information about the attack with the other security agents of system .","By trapping access to resources of system  and\/or handling the resulting triggered events below the level of the operating systems of system , system  may provide increased security against malware. Operation of a security agent in firmware may reduce the opportunity for malware to affect the operation of the security agent. Trapping operations in firmware or at the device level may reduce the ability of malware to spoof or phish elements of system  in order to disguise its operation. For example, no matter what portions of operating system  are compromised by malware, a request to a component ,  might not be disguised from the device itself.",{"@attributes":{"id":"p-0120","num":"0119"},"figref":"FIG. 5","b":["502","502","502","502","504","506","508","504","508","506"]},"I\/O device  may include any suitable portion of an electronic device for controlling access to a resource for the electronic device. In one embodiment, I\/O device  may embody some or all of a peripheral for an electronic device. I\/O device  may be embodied by, for example, a display controller card, computer bus controller, cache device, I\/O controller device, disk controller, memory device, network controller, motherboard, or keyboard controller. I\/O device  may reside in an electronic device. In one embodiment, I\/O device  may be coupled to physical components. Such physical components may include, as just examples, a display, a computer bus, memory, I\/O controllers, a disk, a network card, or a keyboard. In another embodiment, I\/O device  may reside separately from the coupled physical components. For example, a keyboard controller may be coupled through a serial interface with a keyboard. In such embodiments, I\/O device  may reside in an electronic device while such physical components may be communicatively coupled to the electronic device but reside outside the electronic device.","Firmware  may be configured to control the operation of I\/O device . Firmware  may include a below-O\/S security agent  configured to trap requests for resources, operate below the level of operating systems in I\/O device  or in systems in which I\/O device  resides. Below-O\/S security agent  may be configured to handle events resulting from the trapped requests to determine whether to allow, deny, or otherwise handle the request, in order to protect I\/O device  or systems in which I\/O device  resides from malware. In one embodiment, firmware  may include a firmware security agent . Firmware security agent  may incorporate some or all of the functionality of SVMM  or SVMM security agent  of , but is embodied in firmware . In such a case, the functionality of SVMM  or SVMM security agent , such as trapping access to resources and\/or handling the trapped request, may be conducted by firmware security agent . In one embodiment, firmware security agent  may be configured to reside in firmware .","Firmware  may include I\/O commands , a data transmission engine , and programming logic . I\/O commands  may include instructions for sending or receiving information to the device. Such commands may include variations of IN or OUT commands. The execution of I\/O commands  may be operable to perform the desired actions of the device. Requests received by the device may be translated into I\/O commands. Trapping or triggering upon particular requests for resources may be accomplished by trapping or triggering upon the associated I\/O commands . Data transmission engine  may be configured to handle the communication of requests to the device, and subsequent responses. Data transmission engine  may be coupled to the processor  and to a programmable I\/O controller over an I\/O bus, over which I\/O commands  and data are exchanged. Programmable logic  may be configured to provide instructions for firmware  to operate I\/O commands  and data transmission engine . The programming logic  may be loaded into a processor such as processor .","Firmware security agent  may be configured to modify the operation of programming logic  to detect attempted malicious operations. Firmware security agent  may also be configured to monitor the communication of requests to the device to intercept requests of I\/O device  through data transmission engine  and to determine whether such requests are malicious. Firmware security agent  may include a control structure in which flags may be set corresponding to operations that are to be trapped. In one embodiment, flags may be set in the structure according to memory address of commands which are to be trapped. Firmware security agent  may be configured to set flags for the interception of requests to I\/O device . Such flags may correspond to, for example, specific commands of I\/O commands  or such specific commands in combination with specific parameters. Such flags may be configured to intercept particular requests or categories of requests. Upon the triggering of a particular flag corresponding to a trapped attempted operation of an I\/O command , firmware security agent  may be configured to process the event and take a resulting action, pass resulting information to another security agent through the data transmission engine , or pass the triggered event through data transmission engine .","I\/O device  may also include security rules . Security rules  may implement some or all of security rules  of . Security rules  may be implemented in memory . In one embodiment, security rules  may reside outside of firmware . In another embodiment, security rules  may reside inside of firmware . Firmware security agent  may be communicatively coupled to security rules  and configured to access security rules  to determine what flags to set in firmware  to trap particular requests or categories of requests made to I\/O device  for access to its resources. For example, firmware security agent  may be configured to access security rules  to determine whether a triggered event is malicious or not. In one embodiment, security rules  may contain instructions for firmware security agent  to process the triggered event. Firmware security agent  may be configured to use such instructions to determine whether to allow or deny the request, or to take another corrective action. In another embodiment, firmware security agent  may be configured to use such instructions to determine whether to report the request to another security agent. Such corrective actions may also include waiting for a response from the other security agent, which may contain instructions on whether to allow or deny the request.","In some embodiments, firmware security agent  may reside in firmware , which may make it relatively difficult to update firmware security agent . In addition, the ever-changing nature of malware attacks may require anti-malware solutions to be flexible. Consequently, firmware security agent  may use any suitable mechanism for receiving information for determining what requests to I\/O device to trap, and what subsequent actions to take.","In one such embodiment, such a mechanism may include accessing security rules  as described above. Firmware security agent  may be configured to receive new and updated security rules  from other security agents or protection servers. To achieve flexibility, firmware security agent  may be configured to store security rules  in memory  separate from firmware , if\u2014for example\u2014storage of such rules in firmware  would make updating security rules  difficult.","In another such embodiment, firmware security agent  may be configured to update security rules  upon an update or flash of firmware. In such an embodiment, the flexibility of updating the requests to be trapped may be limited. Consequently, security rules  may be directed to very specific, protected resources. For example, security rules  of a disk device may include instructions to trap all write requests to the boot sector of the device. In some cases, where communication with other security agents is inexpensive, security rules  may include instructions to trap a wide variety of requests, wherein processing may be largely offloaded to other security agents.","In yet another such embodiment, firmware security agent  may be configured to receive instructions from other security agents. In one case such instructions may take the form of parameters to function calls of the firmware  or firmware security agent . For example, another security agent may call a function of firmware security agent  named \u201cUpdateRule(trigger, action)\u201d wherein a request to trap for is detailed in trigger and a subsequent action to take is detailed in action. Firmware security agent  may thus update security rules  by receiving instructions concerning updates to security rules. In another case, another security agent may write updates for security rules  to a reserved memory space of device  which may be subsequently accessed by firmware security agent . The instructions to be received from other security agents may also direct firmware security agent  to use specific sets of security rules . For example, during a time-critical operation firmware security agent  may be configured by such instructions to use a minimal, core set of security rules . If I\/O device  is a disk device, such a minimal, core set of rules may include instructions to trap access to the boot sector of the disk. In another example, if time-critical operations are not being presently conducted, firmware security agent  may be configured by such instructions to employ rules from security rules  to trap a much broader range of access attempts and to send corresponding events to other security agents for handling.","Firmware security agent  may be configured to control I\/O commands , scan content or data received or to be sent, and apply access control over the commands and content. Firmware security agent  may be implemented as an extension of existing device firmware.","The implementation of firmware security agents  may depend upon the type of device . For example, display devices and disk devices may trigger on different kinds of content or attempted commands. The creation of firmware security agents  in various devices may be tailored to the specific kind of interface with the device. For example, if device  is configured to communicate through a Serial Advanced Technology Attachment (\u201cSATA\u201d) bus, it may be equipped with firmware security agents  similar to other devices communicating through SATA busses. Firmware security agent  may be customized to support the architecture of device , support an external bus I\/O of device , or other interfaces of device .","Firmware security agent  may be configured to trap attempted access of resources in device  by intercepting particular read and write commands, which may make up part of a request of a resource. A read or write command may be intercepted, evaluated, and blocked or allowed based on a rule such as one in security rules . Security rules  for a firmware security agent  may include any suitable rules for detecting evidence of malware. Such a read and write command may be the result of, for example, a function call to a driver or an interrupt.","For example, security rules  may include rules for firmware security agent  to scan data to be written to the device. The content of the data, or a hash of the data, may be evaluated to determine whether the data corresponds to malware data or code. Such evaluations may be made by comparing the content against data or signatures in a whitelist or blacklist. Successive writes may have to be evaluated together to properly evaluate the full scope of the data or content to be written, in order to correctly identify the contents or data as malware or not. For example, a file may be written to in repeated successive calls to device . The data to be written may be queued such that a proper scan of the contents of the write command may be evaluated.","In another example, security rules  may include rules for firmware security agent  to scan existing data in the device. The device  may contain content received from outside the system such as in a network card. The contents of the received information, as it resides with the device , may be scanned for evidence of malware. Firmware security agent  may make evaluations by comparing the content against data or signatures in a whitelist or blacklist.","In yet another example, security rules  may include rules for firmware security agent  to evaluate a command based upon time or permissions. A device  such as a network device or disk may be protected from reads or writes during times when no legitimate activity should be conducted. For example, certain malware may attack disk drives during boot. Thus, firmware security agent  may prevent any writes to the device during the time that the disk is being booted. Similarly, permissions may be set by an administrator of the system in which device  resides about when or how devices or systems can be used. For example, an administrator of the system in which device  resides may set a device to be unusable outside of business hours. A network device on the system may have no legitimate purpose to transport activity outside of business hours, and thus based on the permissions in security rules , reads and writes of the network device may be blocked by firmware security agent . Such use may block, for example, deliberate activity by an actual user of the device, or by malware using the network device to conduct a denial-of-service attack.","In still yet another example, security rules  may include rules for firmware security agent  to evaluate a command based upon parameters used with the I\/O commands. Such parameters may include, for example, the address to which a write command will write. Security rules  may include a rule indicating that a particular portion of a disk device is read-only. Thus, firmware security agent  may examine the parameters associated with an OUT command for writing data to the disk to determine the address to which the data will be written, and block the command if the attempted write is to a portion of disk that is write-protected by a rule in security rules . Firmware security agent  may consider such a parameter in conjunction with other bases such as content or the entity which originated the call. For example, scanning the content of data to be written may be expensive, and accordingly a security rule  may configure firmware security agent  to scan data to be written only if data is to be written to certain ranges of addresses. In another example, security rules such as security rule  may only allow certain calling entities to write or read from certain portions of the disk device. Thus, firmware security agent  may trap the attempted write or read and not allow the attempt until the identity of the calling entity may be securely determined. Such a determination may be made by evaluating information in the parameters used to call the device function, as some such functions may identify the calling device driver or application. In such a case, firmware security agent  may take any appropriate steps to determine the validity of the call. In one embodiment, firmware security agent  may consult a whitelist or blacklist in security rules  to determine whether the calling entity is authorized to make such a call. In another embodiment, firmware security agent  may communicate with other security agents in the system containing device  to determine whether the calling application or device driver is valid. Such other security agents may have validated the operation of the calling application or device driver, or may communicate with in-O\/S security agents that may have verified such operations. In yet another example, the existing driver calls to a device such as device  may not identify the calling entity. Accordingly, no parameters may be available. In such an example, firmware security agent  may be configured to pass the triggered event or otherwise consult with other security agents in the system to determine the context of the call which resulted in the attempted access. Such other security agents may be able to provide suitable context for the call to determine whether an authorized entity made the attempt.","In a further example, security rules  may include rules for firmware security agent  to evaluate a command based on information from the environment in which device  resides. Other security agents in the system may have detected a malware infection that is difficult to remove, or may require direct intervention from an administrator to clean. The other security agents in the system may have observed suspicious behavior, and the nature of the behavior has not yet been completely analyzed. In such a case, firmware security agent  may receive notification of such an existing threat from the other security agents. Security rules  may thus dictate preventative actions for firmware security agent  depending upon the type of infection. For example, firmware security agent  in a keyboard device may receive notification that evidence of a particular type of malware known for keylogging has been detected but cannot yet be removed. Security rules  may thus dictate that firmware security agent  disallow all reads and writes from the keyboard device to prevent a compromise of the information being communicated with the keyboard.","Firmware security agents  may protect the I\/O of different types of devices in different ways. For example, a firmware security agent  of a display device may shut down portions of the display, depending upon the malware threat. Firmware security agent  may block the display of certain patterns, causing a watermark to be produced on the screen. Firmware security agent  may trap the attempted display of a particular pattern. Firmware security agent  may intercept attempted reads of information from the device in order to prevent screen-captures.","In another example, a firmware security agent  for a keyboard device may optionally encode or decode its results in communication with the rest of the system. Such encryption may be set by the firmware security agent  upon notification that a malware threat such as a keylogger is present.","In yet another example, a firmware security agent  for a network device may trap based upon source Internet Protocol (\u201cIP\u201d) address, source port number, data to be sent or received, destination IP address, or destination port number. Once such an attempt to use the network device is trapped, firmware security agent  may scan the data payload of packets to be sent or received for evidence of malware. In one embodiment, such data payloads may be sent to another security agent or a protection server, wherein the contents may be scanned for evidence of malware. The contents of the data payload may be encrypted such that a packet sniffer may not successfully intercept the contents. Attempted operations on the network device may be trapped due to security risks associated with communicating with unsafe network destinations, wherein network communication with a malicious destination may compromise the security of the system in which device  resides. Attempted operations may be trapped due to the sensitive nature of particular sets of data, such as a banking website. In such a case, upon receipt of data from such a website, the data may be encrypted by firmware security agent  before being passed to another security agent or to the calling entity. Such encryption may prevent a packet sniffer or filter in the system of device  from successfully intercepting the information.","The specific I\/O commands  to be trapped may depend on the specific device and the operations of that device. Thus, the maker of device  may decide how to configure the operation of a firmware security agent  for a particular device . The maker of device  may decide how much to expose the functionality of device  to other security agents. For example, device  may be configured to require validation with other security agents before handing off triggered events to such security agents.","In operation, one or more below-O\/S security agents may be running in the firmware of system  or of the components of system . Firmware security agent  may be operating in display , firmware security agent  may be operating in storage , and PC firmware security agent  may be operating in main PC firmware . Below-O\/S agent  and in-O\/S agent  may be operating in system . Each security agent may communicate with one or more other security agents in system . Each such security agent may validate the instance of another security agent before accepting communication. Protection server  may communicate with one or more of the security agents after validating the security agent.","PC firmware security agent  or below-O\/S agent may be designated as a main security agent. The main security agent may communicate with protection server  to determine security rules. The main security agent may store the security rules locally to the main security agent. The main security agent may distribute security rules to each of the security agents, wherein the security rules may be stored locally to the security agent. The security rules may be customized for the type, make, or model of the device to reduce the expense of a large set of security rules.","Upon receipt of security rules such as rules , a device such as display  may set flags in a control structure within the device firmware  corresponding to operations of the device that are to be trapped. Similar tasks may be performed by storage .","An application  or driver  may try to access a device such as display  or storage . Application or driver  may make such an attempt by calling the kernel of operating system , which in turn may call operating system device drivers, which in turn may send the request to the component , .","The request may arrive at a device such as storage . Firmware security agent  running on the device may filter such a request through monitoring data transmission engine  of the storage  with a control structure. The request may take the form of an I\/O command  made available by the storage . If the request matches any flags that have been set by firmware security agent , the request may be trapped and a resulting event may be triggered. Firmware security agent  may consult security rules  to determine how to handle the triggered event.","In one embodiment, the triggered event may be handled by firmware security agent , and based upon the information available such as associated data, the command, contextual information, time, or environmental information, corrective action many be taken. Such corrective action may include allowing or denying the request, removing malicious code or data, or encrypting data to be transferred. Other corrective action may include sending information to be passed to protection server  concerning the trapped event. Firmware security agent  may inform other security agents about the status of the trapped event, so that other such agents may also take corrective action after consulting their respective security rules. For example, if firmware security agent  detects a malware attack of unknown origin, firmware security agent  may lock out additional access to the display .","In another embodiment, the triggered event may be transferred to another security agent for handling, such as in-O\/S security agent , PC firmware security agent , or below-O\/S agent . The receiving security agent, for example, PC firmware security agent, , may handle the triggered event by consulting security rules . Based upon the information available such as the data, command, contextual information, time, or environmental information, the request represented by the triggered event may be allowed or denied by PC firmware security agent . PC firmware security agent  may communicate with in-O\/S security agent  to determine contextual information concerning the attempted access of resources. PC firmware security agent  may communicate with protection server  for additional information on how to handle the triggered event. PC firmware security agent  may send instructions for resulting action back to the originating firmware security agent . PC firmware security agent  may send information concerning the triggered event to protection server  to be analyzed or recorded. Such analysis or recording may be conducted when the malicious nature of a triggered event is unknown. PC firmware security agent  may notify the security agents of system  that a particular kind of malware has been detected, a kind of suspicious activity has been detected, or that the system  is under a malware attack.","Upon receipt of information from PC firmware security agent , firmware security agent  may take corrective action. Such action may include allowing or denying the attempted access, encrypting data to be transferred, or removing malicious code or data.",{"@attributes":{"id":"p-0150","num":"0149"},"figref":"FIG. 6","b":["600","605","605"]},"In step , a protection server may be accessed to determine security rules. Such security rules may be used to make decisions in the following steps. In step , the firmware security agent may be instructed to trap access to system resources. Such access may arise from applications, drivers, or operating systems running on the electronic device. The firmware security agent may be instructed as to what system resources of the electronic device are to be monitored. The firmware security agent may also be instructed as to what operations on the monitored system resources are to be trapped. For example, read and write commands to a device on which the firmware security agent is running may be identified to be trapped. In step , flags corresponding to such operations to be trapped may be set in a control structure. Such trapped operations may generate a triggered event.","The electronic device may operate and be protected by one or more of the trapping of access of system resources in steps -, or scanning data for the presence of malware in steps -. Each of trapping the access of system resources and scanning data for the presence of malware may be conducted in parallel. Further, each of these may be repeated as necessary to protect the operation of the electronic device.","In step , the access of a system resource such as system memory, registers, or I\/O devices may be trapped. Such trapping may be conducted below the level of operating systems running on the electronic device. Such trapping may be conducted within firmware. In step , a resulting triggered event may be generated associated with the trapped attempt, as well as any associated information. In step , it may be determined whether the triggered event should be presently handled or passed to another security agent for handling. Such a determination may be made by accessing one or more security rules. If the triggered event should be presently handled, then in step  the security rules may be accessed to determine what actions to take based on the trapped event and other information, such as associated data, the command, contextual information, time, or environmental information. For example, the data to be written or read may be scanned for sensitive or malicious content; the calling entity may be identified to see if the entity has permission; the parameters used to call the command may be examined; or alerts about malware in the system from other security agents may be referenced.","In step  it may be determined whether the attempted access was suspicious or not. If accessing the security rules in combination with information associated with the attempted access yields a determination that the attempted access is not suspicious, then in step  the attempt may be allowed. If it is determined that such an attempt is suspicious, then in step  corrective action may be taken. Such corrective action may include removing malicious content from data, informing a protection server or other security agents about the presence of a malicious attempt, disallowing the attempted access, or encrypting data to be transferred. If the attempt is not suspicious, then in step  the triggered event may be allowed.","In step , if it is determined that another security agent is to handle the triggered event, the triggered event is passed to another security agent for handling. In step , a response from the security agent may be received indicating appropriate action to be taken. In step , such action may be taken, such as corrective action or allowing the operation of the triggered event.","In step , memory of a device may be scanned for the presence of malware. Such memory may contain contents that have arrived from another entity, such as another network card or the results of a previously executed file read. If the contents of the memory are known to be malicious, suspicious, or unknown, then in step , the contents of the memory may be removed.","In step , if an attempted access was denied, or if suspicious contents were found, then such an event may be reported to another security agent or a protection server. Such a report may include information regarding any associated malware or suspicious behavior.","The steps of method  may be repeated as necessary to protect the electronic device continuously, periodically, or upon demand.",{"@attributes":{"id":"p-0159","num":"0158"},"figref":["FIG. 7","FIG. 2"],"b":["700","204","700","100","100","700","701","700","204","701","700","724","701","700","224","714","716","718","720","722"]},"System  may include a microcode-based below-O\/S security agent such as microcode security agent . Microcode security agent  may reside within the microcode  of a processor such as processor . In one embodiment, microcode security agent  may be configured to trap attempted access of system resources  made by portions of system  such as application , driver , or operating system . Microcode security agent  may be configured to create a triggered event based on such an attempted access of system resources . For example, operating system  may attempt to launch a program by attempting to execute a segment of code in an address in physical memory . In another example, operating system  may attempt to read or write an address in physical memory . Although physical memory  is shown, microcode security agent may be configured to trap an attempt to access virtual memory. In another embodiment, microcode security agent  may be configured to trap attempted communication of information from other portions of processor , such as microcode modules . Microcode modules  may include other portions of processor  configured to conduct the operation of processor  to execute instructions. Such attempted communication of information may include the results of operations from system resources . For example, during the processing of code, and divide-by-zero operation may be intercepted by a microcode module  and may attempt to generate and communicate an exception .","Microcode  may include hardware-level instructions for carrying out higher-level instructions received from elements of system  such as operating system . Microcode  may translate such higher-level instructions into circuit-level instructions to be executed by processor . Microcode  may be specific to the electronic circuitry or type of processor embodied by processor . Microcode  may be configured with the specific contents of microcode  upon the creation of processor . The ability to update or reprogram microcode  on processor  may be limited. Microcode  may reside in an internal processor memory . Internal processor memory  may be a high-speed memory separate from the system memory of system , such as memory . In one embodiment, internal processor memory  may be read-only-memory. In another embodiment, microcode  may reside in a programmable logic array included in internal processor memory . In yet another embodiment, internal processor memory  may include or be implemented as a memory store or a control store. In such an embodiment, internal processor memory  may be implemented partially or in full by static-random-access-memory or flash memory. In such an embodiment, microcode  may be configured to be loaded into the memory store from some other storage medium, such as memory , as part of the initialization of the processor , and may be configured to be updated, reinstalled, or receive new information such as security rules or machine instructions through data written to the memory store.","Microcode security agent  may be configured to access security rules  to determine what operations, commands, communications, or other actions to trap. Security rules  may reside within microcode , or another suitable portion of processor  or system . Security rules  may be implemented by functional calls from entities outside processor , such as other security agents making calls to microcode security agent  and passing information through parameters. Microcode security agent  may be communicatively coupled to security rules . In one example, a security rule  may have logic such as:\n\n","Microcode  may include a state machine to understand the context of instructions that have been received. Such information may be needed to carry out certain security rules  which, for example, evaluate successive operations within the context of each other. Such information may be passed with a triggered event.","One or more of the below-O\/S security agents of system  may also be embodied in below-O\/S agent . Below-O\/S agent  may be implemented in any suitable manner for providing triggering of access of resources, or handling of such triggers, below the level of operating systems of electronic device  such as operating system . Below-O\/S agent  may embody some or all of the functionality of SVMM  or SVMM security agent  of ; firmware security agent ,  or PC firmware security agent  of ; or firmware security agent  of . Below-O\/S agent  may be communicatively coupled to security rules .","In one embodiment, one or more of the below-O\/S security agents of system  such as below-O\/S agent  may be configured to handle triggered events generated by microcode-based security agents such as microcode security agent . Below-O\/S agent  may be configured to also trap access to resources or handle triggered events in a similar fashion as below-O\/S agents in  and -. Below-O\/S agent  and microcode security agent  may be communicatively coupled. Microcode security agent  may be configured to send triggered events to below-O\/S agent . Below-O\/S agent  may be communicatively coupled to other security agents such as in-O\/S security agent , and may be communicatively coupled to protection server . Below-O\/S agent  may be configured to receive contextual information from other security agents such as in-O\/S security agent . Such information may provide information about the entity which generated an attempted access to system resources . If more than one in-O\/S security agent  is present in system , each in-O\/S security agent  may be configured to perform a designated portion of the trapping, validating, or other tasks associated with in-O\/S security agent . Such portions may be defined by below-operating-system security agents. For example, one in-O\/S security agent  may validate or investigate MOV instructions, while another in-O\/S security agent  may validate or investigate JMP instructions.","Below-O\/S agent  may also be configured to receive security rules or just-in-time information from protection server . Furthermore, below-O\/S agent  may be configured to consult security rules such as security rules , any received contextual information from other security agents such as in-O\/S security agent , or protection server  in order to determine how to handle a received triggered event from microcode security agent .","In particular embodiments, below-O\/S agent  may contain a behavioral state machine, to understand the context of operations encountered in system . Below-O\/S agent  may then be configured to determine an appropriate action to be executed by microcode security agent  based upon the context. Such action may include a corrective action, allowing an operation, denying an operation, or taking other steps in furtherance of the requirements of a security rule. Microcode security agent  may be configured to take such actions as received from below-O\/S agent .","Below-O\/S agent  may be also be configured to determine an appropriate action to be executed by another security agent, such as in-O\/S security agent . For example, if a triggered event from microcode security agent  indicates a particular kind of malware threat, or a threat to a particular portion of the kernel or user mode of electronic device , below-O\/S agent  may be configured to instruct in-O\/S security agent  to take a corrective action. Thus, below-O\/S agent  may control in-O\/S security agent .","Below-O\/S agent  may be configured to validate the instance of microcode security agent , and vice-versa. Below-O\/S agent  may be configured to communicate with microcode security agent  to share or set security rules such as those from security rules  to be implemented in security rules , status information regarding system , administrator or environmental settings and preferences, or other suitable information for microcode security agent  to trap operations, generate triggers, and handle such triggers or send them to other security agents.","Below-O\/S agent  may be configured to communicate such information to microcode security agent  through any suitable mechanism. Below-O\/S agent  may call functions of the processor , microcode , or microcode security agent , and pass information as parameters to the functions. Such functions may be created specifically to pass such changes to microcode security agent . For example, to ban the access of a range of physical memory \u201cA\u201d from any entity operating from the memory from another range of physical memory \u201cB,\u201d a function such as \u201cBar_Memory(A, B)\u201d could be used. Microcode security agent , as a result of this function being called, may be configured to set parameters within microcode . Calling such microcode instructions may be privileged, such that microcode security agent  may be configured to validate below-O\/S agent  before calling such microcode instructions on behalf of below-O\/S agent . In another example, below-O\/S agent  or microcode security agent  may communicate such information by writing data to a memory store, control store, or other writeable portions of processor  or microcode .","Processor  may have limited resources for microcode security agent  to fully implement all necessary trapping and handling to protect system  from malware. In one embodiment, microcode security agent  may be configured to implement only trapping of actions to be conducted by processor , and may offload triggers associated with such trapping to other security agents or components of system  for subsequent handling. Microcode security agent  may take subsequent action, such as allowing or disallowing a request or communication, or may take other action such as reporting information. In another embodiment, microcode security agent  may be configured to implement handling of a small portion of triggered events. Suitable triggered events for such handling may include those not requiring significant contextual information. For example microcode security agent  may receive information through security rules  that a particular range of memory addresses is to be protected from all reads and writes, unless an instance of below-O\/S agent  has been validated. Such a security rule may be implemented because the contents are quite sensitive, and without the operational assistance of below-O\/S agent , the identity of the entity accessing the memory contents cannot be identified. Thus, after validating the instance and operation of below-O\/S agent, microcode security agent  may set a bit indicating such validation. If an attempted access of the memory is triggered, and the bit has not yet been set, then microcode security agent  may be configured to disallow the reading, writing, or execution of the contents of the memory range. If the bit has been set, then microcode security agent  may be configured to then trap the attempted access to the memory range, generate a triggered event to be sent to below-O\/S agent , which would evaluate from contextual information and other settings whether the calling entity was allowed to access the memory range. Below-O\/S agent  may then send a resulting action back to microcode security agent , perhaps indicating whether to allow or deny the access.","A triggered event may include any suitable information that may be used for identification of the source, method, or destination of the attempted action. The triggered event may be used by microcode security agent  or below-O\/S security agent  to apply security rules. The triggered event may be generated by microcode security agent . For example, the triggered event may detail precisely what resource was accessed, what instruction was called, what instruction operands were used, from what memory address the attempt or instruction came from (i.e. the source memory), into what memory the operation's result was to be stored in (i.e. the target memory) or what memory will be affected, or any other information leading to identification of the source, method, or destination of the attempted action. Microcode security agent  may also be configured to include information regarding processor  such as processor states of active, sleep, idle, halt, and reset; interprocessor communications; and power consumption.","Another security agent such as below-O\/S agent  may be configured to use such information in a triggered event to determine the scope of the event when applying a security rule . Below-O\/S agent  may have access to additional clues such as information about the entities operating in operating system , new information in protection server , malware or other threats detected by other security agents, administrator settings, etc. For example, given a trapped request originating from a particular address in physical memory, below-O\/S agent  may be able to determine the thread, process or application associated with the particular address. Then, below-O\/S agent  may be configured to determine whether such an entity is authorized to take the action in question. Below-O\/S agent  may be configured to determine the identity of the entity. Below-O\/S agent  may be configured to classify the entity as known to be safe (e.g., by consulting a whitelist), known to be malicious (e.g., by observing behavior or consulting a blacklist of known malware), or unknown. Below-O\/S agent  may be configured to report information about unknown and malicious entities to protection server .","Microcode security agent  may have access\u2014for trapping purposes\u2014to certain processor  resources and other system resources  that may be unavailable to other security agents. In one embodiment, implementation of microcode security agent  within the microcode  may avoid limitations created by limited exposure of such resources to calling entities outside of the processor. For example, a virtual machine monitor may be limited to trapping operations on resources which have been exposed by processor  for virtualization purposes. Take as a further example the ability to trap an attempted read, write, or execute upon memory. A virtual-machine-monitor-based security agent may only have access to memory as it is available to be virtualized, and, as a consequence, may only be able to trace attempted read, write, or execution attempts to a memory page. In contrast, microcode security agent  may be able to intercept and handle a read, write, or execute request to a specific physical memory address, and evaluate the request based upon security rules . The smaller granularity may provide greater flexibility in providing security solutions in system . The instruction-level awareness of what instruction was used in context with a specific physical memory address informs system  of which entity called what resource, and not merely that a memory page was accessed. This flexibility may be very valuable. For example, microcode security agent  may monitor two adjacent memory addresses for read, write, or execute attempts, but may be directed by security rules  to take completely different actions based upon which of the two memory addresses were accessed. With a view only into the memory page on which an attempt is made, such a distinction in rules may fail to be applied. In another example, other methods by hypervisors for monitoring and setting debug registers did not have the context of the instructions which were used to access the debug registers, as does system . In addition, some other entities for setting or watching such debug registers do not run below the level of the operating system, making them more prone to malware. Finally, some other entities for setting or watching such debug registers are not directed towards security, and are not capable of accessing security rules, evaluating the access, and taking a corrective action.","Corrective actions to be taken by microcode security agent  may include any suitable action determined by security rules  or received from below-O\/S agent . Commands or instructions may be allowed or denied. Information generated from microcode modules  may be allowed or suppressed. Any such commands, instruction, or information may be modified.","Microcode security agent  may be configured to trap the generation of interrupts. The interrupts may be trapped by trapping, for example, an execution of an \u201cINT\u201d instruction, followed by reading relevant registers known to host information associated with an interrupt. For example, general purpose registers may be read to learn the code identifier of the interrupt, as well as the parameters used to call it. For example, interrupt  may be a disk interrupt, and a known set of registers may identify the interrupt as a read or write, as well as relevant sectors and locations of data.","Microcode security agent  may be configured to trap values being written to input and output ports of processor . Microcode security agent  may be configured to trap values being written to input and output devices by processor . Microcode security agent  may be configured to trap on instructions for making such writes or reads.","Microcode security agent  may also be configured to trap certain operations of an arithmetic logic unit (\u201cALU\u201d) of processor . A series of operations on the processor corresponding to the steps of a protected hashing algorithm may be trapped to determine unauthorized access of the function. Some arithmetic operations are used by malware to disguise or morph themselves. Certain arithmetic instructions, bitwise instructions, or MOV instructions are all instructions that might cause a change in the content of a memory page or address range. By trapping such instructions, changes to a code section or data section may be recorded. If subsequent analysis shows that the code section or data section was modified as part of self-modifying malware, then the trapped and recorded instructions may be used to track the encryption algorithm used by the malware. For example, it may be determined that the malware uses an XOR function with a particular key to morph itself. Such information may yield better security rules for detecting self-modifying malware. Further, by keeping track of memory modifications, repair logic may be achieved by reversing the application of the instructions.","In addition, microcode security agent  may be configured to conduct digital-rights-management operations. For example, microcode security agent  may be configured to receive a security rule  indicating that authorization to run a particular program is required. The particular program may be located at a specific address in memory. Such an authorization may take the form of the microcode security agent  receiving, for example, an authorization code, key, or byte from below-O\/S security agent . Such an authorization may be accomplished by microcode security agent  trapping attempted access on the memory or loading of the programs instructions, and sending the triggered event to below-O\/S security agent , which in turn may have access to the authorization code, key, or byte. The below-O\/S security agent  may return the decision to the microcode security gent . Thus, operation of the program may be allowed or disallowed based on the authorization code.","Furthermore, microcode security agent  may be configured to stop the execution of specific code in memory based upon a hash or a checksum of the memory. Such a hash or checksum may be indicated by a security rule  as malicious. As the code is loaded from memory, microcode security agent  may conduct the hash or checksum of the contents, compare it with those of known malicious code, and then deny the attempt to load and load a repair function to eliminate the offending code.","Below-O\/S agent  may be configured to inform other security agents of system , including microcode security agent  that it has been determined that system  has been infected with malware, encountered suspicious behavior, or otherwise been compromised. In such a case, microcode security agent  may be configured to disable operation of portions of processor . Microcode security agent  may be configured to disable such operations by trapping and denying requests to specific system resources , or generated communication from microcode modules . Portions of processor  may be disabled because they are sensitive, or likely to be misused by malware.","Microcode security agent  may be configured to protect a memory address or a range of memory addresses from attempts to load, read, write, or execute attempts. Such memory may include sensitive data, or may be the initialization point for a restricted, sensitive, or protected function. Microcode security agent  may prevent access to such memory where there is no verification that the accessing software is safe or neutral. In such a case, security agents such as below-O\/S agent  may identify specific memory addresses to be protected, perhaps because such memory addresses may correspond to the example sensitive information or protected routines. Below-O\/S agent  may send microcode security agent  information such as security rules  regarding which addresses to protect. Microcode security agent  may trap attempted loading, executing, reading or writing to such memory addresses and send a corresponding triggered event to below-O\/S agent . Below-O\/S agent  may determine whether the calling software is safe or neutral according to security rules , information from protection server , a whitelist, or any other suitable information source. Below-O\/S agent  may return an action to be implemented back to microcode security agent . Microcode security agent  may be configured to protect a page or range in virtual memory and\/or an address or range in physical memory. Microcode security agent  may be configured to translate virtual memory pages, locations, or addresses into physical memory locations or addresses. Thus, given a virtual memory location to trap, or a virtual memory location from where an attempt originated, microcode security agent  may be configured to determine the corresponding physical memory locations, or vice-versa.","Furthermore, microcode security agent  may be configured to protect the access of sensitive code. In one embodiment, microcode security agent  may be configured to protect the access of sensitive code in the manner described above by monitoring access of a particular address, wherein the address represents the beginning of the code as it is stored in memory. In another embodiment, microcode security agent  may be configured to monitor the execution of \u201cJMP\u201d or similar branching instructions which would move the operation of processor  into the middle of sensitive data or code. In such a case, microcode security agent  may be configured to trap the execution of \u201cJMP\u201d instructions in combination with the sensitive memory ranges. Microcode security agent  may be configured to analyze from where the \u201cJMP\u201d instruction originated. The microcode security agent  may be configured to generate a triggered event corresponding to the trapped \u201cJMP\u201d attempted execution, which may be handled by below-O\/S agent . The below-O\/S agent  may be configured to take into account where the \u201cJMP\u201d instruction originated, and whether such memory where the \u201cJMP\u201d instruction originated is authorized to access the memory in question.","Microcode security agent  itself, or the trapping functionality therein may also be configured to be enabled or disabled by other portions of system . Such capabilities may be useful if trapping and handling events are expensive, thus possibly harming system performance. Such enabling and disabling may be based upon the use of particularly sensitive programs or data, detection of a malware threat, administration preferences, or any other suitable reason. In one embodiment, microcode security agent  may be configured to receive a MSAOn signal, VMXOn signal, or other instruction from below-O\/S agent  to begin security processing and trapping. Microcode security agent  may receive an MSAOff signal, \u201cVMWrite VMXOff\u201d signal, or other instruction to stop security processing and trapping. Before beginning or stopping security processing and trapping, microcode security agent  may validate the identity and instance of the security agent making the request.","Furthermore, microcode security agent  may be configured to intercept interprocessor messages and commands between processor  and other processors of electronic device . Such interprocessor commands may be received by an appropriate microcode module  or be attempted by an entity of electronic device  accessing particular system resources . In one embodiment, interprocessor commands may be sent from software accessing processor  from operating system  by way of a machine state register. Malware may try to send such messages, for example, to turn off processors or put them in sleep mode. Microcode security agent  may be configured to trap the attempted writes to, for example, the MSR register that correspond to interprocessor commands. A triggered event for the trapped command may be sent to below-O\/S agent  for handling to verify the source of the attempt.","Microcode security agent  may be configured to intercept the generation and communication of messages from the processor such as software interrupts . Microcode security agent  may be configured to control the execution of an interrupt such that they may be accessed by authorized software only. For example, drivers without a known identity (such as determined by hashes, source of driver in memory, etc.) or a malicious identity will not be allowed to execute software interrupts. Microcode security agent  may trap the access of the interrupt and pass the triggered event to the below-O\/S agent  for handling.","In another example, microcode security agent  may be configured to trap the generation of exceptions  by processor . Exceptions may include, for example, divide-by-zero operations, page faults, and debug signals. Read access to the memory addresses containing these may be trapped by microcode security agent  and handled by below-O\/S agent .","Microcode security agent  may be configured to protect various data structures of the processor . For example, malware may attack the Interrupt Descriptor Table (\u201cIDT\u201d). In one embodiment, microcode security agent  may trap write access attempts to memory locations containing the IDT itself. In another embodiment, microcode security agent  may protect the memory locations where functions for changing the IDT are stored, such as \u201cLOAD IDT\u201d and \u201cSTORE IDT.\u201d In another example, microcode security agent  may be configured to protect the EFLABS or similar data structure, or flags associated with interrupt handlers. Malware may attempt to subvert the operation of interrupt handlers through the alteration of such resources by unauthorized sources.","Although microcode security agent  may be specific to the particular instances of a specific type of processor, as different circuitry arrangements may necessitate different microcode instructions, a set of security rules  may be valid for all processors using a given instruction set. This may be possible because microcode security agent  may trap certain instructions, which would not change between different processors implementing the same instruction set, but the circuitry where the associated resources may vary and depend upon the circuitry. For example, a main desktop central processing unit (\u201cCPU\u201d) and an embedded system CPU may both be ISA processors from the same manufacturer, and thus security rules  may be shared at least in part between the two types of processors. In contrast, a graphics processing unit on a graphics processor or an automobile embedded processor with a different instruction set may not be able to share security rules .","In operation, microcode security agent  may be running in the processor  of electronic device  and below-O\/S agent  may be running below the level of operating system of electronic device . Microcode security agent  and below-O\/S agent  may authenticate each other. Microcode security agent  may initiate trapping of access to system resources  and outputs or communication generated by microcode modules . Microcode security agent  may be so initiated upon demand from below-O\/S agent , upon a security rule , or upon startup of processor . Below-O\/S agent  may send a security enablement request to microcode security agent  because of an occurrence in system , an administrator or system setting, or because of a triggered security rules . Such a request may be generated, for example, because a particular program is to be executed, sensitive data is to be accessed, or a malware threat has been detected elsewhere in system . In-O\/S security agent  and\/or below-O\/S system agent  may authenticate itself to microcode security agent . To authenticate itself, in-O\/S security agent  and\/or below-O\/S system agent may call a privileged instruction provided by processor  to initiate the authentication process. The call may cause microcode security agent  measure and authenticate, with a signature or hash, for example, in-O\/S security agent  and\/or below-O\/S system agent .","Microcode security agent  may receive security rules  from below-O\/S agent . Microcode security agent  may be updated by function calls, or by writes to shared memory such as a memory store. Microcode security agent  may apply flags based on security rules  to a control structure of microcode  configured to trap specific instructions, operands to such instructions, target addresses, source addresses, or any combination thereof. Microcode security agent  may trap attempted accesses of system resources by entities running above the processor, such as operating system , application , or driver . The operation of microcode security agent  may be transparent to such entities. Microcode security agent  may trap the generation of information such as outputs from instances of other microcode modules . Such microcode modules  may include other portions of microcode configured to perform various tasks for processor . For example, some of microcode modules  may detect when a processor exception or interrupt is to be generated, how to route input and output data, or perform mathematical operations. The operation of microcode security agent  may be transparent to such modules. Microcode security agent  may use a state machine to perform certain trapping predicated on previous events observed.","Upon trapping an access to a resource or a generation of information, microcode security agent  may created a triggered event associated with the trapping. Such a triggered event may contain information about the trapping, including contextual information such as the instruction trapped, parameters used, originating memory locations, and target memory locations.","In one embodiment, microcode security agent  may handle the triggered event. In another embodiment, microcode security agent  may pass the triggered event to below-O\/S agent  or another security agent for handling. Microcode security agent  may consult security rules  to determine whether and how to handle the triggered event, or to pass the triggered event to below-O\/S agent . Microcode security agent  may wait for a reply from below-O\/S agent , or may allow the trapped action if no follow-up is required by security rules . Microcode security agent  may take corrective action based on security rules , such as allowing or denying an instruction, or replacing a value or parameter to be executed.","Below-O\/S agent  may receive a triggered event from microcode security agent . Below-O\/S agent  may consult security rules such as security rules  to determine an appropriate action to take based on the triggered event. Below-O\/S agent  may use triggered event information from microcode security agent , contextual information from in-O\/S security agent , information from protection server , determinations from other security agents, administrator settings, time, or other information to determine the appropriate action that should be taken. Below-O\/S agent  may send actions to be taken to in-O\/S security agent  and\/or microcode security agent . Below-O\/S agent  may send information regarding the triggered event and resultant actions to protection server .","Microcode security agent  may receive an action to be taken from another security agent, such as below-O\/S agent . Microcode security agent  may execute the received action, such as allowing or denying an instruction, or replacing a value or parameter to be executed.",{"@attributes":{"id":"p-0196","num":"0199"},"figref":"FIG. 8","b":["800","805","810","815","820"]},"In step , flags corresponding to operations to be trapped may be set in microcode. Such flags may correspond to specific instructions, operands to such instructions, target addresses, source addresses, or any combination thereof. Such flags may be defined by security rules that were received. In step , instructions to be executed may be received and compared against the trapping flags. In step , information generated and to be sent from microcode may be received and compared against the trapping flags. Steps  and  may be implemented by way of a state machine, wherein the steps may be repeated, and the results from multiple iterations of step may be remembered and compared together against a flag or security rule.","In step , it may be determined whether an instruction or information has been trapped. If nothing was trapped, the method may return to monitoring instructions and generated information in steps  and . If something was trapped, then in step  a triggered event associated with the trapping may be created. Such a triggered event may contain information about the trapping, including contextual information such as the instruction trapped, parameters used, originating memory locations, and target memory locations.","In step , it may be determined whether the triggered event is to be handled within microcode, or whether a security agent outside microcode should handle the triggered event. If the triggered event is to be handled within microcode, then in step  an appropriate action for the triggered event may be taken. Such an action may be defined by consulting a security rule. Such an action may include allowing an instruction to be executed or information to be sent, denying the instruction or communication, replacing values in memory or in parameters, or any other corrective action required. The method  may then continue security monitoring in steps  and .","If the triggered event is to be handled outside of the microcode, then in step  the triggered event may be sent to a security agent for handling the triggered event. In step , additional information related to the triggered event may be gathered. Such information may include settings, preferences, contextual information, or malware status. Such information may be used in step  to apply a security rule to the triggered event. Such an application may yield a course of action to be taken with respect to the triggered event. In step  such a course of action may be specified and transferred to various security agents which may implement the specified action. Such actions may include corrective actions, allowing an operation or communication to take place, reporting the event to a protection sever, or any other suitable result. In step , the actions specified in step  may be taken. The method  may then continue security monitoring in steps  and .",{"@attributes":{"id":"p-0201","num":"0204"},"figref":"FIG. 9","b":["900","901","900","920","922","901","924","901","913","920","922","908","920","922"]},"Electronic device  may be implemented wholly or in part by or configured to implement the functionality of the electronic device  of , electronic device  of , electronic device  of , electronic device  of , and\/or any combination thereof. Electronic device  may include one or more processors  coupled to a memory . Processor  may be implemented wholly or in part by or configured to implement the functionality of processor  of , processor  of , processor  of , or any combination thereof. Memory  may be implemented wholly or in part by or configured to implement the functionality of memory  of , memory  of , memory  of , and\/or any combination thereof. Electronic device  may include an operating system , which may include an in-O\/S security agent  coupled to one or more security rules . Operating system  may be implemented wholly or in part by or configured to implement the functionality of operating systems  of , operating system  of , operating system  of , operating system  of , and\/or any combination thereof. In-O\/S security agent  may be implemented wholly or in part by or configured to implement the functionality of in-O\/S security agent  of , in-O\/S security agent  of , and\/or in-O\/S security agent  of , or any suitable combination thereof.","Below-O\/S trapping agent  may be implemented by or configured to implement the functionality of below-O\/S trapping agent  of , SVMM  of , firmware security agents ,  or PC firmware security agent  of , firmware security agent  of , microcode security agent  of , and\/or any combination thereof. Triggered event handler  may be implemented by or configured to implement the functionality of triggered event handler  of , SVMM security agent  of , below-O\/S agent  of , below-O\/S agent  of , and\/or any combination thereof. In various embodiments, some of the functionality of below-O\/S trapping agent  may be accomplished by triggered event handler , or some of the functionality of triggered event handler  may be accomplished by below-O\/S trapping agent . Furthermore, below-O\/S trapping agent  and triggered event handler  may be implemented in the same software module.","Security rules  may be implemented by or configured to implement the functionality of security rules  of , security rules  of , security rules , ,  of , security rules  of , security rules ,  of , and\/or any combination thereof. Security rules  may be implemented by or configured to implement the functionality of security rules  of , security rules  of , security rules  of , and\/or any combination thereof.","Below-O\/S trapping agent  may be configured to intercept access to or information from any suitable resource, such as processor resources . For example, processor resources  may be implemented by or configured to implement the functionality of resource  of , system resources  of , portions of components such as display  and storage  of , or system resources of . Processor resources  may include resources available to a processor such as processor  for enabling the processor to load and execute instructions. Such resources may include, for example, data registers , control registers , caches , processor flags , processor cores , processor exceptions , or processor interrupts . An attempted access of such a resource may include an instruction such as an assembly language instruction with operands. The processor resources  on which trapping may be available may depend upon the resources exposed by the processor . For example, if below-O\/S trapping agent  is implemented in a virtual machine monitor, the processor resources  available for the below-O\/S trapping agent  to trap may be limited to processor resources  exposed by processor  for the purposes of virtualization. In such a case, processor  may include virtualization extensions for some of processor resources . In another example, if below-O\/S trapping agent  is implemented in a microcode security agent, then processor  may have made nearly all resources of the processor  available for trapping.","Below-O\/S trapping agent  may include a processor resource control structure (\u201cPRCS\u201d) . PRCS  may be implemented in a record, data structure, table, or any other suitable structure. PRCS  may contain information specifying which instructions, information, or attempted access of processor resources  are to be trapped. Below-O\/S trapping agent  or triggered event handler  may be configured to set flags in PRCS  corresponding to sensitive operations, information, or resources that are to be trapped. Below-O\/S trapping agent  or triggered event handler  may be configured to set such flags in PRCS  according to information contained within security rules .",{"@attributes":{"id":"p-0207","num":"0210"},"figref":["FIG. 10","FIG. 9"],"b":["1000","1000","926","1000","1014","1004","1006","1008","1010","1012","1000","1002","1004","1006","1008","1010","1012","1000","902"]},"Trigger flag  may include an indication of whether trapping and triggering for the associated entry  is turned on or off. Such a flag may allow a trapping condition to be loaded in PRCS  as an entry  but yet remain dormant. Thus, PRCS  may be loaded with embodiments of security rules without actively enforcing them. Trigger flag  may be configured to be set by an entity such as the below-O\/S trapping agent  of . Such an operation may enable an anti-malware system using PRCS  to operate much faster in contrast to a system which would require PRCS  to be populated and depopulated each time trapping for a particular resource or condition was to be enabled or disabled. The ability to turn on and turn off an entry  may enable an anti-malware system to selectively trap certain operations. Such selectivity may be advantageous if a particular trapping operation is expensive in terms of time or execution, and thus an entry  might be enabled only when particular conditions are detected. For example, if a system normally writes many times to a particular register, trapping on access to that register may be turned off until another part of the antimalware system detects suspicious behavior indicating a possible malware infection. In such a case, the trigger flag  of an entry  corresponding to writes of the register may be set to \u201cON\u201d to catch any additional malicious attempts to attack resources.","Resource identifiers  may include an identification of a particular resource of the processor that is to be trapped. For example, an identifier  may show that the resource is a register such as a particular data register, address registers such as EAX, a stack register, a control register, a vector register, stack pointers such as ESP, an instruction register, a program counter, an instruction register, a program status word, a constant register, a floating point register, or a conditional register. As other examples, identifier  may identify that the resource is an instruction such as \u201cJMP,\u201d \u201cJZ\u201d (jump if condition is equal to zero), \u201cJNZ\u201d (jump if condition is not equal to zero), \u201cMOV\u201d (move a value), or \u201cSysEnter\u201d (a fast call to a Ring 0 procedure). As yet further examples, identifier  may identify that the resource is one of other resources like a cache such as a translation lookaside buffer; a counter such as a time stamp counter; a logical core such as processor, processor . . . processorN of the system; or processor exceptions such as \u201cDIV\/0\u201d or interrupts such as an interprocessor interrupt or other global variables. Resource identifier  may be translated into a representation of the address of the instruction, register, or other resource represented by resource identifier . Resource type  may include an identification of the class or type of resource that the entry  includes. Some entries of PRCS  may apply to all resources of a particular type.","Trigger type  may include an identification of whether the handling of a resulting triggered event is synchronous or asynchronous. Synchronous triggers may cause the execution or communication of the trapped resource to halt until, for example, it is determined whether the attempt is indicative of malware. Asynchronous triggers may allow the execution or communication of the trapped resource to continue, while the trigger is, for example, recorded for future evaluation. In one embodiment, attempted accesses of resources triggered asynchronously may be used to build an evaluation of a larger series of actions, and the proper evaluation of such a series of actions may require multiple data points before a determination can be made. For example, whether a particular read of an instruction pointer register may not itself be malicious, but a subsequent use of the information returned may be malicious. Thus, a state machine may be used to first asynchronously trap the read of the instruction pointer register, but then synchronously trap its usage in another instruction.","When-to-trigger conditions  may include logical rules or conditions under which a triggered event will be generated based on the access of the resource. For example, triggered events may be generated for a register when the resource is written to or read. Triggered events may be generated for an instruction such as \u201cJMP\u201d when the instruction is executed. Triggered events may be generated for a cache such as a Translation Lookaside Buffer when the cache is invalidated. Triggered events may be generated for a processor core depending upon the state of the processor, such as when the core is idle. An processor exception or processor flag may be triggered when the flag or exception is set or written. When-to-trigger conditions  may include compound logical conditions, such as multiple conditions on a single resource (such as a value range), conditions on multiple resource (thus tying in multiple entries ), or a combination of both.","When-to-trigger conditions  may contain conditions according to the type of resource that is to be trapped. For example, a register may be triggered when it is written, written with a particular value, or read. In another example, a cache or pointer may be similarly triggered when it is written, written with a particular value, or read. In yet another example, a processing core may be triggered when the core is idle. In still yet another example, interprocessor interrupts such as one used to command processor cores to halt, sleep, or activate may be triggered before the interrupt is sent (upon attempted access of the global space of the interrupt table) or after the interrupt is sent (after the interrupt table is written).","Execution stage to trigger  may include an indication of in which stage of the execution of an instruction the attempted access will be trapped and a triggered event generated. Execution stage to trigger  may be used in combination with when-to-trigger conditions  as an additional requirement to trap a given resource. To trap a given entry, when-to-trigger conditions  may be evaluated when the associated instruction reaches the stage of execution specified in execution stage to trigger . Execution stage to trigger  may include entries corresponding to, for example, five stages or steps of the execution of an instruction by a processor. In one embodiment, five such stages of execution of an instruction may include 1) fetching the instruction, 2) decoding of the instruction, 3) execution, 4) accessing a memory location for the results, and 5) writing a return value back to memory, register, or another location. In such an embodiment, execution stage to trigger  may include the ability to trigger before or after any of the five stages. This provides a total of six different example triggering options\u2014before fetching, after decoding (and thus before execution), after execution (and thus before accessing a memory location), after accessing a memory location (and thus before writing a return value), and after writing a return value. The ability to trap based upon the stage of execution may provide significant flexibility unavailable in other anti-malware systems. For example, the result of executing a particular instruction may be unknown beforehand, and thus an anti-malware system may set the value of execution stage to trigger  to be after accessing a memory location for the results, but before writing a return value back to a register as commanded by the instruction. This may allow the anti-malware system to evaluate the results of the operation without allowing it to be written. If the results indicate a malicious operation, then a dummy value may be written back to the register instead of the value returned from the fourth stage of execution. Information about the attempted execution may be provided to a handler of the triggered event based on the attempted execution to help determine whether the attempt is malicious.","Each resource  of PRCS  may have multiple entries corresponding to combinations of the access of the resource  with another . Such combination of accesses may include a two-step or more process to be trapped. For example, entries  may include separate entries for a) the access of a memory location corresponding to an interrupt descriptor table (\u201cIDT\u201d) in combination with an access of control registers, and b) the access of a memory location corresponding to an interrupt descriptor table in combination with an access of general purpose registers. Furthermore, in  such separate entries may be handled by separate portions of system . For example, specific in-O\/S trapping agents  may handle gathering contextual information for trapped IDT-general register access, while other in-O\/S trapping agents  may handle gathering contextual information for trapped IDT-control register access.","Returning to , below-O\/S trapping agent  may be configured to set flags or add entries in PRCS . Below-O\/S trapping agent  may be configured to access one or more security rules such as security rules  to determine such flags or entries. In one embodiment, below-O\/S trapping agent  may be configured to receive instructions to set such flags or entries from triggered event handler , which may call below-O\/S trapping agent  after consulting security rules  or protection server . A set of specific privileged routines may be provided by processor  and\/or below-O\/S trapping agent  for setting flags or adding entries to PRCS .","If electronic device  includes more than one processor, each such processor may have a corresponding PRCS . In one embodiment, system  may include a below-O\/S trapping agent  for each such PRCS . In another embodiment, below-O\/S trapping agent  may be configured to trap resources represented in each such PRCS .","If system  supports virtualization, then PRCS  itself may be virtualized. The contents of a virtualized PRCS  may be limited to those resources which are virtualized by the corresponding processor . Such a virtualized PRCS  may be included in a virtual machine monitor. In such a case, below-O\/S trapping agent  or triggered event handler  may be configured to control PRCS  in such a virtual machine monitor. In another embodiment, below-O\/S trapping agent  may be configured to trap resources represented in each such PRCS . Furthermore, entries  may be created in and trigger flags  set in each such virtualized PRCS , on a per-PRCS or per-virtualized processor basis.","Below-O\/S trapping agent  may be configured to send a triggered event resulting from a trapped attempt or communication to triggered event handler . Triggered event handler  may be configured to perform any suitable subsequent action based on the information of the triggered event and one or more security rules . For example, triggered event handler  may be configured to allow execution of an attempted instruction, but require notification of the results after execution. In another example, triggered event handler  may be configured to skip the execution of a command or communication altogether. Such an example may be applied if no return value is required. In yet another example, execution may be transferred to a new location by, for example, by using a \u201cJMP\u201d instruction to send execution to the address of a repair routine.","In operation, below-O\/S trapping agent  and triggered event handler  may be operating on electronic device . Below-O\/S trapping agent  may be operating below the level of the operating systems of electronic device . Furthermore, triggered event handler  may also be operating below the level of the operating systems of electronic device . Triggered event handler  may consult security rules  or protection server  to determine what flags  or entries  to set in PRCS . Triggered event handler  may instruct below-O\/S trapping agent  what flags  or entries  to set in PRCS . Depending upon various conditions detected, such as applications  in use, other indications of malware detected, previously triggered events, or administrator settings for electronic device , below-O\/S trapping agent  and triggered event handler  may change the trigger flags  or add new entries  in PRCS  dynamically during the operation of electronic device . Information to base such dynamic changes may come from, for example, below-O\/S trapping agent  or in-O\/S agent . Entries  in PRCS  may be identified according to the resource  or resource type . The trigger type  may be set to configure a subsequent trapped event to be synchronous or asynchronous. When-to-trigger conditions  may be set to configure under what circumstances an intercepted request will generate a triggered event, as may execution stage to trigger .","Entries in PRCS  may be dynamically enabled or disabled, depending upon various conditions encountered by system . For example, below-O\/S trapping agent  may disable a trapping operation that is expensive because the attempted access that is trapped occurs frequently with many false-positives, until such a time that triggered event handler  receives an indication that the electronic device  is under a malware attack. Then, below-O\/S trapping agent  may enable the trapping operation. In one embodiment, under such conditions extensive trapping on one or more processor resources  may be enabled to prevent unknown malware actions from harming electronic device  further. Such extensive trapping may extend to essentially shutting down the entire execution environment of a processor, virtualized processor, thread, process or application.","A request for a processor resource  may arise from an entity at the level of operating systems in system , such as from application , driver , or operating system . The request may be passed through to processor resources  but intercepted by below-O\/S trapping agent . Furthermore, information or communication may be generated from the processor through various processor resources . The information or communication may be intercepted by below-O\/S trapping agent .","Below-O\/S trapping agent  may use PRCS  to trap an access of a resource if the information or communication matches any when-to-trigger  fields of entries  in PRCS , and subsequently generate a triggered event. Entries  which have been enabled by trigger flags  being set to \u201cON\u201d may be matched to the attempted access or information or communication. The resource to be accessed may be compared to the resource field  and\/or resource type field . If the resource to be accessed matches such fields, then when-to-trigger conditions  may be evaluated. If the when-to-trigger conditions  match system information or information about the request, then PRCS  may generate a triggered event. Execution stage to trigger  may be used to determine when to generate the triggered event. For example, the triggered event may be created before an instruction fetch, after an instruction fetch, after execution, after memory is accessed for a subsequent write, or after another resource such as a register is accessed for a write back. Furthermore, a triggered event may be generated for an attempted communication or generation of information such as an interprocessor interrupt like \u201cInterrupt_Sleep\u201d before or after the interrupt is sent or written to an interrupt table. A generated triggered event may be synchronous or asynchronous, depending upon trigger type . Below-O\/S trapping agent  may halt execution of the attempted access of the resource or generation of the communication if a synchronous triggered event is generated, pending handling of the event. Below-O\/S trapping agent  may allow execution of the attempted access of the resource or generation of the communication if an asynchronous triggered event is generated. Below-O\/S trapping agent  may add additional context information about the attempt into the triggered event, such as the memory address from which the attempt originated, where results were to be written, or any other suitable information.","Below-O\/S trapping agent  may include information related to the triggered event for the purposes of deciding whether the triggered event is suspicious. For example, below-O\/S trapping agent  may determine information such as determining from what portion of memory the attempted access was made. The portion of memory may be correlated by triggered event handler  against known processes, applications, or programs running on electronic device . If the attempted access arose from an unknown or unauthorized process, application or program, then the attempt may be suspicious. Triggered event handler  may use information from in-O\/S security agent  to determine such a correlation. In another example, below-O\/S trapping agent  may provide information regarding previously triggered events, such as those recorded in a state machine. Such previously triggered events that are related to the presently triggered events may provide contextual information about whether the attempts are suspicious.","Below-O\/S trapping agent  may pass the triggered event to triggered event handler , which may handle the event by evaluating information in the triggered event and\/or contextual information from in-O\/S agent  according to security rules . A resulting appropriate action may be determined and sent back to below-O\/S trapping agent  to apply to the trapped attempt. Such an action may include allowing the attempt, denying execution of an instruction, or substituting different data or instructions to circumvent operation of malware.","Below-O\/S trapping agent  may store triggered events for subsequent reference in trapping future attempted access. For example, a malicious operation may require multiple instructions to be executed by processor resources . Thus, each step of such malicious behavior may be reflected in a separate entry  in PRCS . Below-O\/S trapping agent  may trap a first step of a malicious operation, which by itself may not be malicious but only when in combination with subsequent steps. In such a case, the entry  for such a step may be set to trigger asynchronously, as the condition is merely recorded into a state machine so that below-O\/S trapping agent  or PRCS  may be aware of previously handled attempts. The trapping of a second step of a malicious operation may have as a when-to-trigger condition  the trapping of the first step.",{"@attributes":{"id":"p-0226","num":"0229"},"figref":"FIG. 11","b":["1100","1105","1110"]},"In step , entries corresponding to the resources or communications to be trapped may be written to a processor resource control structure, which may be configured to trap the operation, access, or other use of designated resources or communications under specified conditions. The entries in the PRCS may be written with identifications of the resource, the resource type, the conditions under which an event will be triggered, whether the trigger would be asynchronous or synchronous, and in\/at what, if any, execution stage the attempted access or communication should yield a triggered event. In step , entries in the PRCS may also be written with a trigger or enablement flag which indicates whether or not the entry is activated for trapping or not. If the trigger flag is not set, then the entry may be dormant and not be used to trap attempted accesses of resources.","In step , access to resources or generation of communications may be monitored. Such a monitoring may take place through the PRCS. Entities in the electronic device may try to attempt to generate processor communications or attempt to access a processor resource. Such attempts to access a resource may originate from the level of operating systems of the electronic device. If an instruction, command, or other attempt to access the resource matches a resource identifier of an entry in the PRCS wherein the entry has been activated, then the attempt may be trapped. Similarly, if a processor communication is generated that matches a resource identifier of an entry in the PRCS wherein the entry has been activated, then the attempt may be trapped. In one embodiment, the attempt to access a resource or generate communication may be trapped if the additional criteria specifying when to trigger are met. For example, an attempted write of a control register may be trapped when the control register is ever written. In another example, an attempted write of a control register may be trapped when the control register is written with a specific value.","In step , it may be determined whether an attempted access or communication was trapped. If no attempt has been trapped, then in step  it may be determined whether entries in PRCS need to be adjusted. Such an adjustment may include enabling or disabling such entries, adding new entries, or adjusting criteria or settings of entries. Method  may then return to step . Such adjustment could be based on, for example, new malware threats detected in the electronic device, passage of time, previously trapped attempts, or an administrator's settings.","In step , if an attempt has been trapped, it may be determined whether a resulting triggered event should be synchronous or asynchronous. If the trigger type is not synchronous, then method  may return to step  in parallel with proceeding to step . If the trigger type is synchronous, then in step  information about the trapped attempt may be stored. Such information may be used, for example, by a state machine in a future determination of whether a trapped attempt should yield a triggered event. In step , it may be determined whether all conditions of the trigger are met. Such conditions may require, for example, certain values to be written to the resource, or the request originate (or not originate) from particular locations in memory. Furthermore, such conditions may require that other attempts were previously trapped. Information about such attempts may be accessed and stored in a state machine. If all conditions of triggering are not met, then method  may return to step .","If all conditions of triggering are met, then in step  it may be determined in which, if any, specific stage of execution should the triggered event be generated. Such stages may include, for example, before an instruction in the attempt is fetched, after the instruction is fetched, after the instruction is executed, after memory is accessed to read a result, or after a value is written back. Furthermore, such stages may include before or after an interprocessor interrupt is executed. Once the designated execution stage is accomplished, a triggered event for the attempt may be generated in step . Contextual information, such as source or destination address of the attempt, or the resources involved may be included with the triggered event in step  for delivery to a handler in step .","In step , security rules may be consulted to determine in step  whether the triggered event is suspicious, not permitted by administrator settings, or indicative of malware. Contextual information, such as that of the triggered event, other events in the operating system of the electronic device, or administrator settings may be used to evaluate the application of the security rules to the triggered event. If the triggered event is not suspicious, then in step  the trapping agent may be notified and method  may return to step . If the triggered event is suspicious, then in step  a resulting corrective action may be sent to the trapping agent. Such a corrective action may depend upon the specific attempt to access resources or generate processor communication. For example, a malicious instruction may have a value to be read or written spoofed, or a jump instruction may be redirected to a repair routine. In step , the corrective action may be applied. The method  may return to step .",{"@attributes":{"id":"p-0233","num":"0236"},"figref":"FIG. 12","b":["1200","1201","1200","1220","1201","1201","1213","1220","1208","1206","1220"]},"Electronic device  may be implemented wholly or in part by or configured to implement the functionality of the electronic device  of , electronic device  of , electronic device  of , electronic device  of , electronic device  of , and\/or any combination thereof. Electronic device  may include one or more processors  coupled to a memory such as physical memory . Processor  may be implemented wholly or in part by or configured to implement the functionality of processor  of , processor  of , processor  of , processor  of , or any combination thereof. Physical memory  may be implemented wholly or in part by or configured to implement the functionality of memory  of , memory  of , memory  of , memory  of , and\/or any combination thereof. Electronic device  may include an operating system , which may include an in-O\/S security agent  coupled to one or more security rules . Operating system  may be implemented wholly or in part by or configured to implement the functionality of operating systems  of , operating system  of , operating system  of , operating system  of , operating system  of , and\/or any combination thereof. In-O\/S security agent  may be implemented wholly or in part by or configured to implement the functionality of in-O\/S security agent  of , in-O\/S security agent  of , and\/or in-O\/S security agent  of , in-O\/S security agent  of , or any suitable combination thereof.","Below-O\/S security agent  may be implemented by or configured to implement the functionality of below-O\/S trapping agent  or triggered event handler  of , SVMM  or SVMM security agent  of , firmware security agents , , below-O\/S agent , or PC firmware security agent  of , firmware security agent  of , or microcode security agent  or below-O\/S agent  of , below-O\/S trapping agent  or triggered event handler  of , and\/or any combination thereof.","Security rules  may be implemented by or configured to implement the functionality of security rules  of , security rules  of , security rules , ,  of , security rules  of , security rules ,  of , security rules  of , and\/or any combination thereof. Security rules  may be implemented by or configured to implement the functionality of security rules  of , security rules  of , security rules  of , security rules  of , and\/or any combination thereof.","Below-O\/S security  may be configured to intercept access to memory of electronic device . Such memory may include, for example, attempted access of addresses of physical memory  or attempted access of pages of virtualized memory . Such an attempted access may originate from operating system  or entities utilizing operating system  to run on electronic device , such as application  or driver .","In one embodiment, memory secured by below-O\/S security  may include virtualized memory . Virtualized memory  may include memory available to entities, such as operating system , application , or driver , that have been abstracted from physical memory and\/or storage. Virtualized memory  may appear as a contiguous block of memory to entities such as operating system , application , or driver , although the actual spaces used may be spread disparately across actual physical memory, such as physical memory , and\/or in storage such as on a disk. Virtualized memory  may be virtualized according to extensions of processor . The address space of virtualized memory  may be divided into memory pages. The memory pages may be each of equal size, such as four kilobytes. Electronic device  may be configured to use page tables to translate the virtual addresses of virtualized memory  into physical addresses of memory such as physical memory  or addresses of storage. Electronic device  may include a memory management unit  (\u201cMMU\u201d) configured to translate virtual addresses of virtual memory  into physical addresses of memory such as physical memory  and\/or into addresses of a storage. The pages of virtual memory  may be indexed. An attempted access of virtual memory  pages may include an attempted read, write, or execution of the page, and below-O\/S security agent  may be configured to trap the attempt. In one embodiment, a page of virtual memory  may correspond to a physical memory address or an address of a storage. In another embodiment, each page of virtual memory  may correspond to a physical memory address. In yet another embodiment, pages containing certain contents such as specific portions of operating system  may be pinned and may not change during the operation of electronic device .","In another embodiment, memory secured by below-O\/S security agent  may include physical memory . Physical memory  may be accessed through addresses of the physical memory, as shown by markers (A), (B), (C), (D), (E), (F), (G), (H), (I), (J), and (K), which denote specific addresses in physical memory  that may be the base address of a memory range containing a defined element. Physical memory  may be accessed through an attempted read, write, or execution of a specific memory address, and below-O\/S security agent  may be configured to trap the attempt. For example, an attempted write may take the form of an instruction \u201cMOV Addr, Value\u201d wherein a value represented by the variable \u201cValue\u201d is written to a specific memory address represented by \u201cAddr.\u201d Any instruction writing to a physical memory  address may be used. An attempted read may take the form of an instruction such as \u201cMOV Value, Addr\u201d wherein a value represented by the variable \u201cValue\u201d is read from a specific memory address represented by \u201cAddr.\u201d Any instruction reading from a physical memory  address may be used. An attempted execution may take the form of an instruction loading an instruction pointer register such as \u201cEIP\u201d with a physical memory  address, such as \u201cMOV EIP, Addr.\u201d Such an instruction may be configured to execute the code beginning at the address represented by \u201cAddr.\u201d Any instruction for executing an address in memory may be used.","Below-O\/S security agent  may be configured to intercept attempted access to virtual memory . Furthermore, below-O\/S security agent  may be configured to intercept attempted access to physical memory . In one embodiment, a request for virtual memory  may not be intercepted, but a subsequent corresponding attempted access of physical memory  after MMU has translated the virtual memory  page to a physical memory  address, below-O\/S security agent  may be configured to intercept the attempted access to physical memory. In another embodiment, an attempted access may be made directly of physical memory  without being translated through virtual memory , and below-O\/S security agent  may be configured to intercept the attempted access. In still yet another embodiment, an attempted access made to virtual memory  may be intercepted, but below-O\/S security agent  may not be configured to intercept a subsequent access of a physical memory  address.","Below-O\/S security agent  may be communicatively coupled to in-O\/S security agent . Below-O\/S security agent  may be configured to receive contextual information about an attempted access of memory of electronic device  from in-O\/S security agent . The contextual information provided by in-O\/S security agent  may include the identity of entities that have attempted a particular access of memory of electronic device .","Below-O\/S security agent  may be communicatively coupled to or include a memory map . Memory map  may be implemented in a file, record, data structure, or other suitable entity. Memory map  may include information regarding the location of various entities of electronic device  in memory. For example, if a process is loaded in memory of electronic device  for execution, memory map  may include information regarding which memory pages in virtualized memory  or address ranges in physical memory  contain the process. Depending upon the implementation of virtualization of memory in electronic device , all of the contents of the process may or may not be loaded in physical memory , as some contents may be loaded in storage such as a disk. For such contents to be accessed, they may be loaded into physical memory . In such a case, memory map  may contain information about addresses where the contents are stored, whether in physical memory  or in a storage such as a disk. Below-O\/S security agent  may be configured to use memory map  to determine the identity or the owner of any given content in a virtual memory  page or a physical memory  address. Below-O\/S security agent  may build memory map  by, for example, profiling the operation of the operating system , and then determining where in memory various sensitive components are located. As attempts to access memory are made\u2014such as loading the operating system  kernel, or executing kernel mode instructions\u2014below-O\/S security agent  may be configured to communicate with in-O\/S security agent  to determine what portion of operating system  is loading or being executed. In another example, below-O\/S security agent  may be configured to determine a hash or digital signature of the contents of a memory range of such a virtual memory  page. The hash or digital signature may be compared against known values, which may be contained in security rules  or obtained from protection server . The known values may be the result of a previous characterization, in which portions of, for example, operating system  have been identified. Elements to be mapped may be determined by security rules . Below-O\/S security agent  may be configured to track the movement of elements in memory map  as the elements are copied from one place to another in the memory of electronic device .",{"@attributes":{"id":"p-0243","num":"0246"},"figref":"FIG. 13","b":["1302","1304","1302","1304"]},"Virtual memory map  may reflect ten different virtual memory pages. Virtual memory map  may illustrate, for example, that a kernel operating system data structure such a page directory may be found in memory page  and memory page . In another example, the elements of a particular process, function, or routine called \u201cFn,\u201d may be found in memory pages -. In yet another example, data structures for permissions for a system service dispatch table (\u201cSSDT\u201d) may be found in page . In still yet another example, elements of a particular process, function or routine called \u201cFn\u201d may be found in memory page  and memory page .","Physical memory map  may reflect the location of elements with physical memory. Portions of elements in physical memory may be spread across the memory in non-contiguous segments or blocks. Furthermore, portions of elements in physical memory may be spread across the memory in arbitrary order. The size of each segment may vary in size. The segment may begin at an address at an offset from the base address. The example base address shown in  is 00\u00d7000, terminating at address FFxFFF. Addresses denoting the start of various segments of the physical memory are denoted (A)-(O). For elements that are contained within multiple segments of the physical memory, the order of the elements may be noted. In physical memory multiple segments of an element may be linked together by pointers where the end of one segment of an element may point to the next segment of the element.","For example, Fn may be mapped to the segments between (A) and (B), (J) and (K), and (M) and (N). In another example, SSDT permissions may be mapped to the segment between (G) and (H). In yet another example, the page directory data structure may be mapped to the segments between (O) and FFxFFF, (F) and (G), and (I) and (J). In still yet another example, Fn may be mapped to the segments between (H) and (I), and (B) and (C).","Returning to , below-O\/S security agent  may be configured to consult security rules  to determine what portions of memory to protect, and how to protect them. For example, security rules  may be configured to indicate that the page directory data structure may only be written to by certain privileged entities of electronic device . Thus, attempts to write to the page directory data structure may be trapped, and elements attempting the write may be examined to determine whether they are safe, unknown, or known to be unsafe. Below-O\/S security agent  may be configured to consult memory map  to determine where the page directory data structure is located in memory. If below-O\/S security agent  is implemented, for example, fully or in part in a virtual machine monitor, below-O\/S security agent  may be configured to set a flag in a control structure to trap any attempted write to memory pages  and\/or  of virtual memory . If below-O\/S security agent  is implemented, in another example, fully or in part in microcode, below-O\/S security agent  may be configured to set a flag in a control structure to trap any attempted write to memory addresses within the address ranges between addresses (O) and FFxFFF, (F) and (G), and (I) and (J) of physical memory .","In another example, security rules  may be configured to indicate that Fn may only be called by certain privileged entities of electronic device. Thus, attempts to execute Fn may be trapped, and elements calling Fn may be examined to determine whether they are safe, unknown, or known to be unsafe. Below-O\/S security agent  may be configured to consult memory map  to determine where Fn resides in memory. If below-O\/S security agent  is implemented, for example, fully or in part in a virtual machine monitor, below-O\/S security agent  may be configured to set a flag in a control structure to trap an attempted execution of memory pages , , and\/or  of virtual memory . If below-O\/S security agent  is implemented, in another example, fully or in part in microcode, below-O\/S security agent  may be configured to set a flag in a control structure to trap any attempted execution of memory address (A) of physical memory . In some cases, wherein different portions of Fn may be separately executed, below-O\/S security agent  may be configured to trap attempted execution of any memory address within the ranges between (A) and (B), (M) and (N), the addresses (O) and FFxFFF, (F) and (G), (J) and (K), or (I) and (J) of physical memory .","In one embodiment, below-O\/S security agent  may be configured to consult in-O\/S security agent  to determine what entity has made the call to write to memory, which is then used to determine whether the entity is authorized or not to make the write. In another embodiment, below-O\/S security agent  may be configured to determine the memory page of virtualized memory  from which the request came and consult memory map  to determine whether such a memory page is associated with any elements mapped therein. In yet another embodiment, below-O\/S security agent  may be configured to determine a hash or signature of a memory page of the requesting element and compare it against hashes and signatures of known entities.","If below-O\/S security agent  is implemented fully or in part by microcode, below-O\/S security agent  may be configured to determine the address of the instruction which attempted the write. In one embodiment, below-O\/S security agent  may be configured to make such a determination by examining an instruction pointer to determine where in physical memory  the instruction was made. In another embodiment, by accessing memory map , below-O\/S security agent  may be configured to determine an element from the memory map  associated with the address. In yet another embodiment, below-O\/S security agent  may be configured to determine a hash or signature of the requesting element and compare it against hashes and signatures of known entities.","Once an attempted access of memory has been trapped, below-O\/S security agent  may be configured to access security rules  to determine how to handle the trapped attempt based on the identified requesting entity. Security rules  may define that, for example, only certain specified kernel portions of operating system  may call and execute Fn or that only entities that are known to be safe and on a whitelist may write to the permissions of the SSDT. Below-O\/S security agent  may then be configured to take any appropriate action, such as allowing the request to proceed, denying the request, spoofing a response or written value, or executing a corrective process.","In operation, below-O\/S security agent  may be running below the level of operating systems of electronic device  such as operating system . Below-O\/S security agent  may access security rules  to determine what memory resources of electronic device  to protect. Below-O\/S security agent  may determine, develop, and\/or populate the contents of memory map . To do so, below-O\/S security agent  may access security rules , protection server , or any other suitable source of information for populating information in memory map . Below-O\/S security agent  may intercept requests of physical memory  or virtual memory  from entities at the operating system level, such as operating system , application , or driver , to map the ownership and contents of memory in memory map . Below-O\/S security agent  may access in-O\/S security agent  to determine what entities are being loaded into memory so that memory map  may be populated. Memory map  may contain memory mapping for physical memory , virtual memory , and\/or mappings between the two.","Below-O\/S security agent  may consult security rules  to determine what portions of virtual memory  and\/or physical memory  to protect. Security rules  may specify that some portions of memory are to be secured on a dynamic basis, wherein protection for the memory may be enabled or disabled by below-O\/S security agent  depending upon a variety of considerations. Such considerations may include, for example, administrator settings, detection of malicious or suspicious behavior, time, previously detected accesses of memory, or any other suitable criteria. If protecting memory of electronic device  is expensive in terms of computational resources, such dynamic enabling and disabling may allow below-O\/S security agent  to better secure critical portions of the memory of electronic device  while lessening side affects on the ability of electronic device  to carry out other tasks. For example, memory containing the contents of the kernel code of operating system  may always be protected by below-O\/S security agent , while the memory containing the contents of the code of a third-party application  may be protected only upon other indications that malware is present or may affect the third-party application .","Below-O\/S security agent  may set a flag in a control structure to trap attempted access of physical memory  and\/or virtual memory . In one embodiment, as a request is made from an entity in operating system  for a memory page in virtual memory  designated to be trapped, below-O\/S security agent  may intercept the attempted request. In another embodiment, as a request is made for a memory page in virtual memory , below-O\/S security agent may allow the request to be translated by MMU  into a request for an address in physical memory , whereupon below-O\/S security agent may intercept the attempted request. In yet another embodiment, as a request from an entity in operating system  may be made for an address in physical memory  directly, below-O\/S security agent  may intercept the attempted request.","Once a request has been intercepted, below-O\/S security agent  may use any suitable mechanism to evaluate the intercepted request of memory. Security rules  may be used to determine whether the attempt is suspicious, indicating a malicious attempt by malware to use the resources of electronic device . Security rules  may include considerations of, for example, whether a read, write, or execution was attempted; what entity made the attempt; the memory address or page that was accessed; previous attempts or actions by the same requestor; security settings by an administrator of electronic device , such as rules that are more or less restrictive based upon the user of electronic device ; or the identity of the requestor, as determined by memory location and\/or digital signature or hash, or upon related pages or memory addresses.","For example, an attempted write of the page directory data structure in page  of virtual memory  or at address (J) of physical memory  may be intercepted by below-O\/S security agent . If the write has come from a portion of memory of a process that is unknown, the write may be determined to be suspicious by below-O\/S security agent . However, if the attempted write has come from a known, verified part of the operating system  kernel, then the attempt may be determined to not be suspicious. Likewise, an attempted execution of Fn at page  of virtual memory  or at address (H) of physical memory  may be intercepted. If the attempted execution was made from a user input, then the execution may be determined to not be suspicious. If the attempted execution was made from the memory of another program, and the program is not on an approved list, then the attempt may be determined to be suspicious or malicious.","In another example, if Fn is a web browser that normally exposes its cache to other applications for purposes of interoperability, below-O\/S security agent  may allow a specified portion of the memory pages or memory addresses of Fn to be read by other applications. However, if Fn contains metadata or other information that should be kept private, then below-O\/S security agent  may secure those portions of the memory pages or memory addresses of Fn from being read from any process other than Fn itself.","Once a program has been determined to be suspicious, malicious, or otherwise indicative of malware, then below-O\/S security agent  may take any suitable corrective action. Below-O\/S security agent  may, for example, deny a write request to memory page  of virtual memory  or address (J) of physical memory , yet return a result indicating that the value was written. The process generating the request may be monitored for additional attempts to access the resources of electronic device , may be stopped, or may be cleaned from electronic device . In another example, the attempted execution of page  of virtual memory  or address (H) of physical memory  may instead be directed to the execution of a honeybot process or a cleanup process.","The contents of the memory which are secured by below-O\/S security agent  may include data, code, or any other useful system resources which may be attacked by malware. Below-O\/S security agent  may protect the contents of memory against malware attempting to, for example, read, write, or hook mechanisms showing the processes running on electronic device , inject its code into portions of applications loaded in memory, or change permission and access flags of mapping tables for virtual memory . By operating below the level of operating system , below-O\/S security agent  may avoid malware running at the kernel mode level in operating system . Below-O\/S security agent  may accomplish zero-day detection, as in some cases it may not need knowledge that the identity of a requesting entity has been previously determined to be malicious\u2014the fact that the entity is unknown may be used to deny access to some parts of the memory of electronic device . If the operating system  or antivirus or antimalware measures running in the operating system  are completely compromised, the memory may be completely locked from entities running at the level of the operating system.","One application of below-O\/S security agent  may be to detect an attempted access of the contents of virtual memory  even before a read, write, or execute of the specific contents is attempted by detecting a change to the permissions of the particular memory page. The memory tables used by MMU  may be resident in memory, in a page of virtual memory  itself, and\/or address of physical memory . An attempt to change the values of the memory table, for example, to change the permissions of a code section of a process from \u201cread\u201d to \u201cwrite,\u201d may itself be trapped by below-O\/S security agent . The memory page of virtual memory  or the address of physical memory  may be secured by below-O\/S security agent , and upon a trapped attempt to write a new value to the permissions in such a location, below-O\/S security agent  may determine whether the requestor of the attempt is allowed to make such changes. For example, if the request to change the permissions of a code section of a process arose from a different process, the attempted change in permissions may be denied.",{"@attributes":{"id":"p-0261","num":"0264"},"figref":"FIG. 14","b":["1400","1405"]},"In step , security rules may be accessed to determine in step  addresses of physical memory or pages of virtual memory to be secured. The memory to be secured may depend, for example, upon the security rules, the user of the electronic device, other observed behavior in electronic device such as indications of malware, previous attempts to access secured memory, or administrator settings. The memory to be secured may change dynamically, as conditions of the operation of the electronic device may change. The security rules may specify entities of electronic device to be protected, and the location in physical or virtual memory of the entities may be determined by accessing the memory map.","In step , flags may be set in a control structure to trap attempted access of memory according to the requirements of the security rules. Such flags may be set for pages of virtual memory and\/or addresses of physical memory. Flags may contain an indication of the memory that is to be secured, as well as the kind of access method (for example\u2014read, write, or execute) that is to be flagged. In step , access to the secured memory may be monitored to see if an attempted access of the designated type has been made to a designated address or page. In step , it may be determined whether an attempt to access the memory has been trapped. If not, then in step  it may be determined whether flags of the memory to be secured require changing. If so, then the method  may return to step  to access security rules to update the flags for guarding access to memory. If not, then the method  may return to step  to monitor for attempted access of secured memory.","If an attempt to access the memory has been trapped, then beginning in step  the trapped attempt may be evaluated. To evaluate the attempt, the memory map may be consulted to determine from where the request was made, and identify the requestor. The values of data to be written may be determined and evaluated for their contents. The nature of the attempt\u2014read, write, or execute\u2014may be considered. These example considerations may be used in conjunction with the security rules to determine whether or not the attempted access is indicative of malware in step . If the attempted access is indicative of malware, then in step , corrective action may be taken. Such corrective action may include denying the requested access, returning a spoofed value, or initiating a honeybot or corrective process. If the attempted access in not indicative of malware, then in step  the request may be allowed. Method  may return to step  as required to continue securing the memory of the electronic device.",{"@attributes":{"id":"p-0265","num":"0268"},"figref":"FIG. 15","b":["1500","1513","1501","1500","1520","1522","1501","1501","1513","1520","1522","1508","1504","1520","1522"]},"Electronic device  may be implemented wholly or in part by or configured to implement the functionality of the electronic device  of , electronic device  of , electronic device  of , electronic device  of , electronic device  of , electronic device  of , and\/or any combination thereof. Electronic device  may include one or more processors  coupled to a memory . Processor  may be implemented wholly or in part by or configured to implement the functionality of processor  of , processor  of , processor  of , processor  of , processor  of , and\/or any combination thereof. Memory  may be implemented wholly or in part by or configured to implement the functionality of memory  of , memory  of , memory  of , memory  of , memory  of , and\/or any combination thereof. Electronic device  may include an operating system , which may include a system call table , a virtual memory page table , and an in-O\/S security agent . Operating system  may be implemented wholly or in part by or configured to implement the functionality of operating systems  of , operating system  of , operating system  of , operating system  of , operating system  of , operating system  of , and\/or any combination thereof. In-O\/S security agent  may be implemented wholly or in part by or configured to implement the functionality of in-O\/S security agent  of , in-O\/S security agent  of , in-O\/S security agent  of , in-O\/S security agent  of , in-O\/S security agent  of , and\/or any suitable combination thereof. Security rules  may be implemented by or configured to implement the functionality of security rules  of , security rules ,  of , security rules , , ,  of , security rules  of , security rules , ,  of , security rules ,  of , security rules ,  of , and\/or any combination thereof. Protection server  may be implemented wholly or in part by or configured to implement the functionality of protection server  of , protection server  of , and\/or any combination thereof.","Below-O\/S trapping agent  may be implemented by or configured to implement the functionality of below-O\/S trapping agent  of , SVMM  of , firmware security agents ,  and\/or PC firmware security agent  of , firmware security agent  of , and\/or microcode security agent  of , below-O\/S trapping agent  of , below-O\/S security agent  of , and\/or any combination thereof. Triggered event handler  may be implemented by or configured to implement the functionality of triggered event handler  of , SVMM security agent  of , below-O\/S agent  of , below-O\/S agent  of , triggered event handler  of , and\/or any combination thereof. In various embodiments, some of the functionality of below-O\/S trapping agent  may be accomplished by triggered event handler , and\/or some of the functionality of triggered event handler  may be accomplished by below-O\/S trapping agent . Furthermore, below-O\/S trapping agent  and triggered event handler  may be implemented in the same software module.","Page table  may be implemented as a data structure and may be used to implement the virtual memory system of operating system . The virtual memory system is a memory management system that virtualizes access to a memory  of an electronic device . In a virtual memory system, software processes executing on the operating system  are provided with a virtual address space which a process may treat as a contiguous block of memory. In reality, the virtual address space may be dispersed across different areas of physical memory. When a process requests access to memory, the operating system  may be responsible for mapping the virtual address of the process into the physical address in memory  where the data is actually stored. A virtual address space may be divided into fixed size blocks of contiguous virtual memory addresses called virtual memory pages. Page table  may be used to store the mapping from a virtual memory page to its corresponding physical address in memory  where the virtual memory page is stored. Page table  may include various access permissions, such as read, write, and\/or execute, to specify the type of access that is authorized for a given virtual memory page. In some embodiments, below-O\/S trapping agent  and\/or triggered event handler  may be configured to catch any generated exceptions or attempted read, write, or execute operations and use security rules  to determine if the unauthorized request to access memory  is indicative of malware.","System call table  may be a data structure used by operating system  for implementing system calls. A system call may be a routine and\/or system service provided by the operating system . System call table  may provide an interface between an application  and an operating system , allowing the application  to request the operating system  to perform an operation that the application  may not be authorized to perform. Each system call may be identified using an index into system call table  where an entry for the particular system call may be stored. Each entry in system call table  may store the address in memory  where the code corresponding to the particular system call may be stored. Such entries may be implemented as pointers. A system call may be executed by informing operating system  of the appropriate index and subsequently transferring control to operating system . Operating system  may then consult system call table  to identify the location in memory  where the code corresponding to the particular system call is stored. Operating system  may then execute the code and return control to the software component responsible for requesting the system call. Descriptions of example embodiments of system call table  may be found in discussions of system call table  from , below.","Below-O\/S trapping agent  may be configured to intercept access to or information from any suitable resource  associated with system calls, such as memory  and\/or processor . For example, resources  may be implemented by or configured to implement the functionality of resource  of , system resources  of , system resources of , processor resources  of , virtual memory  and\/or physical memory  of , and\/or any combination thereof. Resources  may include resources available to a processor such as processor  for enabling the processor to load and execute instructions. Such resources may include, for example, data registers, control registers, caches, processor flags, processor cores, processor exceptions, and\/or processor interrupts. Resources  may also include virtual and\/or physical memory . An attempted access of such a resource may include an instruction, such as an assembly language instruction with operands, and such an attempted access may be trapped by trapping the execution of the instruction.","Below-O\/S trapping agent  may be configured to intercept access to or information from any suitable resource, such as memory  and\/or resources of processor . Below-O\/S trapping agent  may include a system call trapper  that may be used to trap attempts to access system calls and\/or system call table . System call trapper  and\/or triggered event handler  may then use contextual information associated with a trapped attempt, in conjunction with security rules , to determine whether to allow, deny, and\/or report the attempt to one or more subscribers . The contextual information may include the requesting entity of the trapped access attempt, the particular system call at issue, and\/or the particular type of access attempted (e.g., an attempt to execute the system call or an attempt to read\/write to an entry in system call table ).","System call trapper  may be a module and\/or component of below-O\/S trapping agent  and may be configured to trap access to system calls in any suitable manner. For example, system call trapper  may be configured to trap the execution of an assembly language instruction used to implement system calls, such as an instruction that transfers control to operating system  for execution of a system call. The particular instruction to trap may depend on the particular processor  and\/or operating system  of electronic device . As an example, when using a variant of Microsoft Windows\u2122 executing on a processor  that supports an x86 instruction set architecture (\u201cISA\u201d), system call trapper  may trap attempts to execute the \u2018SysEnter\u2019 and\/or \u2018KiFastSysCall\u2019 instructions. These instructions function to transfer control to operating system  to execute a system call. Trapping attempts to execute the \u2018SysEnter\u2019 instruction may only trap attempts from software executing at \u201cRing3\u201d priority, while trapping attempts to execute the \u2018KiFastSysCall\u2019 instruction may trap attempts from software executing at either \u201cRing0\u201d or \u201cRing3\u201d priority. In some embodiments, an attempt to execute the \u2018SysEnter\u2019 and\/or \u2018KiFastSysCall\u2019 instructions may be trapped by trapping an attempt to execute the virtual memory page corresponding to the physical memory location where the particular instructions may be stored.","In another embodiment, system call trapper  may be configured to trap attempts to access system call table . The particular method used to trap attempts to access system call table  may depend on the particular processor  and\/or operating system  of electronic device . When using a processor  that supports an x86 ISA, system call trapper  may trap attempts to read or write to system call table  by trapping certain attempts to execute the MOV instruction. For example, system call trapper  may trap attempts to write to system call table  by trapping the instruction \u201cMOV syscall_table_address, EAX\u201d. This instruction may operate to write the value from the EAX register into an entry into the system call table at the memory address specified by syscall_table_address. By trapping attempts to write to system call table , system call trapper  may prevent malware from overwriting an entry in the system call table  with a memory address containing malicious code. Similarly, system call trapper  may trap attempts to read from system call table  by trapping the instruction \u201cMOV EAX, syscall_table_address\u201d. This instruction may operate to read the value from an entry in system call table  at the memory address specified by syscall_table_address. Trapping attempts to read an entry in system call table  will effectively trap all attempts to execute the system call associated with the entry in the system call table , as the system call table  must be read to allow the operating system  to identify the location in memory of the code corresponding to the system call. In addition, trapping attempts to read to an entry in system call table  will trap any direct attempt to read to the system call table , such as by malware. In some embodiments, all attempts to read system call table  are trapped. In some embodiments, an attempt to access system call table  may be trapped by trapping an attempt to access the virtual memory page corresponding to the physical memory location where system call table  may be stored.","In yet another embodiment, system call trapper  may be configured to trap an attempt to execute a system call by trapping an attempt to execute code at a memory location where code for the system call resides. System call table  may be consulted to identify the memory location where code for a particular system call resides. The particular method used to trap an attempt to execute a system call may depend on the type of processor  in electronic device . In one embodiment, an attempt to execute a system call may be trapped using a trigger based on the value of, for example, the Instruction Pointer (IP) register. In some embodiments, the IP register may be known as the Program Counter (PC) register. The IP register may be used to store the address of the instruction currently being executed or the address of the next instruction to be executed, depending on the particular processor. When using a processor  that supports an x86 ISA, system call trapper  may trap attempts to execute a particular system call by monitoring the value of the IP register and trapping execution when the value of the IP register contains the address of the system call. In another embodiment, an attempt to execute a system call may be trapped by trapping an attempt to execute the virtual memory page corresponding to the physical memory location where the code for the system call may be stored. System call table  may be consulted at the index corresponding to the particular system call to be trapped to identify the location in memory of the code corresponding to the system call. In one embodiment, the execution of the memory locations containing the routines and functions linked to in system call table  may be trapped by trapping an instruction for transferring control, such as a \u201cJMP\u201d routine directed towards a location known to be within system call table .","The specific implementation of the above methods for trapping access to system calls and system call table  may depend on the particular implementation of below-O\/S trapping agent  and\/or system call trapper . For example, if below-O\/S trapping agent  and\/or system call trapper  are implemented in a virtual machine monitor, any trapping based on a specific memory address (e.g., trapping based on an attempt to read\/write to an entry in the system call table and\/or trapping based on execution at a memory location containing the code of a system call) may be based on the virtual memory address, as the memory address may not have been converted from a virtual memory address into a physical memory address. As another example, if below-O\/S trapping agent  and\/or system call trapper  are implemented in a microcode security agent, any trapping based on a specific memory address may be based on the physical memory address, because the conversion from a virtual address to a physical address may have already been performed at the microcode level.","The memory location of the instruction making the attempt to access system call table  or the functions associated with system call table  may be detected during the trapping of the attempt. The memory location may be analyzed to determine the entity making the attempt.","After trapping a particular attempt, system call trapper  may create and send a triggered event associated with the attempt to triggered event handler . Triggered event handler may then use contextual information associated with the trapped event, in conjunction with security rules , to determine whether to allow, deny, and\/or report the event to one or more subscribers . Contextual information may include the requesting entity of the trapped event, the particular system call at issue, and\/or the action requested (e.g., an attempt to execute a system call and\/or an attempt to read\/write to an entry in system call table ). For example, only certain entities known to be safe and free from malware may be allowed to write to system call table . An entity whose malware status was previously unknown may be determined to be malware based on an unauthorized attempt to write to system call table . In another example, execution of functions linked to in system call table  may be trapped, and execution may be allowed only if the entity making the call to the function made such an attempt through system call table . An attempt by an entity, whose malware status was previously unknown, may be denied direct access to executing such functions. In addition, an entity that is determined to be malware, through a blacklist or other determination, attempting access to system call table  or its related functions may be denied access, and other suitable corrective action may be taken.","Subscribers  may include any entities with use for information associated with a trapped attempt to access system call table  and\/or a trapped attempt to execute a system call. Subscribers  may include applications  and\/or security agents on electronic device , and\/or may include third party applications or other software. For example, a subscriber  may include security software executing on electronic device , such as below-O\/S trapping agent , triggered event handler , and\/or in-O\/S security agent , which may use the contextual information associated with the trapped attempt for detecting malware. In some embodiments, each subscriber  may provide its own security agent operating at the same priority level as below-O\/S trapping agent , such as, for example, a firmware security agent. A subscriber  may also include security software executing remotely, such as on protection server . As another example, subscribers  may include a manufacturer of a particular resource, such as any I\/O device used by electronic device . The manufacturer may be interested in any suspicious attempts to compromise the resource via access to the system call table and\/or execution of a system call, such as a system call associated with the resource. As another example, subscribers  may include an administrator of a digital rights management (\u201cDRM\u201d) system. A DRM system may limit and\/or control the use of digital content and is commonly used to protect digital content protected by copyright, such as video and\/or music content. The administrator of a DRM system may be interested to know when and how various digitally protected files are accessed and may accomplish this by tracking various system calls that may be used to access the protected files. An Application Programming Interface (\u201cAPI\u201d) may be provided to the subscribers  to allow subscribers  to access the information associated with a trapped attempt to execute a system call and\/or trapped attempt to access system call table .",{"@attributes":{"id":"p-0279","num":"0282"},"figref":["FIG. 16","FIG. 15"],"b":["1601","1601","1606","1608","1604","1601","1504","1601","1601","1604","1604"]},"A system call  may provide an interface between an application and an operating system, allowing the application to request the operating system to perform an operation that the application may not be authorized to perform. For example, an application, which typically executes at \u201cRing3\u201d priority, may need to access a file on a disk but may not have permission to perform disk I\/O operations. The application may use a system call , such as a read or write file system call, to transfer control to the operating system to allow the operating system to satisfy the request from the application. The operating system, which may be executing at \u201cRing0\u201d priority, may provide the service associated with the particular system call  and may then transfer control back to the application. For example, the operating system may access system call table  to identify the memory address  where the code corresponding to the system call  is located. The operating system may then execute the code at the specified address  in memory , and may then transfer control back to the application. In this manner, the application may utilize certain services that are typically only available to software executing at \u201cRing0\u201d priority, such as the operating system.","Each system call  may be referenced using an index  into the system call table  where the entry for the system call  is stored. For example, system call table  has N total entries, and each entry may be referenced using an index  ranging from 0 to N\u22121. A system call  may be executed by informing the operating system of the appropriate index  and transferring control to the operating system. In some embodiments, a software component may specify the appropriate index  by placing the index into a register of the processor, and may then execute an instruction to transfer control to the operating system for execution of the system call . For example, in one embodiment using an x86 instruction set architecture (\u201cISA\u201d), the following instructions may be used to implement system calls for an application:","\u201cMOV EAX, index\u201d","\u201cSysEnter\u201d","The first instruction moves \u2018index\u2019 into the EAX register of the processor, where \u2018index\u2019 is an integer corresponding to the index  in the system call table  where the entry of the particular system call  resides. The \u2018SysEnter\u2019 instruction then transfers control to the operating system, and the operating system may access system call table  at the index  specified in the EAX register. The entry at the particular index  of system call table  may specify a memory address  pointing to the location in memory  where the code for the particular system call  resides. The processor may then execute the code located at the specified address  in memory . System calls  may be executed by any software component, including applications, operating systems and\/or drivers. As an example on an x86 ISA, an operating system and\/or driver may execute systems calls  in a similar manner to an application, except using the \u2018KiFastSysCall\u2019 instruction.","System calls  may be added to and\/or removed from system call table . For example, if a new device is added to an electronic device, a device driver for the new device may need to be loaded by the operating system and a system call  may need to be added to system call table  to allow applications to utilize the functionality of the new device. The code for the new system call may be loaded into memory , and an entry for the new system call  may be added to the end of system call table , specifying the address  in memory  where the code for the system call resides.","The above described embodiments for implementing system calls  are merely a few of many possible embodiments. System calls  and\/or system call table  may be implemented in any suitable manner. The specific implementation of system calls  and\/or system call table  may depend on the particular processor and\/or operating system of an electronic device.",{"@attributes":{"id":"p-0287","num":"0290"},"figref":"FIG. 17","b":["1700","1705","1705","1710","1715","1740"]},"In step , an attempt to execute a system call and\/or access the system call table may be intercepted. In some embodiments, an attempt to execute a system call may be intercepted by trapping an attempt to execute a control transfer instruction used to implement system calls. For example, some processors and\/or operating systems may implement system calls using a control transfer instruction, such as the SysEnter and\/or KiFastSysCall instruction, and an attempt to execute a system call may be intercepted by trapping execution of the appropriate control transfer instruction. An attempt to execute a system call may also be intercepted by trapping an attempt to execute the virtual memory page corresponding to the physical memory location where the particular control transfer instructions may be stored. In some embodiments, an attempt to execute a system call may be intercepted by trapping an attempt to execute code at a memory location containing the code of a system call. In such embodiments, the trapping may be based on the value of the IP register. For example, the system call table or a memory map may be consulted to identify a memory location containing the code for a system call, and a trap may occur when the IP register contains the address of the memory location for the particular system call. In other embodiments, an attempt to execute a system call may be intercepted by trapping an attempt to execute the virtual memory page corresponding to the physical memory location where the code for the particular system call may be stored. In some embodiments, an attempt to read or write to the system call table may also be intercepted. In such embodiments, the attempt may be intercepted by trapping execution of an instruction used to read or write to a memory location in the system call table. For example, on the x instruction set architecture, the MOV instruction may be trapped when it is used to read or write to a location in the system call table. An attempt to read or write to the system call table may be also intercepted, in some embodiments, by trapping an attempt to access the virtual memory page corresponding to the physical memory location where system call table may be stored.","In step , the source of the attempted access is identified. For example, the attempted access may be from an application, driver, in-O\/S security agent, the operating system, and\/or other software entity. In step , it is determined whether the attempt is authorized. Security rules may be used in conjunction with contextual information associated with the attempt to determine whether a particular attempt may or may not be authorized. The contextual information may include the source of the attempted access and\/or the specific type of access. For example, the security rules may specify that only the operating system may write to the system call table. As another example, the security rules may specify that a signed driver or other software component associated with an entry may write to its own entry. If the attempt is authorized, then in step  access is allowed. If the attempt is not authorized, then in step  access is denied. Finally, in step , it is determined whether the attempt should be reported to one or more subscribers. Whether the attempt should be reported may depend on the particular system call at issue and the contextual information associated with the attempted access. The security rules may specify when an attempt to execute a system call and\/or access the system call table should be reported to one or more subscribers.","The steps of the method from  may be repeated as necessary to protect the electronic device continuously, periodically, upon demand, and\/or upon the triggering of an event.","Methods , , , , , and  may be implemented using any of the systems of , -, , , , and  and\/or any other system operable to implement methods , , , , , and . As such, the preferred initialization point for methods , , , , , and  and the order of their respective steps may depend on the implementation chosen. In some embodiments, some steps may be optionally omitted, repeated, and\/or combined. In some embodiments, some steps of one or more of methods , , , , , and  may be executed in parallel with other steps of the methods. In certain embodiments, methods , , , , , and  may be implemented partially or fully in software embodied in computer-readable media.","For the purposes of this disclosure, computer-readable media may include any instrumentality or aggregation of instrumentalities that may retain data and\/or instructions for a period of time. Computer-readable media may include, without limitation, storage media such as a direct access storage device (e.g., a hard disk drive and\/or floppy disk), a sequential access storage device (e.g., a tape disk drive), compact disk, CD-ROM, DVD, random access memory (RAM), read-only memory (ROM), electrically erasable programmable read-only memory (EEPROM), and\/or flash memory; as well as non-transitory communications media and\/or any combination of the foregoing.","Although the present disclosure has been described in detail, it should be understood that various changes, substitutions, and alterations can be made hereto without departing from the spirit and the scope of the disclosure as defined by the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["For a more complete understanding of the present invention, and the advantages thereof, reference is now made to the following written description taken in conjunction with the accompanying drawings, in which:",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 17"}]},"DETDESC":[{},{}]}
