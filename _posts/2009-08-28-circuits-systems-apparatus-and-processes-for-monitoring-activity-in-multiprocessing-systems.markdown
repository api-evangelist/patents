---
title: Circuits, systems, apparatus and processes for monitoring activity in multi-processing systems
abstract: An electronic circuit includes a first processor () operable to perform processing operations, a first trace buffer () coupled to the first processor (), a first triggering circuit () coupled to the first processor (), the first triggering circuit () operable to detect a specified sequence of particular processing operations in the first processor (); a second processor (), a second trace buffer () coupled to the second processor (), a second triggering circuit () coupled to the second processor (), the second triggering circuit () operable to detect at least one other processing operation in the second processor (); and a cross trace circuit () having a trace output and having inputs coupled to the first triggering circuit () and to the second triggering circuit (), the cross trace circuit () configurably operable to respond to a sequence including both a detection of the sequence of particular processing operations of the first processor () by the first triggering circuit () and a detection of the at least one other processing operation of the second processor () by the second triggering circuit (), to couple at least one of the first trace buffer () and the second trace buffer () to the trace output. Various circuits, devices, telecommunications products, wireless handsets, systems and processes of operation and manufacture are disclosed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08407528&OS=08407528&RS=08407528
owner: Texas Instruments Incorporated
number: 08407528
owner_city: Dallas
owner_country: US
publication_date: 20090828
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","STATEMENT REGARDING FEDERALLY SPONSORED RESEARCH OR DEVELOPMENT","COPYRIGHT NOTIFICATION","FIELD OF TECHNOLOGY","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF EMBODIMENTS"],"p":["This application claims the benefit under 35 U.S.C. 119(e) of U.S. Provisional Application No. 61\/221,760 (TI-64749PS) entitled \u201cCircuits, Systems, Apparatus and Processes for Coordinating Trace Activity in Multi-Processing Systems\u201d filed on Jun. 30, 2009, and which is incorporated herein by reference in its entirety.","U.S. non-provisional published patent application 20070226795 (published Sep. 27, 2007, TI-61985) \u201cVirtual Cores and Hardware-Supported Hypervisor Integrated Circuits, Systems, Methods and Processes of Manufacture\u201d U.S. Ser. No. 11\/671,752, is hereby incorporated herein by reference.","Not applicable.","Portions of this patent application contain materials that are subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document, or the patent disclosure, as it appears in the United States Patent and Trademark Office, but otherwise reserves all copyright rights whatsoever.","The technology relates to circuits, systems, apparatus and processes with multiple processing units generally, and to system on a chip (SoC) integrated circuits, and with trace circuits for debug of multi-processor systems. Hardware and processes initiate and coordinate trace activity for multiple processors, and can record or export the resulting data.","In the past, most processing systems had only a single processor. Recent processors have added trace capability where Program Counter (PC) activity can be traced. Some systems also provide Data Trace and timing information. The trace output stream can impose very high bandwidth requirements, and such streams of trace data can overwhelm an attempt to capture them. A VLIW DSP (very long instruction word digital signal processor), such as a TMS64xx\u2122 processor from Texas Instruments Incorporated with eight data paths running at 600 MHz, can execute 4.8 BOPS (billion operations per second), i.e. the product of 8 instructions\/clock-cycle\u00d7600 MHz. Capturing four-byte or 32-bit PC (program counter) values from even a single processor CPU running at 600 MHz would generate 2.4 GByte\/sec of PC data (4 bytes\/cycle\u00d7600 MHz). Serial output of the data would involve a clock rate of 19.2 GHz (8 bits\/byte\u00d72.4 GByte\/sec), which would be impractical or at least uneconomical for most current systems. Even if on-chip compression were used to reduce this enormous bandwidth requirement by, e.g. a factor of 10 depending upon the program activity, the resulting average trace bandwidth would be 240 MB\/sec.","Moreover, combining trace streams for multiple processors would effectively multiply the clock rate specification imposed on a serial port for them. Conversely, given an available serial clock, combining trace streams for multiple processors effectively reduces the bandwidth available for each of the processors being traced by the number of trace data streams. Exporting larger and larger amounts of data at higher and higher data rates becomes very expensive and indeed impractical, especially when the recent devices now have four (4), eight (8), and more processors.","Merely acquiring and combining independent free-running trace streams from multiple processors is likely to be wasteful of the trace bandwidth. Even if the trace streams for an individual processor were somehow qualified to try to only capture data of interest, it would fail to address the needs of multi-processing systems. In a multi-processing system, the interaction between the processors is important as well, or even more important. Some architectures have been proposed in the past, see for instance:","U.S. Pat. No. 6,009,539 \u201cCross-Triggering CPUS for Enhanced Test Operations in a Multi-CPU Computer System,\u201d","U.S. Pat. No. 7,332,929 \u201cWide-Scan On-Chip Logic Analyzer with Global Trigger and Interleaved SRAM Capture Buffers,\u201d","U.S. Pat. No. 7,348,799 \u201cSystem and Method for Generating a Trigger Signal.\u201d","However, trace and debug circuits, methods and systems that can more effectively address the needs of multi-processing systems would be very desirable in the art.","Generally and in one form of the invention, an electronic circuit includes a first processor operable to perform processing operations, a first trace buffer coupled to the first processor, a first triggering circuit coupled to the first processor, the first triggering circuit operable to detect a specified sequence of particular processing operations in the first processor; a second processor, a second trace buffer coupled to the second processor, a second triggering circuit coupled to the second processor, the second triggering circuit operable to detect at least one other processing operation in the second processor; and a cross trace circuit having a trace output and having inputs coupled to the first triggering circuit and to the second triggering circuit, the cross trace circuit configurably operable to respond to a sequence including both a detection of the sequence of particular processing operations of the first processor by the first triggering circuit and a detection of the at least one other processing operation of the second processor by the second triggering circuit, to couple at least one of the first trace buffer and the second trace buffer to the trace output.","Generally and in another form of the invention, an electronic circuit includes a processing circuit including a plurality of processor cores and operable to perform processing operations and generate addresses and data, a first storing circuit having a first configuration field for holding a reference value, a comparing circuit responsive to the first storing circuit and to the processing circuit to generate a trigger signal depending on a comparison of an address from the processing circuit with the reference value, a first state machine circuit operable in a given state among a plurality of possible states, and operable to transition from the given state to a new state among the plurality of possible states in response to the trigger signal, a second storing circuit having a second configuration field corresponding to the given state and the trigger signal, the second configuration field for holding a representation of the new state to which the first state machine circuit can transition from the given state in response to the trigger signal, and the first and second storing circuits, the comparing circuit, and the first state machine circuit each have circuit portions corresponding to the processor cores respectively, and a trace circuit that includes mask logic circuits respectively coupled to the first state machine circuit portions and further includes a second state machine circuit coupled to the mask logic circuits and operable to generate a trace capture signal upon an occurrence of a configurably-specified sequence of operations by at least two of the processor cores.","Generally and in a further form of the invention, a trace circuit includes a plurality of trace buffers, a plurality of trace trigger circuits, a merge circuit that includes a sum-threshold circuit having a configurable threshold, and the merge circuit having inputs coupled to the plurality of trace trigger circuits and operable to form event signals in response to any subset of the plurality of the trigger circuits wherein the subset includes a number of the trigger circuits specified by the configurable threshold, and a sequencer circuit operable to deliver a trace output from a selected one or more of the trace buffers in response to a configurable sequence of the event signals from the merge circuit.","Generally and in an additional form of the invention, a buffer circuit includes a dual port memory having a write clock input and a read clock input, a read circuit including a counter circuit coupled to read selected information from the dual port memory, the read circuit having an input and responsive to a signal at the input for actuating a read, an offset register field coupled to the read circuit to configure a read of information from the dual port memory written over an interval prior to the signal actuating the read, and a post count register field coupled to the read circuit to configure a read of information from the dual port memory over an interval subsequent to the signal actuating the read.","Generally and in still another form of the invention, a trace combiner circuit is provided for handling a cross trace event of multiple processors that produce signals, The trace combiner circuit includes plural buffers to hold at least some of the signals, a capture state machine coupled to sequentially drain the buffers when actuated, a cross trace circuit that includes a cross trace sequencer state machine operable to actuate the capture state machine in case of a cross trace event, and a multiplexing circuit having a trace output and responsive to the capture state machine to sequentially couple the buffers to the trace output in coordination with the sequential draining of the buffers.","Generally and in another further form of the invention, a processor debug circuit includes plural electronic processors for performing operations, and an electronic circuit operable to monitor the operations of the plural electronic processors, the electronic circuit configurable for multiple modes including at least one mode to detect a configurably-specified sequence pertaining to operations across at least two of the plural electronic processors and initiate a debug-related response wherein the electronic circuit in that at least one mode is operable on such detection to output information from any selected subset of one or more of the plural processors.","Generally and in a further additional form of the invention, a processor debug circuit includes plural electronic processors for performing operations, and an electronic circuit operable to detect an instance when any processor in a configurably-specified subset of processors among the plurality is executing configurably-specified operations in excess of a configurably-specified amount of time, and further operable to initiate a debug-related response.","Generally and in a yet further form of the invention, a processor debug circuit includes plural electronic processors for performing operations, and an electronic circuit operable to monitor the operations of the plural electronic processors, the electronic circuit operable to detect an occurrence including a configurably-specified sequence of operations by one of the processors and then to capture information from at least one of only the other processors among the plural electronic processors.","Generally and in an another additional form of the invention, a telecommunications apparatus includes a printed wiring board, a modem, an applications integrated circuit including plural electronic processors coupled to the modem, and the applications integrated circuit attached to the printed wiring board for performing operations, and the applications integrated circuit including an electronic circuit operable to monitor the operations of at least the plural electronic processors, the electronic circuit configurable for multiple modes including at least one mode to detect a configurably-specified sequence pertaining to operations across at least two of the plural electronic processors and initiate a debug-related response.","Generally and in a method form of the invention, a processor debug method is for use with plural electronic processors for performing operations. The method includes monitoring the operations of the plural electronic processors, detecting a specified sequence pertaining to operations across at least two of the plural electronic processors, and initiating a debug-related response including outputting information from any selected subset of one or more of the plural processors, upon such detection.","Generally and in a still further form of the invention, an electronic circuit is for use with three or more processors having busses and operations. The circuit includes a first circuit coupled to take and derive triggers and state information from processor busses and operations and discrete events, a second circuit operable to combine the triggers and having logic to detect an interprocessor sequence of the triggers that indicates a debug condition, and a third circuit operable to cause capture of trace data based on the interprocessor sequence of the triggers that indicates the debug condition, wherein the captured trace data includes data from only those processors involved in the interprocessor sequence causing the capture of the trace data.","Various forms of the invention involving processes of manufacture, processes of operation, circuits, devices, telecommunications products, wireless handsets and systems are disclosed and claimed.","Corresponding numerals indicate corresponding parts throughout the Figures of drawing, except where the context indicates otherwise. If a signal name or register field designation is expressed in all caps, title case, or lower case in different places in the drawing and description, the same signal or register field is signified unless the context indicates otherwise. The letter \u201cx\u201d or \u201cX\u201d or \u201cY\u201d in a register designator refers to any digit to identify elements in an applicable set.","Various embodiments not only take into account not only the activity of one CPU, but the interaction and activity of some or all of the CPUs in relation to each other. \u201cCPU\u201d refers to a processor generally, such as any of processors - or a processor central processing unit CPU thereof. Embodiments of apparatus and method are provided to coordinate trace activity of multiple CPUs to qualify what data gets exported to maximize trace bandwidth and provide better debug information. Multiple modes for gathering activity of simultaneous CPU provide different benefits and ways the user can debug the activity in a multiprocessing system. Trace bandwidth is more efficiently utilized.","Some cross trace embodiments are configured to trace activity of the CPUs as they access shared data structures. This provides the ability to determine which CPUs are reading or modifying semaphores, handles, buffers and other shared data structures. Data trace of multiple CPUs is thus provided.","Some cross trace embodiments are programmed to trace CPU activity when an event occurs. This may be a single PC value or a series of PC values. This has a very high instantaneous bandwidth, but is triggered by an event which would not occur very often. The event may be an error detection, a message or semaphore change or any other significant activity.","Some cross trace embodiments trace activity of the CPU when they are interacting. The cross tracing is set up to trace activity of CPUs when executing communication and\/or synchronization code, when two or more processors are engaged. Cross tracing is qualified to trace a given CPU, such as by another CPU simultaneously accessing the same communication and\/or synchronization code, to capture the given CPU executing this code. A CPU executing this communications and\/or synchronization code is captured within a time window established or qualified on the basis of another CPU executing the same or similar code.","Each CPU can also be independently traced to provide a very good debug tool for single threaded applications such as to debug software at less than real time speed or piece-by-piece but with each piece tested at real-time speed. In multi-processor systems running many threads to provide the processing power necessary to execute the algorithms in a product, the interaction of the threads and CPUs is very important to be able to capture and debug.","Some cross trace embodiments can periodically sample the PC values of all of the CPUs to take snapshots of where each CPU is executing and provide profiling information about each CPU's activity without having to record all of the activity of every CPU.","Among various other features and benefits of one or another embodiment, 1) a cross trace unit provides ability to capture trace data based on interprocessor activity, 2) a cross trace unit provides simultaneous samples of multiple CPU program counter values, 3) a cross trace unit can significantly reduce trace export bandwidth requirements in debugging multi-processor systems by only capturing data when processors interact, or 4) capture of trace data can be based on time, triggers and\/or activity of one or more CPUs.","In , in one multi-processor embodiment, processors - have a shared memory  and peripherals . Each of the processors - has a pipeline flattener -, triggering unit - and an encoder -. These are separate units or combined into a single module, depending upon the processor type. The pipeline flattener is used to align the address and data activity since these can occur several clock cycles apart due to pipelining in the CPU. With some CPUs the pipeline flatteners are omitted if the address, data and control signals are already aligned. The pipeline flattener output is then fed to the triggering unit and an encoder . When the trigger conditions are met, the data from the pipeline flattener is compressed and encoded to produce the trace data stream. The encoding process removes redundant information, adds time tags, sync markers and encodes the packets according to a trace protocol. For some background, see U.S. Pat. No. 7,519,497 filed as U.S. patent application Ser. No. 10\/729,239 (TI-34656) and also published as published U.S. patent application 20040133388; U.S. patent application Ser. No. 10\/256,373 (TI-34653) published as published U.S. patent application 20040064763, and U.S. patent application Ser. No. 11\/383,600 (TI-60668) published as published U.S. patent application 20060255981, each hereby incorporated herein by reference. The trace data output is suitably one or more packets of trace data in any appropriate packet size, such as 8, 10, 16 or 20 bits long. An example of trace compression counts and records the number of sequential instructions executed and outputs a single packet that includes the count number. For some background, see U.S. Pat. No. 7,463,653 (TI-34670) which is hereby incorporated herein by reference. In one example, the trace system captures and records parallel trace data at about a 300 MHz data rate for exporting serial data from the chip. For some background, see U.S. patent application Ser. No. 11\/383,469 (TI-60580) published as published U.S. patent application 20060259831, each hereby incorporated herein by reference. High speed serializing-deserializing such as SERDES rapid I\/O, running at 3+ GHz, trades data width for clock rate. A 3 Gbit\/sec serial port using 8\/10 encoding of a 300 MByte\/sec stream would export the same amount of data as an 8-bit wide (byte-wide) parallel trace port running at 300 MHz. A decoder uses the program listing and a start point to then trace program activity. Discontinuities in program flow, sync points, timing information, and data trace may use multiple packets to represent the traced activity.","Trace data from the CPUs - are combined by a Trace Combiner , which includes or acts as a selector or multiplexer. This logic tags the source of the trace data and then outputs the trace data unmodified. Trace data can be stored in an on chip buffer  or exported off chip via trace pins  to an external trace receiver by the trace export unit . For some background on trace export, see U.S. Pat. No. 7,315,808 (TI-30481), which is hereby incorporated herein by reference.","In , in a multi-processor embodiment, each of the CPUs has an on-chip trace buffer -. This embodiment allows simultaneous capture of all the CPU trace data. The system of  has one or more trace export units  to deliver CPU trace data from the trace buffers - via trace pins  to a trace receiver , but these latter items are omitted from the diagram of  for brevity.","In , a multi-processor embodiment has different types of processors , ,  utilized to perform different types of data processing in a heterogeneous SOC. A general purpose processor  executes user interface and control tasks and a DSP  processes image data and\/or modem data, for instance. In , system memory  and peripherals  are coupled via bridges , ,  to the processors , , . Local memory  and peripherals  coupled to processor . Local memory  is coupled to processor . Local memory  and peripherals  are coupled to processor . Processors , , and  respectively have a pipeline flattener , , ; a triggering block , , ; and an encoder , , . A Trace Combiner  has inputs for encoders , , and  and an output to an on-chip trace buffer  and a trace export unit . Trace export unit  communicates with trace pins . ,  and  in this way show three example embodiments of multi-processor systems, and other possible combinations are also supported by embodiments herein. For some background on comparators and triggering, see U.S. Pat. No. 7,299,386 (TI-34662), published U.S. patent application 2006\/0288254 (Ser. No. 11\/467,735, TI-35341), and published U.S. patent application 2007\/0094645 (Ser. No. 11\/566,766, TI-34953.2), which are hereby incorporated herein by reference.",{"@attributes":{"id":"p-0080","num":"0079"},"figref":"FIG. 4","b":["200","210","220","210","210","220","220","200"]},"In , an example of the triggering unit  of  has Compare\/Mask registers COMP\/MASK REGS of , including four address comparators .and four data comparators .for each of an address and data. A selector\/combiner\/sequencer .of  is described further in connection with . Alternate implementations may have more or fewer comparators and may have triggering capabilities as described  with varying degrees of sophistication. Triggering unit  includes trigger configuration registers TrigX_cfg of , a state machine  of , and state configuration registers StateY_cfg of  for the state machine . The triggering unit is also operative to generate halt requests (breakpoints) to stop one or more of the processors -. For Cross Tracing, a REARM signal is introduced to the trigger unit, as described in reference to .","In , the triggering unit  has registers that are programmed by debug software according to user-specified criteria for trace. The example trigger unit  in  has four address comparators .and four data comparators .. The comparators .and .are coupled to the registers of  to receive respective signals from address\/data mask registers Addr_mask_x and Data_mask_x. Four each of further registers Addr_comp_x and Data_comp_x provide respective comparison values or reference values for each of the four address comparators .and the four data comparators .. In , incoming addresses from the pipeline flatteners get masked, then compared in parallel by address comparators .. Incoming data from the pipeline flatteners is compared bit by bit by comparators ., and then are masked off. Alternatively, the incoming data from the pipeline flatteners is masked off and then compared by comparators .","In , an example trigger logic diagram is shown and is composed of , A-, and A-. Other variations are possible including more or less sophistication in the way trigger values are selected and combined. The xx numbered trigger logic described next is replicated for each trigger output trig, trig, trig, , trig  and the trigger outputs are fed to a state machine  for a trigger unit  for a given processor . That circuitry, including state machine  is further replicated as trigger units , , ,  for each corresponding processor , , ,  shown in various Figures herein. More or fewer trigger outputs trig and more or fewer trigger units like  are suitably provided.","In , this example shows four each of address and data comparators .-. in blocks ., .of  and masking logic indicated by AND-gate logic circuits .-.. Each AND-gate logic circuit .has a  multi-bit ADDRESS or DATA input from a processor or bus, and a multi-bit masking input (mask) in  from one of the registers Addr_mask_x or Data_mask_x of . Each AND-gate logic circuit .has a multi-bit output in  to provide a comparison value A to an A input of a corresponding comparator .. Each comparator .also has a multi-bit reference or comparison value input B fed by multi-bit lines comp_reg in  from registers Addr_comp_x or Data_comp_x of .","In , the outputs of the comparators .-. are fed to eight (8) corresponding comparison enable blocks .. Each comparison enable block .has a three-bit (<, =, >) comparison enable configuration (comp_en). The control signals for them are discussed in . Each three-bit (<, =, >) comp_en is fed to an input of a corresponding one of three AND gates , ,  that are also respectively fed by three one-bit comparator .outputs legended <, =, >. AND gates , ,  supply their outputs to OR-gate . Each three-bit (<, =, >) comp_en is also fed to three low active inputs of an AND-gate . The output of AND-gate  goes to an additional input of the OR-gate . In this way the output of the OR-gate  is active if all the (<, =, >) comp_en bits are inactive, or if any one or more comp_en bits are active and a corresponding comparator .output legended <, =, > is active.","The respective eight (8) outputs of the eight (8) comp enable blocks .of  are routed through an AND-OR plane  of  to allow various Boolean logic combinations of the comparators or comparisons to be selected. An upper set of eight OR-gates .-. and a lower set of eight OR-gates .-. all have low-active inputs. Enable bits from  AND enables fields including eight AND enable bits and eight AND enable bits go to those low-active inputs. The respective eight (8) outputs of the eight (8) comp enable blocks .go to high-active inputs of a corresponding pair .of the OR-gates, so that e.g. pair . includes OR-gates . and . that have a high-active input connected to each other and to the output of OR-gate  in block .. The eight outputs of the eight OR-gates .-. are fed to eight inputs of an upper AND-gate , and the eight outputs of the eight OR-gates .-. are fed to eight inputs of a lower AND-gate .","In , an example of operation of the AND-OR plane , for instance, activates the first two of the eight AND enables (e.g., AND=11000000) that in turn activate a first pair of address comparators. Activating the fifth of eight AND enables (e.g., AND=00001000) activates a first data comparator. Activating the OR-enable input to upper AND-gate  delivers the result of ANDing the first address comparison with the second address comparison to a first input of an OR-gate . Activating the OR-enable input to lower AND-gate  passes the output of the lower AND-gate  (first data comparison in this example) to a second input of OR-gate  and produces as OR-output the logic function ((1Addr comp AND 2Addr comp) OR 1data comp).","Notice in  that each of the outputs of OR-gates .and .default high and thereby qualify the inputs of AND-gates  and  when the corresponding AND or AND enable for an OR-gate .or is low or when the AND-gate  in circuit .is high. The remaining OR-gates .and .are enabled by enable bits that are high among AND or AND at the low-active OR-gate enable inputs. Then these OR-gates pass comparison results ., those that have been enabled by comp_en register bits in circuits , on through the AND-OR plane  so that OR-gate  only produces an active high logic function result comp_match if particular enabled comparisons occur according to a particular enabled or configured logic function. That logic function is enabled or configured by the AND enables, the AND enables, and the OR enables.","The diagram of  for the block  shows two (2) planes - and -, and can be increased to 3 or 4 planes or more, or reduced to a single plane or a fixed combination, rather than a programmable solution.","In , four control signals (read, write, instruction and data) are shown and monitored in a circuit block , as well as seven (7) peripheral or other external  EVENTS that are monitored in a circuit block event comp  having a multiplexer . The outputs of circuit blocks ,  and  are designated comp_match, control_match, and event_match respectively and fed to an AND-gate  having output trig. These various comparisons and events are selected and combined into one x-indexed final output trigx, e.g., trig, and the comparisons and events are differently or variously selected and combined into each additional x-indexed final output, trig, trig, trig. The trigger outputs trigx (trig-) are fed to the trigger state machine  of . Pipelining is suitably used to meet timing requirements. The AND\u2014OR plane allows triggering logic expressions or equations to be constructed such as trig=(addr <=addr <addr) AND (data=data OR data=data), for a couple of examples.","In , the control matching circuit block  has inputs read, write instr, data derived from processor  or from bus(es) coupled to processor . Six programmable control selection configuration bits ctl_sel are fed to six corresponding low-active first inputs of six OR-gates .-.. AND-gate  ANDs and supplies output control_match in response to the outputs of the six OR-gates .-.. OR-gates .-. respectively monitor for active control conditions read, write, read or write (using OR-gate ), instruction instr, data, or either instr or data (using OR-gate ). Control block  is replicated for each trigger, , , .","In , note that any of the three inputs to AND-gate  can be defaulted high (disabled in effect). In circuit block  of , setting all AND and AND enables low and both OR enables high produces a default comp_match high at AND-gate . In circuit block  of , setting all control selection ctl_sel bits low produces a default control_match high. In circuit block , setting all event selection event_sel bits low to select the hardwired one (1) at mux  input zero (0) produces a default event_match high. In operation, any one, two or all of circuit blocks , ,  can be variously activated (or defaulted high instead) by configuration bits specifying AND enables AND, AND, and specifying OR enables, ctl_sel, and event_sel as desired to conveniently establish and monitor desired logic functions encompassing the variously masked address\/data comparisons, the control conditions, and peripheral events or other events.","In , in addition to the address and data comparator .and ., and mask registers Addr_mask_x and Data_mask_x, the triggering unit  has four pairs of trigger configuration registers TrigX_cfg and TrigX_cfg associated with block .to qualify what comparator values are of interest. In each register TrigX_cfg, the outputs of the eight comparators .and .of  are selected using eight groups of three enable bits comp_en in  each signifying (<, =, >) from the TrigX_cfg register in . In each register TrigX_cfg has fields AND, AND, as well as an OR field, and, Ctl_Sel, and Event_sel that specify which comparators outputs will be ANDed and ORed together to determine a comp match, as well as to select control signals and external events. Address comparators .are each configured by register TrigX_cfg to operate and deliver an output for a specified relation such as less than \u201c<\u201d, equal \u201c=\u201d or greater than \u201c>\u201d or combination \u201c<=\u201d or \u201c>=\u201d or not-equal \u201c< >.\u201d If nothing is selected the output of the comp_enable block is forced high. Data comparators .are each also configured to operate and deliver an output for a specified relation such as such as less than \u201c<\u201d, equal \u201c=\u201d or greater than \u201c>\u201d or combination \u201c<=\u201d or \u201c>=\u201d. (In some other embodiments, the data comparators .are each configured instead to operate and deliver an output for a specified relation such as equal \u201c=\u201d or not equal \u201c!=\u201d.)","Each  trigger configuration register TrigX_cfg is also configured with Sel bit(s) in the bit fields Ctl_sel and Event_sel to allow a selection of one Control Signal and one discrete Event (e.g., external interrupt, peripheral event, etc.) from the correspondingly-named CONTROL SIGNALS input lines and EVENTS input lines to  block .. If no control or external signal is selected, their outputs, control_match and event_match are forced high. Other implementations of programmable combinational logic are possible, but these serve to illustrate the functionality of the trigger unit .","To capture trace data, in one example when the processor  executes a certain function, two address comparators .are programmed for the start (lower) and stop (upper) addresses Addr_comp_ and Addr_comp_ of the function. The trigger configuration Trig_cfg is set up for Greater or equal \u201c>=\u201d to the lower address Addr_comp_ and less than or equal \u201c<=\u201d to the upper address Addr_comp_. The trigger configuration Trig_cfg is set up for addr comp  AND addr comp . When processor  executes an instruction within the programmed address range, the trigger unit  outputs a signal and the circuits including the encoder  of  cooperate to capture, compress and export trace data.","Referring to , more sophisticated tracing and triggering can be performed if the trigger unit block .contains a state machine or sequencer as in  to detect sequences of program activity. The state machine starts in the NT (no trigger) state and goes back to the NT state in response to a REARM signal () or in response to a RESET signal ( or A). Each trigger state T, T, T, T can be programmed to recognize specific trigger events or conditions Trig, Trig, Trig, Trig being met or not. For some background on programmable state machines see, e.g., Samuel et al. U.S. Pat. No. 7,159,083 assigned to Texas Instruments Incorporated and hereby incorporated herein by reference. In , the programmable state machine can move from any state to any state T-T in response to trigger events TrigX. If no triggers are active or no trigger condition is met, the state machine returns to the NT state. State T is the active state where trace data is captured (or a breakpoint asserted). States T, T and T are intermediate states, used for detecting the occurrence of a progression of trigger events in specified triggering sequence(s). In  the flagX_mY outputs of the Triggering Units are such that X is the processor number (e.g. processor , Triggering Unit , flag_mY). And match output flagX_mY is the output from state TY of  state machine  (e.g. flagX_m goes active in state machine state T of Triggering Unit X). Also, by way of example, there are 16 flags if there are four (4) Triggering Units X and four state machine states T, T, T, T that give match outputs , , , .",{"@attributes":{"id":"p-0097","num":"0096"},"figref":["FIG. 8A","FIG. 5","FIG. 8A","FIG. 8"],"b":"215"},"Referring to , the sequencer control registers allow programming of all of the state transitions from any state to any state in  based on one of the trigger events, which themselves are qualifiers for address, data, control and discrete events. This capability is used to qualify breakpoints to halt the process or minimize the trace data to only the range of interest. The nt_cfg register specifies which state to branch to based on which trigger event occurs when the current state is the no-trigger state NT. Register nt_cfg is provided and each of the states has a negated state action for the current state. This simple configuration acceptably does not address simultaneous trigger events, and in some other embodiments a trigger sequencer is provided with priority circuitry to handle simultaneous triggering if desired. In each state, if another trigger event occurs, the current state is changed to the corresponding new state \u201cnew st\u201d according to the contents of the state configuration register. Each such state configuration register has entries to specify a new st to be different from the current state to which the state configuration register applies. If the trigger event which brought the state machine to the current state gets de-asserted, the configuration register specifies what should happen, and the state in  can change to the No-Trigger state NT, remain the same, or advance to another state T, T, T or T. This allows triggers to act as one shot events or as continuous events. The state can be forced back to the NT state when the REARM signal is asserted.","In , the state configuration registers nt_cfg and each StateY_cfg operate as sequencer control registers to allow programming of all of the state transitions from any current state to any state T-T or NT based on one of the trigger events TrigX, which themselves are qualifiers for address, data, control and discrete events. In  the register legend \u201cnew st\u201d represents a particular entry T, T, T, or T entered in register StateY_cfg for each trigger event TrigX. If the state machine of  is in state TY and trigger event TrigX occurs, then particular entry in the \u201cnew st\u201d register field signifies the particular new state to be entered. For instance, if the state machine is in state T and trigger event Trig occurs, then state machine circuitry responds to the particular \u201cnew st\u201d entry (e.g., let it be \u201c011\u201d in binary or \u201c3\u201d in decimal) in register State_cfg for a trigger event Trig and goes to new state T corresponding to the entry \u201c3\u201d. In , corresponding state transition is represented by arrow 215.23. The register StateY_cfg in effect represents a transition matrix for the state machine of all (m x n) transition conditions Trigx to take the state machine from any state Y to any other state \u201cnew st.\u201d","The state machine capability of  is used, for instance, to qualify address breakpoints to halt a processor and minimize the trace data to only the range of interest. In terms of the State transition diagram of , the registers StateY_cfg of  program or specify the logic to associate with each transition arrow in , wherein those transition arrows are without legends because they are programmable.","An example tracing process based on  starts tracing when the processor  executes a function within an address range (Trig ) and an interrupt occurs (Trig) and the data read from a peripheral is negative (Trig). Trig  is programmed to match the end of the interrupt service routine. The trigger conditions are configured into the four TrigX_cfg registers of , and the four comparison values each for comparators .and .are set up in  registers Addr_comp_x and Data_comp_x. The sequencer .is programmed by configuring the four registers StateY_cfg of . The sequencer .in this example, is programmed to wait in state NT until the desired function is being executed (trig  occurs), whereupon the sequencer advances to state T via arrow .. While in state T, if an interrupt occurs (Trig ), the state machine advances to state T along arrow .. But if no interrupt occurs and the function is exited, a transition returns operations to state NT along arrow .. Given state T, if a data read from the peripheral has the most significant bit set (i.e. it is negative) (Trig ) then operations advance along arrow . to state T. Otherwise, if the interrupt service routine is exited (Trig), operations return to state NT along arrow .","In , in a multi-processor embodiment, each of the processors - is shown with a pipeline flattener - and a triggering unit -. Rather than encoding the trace data as in  for each individual processor - and then combining the independent trace data streams, the outputs of the pipeline flatteners - are fed to a cross trace unit . This provides a flat view of activity for each of the processors -. If the cross trace unit  is only supporting capture of program counter activity, the pipeline flattener may not be necessary. The cross trace unit  can select and combine trace information from CPUs according to their interaction. Four sets of triggering logic , , ,  each as described in  provide match controls for the cross trace unit . Cross trace unit  provides an initializing signal REARM to the triggering logic , , , .","Trace data from the cross trace unit  is stored in an on chip trace buffer  or exported off chip to an external trace receiver  by the trace export unit . The trace data in this implementation may be, but does not need to be, compressed, and can provide sufficient information to debug CPU interaction.","FIGS.  and A-D show five different embodiments for the processors - and trace hardware, which are replicated for , , ,  and  and elsewhere herein. Each embodiment has various benefits.","In , the first embodiment has a processor  and a pipeline flattener . This embodiment is economical of hardware and has the cross trace unit  of  including triggering logic, and the clocks of all the processors are the same frequency.","In , processor-specific triggering units - respectively support processors - and pipeline flatteners -. Each processor can be clocked at a different clock frequency. This embodiment is economical of hardware and suitable when it is acceptable to have some latency, and to trace from the trigger point onward, and to capture uncompressed data.","In , a circular buffer  is added in embodiments so that latency is desirably hidden. Moreover, the circular buffer  can capture data before the trigger condition is fully satisfied. If the trigger condition is met, then the circular buffer  usefully holds data before and after the moment of the trigger condition being met, and otherwise the data can be discarded. The data captured in  is uncompressed.","In , an encoder unit  is provided after the circular buffer  to compress the trace data and beneficially permit a reduction working size of on-chip trace buffer  and permit a more economical trace export unit  with reduced bandwidth in . Such compression is beneficial in embodiments with a high CPU clock rate to reduce the required clock rate for trace data acquisition.","In , encoder  is situated before the circular buffer . The encoder  compression is also beneficial in embodiments with a high CPU clock rate. Moreover, putting encoder  before circular buffer  provides greater trace capture depth and can utilize a smaller circular buffer  since the data is compressed before buffering. The  embodiment suitably includes a circuit or mechanism that indicates the start of a compressed trace packet, and the circular buffer  can discard partial packets when reading, in the case of wrap around.","In , an enhanced trigger unit  provides additional outputs (match-match) and accepts a REARM signal. Some embodiments include these additional features for even more comprehensive cross trigger control. Refer to the description of  for registers and operations that are left implicit in . The four match signals (match-) correspond with the four trigger states in embodiments providing a sequencer or correspond to the four trigger events described herein already. Each trigger unit  can create different flags each based on a different detection logic specific to that flag and then provide one or match outputs representing different relation operators such as <. =, > for each flag.","In , , and -, programmable triggers (programmed by registers Trig,,,_cfg of ) using comparators and using suitable logic circuits (and\/or in some embodiments sum-threshold circuits and\/or neural networks) produce active triggers for and state transitions in the state machine(s) of . State machine  of  is programmed by registers StateX_cfg of  for each new state transition from a given current state, and each such state machine  for a given processor is coupled to, fed by and responsive to the trigger comparators and circuits or networks that produce the triggers.","In , pipeline flattener  sends all of the address, data, control and event signals simultaneously to the triggering unit , encoder  and circular buffer . This allows the export of trace data in parallel with, or separately from, the cross trace operations and output of Cross Trace Unit . The circular buffer  has drain and stop controls and it outputs raw (uncompressed) or compressed data. Cross Trace Unit  is coupled to on-chip trace buffer  and Trace Export Unit  to Trace pins .","In , the output of each circular buffer - is coupled to and sent directly to the corresponding encoder - to compress the trace data. Compare with . The circular buffer - beneficially allows the capture of data occurring before a trigger event as noted in connection with . Cross Trace Unit  is left implicit in the diagram and receives Compressed Trace Data from each Encoder - and the match outputs from Triggering -. Each pipeline flattener - has its outputs for Address, Data, Control Signals, and Events coupled in parallel respectively to corresponding Triggering - as well as to corresponding circular buffer -. Each circular buffer - has its output coupled to the corresponding Encoder -. Each Triggering - has its match outputs coupled to the Cross Trace Unit . Each Triggering - can respond to the REARM signal as well as to combinations of the inputs from the pipeline flattener -. The Cross Trace Unit  issues drain and stop controls to circular buffers -.","In , each pipeline flattener - sends all of the address, data, control and event signals simultaneously or in parallel to the corresponding triggering unit - and encoder -. The output of each encoder - is coupled and sent to the corresponding circular buffer -. This arrangement allows a much smaller circular buffer to be used, and an associated circuit or process mechanism identifies the start of a group of trace packets representing one traced event. Complete trace packet groups are output from each circular buffer - as Compressed Trace Data for Cross Trace Unit . Some embodiments multiplex the inputs and outputs of each encoder - and circular buffer - such that the encoders are switched in circuit-wise before and so as to feed the circular buffers or alternatively the circular buffers are switched in circuit-wise before and so as to feed the encoders. A circular buffer such as  beneficially allows the capture of data occurring before a trigger event involving that one circular buffer, or involving some or all of the circular buffers.","In , Cross Trace Unit  is left implicit in the diagram and receives Compressed Trace Data from circular buffer - and the match outputs from Triggering . Compare with . Each pipeline flattener - has its outputs for Address, Data, Control Signals, and Events coupled in parallel respectively to corresponding Triggering - as well as to corresponding Encoder -. Each Encoder - has its output coupled to the corresponding circular buffer -. Each Triggering - has its match outputs coupled to the Cross Trace Unit . Each Triggering - can respond to the REARM signal as well as to combinations of the inputs from the pipeline flattener -. Cross Trace Unit  issues stop and drain controls to circular buffers -.","The circular buffer  shown in ,  and , may optionally have Post Count, Read Count and Read Offset control signals to provide more sophisticated trace capture. Using a Post Count value, the circular buffer outputs a wr_done_x signal, as shown in , but left off ,  and  for brevity. Without these advanced control signals, the Read data could simply start at the address just past the write counter and return data until the read counter reaches the write counter. In this embodiment these Post Count, Read Count and Read Offset controls come from the Capture Control block ., but other embodiments may embed them within the circular buffer itself.","In , circular buffer  has a Write Control logic ., write counter ., read control logic ., a read counter ., a  port adder ., a Dual Port RAM ., and a post counter .. Write Control logic .normally has write counter enable wc_en active. Trace Data in  is written to the dual port RAM ., and after each value or datum, the write counter .is incremented. Dual Port RAM .has a finite capacity that, in effect, establishes a Trace Data window. The write counter .automatically wraps around to the start of the address space for circular buffer  when a data value is written to the last location in the Dual Port RAM .. Trace Data is written and windowed continually, and in due course Cross Trace Unit  asserts the control signal Stop to the Write Control logic .. In response to the Stop signal, Write control logic .asserts or sends a posting-enable signal (pst_en) to post counter .. Write-enable signal wc_en to Write Counter .continues active. When Stop is asserted, the write control logic .allows X more samples of Trace Data to be written under control of the write counter .to the Dual Port RAM .. The post counter .for a circular buffer is programmable on lines Post_countx by register PostCntx of  to allow the number PostCntX of Trace Data samples after a stop (trigger) to be set by the user. Post counter .downcounts from the programmed number PostCntX. The applicable processor CPU clock domain uses a clock wr_clk that is also used as the write clock for write counter .and post counter .of circular buffer  (in general) so that circular buffer enters TRACE DATA into Dual Port RAM .as fast as the processor sends it. When the downcounting reaches zero, post counter .outputs a signal (pst_tc) to Write Control .signifying that the write has completed and is to be terminated. In response to pst_tc, Write Control .disables counting by Write Counter .by de-asserting wc_en. By disabling Write Counter ., Write Control .terminates writing of Trace Data into Dual Port RAM .for the time being. Write Control .asserts a wr_done signal that signifies to Cross Trace Unit  that the write has completed. This stop\/wr_done handshake is useful when processing compressed trace data because the data words are likely to be sporadic, due to the varying compression of the raw Trace Data.","The Cross Trace Unit  then asserts the drain signal DRAINx to the Read Control logic .of the particular xth circular buffer , which activates enable rc_en to Read Counter .. The starting read address is jointly determined by 1) the current Write Counter .value, by 2) an offset value OFFSETx for circular buffer supplied on lines Read_Offsetx as programmed by the user in register OFFSETx of , and by 3) the Read Counter .value, which suitably starts at 0 and counts up to the value specified in the Read Countx Register of  and supplied on lines Read_countx. These three values are summed by the three-(3-) port adder .and the read address is sent to the Dual Port RAM .. As each data value is read out, the Read Counter .is incremented and counts up to a programmable value or to the address capacity of Dual Port RAM .. A read clock rd_clk is provided and coupled to read counter .using a convenient frequency or clock rate for trace read purposes and that can be different from or slower than write clock wr_clk. When the programmed number of trace data samples have been read from Dual Port RAM ., Read Counter .sends signal rc_tc to the Read Control .. Read Controller .terminates the reading by de-asserting an rc_en to disable Read Counter .. Read Controller .asserts an EMPTY signal to Write Control ., which in turn lifts the disable from normally enabled (wc_en) Write Counter .and thereby commences the operational cycle of circular buffer  described in connection with this .","If the trace logic is configured to capture data after a trigger event, the PostCntx value is set to the desired number of samples, the OFFSETx value is set to the negative of the PostCntx value, and the Read Counter .is used to read the specified number of samples, beginning at PostCntx samples back from the Write Counter .","If the trace logic is configured to capture data up to a trigger event, the PostCntx value is set to 0, the OFFSETx value is set to the negative of the desired number of samples, and the Read Counter .is used to read the specified number of samples, beginning at desired number of samples back from the Write Counter .","If the trace logic is configured to capture data around a trigger event, the PostCntx value is set to the desired number of samples after the trigger, the OFFSETx value is set to the negative of the desired number of samples before the trigger, and the Read Counter .is used to read the total number of samples.","Other implementations of the circular buffer  are possible, using other types of RAMs, registers, FIFOs, etc. The read\/write address mechanism is modified accordingly.","In , like , each of the processors - is coupled with a pipeline flattener -, a triggering unit -, a circular buffer - and an encoder -. The data presented to the cross trace unit  is compressed, but the trigger signals developed by each of the trigger units are available to combine and generate a coordinated trace stream. Controls for the circular buffers - are used to empty them into either the on chip trace buffer  or exported off chip to an external trace receiver  by the trace export unit .","The embodiment of  does not have or does not need to have encoders - tag the start of each trace packet group and read back complete packet groups, which promotes simplicity of operation. Complete data is fed into the encoders -. When the last data value is read from one of the circular buffers -, the corresponding encoder - is pulsed by Cross Trace Unit  with a flush command (STOP) to output any packets still being processed. For example, suppose the last few trace data values were sequential program instructions and the encoder  is constructed to normally output a packet when a program address (program counter PC) discontinuity occurs in the program sequence. The flush command forces the discontinuity and the encoder  outputs the number of sequential instructions it has captured. In addition, this embodiment minimizes the temporal differences in trace data across multiple processor - cores. When storing compressed data from the encoders -, there is a larger uncertainty regarding when a particular trace event occurred due to the compression. The trace data is already compressed, and when a synchronization point is detected by Cross Trace Unit , the trace data is decoded.","In , the Cross Trace Unit  includes Trace Capture Qualifiers - for each processor -. The outputs of the Trace Capture Qualifiers - are fed to a Cross Trace Trigger Unit  which controls the data being collected by the trace combiner  as well as generates trace tags to identify the trace streams. The trace tags suitably are provided as any one, some or all of time stamps, synchronization (sync) markers, loop markers, control bits, processor core identification ID tag for each respective trace stream, trace encoder controls for an external trace decoder, event descriptors, or other trace tags in the trace stream itself or parallel to the trace stream(s). External events are also utilized to affect the operation of the cross trigger sync\/trigger logic  by sending them through a Trace Capture Qualifier . The drain signal on the straight-through line in  is not and does not need to be synchronized, when the read logic in the circular buffer is in the same clock domain as in the example here. If the circular buffers - are implemented differently, then appropriate synchronization logic is used. The detailed signals are shown for Trace Capture Qualifier . Details for Trace Capture Qualifiers , ,  are similar, and left out for clarity.","In , outputs from Trace Capture Qualifiers - to Cross Trace Trigger unit  include bufx_rdy and flagx_m-. Inputs from Cross Trace Trigger unit  to Trace Capture Qualifiers - are RESTART, DRAINx, HOLD. For the Trace Capture Qualifier  driven by external events, the outputs are flags_m-. Regarding Trigger signals, the inputs to Trace Capture Qualifiers are wr_done from each circular buffer and each match- (flagx_m-) from Triggering units . Outputs from Trace Capture Qualifiers are STOP and DRAINx to circular buffers and REARM to Triggering units -. The lines designated Post_countx, Read_Offsetx and Read_countx also go from Cross Trace Trigger unit  in  to circular buffers of .","In , the logic of each of the trace capture qualifiers - has a Latch\/Sync block .and a Sync block .. Let the processor CPU clock domains use one or more clocks wr_clk and let the cross trigger clock domain use a different clock rd_clk. Latch\/Sync block .has inputs that respectively receive trigger signals matchx_- for each of several flags from each Triggering Unit among such units - (, ). Latch\/Sync block .has further inputs that respectively receive each circular buffer signal wr_done_x (, ) from the processor CPU clock domains clocked on one or more clocks wr_clk. Latch\/Sync block .latches and synchronizes the signals on those inputs to the cross trigger clock domain on rd_clk. The four match signals matchx_,,, from each of the four Triggering blocks - are thus synchronized by Latch\/Sync block .and output as a corresponding one of sixteen flagx match signals flagx_m- in  to Cross Trace Trigger Unit  in , , A. The wr_done signal from each circular buffer is also thus synchronized by Latch\/Sync block .and output as a corresponding one of signals bufx_rdy in . Signals are latched since the CPU clock wr_clk can be much faster than the Cross Trace Trigger  clock rd_clk. A hold signal HOLD from the Cross Trace Trigger Unit  is synchronized by Sync block .to the CPU clock domain wr_clk to deliver a STOP signal in common to the circular buffers - to be stopped in  when a cross tracing trigger event is detected by Cross Trace Trigger Unit . (Some other embodiments are arranged to deliver respective separate HOLD\/STOP signals from the Cross Trace Trigger Unit  to the circular buffers - in case fewer than all of the circular buffers are to be stopped when a cross tracing trigger event is detected.) The separate HOLDx\/STOPx signals are qualified by applicability (or not) of a given circular buffer to the cross tracing trigger event as indicated by MASK REGS not masking off (or masking off) all match flag inputs from Triggering Unit via Trace Capture Qualifier for a given processor . (see , A and B). In , a RESTART signal is synchronized similar to the HOLD signal and delivered to the triggering units - as REARM. RESTART also is used to reset Latch\/Sync block .. The Read Countx, Post Countx and Read Offsetx are not shown synchronized as it is assumed that these signals will be static during operation of the Cross Trace Unit.","In , the Cross Trace Trigger unit  of  merges the signals from the Triggering blocks - synchronized by the Trace Capture Qualifiers -. This example shows four sets of four match flags each, and the numbers can be arbitrarily established to suit the system architecture and support desired trace operations. The flags flagx_m- are combined by the merging unit .to generate or create outputs called sequencer events (seq_ev#). Four such sequencer event outputs seq_ev# are shown in this example, and the number of such sequencer events can be established to be greater or fewer or can be configurably or programmably determined in various embodiments. The sequencer events seq_ev# lines go to a Sequencer unit .which is programmed or configured in mask registers MASK REGS to detect or identify the desired or specified activities of processors - and the occurrence of a specified relationship between those activities and\/or a particular sequence of those activities. In this way, particular actions and interactions of processors - and other system components in relation to one another are detected and traced. Sequencer unit .outputs a capture signal CAPT to a Capture Control unit .when a sequence of conditions has been satisfied. Sequencer .delivers a hold output HOLD for the Trace Capture Qualifier circuits - (each as in ) to then deliver the Stop signal to the circular buffers -. The hold output HOLD is fed by, or can be same as, Capture CAPT or otherwise as appropriate to control the circular buffers -.","In , a Sequencer Counter Seq Ctr .is provided in some embodiments to time specific processor activities or time particular states of Sequencer .. Sequencer .has a load (seq_) output, an enable\/run (seq_run) output and a time completion (seq_tc) input each coupled to the sequence counter Seq Ctr .. The enable\/run seq_run is activated for Seq Ctr if, for a current Sequencer state Sx among states S-S, a nonzero value is configured into a programmable Seq_Ctr register field Run for a corresponding register Seqx_cfg in registers SEQ REGS of . For example, if  Sequencer .is in a state S, and  corresponding or associated register Seq_cfg has a nonzero value in its Seq_Ctr register field Run, then enable\/run seq_run is fed to sequence counter Seq Ctr .. Seq Ctr .is loaded with a nonzero value in that Seq_Ctr register field Run of  for a register Seq_cfg and then counts down to zero whereupon time completion seq_tc goes active.","In , a Capture Control unit .receives the bufx_rdy inputs from  that are synchronized to respective wr_done outputs from the circular buffers - of  and other Figures. Capture Control unit .in  issues one or more particular drain signals DRAINx to the circular buffers - respective to the one or more particular processor(s) being traced among processors -. Capture Control unit .also sends multiplexer selection controls mux_ctl to Trace Combiner  and outputs trace tags to identify the trace streams. The protocol for combining the trace streams can be an existing protocol, such as the MIPI Trace Wrapping Protocol, or a proprietary one. The lines designated Post_countx, Read_Offsetx and Read_countx go from Capture Control unit .to circular buffers of . Capture Control .issues the RESTART signal to re-initialize the Triggering units and other circuitry as appropriate. Capture Control .issues a capture completion signal CaptComp signal to re-initialize the Sequencer state machine SEQ SM as appropriate.","In , a Capture Counter .is enabled by a line capt_en from Capture Control .and delivers a time completion active or counter-timed-out signal on a line capt_tc to Capture Control .. Capture Counter .is used to collect a programmed number of samples from each particular processor CPU - from which trace output is obtained. The value for the Capture Counter .should correspond with the number of samples specified in the circular buffer unit (). These may be the same register value or separate values depending on the specific implementation.","In  Merge block .includes four sub-blocks typified by Merge sub-block ... In Merge sub-block .., sixteen match-related flags seq_ev_flag_-.- are received and held in MERGE REGS from the trace capture qualifier blocks - of . These match-related flags are ANDed with sixteen programmable or configurable selection mask bits flag_-.msk- from registers MASK REGS in the cross trace trigger unit  and ORed to create Sequencer Events seq_ev in . This logic circuit of Merge sub-block .. in  is replicated four times, for generating Sequencer Events seq_ev-. Note that the merge logic cross traces across multiple trace sources such as processors - in  and other Figures. Operations and circuitry of the merge block are pipelined for speed if necessary or desired. Other circuits for merging alternatively have logic programmable for any one, some or all combinations of Boolean ORs, ANDS and NOTs and can mask off any don't-care inputs.","In , an example of a further form of circuitry is shown for use in either or both a merge sub-block .of  and or Selector\/Combiner\/Sequencer .of . In , inputs such as the flags from the trace capture qualifier block are ANDed with selection bits in the cross trace trigger unit and summed up and compared to a threshold. The logic in  is changed from a simple OR gate to an adder\/comparator in . This provides more flexibility in dealing with two or more of four processor type issues. Alternatively they could be just ANDed with selection bits and ORed to create Sequencer Events, see . The circuitry of  is pipelined for speed if necessary or desired. By using the sum of the selected flags and a threshold, the amount of matching can be varied. A threshold of 1 is equivalent to just ORing the masked flags together, while comparing the sum to a threshold allows the sequencer to respond to an occurrence of 2 or more trigger events. The circuitry of  is an example of a pattern recognition circuit having a neural network, with a neural network including a sum-threshold layer being depicted, and some further embodiments have one or more neural networks each including and using one or more such layers with either or both of weighted or unweighted sum-thresholds for either pre-configured or dynamically machine-learned detection responses. In this way, more complex patterns of processor activity across the spatial real estate of the chip as well as over clock cycles through time in the chip are monitored and detected by more powerful neural network circuitry in pattern recognition circuitry with sequencer included and applied for each particular processor as in  and\/or in .","In , four processor-related sets X of the match-related seq_evX_flagY_m- flag bits have each set including 4\u00d74=16 bits for the  merge logic .and stored in four corresponding sets of registers in MERGE REGS. One register among Seq_Ev-_reg of  supports each sequencer event seq_ev_- with different merging. This register complement of  supports the logic of , and has register (fields) Threshx to also support the sum-threshold circuitry of , and provides full flexibility to trigger any event based on any flag input from any CPU - originated via the already-described triggering - herein and the latch synch circuitry in . Also, four sets of sixteen selection mask bits flag_-.msk-, each from MASK REGS, are provided to select any of two-to-the-sixteenth (2^16) selection functions. Sixty-four (64) mask bits for Seq_ev,,,_reg flag,,,_msk,,, separately mask four (4) different ways using the 16 flags from Triggering Units - for supporting or generating the respective four (4) Sequencer event outputs of  Merge block .and Sequencer SM .. Note in , A and  that four mask bits .msk, .msk, .msk, .msk per flag are used for illustration, and any appropriate number of the mask bits are used.","In , to support the change in  relative to , the registers of  are changed to add a threshold parameter. The register set is augmented to contain the threshold value. This provides full flexibility to trigger any event based on any flag input from any of the processors - or from discrete inputs.","In , the sequencer .has a sequencer state machine SEQ SM described by a state transition diagram. The sequencer state machine SEQ SM can move from any state S, S, S, or S to any other said state. Let state S be the starting state. When state S is active the CAPT signal is asserted. States S and S are used to provide sophisticated or complex tracing capability. The sequencer .can alternatively and feasibly employ a Capture-or-not logic mechanism SEQ LOGIC instead of the state machine SEQ SM in , or along with SEQ SM. The SEQ LOGIC is programmable for any of four logic conditions LOGIC, , ,  by programming logic registers with ordered sets of e.g., four registered values abcd in  for each of the events Seq_Ev-. Each bit in the four bits in each such value abcd can be any of 1, 0, or X (don't-care). SEQ LOGIC can be programmed to feed event states into the sequencer state machine SEQ SM. A transition back to the S state can be programmed to assert the REARM signal. Suppose one processor has met the triggering conditions and the sequencer state gets advanced to S or S. If that state times out, and the sequencer returns to state S, RESTART resets the original processors triggering logic, so that the triggering logic must re-trigger before the sequencer state can change again. RESTART, CaptComp or Reset can also force a transition to the state S and reset the logic directly.","As described for SEQ LOGIC, simultaneous events from different processors - are captured to activate capture signal CAPT. The sequencer .state machine SEQ SM of  desirably provides extensive, programmable capability to detect and trigger on related processor actions and on processor interactions between processors -. These actions and interactions are captured programmably and can be simultaneous or sequential or mixtures of both. State S operates as an IDLE state, and state S acts as a Capture state. If transition conditions noted by arrows from state to state are Boolean inactive (e.g., zero) and thus not currently satisfied, operations remain in the current state, as indicated by the legend \u2018else\u2019 added to respective arcs from each state to itself. A given transition condition noted by a respective arrow from state to state is qualified when a respective particular sequence event occurs. The transition is activated and occurs along the arrow from the current state to a configured destination state nxt_st. The nxt_st configuration for SEQ SM is entered in registers SEQ REGS as described in  or .","In , the sequencer state machine SEQ SM in the sequencer block .of  provides the ability to perform complex trace sequence qualification for and across multiple processors, beyond the capability of a trigger sequencer for one processor. When debugging complex multi-processor systems, the sequencer allows a trigger event to queue another trigger event, and if that does not occur, the state of the triggering logic can return to the untriggered state.","An example of use of the sequencer of  is a video processing engine consisting of several processors. One processor is responsible for moving data into and out of the chip and the other processors are used to compress a portion of an image. The sequencer can be programmed to move to state S while any of the image processors are busy, and to state S if the data moving processor gets activated. This approach is used, for instance, to detect one processor trying to move image data, while another processor has not completed its portion of an algorithm in time, causing data corruption. If all of the image processors are done, the state returns to S, so an activation of the data movement processor does not cause the state to advance to S. If state S is reached, the trace data for the image processors may show an algorithm inefficiency, a data dependency, an unexpected interrupt, or other condition causing the problem.","In , another embodiment of sequencer .also has a sequencer state machine SEQ SM described by a state transition diagram. Compared to , an IDLE state is added, and SEQ SM is responsive to Reset, as well as to CaptComp or RESTART from Capture Control ., to return to IDLE, and sequence events Seq_evx are multiplexed in  or  to produce multiplexed sequence events Mseq_evx.","In , this embodiment of sequencer state machine SEQ SM can move from any state IDLE, S, S, S, or S to one or more other said states in ways defined by the transition arrows. The IDLE state is the starting state. When state S is active the Capture signal is asserted (CAPT=1), and all other states IDLE, S,  and S, the Capture signal is de-asserted (inactive CAPT=0). States S, S, S and S are used to provide sophisticated or complex tracing capability. The sequencer .state machine SEQ SM of  desirably provides further extensive, programmable capability to detect and trigger on related processor actions and on processor interactions between processors -. These actions and interactions are captured programmably and can be simultaneous or sequential or mixtures of both. If transition conditions noted by arrows from state to state are Boolean inactive (e.g., zero) and thus not currently satisfied, operations remain in the current state as long as the Sequence Counter .has not timed out, as indicated by the legend Seqx_tc=0 by respective arcs from each state to itself. A given transition condition noted by a respective arrow from state to state is qualified when a respective particular sequence event occurs. The transition is activated and occurs along the arrow from the current state IDLE or S-S to a configured destination state nxt_st. The nxt_st configuration for SEQ SM is entered in registers SEQ REGS as described in  or . When either the Sequence Counter .has timed out for a given state, operations go from the given state to IDLE as indicated by the legend Seqx_tc by respective arrows to IDLE from any given state.","Dynamic determination of which processor activity to trace based on the sequencer event inputs seq_evx is also provided when necessary or desired. For instance, in a homogeneous array of processors, tasks may be assigned randomly depending on whether a processor is free or not. In such scenario, the processor of interest is the one which generates a trigger event on a dynamic basis and cannot be preassigned. Accordingly, circuitry for dynamic determination of which processor activity to trace based on the sequencer event inputs is also provided in that case.","In , a first example of operation of state machine SEQ SM is configured to start in IDLE and respond to a first event Seq_ev, Seq_ev, Seq_ev, in any one of the processors , ,  followed by an event Seq_ev in processor . In , a Mux maps the processor  event Seq_ev to a Mux output Mseq_ev for use by state machine SEQ SM. Also, Mux maps first event Seq_ev, Seq_ev, Seq_ev for processors , ,  to Mux outputs Mseq_ev, Mseq_ev, Mseq_ev for state machine SEQ SM. Then, regardless of which muxed event Mseq_ev, Mseq_ev, Mseq_ev goes active, the state machine SEQ SM goes from IDLE or S-S to one of the intermediate states S, S, S. Then if the processor  event occurs, Mux output Mseq_ev goes active and transitions from whichever state S, S or S to the Capture state S. However, suppose operations have reached one of the intermediate states S, S, S and no processor event occurs during a time period programmed for Seq Ctr .. In that case, operations time out and go back to IDLE, whereupon the sequence monitoring continues anew.","Also, notice that in  some of the transition arrows are missing compared to . Configuring nxt_st values in the configuration registers of  or A can effectively eliminate or include or add various transition arrows in the state transition diagram. A transition arrow is eliminated by configuring the nxt_st value for a given state to be that same state itself, and a transition arrow is included or added by configuring the nxt_st value for a given state to be a different state to which the arrow is to point.","In , a second example of operation of state machine SEQ SM is configured to start in IDLE and respond to events in the exact order Seq_ev, Seq_ev, Seq_ev, Seq_ev, from the processors , , , . In , the Mux maps the processor Seq_evX ordering X=3, 1, 2, 0 to Mux outputs Mseq_evY with Y=0, 1, 2, 3 for use by state machine SEQ SM. Also,  nxt_st entries are configured as follows for: S\u2014all S except S for Mseq_ev; S\u2014all S except S for Mseq_ev; S\u2014all S except S for Mseq_ev. S\u2014all S. Then when the processor , , ,  events successively occur, Mux outputs Mseq_ev, , ,  successively go active and transitions go from IDLE to state S, to S, to S, to S whereupon Capture signal CAPT=1 is asserted and output. However, suppose operations have reached one of the intermediate states S, S, S and no processor event conforming to the sequence occurs during a time period programmed for Seq Ctr .. In that case, operations time out and go back to IDLE, whereupon the sequence monitoring continues anew.","In , the sequencer .embodiment includes Mux and Combinational Logic configured by a Selection Control Register SEL.CTRL.REG to map the processor events Seq_evX ordering X to Mux outputs Mseq_evY. Additionally, combinational logic processes the mapped processor events according to programmed combinational logic to detect concurrent processor events of particular interest and map any one of them to one or more outputs Mseq_evY instead. The combinational logic also is programmable to make an instance of sequencer counter SEQ CTR .timeout itself constitute a sequence event or make such counter timeout also be qualified by a particular processor event Seq_EvX. In this way, event states Mseq_evY are fed into the sequencer state machine SEQ SM of sequencer .so that successive states, repetitions of the same state or successive concurrences of different states are fed to and captured by state machine SEQ SM.","In , a further alternative embodiment for sequencer .has multiple individually-configurable sequencer state machines SEQ, SEQ, . . . SEAN, and each such state machine is like the sequencer state machine SEQ SM of  or A or similar The Capture state of each state machine SEQ, SEQ, . . . SEQN is designated PRE_CAPT, PRE_CAPT, . . . PRE_CAPTN. The inputs of the state machines SEQ, SEQ, . . . SEQN are respectively fed by Mux and Combination Logic as in . Further in , the PRE_CAPTx outputs of the state machines SEQ, SEQ, . . . SEQN are fed to additional output Combinational Logic to detect concurrent occurrences of different sequences of events that occur within a time window or otherwise related to each other. In some further embodiments, a further state machine SEQ SM monitors sequences in such concurrent occurrences and provides a Comprehensive Capture output CAPT to feed very complicated combinations and sequences of event states into the Capture Control sequencer state machine .",{"@attributes":{"id":"p-0148","num":"0147"},"figref":["FIG. 23D","FIG. 23"]},"In , a set of registers SEQ REGS for the sequencer .in , , A, B contains a control\/status register Seq Cntrl for resetting, and enabling the sequencer .and the ability to read the current state. The  register set SEQ REGS is replicated to the extent desired to support the plurality of state machines SEQ, SEQ, . . . SEQN in .","In  SEQ REGS, a multi-bit sequence count register Seq Cnt is used to set the value in the Sequencer Counter .of . Since the sequencer .has four states S-S in , there are four Seq_Cfg registers in , one for each state. For each state S-S, the next state nxt_st is or can be programmed in respective register fields for each of the sequencer events seq_ev-. Also, a Seq_Ctr timeout nxt_st register field specifies the next state when the Sequencer Counter .expires.","Sequencer Counter .is a loadable counter that is loaded with the Seq Ctr register SEQ CNT (count) value when SeqX_Cfg register subfield Ld is set active and the state corresponds to X. The Sequencer Counter .is enabled when the SeqX_Cfg register subfield Run is set active and the state corresponds to X. The Sequencer Counter .expires by reaching zero after down-counting from the pre-programmed sequence count value specified, programmed or configured in register SEQ CNT. When Sequencer Counter .expires, it issues an active signal on the  line seq_tc to sequencer .. (The counter could of course be an up-counter instead and arranged to expire when the count up equals the pre-programmed sequence count Ld in Seq_Ctr.) The Seqx_Cfg registers of  also contain control bits in register field Seq_Ctr for the Sequencer Counter .to allow the value to be cleared and the Sequencer Counter .to be enabled\/run by an active enable\/run signal on  line seq_run from an active Run bit in the Seq_Ctr field Run in .  provides a steady state arc (\u201celse\u201d) for each state S-S. This allows the sequencer .of  to dwell in a state S-S, waiting for another event Seq_Evx, or to return to a different state S-S if the Sequencer Counter .reaches zero (seq_tc active).","In , an alternative register set for SEQ REGS is described similarly to  and augmented further. SEQ REGS of  further provides configuration bits values \u201cabcd\u201d for different registers to program the mux mapping and Boolean logic operation of Mux and Combinational Logic of  and . For example, the number of bits to control mapping of N bits for Seq_evX is log(N!), e.g. 5 bits to map four inputs to four outputs Mseq_evY. Various combinational logic functions are selected under control of additional configuration register bits to process the input lines and\/or output lines of a Mux and Combinational Logic unit of  or . Seq_Ctr field of  is augmented with a subfield called Clear clr in .","In , in a state transition diagram for Capture Control state machine ., the Capture Control state machine .selects the data to output, based on the capture control registers CAPT REGS of . For this state machine .of , the four processors - provide four trace sources, for example. Correspondingly, the number of states for this state machine .is suitably established as S=2*N+3, e.g., S=11 states including N=4 capture states C-C for the number N of trace sources, plus an equal number N of wait states W-W for the number of N trace sources to wait for each buffer ready signal bufx_rdy, plus an initial ready state RDY state plus a Done state plus a RESTART state. A mode of operations is configured in  as single capture (Mode=single) or continuous capture (Mode=cont). In Mode=single the state machine .starts in the RDY state and ends in the Done state, and then returns to RDY upon being specifically re-initialized by software or RESET active in  register Capt Cntrl. In Mode=cont, state machine .returns from the Done state to the RDY state via RESTART automatically.","When the CAPT signal is asserted from the sequencer SEQ .of , and given that the master enable EN is active in register Capt Cntrl of  or A, the Capture Control state machine .in  goes from RDY state to the lowest x-numbered enabled (Bufx_En=1) wait state Wx among states W through W, as indicated by the lowest active x-numbered  register entry bufx_en=1. The state machine .waits for the bufx_rdy signal to indicate the post-counted capture of trace data is complete. State machine .then advances to the correspondingly-numbered capture state among states C through C. Each state Cx activates its respective output DRAINx to the corresponding  Circular Buffer , activates the Capture Counter .by supplying a signal captx_en to the capt_en line of , and supplies a respective multiplexer control mux_ctl=0, 1, 2, or 3 to Trace Combiner . When the  number CaptCntx of samples for that state Cx have been output by the corresponding  Circular Buffer , the Capture Control state machine .of  advances to the next higher-numbered enabled wait state Wy. The just-described operations continue until all samples have been transferred from the pertinent circular buffers to Trace Combiner , with mux_ctl appropriately controlling the mux selections and function of Trace Combiner . If the bufx_en signal for any of the processors is 0, the data from that processor is not collected. Then the Capture Control state machine .goes to Done state and outputs a CaptComp active signal if the capture mode is Mode=single in the  Mode field. If the capture mode is continuous (Mode=cont), state machine .goes to the RESTART state to reset all of the trigger sources to get ready for the next occurrence of the trigger sequence, then it returns to the RDY state and waits for the next qualified trigger sequence. This programmability specifically captures the data of interest and transfers that data using Cross Trace Trigger  of  to Trace Combiner . Trace sources of no interest are thus skipped, and moreover, irrelevant trace combinations and trace sequences of no interest are also skipped. In some embodiments, trace tags are provided in the ID field of the Sequencer .state machine registers of  (A). The trace tags can be time stamps from Trace Combiner  or identifications otherwise assigned by the in-circuit emulator or using position information from the Circular Buffers -. In some embodiments, a trace-tag or time sync tag is issued in response to the Capture Control .state machine returning to the RDY state or reaching the DONE state. The process begins anew in subsequent tracing.","In , operations of Capture Control state machine .in  sequentially drain the pertinent data of circular buffers - of  that are applicable to the events captured or identified by sequencer .. In other words, this state machine .is primarily an output controller to unload the pertinent circular buffers one-by-one via the Trace Combiner  of  into the  On Chip Trace Buffer  and\/or Trace Export Unit  for export via trace pins  to Trace Receiver .","In , Capture Control state machine .is in the RDY state as operations commence or begin again. When CAPT becomes active from Sequencer ., the lowest numbered enabled circular buffer (as indicated by  register field bufx_en active) transitions the state machine .from RDY to the correspondingly numbered state Wx among wait states W, W, W and W and then to the corresponding state Cx among states C, C, C and C. The role of the various outbound-arrow legends (e.g., EN & CAPT & !buf_en & buf_en) is to verify not only that capture has occurred but also that a given circular buffer is enabled (in the sense that state machine .will access it) and all lower numbered buffers are not enabled (the symbol \u201c!\u201d stands for Boolean NOT). Bufx_rdy in turn responds to the signals wr_done from circular buffers of . For example, in , the register bits buf-_en are configuration bits corresponding to each circular buffer -. Buffer - outputs buf-_rdy are bits or signals activated upon completion of post-counting in  that acknowledge the HOLD\/STOP control from  Sequencer .","In , when a given Capture state C, C, C or C is reached, the Capture Control state machine .outputs a state Cx-specific drain command DRAINx from ,  to its corresponding circular buffer in . Buffer data BUF DATA streams out of  RAM .f to the  Trace Combiner  and is muxed by Trace Combiner mux under x-valued control signal mux_ctl=x that is concurrently supplied from state machine state Cx. The Trace Combiner  multiplexing circuit has a trace output and responds to the Capture Control state machine .to sequentially couple the applicable circular buffers to the trace output in coordination with the sequential draining of those circular buffers . In the meantime, state machine .state Cx of  activates enable line capt_en in  and enables Capture Counter CaptCtr .. Thus, in this meantime, Capture Counter .is counting down from the applicable CaptCntx value until counter terminal count signal capt_tc goes active (counter is zero). As described in connection with , Capture Control state machine .can drain a selected buffer sequence of selected ones of fewer than all the circular buffers and sequentially drain a first configurable amount of data from a first such circular buffer and then a second configurable amount of data from a second such circular buffer.","In , the state machine .then responds to the counter terminal count signal capt_tc and goes via a transition arrow to the next higher-x-numbered state Wx for which a  buffer enable bufx_en is active. This process is continued in the same manner until all circular buffers applicable to the cross-trace are drained. When the last, highest-numbered, applicable circular buffer has been drained, then a transition is made from the corresponding last-applicable state machine state Cx to the RESTART or DONE completion state, depending on whether Mode=cont or Mode=single respectively State machine .in the state DONE outputs the CaptComp signal of  to sequencer SEQ .in , , and A. The Restart signal is issued as part of the automatic transition to the RDY state via the RESTART state from last-applicable state machine state Cx in continuous mode (Mode=cont). In general, software initialization or hardware initialization that sets RESET active in  or A thereby resets all the logic in the circuitry directly, see , , A, . This reset operation also means that when state machine .is in the DONE state in Single mode, setting RESET active returns operations from the DONE state directly to the RDY state.","In , Capture Control registers Capt Cntrl facilitate output from each of the trace sources using bit lines Bufx_en. The full or empty status of each circular buffer in  can be read back on the Bufx_rdy signals from  Trace Capture Qualifiers - and Circular Buffers -. Capture Control registers Capt Cntrl of  have a RESET field that programmably resets the  state machine .to RDY state and an enable field EN that enables the Capture Control state machine .. Reading a STATE field in Capture Control registers Capt Cntrl provides the current state machine state RDY, W-W, C-C, RESTART or DONE. Each of the trace sources has a separate count value register, Capt Cnt- with values Read_Count- to separately load the  Capture Counter Capt Ctr .and send Read_Countx to circular buffers . The number of CaptCnt registers corresponds to and varies with the provided number of trace sources, as do the enables Bufx_en and ready statuses Bufx_rdy in the Capt Cntrl register. The CaptCntx register fields specify the number of trace words to output for each trace source . Individual counts CaptCnt- are programmable to allow the Cross Trace unit  to capture more or less data from each trace source, i.e. source-specifically, depending upon the amount of information the user wants to capture. Alternatively, a single CaptCnt register is used to support access to each trace source and capture a non-source-specific amount of data from each trace source, such that each amount is equal or the same.","In , a register array of post counts and offsets are added, compared to the registers of . Each respective post count register Post Cnt- determines how many samples to capture from  Circular Buffers - to the On Chip Trace Buffer  (e.g., ) after the trigger event. Each respective Offset register Offset- determines how many samples to extract from  Circular Buffers - before the trigger event. Register fields buf- of  include the register fields bufx_en and bufx_rdy of .","A programmable\/configurable MODE register is coupled to a mode decoder and configuration circuit block in . The mode decoder and configuration circuit block is suitably provided in some embodiments to respond to a given MODE identifier in the MODE register and deliver decoded outputs and configuration values to any one, some or all of the registers in , , , , , A, , A and B to implement various modes as discussed further herein.","In , the description of  applies to the extent of correspondence to . In addition, the trace source (buffer ) selection has been augmented. Instead of just enabling a trace source , the Bufx_en can be qualified. Each buffer control register field bufctl_x has a select Sel field which statically selects the buffer for draining as does bufx_en of  hereinbefore. Moreover in , each buffer control register field bufctl_x has also four (4) .actY control signals which can qualify a trace source for data capture. The Bufx_rdy, Bufx_en and state machine status values are diagrammatically moved to and situated in a separate read only Capture Status register, CaptStat.","In , the Bufx_en signal for each buffer is generated by logic of  to enable Bufx_en for draining (bufctl_x_Sel=1) when capture occurs or to conditionally enable it (bufctl_x.actY=1). When conditionally enabled, the buffer corresponding to the trace source will only be drained on the condition if the  Triggering Unit state machine .for processor is in any one of the bufctl_x_actY specified trigger states TY. This conditional","enablement is illustrated in  and expressed by Equation (1) using an OR",{"@attributes":{"id":"p-0164","num":"0163"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mo":["(",")"],"munder":{"mo":"\u22c3","mi":"Y"}}}},"br":{}},{"@attributes":{"id":"p-0165","num":"0164"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mi":"Bufx_en","mo":"=","mrow":{"munder":{"mo":"\u22c3","mi":"Y"},"mo":"\u2062","mrow":{"mrow":{"mo":["(",")"],"mrow":{"mrow":{"mrow":{"mi":["flagX","mY"],"mo":"."},"mo":["\u2062","&"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},"mo":["\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mi":["bufctl_x","_actY"]}},"mo":"."}}}},{"mrow":{"mo":["(",")"],"mn":"1"}}]}}}}},"In , logic .(.-.) generates the Bufx_en signal. Each unit of the logic is a replica of logic ., shown in detail. OR-gate .passes an active Bufctl_x_Sel signal, which activates Bufx_en by static configuration using Bufctl_x_Sel. OR-gate . also receives inputs from four AND-gates .-.. Each AND gate .XY has a first input for bufctl_X.actY and a second input for flag_X.mY. For dynamic or conditional enable of Bufx_en by the flags flag_X.mY, then Bufctl_x_Sel is made inactive and bufctl_X.actY are configured or set active, for example, instead.","Note that each bufX_en is a register bit in a flip-flop that stays set once it is set. BufX_en becomes set if a flag_X.mY contributes to some pertinent sequence in SEQ .at any time instance along the way. The FIG. B\/C logic circuit dynamically selects only the circular buffers X for those CPUs X of interest to drain when bufctl_X.actY are set active.","In a periodic sampling mode situation described later hereinbelow, the bufctlX.s bit is set for all those CPUs of interest. When the trigger .and Sequencer SEQ .events occur such that data will be drained, that data is then drained from every selected CPU corresponding to which the bufctlX.s bit is set.","In scenario for a simultaneous activity mode also described later hereinbelow, four (4) CPUs are running and any two of them may be competing for the same resources, the analyst or software specifies the pertinent trigger states (flagX.mY) by setting correspondingly X,Y numbered bufctlX.actY, that will allow data to be drained. This way when a deadlock situation occurs, say between processor  and processor , only their buffers  and  are drained, and buffers  and  processor  and processor  are not drained. The circuitry to control BufX_en bits is provided and arranged so that the BufX_en bits go on and off if SEQ SM encounters a trigger sequence that only approaches and does not include the final capture event and then goes back to state S without reaching capture state S. In this way, such circuitry is prevented from getting or accumulating a lot of irrelevant bufX_en that could occur in some uncompleted trace scenarios playing out in the multi-processor system.","This prevention becomes ever more important as integrated circuit chips and systems with larger and larger numbers of processor cores become increasingly pervasive in the global market. Preventing accumulation of irrelevant bufX_en can thereby substantially increase the debug and tracing value and efficiency of the circuitry in systems with larger numbers of processor cores not only for systems, and systems-on-chip (SoC), with a few more than two cores, but also for contemplated systems with 16, 64 or hundreds or more processor cores.","For instance, in a potential processor deadlock monitoring sequence, suppose a first processor  grabs both resources R and R and a second processor  requests a resource, then deadlock might happen if sequencer counter .timeout occurs after a predetermined time interval and SEQ SM state S would be reached. In that case, the one-bits in bufX_en due to flags that went active during that sequence would remain latched in bufX_en for use by capture state machine .to drain the circular buffers X corresponding to active bufX_en bits. But if the first processor  instead releases the resources in time (i.e., before timeout), the second processor  would be able to complete its task without a deadlock situation arising and state machine SEQ SM would return to state S. Accordingly, the BufX_en bits are automatically reset (off) because no deadlock has occurred at the moment.","As noted, the circuitry in some embodiments is arranged so that the BufX_en bits go on and off if the trigger sequence only approaches and does not reach the final capture event and then goes back to state S. In that case, the one-bits in bufX_en due to flags that went active during an incomplete sequence are reset to zero in bufX_en upon the SEQ SM going back to state S. The flagX_mY signals are active when a  Triggering state machines .X are in a given state TY, so if they change state, the flags can get de-asserted automatically and memorylessly. The trace capture qualifiers register the match signals in order for them to cross clock domains, but these registers .() just introduce some latency, but basically follow their input matchY signals to output the flagX_mY signals. So the  logic .X inherently has, or can be readily made to have, this behavior to make bufX_en go on and off if the trigger sequence in sequencer SEQ .approaches the final capture event but state S is not reached and the SEQ SM instead then goes back to state S. Compared to the AND logic in the merge unit .of ,  A, sixteen (16) bufctl_X.actY bits are present in the bufX_en logic .of . Sixty-four (i.e., 4\u00d716=64) mask bits Seq_ev-_flag_X_mskY support four Seq_ev-, sixteen (16) of the mask bits to support each of the four Seq_EvX from the merge unit .of . Four (4) flags per processor are provided in  for a total of sixteen (16) flags to support four processors - in this example. There are 64 mask bits, but the same 16 flags are used together with each of the four sets of 16 mask bits per event. The programmability lets each Seq_Ev be activated by different combinations of trigger states T-T in . In some embodiments, circuit optimization can reuse some of the AND-gates from the merge\/mask circuitry .in  for AND-gates  in the bufX_en circuitry of . Some other embodiments have separate sets of gates in  and in .","Four logic circuits .- are provided in , controlled by the 5-bit bufctlX fields of the capture control register CaptCntrl. The output of each of the four AND\/OR gates is a single bit called bufX_en (e.g., four total). Note by way of comparison that the registers of  or A have four (4) programmable static register bits called BufX_en in the CaptCntrl register. In , the logic circuits .- are added and used in combination with the registers of , thereby providing or generating the four (4) register bits BufX_en in the CaptCntrl register thus to be dynamically programmable based on processor X operations on the fly. The  CaptStat register is provided with bits BufX_en and allows these BufX_en bits to be read back as well.","The  logic .- provides the cross trace unit  the ability to respond to bufctlX.s to either drain any statically selected buffer X, or instead to use bufctl_X.actY to respond dynamically to Triggering units X to drain only those buffers X corresponding to particular Triggering units X that have reached one of the programmed trigger states in response to operations of processors X. The bufctlX.actY bits are set up or configured ahead of time, but the logic circuits .- provide dynamic control of the buffer draining, by only activating particular BufX_en signals if the operations of particular processors X interestingly put their corresponding Triggering units X in the selected Trigger states.","In a debug process, suppose the debug analyst is still uncertain whether other processors X may be contributing to a given problem. In that case, the debug analyst conveniently sets the bufctlX.s bits for all the processors X for X=0, 1, 2, . . . N and this captures all of the data pertaining to the problematic event to sort through for subsequent debug analysis or scrutiny. This is a further useful feature of the bufctlX.s bits in register CaptCntrl.","The exact number and order of sequence events Seq_ev- is less relevant for the most part to determining which bufX_en signals should be enabled although useful in some versions. However, when the sequencer state machine .reaches capture state S in  or A, the logic .X operates to latch the bufX_en active signals resulting from flags that contributed to the sequence that reached state S. Draining the circular buffers X corresponding to those bufX_en active signals provides a snapshot of all those processors X that interacted to reach the capture state S and generate CAPT active.","In some embodiments, a single mode bit (call it ACT) is coupled to logic analogous to that of , and sets all sixteen Bufctl_X.actY bits active. Sometimes a processor CPU X participates in the pertinent trigger sequence, but the trace data is not of interest for particular debug or trace purposes. In such case, the BufctlX.actY bits Y=0,1,2,3 for that particular processor X are set to zero individually by configuration. In , alternative logic is provided for circuits .that latches the buffer enable value in a D-latch for bufX_en when capture signal CAPT occurs. Subsequently, the logic responds to capture completion CaptComp and clears that D-latch for bufX_en after the buffers have been drained. Compared to , this logic of  provides and uses a mux . to isolate flag behavior from affecting the state of bufX_en until capture signal CAPT goes active. The  circuitry beneficially focuses bufX_en activity on flags that are active when  SEQ .reaches capture state S, and not flags that were involved in irrelevant earlier uncompleted sequences. When capture signal CAPT goes active at the selection input of mux ., the output of OR-gate . is coupled by mux . to a first input of an AND-gate . that is qualified by CaptComp inactive at a second input while capture completion in capture SM .remains pending. The output of OR-gate . thereupon passes through AND-gate . and is latched into the D-latch bufX_en that supports the register bit bufX_en. Upon capture completion CaptComp goes active and disqualifies AND-gate ., resetting the D-latch for buf_en. Moreover, CAPT also goes inactive and controls mux . to keep the output of AND-gate . low and maintain buf_en reset low.","Transient conditions can come and go that involve a first processor and its Triggering unit reaching and leaving a trigger state TY. Such condition can cause a non-returning Seq_evY in Merge Unit .(i.e., Seq_evY going from inactive to active and then back to inactive instead of staying active or returning to active). The temporarily-active Seq_evY is desirably sufficient to transition SEQ SM, and can be followed by some other event due to some other processor to go to the capture state S, while the first processor has already exited from its trigger state. Seq_evY going back to inactive might leave nothing for the bufctlX.actY register bits to enable, and thus not indicate that buffer for processor should be drained. Alternative implementations may include sticky control bits which will remember any processor involved in the sequence of events leading up to the capture of trace data. If a REARM signal is asserted, those sticky bits would be reset.","But for some scenarios, like debugging processors deadlocking over resources, the processors X are basically hung in their states waiting forever, so the flagX.mY signals do not get de-asserted. Other scenarios might have a more transient trigger sequence, and in using some embodiments, the debug analyst can just set the bufctl_X_Sel signal of all processors X that might be involved, and then capture all the trace data and sort through it. Also, more selective methods and embodiments can be applied as described further to handle transient conditions. To handle a transient condition, one approach simply revises the  configuration of Triggering SM circuitry .such that if  State T is active, then instead of returning to no-trigger state NT when the trigger condition is negated, return to state T instead. This way the Triggering state machine logic .can use the state (e.g., T) to remember that a trigger has occurred sometime in the past. Then this memory state (e.g., T) can be used to generate a persisting flag_x.m with a  bufctlX.act qualifier respective to it, even though the state machine .for processor is no longer in the active trigger state T.","In another embodiment, FIG. B\/C logic is used, and the bufX_en bits are supported by RS flip-flops or otherwise to remain set once they become set and until they are affirmatively reset. Also, SEQ SM in SEQ .has state S associated with an additional helper state (call it RETX) to which all transition arrows going to state S in  or A go instead. In an uncompleted trace trigger scenario, State RETX affirmatively resets all the bufX_en bits and then transitions directly to state S. In this way, the bufX_en RS flip-flops are prevented from getting or accumulating a lot of irrelevant bufX_en resulting from uncompleted trace trigger sequence scenarios in the multi-processor system. The circuitry is arranged in such embodiment so that the BufX_en bits go on and off by 1) going on if the trigger sequence only approaches the final capture event without reaching state S and 2) going off if the trigger sequence then goes back to state S. However, if a transient flag_X.mY and its sequence event Seq_evZ contributes to the final vital SEQ SM sequence but does go inactive during the sequence and prior to reaching capture state S, the bufX_en RS flip-flop bit for that flag does not go off but instead remains set and ready for draining circular buffer X.","In some embodiments such as FIG. B\/C or B\/D, further filter logic circuitry is additionally included to generate derived flags called filtered flags herein (designate them FFlag_X.mY). Filtered flags FFlag_X.mY are produced by circuitry similar to  reused from the AND-gates of  and with further AND-gates qualified by each Sequence event Seq_evZ to which the flags contribute. The ANDing (&) performs a filtering operation producing filtered elements represented by the Boolean expression (2).\n\nSeq_evZ & (flagX_mY & seq_evZ flag_X.mskY)\u2003\u2003(2)\n","ORing over sequence event index Z",{"@attributes":{"id":"p-0183","num":"0182"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mo":["(",")"],"munder":{"mo":"\u22c3","mi":"Z"}}}},"br":{}},{"@attributes":{"id":"p-0184","num":"0183"},"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mi":["FFlag_X","mY"],"mo":"."},{"mrow":[{"mrow":{"munder":{"mo":"\u22c3","mi":"Z"},"mo":"\u2062","mi":"Seq_evZ"},"mo":["\u2062","&"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"mo":["(",")"],"mrow":{"mrow":[{"mi":"flagX_mY","mo":["\u2062","&"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"mi":["_X","mskY"],"mo":"."}],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mi":["seq_evZ","_flag"]}}],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}],"mo":"="}},{"mrow":{"mo":["(",")"],"mn":"3"}}]}}}}},"In this filtered flag circuitry embodiment, the buffer enable bits bufX_en are produced from the filtered flags ANDed with the configuration bits bufctl_x_actY in Boolean Equation (4A) in a manner patterned after Equation (1). Circuitry, such as a pair of AND-gates or a three-input AND-gate, represented by Boolean expression (2) filters out irrelevant flag instances that don't contribute to any active Seq_evZ. Then, OR-gates are sufficiently provided to OR over indices Y and Z thereby to deliver signals to the bufX_en latches according to Boolean Equation (4B):",{"@attributes":{"id":"p-0186","num":"0185"},"maths":{"@attributes":{"id":"MATH-US-00005","num":"00005"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":[{"mrow":{"mi":["bufX_en",{}],"mo":["=","\u2062"],"mrow":{"mrow":{"mrow":{"munder":{"mo":"\u22c3","mi":"Y"},"mo":"\u2062","mrow":{"mi":["FFlag_X","mY"],"mo":"."}},"mo":["\u2062","&"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},"mo":["\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mi":["bufctl_x","_actY"]}}},{"mrow":{"mstyle":{"mspace":{"@attributes":{"width":"3.6em","height":"3.6ex"}}},"mo":"\u2062","mrow":{"mo":["(",")"],"mrow":{"mn":"4","mo":"\u2062","mi":"A"}}}}]},{"mtd":[{"mrow":{"mrow":{"mo":["=","\u2062"],"mi":{},"mrow":{"mrow":{"munder":{"mo":"\u22c3","mi":"Y"},"mo":"\u2062","mrow":{"munder":{"mo":"\u22c3","mi":"Z"},"mo":"\u2062","mi":"Seq_evZ"}},"mo":["\u2062","&"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}},"mo":"\u2062","mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}}},{"mrow":{"mo":["(",")"],"mrow":{"mn":"4","mo":"\u2062","mi":"B"}}}]},{"mtd":[{"mrow":{"mi":{},"mo":"\u2062","mrow":{"mrow":{"mo":["(",")"],"mrow":{"mrow":[{"mi":"flagX_mY","mo":["\u2062","&"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"mi":["_X","mskY"],"mo":"."}],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mi":["seq_evZ","_flag"]}},"mo":["\u2062","&"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}}},{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}]},{"mtd":[{"mrow":{"mi":{},"mo":"\u2062","mrow":{"mi":["bufctl_x","_actY"],"mo":"\u2062"}}},{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}]}]}}}},"Some embodiments have a configuration mode wherein the register bits bufctlX.actY themselves are automatically and dynamically generated, such as by ORing over all Z all the seq_evZ flag_X.mskY either according to Equation (5) or (5A):",{"@attributes":{"id":"p-0188","num":"0187"},"maths":{"@attributes":{"id":"MATH-US-00006","num":"00006"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":[{"mrow":{"mrow":[{"mi":["bufctl_X","_actY"],"mo":"\u2062"},{"munder":{"mo":"\u22c3","mi":"Z"},"mo":"\u2062","mrow":{"mi":["seq_evZ","_flag"],"mo":["\u2062","\u2062"],"mrow":{"mi":["_X","mskY"],"mo":[".","."]}}}],"mo":"="}},{"mrow":{"mo":["(",")"],"mn":"5"}}]},{"mtd":[{"mrow":{"mrow":[{"mi":["bufctl_X","_actY"],"mo":"\u2062"},{"mrow":[{"mrow":{"munder":{"mo":"\u22c3","mi":"Z"},"mo":"\u2062","mi":"Seq_evZ"},"mo":["\u2062","&"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"mi":["_X","mskY"],"mo":"."}],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mi":["seq_evZ","_flag"]}],"mo":"="}},{"mrow":{"mo":["(",")"],"mrow":{"mn":"5","mo":"\u2062","mi":"A"}}}]}]}}}},"Equation (1) earlier hereinabove describes the conditional logic in , so substituting Equation (5A) into Equation (1) yields the circuit represented by Boolean equation (6):",{"@attributes":{"id":"p-0190","num":"0189"},"maths":{"@attributes":{"id":"MATH-US-00007","num":"00007"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mi":"BufX_en","mo":"=","mrow":{"munder":{"mo":"\u22c3","mi":"Y"},"mo":"\u2062","mrow":{"mo":["[","]"],"mrow":{"mrow":[{"mrow":{"mi":["flagX","mY"],"mo":"."},"mo":["\u2062","&"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"mo":["(",")"],"mrow":{"munder":{"mo":"\u22c3","mi":"Z"},"mo":"\u2062","mrow":{"mo":["(",")"],"mrow":{"mrow":[{"mi":"seq_evZ","mo":["\u2062","&"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"mi":["_X","mskY"],"mo":"."}],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mi":["seq_evZ","_flag"]}}}}],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}}}}},{"mrow":{"mo":["(",")"],"mn":"6"}}]}}}}},"Generally, the OR\/AND structure of circuitry that these various Boolean Equations represent is a more elaborate circuitry analogous to the circuitry of . To avoid unduly multiplying the drawing Figures, the additional circuitry embodiments are believed to be sufficiently specified and disclosed by their Boolean expressions and equations and the associated description herein. Some embodiments drain the buffers X in an X-ordered sequence as described in detail herein, corresponding to the active bufX_en bits. Some other embodiments are also feasible to drain the buffers X corresponding to the active bufX_en in parallel with each other, and the herein-described static and dynamic methods of generating the active bufX_en bits facilitate the use of both kinds of embodiments. Many embodiments and combinations thereof for dynamic determination and use of bufX_en are thus possible.","In operation, the Cross Trace Trigger unit  is configured or parameterized to generate the desired number of processor CPU - bus inputs. The inputs may be operating at different clock rates so appropriate clock domain crossing logic is suitably provided for  Trace Capture Qualifiers -. The Cross Trace Trigger unit  has several modes of operation, as described in detail next. Various embodiments can provide or omit various such modes and other modes. Configuration is simplified by using mode macros for configuring the various registers according the following descriptions of different modes, and then selecting any particular mode using a corresponding particular value of one or more mode ID bits. Four modes of operation presented here are 1) periodic sampling, 2) shared data, 3) event sampling and 4) simultaneous activity. These modes are not necessarily exclusive.","1) Periodic Sampling Mode","In a periodic sampling mode of Cross Trace Trigger unit , the circular buffers - are configured to store program counter (PC) values for each of the processors -. The Cross Trace Trigger unit  outputs HOLD\/STOP in , ,  and stops the capture of all the applicable circular buffers - simultaneously or concurrently. Cross Trace Trigger unit  then issues a DRAINx drain signal using Read Counter .to count from a current count or position value to the pre-established or pre-programmed buffer depth values from each circular buffer. Since data from the processors - is acquired concurrently, this Periodic Sampling mode provides a snapshot of where each processor - is running at the exact time the capture is stopped. Once the data is drained and stored or exported, the data acquisition can be or is repeated. The event which causes this sampling can be a timer event, or the data acquisition can simply run at the maximum capture rate. The program counter PC values are compressed in some embodiments within each buffer to maximize trace output bandwidth, by minimizing the amount of data to be sent. This mode is suitably used for profiling code, for one example.","Using the example triggering and cross trace registers previously described for a four processor system, the Periodic Sampling mode is configured by setting the respective Triggering Unit - registers of  for each processor - as shown in TABLE 1 (no triggers). Also, the registers of  for Cross Trace Trigger unit  are configured as shown in TABLE 2. This configuration example causes the Cross Trace Trigger unit  to generate a capture event every 150 clocks (Seq Ctr), and then extract 32 trace data values (PostCnt, CaptCnt) for each of the four processors -. The cross trace sequencer .state machine SEQ SM of  starts in IDLE state S and loads the register Seq Ctr value 150 into the counter Seq_Ctr .of . State machine SEQ_SM advances to state S and waits for the counter Seq_Ctr to count down to 0 whence timeout event seq_ev=seq_tc=1, and then SEQ_SM goes to state S and activates Capture CAPT\/HOLD. State S signal CAPT=1 from sequencer state machine SEQ SM triggers the Capture Control state machine .of . Capture Control state machine .issues DRAIN- signals to the circular buffers - and drains them for 32 clocks as specified by registers PostCnt- and CaptCnt- in . Capture Control state machine .then issues CaptComp to Sequencer .state machine SEQ SM. The state of sequencer state machine SEQ SM responds to the CaptComp signal and goes back to IDLE state S, reloading the counter Seq_Ctr with the value 150. ( explicitly illustrates the CaptComp transition from a state back to IDLE.) This overall structure and process embodiment operates and occurs continuously until it gets disabled, such as by resetting the Sequencer Control register Seq Cntrl.",{"@attributes":{"id":"p-0195","num":"0194"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"PERIODIC SAMPLING MODE, TRIGGER REGISTERS"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"49pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Register Name","Value","Register Name","Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":[{},"Addr Comp 0","0x0","Addr Mask 0","0x0"]},{"entry":[{},"Addr Comp 1","0x0","Addr Mask 1","0x0"]},{"entry":[{},"Addr Comp 2","0x0","Addr Mask 2","0x0"]},{"entry":[{},"Addr Comp 3","0x0","Addr Mask 3","0x0"]},{"entry":[{},"Data Comp 0","0x0","Data Mask 0","0x0"]},{"entry":[{},"Data Comp 1","0x0","Data Mask 1","0x0"]},{"entry":[{},"Data Comp 2","0x0","Data Mask 2","0x0"]},{"entry":[{},"Data Comp 3","0x0","Data Mask 3","0x0"]},{"entry":[{},{},{},"nt_cfg","0x0"]},{"entry":[{},"Trig0_cfg0","0x0",{},"0x0"]},{"entry":[{},"Trig0_cfg1","0x0","State0_cfg",{}]},{"entry":[{},"Trig1_cfg0","0x0",{},"0x0"]},{"entry":[{},"Trig1_cfg1","0x0","State1_cfg",{}]},{"entry":[{},"Trig2_cfg0","0x0",{},"0x0"]},{"entry":[{},"Trig2_cfg1","0x0","State2_cfg",{}]},{"entry":[{},"Trig3_cfg0","0x0",{},"0x0"]},{"entry":[{},"Trig3_cfg1","0x0","State3_cfg"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0196","num":"0195"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"PERIODIC SAMPLING MODE, CROSS TRACE REGISTERS"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Register Name","Value","Register Name","Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Seq Cntrl","Enable","Seq Ctr","150"]},{"entry":["Seq_Ev0","0x0","Seq_Cfg0","load ctr=1"]},{"entry":[{},{},{},"goto S1"]},{"entry":["Seq_Ev1","0x0","Seq_Cfg1","S3 when ctr=0"]},{"entry":[{},{},{},"else S1"]},{"entry":["Seq_Ev2","0x0","Seq_Cfg2","0x0"]},{"entry":["Seq_Ev3","0x0","Seq_Cfg3","goto S0"]},{"entry":["Capt Cntrl","All Bufx_en",{},{}]},{"entry":[{},"Enabled,",{},{}]},{"entry":[{},"Mode=",{},{}]},{"entry":[{},"\u2003Continuous",{},{}]},{"entry":["Offset 0","0x0","Capt Cnt 0","32"]},{"entry":["Offset 1","0x0","Capt Cnt 1","32"]},{"entry":["Offset 2","0x0","Capt Cnt 2","32"]},{"entry":["Offset 3","0x0","Capt Cnt 3","32"]},{"entry":["Post Cnt 0","32",{},{}]},{"entry":["Post Cnt 1","32",{},{}]},{"entry":["Post Cnt 2","32",{},{}]},{"entry":["Post Cnt 3","32"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"In the Shared Data mode of Cross Trace Trigger Unit , the Triggering Units - have address\/data qualifiers as discussed in  and . Triggering Units - monitor respective processor CPU - activity for actions which access shared data objects. The shared data objects can be semaphores, buffers, message queues, shared peripherals, or other shared data objects. The processor - CPUs address\/data qualifier of other Triggering Units - are suitably programmed to look for similar data accesses or program flow in interprocessor communication code. The Cross Trace Trigger unit  is programmed to capture CPU activity if there are one or more matches of activity when a processor - CPU data access or program execution of the shared data routine is detected by any Triggering Unit -. This can enable the user to determine what each CPU is doing when a shared data object is modified. The Cross Trace Trigger  logic in some embodiments also includes one or more intelligent sequencers as in, or based on, SEQ .of  and Capture Control .of  that hold state activity and then wait for additional state activity before triggering the CAPT output and\/or DRAINx signals. For example, the Cross Trace Trigger unit  logic can be configured to detect a sequence wherein a first processor CPU, e.g. , writes to a data location and then another CPU, e.g. , does not read the same data within a certain time frame or interval. Detection of that sequence causes a trigger event and records where the other CPU, e.g. , is executing code. By configuring the Cross Trace Registers with an Offset, the activity before the trigger can be captured. This is very useful when the trigger is a failure of an event to occur. If processor CPU  does read the data within the specified time frame, the Cross Trace Trigger unit  state machines of  return to looking for first-CPU  accesses to the shared data resource. Cross Trace Trigger unit  asserts the REARM signal to clear the previous triggered condition.","To illustrate this Shared Data mode of operation suppose, for example, a four processor system has CPU  managing buffers of data and CPU , CPU  and CPU  processing the data. Further, each data processing CPU - has two input buffers and two output buffers used in a ping pong fashion wherein one pair of buffers gets loaded\/unloaded while the other pair is being processed. CPU  copies data into\/out of the buffers and sets a data ready flag for each of the data processing CPUs -. When any of the data processing CPUs - finish processing a buffer of data, it sets a Data_Done_x flag. This enables CPU  to determine which data processing CPU is available to process the next buffer of information. A data overflow error may occur if the data processing CPUs cannot process the data fast enough or if CPU  cannot load and unload the buffers fast enough.","To trace the foregoing example in Shared Data Mode, TABLES 3-5 show the register configurations. The trigger registers of , ,  for CPU  are each configured with all zeroes as shown in TABLE 3. No triggers are configured in this example to occur due to CPU  buffer-managing activity. Trigger state machine  of Triggering Unit  stays in its NT state that issues no match flag. The trigger registers of , ,  for the data processors - are each configured as shown in TABLE 4. When a processor executes in the poll routine, as indicated by asserted addresses in an address range characteristic of that poll routine, it causes the corresponding Triggering Unit state machine  of  to go from no-trigger state NT to trigger state T.","To accomplish this, the configuration previously sets  registers AddrComp, to the start\/end addresses of the poll ready poll routine code.  register field Trig_cfg_addr is set to 011 (=,> for greater than or equal) and Trig_cfg_addr is set to 110 (<,=). The AND register field in Trig_cfg register is set with configuration bits that configure the AND function between the >=Addr and <=Addr comparisons. In this way, comparator operation detects when operations are in the poll routine.  register field nt_cfg_trig has a new state new st entry code T, and State_cfg_trig has an entry code T. Trigger state T continues as long as trig is active and then returns to the NT state. Each trigger state machine  in Triggering Units , ,  is constructed and\/or configured so that trigger state T in any one of them issues a respective match flag (flag,,_m) to Cross Trace Unit  of . The Cross Trace Unit  has registers as shown in ,  and A, and an example of their configuration for Shared Data Mode is provided in TABLE 5.",{"@attributes":{"id":"p-0201","num":"0200"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 3"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"SHARED DATA MODE, CPU 100 TRIGGER REGISTERS"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"49pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Register Name","Value","Register Name","Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":[{},"Addr Comp 0","0x0","Addr Mask 0","0x0"]},{"entry":[{},"Addr Comp 1","0x0","Addr Mask 1","0x0"]},{"entry":[{},"Addr Comp 2","0x0","Addr Mask 2","0x0"]},{"entry":[{},"Addr Comp 3","0x0","Addr Mask 3","0x0"]},{"entry":[{},"Data Comp 0","0x0","Data Mask 0","0x0"]},{"entry":[{},"Data Comp 1","0x0","Data Mask 1","0x0"]},{"entry":[{},"Data Comp 2","0x0","Data Mask 2","0x0"]},{"entry":[{},"Data Comp 3","0x0","Data Mask 3","0x0"]},{"entry":[{},{},{},"nt_cfg","0x0"]},{"entry":[{},"Trig0_cfg0","0x0",{},"0x0"]},{"entry":[{},"Trig0_cfg1","0x0","State0_cfg",{}]},{"entry":[{},"Trig1_cfg0","0x0",{},"0x0"]},{"entry":[{},"Trig1_cfg1","0x0","State1_cfg",{}]},{"entry":[{},"Trig2_cfg0","0x0",{},"0x0"]},{"entry":[{},"Trig2_cfg1","0x0","State2_cfg",{}]},{"entry":[{},"Trig3_cfg0","0x0",{},"0x0"]},{"entry":[{},"Trig3_cfg1","0x0","State3_cfg"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0202","num":"0201"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 4"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"SHARED DATA MODE, DATA PROCESSOR"},{"entry":"TRIGGER REGISTERS"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"63pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"Register",{}]},{"entry":["Register Name","Value","Name","Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Addr Comp 0","Poll ready start","Addr Mask 0","0x0"]},{"entry":["Addr Comp 1","Poll ready end","Addr Mask 1","0x0"]},{"entry":["Addr Comp 2","0x0","Addr Mask 2","0x0"]},{"entry":["Addr Comp 3","0x0","Addr Mask 3","0x0"]},{"entry":["Data Comp 0","0x0","Data Mask 0","0x0"]},{"entry":["Data Comp 1","0x0","Data Mask 1","0x0"]},{"entry":["Data Comp 2","0x0","Data Mask 2","0x0"]},{"entry":["Data Comp 3","0x0","Data Mask 3","0x0"]},{"entry":[{},{},"nt_cfg","goto T0 when trig0"]},{"entry":["Trig0_cfg","In Poll routine","State0_cfg","stay in T0 if trig0"]},{"entry":[{},"Addr0: >=",{},"else NT"]},{"entry":[{},"\u2002Addr1: <=",{},{}]},{"entry":["Trig0_cfg1",">=Addr0 AND",{},{}]},{"entry":[{},"\u2003\u2003<=Addr1",{},{}]},{"entry":[{},"Ctl_sel: Instr = 1,",{},{}]},{"entry":[{},"\u2002Read = 1.",{},{}]},{"entry":["Trig1_cfg0","0x0","State1_cfg","0x0"]},{"entry":["Trig1_cfg1","0x0",{},{}]},{"entry":["Trig2_cfg0","0x0","State2_cfg","0x0"]},{"entry":["Trig2_cfg1","0x0",{},{}]},{"entry":["Trig3_cfg0","0x0","State3_cfg","0x0"]},{"entry":["Trig3_cfg1","0x0"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"TABLE 5 tabulates an example configuration for Shared Data Mode of the registers in ,  and A for Cross Trace Unit . In  Merge block ., MASK REGS are configured all zeroes except one-bits in each of the respective mask register bits flag,,_msk. In this way, only flag_m from Trigger Unit , flag_m from , and flag_m from  are admitted to the logic of . That logic of  has a configured threshold value Thresh=1. Because Thresh=1, and when any of the data processors - is executing its poll loop waiting for CPU  to load data, the sequencer event Seq_ev from Merge block .goes active. The Sequencer .state machine SEQ SM is already configured with nxt_st entry code S in  register field Seq_cfg_Seq_ev. Accordingly, the state machine SEQ SM goes to state S in response to sequencer event Seq_ev active, i.e., in response to polling by any processor ,  or  as signaled by the match flag,,_m from state machine  state T of any Triggering Unit -. Processor  should have completed the loading and unloading of the requesting processors ping-pong buffer by the time it is ready to process another buffer of data. If the state machine SEQ SM remains at state S for more than a reasonable time for the handshake, e.g. 50 clocks, configured for Seq Ctr ., processor  is not keeping up and Seq Ctr timeout occurs and the state machine SEQ SM transitions to state S to issue signals CAPT\/HOLD. CAPT triggers the Capture Control unit .; and STOP to circular buffers as in  is responsive to HOLD. To accomplish this, the  configuration has nxt_st=S entered (TABLE 5A) in the nxt_st sub-field in Seq_cfg_Seq_Ctr, and the run count 50 entered in the subfield \u201crun.\u201d","Moreover, the trace is configured to operate to respond when two or more of the data processors - are concurrently in their poll loop. A replica of the  circuitry is provided and separately configured with Thresh=2 to generate a sequencer event Seq_ev active. In response to Seq_ev active from  Merge block .,  state machine SEQ SM goes directly from IDLE state S to state S and issues CAPT and HOLD. The configuration for the transition to S is a nxt_st entry signifying S in each of  register fields Seq_cfg_Seq_ev and Seq_cfg_Seq_ev.","The Capture Control unit .has  register values CaptCnt- for Capture Counter CaptCtr .configured to capture 150 cycles of data from each of the processors -, including 100 pre-event cycles and 50 post-event cycles.  registers Offset- specify the 100 pre-event cycles and registers PostCnt- specify the 50 post-event cycles for those processors -. Separately, CaptCnt is set to capture 250 cycles of data from processor , including Offset=150 pre-event cycles and PostCnt=100 post-event cycles. This data provides information whether and why CPU  is unable to keep up with the data rate (Seq_ev) or if two or more the other data processing CPUs , ,  unexpectedly are polling for more data (Seq_ev) and what CPU  was doing about the same time. Note also in TABLE 5 that  register CaptCntrl has all buffer bits Bufx_en active so that data from all processors - is admitted to the Trace Combiner . At the end of the process, state machine SEQ SM .goes back to state S in response to CaptComp from Capture Control .because SEQ SM is configured with nxt_st entry S in register field Seq_cfg_Seq_ev. The CaptCntrl register is configured for Single mode so the data will be captured when a counter underflow event (timeout) occurs and then stop so the failing data can be examined.","A similar example of shared data mode is the reverse situation, where processor  is loading and unloading buffers of data and processors - cannot keep up with the data processing load. For conciseness, this example is not described in detail herein, but can also be traced using the cross trace logic.",{"@attributes":{"id":"p-0207","num":"0206"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 5"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"SHARED DATA MODE, CROSS TRACE REGISTERS"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"63pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"Register",{}]},{"entry":["Register Name","Value","Name","Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Seq Cntrl","Enable","Seq Ctr","\u200250"]},{"entry":["Seq_Ev0","CPU101-match0,","Seq0_Cfg","goto S1 if Seq_Ev0"]},{"entry":[{},"CPU102-match0,",{},"active;"]},{"entry":[{},"CPU103-match0,",{},"Ld load Seq Ctr,"]},{"entry":[{},"Thresh = 1",{},"goto S3 if two procs"]},{"entry":[{},{},{},"in poll routine; goto"]},{"entry":[{},{},{},"S0 if no polling"]},{"entry":["Seq_Ev1","CPU101-match0,","Seq1_Cfg","goto S3 if two or"]},{"entry":[{},"CPU102-match0,",{},"more polling, goto"]},{"entry":[{},"CPU103-match0,",{},"S3 if timeout"]},{"entry":[{},"Thresh = 2",{},"Seq_ct = 1"]},{"entry":["Seq_Ev2","0x0","Seq2_Cfg","0x0"]},{"entry":["Seq_Ev3","0x0","Seq3_Cfg","If CaptComp, goto"]},{"entry":[{},{},{},"S0"]},{"entry":["Capt Cntrl","All \u2003Bufx_en",{},{}]},{"entry":[{},"Enabled,",{},{}]},{"entry":[{},"Mode = Single",{},{}]},{"entry":["Offset 0","150","Capt Cnt 0","250"]},{"entry":["Offset 1","100","Capt Cnt 1","150"]},{"entry":["Offset 2","100","Capt Cnt 2","150"]},{"entry":["Offset 3","100","Capt Cnt 3","150"]},{"entry":["Post Cnt 0","100",{},{}]},{"entry":["Post Cnt 1","\u200250",{},{}]},{"entry":["Post Cnt 2","\u200250",{},{}]},{"entry":["Post Cnt 3","\u200250"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0208","num":"0207"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 5A"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"SEQx_CFG REGISTER CONFIGURATION FOR TABLE 5"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Register|Cur.",{},{},{},{}]},{"entry":["State","Seq_Ev0","Seq_Ev1","Seq_Ctr","Seq_Ev3"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["Seq0_Cfg (S0)","S1","S3","S0","S0"]},{"entry":["Seq1_Cfg (S1)","S1","S3","S3","S0"]},{"entry":["Seq2_Cfg (S2)","S0","S0","S0","S0"]},{"entry":["Seq3_Cfg (S3)","S3","S3","S3","S0"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"In the Event Sampling mode of Cross Trace Trigger Unit , the circular buffers - are configured to store program counter (PC) values from each processor -. The Cross Trace Trigger Unit  stops capture of all the circular buffers - simultaneously and then drains the values from each circular buffer -. Since data is acquired by the circular buffers - concurrently, this provides a snapshot of where each processor - CPU is running at the exact time the capture is stopped. The event which causes this sampling can be an external event or be caused by the data or program activity of one or more of the CPUs. External events desirably initiate capture of processor - CPU activity that occurred immediately before the event. The event can be a CPU accessing shared data structures or executing an interprocessor communication (IPC) code or some other event. For example, when a processor CPU, e.g. , decrements a resource counter, Cross Trace Trigger Unit  captures all that CPU  activity until the resource is claimed by another CPU.","To illustrate the Event Sampling mode of operation, a multi-processor system has CPU  managing a communication peripheral. CPU  receives one or more interrupts, processes each interrupt, and may put a task on the task queue depending on a message from the communication peripheral. Suppose one of the other processors, such as CPU , , or  must start executing the task before the next interrupt occurs. Further suppose CPU  code has been previously traced and debugged, but get-task execution by processors - is problematic. Once the task is put on the task queue, the Event Sampling mode of Cross Trace Trigger Unit  records the activity of all the other processors - to determine the task response time and trace their operations to verify or diagnose them.","The trigger registers of ,  and  in Event Sampling Mode for CPU  are shown in TABLE 6. A trigger event trig is caused by the entry into the Interrupt Service Routine (ISR), and another trigger event trig is caused if the task queue gets written by CPU . These trigger events are established in Triggering Unit . There, Registers Addr Comp ,  of  are pre-loaded respectively with the start address and the stop address of interrupt service routine ISR. Register Trig_cfg of  is loaded in the addr field with value 011 (=,>), and loaded in the addr field with value 110 (<,=). Register Trig_cfg is loaded with bits in the AND plane field to enable addr and addr comparators and in the OR plane field to enable the first AND plane. The ctl_sel field is enabled to select instruction instr and read operations. In this way, the  address comparator detects ISR execution when CPU  asserts an instruction read at an actual address on a bus in the address range defined by the Addr Comp , registers and Register Trig_cfgx such that ISR start address <=Asserted Address <=ISR stop address.","Analogously, address comparison detects a trig event wherein write-to-task-queue software code asserts a data write to a task queue address in a task queue address range specified or configured into registers Addr Comp ,; and registers Trig_cfg and Trig_cfg  are configured to define the trig event. The  configuration registers are configured so that the Triggering Unit  state machine  of  looks for a two-step sequence of processor  operation having 1) ISR execution (trig, NT-to-T transition) followed by 2) data write by processor  to task queue (trig, T-to-T transition). When such two-step sequence is detected by Triggering Unit  state machine  reaching state T, the state machine in state T outputs a match flag value flag_m=1 to Cross Trace Trigger Unit  of .",{"@attributes":{"id":"p-0213","num":"0212"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 6"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"EVENT SAMPLING MODE, INTERRUPT"},{"entry":"PROCESSOR TRIGGER REGISTERS"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"63pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"Register",{}]},{"entry":["Register Name","Value","Name","Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Addr Comp 0","ISR start","Addr Mask 0","0x0"]},{"entry":["Addr Comp 1","ISR stop","Addr Mask 1","0x0"]},{"entry":["Addr Comp 2","Task queue start","Addr Mask 2","0x0"]},{"entry":["Addr Comp 3","Task queue stop","Addr Mask 3","0x0"]},{"entry":["Data Comp 0","0x0","Data Mask 0","0x0"]},{"entry":["Data Comp 1","0x0","Data Mask 1","0x0"]},{"entry":["Data Comp 2","0x0","Data Mask 2","0x0"]},{"entry":["Data Comp 3","0x0","Data Mask 3","0x0"]},{"entry":[{},{},"nt_cfg","goto T0 when trig0"]},{"entry":["Trig0_cfg0","ISR execution","State0_cfg","goto T2 if trig1 else"]},{"entry":[{},"Addr0: >=,",{},"stay in T0 if trig0"]},{"entry":[{},"Addr1: <=",{},"else NT"]},{"entry":["Trig0_cfg1",">=Addr0 AND",{},{}]},{"entry":[{},"<=Addr1",{},{}]},{"entry":[{},"Ctl_sel: Instr=1,",{},{}]},{"entry":[{},"Read=1",{},{}]},{"entry":["Trig1_cfg0","Write to task queue:","State1_cfg","goto NT"]},{"entry":[{},"Addr2: >=,",{},{}]},{"entry":[{},"\u2003\u2003\u2003Addr3: <=",{},{}]},{"entry":["Trig1_cfg1",">=Addr2 AND",{},{}]},{"entry":[{},"\u2003\u2003\u2003<= Addr3",{},{}]},{"entry":[{},"Ctl_sel: Data=1,",{},{}]},{"entry":[{},"Write=1",{},{}]},{"entry":["Trig2_cfg0","0x0","State2_cfg","0x0"]},{"entry":["Trig2_cfg1","0x0",{},{}]},{"entry":["Trig3_cfg0","0x0","State3_cfg","0x0"]},{"entry":["Trig3_cfg1","0x0"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"The trigger registers for the task processors - are shown in TABLE 7. Execution by any of the processors in the get_task routine causes the trigger state of the corresponding Trigger Unit state machine  to go from No-Trigger state NT to trigger state T in . Each of the Triggering Units - is configured as shown in TABLE 7.  registers Addr Comp, for monitoring each processor , ,  are configured as in TABLE 7. Trigger trig for any of these processors - occurs when a read address, in the range of Addr Comp, for the get_task routine, is actually asserted on an address bus by an instruction read by any one such processor -. If trig occurs, a respective Trigger Unit state machine  goes from state NT to state T and issues a match flag value flagX_m= as an active input to Cross Trace Trigger Unit  of .",{"@attributes":{"id":"p-0215","num":"0214"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 7"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"EVENT SAMPLING MODE, TASK PROCESSOR"},{"entry":"TRIGGER REGISTERS"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"63pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Register Name","Value","Register Name","Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Addr Comp 0","get_task start","Addr Mask 0","0x0"]},{"entry":["Addr Comp 1","get_task stop","Addr Mask 1","0x0"]},{"entry":["Addr Comp 2","0x0","Addr Mask 2","0x0"]},{"entry":["Addr Comp 3","0x0","Addr Mask 3","0x0"]},{"entry":["Data Comp 0","0x0","Data Mask 0","0x0"]},{"entry":["Data Comp 1","0x0","Data Mask 1","0x0"]},{"entry":["Data Comp 2","0x0","Data Mask 2","0x0"]},{"entry":["Data Comp 3","0x0","Data Mask 3","0x0"]},{"entry":[{},{},"nt_cfg","goto T0 when trig0"]},{"entry":["Trig0_cfg0","get_task","State0_cfg","stay in T0 if trig0"]},{"entry":[{},"execution",{},"else NT"]},{"entry":[{},"Addr0: >=",{},{}]},{"entry":[{},"\u2009Addr1: <=",{},{}]},{"entry":["Trig0_cfg1",">=Addr0 AND",{},{}]},{"entry":[{},"\u2003\u2003\u2003<=Addr1",{},{}]},{"entry":[{},"Ctl_sel: Instr=1,",{},{}]},{"entry":[{},"\u2002Read = 1.",{},{}]},{"entry":["Trig1_cfg0","0x0","State1_cfg","0x0"]},{"entry":["Trig1_cfg1","0x0",{},{}]},{"entry":["Trig2_cfg0","0x0","State2_cfg","0x0"]},{"entry":["Trig2_cfg1","0x0",{},{}]},{"entry":["Trig3_cfg0","0x0","State3_cfg","0x0"]},{"entry":["Trig3_cfg1","0x0"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"The Cross Trace Trigger Unit  registers for this example of an Event Sampling Mode are shown in TABLE 8. Only trace data from CPUs - are of interest because the example presumes processor  manager code is already debugged and so no trace data from CPU  is captured.  samples of each of the task processors - is captured every time a task gets put on the task queue by manager processor  in response to a peripheral message.","In TABLE 8, Merge block .output Seq_ev is activated in  when Triggering unit  issues flag_m=1, indicating a CPU  task queue write that followed an ISR execution in CPU . To support the merge operation, MASK REGS has a one-bit set only for bit position flag_msk=1 and Thresh=1 in . Upon receipt of active match flag_m=1 merge block .outputs sequence event Seq_ev active to Sequencer .. Sequence Count SeqCnt is set to zero so that Sequence counter Seq Ctr .immediately times out upon receipt of Seq_ev active. Sequencer .state machine SEQ SM is programmed to thereupon go from state S to capture state S and Capture signal CAPT commences immediately. Registers PostCnt,, are each set to 100 cycles as are registers CaptCnt,, so as to deliver 100 cycles of information on each processor - only. The CaptCntrl register is set for continuous mode, so after each capture sequence, the logic gets re-armed. This enables response time to putting a task on the queue to be profiled. The field for  bufctl, bufctl and bufctl is set to 1 to enable trace capture of CPU-. The field for bufctl is set to 0, to prevent trace capture of CPU.",{"@attributes":{"id":"p-0218","num":"0217"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 8"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"EVENT SAMPLING MODE, CROSS TRACE REGISTERS"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"Register",{}]},{"entry":["Register Name","Value","Name","Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Seq Cntrl","Enable","Seq Ctr","0"]},{"entry":["Seq_Ev0","CPU100-match2,","Seq0_Cfg","goto S3 if task"]},{"entry":[{},"Thresh=1",{},"queue written"]},{"entry":["Seq_Ev1","0x0","Seq1_Cfg","0x0"]},{"entry":["Seq_Ev2","0x0","Seq2_Cfg","0x0"]},{"entry":["Seq_Ev3","0x0","Seq3_Cfg","0x0"]},{"entry":["Capt Cntrl","Enable Buf1-3_en,",{},{}]},{"entry":[{},"Mode=Continuous",{},{}]},{"entry":["Offset 0","0x0","Capt Cnt 0","0x0"]},{"entry":["Offset 1","0","Capt Cnt 1","100"]},{"entry":["Offset 2","0","Capt Cnt 2","100"]},{"entry":["Offset 3","0","Capt Cnt 3","100"]},{"entry":["Post Cnt 0","0x0",{},{}]},{"entry":["Post Cnt 1","100",{},{}]},{"entry":["Post Cnt 2","100",{},{}]},{"entry":["Post Cnt 3","100"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"TABLE 8A supports an additional hypothetical trace investigation of the operation of the processors. Merge block .output Seq_ev is activated when flag_m from Triggering Unit  goes active for processor . Separate output Seq_ev is activated when at least one of Triggering Units - issues an active match flag\u2014flag,,_m\u2014for at least one processor , , . Logic as shown in  has a single mask bit flag_msk set to one (1) in associated seq_ev MASK REGS for that logic. Separately for seq_ev, a replica of the logic of  has replica MASK REGS with three one-bits set in the flag,,_msk positions and threshold Thresh=1 in TABLE 8A for the replica logic. SeqCnt is set to 50 cycles. In this way, an event or event sequence is collectively defined by 1) CPU  Seq_ev and SeqCtr timeout OR 2) a sequence including event Seq_ev followed by Seq_ev active. In TABLES 8A and 8B, such event or event sequence causes Sequencer state machine SEQ SM to go to a state S and produce a Capture signal CAPT active. Configuration of each  Offset,, is 50 cycles in TABLE 8A. This Offset desirably delivers trace data from circular buffers - about processors - activity from the moment of sequence event Seq_ev even though SeqCtr timeout 50 cycles later is what activates Capture signal CAPT. Configuration of PostCnt,, is 100 cycles in TABLE 8A to capture get_task execution, if it occurs, in processor , , and\/or . The CaptCntrl mode is set to single, so that when a failure to respond in time occurs, the data is captured and acquisition stops.",{"@attributes":{"id":"p-0220","num":"0219"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 8A"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"EVENT SAMPLING MODE, CROSS TRACE REGISTERS"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"63pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Register",{},{},{}]},{"entry":["Name","Value","Register Name","Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Seq Cntrl","Enable","Seq Ctr","50"]},{"entry":["Seq_Ev0","CPU 100 event","Seq0_Cfg","goto S1 if Seq_ev0"]},{"entry":[{},"Flag0_m2, Thresh=1",{},"(task queue written)"]},{"entry":["Seq_Ev1","CPUs 101-103, any","Seq1_Cfg","go from S1 to S3 if"]},{"entry":[{},"flag1,2,3_m0,",{},"Seq_ev1 or if"]},{"entry":[{},"Thresh=1",{},"Seq_tc=1 (timeout)."]},{"entry":["Seq_Ev2","0x0","Seq2_Cfg","0x0"]},{"entry":["Seq_Ev3","0x0","Seq3_Cfg","0x0"]},{"entry":["Capt Cntrl","Enable Buf1-3_en",{},{}]},{"entry":[{},"Mode=Single",{},{}]},{"entry":["Offset 0","0x0","Capt Cnt 0","0x0"]},{"entry":["Offset 1","50","Capt Cnt 1","150"]},{"entry":["Offset 2","50","Capt Cnt 2","150"]},{"entry":["Offset 3","50","Capt Cnt 3","150"]},{"entry":["Post Cnt 0","0x0",{},{}]},{"entry":["Post Cnt 1","100",{},{}]},{"entry":["Post Cnt 2","100",{},{}]},{"entry":["Post Cnt 3","100"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0221","num":"0220"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 8B"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"SEQx_CFG REGISTER CONFIGURATION"},{"entry":"FOR TABLE 8A"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"56pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Register|Cur. State","Seq_Ev0","Seq_Ev1","Seq_Ctr"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":[{},"Seq0_Cfg (S0)","S1","S0","S0"]},{"entry":[{},"Seq1_Cfg (S1)","S1","S3","S3"]},{"entry":[{},"Seq2_Cfg (S2)","S0","S0","S0"]},{"entry":[{},"Seq3_Cfg (S3)","S3","S3","S3"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"Turning to the Simultaneous Activity mode of Cross Trace Trigger Unit , an example is illustrated wherein the Cross Trace Trigger Unit  monitors circumstances in which multiple processors among the processors - are executing communication and synchronization code. Such circumstances then cause the contents in the applicable circular buffers - for the respective processors executing such code to be captured by Cross Trace Trigger Unit  when the Simultaneous Activity mode is active. Then trace data from those circular buffers is exported using Trace Combiner , On Chip Trace Buffer  and Trace Export Unit  to the Trace Pins . This Simultaneous Activity mode is useful to locate deadlock code, for instance, wherein multiple processors are trying to access the same resources such as a memory space or peripheral buffer.","To illustrate the Simultaneous Activity mode, suppose a four-processor system with shared resources executes some tasks that require multiple resources. Assume that a Task A and Task B run on separate processors. Suppose further that semaphores are used to keep track of requests and ownership of the shared resources. If Task A needs Resources R and R, and Task B also needs Resources R and R, the situation can arise where each Task owns one of the Resources it needs but neither Task can run until it acquires the other Resource as well. Notice that the word \u201csimultaneous\u201d in connection with this Simultaneous Activity mode has an approximate meaning relative to deadlock since Resources R might be granted to one processor at a somewhat different time than when Resources R are granted to the other processor, and yet both processors would thereafter be in deadlock at the same time since they both need R and R.","The , ,  trigger registers are configured for each Triggering Unit - to monitor all of the processors -. TABLE 9 shows the register configuration for any one Triggering Unit . It is assumed that Task A and Task B can run on any pair of the processors -. A resource is claimed by reading a semaphore or hardware register and getting an available status, in this case 0, then writing a non-zero value to the same location. For hardware mechanisms, this may be a single bit, for a semaphore, it could be a bit or the processor ID. A resource is released by writing a 0 to the semaphore, indicating it is now available.","A trigger event trig (resource busy) is caused by a processor requesting an already-busy shared resource R or R, as indicated by a read operation, an asserted address of the appropriate semaphore configured in registers Addr Comp or , along with a non-zero data value (i.e., busy). Trigger event trig (resource granted) is caused by a processor being granted a shared resource R or R, as indicated by a write operation, an asserted address of the appropriate semaphore configured in registers Addr Comp or , along with a non-zero data value. Trigger event trig (resource released) is caused by a processor releasing a shared resource R or R, as indicated by a write operation, an asserted address of the appropriate semaphore configured in registers Addr Comp or , along with a zero data value. See TABLE 9 for configuration of each of these trigger events trig- in registers Trig-_cfg,.","TABLE 9A summarizes the configuration and\/or structure of state machine  and its trigger-induced transitions that are described in the next several paragraphs.",{"@attributes":{"id":"p-0227","num":"0226"},"figref":["FIG. 8A","FIG. 8"]},"In , State T in trigger state machine .is entered by a transition from state NT in Triggering Unit when get_resource code is executed by processor and thereby requests Resource R or R. If the resource is busy (non-zero data value), trig is asserted and the state machine  transitions to the state T (resource busy) and match flagX_m is output active from Triggering Unit . (This state machine  transition is configured by a  new_st entry code T in register field nt_cfg_trig for each Trigger Unit .).","In , State T (one resource granted) is entered from state T if and when the requested resource is granted to processor , whereupon trig is asserted and a match flagX_m for processor is output from Triggering Unit while match flagX_m is reset inactive. (The  register field State_cfg_trig is configured for that T-to-T transition with entry code T.) State T is alternatively enterable directly from NT state. If the requested resource is granted to processor directly upon request, trig is asserted and an NT-to-T transition occurs.","Further in , State T (both resources granted) is entered from state T if and when another resource request is granted to processor , whereupon trig is asserted a second time and a match flagX_m for processor is output from Triggering Unit while match flagX_m is reset inactive. (The  register field State_cfg_trig is configured for that T-to-T transition with entry code T.)","State T (one resource granted) is entered from state T if and when a resource is released by processor , whereupon trig is asserted and a match flagX_m for processor is output from Triggering Unit while match flagX_m is reset inactive. (The  register field State_cfg_trig is configured for that T-to-T transition with entry code T.)","In , State NT (idle) is entered from state T if and when a resource is released by processor , whereupon trig is asserted and match flagX_m for processor is reset inactive from Triggering Unit . (The  register field State_cfg trig is configured for that T-to-NT transition with entry code NT.)",{"@attributes":{"id":"p-0233","num":"0232"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 9"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"SIMULTANEOUS ACTIVITY MODE, TRIGGER REGISTERS"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"Register",{}]},{"entry":["Register Name","Value","Name","Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Addr Comp 0","Reg R1","Addr Mask 0","0x0"]},{"entry":["Addr Comp 1","Reg R2","Addr Mask 1","0x0"]},{"entry":["Addr Comp 2","0x0","Addr Mask 2","0x0"]},{"entry":["Addr Comp 3","0x0","Addr Mask 3","0x0"]},{"entry":["Data Comp 0","0x0 (it indicates Free)","Data Mask 0","Resource Claim"]},{"entry":[{},{},{},"Field"]},{"entry":["Data Comp 1","0x0","Data Mask 1","0x0"]},{"entry":["Data Comp 2","0x0","Data Mask 2","0x0"]},{"entry":["Data Comp 3","0x0","Data Mask 3","0x0"]},{"entry":[{},{},"nt_cfg (Idle)","goto T0 if trig0"]},{"entry":[{},{},{},"else T1 if trig 1"]},{"entry":["Trig0_cfg0","Resource Busy","State0_cfg","goto T1 if trig 1"]},{"entry":[{},"Addr0: =,","(waiting)","else stay in T0"]},{"entry":[{},"\u2009Addr1: =,",{},{}]},{"entry":[{},"Data: < >",{},{}]},{"entry":["Trig0_cfg1","(=Addr0 OR =Addr1)",{},{}]},{"entry":[{},"AND Data <> 0",{},{}]},{"entry":[{},"Ctl_sel: data=1,",{},{}]},{"entry":[{},"\u2003\u2003read=1",{},{}]},{"entry":["Trig1_cfg0","Resource Granted","State1_cfg","goto T2 if trig1"]},{"entry":[{},"Addr0: =,","(one owned)","else NT if trig 2"]},{"entry":[{},"\u2009Addr1: =,",{},"else stay in T1"]},{"entry":[{},"Data: < >",{},{}]},{"entry":["Trig1_cfg1","(=Addr0 OR =Addr1)",{},{}]},{"entry":[{},"AND Data <> 0",{},{}]},{"entry":[{},"Ctl_sel: data=1,",{},{}]},{"entry":[{},"\u2003\u2003\u2003write=1",{},{}]},{"entry":["Trig2_cfg0","Resource Released","State2_cfg","goto T1 if Trig2"]},{"entry":[{},"Addr0: =,","(both owned)","else stay in T2"]},{"entry":[{},"\u2009Addr1: =,",{},{}]},{"entry":[{},"Data: =",{},{}]},{"entry":["Trig2_cfg1","(=Addr0 OR =Addr1)",{},{}]},{"entry":[{},"AND Data=0",{},{}]},{"entry":[{},"Ctl_sel: data=1,",{},{}]},{"entry":[{},"\u2003\u2003\u2003write=1",{},{}]},{"entry":["Trig3_cfg0","0x0","State3_cfg",{}]},{"entry":["Trig3_cfg1","0x0"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0234","num":"0233"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 9A"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"STATEx_CFG REGISTER CONFIGURATION"},{"entry":"FOR TABLE 9"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"63pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Register|Cur.",{},{},{}]},{"entry":[{},"State","Trig0","Trig1","Trig2"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":[{},"nt_cfg (NT)","T0","T1","NT"]},{"entry":[{},"State0_Cfg (T0)","T0","T1","T0"]},{"entry":[{},"State1_Cfg (T1)","T1","T2","NT"]},{"entry":[{},"State2_Cfg (T2)","T2","T2","T1"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"A deadlock occurs if two or more processors are in state T or T for more than a predetermined amount of time. The deadlock condition is undesirable and should be traced, diagnosed and corrected. To accomplish this, Cross Trace Trigger Unit  is configured to detect and capture an occurrence indicative of such deadlock when one processor is represented by its Triggering Unit state machine  in a state T or T and another processor is represented by its separate Triggering Unit state machine  in a state T or T. Cross tracing is used because such a deadlock event involves two different processors and , and responding to their respective Triggering Units and is performed herein by Cross Trace Trigger Unit  and activates seq_en active to Seq Ctr .in .","The  or B cross trace registers for Cross Trace Trigger Unit  are configured as shown in TABLE 10. As an introductory matter, if any processor Triggering Unit is in  trigger state machine  state T (waiting for R or R), a match flagX_m is issued. If any processor Triggering Unit is in  trigger state machine  state T (owns R or R), a match flagX_m is issued.","In , Merge block .MASK REGS for sequencer event Seq_ev are configured with ones for all of the flags except flag_.msk, flag.msk, flag.msk and flag.msk. Threshold is set to unity (Thresh=1) in a Seq_ev merge logic of , so that if at least one Triggering Unit issues a match flag flagX_m, flagX_m or flagX_m, then Merge block .thus issues a sequencer event Seq_ev.","A simplified version of  showing relevant states for this example is shown in . Sequencer state machine SEQ SM of FIG. \/D is configured to respond to sequencer event Seq_ev by going out of IDLE state S to SEQ SM state S. State S issues load Ld=1 to register field Seq_cfg_Seq_Ctr of . In TABLE 10, the masking by Merge Unit .using the thus-configured MASK REGS section for Seq_ev only admits match flags flag,,,_m, m and m, which relate to processor CPUs , , ,  respectively. Thus TABLE 10 uses nomenclature CPU-match-, CPU-match-, CPU-match-, CPU-match- to refer to the conditions that said match flags represent.","In , Merge block .MASK REGS for sequencer event Seq_ev are configured with ones for all of the flags except flag_.msk, flag.msk, flag.msk and flag.msk Threshold is set to two (Thresh=2) in a Seq_ev merge logic of , so that if two or more Triggering Unit issues a match flag flagX_m, flagX_m or flagX_m, then Merge block .thus issues a sequencer event Seq_ev. Sequencer state machine SEQ SM of FIG. \/D is configured to respond to sequencer event Seq_ev by going out of state S to SEQ SM state S. State S issues Run=1 to register field Seq_cfg_Seq_Ctr of . State S represents two or more processors using or requesting Resources R and R. If this state persists longer than the value loaded into the SeqCtr takes to count down to zero, it may indicate a deadlock. The nxt_st field of the Seq_Ctr field is set to S, so that if the SeqCtr counts down to zero, sequencer state machine SEQ SM of FIG. \/D is configured to respond by going out of state S to SEQ SM state S.","A deadlock occurs if one processor is in state T or T and another processor is currently in T or T for a period of time longer than it should take to perform the task using resources R and R. The , A cross trace registers configurations are shown in TABLE 10. If any processor is in state T, T or T, goto state S of SEQ SM as above. If a second processor is in state T, T, or T, goto state S of SEQ SM as above and start the timeout counter. If one of the processors releases its resource and returns to state NT, then the SEQ_SM will goto state S and the SeqCtr will be reloaded. If all processors release resources R and R, SEQ_SM will goto state S. If the SeqCtr expires while in state S, then deadlock exists, and configuration in TABLES 10 and 10A has SEQ SM goto state S and capture the data. Sequencer state machine SEQ SM is configured by  registers Seqx_cfg to respond to such deadlock by going from such SEQ SM states, under conditions as just described, to state S and capturing trace data for subsequent diagnostic analysis by activating outputs CAPT and HOLD. The trace data from Circular Buffers - covers a configured time window in  and TABLE 10 of 100 clock cycles (CaptCnt-), including 50 cycles (Offset-) previous to the deadlock event and 50 cycles (PostCnt-) after the deadlock event.","The field of all the bufctlx words in  is set to 0. The .act, .act and .act fields of all the bufctlx words are set to 1 and the .act field is set to 0. This enables dynamic trace capture for only those particular processors among processors - that were accessing the shared resources.","The TABLES and Figures as described herein define the hardware for implementation straightforwardly.",{"@attributes":{"id":"p-0243","num":"0242"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 10"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"SIMULTANEOUS ACTIVITY MODE,"},{"entry":"CROSS TRACE REGISTERS"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Register",{},{},{}]},{"entry":["Name","Value","Register Name","Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Seq Cntrl","Enable","Seq Ctr","200"]},{"entry":["Seq_Ev0","CPU100-match0-2,","Seq0_Cfg","if \u20031 \u2003match"]},{"entry":[{},"CPU101-match0-2,",{},"(Seq_Ev0), goto S1."]},{"entry":[{},"CPU102-match0-2,",{},{}]},{"entry":[{},"CPU103-match0-2,",{},{}]},{"entry":[{},"Thresh=1",{},{}]},{"entry":["Seq_Ev1","CPU100-match0-2,","Seq1_Cfg","If >= 2 matches,"]},{"entry":[{},"CPU101-match0-2,",{},"(seq_ev1), goto S2."]},{"entry":[{},"CPU102-match0-2,",{},"If seq_ev0 deasserted"]},{"entry":[{},"CPU103-match0-2,",{},"goto S0."]},{"entry":[{},"Thresh=2",{},"Load SeqCtr 320.c"]},{"entry":["Seq_Ev2","\u2009Enable","Seq2_Cfg","If Seq_ev2, goto S3"]},{"entry":[{},{},{},"else \u2003Seq_ev1"]},{"entry":[{},{},{},"deasserted goto S1."]},{"entry":[{},{},{},"Enable SeqCtr 320.c"]},{"entry":["Seq_Ev3","0x0","Seq3_Cfg","goto S0"]},{"entry":["Capt Cntrl","Enable All",{},{}]},{"entry":["Offset 0","50","Capt Cnt 0","100"]},{"entry":["Offset 1","50","Capt Cnt 1","100"]},{"entry":["Offset 2","50","Capt Cnt 2","100"]},{"entry":["Offset 3","50","Capt Cnt 3","100"]},{"entry":["Post Cnt 0","50",{},{}]},{"entry":["Post Cnt 1","50",{},{}]},{"entry":["Post Cnt 2","50",{},{}]},{"entry":["Post Cnt 3","50"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"Still other embodiments for Simultaneous Activity mode detect deadlock or other interprocessor conditions by configuring a different set of sequencer events.","In , a multi-processor embodiment has the same one SMP HLOS (Symmetric Multi-Processing High Level Operating System) running on all processor -CPU cores indexed by index X, e.g. with four processors -. Each CPU has a hardware-supported hypervisor to share its bandwidth between the SMP HLOS and another operational category or world in the following manner. CPU is shared between SMP HLOS and Secure Environment using a security zone mechanism. CPU is shared between SMP HLOS and Modem RTOS (Real Time Operating System) using a security zone mechanism plus secure state machine SSM  () protected hardware hypervisor structuring. For background on such structuring, see published U.S. patent application 20070226795 (TI-61985) \u201cVirtual Cores and Hardware-Supported Hypervisor Integrated Circuits, Systems, Methods and Processes of Manufacture,\u201d which is hereby incorporated herein by reference. CPU is shared between SMP HLOS and Public HLOS using security zone mechanism plus SSM hardware hypervisor structuring. CPU is shared between SMP HLOS and drivers such as non-GPL drivers using security zone mechanism plus SSM hardware hypervisor structuring.","In , the symmetric multiprocessing (SMP) core(s) have one of the cores - that is called the SMP core and designated processor  or CPU . A hardware (HW) supported secure hypervisor runs at least on the SMP core . Linux SMP HLOS is symmetric across all cores and is chosen as the master HLOS in some embodiments. A secure environment is provided by use of SSM  of . The HW hypervisor mechanism provides standalone CPU virtualization in order to run a single processor based OS such as WinCE or Nucleus. The hypervisor code runs in Monitor Mode, and virtual worlds are switched from Monitor Mode. The hypervisor-mediated virtual worlds or categories are scheduled by timers in synchronous time sharing fashion. The HW secure hypervisor mechanism in some embodiments is asymmetric relative to the processor cores. In some other embodiments, a pseudo-symmetric architecture has virtual processors wherein any of the virtual processors can do SMP (symmetric multi-processing) while using a control core plus a further number n\u22121 (one less than n) CPU cores, also called processor cores herein. In other words, if a complete cluster has four (4) cores or processors, then the pseudo-symmetric virtual core mechanism uses an SMP cluster of 3 CPUs as processor cores with some operations conducted by the additional control core CPU .","The hardware hypervisor provides real time interrupt firing capability for virtual worlds to ensure RTOS capability. Any OS running in a virtual world is able to call Secure services even if the secure environment is on CPU  and the virtual world is running on another CPU -. Any security mechanism and any hypervisor mechanism are invisible to the SMP HLOS. A minor FIQ (Fast interrupt request) latency introduction has negligible effect on the SMP HLOS performance.","Some trace embodiments as described herein are implemented in system-on-chip hardware of ,  and  and the other Figures, or otherwise appropriately to form more comprehensive system-on-chip embodiments for larger device and system embodiments, as described next. In , a system embodiment  improved as in the other Figures has one or more microprocessor unit MPU subsystem(s) and an IVA imaging, video and audio processing subsystem , and DMA (Direct Memory Access) subsystems .. Each MPU subsystem suitably has one or more processors with CPUs such as RISC or CISC processors , and having superscalar processor pipeline(s) with L1 and L2 caches. IVA subsystem  has one or more programmable digital signal processors (DSPs), such as processors having single cycle multiply-accumulates for image processing, video processing, and audio processing. Various processors -and trace blocks - as described in the other Figures herein are suitably distributed, situated and\/or allocated among some or all of the various processors in system  of .","IVA  provides multi-standard codecs for high speed and low real-estate impact (AVS, H.264, H.263, MPEG4, WMV9, RealVideo\u00ae), and MPEG4, for some examples. Also integrated are a 2D\/3D graphics engine, a Mobile DDR Interface, and numerous integrated peripherals as selected for a particular system solution. The IVA subsystem  has L1 and L2 caches, RAM and ROM, and hardware accelerators as desired such as for motion estimation, variable length codec, and other processing. DMA (direct memory access) performs target accesses via target firewalls .and .of  connected on interconnects . A target is a circuit block targeted or accessed by another circuit block operating as an initiator. In order to perform such accesses the DMA channels in DMA subsystems .are programmed. Each DMA channel specifies the source location of the Data to be transferred from an initiator and the destination location of the Data for a target. Some Initiators are MPU , DSP DMA ., System SDMA ., Universal Serial Bus USB HS, virtual processor data read\/write and instruction access, virtual system direct memory access, display ., DSP MMU (memory management unit), and camera .. Another initiator is a secure debug access port to emulation block EMU, see also .","In , data exchange between a peripheral subsystem and a memory subsystem and general system transactions from memory to memory are handled by the System SDMA .. Data exchanges within a DSP subsystem . are handled by the DSP DMA .. Data exchange to store camera capture is handled using a Camera DMA . in camera subsystem CAM .. The CAM subsystem . suitably handles one or two camera inputs of either serial or parallel data transfer types, and provides image capture hardware image pipeline and preview. Data exchange to refresh a display is handled in a display subsystem . using a DISP (display) DMA .. This subsystem ., for instance, includes a dual output three layer display processor for 1\u00d7 Graphics and 2\u00d7 Video, temporal dithering (turning pixels on and off to produce grays or intermediate colors) and SDTV to QCIF video format and translation between other video format pairs. The Display block . feeds an LCD (liquid crystal display), plasma display, DLP\u2122 display panel or DLP\u2122 projector system, using either a serial or parallel interface. Also television output TV and Amp provide CVBS or S-Video output and other television output types.","In , a hardware security architecture including SSM  propagates Mreqxxx qualifiers on the interconnect  and . The MPU  issues bus transactions and sets some qualifiers on Interconnect . SSM  also provides one or more MreqSystem qualifiers. The bus transactions propagate through the L4 Interconnect  and line  then reach a DMA Access Properties Firewall .. Transactions are coupled to a DMA engine .in each subsystem .which supplies a subsystem-specific interrupt to the Interrupt Handler . Interrupt Handler  is also fed one or more interrupts from Secure State Machine SSM  that performs security protection functions. Interrupt Handler  outputs interrupts for each processor -, such as MPU . In , firewall protection by firewalls .is provided for various system blocks ., such as GPMC (General Purpose Memory Controller) to Flash memory ., ROM ., on-chip RAM ., Video Codec ., WCDMA\/HSDPA ., device-to-device SAD2D . to Modem chip , and a DSP . and DSP DMA .. A System Memory Interface SMS with SMS Firewall  is coupled to SDRC . (External Memory Interface EMIF with SDRAM Refresh Controller) and to system SDRAM  (Synchronous Dynamic Random Access Memory).","In , interconnect  is also coupled to Control Module  and cryptographic accelerators block  and PRCM . Power, Reset and Clock Manager PCRM  is coupled via L4 interconnect  to Power IC circuitry in chip , which supplies controllable supply voltages VDD, VDD, etc. PRCM  is coupled to L4 Interconnect  and coupled to Control Module . PRCM  is coupled to a DMA Firewall . to receive a Security Violation signal, if a security violation occurs, and to respond with a Cold or Warm Reset output. Also PRCM  is coupled to the SSM .","In , some embodiments have symmetric multiprocessing (SMP) core(s) such as RISC processor cores in the MPU subsystem. One of the cores is called the SMP core. A hardware (HW) supported secure hypervisor runs at least on the SMP core. Linux SMP HLOS (high-level operating system) is symmetric across all cores and is chosen as the master HLOS in some embodiments.","The system embodiments of and for  are provided in a communications system or other multiprocessor system and implemented as various embodiments in any one, some or all of cellular mobile telephone and data handsets, a cellular (telephony and data) base station, a WLAN AP (wireless local area network access point, IEEE 802.11 or otherwise), a Voice over WLAN Gateway with user video\/voice over packet telephone, and a video\/voice enabled personal computer (PC) with another user video\/voice over packet telephone, that communicate with each other. A camera CAM provides video pickup for a cell phone or other device to send over the internet to another cell phone, personal digital assistant\/personal entertainment unit, gateway and\/or set top box STB with television TV. Video storage and other storage, such as hard drive, flash drive, high density memory, and\/or compact disk (CD) is provided for digital video recording (DVR) embodiments such as for delayed reproduction, transcoding, and retransmission of video to other handsets and other destinations.","In , a Modem integrated circuit (IC)  supports and provides wireless interfaces for any one or more of GSM, GPRS, EDGE, UMTS, and OFDMA\/MIMO embodiments. Codecs for any or all of CDMA (Code Division Multiple Access), CDMA2000, and\/or WCDMA (wideband CDMA or UMTS) wireless are provided, suitably with HSDPA\/HSUPA (High Speed Downlink Packet Access, High Speed Uplink Packet Access) (or 1\u00d7EV-DV, 1\u00d7EV-DO or 3\u00d7EV-DV) data feature via an analog baseband chip and RF GSM\/CDMA chip to wireless antenna(s). Replication of blocks and antennas is provided in a cost-efficient manner to support MIMO OFDMA of some embodiments. An audio block in an Analog\/Power IC  has audio I\/O (input\/output) circuits to a speaker, a microphone, and\/or headphones as illustrated in . A touch screen interface is coupled to a touch screen XY off-chip in some embodiments for display and control. A battery provides power to mobile embodiments of the system and battery data on suitably provided lines from the battery pack.","DLP\u2122 display technology from Texas Instruments Incorporated is coupled to one or more imaging\/video interfaces. A transparent organic semiconductor display is provided on one or more windows of a vehicle and wirelessly or wireline-coupled to the video feed. WLAN and\/or WiMax integrated circuit MAC (media access controller), PHY (physical layer) and AFE (analog front end) support streaming video. A MIMO UWB (ultra wideband) MAC\/PHY supports OFDM in 3-10 GHz UWB bands for communications in some embodiments. A digital video integrated circuit provides television antenna tuning, antenna selection, filtering, RF input stage for recovering video\/audio and controls from a DVB station.","In , processors -are supported by trace\/debug and other blocks of  and the other Figures herein. A block called a Generalized Interrupt Handler GIC  is provided to handle interrupts that can be selectively masked and routed to respective GIC Bus - ports corresponding to each of the CPU cores CPU -. The Interrupt architecture, for example, optionally has SFIQ input. Some ordinary interrupts IRQ are reserved for SMP HLOS in some embodiments. Public FIQ can be used with SMP HLOS of Public Non-virtual mode. Other modes (Public Virtual, Secure Non-virtual and Secure Virtual) use exclusively Secure FIQ to preempt the SMP HLOS. Some embodiment do not differentiate interrupt lines activated by and assigned to Virtual modes from interrupt lines activated by and assigned by Non-virtual modes at GIC level. Each interrupt line from many possible interrupt lines to GIC interrupt handler  is tagged to the Public Normal, Public Virtual, Secure Normal or Secure Virtual mode. A Security zone mechanism (SZ) traps any FIQ in Monitor Mode. The Monitor code is written to identify to which category (Public Non-virtual, Public Virtual, Secure Non-virtual or Secure Virtual) the FIQ belongs. To do this, the Monitor code reads the GIC  qualifier MreqSecure (Secure or Public FIQ) and then reads the SSM  qualifier MreqSystem (Non-virtual or Virtual). Using the identified mode information, the Monitor code switches operations to a specific processor . A shared Snoop Control Unit (not shown) supports cache coherency.","In some embodiments, the security zone mechanism is implemented on all CPUs - of the cluster. The Secure Kernel and its secure services run specifically on CPU , which operates as a master CPU. CPU  is the first CPU core to boot and to setup or configure the hypervisor structure. CPU cores other than CPU  have a small secure kernel that includes a Monitor Mode implementation to forward SMI\/WFI (Software Monitor Interrupt SMI or Wait for Interrupt WFI). SMI\/WFI are generated by a virtual OS kernel (WinCE, RTOS) as Secure fast interrupt SFIQ. SFIQ is coupled to the secure hypervisor in Monitor Mode operating on the master CPU  core, which executes or drives hypervisor scheduling. The hypervisor scheduling on master CPU  core is unnecessary on the other CPU cores, which simplifies this embodiment. The Security Monitor bus SECMON interface for each processor is accessible by the SSM . The CPU cores in some embodiments have circuitry for establishing various privilege modes such as some or all of Monitor, Supervisor, System, FIQ mode, IRQ mode, Abort mode, Undefined mode, and a non-privilege mode such as a User mode. A Wait for Interrupt WFI instruction is trapped into Monitor Mode as a SWI software interrupt exception, if and as-configured on a CPU-specific basis. In some embodiments, all clocks and timers for various processors and blocks operate in a synchronous mode, and are either synchronous at the same clock rate or clock frequency or run at clock rates that are exact multiples of each other and have coinciding clock edges at the lower or lowest clock rate. All clocks and timers, including watchdog timers, are programmable by CPU  to support the hypervisor scheduling.","Various signal designators are used in connection with the coupling to busses. The signal designators are composites build up from abbreviations and interpreted according to the following Glossary TABLE 11.",{"@attributes":{"id":"p-0260","num":"0259"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"center"}},"thead":{"row":{"entry":"TABLE 11"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"GLOSSARY"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Abbreviation","Remarks"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["A","Address"]},{"entry":["CLK","Clock"]},{"entry":["D","Data"]},{"entry":["EN","Enable"]},{"entry":["I","Instruction (bus)"]},{"entry":["W","Write"]},{"entry":["R","Read"]},{"entry":["Supervisor Mode","Processor non-user mode for interruptions, exception, operatings"]},{"entry":[{},"system, etc."]},{"entry":["CPSR_Mode","User or Exception Mode bit in MPU core CPSR register."]},{"entry":[{},"Processor hardware signals to indicate in which mode the"]},{"entry":[{},"processor core is evolving in, taken from Execute stage of"]},{"entry":[{},"processor pipeline."]},{"entry":["SECMON","Security monitor bus coupled to processor core and SSM 2460"]},{"entry":[{},"hardware-support for hypervisor."]},{"entry":["MPU2BUS","MPU bus bridge to a bus protocol for a bus outside of MPU"]},{"entry":[{},"processor core."]},{"entry":["TRACE","Embedded trace macrocell 600 allows tracing code executed and"]},{"entry":[{},"data transferred, example is ETM."]},{"entry":["TRACEPWRUP","TRACE Power Up activates a TRACE interface to each MPU 10x."]},{"entry":[{},"Trace is enabled only when emulation is needed. For security"]},{"entry":[{},"purposes, TRACE from MPU is output on SECMON bus to SSM"]},{"entry":[{},"Debug Section of FIG. 29."]},{"entry":["TRACEIA[ ]","TRACE instruction address. Virtual address of the instruction"]},{"entry":[{},"executed by the processor at writeback WB stage plus one in the"]},{"entry":[{},"MPU pipeline."]},{"entry":["TRACEIACTL[ ]","Execution status of the instruction executed by each MPU at"]},{"entry":[{},"writeback WB stage plus one in the pipeline."]},{"entry":["TRACEDDCTL[:]","Trace data data control."]},{"entry":["TRACEDACTL[ ]","Trace data address control"]},{"entry":["TRACEDA[:]","Trace data address"]},{"entry":["PRCM","Power, resets, and clocks manager"]},{"entry":["NSBIT_IC","CP15S_NS transferred to In-Circuit emulation block 2785."]},{"entry":["DBGACK","Asserted when the MPU is Halted subsequently to a debug request"]},{"entry":[{},"taken when DSCR = HALT mode."]},{"entry":["EDBGRQ","External debug request to Halt processor(s) (handshake reply is"]},{"entry":[{},"DBGACK)"]},{"entry":["DBGEN","Debug enable (MPU Halt or Real-Time Debugging mode)"]},{"entry":["NIDEN","Non-Intrusive Debug NID enable for MPU to supply a trace output"]},{"entry":[{},"to Trace receiver 600"]},{"entry":["SMI","MPU instruction to switch to Monitor Mode, a secure mode."]},{"entry":["SPIDEN","in-circuit emulation secure privileged intrusive debug enable,"]},{"entry":[{},"debug in Secure Supervisor Mode"]},{"entry":["SPNIDEN","TRACE secure privileged non-intrusive debug enable for MPU to"]},{"entry":[{},"supply a trace output in Secure Supervisor mode"]},{"entry":["SUNIDEN:","TRACE secure user non-intrusive debug enable for MPU to supply"]},{"entry":[{},"a trace output in Secure User mode"]},{"entry":["SystemMpuTapEn","Enable from System microprocessor MPU 100 or external"]},{"entry":[{},"computer to JTAG debug TAP (test access port) controller"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0261","num":"0260"},"figref":"FIG. 29","b":["2770","2772","2610","2780","2785","2765","2765"]},"In-circuit Emulator  is coupled to the TAP controller which in turn controls and selects serial scan chains that are built into each processor in predetermined core areas. These serial scan chains, and other emulation and testability features, obtain bits from each processor that represent a selected portion of the processor state (also called the image). Some background information on this type of technology is provided in U.S. Pat. No. 5,329,471, \u201cEmulation Devices, Systems And Methods Utilizing State Machines,\u201d which patent is hereby incorporated herein by reference. The processor state is selectively coupled to an emulation and testability host computer.","Emulation security and privilege modes are established by configurable entries in a register Control_SEC_EMU. Various debug modes are provided and have names to correspond with various Boolean combinations of two or more of the Mreqxxx qualifiers. ForceDAP< > entries in register Control_SEC_EMU are used to establish and control the MreqInfo qualifiers for debug purposes. Different trace\/debug modes are configurable by a combination of Control Module  registers, SSM registers  and MPU registers (e.g., CP15S_, DSCR) configuration fields or bits establishing the different debug modes.","An invasive debug mode is activated by setting DBGEN active. Invasive debug mode couples the SSM Debug Section ,  with the in-circuit emulator  and\/or a Trace receiver  of . Invasive debug is used for debug of a halted system or running system, using watch points and break points. A Real Monitor Mode and a Halt Mode are software configurable when DBGEN is active. The configurable signal System MPU TAP En sets enable DBGEN_EN active to activate DBGEN from Emulator . The type of debug mode is set in a processor Debug Status and Control Register (DSCR) using debug mode bits. Hardware halting of each processor in debug mode operates when an external debug request (e.g. EDBGRQ) is received from Emulator . Processor responds with the DBGACK debug acknowledge signal active, and processor is halted. DBGACK is coupled to both Emulator  and to SSM Debug Section . MPU core(s) are halted on specific addresses, events or instructions in some multiprocessor embodiments as described herein. Halt mode debugging halts processor to collect information and invasively allows changing processor and coprocessor state.","A Non-Invasive Debug (NID) observational mode, also called real-time debugging here, is established by setting a trace enable signal NIDEN active. Real-time debugging is established by suitable values in register DSCR and is used to collect information in situations in which processor is not halted. Processor is caused to take a Debug Exception instead of halting and a software module called a monitor target can then take control to examine or alter the processor state. The SSM Debug Section is coupled with the Trace block . A trace export from each processor to the Trace block  occurs when NIDEN is activated. Non-invasive debug mode permits data observation of a running system through trace, performance monitoring, and program counter (PC) sampling from processors according to embodiments as described for the other Figures herein.","In , a trace instruction bus  at port  couples the MPU  to Trace receiver . A Trace data bus  conveys the results of actual execution in any selected one, some or all processors , such as from a writeback execution stage of the processor pipeline. A Trace bus firewall  is coupled to the trace instruction bus  and trace data bus  to hardware-protect the Monitor Mode from security compromise. This firewall  is coupled to receive and check trace information from each processor via the trace instruction bus . Control Module registers are coupled to this hardware , which re-creates or specifies Monitor code virtual address ranges or spaces for instruction fetch and data transfer (relating to Monitor Stack(s), Monitor code ROM location and via a Peripheral Port as addressable spaces) and checks that the instructions fetched from L1\/L2 Caches and ROM locations correspond to what is expected.","The Trace Instruction Address bus TRACEIA outputs virtual addresses that have been executed or generated by processor(s) at writeback execute stage in the pipeline. The Trace Instruction Address bus  is qualified by Trace instruction address control IACTL information available on the SECMON Bus. The SECMON Bus also outputs the CPSR modes from the writeback execute stage itself in the pipeline, thereby checking and promoting the coherency of the information and the reliability of the information used for the checking Certain Trace bus control signals for Trace instruction address control IACTL, Trace data address control TRACEDACTL and Trace data data control DDCTL are used to ascertain and control that the instruction execution and data transfer are valid. In this way, the instructions fetched from L1\/L2 Caches and ROM locations are properly executed.","In , a Trace DA bus  outputs the virtual addresses of the Data that has been manipulated by the processor at an Add execute pipeline stage. The TRACEDA bus is qualified by Trace DACTL lines in , such as on SECMON Bus at Add stage in the pipeline so that the checking occurs when a line indicates that a data item is present and another line indicates that the data is not a coprocessor access. A Trace DDCTL bus performs Data transfer as addresses are output on the Trace DA bus. Data transfer in Monitor Mode involves SECMON bus lines corresponding to Trace DDCTL so that when a data item is present, other bus lines indicate that no data write failed and no imprecise data abort occurred.",{"@attributes":{"id":"p-0269","num":"0268"},"figref":["FIG. 30","FIGS. 30A and 30B","FIGS. 5","FIG. 30","FIG. 30"],"b":["6","1","6","2","6","3","8","18","20"]},"Various embodiments are used with one or more microprocessors, each microprocessor having a pipeline, and selected from the group consisting of 1) reduced instruction set computing (RISC), 2) digital signal processing (DSP), 3) complex instruction set computing (CISC), 4) superscalar, 5) skewed pipelines, 6) in-order, 7) out-of-order, 8) very long instruction word (VLIW), 9) single instruction multiple data (SIMD), 10) multiple instruction multiple data (MIMD), 11) multiple-core using any one or more of the foregoing, and 12) microcontroller pipelines, control peripherals, and other micro-control blocks using any one or more of the foregoing.","Various embodiments as described herein are manufactured in a process that prepares RTL (register transfer language) and netlist for a particular design including circuits of the Figures herein in one or more integrated circuits or a system. The design of the trace circuitry and other hardware is verified in simulation electronically on the RTL and netlist. Verification checks contents and timing of registers, operation of trace hardware circuits under various configurations and described modes and hardware to be traced in different scenarios such as semaphores, handles, buffers, message queues, shared peripherals, or other shared data structures and data trace of multiple processors, real-time and non-real-time operations, events and interrupts, responsiveness to transitions through modes, sleep\/wakeup, and various attack scenarios. When satisfactory, the verified design dataset and pattern generation dataset go to fabrication in a wafer fab and packaging\/assembly produces a resulting integrated circuit and tests it with real time video. Testing verifies operations directly on first-silicon and production samples such as by using scan chain methodology on registers and other circuitry until satisfactory chips are obtained. A particular design and printed wiring board (PWB) of the system unit, has one or more peripherals coupled to the processors and can have a user interface coupled to the processors. A storage, such as SDRAM and Flash memory is coupled to the system and has configuration values, macros and parameters and has software, e.g., a hypervisor, a real-time operating system RTOS, image codec-related software HLOS, protected applications (PPAs and PAs), and\/or other supervisory software and applications. System testing tests operations of the integrated circuit(s) and system in actual application for efficiency and satisfactory operation of fixed or mobile display for continuity of content, phone, e-mails\/data service, web browsing, voice over packet, content player for continuity of content, camera\/imaging, audio\/video synchronization, and other such operation that is apparent to the human user and can be evaluated by system use. Also, various attack scenarios are applied. If further increased efficiency is called for, the values, macros and parameter(s) are reconfigured for further testing. Adjusted configurations and parameter(s) are loaded into the Flash memory or otherwise, components are assembled on PWB to produce resulting system units.","Aspects (See explanatory notes at end of this section)",{"@attributes":{"id":"p-0272","num":"0271"},"b":["1","1"]},{"@attributes":{"id":"p-0273","num":"0272"},"b":["1","1"]},{"@attributes":{"id":"p-0274","num":"0273"},"b":["1","1"]},{"@attributes":{"id":"p-0275","num":"0274"},"b":["1","1"]},{"@attributes":{"id":"p-0276","num":"0275"},"b":["1","1"]},{"@attributes":{"id":"p-0277","num":"0276"},"b":["1","1"]},{"@attributes":{"id":"p-0278","num":"0277"},"b":["9","9"]},{"@attributes":{"id":"p-0279","num":"0278"},"b":["9","9"]},{"@attributes":{"id":"p-0280","num":"0279"},"b":["9","9"]},{"@attributes":{"id":"p-0281","num":"0280"},"b":["9","9"]},{"@attributes":{"id":"p-0282","num":"0281"},"b":["9","9"]},{"@attributes":{"id":"p-0283","num":"0282"},"b":["9","9"]},{"@attributes":{"id":"p-0284","num":"0283"},"b":["9","9"]},{"@attributes":{"id":"p-0285","num":"0284"},"b":["9","9"]},{"@attributes":{"id":"p-0286","num":"0285"},"b":["9","9"]},{"@attributes":{"id":"p-0287","num":"0286"},"b":["9","9"]},{"@attributes":{"id":"p-0288","num":"0287"},"b":["9","9"]},{"@attributes":{"id":"p-0289","num":"0288"},"b":["9","9"]},{"@attributes":{"id":"p-0290","num":"0289"},"b":["9","9"]},{"@attributes":{"id":"p-0291","num":"0290"},"b":["9","9"]},{"@attributes":{"id":"p-0292","num":"0291"},"b":["9","9"]},{"@attributes":{"id":"p-0293","num":"0292"},"b":["12","12"]},{"@attributes":{"id":"p-0294","num":"0293"},"b":["12","12"]},{"@attributes":{"id":"p-0295","num":"0294"},"b":["18","18"]},{"@attributes":{"id":"p-0296","num":"0295"},"b":["18","18"]},{"@attributes":{"id":"p-0297","num":"0296"},"b":["18","18"]},{"@attributes":{"id":"p-0298","num":"0297"},"b":["18","18"]},{"@attributes":{"id":"p-0299","num":"0298"},"b":["18","18"]},{"@attributes":{"id":"p-0300","num":"0299"},"b":["23","23"]},{"@attributes":{"id":"p-0301","num":"0300"},"b":["23","23"]},{"@attributes":{"id":"p-0302","num":"0301"},"b":["23","23"]},{"@attributes":{"id":"p-0303","num":"0302"},"b":["23","23"]},{"@attributes":{"id":"p-0304","num":"0303"},"b":["23","1","23"]},{"@attributes":{"id":"p-0305","num":"0304"},"b":["23","1","23","1"]},{"@attributes":{"id":"p-0306","num":"0305"},"b":["24","24"]},"25A. The processor debug circuit claimed in claim 25 wherein said plural electronic processors include at least one program counter and wherein said electronic circuit is also operable to detect when any pair of said processors in a configurably-specified subset are concurrently executing operations in a configurably-specified program counter address range.",{"@attributes":{"id":"p-0308","num":"0307"},"b":["25","25"]},{"@attributes":{"id":"p-0309","num":"0308"},"b":["25","1","25"]},{"@attributes":{"id":"p-0310","num":"0309"},"b":["29","29"]},{"@attributes":{"id":"p-0311","num":"0310"},"b":["30","30"]},{"@attributes":{"id":"p-0312","num":"0311"},"b":["32","32"]},{"@attributes":{"id":"p-0313","num":"0312"},"b":["33","33"]},{"@attributes":{"id":"p-0314","num":"0313"},"b":["34","34"]},{"@attributes":{"id":"p-0315","num":"0314"},"b":["36","36"]},{"@attributes":{"id":"p-0316","num":"0315"},"b":["36","36"]},{"@attributes":{"id":"p-0317","num":"0316"},"b":["36","36"]},{"@attributes":{"id":"p-0318","num":"0317"},"b":["40","40"]},"Notes: Aspects are paragraphs which might be offered as claims in patent prosecution. The above dependently-written Aspects have leading digits and internal dependency designations to indicate the claims or aspects to which they pertain. Aspects having no internal dependency designations have leading digits and alphanumerics to indicate the position in the ordering of claims at which they might be situated if offered as claims in prosecution.","Processing circuitry comprehends digital, analog and mixed signal (digital\/analog) integrated circuits, ASIC circuits, PALs, PLAs, decoders, memories, and programmable and nonprogrammable processors, microcontrollers and other circuitry. Internal and external couplings and connections can be ohmic, capacitive, inductive, photonic, and direct or indirect via intervening circuits or otherwise as desirable. Process diagrams herein are representative of flow diagrams for operations of any embodiments whether of hardware, software, or firmware, and processes of manufacture thereof. Flow diagrams and block diagrams are each interpretable as representing structure and\/or process. While this invention has been described with reference to illustrative embodiments, this description is not to be construed in a limiting sense. Various modifications and combinations of the illustrative embodiments, as well as other embodiments of the invention can be made. The terms \u201cincluding\u201d, \u201cincludes\u201d, \u201chaving\u201d, \u201chas\u201d, \u201cwith\u201d, or variants thereof are used in the detailed description and\/or the claims to denote non-exhaustive inclusion in a manner similar to the term \u201ccomprising\u201d. The appended claims and their equivalents cover any such embodiments, modifications, and embodiments as fall within the scope of the invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 4","FIGS. 2 and 3"]},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 6","FIG. 5"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 6A","FIG. 5","FIG. 6A","FIGS. 6A-1"],"b":["6","2","6","3"]},{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 7","FIG. 5"]},{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 8","FIG. 5"]},{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 8A","FIG. 5","FIG. 8"]},{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 9","FIGS. 8 and 5"]},{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 10","FIGS. 11"],"b":["11","11","11","11"]},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIGS. 11","b":["11","11","11","11"]},{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 12","FIG. 5"]},{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 13","FIG. 4"]},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 17","FIG. 11C"]},{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 18","FIGS. 10 and 17"],"b":"330"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 19","FIG. 18"]},{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 20","FIG. 18"]},{"@attributes":{"id":"p-0048","num":"0047"},"figref":["FIG. 21","FIG. 20"]},{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 21A","FIG. 20"]},{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 22","FIG. 20"]},{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 23","FIG. 20"]},{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 23A","FIG. 20"]},{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 23B","FIG. 20"]},{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 23C","FIG. 20"]},{"@attributes":{"id":"p-0055","num":"0054"},"figref":["FIG. 23D","FIG. 23"]},{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIG. 24","FIGS. 20"],"b":["23","23"]},{"@attributes":{"id":"p-0057","num":"0056"},"figref":["FIG. 24A","FIGS. 20"],"b":["23","23","23","23"]},{"@attributes":{"id":"p-0058","num":"0057"},"figref":["FIG. 25","FIG. 20"]},{"@attributes":{"id":"p-0059","num":"0058"},"figref":["FIG. 26","FIGS. 20 and 25"]},{"@attributes":{"id":"p-0060","num":"0059"},"figref":["FIG. 26A","FIGS. 20 and 25"]},{"@attributes":{"id":"p-0061","num":"0060"},"figref":["FIG. 26B","FIGS. 20 and 25"]},{"@attributes":{"id":"p-0062","num":"0061"},"figref":["FIG. 26C","FIG. 26B"]},{"@attributes":{"id":"p-0063","num":"0062"},"figref":["FIG. 26D","FIG. 26B"]},{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0066","num":"0065"},"figref":["FIG. 29","FIGS. 27 and 28"]},{"@attributes":{"id":"p-0067","num":"0066"},"figref":["FIG. 30","FIGS. 30A and 30B","FIGS. 5"],"b":["6","1","6","2","6","3","8","18","20"]}]},"DETDESC":[{},{}]}
