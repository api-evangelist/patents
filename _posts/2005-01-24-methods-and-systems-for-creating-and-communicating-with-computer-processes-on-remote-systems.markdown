---
title: Methods and systems for creating and communicating with computer processes on remote systems
abstract: An application programming interface (API) presents services of a system to applications. The API is usable with all processes, local and remote, and is transparent with respect to the location of processes. A process table stores information about processes created using the system. The process table supports centralized process control and peer-to-peer process communication and synchronization. Each process is assigned a Universally Unique Identifier (UUID) that uniquely identifies the process no matter the computing device on which it runs. A parent UUID and a group UUID may be attached to the process and used for enforcing dependencies (e.g., for halting the process and all of its child processes) and for managing arbitrary, user-defined groups, respectively. A global event is associated with each process. When a process receives this event, it performs a controlled shutdown, cleans up, and reports status.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07587725&OS=07587725&RS=07587725
owner: Microsoft Corporation
number: 07587725
owner_city: Redmond
owner_country: US
publication_date: 20050124
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATION(S)","TECHNICAL FIELD","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","Creating and Communicating with Local and Remote Processes","An Exemplary Application Programming Interface","Specific Considerations When Communicating with Remote Processes"],"p":["This application is a divisional application of and claims the benefit of U.S. patent application Ser. No. 09\/872,257, filed Jun. 1, 2001, which issued as U.S. Pat. No. 7,089,561 on Aug. 8, 2006, content of which is hereby incorporated by reference.","The present invention relates generally to computer operating systems, and, more particularly, to communications mechanisms for computer processes.","Often, a process running on one computing device may need to create or communicate with a process on another device. The use of remote devices may simply be a convenience as, for example, when a program requires so many resources that it cannot effectively be run on one device. The work of the program may then be shared among several devices by invoking processes on the remote devices to perform pieces of the overall task. The results produced by the remote processes are collected in a central, coordinating process. In other cases, the use of remote devices is inherent in the nature of the work at hand. For example, communications protocols cannot be fully tested on one device. A script for testing a protocol may be run on a test host device. To perform the test, the script may start an application on a second device, start a peer application on a third device, and start an application on a fourth device to monitor the communications between the applications on the second and third devices.","Methods exist for a process running on a host computing device to create a process on a remote device. However, these methods provide much less functionality for communicating with the remote process than is available for processes running locally. Often, these methods only allow the host device to start the remote process, receive output from it, and terminate it. The termination is uncontrolled, not giving the remote process a chance to clean up before exiting. Another drawback of these methods is the distinction they draw between local and remote processes. This makes it very difficult to debug a program on one device and know that it will work correctly when it is running on multiple devices.","Even for purely local processes, current methods of communication are in some ways inadequate. Local processes may be limited in their ability to log ongoing status information. Termination of local processes may be as uncontrolled as for remote processes.","What is needed is a method that enhances the communications abilities of all processes and that provides the full functionality of local processes to processes on remote computing devices. The method would ideally hide the distinction between local and remote processes, allowing all processes to be treated in the same manner.","The above problems and shortcomings, and others, are addressed by the present invention, which can be understood by referring to the specification, drawings, and claims. The present invention provides mechanisms for creating and communicating with computer processes. An application programming interface (API) presents the services of the invention to applications. The API is usable with all processes, local and remote, and is transparent with respect to the location of processes. The invention also works with processes that do not use the API, although some enhanced services are available only to processes using the API.","A process table stores information about processes created using the invention. The process table is accessible by all processes, local and remote, and supports centralized process control and peer-to-peer process communication and synchronization. Locks are used to synchronize access to the process table.","Each process is assigned a Universally Unique Identifier (UUID) that uniquely identifies the process no matter the computing device on which it runs. A parent UUID and a group UUID may be attached to the process and used for enforcing dependencies (e.g., for waiting for or halting the process and all of its child processes) and for managing arbitrary, user-defined groups, respectively.","A global event is associated with each process. When a process receives this event, it performs a controlled shutdown, cleans up, and reports its status. Users define other global events and assign meanings to them. Global events form a generally useful message-passing mechanism.","At frequent intervals, processes and process threads log heartbeat entries in the process table. If a process or thread stops updating this field, then other processes can assume that this process or thread broke into the debugger. A process may log other information such as the number of its threads and the current status of the threads.","Turning to the drawings, wherein like reference numerals refer to like elements, the invention is illustrated as being implemented in a suitable computing environment. The following description is based on embodiments of the invention and should not be taken as limiting the invention with regard to alternative embodiments that are not explicitly described herein.","In the description that follows, the invention is described with reference to acts and symbolic representations of operations that are performed by one or more computers, unless indicated otherwise. As such, it will be understood that such acts and operations, which are at times referred to as being computer-executed, include the manipulation by the processing unit of the computer of electrical signals representing data in a structured form. This manipulation transforms the data or maintains them at locations in the memory system of the computer, which reconfigures or otherwise alters the operation of the computer in a manner well understood by those skilled in the art. The data structures where data are maintained are physical locations of the memory that have particular properties defined by the format of the data. However, while the invention is being described in the foregoing context, it is not meant to be limiting as those of skill in the art will appreciate that various of the acts and operations described hereinafter may also be implemented in hardware.","The present invention provides services for creating and communicating with computer processes, whether the processes are all running locally on one computing device or are scattered among several remote devices. Information about processes is gathered into data structures called \u201cprocess tables.\u201d The process tables are accessible by all processes, local and remote, and support centralized process control and peer-to-peer process communication and synchronization.","This section provides an overview of the mechanisms and capabilities of the invention and includes implementation details only when they are useful to illustrate the discussion. The following section expands on this overview by presenting, in great detail, an exemplary embodiment of the invention.",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1","b":["100","102","104","106","100","1","2","2","3","3","4","1","100","2","2","3","3","4","5","6","4","5","106","4","100","5","102","6","4","5","104"]},"Each computing device runs a service called \u201cspsrv\u201d that coordinates communications among the devices. The spsrv service listens for requests coming in to a device and processes them. These requests include requests to create a process, requests to provide updated status information, and requests to send information to a process. The spsrv service also sends out status updates and responses to enquiries. This service generally makes communications details transparent so that an application can deal with processes regardless of the device on which they are running. Details specific to remote communications are discussed in the section below entitled \u201cSpecific Considerations When Communicating with Remote Processes.\u201d","Each computing device contains a process table that has an entry for each process running on, or invoked by a process running on, the computing device. The process table  of computing device  contains six entries. The first four entries are for Processes  through  which run on the device. In addition, the process table contains entries for Process  and  which do not run locally but were invoked by Process  which does run locally. Process table  on computing device  contains an entry for Process  because that process runs locally, even though the process was invoked on another device. Similarly, process table  on computing device  contains entries for Process , running locally though invoked remotely, and Process , running locally. Process  illustrates processes running on a computing device that have nothing to do with the job run by the user of computing device . Process tables are described in greater detail with reference to . For the moment, note that process tables are populated when a process is created and contain information useful for controlling and monitoring the processes.","The computing devices , , and  of  may be of any architecture.  is a block diagram generally illustrating an exemplary computer system that supports the present invention. The computing device  is only one example of a suitable environment and is not intended to suggest any limitation as to the scope of use or functionality of the invention. Neither should the computing device  be interpreted as having any dependency or requirement relating to any one or combination of components illustrated in . The invention is operational with numerous other general-purpose or special-purpose computing environments or configurations. Examples of well-known computing systems, environments, and configurations suitable for use with the invention include, but are not limited to, personal computers, servers, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set-top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, and distributed computing environments that include any of the above systems or devices. In its most basic configuration, computing device  typically includes at least one processing unit  and memory . The memory  may be volatile (such as RAM), non-volatile (such as ROM, flash memory, etc.), or some combination of the two. This most basic configuration is illustrated in  by the dashed line . The computing device may have additional features and functionality. For example, computing device  may include additional storage (removable and non-removable) including, but not limited to, magnetic and optical disks and tape. Such additional storage is illustrated in  by removable storage  and non-removable storage . Computer-storage media include volatile and non-volatile, removable and non-removable, media implemented in any method or technology for storage of information such as computer-readable instructions, data structures, program modules, or other data. Memory , removable storage , and non-removable storage  are all examples of computer-storage media. Computer-storage media include, but are not limited to, RAM, ROM, EEPROM, flash memory, other memory technology, CD-ROM, digital versatile disks (DVD), other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage, other magnetic storage devices, and any other media which can be used to store the desired information and which can accessed by device . Any such computer storage media may be part of device . Device  may also contain communications connections  that allow the device to communicate with other devices. Communications connections  are examples of communications media. Communications media typically embody computer-readable instructions, data structures, program modules, or other data in a modulated data signal such as a carrier wave or other transport mechanism and include any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communications media include wired media, such as wired networks (including the LAN  of ) and direct-wired connections, and wireless media such as acoustic, RF, infrared, and other wireless media. The term computer-readable media as used herein includes both storage media and communications media. The computing device  may also have input devices  such as a keyboard, mouse, pen, voice-input device, touch-input device, etc. Output devices  such as a display, speakers, printer, etc., may also be included. All these devices are well know in the art and need not be discussed at length here.","The services of the present invention are presented to applications by means of an Application Programming Interface (API). The API can be used with all processes, local and remote, and is transparent with respect to the location of a process. The API returns sensible values if a request fails because of a network problem and does not falter if remote devices are unavailable. If a process uses the API, then the process is called a \u201cWINDOWS Test Technologies (WTT)-based process.\u201d The name \u201cWTT\u201d is of only historical interest, and the invention is not limited to use in the testing field or to use with Microsoft's \u201cWINDOWS\u201d operating systems. The invention works with any combination of WTT-based and non-WTT-based processes, although some enhanced services are available only to WTT-based processes. For purposes of this discussion, the services provided by the API are roughly divided into four major categories of communications tasks: creating processes, monitoring processes, waiting for processes, and sending signals to processes, especially termination signals.","Using the API, applications can create new processes and run them either on the local computing device or on a remote device. Each process is tagged by a Universally Unique Identifier (UUID) that uniquely identifies the process no matter the computing device on which it resides. In addition, a parent UUID and a group UUID may be assigned to the process and used for enforcing dependencies (e.g., for signaling the process and all of its child processes) and for managing arbitrary, user-defined groups, respectively. The process table stores information about processes created on the computing device, whether the process runs locally on the device or runs remotely. The process table is created as a memory-mapped file and is visible to all processes on the device. A global event is associated with each process created via the API and is used for process control and signaling.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIGS. 3A and 3B","FIG. 3A","FIG. 1","FIG. 1","FIG. 3B"],"b":["300","302","304","306","308","3","4","310","314","3","6","6","100","104","318","320","322","6","108","100","112","104"]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 4","FIG. 1","FIG. 4"],"b":["3","6","112"]},"Because a process table is accessible to all processes on the computing device, mechanisms exist for coordinating access to the table. One mechanism involves software locks, both for the entire table and for each individual row. For example, a process updating its heartbeat time can lock access to its row while it writes the current time into the Heartbeat Time field. When a process is created or deleted, the entire process table is locked so that a row can be added or deleted without interference.","At frequent intervals, for each process, a monitor thread logs heartbeat entries in the Heartbeat Time field in the local process table. Each thread in a process updates a local heartbeat and the monitor thread keeps track of these local heartbeats, updating the heartbeat field in the local process table if all the threads are updating their local heartbeats. If any thread deadlocks and stops updating its local heartbeat, the monitor thread detects this, logs the fact, and either breaks into the debugger or marks the process as requiring assistance. When an application wants to monitor the heartbeat of a process, the application begins by looking up the entry for the process in the process table on the computing device on which the application is running. The application reads the Target Device field to see where the process is running. Then, if the target device is the local device, the application reads the Heartbeat Time field in the local process table. Otherwise, the target device is distinct from the local device and the application sends a request to the spsrv service running on the target device asking it to send the value of the Heartbeat Time of the process. For example, if Process  in  wants to know whether Process  is still running normally, that is to say, is still logging heartbeats, Process  would consult Process Table  on its local computing device . Reading the entry for Process , Process  discovers that Process  is running remotely, on computing device . (See .) Process  formulates a request and sends it to the computing device . That device reads its process table  and reports to Process  that the Heartbeat Time field of Process  currently reads \u201c14:24:56\u201d. Process  compares that heartbeat time (adjusted, if necessary, for time zone differences) to its local clock and decides whether Process  is running or has broken into the debugger.","In addition to its heartbeat, a process may log other information including the number of its threads, the current status of the threads, console output, log file output, etc. An application wishing to monitor this output can use the same techniques described above with respect to heartbeats. The application can also obtain ongoing status information by requesting that a copy of new information written by the process be sent to the application as it is written. Using parent and group UUIDs, an application can monitor all of the processes in a dependency list or in a user-defined process group.","A process may wait for other processes to achieve a specified status, for example, to complete their initialization or to terminate. The API provides a function that waits until the processes achieve the status or until a timeout period elapses. The function checks the heartbeat of all WTT-based processes and, if a process is not logging heartbeats, then the process may be assumed to have broken into the debugger. Using the processes in  as an example, assume that Process  calls the API function to wait for Processes , , and  to complete their initialization. Because Processes  and  run on remote computing devices, the API function sends a wait request to those remote devices. Each device waits on the processes local to it and then reports the results to Process . For each process in the wait list, the returned status may be Completed Initialization, Still Initializing, or Heartbeat Stopped. Using UUIDs in the same manner as in process monitoring, a process can wait for all of the processes in a dependency list or in a user-defined process group. Note that because non-WTT-based processes do not update their Heartbeat Time field, it cannot be assumed that these processes broke into the debugger.","When a job is divided into discrete processes, the processes often need to communicate among themselves to coordinate the tasks they perform. The API provides a generally useful signaling mechanism for this purpose in the form of Global Events. As an example, one particular event is the Controlled Shutdown. When a WTT-based process receives this event, it releases the resources it is using, reports its status, and performs a controlled shutdown. Users may define other Global Events and assign meanings to them. When a process receives an event, it responds in a fashion appropriate to the event's meaning. However, if a process receives an event it does not understand, it may terminate in an uncontrolled fashion. A process may use parent and group UUIDs to send an event to groups of processes.","The services provided by the invention as described in the previous section are presented again in this section but with more attention paid to the details of an exemplary API. In its specific details, this embodiment is oriented towards use with Microsoft's \u201cWINDOWS\u201d operating system, but the principles are applicable to other environments. This section begins by describing the fundamental data structures used in this embodiment.","Note that UUIDs are sometimes called GUIDs (Globally Unique Identifiers).","The variable types TCHAR and Tstring are used in the definitions below to provide source code compatibility between Unicode and non-Unicode machines. If the parameter _UNICODE is defined during the build, then TCHAR is defined to be the Unicode's basic wide character type, \u201cwchar_t,\u201d otherwise it becomes the standard ASCII 8-bit signed \u201cchar.\u201d Similarly, Tstring is a string of TCHARs and becomes either the Unicode wide string, \u201cwstring,\u201d or ASCII \u201cstring.\u201d","1 WTTPROCESSPARAM","Describes the input parameters to the WTTCreateProcess call.",{"@attributes":{"id":"p-0039","num":"0038"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ From the winbase.h file."},{"entry":"#define MAX_COMPUTERNAME_LENGTH 31"},{"entry":"\/\/ Type of processes: WTT-based or not."},{"entry":"#define WTT_PROC_TYPE_NONWTT_BASED\u20031"},{"entry":"#define WTT_PROC_TYPE_WTT_BASED\u2003\u2003\u20022"},{"entry":"\/\/ System processes and other non-WTT-based processes launched outside"},{"entry":"\/\/ the scope of the API."},{"entry":"#define WTT_PROC_TYPE_SYSTEM_BASED\u20033"},{"entry":"typedef struct_WTTPROCESSPARAM"},{"entry":"{"},{"entry":"\u2003\u2003\/\/ Sizeof this structure (including this field). User needs to input a"},{"entry":"\u2003\u2003\/\/ value of sizeof(WTTPROCESSPARAM) for this."},{"entry":"\u2003\u2003IN DWORD\u2003dwStructSizeOf;"},{"entry":"\u2003\u2003\/\/ Flags. Reserved: must be zero (MBZ)."},{"entry":"\u2003\u2003IN DWORD\u2003dwFlags;"},{"entry":"\u2003\u2003\/\/ Flags used in WTTCreateProcess."},{"entry":"\u2003\u2003\/\/ Only CREATE_NEW_CONSOLE,"},{"entry":"\u2003\u2003\/\/ CREATE_NEW_PROCESS, and DETACHED_PROCESS are"},{"entry":"\u2003\u2003currently supported."},{"entry":"\u2003\u2003IN DWORD\u2003dwCreateProcessFlags;"},{"entry":"\u2003\u2003\/\/ Is this a WTT-based process?"},{"entry":"\u2003\u2003IN DWORD\u2003dwProcessType;"},{"entry":"\u2003\u2003\/\/ The username and password to use when running the process. The"},{"entry":"\u2003\u2003\/\/ password is unencoded text but is encrypted before sending to"},{"entry":"\u2003\u2003the target device."},{"entry":"\u2003\u2003IN TCHAR\u2003\u2009*szUserName;"},{"entry":"\u2003\u2003IN TCHAR\u2003\u2009*szPassword;"},{"entry":"\u2003\u2003\/\/ The command line to execute when starting the process."},{"entry":"\u2003\u2003IN TCHAR\u2003\u2009*szCommandLine;"},{"entry":"\u2003\u2003\/\/ NULL or a debugger string such as \u201cntsd -g\u201d."},{"entry":"\u2003\u2003IN TCHAR\u2003\u2009*szDebugger;"},{"entry":"\u2003\u2003\/\/ NULL or the UNC-style (e.g., \\\\machine\\share\\path...) name of a"},{"entry":"\u2003\u2003\/\/ generated log file."},{"entry":"\u2003\u2003IN TCHAR\u2003\u2009*szLogFile;"},{"entry":"\u2003\u2003\/\/ The directory where the process is created. Can be NULL, which"},{"entry":"\u2003\u2003\/\/ means use the current directory for launching the process."},{"entry":"\u2003\u2003IN TCHAR\u2003\u2009*szCurrentDirectory;"},{"entry":"\u2003\u2003\/\/ If the process was invoked remotely, then get the GUID from the"},{"entry":"\u2003\u2003\/\/ caller. From an external caller's perspective, this is not provided"},{"entry":"\u2003\u2003as an input."},{"entry":"\u2003\u2003UUID\u2003\u2003\u2003\u2009Guid;"},{"entry":"\u2003\u2003\/\/ This optionally identifies a group with which the process is"},{"entry":"\u2003\u2003associated."},{"entry":"\u2003\u2003UUID\u2003\u2003\u2003\u2009GroupGuid;"},{"entry":"\u2003\u2003\/\/ The GUID of the parent of this process. There may be a chain of"},{"entry":"\u2003\u2003\/\/ parent-child processes."},{"entry":"\u2003\u2003UUID\u2003\u2003\u2003\u2009ParentGuid;"},{"entry":"\u2003\u2003\/\/ The identity of the target computing device, for example, its name"},{"entry":"\u2003\u2003\/\/ or IP address."},{"entry":"\u2003\u2003IN TCHAR\u2003\u2009szTargetMachine"},{"entry":"\u2003\u2003[MAX_COMPUTERNAME_LENGTH + 1];"},{"entry":"} WTTPROCESSPARAM, *PWTTPROCESSPARAM;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"By associating a group GUID with a set of processes, processes can communicate with all the processes in the set. This is similar to a \u201cprocess group\u201d in Windows NT or Unix.","2 WTTPROCLISTINFO","Defines information relating to a process. WTTGetProcessListInfo returns this information. A pointer to this structure is passed as an input parameter to WTTOpenProcess. An application receives a handle to a process by calling WTTOpenProcess and can use that handle to monitor the process, even if the process was not created by the application.",{"@attributes":{"id":"p-0042","num":"0041"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef struct_WTTPROCLISTINFO"},{"entry":"{"},{"entry":"\u2003\u2003\/\/ The GUID, Process ID, and type of the process. The process type"},{"entry":"\u2003\u2003can be:"},{"entry":"\u2003\u2003\/\/ WTT_PROC_TYPE_NON_WTT_BASED\u2003(defined to be 1);"},{"entry":"\u2003\u2003\/\/ WTT_PROC_TYPE_WTT_BASED\u2003\u2003\u2003\u2002\u2009(2); or"},{"entry":"\u2003\u2003\/\/ WTT_PROC_TYPE_SYSTEM_BASED\u2003\u2003(4)."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003UUID","Guid;"]},{"entry":["\u2003\u2003DWORD","dwPid;"]},{"entry":["\u2003\u2003DWORD","dwProcType;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\/\/ These variables are meaningful only if the process is WTT-based"},{"entry":"\u2003\u2003\/\/ and is logging heartbeats. For non-WTT-based processes,"},{"entry":"\u2003\u2003\/\/ dwHBTime is zero and ulLastHBUpdateTime is the time the"},{"entry":"\u2003\u2003process was created."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003DWORD","dwHBTime;"]},{"entry":["\u2003\u2003ULARGE_INTEGER","ulLastHBUpdateTime;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\/\/ The number of seconds since the process was created (reported as"},{"entry":"\u2003\u2003\/\/ zero for non-WTT-based processes)."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2003\u2003DWORD","dwElapsedSeconds;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\/\/ This is the status of the process. Its possible values are given below"},{"entry":"\u2003\u2003\/\/ in the section describing WTTGetProcessInfo. For non-WTT-based"},{"entry":"\u2003\u2003\/\/ processes, the reported status is"},{"entry":"\u2003\u2003WTTHANDLE_PROCSTATUS_UNDEFINED."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2003\u2003DWORD","dwProcStatus;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\u2003\u2003\/\/ The module name (not fully qualified with path)."}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2003\u2003TCHAR","szModuleName[256];"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} WTTPROCLISTINFO, *PWTTPROCLISTINFO;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"Holds information about a thread including the Thread Identifier and a list of comments. Comments may be pushed onto the stack, and the most recent comment may be popped off the stack and examined.",{"@attributes":{"id":"p-0044","num":"0043"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct_WTTTHREADINFO"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003DWORD\u2003\u2003\u2003\u2003\u2003\u2003dwThreadId;"]},{"entry":[{},"\u2003\u2003\/\/ The Standard Template Library (STL) contains"]},{"entry":[{},"\u2003\u2003type-parameterized classes."]},{"entry":[{},"\u2003\u2003\/\/ slThreadCommentStack is an STL stack of STL strings."]},{"entry":[{},"\u2003\u2003stack <string> \u2003\u2003\u2003\u2003slThreadCommentStack;"]},{"entry":[{},"} WTTTHREADINFO, *PWTTTHREADINFO;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0045","num":"0044"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Holds detailed process information."},{"entry":"typedef class_WTTPROCESSINFO"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ All members are public (can use a ctor and a dtor)."]},{"entry":[{},"public:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"DWORD","dwProcType;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Status of the process (initialized, debug break, terminated,"]},{"entry":[{},"\/\/ etc.) This is the same as in the WTTPROCLISTINFO"]},{"entry":[{},"\/\/ structure. That one is there for convenience only."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"DWORD","dwProcStatus;"]},{"entry":[{},"UUID","Guid;"]},{"entry":[{},"DWORD","dwProcPid;"]},{"entry":[{},"DWORD","dwProcExitCode;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ Time elapsed since the creation of the process."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ULARGE_INTEGER","ulElapsedTime;"]},{"entry":[{},"TCHAR","*pszModuleName;"]},{"entry":[{},"TCHAR","*pszCommandLine;"]},{"entry":[{},"TCHAR","*pszTargetMachine;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Singly-linked list of thread information (used to store"]},{"entry":[{},"\/\/ elements of type WTTTHREADINFO)."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"list <PWTTTHREADINFO>","slThreadList;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ List of log files associated with the process."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"list <string>","slLogList;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ List of variations covered."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"list <string>","slVarnList;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"_WTTPROCESSINFO( )"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"pszModuleName = new TCHAR[MAX_PATH];"]},{"entry":[{},"pszCommandLine = new TCHAR[MAX_CMD_LINE];"]},{"entry":[{},"pszTargetMachine = new"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"TCHAR[MAX_COMPUTERNAME_LENGTH + 1];"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} WTTPROCESSINFO, *PWTTPROCESSINFO;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},{"@attributes":{"id":"p-0046","num":"0045"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct_WTTP_LOG_INFO"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003TCHAR\u2003\u2003szLogFileName[128]; \u2003\u2003\/\/ UNC path of log file."]},{"entry":[{},"} WTTP_LOG_INFO, *PWTTP_LOG_INFO"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"This structure is opaque to the user and is used as a handle for future operations. This process-specific handle may be replaced by WTTHANDLE.","7 WTTHANDLE","This data structure is opaque to the user and is used as a handle for future operations. This handle is capable of handling objects no matter their type\u2014whether processes, events, mutexes, etc. For \u201cWINDOWS\u201d implementations, this handle is similar to the handles used by Win32 processes.",{"@attributes":{"id":"p-0049","num":"0048"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef struct_WTT_HANDLE"},{"entry":"{"},{"entry":"\u2003\u2003\/\/ The exit status of the process as would be returned by a local call"},{"entry":"\u2003\u2003\/\/ to the Win32 function GetExitCodeProcess( )."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2003\u2003DWORD","dwStatus;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\u2003\u2003\/\/ The Process Identifier of a created child."}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2003\u2003DWORD","dwProcID;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\/\/ Was the process successfully created? If not, then this is set to"},{"entry":"\u2003\u2003\/\/ ERROR_SERVICE_NOT_ACTIVE."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2003\u2003DWORD","dwProcCreationStatus;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\/\/ This points to information such as the heartbeat timer, etc. This"},{"entry":"\u2003\u2003\/\/ field is opaque and only makes sense on the device on which the"},{"entry":"\u2003\u2003process is created."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2003\u2003PWTT_SHAREDINFO","pSharedInfo;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\u2003\u2003\/\/ The current status of the process."}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2003\u2003DWORD","dwProcStatus;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\/\/ Store the following data in the process handle. While marshaling"},{"entry":"\u2003\u2003\/\/ the parameters, the offsets are clearly defined and the strings are"},{"entry":"\u2003\u2003\/\/ put towards the end of the buffer."},{"entry":"\u2003\u2003\/\/ If the call comes from a remote device, then get the GUID from the"},{"entry":"\u2003\u2003caller."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003UUID","Guid;"]},{"entry":["\u2003\u2003TCHAR","*szCommandLine;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\/\/ The following two parameters are supplied in case the process"},{"entry":"\u2003\u2003\/\/ needs to be launched by a specified user."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003TCHAR","*szUserName;"]},{"entry":["\u2003\u2003TCHAR","*szPasswd;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\u2003\u2003\/\/ Both for storage in the local process table and for redirection."}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003TCHAR","*szTargetMachineName;"]},{"entry":["\u2003\u2003TCHAR","*szModule;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\/\/ The object type can be WTT_PROC_OBJECT,"},{"entry":"\u2003\u2003\/\/ WTT_EVENT_OBJECT, etc."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003DWORD","dwObjectType;"]},{"entry":["\u2003\u2003PHANDLE","hObjectHandle;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} WTT_HANDLE, *WTTHANDLE;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Having presented the data structures used in this implementation, the following describes the function calls provided by the API.","8 WTTCreateProcess","Create a process, whether WTT-based or not. The user's input parameters are passed in as part of the WTTPROCESSPARAM structure. The returned structure pointer (pHWTTProcess) is opaque and is used in future calls. If UserName and Password are specified as part of the input structure, then the process is created with the logon credentials of the specified user.","The call is basically asynchronous in nature and returns as soon as possible after the process is successfully created or with a meaningful error value explaining why the process creation failed.",{"@attributes":{"id":"p-0053","num":"0052"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"DWORD WTTCreateProcess"]},{"entry":[{},"("]},{"entry":[{},"\u2003IN OUT PWTTPROCESSPARAM\u2003pWTTProcessParam,"]},{"entry":[{},"\u2003OUT WTTHANDLE\u2003\u2003\u2003\u2003\u2003\u2003\u2003*pHWTTProcess"]},{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"pWTTProcessParam","Points to a structure of type WTTPROCESSPARAM, which contains the input parameters. Some of the fields in this structure are appropriately updated to store output values. For example, if the passed in GUID is \u201cNIL\u201d (see Note on UUIDs below), then the newly created GUID is stored when the function returns.","The following flags are supported in the WTTPROCESSPARAM structure's dwCreateProcessFlags field: CREATE_NEW_CONSOLE, CREATE_NEW_PROCESS, and DETACHED_PROCESS.","pHWTTProcess","An opaque pointer used in future calls to the API for accessing information about the process.","Return Values:","ERROR_SUCCESS if the process is successfully created, else Win32 error. In the latter case, the returned handle is NOT valid.","Implementation Notes:","This function assigns a GUID to the process that uniquely identifies the process no matter the device on which it runs. Then the function locks access to the process table and finds an empty slot in the table. Assigning the slot to the new process, this function stores in the slot the initial data for the process including its GUID, Parent GUID, Group GUID, etc. The parent of the process updates the heartbeat field and writes a zero value into the HB field. This makes it possible for the WTTWaitForMultipleObjects function to detect a DEBUG_BREAK that occurs before the creation of the Global Event.","If the process is to run on a remote device, then the parameters of the call are marshaled over the network and sent to the remote (target) device. The process is then created locally on the target device.","Once the new process starts, its status in the process table (the dwProcStatus field) is automatically updated.","9 WTTSignalProcesses","Send a signal to the processes in a set. The set may include both WTT-based and non-WTT-based processes. The global event handle is set for each process. One currently defined signal is \u201cterminate the process.\u201d On receipt of that signal, a process cleans up after itself and performs a controlled stop. Sending a terminate signal is similar to sending a \u201ckill\u201d signal.",{"@attributes":{"id":"p-0064","num":"0063"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"DWORD WTTSignalProcesses"]},{"entry":[{},"("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003IN DWORD","nCount,"]},{"entry":[{},"\u2003IN WTTHANDLE","*phWTTProcess,"]},{"entry":[{},"\u2003IN DWORD","dwFlags"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"nCount","The number of processes in the phWTTProcess array.","phWTTProcess","The set of processes to signal. This is an array of WTTHANDLEs for WTTProcesses as returned by the WTTCreateProcess and WTTOpenProcess functions.","dwFlags","The type of signal to send:","WTT_SIGNAL_PROCESS","Attempt a controlled stop by signaling the event associated with the process. It is the responsibility of non-WTT-based processes to check the global event.","WTT_TERMINATE_PROCESS","Force-terminate the process. This cannot be combined with WTT_SIGNAL_PROCESS.","WTT_TERMINATE_ALL_CHILDREN","This terminates all processes in a process tree. For every process in the process tree, internal process APIs are recursively used to terminate the children. The process table is searched to find all the descendents so that they can be signaled.","Return Values:","ERROR_SUCCESS if the signal is successfully sent, else Win32 error.","Implementation Notes:","For non-WTT-based processes, the standard global event handle is signaled. If a non-WTT-based process does not clean up within an acceptable period of time after being sent a WTT_SIGNAL_PROCESS signal, then the calling process can send a WTT_TERMINATE_PROCESS signal.","10 WTTWaitForMultipleObjects","Wait for processes in a set to achieve a specified status, but stop waiting if a timeout period expires. The function checks the heartbeats of all WTT-based processes, and if a process is not logging heartbeats, then it is assumed to have broken into the debugger. This function is often used to wait for processes to terminate. In that case, the different possible scenarios on returning from this function are as follows:\n\n","A debug break cannot be declared for a non-WTT-based process because this type of process does not log heartbeats.","DWORD WTTWaitForMultipleObjects",{"@attributes":{"id":"p-0082","num":"0084"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003IN DWORD","nCount,"]},{"entry":[{},"\u2003\u2003IN WTTHANDLE","*phWTTProcess,"]},{"entry":[{},"\u2003\u2003IN BOOL","fWaitAll,"]},{"entry":[{},"\u2003\u2003IN DWORD","dwTimeoutInSeconds,"]},{"entry":[{},"\u2003\u2003IN DWORD","dwDebugTimeoutInSeconds,"]},{"entry":[{},"\u2003\u2003IN DWORD","dwWaitType,"]},{"entry":[{},"\u2003\u2003OUT DWORD","*pdwSummaryStatus,"]},{"entry":[{},"\u2003\u2003OUT DWORD","*pdwSummaryIndex"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},")"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"nCount","The number of processes in the phWTTProcess array.","phWTTProcess","The set of processes stored as an array of WTTHANDLEs.","fWaitAll","TRUE means wait for all processes in the set. FALSE means wait for the first process to achieve the specified status.","dwTimeoutInSeconds","The function timeout period. The function waits no longer than this before returning. If a process does not achieve the specified status (e.g., terminated) during this period of time, its status is returned as WAIT_TIMEOUT.","dwDebugTimeoutInSeconds","If a process has not logged a heartbeat during this period, then the process is declared to have broken into the debugger. The value of this parameter may be smaller than the value of dwTimeoutInSeconds. A value of INFINITE is also possible which effectively ignores heartbeats.","If fWaitAll is TRUE, then the value of this parameter should be the maximum of the debug timeout values of all the processes in the monitored set.","dwWaitType","The type of status to wait for. These values cannot be combined. Many more statuses are possible; the following are currently implemented:","WTT_PROCESS INITIALIZE","Wait for the processes to complete their initialization.","WTT_PROCESS_TERMINATE","Wait for the processes to finish.","pdwSummaryStatus","The address to receive the first failure status of the array (or NULL if this information is not desired). This field is meaningful only if the return value is ERROR_SUCCESS and if fWaitAll is FALSE.","pdwSummaryIndex","The address to receive the index corresponding to the summary status (or NULL if this information is not desired).","Return Values:","ERROR_SUCCESS if all the processes successfully achieve the specified status.","WAIT_TIMEOUT if the timeout expires before all the processes achieve the specified status. In this case, *pdwSummaryIndex and *pdwSummaryStatus are undefined.","WTT_ERROR_DEBUG_BREAK if a process breaks into the debugger. *pdwSummaryStatus contains WTT_ERROR_DEBUG_BREAK and the index of that process in the phWTTProcess array is returned in *pdwSummaryIndex. There could be several processes in such a state in which case pdwSummaryIndex points to the first one.","Win32 if the function call fails.","Implementation Notes:","When processes in the set run on a distributed set of computing devices, there may be one thread per process (or one per computing device) which the overall thread monitors.","For non-WTT-based processes, dwLastHBUpdateTime is the time the process was created and is not updated. No debug break can be declared for these processes.","11 WTTGetProcessInfo","Query the status of a process that was launched by the WTTCreateProcess function. After reviewing the information returned, WTTFreeProcessInfo is called to release the memory allocated by this function.",{"@attributes":{"id":"p-0111","num":"0113"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"DWORD WTTGetProcessInfo"]},{"entry":[{},"("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003IN WTTHANDLE","phWTTProcess,"]},{"entry":[{},"\u2003OUT PWTTPROCESSINFO","*ppWTTProcessinfo"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"phWTTProcess","Process information is stored in a WTTHANDLE structure. The handle could have been obtained either by a call to WTTCreateProcess or by a call to WTTOpenProcess (after a call to WTTGetProcessListInfo).","Additionally, this could have a value of NULL. In that case, the information returned pertains to the process that called this function. This is useful when a non-WTT-based process wishes to get GUID information about itself, which it can then use to open a handle to the Global Event.","ppWTTProcessinfo","This stores information about the process being queried. The information includes the threads present, the stack of thread comments for each thread, a list of log files that this process monitors, and a list of variations completed by the process.","Return Values:","ERROR_SUCCESS if the request is successfully processed, else Win32 error.","Implementation Notes:","For WTT-based processes, the following information is returned:\n\n","The data returned are stored in the form of simple link lists or stacks. Small routines are provided to return the size, traverse, and list the contents of the lists or stacks.","For non-WTT-based process, a list of thread identifiers, the module name, the type of the process, and the current state of the process are returned. The current state of the process may not be very accurate because non-WTT-based processes do not log heartbeats.","The process statuses are:\n\n","The macro GET_PROC_STATUS(pWTTProcessinfo->dwProcStatus) returns a string corresponding to the process status.","12 WTTFreeProcessInfo","Release the memory allocated within the WTTPROCESSINFO structure during a WTTGetProcessInfo function call.","DWORD WTTFreeProcessInfo(IN PWTTPROCESSINFO *ppWTTProcessinfo);","Parameter:","ppWTTProcessinfo","Pointer to a pointer to a structure containing information about a process returned by a call to WTTGetProcessInfo.","Return Values:","ERROR_SUCCESS if the allocated memory is successfully released, else Win32 error. The pointer to the WTTPROCESSINFO structure is not defined after a call to this function.","13 WTTGetProcessListInfo","Get the process list from the target machine's process table. The information returned varies depending upon the values specified in dwFlags. Memory allocation is done within the function call itself. WTTFreeProcessListInfo is called to release the memory after reviewing the information returned.",{"@attributes":{"id":"p-0129","num":"0145"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"DWORD WTTGetProcessListInfo"]},{"entry":[{},"("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003IN LPCTSTR","pszMachine,"]},{"entry":[{},"\u2003BOOL","bResolveRemote,"]},{"entry":[{},"\u2003IN DWORD","dwFlags,"]},{"entry":[{},"\u2003OUT DWORD","*pdwCount,"]},{"entry":[{},"\u2003OUT PWTTPROCLISTINFO","*ppWTTProcessListInfo"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"pszMachine","The name of the computing device from which to retrieve the process table information.","bResolveRemote","TRUE means remote entries should be resolved. In that case, extra heartbeat-related information is retrieved for processes initiated by WTTCreateProcess on the computing device specified by pszMachine. A query is made to that remote device.","dwFlags","Include_wtt_based_procs","Include all WTT-based processes created by WTTCreateProcess or otherwise.","Include_Non_wtt Based_Procs","Include non-WTT-based processes created by WTTCreateProcess.","Include_System_Procs","GUID is displayed as NULL for these. WTTOpenProcess cannot be called for processes of this type.","pdwCount","Pointer to the number of elements in the ppWTTProcessListInfo array.","ppWTTProcessListInfo","An array of output information for the processes.","Return Values:","ERROR_SUCCESS if the information is successfully retrieved, else Win32 error.","Implementation Notes:","During the marshaling of parameters to a remote device, pszMachine is marshaled into the szTargetMachine field of the buffer.","This function needs to carefully check to see if a process actually exists. If the entry for a particular process is present in the <GUID>.ini file but not present in the process table, then the process no longer exists. There is a problem, however, because there may be entries in the process table for processes that have exited. This happens only if a WTT-based process is killed with a forced kill signal. Even doing an OpenProcess( ) on the process identifier (PID) is not a foolproof check as the PID could have been recycled. The solution is to use the Phandle pointer in the process table (on the local machine where the process was instantiated) to wait on the Process Handle with a timeout of zero. If the process is gone, then Phandle is signaled immediately.","When returning the list of process information, allocate space for one more than the total number of entries returned. The last entry is a \u201cNULL\u201d: NIL for GUIDs and ZERO for DWORDS.","14 WTTFreeProcessListInfo","Release the memory allocated during a WTTGetProcessListInfo function call.",{"@attributes":{"id":"p-0150","num":"0166"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"DWORD WTTFreeProcessListInfo"]},{"entry":[{},"("]},{"entry":[{},"\u2003\u2003IN PWTTPROCLISTINFO\u2003\u2009*ppWTTProcessListInfo"]},{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"ppWTTProcessListInfo","The array for which memory is to be released.","Return Values:","ERROR_SUCCESS if the allocated memory is successfully released, else Win32 error.","15 WTTTailLog","Retrieve a copy of output as it is added to a log file. The effect is that of a distributed \u201ctail-f\u201d command. A callback allows this function to return asynchronously.",{"@attributes":{"id":"p-0155","num":"0171"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"DWORD WTTTailLog"]},{"entry":[{},"("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003WTTHANDLE","pWTTProcInfo,"]},{"entry":[{},"\u2003\u2003WTTP_LOG_INFO","*pWTTLogInfo,"]},{"entry":[{},"\u2003\u2003DWORD","dwBytes,"]},{"entry":[{},"\u2003\u2003WTTPROC_CALLBACK","CALLBACKFUNCTION"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"pWTTProcInfo","Information about the process of interest to be passed over to the remote device.","pWTTLogInfo","This structure contains the log information. It includes the UNC path of the log file. If this pointer is NULL, then the first log file is used, as specified in the <GUID>.ini file.","dwBytes","The number of bytes to be retrieved. If this is set to the value WTTPROCESS_FULL_LOGSIZE, then entire log files are retrieved.","CALLBACKFUNCTION","Register a callback function with the spsrv service to retrieve data (the tail of the log file) asynchronously.","Return Values:","ERROR_SUCCESS if the log file stream is successfully initialized, else Win32 error.","16 WTTCancelTailLog","Cancel the effect of a previous call to WTTTailLog.",{"@attributes":{"id":"p-0166","num":"0182"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"DWORD WTTCancelTailLog"]},{"entry":[{},"("]},{"entry":[{},"\u2003\u2003WTTHANDLE\u2003\u2003\u2003\u2003pWTTProcInfo,"]},{"entry":[{},"\u2003\u2003WTTP_LOG_INFO\u2003*pWTTLogInfo"]},{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"pWTTProcInfo","Information about the process of interest to be passed over to the remote device.","pWTTLogInfo","This structure contains the log information. It includes the UNC path of the log file. If this pointer is NULL, then cancel all tail logs for the process identified by the pWTTProcInfo parameter.","Return Values:","ERROR_SUCCESS if the cancellation is successful, else Win32 error.","17 WTTOpenProcess","Get a WTT process handle.",{"@attributes":{"id":"p-0173","num":"0189"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"DWORD WTTOpenProcess"]},{"entry":[{},"("]},{"entry":[{},"\u2003\u2003IN WTTPROCLISTINFO\u2003\u2002*pWTTProcessInfo,"]},{"entry":[{},"\u2003\u2003OUT WTTHANDLE\u2003\u2003\u2003\u2003*pWTTProcInfo"]},{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"pWTTProcessInfo","A pointer to the element in the array retrieved by WTTGetProcessListInfo that concerns the process of interest.","pWTTProcInfo","A returned pointer to a handle to the process of interest.","Return Values:","ERROR_SUCCESS if the handle is successfully retrieved, else Win32 error.","Implementation Notes:","The handle has information like the GUID of the process, the name of the device on which the process runs, etc. Once the handle is received, it is more efficient to store its information in a local process table and to then call WTTCloseHandle to release the memory.","18 WTTCloseHandle","Close a WTT process handle. This releases the memory allocated by the WTTOpenProcess call. The local process table entry created for the process is marked as invalid.","DWORD WTTCloseHandle(WTTHANDLE *pWTTProclnfo);","Parameter:","pWTTProcInfo","A pointer to a handle to the process of interest.","Return Values:","ERROR_SUCCESS if the handle is successfully closed, else Win32 error.","19 WTTConsoleOutput","Provide console output for a process. A callback allows this function to return asynchronously.",{"@attributes":{"id":"p-0186","num":"0202"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"DWORD WTTConsoleOutput"]},{"entry":[{},"("]},{"entry":[{},"\u2003\u2003WTTHANDLE\u2003\u2003\u2003\u2003\u2003\u2002pWTTProcInfo,"]},{"entry":[{},"\u2003\u2003WTTPROC_CALLBACK\u2003CALLBACKFUNCTION"]},{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"pWTTProcInfo","Process information stored in a WTTHANDLE structure.","CALLBACKFUNCTION","Register a callback function with the spsrv service to retrieve data asynchronously","Return Values:","ERROR_SUCCESS if the console output stream is successfully initialized, else Win32 error.","20 WTTCancelConsoleOutput","Cancel the console output associated with a particular process.","DWORD WTTCancelConsoleOutput(WTTHANDLE pWTTProcInfo);","Parameter:","pWTTProcInfo","Process information stored in a WTTHANDLE structure.","Return Values:","ERROR_SUCCESS if the cancellation is successful, else Win32 error.","21 WTTSetLogFile","Add a log file to the list of log files to which a process logs.",{"@attributes":{"id":"p-0198","num":"0214"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"DWORD WTTSetLogFile"]},{"entry":[{},"("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"WTTHANDLE","pProcessInfo,"]},{"entry":[{},"LPCWSTR","pszLogFile"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"pProcessInfo","Process information stored in a WTTHANDLE structure.","pszLogFile","The name of the log file to add to the list.","Return Values:","ERROR_SUCCESS if the log file is successfully added to the list, else Win32 error.","22 WTTPROC_CALLBACK","The functions WTTTailLog and WTTConsoleOutput use callback functions to allow them to return asynchronously. The structure of the callback function is as follows:",{"@attributes":{"id":"p-0205","num":"0221"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedefDWORD (*WTTPROC_CALLBACK)"]},{"entry":[{},"("]},{"entry":[{},"\u2003\u2003SOCKET\u2003hSocket,"]},{"entry":[{},"\u2003\u2003LPVOID\u2003\u2009pData,"]},{"entry":[{},"\u2003\u2003DWORD\u2003\u2002dwBytes"]},{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"UUIDs (also called GUIDs) provide unique designations of objects such as processes, interfaces, manager entry-point vectors, and client objects. In practice, these identifiers need only be unique within the context of their use, that is, within the set of communicating computing devices. Because techniques already exist for making the identifiers truly unique, those techniques are used here.",{"@attributes":{"id":"p-0207","num":"0223"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct_GUID"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"unsigned long","Data1;"]},{"entry":[{},"unsigned short","Data2;"]},{"entry":[{},"unsigned short","Data3;"]},{"entry":[{},"unsigned char","Data4[8];"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} GUID;"]},{"entry":[{},"typedef GUID UUID;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"Data1","The first eight hexadecimal digits of the UUID.","Data2","The first group of four hexadecimal digits of the UUID.","Data3","The second group of four hexadecimal digits of the UUID.","Data4","An array of eight elements. The first two elements of the array contain the third group of four hexadecimal digits of the UUID. The remaining six elements contain the final twelve hexadecimal digits of the UUID.","Remarks:","For implementations based on Microsoft's \u201cWINDOWS\u201d operating systems, the following standard Win32 functions are used to create, compare, and manipulate UUIDs. Other implementation platforms provide similar functions.","signed int RPC_ENTRY UuidCompare",{"@attributes":{"id":"p-0218","num":"0234"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"signed int RPC_ENTRY UuidCompare"]},{"entry":[{},"("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003UUID","*Uuid1,"]},{"entry":[{},"\u2003\u2003UUID","*Uuid2,"]},{"entry":[{},"\u2003\u2003RPC_STATUS","*Status"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},");"]},{"entry":[{},"RPC_STATUS RPC_ENTRY UuidCreate(UUID *Uuid);"]},{"entry":[{},"RPC_ENTRY UuidCreateNil(UUID *Nil_Uuid);"]},{"entry":[{},"RPC_STATUS RPC_ENTRY UuidFromString"]},{"entry":[{},"("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003unsigned char","*StringUuid,"]},{"entry":[{},"\u2003\u2003UUID","*Uuid"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},");"]},{"entry":[{},"RPC_STATUS RPC_ENTRY UuidToString"]},{"entry":[{},"("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003UUID","*Uuid,"]},{"entry":[{},"\u2003\u2003unsigned char","**StringUuid"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"A suitable infrastructure is provided for tagging and monitoring non-WTT-based processes. Every non-WTT-based process created by the WTTCreateProcess function is given a WTT-created GUID for tagging. The GUID is stored in the WTT-based process handle for future tracking purposes.","A Global Event handle is present for every non-WTT-based process. The naming structure of this handle is \u201cEvent\\<GUID>\u201d and it is present on the device on which the process is created. When a non-WTT-based process is created, it has the option of waiting on this event handle and performing a clean shutdown if requested.","25 Note on Locking","Central to the implementation of this API is the process table. The process table has row-level exclusive locks and a global process table lock that over-rides the row-level locks.","There are at least six points in time when locking comes into play:\n\n","Considering all these, a global lock (mutex) is needed whenever a write affects the entire process table, as in cases (a), (b), and (f) above. A row-level exclusive lock is needed (after acquiring the global process table) when updating process-specific information, as in cases (c), (d), and (e) above.","While the invention is useful when all processes run on the same computing device, it is also designed for the case when some processes run remotely. This section discusses specific considerations that come into play when the API supports remote processes.","PWTTPROCESSINFO contains a field called szDestMachine that holds the value of the target device on which the process runs. If the value is NULL, then the call is local. If not, the command and its parameters are sent to the target device, and the results are piped back to the originating device. All calls are synchronous in nature. So, if the target device crashes during the period of passing the command, an appropriate error is returned.","The need to pass by value argues for using Remote Procedure Calls (RPC) as a message-passing paradigm. On the other hand, if all input parameters to a call are based on parameters passed only by value, then interfaces (function tables) for the call can be set up and the spsrv service used to handle the commands on the remote device. Another consideration is that if 32-bit-based machines communicate with IA64 cluster machines, then RPC is very useful as it takes care of architectural differences. RPC interfaces are flexible in terms of marshaling both pointer-based and value-based parameters.","Every time a new API call is made, a new GUID may be generated on the device that initiated the call. This GUID is used to \u201ctrack\u201d the call. The GUID is sent with the call to the target device. The target device keeps track of the GUID. If the target device crashes, then the target device, after re-booting, \u201ccalls back\u201d its parent device with the knowledge of the GUID of the last call and the name or IP address of the parent device.","For every process created on a particular device, a <GUID>.ini file is created in the %windir%\\WTTbin\\GUID directory. (For non-\u201cWINDOWS\u201d implementations, a similar directory is used.) This directory stores information about the process, its threads, and its stack comments. The files store information more persistently than can memory and prevent having to use memory for ever-changing, bulky data. A process is free to update the information in its file whenever the thread comments are updated. If a query about the state of a process is made and if the process no longer has an entry in the process table, but a <GUID>.ini file exists, then the status of the process is updated to ERROR_SERVICE_NOT_ACTIVE. Due to the presence of multiple threads possibly operating simultaneously on this file, synchronization is important. A cleanup routine removes .ini files three or more days old. This is the structure of a <GUID>.ini file:",{"@attributes":{"id":"p-0229","num":"0251"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[GLOBAL]"]},{"entry":[{},"GGUID = nnn"]},{"entry":[{},"PID = nnn"]},{"entry":[{},"Status = WTT_PROCESS_RUNNING\u2003\/\/ Or some other status."]},{"entry":[{},"[LogFiles]"]},{"entry":[{},"<Log1.log>"]},{"entry":[{},"<Log2.log>"]},{"entry":[{},"[<ThreadId1>]"]},{"entry":[{},"Comment1"]},{"entry":[{},"Comment2"]},{"entry":[{},"..."]},{"entry":[{},"[<ThreadId2>]"]},{"entry":[{},"Comment1"]},{"entry":[{},"Comment2"]},{"entry":[{},"..."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"For marshaling parameters for a function call, the spsrv service has a function table that is used to form the receive and send stubs for the spsrv service running on the remote device. To form the stub for receiving data, the buffer is as generic and as flexible as possible. It identifies the function, determines the number of parameters, and sets a fixed order of parameters depending on the function. The following structure is used. It is marshaled into a byte buffer, sent out the socket, and un-marshaled on the other end. When the call completes, the same procedure gets the returned value of the call.",{"@attributes":{"id":"p-0231","num":"0253"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ This is the index into the function dispatch table on the remote device."},{"entry":"DWORD\u2003dwTestAPINum;"},{"entry":"\/\/ This usually corresponds to nCount."},{"entry":"DWORD\u2003dwNumHWTTProcesses;"},{"entry":"\/\/ Offset into the non-variable-length buffers."},{"entry":"DWORD\u2003dwHWTTProcOffset[MAX_PROCS];"},{"entry":"\/\/ The number of processes present in the"},{"entry":"\/\/ WTTPROCESSMARSHALPARAM structure (see below)."},{"entry":"DWORD\u2003dwNumMPProcesses;"},{"entry":"\/\/ Offset into the non-variable-length buffers."},{"entry":"DWORD\u2003dwNumMPOffset[MAX_PROCS];"},{"entry":"\/\/ The total number of bytes taken up by the buffer."},{"entry":"DWORD\u2003dwBytesForBuffer;"},{"entry":"DWORD\u2003dwNumWTTPLogInfo;"},{"entry":"\/\/ Offset into the non-variable-length buffers."},{"entry":"DWORD\u2003dwNumWTTPLogOffset[MAX_PROCS];"},{"entry":"DWORD\u2003dwNumWTTProcListElem;"},{"entry":"\/\/ Offset into the non-variable-length buffers."},{"entry":"DWORD\u2003dwNumWTTProcListOffset[MAX_PROCS];"},{"entry":"DWORD\u2003dwWaitTimeout;"},{"entry":"DWORD\u2003dwFlags;"},{"entry":"DWORD\u2003dwWaitAll;"},{"entry":"DWORD\u2003dwBytes;"},{"entry":"\/\/ Now for storage for the variable-length data fields."},{"entry":"(dwNumHWTTProcesses * sizeof(_M_HWTTPROCESS))"},{"entry":"(dwNumMPProcesses * sizeof(WTTPROCESSMARSHALPARAM))"},{"entry":"(dwNumWTTPLogInfo * sizeof(WTTP_LOG_INFO))"},{"entry":"(dwNumWTTProcListElem * sizeof(WTTPROCLISTINFO))"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},{"@attributes":{"id":"p-0232","num":"0254"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef struct"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003DWORD\u2003dwFlags;","\/\/ Flags; currently a reserved"]},{"entry":[{},"field. Input."]},{"entry":["\u2003DWORD\u2003dwCreateProcessFlags;","\/\/ Flags used in CreateProcess."]},{"entry":[{},"Input."]},{"entry":["\u2003DWORD\u2003dwProcessType;","\/\/ Is this a WTT-based process?"]},{"entry":[{},"Input."]},{"entry":["\u2003DWORD\u2003dwOffSets[25];","\/\/ Offsets to the variable-length"]},{"entry":[{},"strings."]},{"entry":"\u2003Void\u2003\u2003*pBuf;"},{"entry":"\u2003..."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} WTTPROCESSMARSHALPARAM,"},{"entry":"*PWTTPROCESSMARSHALPARAM;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"The output buffer for most calls contains the following information: information in HWTTPROCESS, marshaled as _M_HWTTPROCESS; dwSummaryStatus; and dwSummaryIndex. Variable-length data are put at the end of the buffer. For WTTGetProcessListInfo, a list is formed of entries containing information about the processes of interest. The information carried back is as follows: a list of threads present including their thread identifiers; a list of comments on a per-thread basis; and a list of variations completed by the process. The data structures useful for marshaling this data are as follows:",{"@attributes":{"id":"p-0234","num":"0256"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003Struct_WTTP_THREAD_INFO"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003DWORD dwThreadId;"]},{"entry":[{},"\u2003\u2003\u2003\/\/ Offset into the comments strings for a thread."]},{"entry":[{},"\u2003\u2003\u2003DWORD dwCommentOffset"]},{"entry":[{},"\u2003\u2003\u2003[MAX_COMMENTS_PER_THREAD];"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003\u2003Struct _WTTP_VARIATION_INFO"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\/\/ Offset into the variable-length name strings."]},{"entry":[{},"\u2003\u2003\u2003DWORD dwVarnNameOffset[MAX_VARNS];"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003\u2003Struct _WTTP_LOG_INFO"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\/\/ Offset into the log strings."]},{"entry":[{},"\u2003\u2003\u2003DWORD dwLogOffset[MAX_LOGS_PER_PROC];"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"The structure of the marshaling buffer is as follows (no"]},{"entry":[{},"pointers are passed):"]},{"entry":[{},"\u2003\u2003\/\/ The size of this entire buffer in bytes."]},{"entry":[{},"\u2003\u2003DWORD dwBuffSize;"]},{"entry":[{},"\u2003\u2003DWORD _dwThreadCount;"]},{"entry":[{},"\u2003\u2003\/\/ All fixed-length data for threads (i.e., the thread identifier"]},{"entry":[{},"\u2003\u2003\/\/ and the offsets for the comments) go here while the actual"]},{"entry":[{},"\u2003\u2003comments are in the variable-length section."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003Struct _WTTP_THREAD_INFO","*pThreadInfo;"]},{"entry":[{},"\u2003\u2003DWORD","_dwVariationCount;"]},{"entry":[{},"\u2003\u2003Struct_WTTP_VARIATION_INFO","*pVarnInfo;"]},{"entry":[{},"\u2003\u2003DWORD","_dwLogCount;"]},{"entry":[{},"\u2003\u2003Struct_WTTP_LOG_INFO","*pLogInfo;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003(The variable-length data go here.)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"ul":{"@attributes":{"id":"ul0008","list-style":"none"},"li":{"@attributes":{"id":"ul0008-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0009","list-style":"none"},"li":["PDWORD pdwThreadCount;","PWTTPROCESS_THREAD_INFO *pThreadInfo;\n\nWTTGetProcessListInfo retrieves information about a set of processes. Its return buffer contains the following information:\n"]}}}},{"@attributes":{"id":"p-0235","num":"0259"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ The size of this entire buffer in bytes."},{"entry":"DWORD\u2003dwBuffSize;"},{"entry":"\/\/ The number of processes whose information is returned in this buffer."},{"entry":"DWORD\u2003dwProcs;"},{"entry":"DWORD\u2003dwProcInfoOffset[WTT_MAX_PROCS];"},{"entry":"DWORD\u2003dwProcessId;"},{"entry":"DWORD\u2003dwGuidOffSet;"},{"entry":"DWORD\u2003dwSrcMcOffset;"},{"entry":"DWORD\u2003dwDestMcOffset;"},{"entry":"DWORD\u2003_dwProcListCount;"},{"entry":"\/\/ The time of the last recorded heartbeat is split into two parts."},{"entry":"DWORD\u2003LastHBTimeHighDword;"},{"entry":"DWORD\u2003LastHBTimeLowDword;"},{"entry":"DWORD\u2003dwHeartBeat;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In view of the many possible embodiments to which the principles of this invention may be applied, it should be recognized that the embodiments described herein with respect to the drawing figures are meant to be illustrative only and should not be taken as limiting the scope of invention. Therefore, the invention as described herein contemplates all such embodiments as may come within the scope of the following claims and equivalents thereof."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["While the appended claims set forth the features of the present invention with particularity, the invention, together with its objects and advantages, may be best understood from the following detailed description taken in conjunction with the accompanying drawings of which:",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIGS. 3A and 3B"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
