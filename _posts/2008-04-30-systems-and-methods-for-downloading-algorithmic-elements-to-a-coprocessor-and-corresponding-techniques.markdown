---
title: Systems and methods for downloading algorithmic elements to a coprocessor and corresponding techniques
abstract: Systems and methods for downloading algorithmic elements to a coprocessor and corresponding processing and communication techniques are provided. For an improved graphics pipeline, the invention provides a class of co-processing device, such as a graphics processor unit (GPU), providing improved capabilities for an abstract or virtual machine for performing graphics calculations and rendering. The invention allows for runtime-predicated flow control of programs downloaded to coprocessors, enables coprocessors to include indexable arrays of on-chip storage elements that are readable and writable during execution of programs, provides native support for textures and texture maps and corresponding operations in a vertex shader, provides frequency division of vertex streams input to a vertex shader with optional support for a stream modulo value, provides a register storage element on a pixel shader and associated interfaces for storage associated with representing the “face” of a pixel, provides vertex shaders and pixel shaders with more on-chip register storage and the ability to receive larger programs than any existing vertex or pixel shaders and provides 32 bit float number support in both vertex and pixel shaders.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08305381&OS=08305381&RS=08305381
owner: Microsoft Corporation
number: 08305381
owner_city: Redmond
owner_country: US
publication_date: 20080430
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","COPYRIGHT NOTICE AND PERMISSION","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENTS","EXAMPLE"],"p":["This application is a divisional of U.S. patent application Ser. No. 10\/987,686 filed Nov. 12, 2004 which claims the benefit of U.S. Provisional Application No. 60\/520,253 filed Nov. 14, 2003, the entire contents of which are hereby incorporated by reference in their entireties.","A portion of the disclosure of this patent document may contain material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent files or records, but otherwise reserves all copyright rights whatsoever. The following notice shall apply to this document: Copyright\u00a9 2001-2003, Microsoft Corp.","The present invention provides systems and methods relating to graphics interface(s) as a layer between applications\/application developers and a more flexible graphics pipeline that renders and processes graphics data, and to corresponding hardware improvements.","For the vast majority of applications, application programmers rely on or utilize some form of software interface for interactions between a host system, such as the host system of a computer, and its associated subsystems, such as a computer's graphics subsystem. For graphics applications, developers or programmers typically utilize a graphics software interface, such as a 3D graphics application programming interface (API), to facilitate the interaction with constituent parts of a graphics system. For instance, a developer might develop a graphics application that makes and receives calls to and from the graphics API in order to achieve some result pertaining to a graphics effect applied to graphics data. Programmers typically rely on software interfaces to graphics processing units (GPUs), peripherals and other specialized devices so that they can focus on the operational specifics of their application and the artistry of the graphics content rather than on the specifics of controlling a particular device or the algorithmic details associated with generating certain graphics objects or transforming those objects according to a particular effect. Programmers also rely on software interfaces so that their efforts are not duplicated from application to application, i.e., so that function calls or interfaces which are likely to be useful to multiple developers or likely to be applicable to various graphics scenarios, such as \u201cCreate Triangle,\u201d \u201cFill in Object with a Specified Solid Color,\u201d Stretch\/Scale Rectangle,\u201d etc. can re-used. However, even after generations of software interfaces, there are certain aspects of today's software interfaces that can be improved.","Historically, graphics peripherals, integrated circuits (ICs) and other specialized graphics hardware designed for specific tasks, e.g., special purpose co-processing chips such as GPUs, have been better than the host processor of a host computing system at performing certain types of functions. For instance, video cards generally include special purpose hardware for copying and processing pixels and vertices faster than the central processing unit (CPU). So, historically, for a PC having a host system with a CPU and a graphics subsystem having a GPU, when any sort of graphics \u201cthinking\u201d was involved, the CPU handled the processing and when repetitive number crunching of large arrays of data was implicated, the GPU was called upon for processing. However, changes in graphics technology have occurred that have transformed the traditionally fixed function graphics pipeline into a more flexible entity.","For instance, hereby incorporated by reference, commonly assigned copending U.S. patent application Ser. No. 09\/796,577, filed Mar. 1, 2001, entitled \u201cMethod and System for Defining and Controlling Algorithmic Elements in a Graphics Display System,\u201d relates to systems and methods for enabling programmability of a 3D graphics chip, wherein programming or algorithmic elements written by the developer can be downloaded to the chip, thereby programming the chip to perform those algorithms. As described, a developer writes a routine representing algorithmic element(s), wherein the routine is downloadable to the 3D graphics chip and then downloads the algorithmic element(s) to the programmable chip. Alternatively, the developer chooses from a pre-existing set of algorithmic elements that are provided in connection with the API itself, or specifies the location of an otherwise existing routine. The routine adheres to a specific format for packing up the algorithmic element(s), or instructions, for implementation by the 3D graphics chip. In one embodiment, the developer packs the instruction set into an array of numbers, by referring to a list of \u2018tokens\u2019 understood by the 3D graphics chip. This array of numbers in turn is mapped correctly to the 3D graphics chip for implementation of the algorithmic element(s) by the 3D graphics chip. The architecture of the '577 application enables the developer to be flexible when defining the computation to be performed by the chip, while simultaneously allowing the developer to leverage the power and performance advantages provided by the 3D graphics chip.","Vertex and pixel shaders, which may be implemented with software or hardware or with a combination of both, are specialized components of a graphics subsystem that include specialized functionality for the processing of pixels, vertices, or other graphics data, so as to perform specialized operations, such as lighting and shading, and other transformations upon graphics data. In this regard, vertex and pixel shaders are two types of procedural shaders that have evolved to possess programmable functionality, e.g., as described in the '577 application.","Additional background relating to vertex and pixel shaders can be found in commonly assigned copending U.S. patent application Ser. No. 09\/801,079, filed Mar. 6, 2001, entitled \u201cAPI Communications for Vertex and Pixel Shaders,\u201d hereby incorporated into the present disclosure by reference. Briefly, the '079 application is directed to a three dimensional (3-D) graphics application programming interface (API) that provides improved communications between application developers and hardware rendering devices, such as procedural shaders. In particular, the '079 application is directed to improved API communications for host interaction with procedural shaders, such as vertex and pixel shaders, having local registers. The API communications of the '079 application advantageously expose various on-chip graphical algorithmic elements, while hiding the details of the operation of vertex shaders and pixel shaders from the developer. Advantageously, the procedural shaders and corresponding communications do not access the main memory or stack on the host system, but rather perform their operations efficiently with respect to a set of local registers. For the particular graphical algorithmic elements exposed, the graphics subsystem and corresponding interfaces of the '079 application allow for an efficient instruction set with numerous performance advantages, including faster accessing and processing of data as a result of bypassing the host system memory or stack.","As is apparent from the above, advances in hardware, such as procedural shaders, and graphics interfaces and algorithms have been revolutionizing the way graphics platforms operate. Generally speaking, however, current 3D graphics chips on the market can still be made more flexible and efficient, i.e., room for improvement still exists, both with respect to vertex shaders and pixel shaders.","For instance, on the vertex shader side of the graphics pipeline, while programs, i.e., algorithmic element(s) packaged as tokenized set(s) of instructions, currently can be downloaded to a graphics chip, the flow represented by a program performed by the graphics chip must be static. While such static flow may include branches, the branches themselves are fixed and may not be predicated upon a characteristic only known at runtime, i.e., any branches that may currently exist in a program downloaded to a vertex shader are predicated upon pre-set constants, such that all data fed to the vertex shader is processed in exactly the same way until the corresponding program is unloaded.","For instance, as illustrated in , a developer D (or a software application A) can specify a program P having exemplary instructions I to I to a graphics API GAPI for download to the graphics chip, such as vertex shader VS, in order to program the graphics chip to perform the algorithms represented by the program P. Once the program P is downloaded to vertex shader VS, however, i.e., once vertex shader VS is programmed with program P, graphics data processed by vertex shader VS must be processed according to the algorithms I\u2032 to I\u2032 represented by or corresponding to instructions I to I. In this simple example, the goal of the illustrated program P is to process black pixels in one way (I, I and I), and white pixels in another way (I and I). However, once the program is loaded into vertex shader VS, there can be no branching taking place upon a characteristic or variable of the runtime system which can be limiting.","While the ability to define a static process flow for all graphics data to be processed according to algorithms I\u2032 to I\u2032 on the graphics chip is beneficial, currently, the static definition must remain for the duration of processing according to program P, i.e., until the processing is stopped and another program providing a different static computational flow is downloaded to the vertex shader VS for further processing of graphics data.","As illustrated in , represented by the arrows illustrating the computational flow process performed on the graphics data, the processing that occurs for each data point of the graphics data streamed through the graphics chip's execution engine is limited to the static flow of the following: if a constant C is \u201c0\u201d, vertex shader VS processes according to algorithm, instruction, or function I\u2032, followed by algorithm I\u2032 and followed by algorithm I\u2032 before being output; and if a constant C is \u201c1\u201d, vertex shader VS processes according to algorithm I\u2032 and algorithm I\u2032 before being output. In this regard, all of the graphics data must be processed in these static rules of process flow, i.e., some of the data cannot be processed according to different rules of process flow. More particularly, the graphics data cannot currently be processed according to dynamic branches of program P determined at runtime, e.g., an \u201cIf Then\u201d or \u201cIf Then Else\u201d command or structure based upon a runtime condition cannot be deployed in a program. Accordingly, it would be desirable to provide dynamic flow control for programs that are downloaded to a vertex shader VS, whereby a coprocessor can receive a program which thereby programs the coprocessor to dynamically process data in a particular way defined by the program, and wherein the coprocessor can process data differently according to different branches defined by the program. For instance, according to criteria specified in the program, it would be desirable to process some of the data streaming through the coprocessor according to a first algorithm depending upon a first condition that is set or discovered at runtime, and some of the data according to a second algorithm depending upon a second runtime condition or setting without recourse to downloading another program. It would be further desirable to enable branching to occur dynamically during the execution of a program that has been downloaded to a graphics chip to predicate control of the processing of graphics data on runtime characteristics or variables.","It is to be noted that the dichotomy of symbolic representation, e.g., I v. I\u2032, is used above when describing a program instruction versus its functional representation as a part of a program that has been downloaded to a graphics chip, respectively; however, one can appreciate that a program may be parsed and\/or partially, quasi- or fully tokenized or compiled en route to the graphics chip as part of the download process to format the program for reception and use by the graphics chip. As a consequence, the process of tracing or finding definitive correspondence between a representation I\u2032 in the graphics chip and a source code instruction I may be amorphous. Moreover, where one instruction \u201cends\u201d and another \u201cbegins\u201d is not necessarily definitive, atomicity of operation may be defined in different ways, programs operate according to functional objectives, which can be divided into subsets of functional objectives, which can be divided into even smaller subsets of functional objectives, and so on. Thus, such symbolism for instructions has been used herein for conceptual or illustrative purposes.",{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIGS. 2A and 2B","FIG. 2A","FIG. 2A"]},"Graphics API GAPI also includes, however, many other objects and interfaces, such as external object(s) or interface(s) EO, which may be used in connection with, inter alia, initializing, setting or changing various storage elements, such as registers, located in the graphics coprocessing subsystem, e.g., in the vertex shader VS. Thus, as illustrated in , an exemplary vertex shader VS includes at least (1) a storage bank for n constants C[] to C[n\u22121], which are immutable (read only) during operation of the vertex shader VS, (2) a plurality of readable\/writable input register storage elements I to Ik (e.g., for vertices, intermediate programming results, etc.) and (3) a plurality of readable\/writable output register storage elements O to Om. Exemplary vertex shader VS may include other register storage elements for storing other kinds of variables and constants as well, whether readable and\/or writable.","Because of how quickly the above described storage elements can be accessed by the execution engine EE of the vertex shader VS, a program loaded into vertex shader VS via download object(s) DO can also execute upon large quantities of data streamed through the execution engine EE very quickly. Constants C[] to C[n\u22121] may be first set by the external objects EO in order to define the context into which program(s) are to be downloaded, and constants C[] to C[n\u22121] can also be declared globally at the loading or instantiation of a program in the vertex shader VS for reference during operation of the program, although constants may not be altered or reset during operation of the program, e.g., while the execution engine EE processes a stream, or container, of graphics data. In this regard, as implied by the notation, C[] to C[n\u22121], constants are capable of being referenced by index with programming commands. An exemplary command that indexes a constant is the command \u201cmov r, C[],\u201d which when executed moves the value rinto constant storage location C[]. However, presently, no readable and writable storage element in vertex shader VS may be referenced by index, i.e., a \u201cmov r, I2\u201d or a \u201cmov r, O7\u201d command can be executed, but the equivalent \u201cmov r, I[1]\u201d or \u201cmov r, O[6]\u201d commands using an index into the array of input and output registers can not be performed. The registers I to Ik and O to Om are individually and independently addressable only. Thus, a program cannot currently index readable\/writable input and output registers of a vertex shader VS. This would be particularly desirable and provide more vertex shader flexibility for a variety of reasons, including, but not limited to, achieving looping or recursive behavior within a program downloaded to the vertex shader VS.",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 3A"},"After texture sampling, additional transformations optionally can be applied to the textured surface prior to rendering the image with picture elements (pixels) of a display device. Images in computer graphics are represented as a 2-D array of discrete values (grey scale) or as three 2-D arrays of discrete values (color). Using a standard (x, y, z) rectangular coordinate system, a surface can be specified as a mesh (e.g., triangle mesh) with an (x, y, z) coordinate per mesh vertex, or as a geometry map in which the (x, y, z) coordinates are specified as a rectilinear image over a 2D (u, v) coordinate system, sometimes called the surface parameterization domain. Texture map(s) can also be specified with the (u, v) coordinate system.","Point samples in the surface parametrization domain, where signals have been attached to the surface, including its geometry, can be generated from textured meshes or geometry maps. These samples can be transformed and shaded using a variety of computations. At the end of this transformation and shading processing, a point sample includes (a) positional information, i.e., an image address indicating where in the image plane the point maps to and (b) textured color, or grey scale, information that indicates the color of the sample at the position indicated by the positional information. Other data, such as depth information of the point sample to allow hidden surface elimination, can also be included. The transformed, textured surface is placed in a frame buffer prior to being rendered by a display in 2-D pixel image space (x, y). At this point, in the case of a black and white display device, each (x, y) pixel location in 2-D image space is assigned a grey value in accordance with some function of the surface in the frame buffer. In the case of a typical color display device, each (x, y) pixel location in 2-D image space is assigned red, green and blue (RGB) values. It is noted that a variety of color formats other than RGB exist as well.","In order to render the surface on the display device itself, conventionally, the textured surface is sampled at positions that reflect the centers of the pixels of the device on which the image is to be displayed. This sampling may be performed by evaluating a function of the transformed, textured surface, at points that correspond to the center of each pixel, by mapping the centers of the pixels back into texture space to determine the point sample that corresponds to the pixel center.","Having described an exemplary texture mapping process,  illustrates that present graphics coprocessing subsystem architectures do not accommodate the storage and manipulation of texture maps in video memory by a vertex shader VS. Presently, vertex buffer VB, the video memory allocated for use with the vertex shader VS, can store whole sets of integers, which is suitable for processing of vertex, or positional information. Vertex buffer VB is thus well suited for storing positional information associated with vertices of a geometry map, but vertex buffer VB cannot presently store, or output, float data precise enough to represent a texture map meeting the requirements for today's graphics pipelines and output devices. Since vertex shader VS generally operates with respect to vertex data, i.e., positional information, sufficient precision to handle the colorization requirements of a texture map has generally not been a concern at the vertex shading stage. Thus, vertex buffer VB does not presently support float data inputs or outputs. However, there are a variety of operations and transformations that can be applied at the vertex shading stage for which float precision would be desirable. More particularly, 32 bit float precision would be desirable for supporting texture storage and processing by vertex shader VS, in keeping with the evolution of the graphics pipeline including the appearance of high precision monitors that have support for 10 bit rasterization, as opposed to a conventional 8 bit rasterization, processes.","It would be further desirable to increase the number of registers available on a vertex shader for use by a vertex shader during operation as input, output, intermediate and other special purpose storage. For instance, a program downloaded to the vertex shader could benefit from increased amount of register storage available on the vertex shader for more variables, temporary storage, outputs, etc. Presently, the number of register storage elements in a vertex shader VS is limited to 12.","It would be further desirable to increase the number of instructions that can be accommodated in a program to be downloaded to a vertex shader. Presently, the number of instructions that can be downloaded as a program to a vertex shader via the 3D graphics API is 96. One of ordinary skill can appreciate that the complexity of algorithms to be performed by the vertex shader VS is limited by this limit of instructions. Thus, it would be desirable to raise the bar from the current maximum number of instructions that can be packaged for execution by a vertex shader VS.","With respect to the processing of multiple vertex streams simultaneously, prior art vertex shaders are invoked once per vertex, i.e., with every invocation of the vertex shader, the input registers are initialized with unique vertex elements from the incoming vertex streams. Thus, as illustrated in , with older shader models, a vertex data point is input from each of vertex data streams VDS and VDS to load the input registers I to Ik for each \u201ccycle\u201d of the vertex shader VS. While the processing of multiple vertex data streams, or containers, simultaneously in parallel is advantageous in its own right, not all algorithms are well suited to processing parallel data streams by processing a data point from each data stream upon each operational cycle of the vertex shader VS. For instance, at the cycle designated by start time t, vertex data point V and W are input to the appropriate input registers of vertex shader VS for processing and corresponding output. At the start of the next cycle, at time t, vertex data point V and W are input to the appropriate input registers of vertex shader VS for processing and corresponding output, and so on. However, currently, a program downloaded to vertex shader VS can not process two vertex data points from vertex data stream VDS, then process one vertex data point from vertex data stream VDS, then two from VDS, then one from VDS, and so on, repetitively. Thus, it would be desirable to provide support for division of inputs from multiply specified data streams for processing by the vertex shader VS. More particularly, when multiple data streams are input to a vertex shader VS, it would be desirable to specify frequencies for each data stream input which determine how often data from each respective stream is input to the vertex shader VS.","On the pixel shader side of the graphics pipeline, there are also several ways in which improvement may be achieved. Similar to vertex shaders, for instance, a program can be downloaded to current pixel shaders via a graphics API for execution by the pixel shader generally for specialized operations on pixels. In this regard, the number of local registers provided for use with the pixel shader and the maximum number of instructions that may be provided for a program downloaded to the pixel shader currently limit the complexity and sophistication of operation that can be achieved with a downloaded program. The number of local registers currently available for use in connection with operation of a pixel shader is 6-12 and the maximum number of instructions that a program may include if it is to be downloaded to a pixel shader is 256. Thus, it would be desirable to increase the number of local registers provided on a pixel shader. It would also be desirable to increase the maximum number of instructions that may be associated with a program to be downloaded to a pixel shader.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 5A","FIG. 5B"],"b":["1","2","3"]},"Additionally, the pixel shader side of the graphics pipeline is even more limited than the vertex shader side with respect to branching, i.e., flow control, in programs. While programs, i.e., algorithmic element(s) packaged as tokenized set(s) of instructions, currently can be downloaded to a pixel shader, the flow represented by a program performed by the pixel shader PS must be static, non-branched and not predicated upon characteristics that become known at runtime. Thus, for instance, as illustrated in , a developer D (or a software application A) can specify a program P having exemplary instructions I to I to a graphics API GAPI for download to the graphics chip, such as pixel shader PS, in order to program the graphics chip to perform the algorithms represented by the program P. Once the program P is downloaded to pixel shader PS, i.e., once pixel shader PS is programmed with program P, graphics data processed by pixel shader PS must be processed according to the algorithms I\u2032 to I\u2032 represented by or corresponding to instructions I to I. However, presently, there can be no branching taking place, whether based upon a characteristic or variable set or generated during operation of the runtime system or not.","While the ability to define a static non-branched process flow for all graphics data to be processed according to algorithms I\u2032 to I\u2032 on the pixel shader is beneficial, branching behavior is an important and powerful programming tool and thus it would be desirable to provide both static branching behavior based upon pre-set characteristics of the system, as well as dynamic branching behavior based upon runtime characteristics, for programs downloaded to pixel shaders.","As illustrated in , represented by the arrows illustrating the computational flow process performed on the graphics data, the processing that occurs for each data point of the graphics data streamed through the pixel shader's execution engine is limited to being processed according to algorithm (or function) I\u2032, followed by being processed according to algorithm I\u2032, followed by being processed according to algorithm I\u2032, followed by being processed according to algorithm (or function) I\u2032, and lastly by being processed according to algorithm I\u2032 before being output. In this regard, all of the graphics data must be processed in this exact static sequence, i.e., some of the data cannot be processed according to a different sequence or branch. More particularly, the graphics data cannot currently be processed according to different branches of program P, e.g., an \u201cIf Then\u201d or \u201cIf Then Else\u201d command or structure cannot be deployed, and no different branches can be staticly defined prior to downloading the program either.","Accordingly, it would be desirable to provide both static and dynamic flow control for programs that are downloaded to a pixel shader, whereby a coprocessor can receive a program which thereby programs the coprocessor to process data according to branches and conditions defined by the program, and wherein the coprocessor can process data differently according to the different branches defined by the program. For instance, according to criteria specified in the program, it would be desirable to process some of the data streaming through the coprocessor according to a first algorithm dependent upon the presence of a pre-set constant, or variable set or generated at runtime, and some of the data according to a second algorithm without recourse to downloading another program. In short, it would be desirable to enable branching to occur during the execution of a program once downloaded to the pixel shader to predicate control of the processing of graphics data on preset or runtime characteristics or variables.","In view of the foregoing, the present invention provides systems and methods for downloading algorithmic elements to a coprocessor and corresponding processing and communication techniques. For an improved graphics pipeline, the invention provides a class of co-processing device, such as a graphics processor unit (GPU), providing improved capabilities for an abstract or virtual machine for performing graphics calculations and rendering. The invention allows for runtime-predicated flow control of programs downloaded to coprocessors, allowing significantly more sophisticated effects and algorithms to be implemented. The invention enables coprocessors to include indexable arrays of on-chip storage elements that are readable and writable during execution of programs. By providing for float storage in vertex buffer storage associated with a vertex shader, the invention provides native support for textures and texture maps and corresponding operations. The invention further provides frequency division of vertex streams, so that multiple vertex data streams may be input to a vertex shader in parallel, but the respective data of the respective data streams need not be consumed by the execution engine of the vertex shader VS at the same frequency, or rate. Each stream may have an associated stream modulo value too. For pixel shaders, the invention provides a register storage element on a pixel shader and associated interfaces for storage associated with representing the \u201cface\u201d of a pixel, i.e., whether it is a frontward facing pixel or a backward facing pixel. The invention further provides vertex shaders and pixel shaders with more on-chip register storage and the ability to receive larger programs than any existing vertex or pixel shaders, providing increased programming flexibility. The invention still further provides  bit float number support in both vertex and pixel shaders.","Other features of the present invention are described below.","Overview","As mentioned in the background, current 3D graphics chips on the market can be made more flexible and efficient, with respect to both vertex shaders and pixel shaders.","For programs downloaded to vertex shaders, the invention enables branching to occur dynamically during the execution of the programs predicating control of the processing of graphics data characteristics or variables that are set or generated at runtime. The invention further enables programs downloaded to a vertex shader to index readable\/writable input and output registers of the vertex shader, which in turn enables looping or recursive behavior to be specified in programs. The invention further provides vertex buffers associated with vertex shaders with support for float data inputs or outputs, including 32 bit float precision and storage support for texture maps in the vertex buffer. The invention still further provides 96 registers for vertex shaders and a max instruction count of 512 for a program downloaded to a vertex shader, representing increased flexibility over more constrictive prior art systems. The invention still further provides for controlled division of inputs from multiply specified data streams for processing by a vertex shader by enabling the specification of frequencies for each data stream input that determine how often data from each respective stream is input to the vertex shader.","For pixel shaders, the invention provides 6-12 temporary registers for pixel shaders and a max instruction count of 512 for a program downloaded to a pixel shader, representing increased flexibility over more constrictive prior art systems. The invention also provides a register storage element on a pixel shader and corresponding interfaces for specifying to the execution engine of the pixel shader that an incoming pixel data point is a frontward facing pixel or a backward facing pixel, e.g., to achieve different effects for the front face of a triangle as opposed to the back face of a triangle. The invention also enables static and dynamic flow control for programs that are downloaded to a pixel shader, whereby a coprocessor can receive a program which thereby programs the coprocessor to process data according to branches and conditions defined by the program, and wherein the coprocessor can process data differently according to the different branches defined by the program. For instance, according to criteria specified in the program, the invention enables some of the data streaming through the pixel shader to be processed according to a first algorithm dependent upon the presence of a pre-set constant, or variable set or generated at runtime, and some of the data according to a second algorithm without recourse to downloading another program.","Systems and Methods for Downloading Algorithmic Elements to a Coprocessor","I. Vertex Shaders","As mentioned in the background, existing vertex shaders do not support runtime predicated dynamic flow control of programs. Thus, as illustrated in , the invention enables a program to be defined with branches according to variables or context, e.g., conditions a or b, that will be known at runtime. In the exemplary program P depicted in , after instruction , the program specifies that if runtime behavior a is present, instruction  will be processed next, followed by instruction , and so on. After instruction , the program specifies that if runtime behavior b is present instead, instruction  will be processed next, followed by instruction , etc. The representational flow of this branching behavior of program P loaded into vertex shader VS is depicted in . The graphics data is processed according to either runtime behavior a\u2032 (corresponding to condition a in program P) or behavior b\u2032 (corresponding to condition b in program P), and a programmer, looking ahead to the runtime environment, can dynamically control the flow or branching behavior associated with a program P for processing graphics data input to vertex shader VS. Providing more flexibility in program definition, the invention thus enables each graphics data point input to vertex shader VS to be processed uniquely according to the dynamic flow.","Exemplary non-limiting syntax for achieving existing static flow and dynamic flow in accordance with the invention for vertex shaders is as follows:\n\n","The src param (BOOL register) accepts a NOT modifier. IF can be nested up to 24 times (24 deep).\n\n","Calls can be nested 4 times (4 deep). CALLNZ (predicated and the non-predicated varieties) count to this limit.\n\n","Calls can be nested 4 deep. CALLNZ (predicated) and CALL count to this limit. The BOOL register accepts only the NOT modifier.\n\n","Loops can be nested  deep (counting rep-endrep).\n\n","Rep-loops can be nested  deep (counting loop-endloop).\n\n","For dynamic flow control, the following exemplary instructions (and corresponding exemplary non-limiting restrictions) may be used:\n\n","The IFC instruction is used to skip a block of code, based on a condition. IFC block must end with ELSE or ENDIF instruction. IFC takes 2 slots. ifc-else-endifs (along with the predicated if blocks) can be nested up to 24 times (24 deep). SRC and SRC utilize a replicate swizzle. IFC-blocks do not straddle a loop block; an IFC-block should be either completely inside the loop block or surrounding the loop block.\n\n","The IF instruction is used to skip a block of code, based on a channel of the predicate register. An IF block ends with an ELSE or ENDIF instruction. IF-blocks can be nested. This counts to the total dynamic nesting depth along with IFC-blocks. An IF-block does not straddle a loop block, i.e., an IF-block should be either completely inside a loop block or surrounding the loop block. Not modifiers are allowed on the predicate channel.\n\n","The BREAKP opcode takes 2 instruction slots. A NOT modifier is allowed.\n\n","The BREAKC opcode takes 2 instruction slots.\n\n","The BREAK opcode takes 1 instruction slot.\n\n","The CALLNZ instruction performs a conditional call based on the predicate channel. A NOT modifier can be applied. The instruction consumes one instruction slot. CALLNZ Calls can be nested 4 deep. This counts to the total CALL\/CALLNZ depth. The predicate register accepts the NOT modifier.","As mentioned with respect to , vertex shaders VS also lack readable and writable register storage that is indexable by commands of a program downloaded to vertex shader VS. As illustrated in , vertex shader VS of the invention includes indexable input registers I[] to I[k\u22121] and output registers O[] to O[m\u22121]. Thus, as illustrated in , a developer can write a program P that specifies operations for an entire bank of register storage by index. Previously, a separate instruction would be required for each register to be affected by the indexed command, whereas the indexing enables an operation to be performed across an array of (non-constant) storage elements. Thus, for the exemplary program P shown, three operations are performed wherein an index value i increments from 0 to 2, simultaneously expressing multiple operations to be performed with the simple indexed command: O[i]=2*I[i].","As mentioned, with earlier shader models, only the constant register bank could be indexed. In one non-limiting embodiment, the shader model of the invention additionally enables the following register banks to be indexed using a loop counter register (aL): Input registers (I[k]) and Output registers (O[m]). Since O[k] registers can be declared to have various semantics, care is taken indexing them. If indexing of output registers is present in the shader, for instance, the position and psize semantics are declared in O[] and O[], respectively. Thus, it may be undefined to index through O[i] registers that have been declared to have semantics: position and\/or psize.","As implied, output declarations are introduced, whereby semantics are assigned to each register. Old oPos and oPts are replaced by declaring an o register with a position or pointsize semantic, further described below.","In one embodiment, there are 12 \u201cout\u201d registers. 10 of them (any 10, not necessarily o[]-o[]) have 4-components (x, y, z, w), another one is declared as position (all 4 components), and optionally one more can be a scalar pointsize.","In one non-limiting embodiment, the syntax for declaring outputs (O# registers) is similar to declarations for the inputs, as follows:\n\n","A similar set of semantics as for the input declaration can be used. Semantic names come from the enum D3DDECLUSAGE (and are paired with an index, e.g., position). As mentioned, there is one O# register with _position declaration when not used for processing vertices. The position semantic and the pointsize semantic are have meaning to the graphics API GAPI, beyond simply enabling linkage from vertex to pixel shaders. For instance, for shaders with flow control, it is assumed that the worst case output is declared (dcl'd) because there are no defaults if a shader does not actually output what it declares it should due to flow control.\n\n","The same \u201cout\u201d register may be dcl'd multiple times so that different semantics can be applied to individual components, each time with a unique write mask. However, the same semantic may not be used multiple times in a declaration. Thus, vectors are 4 components or less, and do not transcend 4-component register boundaries (individual \u201cout\u201d registers). When the _pointsize semantic is used, it includes full write mask since it is considered a scalar. When the _position semantic is used, it includes full write mask since all 4 components are written.","Exemplary use scenarios for the above-described are as follows:",{"@attributes":{"id":"p-0077","num":"0136"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["vs_3_0 dcl_color4 o3.xyz","\/\/ color4 is a semantic name"]},{"entry":["dcl_texcoord3 o2.xyz dcl_fog","\/\/ different semantics can be"]},{"entry":["o2.w","\/\/ packed into one register."]},{"entry":["dcl_tangent o4.xyz dcl_position","\/\/ position is declared"]},{"entry":["o7.xyzw","\/\/ to some unique register in a"]},{"entry":[{},"\/\/ vertex shader,"]},{"entry":[{},"\/\/ with all 4 components."]},{"entry":[{},"\/\/ (when ProcessVertices is not used)"]},{"entry":["dcl_psize o6","\/\/ Pointsize does not have a mask"]},{"entry":[{},"\/\/ (i.e., mask is full - xyzw) ->"]},{"entry":[{},"\/\/ this is an implied scalar"]},{"entry":[{},"\/\/ register."]},{"entry":[{},"\/\/ No other semantics are"]},{"entry":[{},"\/\/ assigned to any components"]},{"entry":[{},"\/\/ of this register."]},{"entry":[{},"\/\/ If pointsize declaration is"]},{"entry":[{},"\/\/ NOT used (typical), then"]},{"entry":[{},"\/\/ only 11 \u201cout\u201d registers are"]},{"entry":[{},"\/\/ available, not 12."]},{"entry":[{},"\/\/ Pixel shaders do not see this"]},{"entry":[{},"\/\/ value."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Since dynamic branching can take place, as described above, there is a potential for varying outputs per vertex. The output of the shader can also vary with static flow control.",{"@attributes":{"id":"p-0079","num":"0138"},"figref":"FIG. 9"},"With the increased precision of float representation of textures for look up by a vertex shader VS, the invention enables displacement maps to be applied to data. Displacement maps represent perturbations in positional information with a high degree of precision. While a texture map can create a rough appearance of a surface, the geometry itself may appear undesirably smooth at the edges. Accordingly, a displacement map can perturb the geometry itself to create a more realistic \u201crough\u201d effect. Previously, vertex shaders did not include storage support for the float precision required of a displacement map, and thus displacement maps are an example of the kind of increased flexibility that the graphics API of the present invention provides developers.","Also, a new register has been introduced in vertex shader VS\u2014the sampler register that represents the vertex texture sampler. This register is defined in the shader before using it via graphics API GAPI. An application can query if a format is supported as a vertex texture by calling CheckDeviceFormat( ) with the D3DUSAGE_QUERY_VERTEXTEXTURE flag. A vertex texture created in POOL_DEFAULT can be set as a pixel texture and vice versa. In one embodiment, to use the software vertex processing, the vertex texture is created in the POOL_SCRATCH (regardless of whether it is a mixed mode device or a software vertex processing device).","In one non-limiting embodiment, the functionality is similar to the functionality of pixel textures except for the following: (A) Anisotropic texture filtering is not supported. Hence D3DSAMP_MAXANISOTROPY is ignored and D3DTEXF_ANISOTROPIC cannot be set for neither MAGFILTER nor MINFILTER for these stages and (B) Rate of change information is not available, and hence the application computes the level of detail (LOD) and provides that information as a parameter to the TEXLDL instruction.","In various non-limiting alternate embodiments, similar to pixel textures, if MET textures are supported for vertex textures, D3DSAMP_ELEMENTINDEX is used to figure out from which element to sample. The state D3DSAMP_DMAPOFFSET is ignored for these stages. Not all texture formats may be supported as vertex textures. Formats that support D3DUSAGE_QUERY_VERTEXTEXTURE can be used as vertex textures. The application can query whether support exists for a particular texture format with the CheckDeviceFormat( ) API.","In various other non-limiting alternate embodiments, a caps field D3DCAPS9.VertexTextureFilterCaps indicates what kinds of filters are legal at the vertex texture samplers. D3DPTFILTERCAPS_MINFANISOTROPIC and D3DPTFILTERCAPS_MAGFANISOTROPIC are disallowed. Applications should also query if a format is supported as cube\/volume at a vertex texture sampler. Also, there are no wrap modes for vertex texture coordinates since there is no connectivity information available inside a vertex shader.","A sampling stage register S# identifies a sampling unit that can be used in texture load statements. A sampling unit corresponds to the texture sampling stage, encapsulating the sampling-specific state provided in the SetSamplerState( ) API. In one embodiment, there are 4 vertex samplers.","Each sampler uniquely identifies a single texture surface which is set to the corresponding sampler using the IDirect3DDevice9::SetTexture(I, IpTexture) method. However, the same texture surface can be set at multiple samplers.","At draw time, a texture is not simultaneously set as a RenderTarget and a texture at a stage. In the embodiment wherein there are 4 samplers supported, up to 4 texture surfaces may be read from in a single shader pass. A sampler register may appear as an argument in the texture load statement: TEXLDL. In a preferred non-limiting embodiment of the invention, if a sampler is used, it is declared at the beginning of the shader program using a DCL statement.","The ability to perform texture look ups with vertex shaders VS in accordance with the invention also supports software transformation and lighting (T&L). The software T&L filter types supported can be checked by looking at the D3DCAPS9.VertexTextureFilterCaps field in the caps structure obtained by a call to the IDirect3DDevice9::GetDeviceCaps( ) API in the software mode. Published texture formats are supported as vertex textures in software vertex processing.","An application can check if a particular texture format is supported in the software vertex processing mode by calling CheckDeviceFormat( ) and providing (D3DUSAGE_QUERY_VERTEXTEXTURE|D3DUSAGE_SOFTWAREPROCESSING) as usage. All formats are supported for software vertex processing. POOL_SCRATCH may be used for software vertex processing.","Exemplary non-limiting API calls and syntax for achieving the above-described texture operations with vertex shaders VS include:",{"@attributes":{"id":"p-0091","num":"0150"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ New Define"},{"entry":"#define D3DVERTEXTEXTURESAMPLER (D3DDMAPSAMPLER+1)"},{"entry":"\/\/ New usage"},{"entry":"#define D3DUSAGE_QUERY_VERTEXTEXTURE (0x00100000L)"},{"entry":"\/\/ New caps field in D3DCAPS9"},{"entry":"DWORD VertexTextureFilterCaps;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Also, in addition to the changes to the device driver interface (DDI) described below, a new D3DFORMAT_OP_ has been added to DDI such that the drivers use to mark formats that the vertex texture sampler understands. These formats are then allowed to be used as vertex textures (e.g., an application calls CheckDeviceFormat( ) with the usage flag D3DUSAGE_QUERY_VERTEXTEXTURE). In a non-limiting embodiment, the usage flag is defined as follows:\n\n","With respect to output registers, in one embodiment, the various types of output registers are collapsed into 12 output registers O# (2 for color, 8 for texture, 1 for position, and 1 for fog and pointsize). These can be used for anything the user wishes to interpolate for the pixel shader: texture coordinates, colors, fog, etc.","As mentioned, the invention improves upon the number of instruction slots that may be occupied by a program P for download to a vertex shader. In this regard, devices that support the invention support at least 512 instruction slots. The maximum count of slots that is supported is indicated by the cap D3DCAPS9.MaxVertexShader30InstructionSlots. The maximum value that can be set on this cap is 32768. The number of instructions executed can be higher because of the looping support. The 3DCAPS9.MaxVShaderInstructionsExecuted cap applies as well and should be at least 2^16.","The total number of instructions executed can be clamped to the DDI-only render state D3DRS_MAXVERTEXSHADERINST. The legal values for this render state are numbers that are powers of 2; if any other integer is set, the next nearest power of 2 number is assumed. In one embodiment, this defaults to D3DINFINITEINSTRUCTIONS.","Table I below illustrates an exemplary non-limiting implementation of registers for a vertex shader in accordance with the class of virtual machine defined by the invention.",{"@attributes":{"id":"p-0097","num":"0157"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"322pt","align":"center"}},"thead":{"row":{"entry":"TABLE I"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary Non-Limiting Registers and Corresponding Characteristics"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"9"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"9","colwidth":"35pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},{},"#read-",{},{},{},{},"Requires"]},{"entry":["Register Type","Count","r\/w","ports","#reads\/inst","Dimension","RelAddr","Defaults","DCL"]},{"entry":{"@attributes":{"namest":"1","nameend":"9","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"9"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"9","colwidth":"35pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Input(v#)","16","r","1","unlimited","4","aL only","partial(0001)","y"]},{"entry":["Temp (r#)","32","r\/w","3","unlimited","4","n","none","n"]},{"entry":["Float Constant","256","r","1","unlimited","4","y","0000","n"]},{"entry":["(c#)","(at least)"]},{"entry":["Integer Constant","16","r","1","1","4","n","0000","n"]},{"entry":"(i#)"},{"entry":["Bool Constant","16","r","1","1","1","n","FALSE","n"]},{"entry":"(b#)"},{"entry":["Address (a#)","1","u\/w","n\/a","unlimited","4","n\/a","none","n"]},{"entry":["Loop Counter","1","u","n\/a","unlimited","1","n\/a","none","n"]},{"entry":"(aL)"},{"entry":["Sampler (s#)","4","r","1","1","1","n","none","y"]},{"entry":["Output (o)","12","w","n\/a","n\/a","4","aL only","None","y"]},{"entry":{"@attributes":{"namest":"1","nameend":"9","align":"center","rowsep":"1"}}}]}}]}}},"Table I below illustrates an exemplary non-limiting implementation of registers for a vertex shader in accordance with the class of virtual machine defined by the invention.","In Table I, \u201cr\u201d corresponds to Read, \u201cw\u201d corresponds to Write and \u201cu\u201d corresponds to Use. For a partial (x, y, z, w), if only a subset of channels are updated in the register, in one embodiment, the remaining channels default to specified values (x, y, z, w). aL only register banks can be addressed using the aL register.","In Table I, \u201cr\u201d corresponds to Read, \u201cw\u201d corresponds to Write and \u201cu\u201d corresponds to Use. For a partial (x, y, z, w), if only a subset of channels are updated in the register, in one embodiment, the remaining channels default to specified values (x, y, z, w). aL only register banks can be addressed using the aL register.","With respect to exemplary register defaults for a vertex shader, use of uninitialized temporary, address registers may be made illegal, the result being undefined. A runtime debug component may attempt to detect such usage (if there is no dynamic flow control) and return a failure at Draw( ) time. Other defaults are specified in the table above.","With respect to modifiers for a vertex shader, the following modifiers are supported:\n\n","_abs and negate (\u2212) or both (\u2212r0.abs) are supported on reads. If both are present, the abs( ) happens first.","Other instructions supported by a vertex shader in accordance with the invention include:\n\n",{"@attributes":{"id":"p-0105","num":"0177"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"dcl_cube s3;","\/\/ indicates that sampler 3 will look up"]},{"entry":[{},{},"\/\/ a cube map"]},{"entry":[{},"..."]},{"entry":[{},"texldl r0, r3, s3;","\/\/ Also, r3 is expected to have .rgb"]},{"entry":[{},{},"\/\/ initialized, since s3 is declared as a"]},{"entry":[{},{},"\/\/ cube map."]},{"entry":[{},{},"\/\/ All 4 components of r0 are written"]},{"entry":[{},{},"\/\/ with texture lookup result (including"]},{"entry":[{},{},"\/\/ defaults for components missing in"]},{"entry":[{},{},"\/\/ texture format)."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"In one embodiment, the DCL instruction occupies 0 instruction slots, appears before the first arithmetic or addressing instruction in the shader program P and can be intermixed with def instructions (which are the other type of instruction that resides at the beginning of a shader). dst is s# for this type of dcl and a given s# register can only be dcl'd once. The component mask is not specified (same as full mask) and _textureType is one of: 2d, _cube and _volume. TEXLDL\u2014Texture lookup with a provided LOD (see description herein relating to texture look ups in vertex shader)\n\n","The syntax for DCL allows for a write mask. Exemplary syntax for the output registers is as follows:",{"@attributes":{"id":"p-0108","num":"0184"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"dcl_position2, v0.xz"]},{"entry":[{},"dcl_diffuse, v0.y"]},{"entry":[{},"\/\/ Decl for the output"]},{"entry":[{},"dcl_position2, o0.xz"]},{"entry":[{},"dcl_diffuse, o1.y"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Further, input vertex element data is copied to the specified components if a corresponding stream declaration is found. The un-declared components are not set to default values. Components that are specified in the input declaration are referenced in the vertex shader. If a component is declared but is not provided via the vertex declaration, then it assumes the usual default value (x, y, z default to 0 and w to 1). Thus, for the following exemplary input vertex declaration:\n\n","For SINCOS, for an implementation that does not implement sincos natively, taylor coefficients are set up in constants behind the scenes (the 2 extra parameters to sincos are removed, and the user does not need to provide them). Also, components in dest writemask (.x, .y or .xy) are the ones that are touched. Predication of this instruction may be orthogonal. SLT\u2014computes sign if less","With respect to DDI changes to vertex shaders in accordance with the invention, a new DDI only Renderstate is provided:\n\n","The legal values for this renderstate are integers that are powers of 2, and if any other integer is set, the next nearest power of 2 number is assumed. The new DDI only Renderstate Defaults to D3DINFINITEINSTRUCTIONS. Support for this feature involves an additional register, instruction modifier and a new instruction.","With respect to the register, an additional predicate register is supported. This is a boolean vector register that is modified via the Setup instruction defined below in Table II. IN one embodiment, there are no defaults for this register so an application sets it prior to use.",{"@attributes":{"id":"p-0114","num":"0228"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"315pt","align":"center"}},"thead":{"row":{"entry":"TABLE II"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Predicate Register"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"9"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"9","colwidth":"49pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Register Type","Count","r\/w","#read-ports","#reads\/inst","Dimension","RelAddr","Defaults","Requires DCL"]},{"entry":{"@attributes":{"namest":"1","nameend":"9","align":"center","rowsep":"1"}}},{"entry":["Predicate(p#)","1","r\/w","1","1","4","n\/a","none","n"]},{"entry":{"@attributes":{"namest":"1","nameend":"9","align":"center","rowsep":"1"}}}]}}]}}},"The following new instructions are supported.",{"@attributes":{"id":"p-0116","num":"0230"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SETP - Set the predicate register"]},{"entry":[{},"Instruction:"]},{"entry":[{},"setp_cmp dst, src0, src1"]},{"entry":[{},"Format:"]},{"entry":[{},"Op code token D3DSIO_SETP"]},{"entry":[{},"Dest token"]},{"entry":[{},"Source0 token"]},{"entry":[{},"Source1 token"]},{"entry":[{},"Operation:"]},{"entry":[{},"per channel in dest write mask."]},{"entry":[{},"{"]},{"entry":[{},"dst.channel = src0.channel cmp src1.channel;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"For each channel that can be written according to the destination write mask, the boolean result of the comparison operation between the corresponding channels of src and src is saved (after the source modifier swizzles have been resolved). Source swizzles and destination write masks are heeded. In one embodiment, the p register is the Dest token.","An instruction modifier with the predicate is also supported. This instruction modifier costs an additional instruction slot and exemplary non-limiting syntax is as follows:\n\n","The destination write mask may be \u201cand\u201d-ed (joined) with the per channel predicate boolean value and the data written back into the destination (after the usual application of the instruction modifiers), without side effects, i.e., this update does not change the predicate register. Swizzles allowed inside the instruction modifier include full (.xyzw) or replicate (.x, .y, .z, .w). The presence of a (!) inside the modifier reverses the meaning of the predicate bits.","In one non-limiting embodiment, the instruction modifier is syntactically present before the opcode, but in the binary format, it is the tailing token.","In one embodiment, all instructions except the following can be predicated: SETP, IF, ELSE, ENDIF, DCL, DEF, DEFI, DEFB, END, CALL, CALLNZ, RET, LOOP, ENDLOOP, REP, ENDREP, IFC, BREAKC and BREAK.","With respect to predication's interaction with flow control, predication can be used orthogonally with the dynamic and static flow control, described above. IF, CALLNZ and BREAKP accept the predicate register as a parameter also.","As mentioned in the background with respect to , the state of the art currently does not support vertex stream frequency division. Thus, as illustrated in , the invention advantageously supports the ability to specify how often data is input for processing from respective vertex data streams VDS to VDSN, i.e., to specify how many cycles of the execution engine of vertex shader VS are completed before receiving another data point from a designated vertex stream. For instance, as specified via graphics API GAPI, the data of vertex data stream VDS is processed one vertex every cycle, whereas the data of vertex of vertex data stream VDSN is processed one vertex every three cycles. This might be useful, for instance, for processing triangles, which have 3 vertices such that after processing every triangle, a different data point from vertex data stream VDSN is input to the process.","In the older shader models (including the fixed function), the vertex shader was invoked once per vertex; with every invocation, the input registers were initialized with unique vertex elements from the vertex streams. The frequency division feature of the invention advantageously allows a subset of the input registers to be initialized at a less frequent rate.","Two exemplary non-limiting APIs are introduced for the frequency division of vertex streams in accordance with the invention: SetStreamSourceFrequency(UINT StreamIndex, UINT Frequency) and a corresponding Get* method. In one embodiment, the Frequency is a value greater than zero and can be at most 2^16\u22121 (WORD).","The application sets a frequency for a given stream, and the elements in that stream are affected by this value. Frequency is \u201cafter how many vertices is the data from that stream fetched into the vertex processing machine,\u201d i.e., if it is 2, then the data from that stream is fetched into the Vn registers every 2 vertices of processing. In an exemplary embodiment, the vertex offset (in the VB) is computed using the following formula:\n\nVertexOffset=StartVertex\/Divider*StreamStride+VertexIndex\/Divider*StreamStride+StreamOffset\n","It is noted that the division is an integer division, that StartVertex, which is provided in DrawPrimitive calls, is also divided by the frequency divider and the state is recorded in state blocks as vertex state. Stream frequency may be ignored for indexed primitives.","Exemplary non-limiting API changes that support this feature include the following:\n\n","Exemplary non-limiting DDI changes that support this feature include the following:",{"@attributes":{"id":"p-0130","num":"0249"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["D3DDP2OP_SETSTREAMSOURCEFREQ","\/\/ New DP2 Command"]},{"entry":["typedef struct _D3DHAL_SETSTREAMSOURCEFREQ","\/\/ New structure corresponding"]},{"entry":["{","\/\/ with the command"]},{"entry":"UINT StreamID;"},{"entry":"UINT Frequency;"},{"entry":"} D3DHAL_DP2SETSTREAMSOURCEFREQ,"},{"entry":"*LPD3DHAL_DP2SETSTREAMSOURCEFREQ;"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0131","num":"0250"},"figref":"FIG. 10B"},"As mentioned above, the invention includes a method of using a vertex stream frequency divider via a graphics instancing API. The present invention provides an alternate improved method of frequency dividing by adding a stream modulo value. Instead of the frequency divider only applying to non-indexed primitives, as described below in exemplary non-limiting detail, the frequency divider and the modulo are extended to indexed primitives.","The goal of the instancing API is to allow drawing of multiple instances of the same object with different per-instance data in one API call. The following changes have been made to the API to achieve this:\n\n","When using the instancing API the primitive count is usually equal to the number of instances multiplied to the number of primitives per instance. There is no reset of the primitive during a drawing call.","Exposing the Support of the New API","A new cap D3DVTXPCAPS_STREAMMODULO is introduced to expose the modulo support.","The stream divider\/modulo is ignored when the fixed function vertex pipeline or a vertex shader prior to the invention is used.\n\n","When the D3DSTREAMSOURCEMODULO bit is set in the Value then it represent a modulo value instead of a divider.",{"@attributes":{"id":"p-0138","num":"0000"},"ul":{"@attributes":{"id":"ul0025","list-style":"none"},"li":"SetStreamSourceFreq(0, 100|D3DSTREAMSOURCEMODULO);"}},"The modulo is a positive non-zero value.","For indexed primitives any number of streams can have a modulo assigned to them and these values can be different.","For indexed primitives all modulo values, assigned to streams, are the same. The stream dividers is a multiple of the modulo value.","Non-Indexed Primitives",{"@attributes":{"id":"p-0142","num":"0000"},"ul":{"@attributes":{"id":"ul0026","list-style":"none"},"li":"DrawPrimitive(PrimitiveType, StartVertexIndex, PrimitiveCount)"}},"The vertex offsets for each stream are computed according to the following pseudo-code:",{"@attributes":{"id":"p-0144","num":"0267"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"NumVertices = f(PrimitiveCount, PrimitiveType);"},{"entry":"for (Counter=0; Counter < NumVertices; Counter++)"},{"entry":"{"},{"entry":"If (a stream is marked as having a modulo)"},{"entry":"{"},{"entry":"\u2003\u2003VertexIndex = StartVertex + (Counter % StreamDivider)"},{"entry":"}"},{"entry":"else"},{"entry":"{"},{"entry":"\u2003\u2003VertexIndex = (StartVertex + Counter) \/ StreamDivider;"},{"entry":"}"},{"entry":"VertexOffset = VertexIndex * StreamStride + StreamOffset;"},{"entry":"}"},{"entry":"Indexed primitives"},{"entry":"DrawIndexedPrimitive ("},{"entry":"\u2003PrimitiveType,"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003BaseVertexIndex,","\u2002\/\/ Vertex, which corresponds to index 0"]},{"entry":["\u2003StartVertex,","\u2002\/\/ Vertex, which corresponds to the min index"]},{"entry":[{},"\u2002\/\/ value in the index buffer"]},{"entry":["\u2003NumberOfVertices,","\/\/ Number of vertices, used in an instance of an"]},{"entry":[{},"object"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003StartIndex,\u2003\u2003\/\/ Start index in the index buffer"},{"entry":"\u2003PrimitiveCount\u2003\u2002\/\/ Number of primitives in an instance"},{"entry":")"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"The vertex offsets for each stream are computed according to the following pseudo-code:",{"@attributes":{"id":"p-0146","num":"0269"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"NumIndices = f(PrimitiveCount, PrimitiveType);"},{"entry":"for (Counter=0; Counter < NumIndices; Counter++)"},{"entry":"{"},{"entry":"\u2003If (a stream is marked as having a modulo || StreamDivider == 1)"},{"entry":"\u2003{"},{"entry":"\u2003\u2003VertexIndex = BaseVertexIndex + IndexBuffer[StartIndex +"},{"entry":"\u2003(Counter % StreamDivider)]"},{"entry":"\u2003}"},{"entry":"\u2003else"},{"entry":"\u2003{"},{"entry":"\u2003\u2003VertexIndex = (StartVertex + Counter) \/ StreamDivider;"},{"entry":"\u2003}"},{"entry":"\u2003VertexOffset = VertexIndex * StreamStride + StreamOffset;"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}],"ul":{"@attributes":{"id":"ul0027","list-style":"none"},"li":["A triangle list is used.","An object instance has NVER vertices.","The number of instances of N.","Stream  has NVER vertex positions of an object","Stream  has NVER vertex normals of an object.","Stream  has N matrices. Each matrix is applied to an instance of an object.","SetStreamSourceFreq(, NVER|D3DSTREAMSOURCEMODULO);","SetStreamSourceFreq(, NVER|D3DSTREAMSOURCEMODULO);","SetStreamSourceFreq(, NVER);","DrawPrimitive(D3DPT_TRIANGLELIST, , N * (NVER\/3));\n\nIndexed Primitive\n","An indexed triangle list is used.","An index stream NINDEX indices.","An object instance has NVER vertices.","The number of instances of N.","Stream  has NVER vertex positions of an object","Stream  has NVER vertex normals of an object.","Stream  has N matrices. Each matrix is applied to an instance of an object.","SetStreamSourceFreq(, NINDICIES|D3DSTREAMSOURCEMODULO);","SetStreamSourceFreq(, );","SetStreamSourceFreq(, NINDICES);","DrawIndexedPrimitive(D3DPT_TRIANGLELIST, ,,NVER,N*(NINDICES\/3));"]}},"It is noted that the stream  is indexed, because the divider value is equal to one. The stream  is not indexed.","Table III shows how slot counts for vertex shaders have evolved to the point of the present invention, wherein model and model refer to previous shader models for comparison, as follows:",{"@attributes":{"id":"p-0149","num":"0293"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE III"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary Vertex Shader Instruction Slot Consumption"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"70pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Instruction","model1","model2","the invention"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]},{"entry":[{},"Total","256\u2003","256\u2003","512(min)"]},{"entry":[{},"abs","1","1","1"]},{"entry":[{},"add","1","1","1"]},{"entry":[{},"break","n\/a","1","1"]},{"entry":[{},"breakc","n\/a","3","3"]},{"entry":[{},"breakp","n\/a","3","3"]},{"entry":[{},"call","2","2","2"]},{"entry":[{},"callnz b","3","3","3"]},{"entry":[{},"callnz p","n\/a","3","3"]},{"entry":[{},"crs","2","2","2"]},{"entry":[{},"dcl","n\/a","n\/a","n\/a"]},{"entry":[{},"def","n\/a","n\/a","n\/a"]},{"entry":[{},"defi","n\/a","n\/a","n\/a"]},{"entry":[{},"defb","n\/a","n\/a","n\/a"]},{"entry":[{},"dp3","1","1","1"]},{"entry":[{},"dp4","1","1","1"]},{"entry":[{},"dst","1","1","1"]},{"entry":[{},"else","1","1","1"]},{"entry":[{},"endif","1","1","1"]},{"entry":[{},"endloop","2","2","2"]},{"entry":[{},"endrep","2","2","2"]},{"entry":[{},"exp","1","1","1"]},{"entry":[{},"expp","1","1","1"]},{"entry":[{},"frc","1","1","1"]},{"entry":[{},"if b","3","3","3"]},{"entry":[{},"if p","n\/a","3","3"]},{"entry":[{},"ifc","n\/a","3","3"]},{"entry":[{},"label","0","0","0"]},{"entry":[{},"lit","3","3","3"]},{"entry":[{},"log","1","1","1"]},{"entry":[{},"logp","1","1","1"]},{"entry":[{},"loop","3","3","3"]},{"entry":[{},"lrp","2","2","2"]},{"entry":[{},"m3\u00d72","2","2","2"]},{"entry":[{},"m3\u00d73","3","3","3"]},{"entry":[{},"m3\u00d74","4","4","4"]},{"entry":[{},"m4\u00d73","3","3","3"]},{"entry":[{},"m4\u00d74","4","4","4"]},{"entry":[{},"mad","1","1","1"]},{"entry":[{},"max","1","1","1"]},{"entry":[{},"mov","1","1","1"]},{"entry":[{},"mova","1","1","1"]},{"entry":[{},"min","1","1","1"]},{"entry":[{},"mul","1","1","1"]},{"entry":[{},"nop","1","1","1"]},{"entry":[{},"nrm","3","3","3"]},{"entry":[{},"pow","3","3","3"]},{"entry":[{},"rcp","1","1","1"]},{"entry":[{},"rep","3","3","3"]},{"entry":[{},"ret","1","1","1"]},{"entry":[{},"rsq","1","1","1"]},{"entry":[{},"setp","n\/a","1","1"]},{"entry":[{},"sge","1","1","1"]},{"entry":[{},"sgn","3","3","3"]},{"entry":[{},"sincos","8","8","8"]},{"entry":[{},"slt","1","1","1"]},{"entry":[{},"texldl","n\/a","n\/a","2+3CUBE"]},{"entry":[{},"ALL:",{},"PRED+1","PRED+1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"As mentioned in the background in connection with , a face register is not currently available for use in connection with a pixel shader. Thus, as illustrated in , a pixel shader PS in accordance with the invention, in addition to including constants, input and output registers, etc. also includes a face register FR. As illustrated in , this enables a program P downloaded to pixel shader PS to operate upon pixels in a way that takes its face, whether forward or backward, into account. This enables a shader program P, for instance, to perform one sided, or double sided lighting effects. In one embodiment, the face register is a floating point scalar register that may contain the primitive area, or appropriate sign. Using the appropriate sign, if the value is less than zero (sign bit is set, negative) the primitive is the back face (the area is negative, CounterClockwise). Hence, inside the pixel shader, the application can make a decision as to which lighting technique to use. Two-sided lighting can be achieved this way. In one embodiment, this register requires a declaration, e.g., by the setup engine SE or graphics API GAPI. The register FR may be undefined for lines and point primitives. The face register FR can be used with the setp and ifc instructions (as one half of a comparison). In embodiments relying on the sign of the bit, it makes sense to compare this register against 0 (>0, or <0).","A position register is also provided for pixel shaders in accordance with the invention, including the current pixels (x, y) in the corresponding channels. The (z, w) channels are undefined. This register is declared. When multisampling, the (x, y) contain the pixel coordinates and not the sample coordinate (multisampling happens once per pixel). When the driver performs super sampling and the pixel shader is run multiple times per pixel, the (x, y) should contain the resolved coordinate, that is, normalized by the render-target bloat factor.","The Boolean and integer constants for pixel shaders in accordance with the invention can be set using an API defined in accordance with the invention, and described in more detail below.","With respect to pixel shader input registers, The input registers for pixel shaders in accordance with the invention fully support floating point and the t# registers have been consolidated into the input registers. The DCL at the top of the shader is used to describe what is contained in a particular input register, and a semantic for the pixel types is introduced. No clamping is performed when the input registers are defined as colors (like texture coordinates). The evaluation of the registers defined as color differs from the texture coordinates when multisampling. These registers can be indexed using the aL register.","Exemplary declaration syntax is as follows:\n\n","The same set of semantics as for the vertex shader output declaration can be used. Semantic names come from the enum D3DDECLUSAGE (and are paired with an index, i.e. position). The \u201cposition\u201d semantic (position) and the pointsize semantic are not available for pixel shaders. For pixel shaders with flow control, it is assumed that the worst case input is dcl'd, and that there are no defaults if a VS does not actually output what it declares in the input of the pixel shader.","The declarations can have write masks, e.g., as follows:\n\n","Write masks allow packing of attributes. However, the packing should match the vertex shader output declaration. Multiple semantics may be defined for individual input registers, as long as the component masks are non-overlapping. In one embodiment, there are no defaults for missing components, and it is validated that vertex shaders output at least enough data for what is requested by the corresponding pixel shader.","An optional instruction modifier that can be applied to the DCL instruction is _centroid. Exemplary use of the _centroid modifier is as follows:",{"@attributes":{"id":"p-0159","num":"0306"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["dcl_fog v0.x dcl_tangent_centroid v0.yzw","\/\/ multiple semantics can be"]},{"entry":[{},"\/\/ packed into one register"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"To achieve flat shading, when D3DRS_SHADEMODE is D3DSHADE_FLAT, during clipping and triangle rasterization, attributes with D3DDECLUSAGE_COLOR are interpolated as flat shaded. If any components of a register are declared with the semantic name color#, but other components of the same register are given different semantics, then turning on flat shading may result in undefined interpolation (linear vs. flat) on the components in that register with associated semantics other than color.","With respect to pixel shader output registers in accordance with the invention, exemplary non-limiting behavior is as described as follows. Output registers oC# and oDepth can be written any number of times in accordance with the invention. The output of the pixel shader comes from the contents of the output registers at the end of shader execution. If a write to an output register does not happen, perhaps due to flow control or if the shader did not write it, the corresponding rendertarget is also not updated. If a subset of the channels in an output register are written, then undefined values are written to the remaining channels.","Additionally, the oC# registers can be written with any writemasks in accordance with the invention. The renderstates D3DRS_COLORWRITEENABLE, D3DRS_COLORWRITEENABLE1, D3DRS_COLORWRITEENABLE2 and D3DRS_COLORWRITEENABLE3 determine which components of oC# ultimately get written to the rendertarget (after blend, if applicable). If the shader writes some, but not all of the components defined by the D3DRS_COLORWRITEENABLE* renderstates for a given oC# register, then the defined but unwritten channels produce undefined values in the corresponding rendertarget. If NONE of the components of an oC# are written, the corresponding rendertarget is not updated (as stated above), so the D3DRS_COLORWRITEENABLE* renderstates do not apply in such case.","Table IV below illustrates an exemplary non-limiting implementation of registers for a pixel shader in accordance with the class of virtual machine defined by the invention.",{"@attributes":{"id":"p-0164","num":"0311"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"315pt","align":"center"}},"thead":{"row":{"entry":"TABLE IV"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary Non-Limiting Registers and Corresponding Characteristics"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"9"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"9","colwidth":"35pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},{},"#read-",{},{},{},{},"Requires"]},{"entry":["Register Type","Count","r\/w","ports","#reads\/inst","Dimension","RelAddr","Defaults","DCL"]},{"entry":{"@attributes":{"namest":"1","nameend":"9","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"9"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"9","colwidth":"35pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Temp (r#)","32","r\/w","3","unlimited","4","n","none","n"]},{"entry":["Input(v#)","10","r","1","unlimited","4","aL only","none","y"]},{"entry":["Float Constant (c#)","224","r","1","unlimited","4","n","0000","n"]},{"entry":["Integer Constant","16","r","1","1","4","n","0000","n"]},{"entry":"(i#)"},{"entry":["Bool Constant (b#)","16","r","1","1","1","n","FALSE","n"]},{"entry":["Sampler (s#)","16","r","1","1","4","n","depends*","y"]},{"entry":["Face (vFace)","1","r","1","1","1","n","none","y"]},{"entry":["Position","1","r","1","1","4","n","none","y"]},{"entry":"Input(vPos)"},{"entry":["Loop Counter (aL)","1","u","n\/a","unlimited","1","n\/a","none","n"]},{"entry":"Output Registers:"},{"entry":["Color (oC)","#MRT**","w","0","0","4","n","none","n"]},{"entry":["Depth (oDepth)","1","w","0","0","1","n","none","n"]},{"entry":{"@attributes":{"namest":"1","nameend":"9","align":"center","rowsep":"1"}}}]}}]}}},"In Table IV, \u201cr\u201d corresponds to Read, \u201cw\u201d corresponds to Write and \u201cu\u201d corresponds to Use. For a partial (x, y, z, w), if only a subset of channels are updated in the register, in one embodiment, the remaining channels default to specified values (x, y, z, w). aL only register banks can be addressed using the aL register.","With respect to pixel shader instruction count, the invention supports at least 512 instruction slots. In one embodiment, the maximum number of slot count that is supported is indicated by the cap D3DCAPS9.MaxPixelShader30InstructionSlots. The maximum value that can be set on this cap is 32768. The maximum number of instructions executed is indicated by the cap D3DCAPS9.MaxPShaderInstructionsExecuted, which is at least 0xffff in accordance with a preferred embodiment. This cap can be set to D3DINFINITEINSTRUCTIONS, indicating that the actual number of instructions executed is unlimited.","The total number of instructions executed can be clamped to the DDI-only renderstate D3DRS_MAXPIXELSHADERINST. The legal values for this renderstate are numbers that are powers of 2; if any other integer is set, the next nearest pow2 number is assumed. This renderstate defaults to D3DINFINITEINSTRUCTIONS and there are no additional dependent read limits. In one embodiment, there is no distinction between texture operations and arithmetic operations.","The following modifiers are supported for pixel shaders in accordance with the invention:\n\n","Swizzles on Samplers: The sampler registers in the texture operations also accept swizzles. This is a way to indicate swizzling of the color channels looked up from the texture by the sampler.\n\n","When set on an input register declaration that is not a \u201ccolor,\u201d \u201cdiffuse\u201d or \u201cspecular\u201d semantic, the attribute evaluation is altered when multisampling. The attribute evaluation defines that the attribute is to be interpolated clamped in some fashion to the gamut of the attribute across the primitive, when the multisample pixel center is not covered by the primitive. Care should be taken when an attribute marked with _centroid is used for texture sampling since normally, the evaluation is performed at the pixel center. This has no effect on input registers with semantic \u201ccolor,\u201d \u201cdiffuse\u201d or \u201cspecular,\u201d i.e., these attributes are always evaluated as if the _centroid modifier is set.","The _centroid modifier can be also set on the texld* instructions and dsx\/dsy instructions. When a texture-coordinate is evaluated at the centroid, the gradient information computed may not be accurate. When this hint is provided, implementations can adjust this gradient computation to be more accurate.","In various embodiments, abs and negate (\u2212) or both (\u2212r.abs) are supported on reads. If both are present, the abs( ) happens first.","As described in connection with  in the background, current pixel shaders cannot support programs that have either staticly defined branching, or dynamically defined branching predicated on runtime behavior. Thus, with respect to the instruction set included in a shader program to be downloaded to a pixel shader in accordance with the invention, the shader program may achieve static flow control, and dynamic flow control, as illustrated in .",{"@attributes":{"id":"p-0174","num":"0326"},"figref":["FIG. 12A","FIG. 12B"],"b":"0"},"With respect to static flow control, the functionality is the same as applies to static flow control for vertex shaders. In one embodiment, the exception to this is that if-else-endif (with boolean) can be nested up to 24-deep.","With respect to dynamic flow control, the functionality is the same as applies to dynamic flow control for vertex shaders. However, in one non-limiting implementation, the output registers (oDepth and oC#) of the pixel shader are not written within dynamic flow control, and cannot be written using predication, though writing to the outputs within static flow control is still alright in this implementation.","Other exemplary pixel shader instructions that may be used in accordance with the invention include:\n\n","The DSX instruction computes the rate of change of a given src register in the x-direction. In one embodiment, the DSX instruction computes gradients on the current contents of registers in pixels, regardless of whether pixels in gradient computation are active, either due to flow control or due to being off the edge of a primitive. This implies that the pixels that are utilized for this instruction are executed in lockstep. Dest Token accepts all write masks. Src Token accepts all swizzles. Src modifiers (negate\/abs\/abs+neg) are not allowed, although the saturate instruction modifier is permitted.\n\n","The DSY instruction computes the rate of change of a given src register in the y-direction. The DSY instruction computes gradients on the current contents of registers in pixels, regardless of whether pixels in gradient computation are active, either due to flow control or due to being off the edge of a primitive. This implies that the pixels that are required for this instruction are executed in lockstep. Dest Token accepts all write masks. Src token accepts all swizzles. Src modifiers (negate\/abs\/absneg) are not allowed, although the saturate instruction modifier is permitted.\n\n","The TEXLDD instruction samples a texture using the texture coordinates at SRC, the sampler specified by Src, and the gradients DSX and DSY coming from SRC and Src. In various embodiments, all sources support arbitrary swizzles and all write-masks are valid on the destination. D3DSAMP_MAXMIPLEVEL and D3DSAMP_MIPMAPLODBIAS are honored. SRC can only be a sampler register.\n\n","For the texture load statement, all sources support arbitrary swizzles. All write-masks are valid on the destination. In one embodiment, the bias value in the TEXLDB instruction can range between [\u221216.0, +15.0], and bias values outside this range produce undefined results.","Kill Pixel: texkill","For the texkill statement, sources support arbitrary swizzles.\n\n","Using provided texture coordinates, the TEXTDL instruction for pixel shaders samples a texture at a particular sampler. The particular LOD being sampled is specified as the 4th component of the texture coordinate. src provides the texture coordinates for the texture sample. src identifies the sampler (s#), where # specifies which texture sampler number to sample. Associated with a sampler are 1) a texture and 2) control state defined by the D3DSAMPLERSTATETYPE enumerant (e.g., D3DSAMP_MINFILTER).","TEXTDL looks up the texture set at the sampler stage referenced by src. The LOD is not computed, simply src.w is the LOD that is selected. This value can be negative in which case the LOD selected is the zero'th one (biggest map) with the MAGFILTER. Since src.w is a floating point value, the fractional value is used to interpolate (if MIPFILTER is LINEAR) between two mip levels. Sampler states MIPMAPLODBIAS and MAXMIPLEVEL are honored.","In one embodiment, if a shader program samples from a sampler that does not have a texture set, then 0001 is obtained in the destination register.","The following exemplary algorithm that the reference rasterizer (refract) follows is provided for reference:",{"@attributes":{"id":"p-0187","num":"0374"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"LOD = src0.w + LODBIAS;"]},{"entry":[{},"if (LOD <= 0 )"]},{"entry":[{},"{"]},{"entry":[{},"LOD = 0;"]},{"entry":[{},"Filter = MagFilter;"]},{"entry":[{},"tex = Lookup( MAX(MAXMIPLEVEL, LOD), Filter );"]},{"entry":[{},"}"]},{"entry":[{},"else"]},{"entry":[{},"{"]},{"entry":[{},"Filter = MinFilter;"]},{"entry":[{},"LOD = MAX( MAXMIPLEVEL, LOD);"]},{"entry":[{},"tex = Lookup( Floor(LOD), Filter );"]},{"entry":[{},"if( MipFilter == LINEAR )"]},{"entry":[{},"{"]},{"entry":[{},"tex1 = Lookup( Ceil(LOD), Filter );"]},{"entry":[{},"tex = (1 \u2212 frac(src0.w))*tex + frac(src0.w)*tex1;"]},{"entry":[{},"}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In general, the texture coordinates should not be scaled by texture size. dst is r# and can accept a writemask. In various non-limiting embodiments, defaults for missing components are either 0 or 1, and depend on the texture format. Refrast source lists the defaults. srcl is s#, with no negate, but it can support swizzle. The s# is dcl'd at the beginning of the shader program.","The number of coordinates required to perform the texture sample depends on how the s# was dcl'd. If it was dcl'd as a cube, a 3 component texture coordinate is used (.rgb). Sampling a texture with lower dimensions than are present in the texture coordinate is allowed, and it is assumed to ignore the extra texture coordinate components. Conversely, sampling a texture with higher dimensions than are present in the texture coordinate cannot be performed.","In various non-limiting embodiments the following conditions apply. If src (texture coordinate) is r#, the components required for the lookup (described above) must have been previously written. Sampling unsigned RGB textures results in float values between 0.0 and 1.0. Sampling signed textures results in float values between \u22121.0 to 1.0. For sampling floating point textures: Float16\u2192MAX_FLOAT16 range preserved and Float32\u2192Max range of pipeline preserved. There is no dependent read limit. Additional instructions for pixel shaders include:\n\n","An implementation that does not support SINCOS natively sets up taylor coefficients in constants behind the scenes. Only components in dest writemask (.x, .y or .xy) are touched and predication of SINCOS is orthogonal.\n\n","With respect to predication, this is the same as for the vertex shader.","API changes for pixel shaders implicated by the invention include:\n\n","DDI changes for pixel shaders implicated by the invention include:",{"@attributes":{"id":"p-0195","num":"0418"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ New Renderstate"},{"entry":"D3DRS_MAXPIXELSHADERINST \/\/ (DWORD) Max number of"},{"entry":"instructions that can be executed."},{"entry":"\/\/ The legal values for this renderstate are integers that are powers of 2;"},{"entry":"\/\/ if any other integer is set, the next nearest pow2 number is assumed."},{"entry":"\/\/ Defaults to D3DINFINITEINSTRUCTIONS"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Software implementations (runtime and ref, for VS and ref for PS) of shaders have some validation relaxed in accordance with the invention, which can be useful for debugging and prototyping purposes.","With respect to pixel shader core precision requirements, the invention supports a mechanism that applications use to choose between full precision and partial precision hardware processing capabilities on hardware that supports this choice.","The pixel shader virtual machine of the invention provides support for 2 levels of precision: Full precision (fp32 or higher); this precision level is required and must be supported by the implementation and Partial precision _pp (fp16=s10e5); this precision level is optional and need not be supported by the implementation.","By default all operations occur at the full precision level; the mechanism for overriding this default is the _pp modifier, which may be used by shader code to indicate areas where the application deems partial precision acceptable, provided that the underlying implementation supports it. Implementations are always free to ignore the modifier and perform the affected operations in full precision.","The _pp modifier can occur in two contexts: (1) On a texture coord decl to enable texture coordinates to be passed to the pixel shader in partial precision form. This allows, for example, the use of texture coordinates to relay color data to the pixel shader, which may be faster with partial precision than with full precision in some implementations. In the absence of this modifier, texture coordinates must be passed in full precision; and (2) On any instruction to request the use of partial precision, including texture load instructions. This indicates that the implementation is allowed to execute the instruction with partial precision and store a partial precision result. In the absence of an explicit modifier, the instruction is performed at full precision (regardless of the precisions of the input operands).","In addition to scenarios where an application might deliberately choose to trade off precision for performance, there are several kinds of shader input data which present themselves with less precision and which are natural candidates for partial precision processing. For instance, color iterators are accurately represented by partial precision values (or less, though no less than 8-bit). Texture values from most formats also can be accurately represented by partial precision values (values sampled from 32-bit floating point format textures are an obvious exception). Constants may be represented by partial precision representation as desired.","In all these cases the developer may choose to use _pp instructions to process the data, knowing that no input data precision is \u201clost\u201d (with the caveat that in some situations numerical considerations may require that some internal steps of a calculation be performed at full precision even when input and final output values do not have more than partial precision.)","Table V shows how slot counts for pixel shaders have evolved to the point of the present invention, wherein model and model refer to previous shader models for comparison, as follows:",{"@attributes":{"id":"p-0204","num":"0427"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE V"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary Pixel Shader Instruction Slot Consumption"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"70pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Instruction","model1","model2","the invention"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]},{"entry":[{},"Total","96\u2002","512(max)","512(min)"]},{"entry":[{},"Arith","64\u2002","512(max)","512(min)"]},{"entry":[{},"Tex","32\u2002","512(max)","512(min)"]},{"entry":[{},"abs","1","1","1"]},{"entry":[{},"add","1","1","1"]},{"entry":[{},"break","n\/a","1","1"]},{"entry":[{},"breakc","n\/a","3","3"]},{"entry":[{},"breakp","n\/a","3","3"]},{"entry":[{},"call","n\/a","2","2"]},{"entry":[{},"callnz b","n\/a","3","3"]},{"entry":[{},"callnz p","n\/a","3","3"]},{"entry":[{},"cmp","1","1","1"]},{"entry":[{},"crs","2","2","2"]},{"entry":[{},"dcl","n\/a","n\/a","n\/a"]},{"entry":[{},"def","n\/a","n\/a","n\/a"]},{"entry":[{},"defi","n\/a","n\/a","n\/a"]},{"entry":[{},"defb","n\/a","n\/a","n\/a"]},{"entry":[{},"dsx","n\/a","2","2"]},{"entry":[{},"dsy","n\/a","2","2"]},{"entry":[{},"dp2add","2","2","2"]},{"entry":[{},"dp3","1","1","1"]},{"entry":[{},"dp4","1","1","1"]},{"entry":[{},"else","n\/a","1","1"]},{"entry":[{},"endif","n\/a","1","1"]},{"entry":[{},"endloop","n\/a","n\/a","2"]},{"entry":[{},"endrep","n\/a","2","2"]},{"entry":[{},"exp","1","1","1"]},{"entry":[{},"frc","1","1","1"]},{"entry":[{},"if b","n\/a","3","3"]},{"entry":[{},"if p","n\/a","3","3"]},{"entry":[{},"ifc","n\/a","3","3"]},{"entry":[{},"label","n\/a","0","0"]},{"entry":[{},"log","1","1","1"]},{"entry":[{},"loop","n\/a","n\/a","3"]},{"entry":[{},"lrp","2","2","2"]},{"entry":[{},"m3\u00d72","2","2","2"]},{"entry":[{},"m3\u00d73","3","3","3"]},{"entry":[{},"m3\u00d74","4","4","4"]},{"entry":[{},"m4\u00d73","3","3","3"]},{"entry":[{},"m4\u00d74","4","4","4"]},{"entry":[{},"mad","1","1","1"]},{"entry":[{},"min","1","1","1"]},{"entry":[{},"max","1","1","1"]},{"entry":[{},"mov","1","1","1"]},{"entry":[{},"mul","1","1","1"]},{"entry":[{},"nop","1","1","1"]},{"entry":[{},"nrm","3","3","3"]},{"entry":[{},"pow","3","3","3"]},{"entry":[{},"rcp","1","1","1"]},{"entry":[{},"rep","n\/a","3","3"]},{"entry":[{},"ret","n\/a","1","1"]},{"entry":[{},"rsq","1","1","1"]},{"entry":[{},"setp","n\/a","1","1"]},{"entry":[{},"sincos","8","8","8"]},{"entry":[{},"texld","1(tex)","(1+3CUBE)*","1+3CUBE"]},{"entry":[{},"texldb","1(tex)","\u20026*","6"]},{"entry":[{},"texldp","1(tex)","(3+1CUBE)*","3+1CUBE"]},{"entry":[{},"texldd","n\/a","3","3"]},{"entry":[{},"texldl","n\/a","n\/a","2+3CUBE"]},{"entry":[{},"texkill","1(tex)","\u20022*","2"]},{"entry":[{},"ALL:",{},"PRED+1","PRED+1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"One of ordinary skill in the art can appreciate that the invention can be implemented in connection with any computer or other client or server device, which can be deployed as part of a computer network, or in a distributed computing environment. In this regard, the present invention pertains to any computer system or environment having any number of memory or storage units, and any number of applications and processes occurring across any number of storage units or volumes, which may be used in connection with processes for downloading algorithmic elements to a coprocessor in accordance with the present invention. The present invention may apply to an environment with server computers and client computers deployed in a network environment or distributed computing environment, having remote or local storage. The present invention may also be applied to standalone computing devices, having programming language functionality, interpretation and execution capabilities for generating, receiving and transmitting information in connection with remote or local services and processes. Graphics data, such as images (e.g., photos) and video (e.g., movies, advertisements, etc.) continue to proliferate on networks and may be particularly relevant to those computing devices operating in a network or distributed computing environment, and thus the techniques for downloading algorithmic elements to a coprocessor in accordance with the present invention can be applied with great efficacy in those environments.","Distributed computing provides sharing of computer resources and services by exchange between computing devices and systems. These resources and services include the exchange of information, cache storage and disk storage for files. Distributed computing takes advantage of network connectivity, allowing clients to leverage their collective power to benefit the entire enterprise. In this regard, a variety of devices may have applications, objects or resources that may implicate the systems and methods for downloading algorithmic elements to a coprocessor of the invention.",{"@attributes":{"id":"p-0207","num":"0430"},"figref":["FIG. 13A","FIG. 13A"],"b":["10","110","110","110","14","10","10","110","110","110"],"i":["b","a","b","c","a","b","a","b","c"]},"It can also be appreciated that an object, such as , may be hosted on another computing device , , etc. or , , etc. Thus, although the physical environment depicted may show the connected devices as computers, such illustration is merely exemplary and the physical environment may alternatively be depicted or described comprising various digital devices such as PDAs, televisions, MP3 players, etc., software objects such as interfaces, COM objects and the like.","There are a variety of systems, components, and network configurations that support distributed computing environments. For example, computing systems may be connected together by wired or wireless systems, by local networks or widely distributed networks. Currently, many of the networks are coupled to the Internet, which provides an infrastructure for widely distributed computing and encompasses many different networks. Any of the infrastructures may be used for exemplary communications made incident to downloading algorithmic elements to a coprocessor according to the present invention.","In home networking environments, there are at least four disparate network transport media that may each support a unique protocol, such as Power line, data (both wireless and wired), voice (e.g., telephone) and entertainment media. Most home control devices such as light switches and appliances may use power lines for connectivity. Data Services may enter the home as broadband (e.g., either DSL or Cable modem) and are accessible within the home using either wireless (e.g., HomeRF or 802.11B) or wired (e.g., Home PNA, Cat 5, Ethernet, even power line) connectivity. Voice traffic may enter the home either as wired (e.g., Cat 3) or wireless (e.g., cell phones) and may be distributed within the home using Cat 3 wiring. Entertainment media, or other graphical data, may enter the home either through satellite or cable and is typically distributed in the home using coaxial cable. IEEE 1394 and DVI are also digital interconnects for clusters of media devices. All of these network environments and others that may emerge as protocol standards may be interconnected to form a network, such as an intranet, that may be connected to the outside world by way of the Internet. In short, a variety of disparate sources exist for the storage and transmission of graphics data, and consequently, moving forward, computing devices will require ways of sharing data, such as data accessed or utilized incident to program objects, which may be downloaded to a coprocessor in accordance with the present invention.","The Internet commonly refers to the collection of networks and gateways that utilize the TCP\/IP suite of protocols, which are well-known in the art of computer networking. TCP\/IP is an acronym for \u201cTransmission Control Protocol\/Internet Protocol.\u201d The Internet can be described as a system of geographically distributed remote computer networks interconnected by computers executing networking protocols that allow users to interact and share information over the network(s). Because of such wide-spread information sharing, remote networks such as the Internet have thus far generally evolved into an open system for which developers can design software applications for performing specialized operations or services, essentially without restriction.","Thus, the network infrastructure enables a host of network topologies such as client\/server, peer-to-peer, or hybrid architectures. The \u201cclient\u201d is a member of a class or group that uses the services of another class or group to which it is not related. Thus, in computing, a client is a process, i.e., roughly a set of instructions or tasks, that requests a service provided by another program. The client process utilizes the requested service without having to \u201cknow\u201d any working details about the other program or the service itself. In a client\/server architecture, particularly a networked system, a client is usually a computer that accesses shared network resources provided by another computer, e.g., a server. In the example of , computers , , etc. can be thought of as clients and computers , , etc. can be thought of as the server where server , , etc. maintains the data that is then replicated in the client computers , , etc., although any computer can be considered a client, a server, or both, depending on the circumstances. Any of these computing devices may be processing data or requesting services or tasks that may implicate the interfaces associated with downloading programs to coprocessors in accordance with the invention.","A server is typically a remote computer system accessible over a remote or local network, such as the Internet. The client process may be active in a first computer system, and the server process may be active in a second computer system, communicating with one another over a communications medium, thus providing distributed functionality and allowing multiple clients to take advantage of the information-gathering capabilities of the server. Any software objects utilized pursuant to the techniques for downloading algorithmic elements to a coprocessor of the invention may be distributed across multiple computing devices or objects.","Client(s) and server(s) communicate with one another utilizing the functionality provided by protocol layer(s). For example, HyperText Transfer Protocol (HTTP) is a common protocol that is used in conjunction with the World Wide Web (WWW), or \u201cthe Web.\u201d Typically, a computer network address such as an Internet Protocol (IP) address or other reference such as a Universal Resource Locator (URL) can be used to identify the server or client computers to each other. The network address can be referred to as a URL address. Communication can be provided over a communications medium, e.g., client(s) and server(s) may be coupled to one another via TCP\/IP connection(s) for high-capacity communication.","Thus,  illustrates an exemplary networked or distributed environment, with a server in communication with client computers via a network\/bus, in which the present invention may be employed. In more detail, a number of servers , , etc., are interconnected via a communications network\/bus , which may be a LAN, WAN, intranet, the Internet, etc., with a number of client or remote computing devices , , , , , etc., such as a portable computer, handheld computer, thin client, networked appliance, or other device, such as a VCR, TV, oven, light, heater and the like in accordance with the present invention. It is thus contemplated that the present invention may apply to any computing device in connection with which it is desirable to download algorithmic elements to a coprocessor.","In a network environment in which the communications network\/bus  is the Internet, for example, the servers , , etc. can be Web servers with which the clients , , , , , etc. communicate via any of a number of known protocols such as HTTP. Servers , , etc. may also serve as clients , , , , , etc., as may be characteristic of a distributed computing environment.","Communications may be wired or wireless, where appropriate. Client devices , , , , , etc. may or may not communicate via communications network\/bus , and may have independent communications associated therewith. For example, in the case of a TV or VCR, there may or may not be a networked aspect to the control thereof. Each client computer , , , , , etc. and server computer , , etc. may be equipped with various application program modules or objects  and with connections or access to various types of storage elements or objects, across which files or data streams may be stored or to which portion(s) of files or data streams may be downloaded, transmitted or migrated. Any one or more of computers , , , , etc. may be responsible for the maintenance and updating of a database  or other storage element, such as a database or memory  for storing data processed according to the invention. Thus, the present invention can be utilized in a computer network environment having client computers , , etc. that can access and interact with a computer network\/bus  and server computers , , etc. that may interact with client computers , etc. and other like devices, and databases .","Exemplary Computing Device",{"@attributes":{"id":"p-0218","num":"0441"},"figref":"FIG. 13B"},"Although not required, the invention can be implemented via an operating system, for use by a developer of services for a device or object, and\/or included within application software that operates in connection with methods for downloading algorithmic elements to a coprocessor of the invention. Software may be described in the general context of computer-executable instructions, such as program modules, being executed by one or more computers, such as client workstations, servers or other devices. Generally, program modules include routines, programs, objects, components, data structures and the like that perform particular tasks or implement particular abstract data types. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments. Moreover, those skilled in the art will appreciate that the invention may be practiced with other computer system configurations and protocols. Other well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers (PCs), automated teller machines, server computers, hand-held or laptop devices, multi-processor systems, microprocessor-based systems, programmable consumer electronics, network PCs, appliances, lights, environmental control elements, minicomputers, mainframe computers and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network\/bus or other data transmission medium. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices, and client nodes may in turn behave as server nodes.",{"@attributes":{"id":"p-0220","num":"0443"},"figref":"FIG. 13B","b":["100","100","100","100"]},"With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus (also known as Mezzanine bus).","Computer  typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer  and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CDROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk , such as a CD-ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in  provide storage of computer readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules  and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules  and program data . Operating system , application programs , other program modules  and program data  are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices such as a keyboard  and pointing device , commonly referred to as a mouse, trackball or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus , but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A graphics interface , such as Northbridge, may also be connected to the system bus . Northbridge is a chipset that communicates with the CPU, or host processing unit , and assumes responsibility for accelerated graphics port (AGP) communications. One or more coprocessors, such as graphics processing units (GPUs) , may communicate with graphics interface . In this regard, GPUs  generally include on-chip memory storage, such as register storage and GPUs  communicate with a video memory , wherein the methods for downloading algorithmic elements to a coprocessor of the invention have particular impact. GPUs , however, are but one example of a coprocessor and thus a variety of coprocessing devices may be included in computer , and may include a variety of procedural shaders, such as pixel and vertex shaders. A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface , which may in turn communicate with video memory . In addition to monitor , computers may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","The computer  may operate in a networked or distributed environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks\/buses. Such networking environments are commonplace in homes, offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Exemplary Distributed Computing Frameworks or Architectures","Various distributed computing frameworks have been and are being developed in light of the convergence of personal computing and the Internet. Individuals and business users alike are provided with a seamlessly interoperable and Web-enabled interface for applications and computing devices, making computing activities increasingly Web browser or network-oriented.","For example, MICROSOFT\u00ae's managed code platform, i.e., .NET, includes servers, building-block services, such as Web-based data storage and downloadable device software. Generally speaking, the .NET platform provides (1) the ability to make the entire range of computing devices work together and to have user information automatically updated and synchronized on all of them, (2) increased interactive capability for Web pages, enabled by greater use of XML rather than HTML, (3) online services that feature customized access and delivery of products and services to the user from a central starting point for the management of various applications, such as e-mail, for example, or software, such as Office .NET, (4) centralized data storage, which increases efficiency and ease of access to information, as well as synchronization of information among users and devices, (5) the ability to integrate various communications media, such as e-mail, faxes, and telephones, (6) for developers, the ability to create reusable modules, thereby increasing productivity and reducing the number of programming errors and (7) many other cross-platform and language integration features as well.","While some exemplary embodiments herein are described in connection with software, such as an application programming interface (API), residing on a computing device, one or more portions of the invention may also be implemented via an operating system, or a \u201cmiddle man\u201d object, a control object, hardware, firmware, intermediate language instructions or objects, etc., such that the methods for downloading algorithmic elements to a coprocessor in accordance with the invention may be included in, supported in or accessed via all of the languages and services enabled by managed code, such as .NET code, and in other distributed computing frameworks as well.","A programming interface (or more simply, interface) may be viewed as any mechanism, process, protocol for enabling one or more segment(s) of code to communicate with or access the functionality provided by one or more other segment(s) of code. Alternatively, a programming interface may be viewed as one or more mechanism(s), method(s), function call(s), module(s), object(s), etc. of a component of a system capable of communicative coupling to one or more mechanism(s), method(s), function call(s), module(s), etc. of other component(s). The term \u201csegment of code\u201d in the preceding sentence is intended to include one or more instructions or lines of code, and includes, e.g., code modules, objects, subroutines, functions, and so on, regardless of the terminology applied or whether the code segments are separately compiled, or whether the code segments are provided as source, intermediate, or object code, whether the code segments are utilized in a runtime system or process, or whether they are located on the same or different machines or distributed across multiple machines, or whether the functionality represented by the segments of code are implemented wholly in software, wholly in hardware, or a combination of hardware and software.","Notionally, a programming interface may be viewed generically, as shown in  or .  illustrates an interface InterfacA as a conduit through which first and second code segments communicate.  illustrates an interface as comprising interface objects I and I (which may or may not be part of the first and second code segments), which enable first and second code segments of a system to communicate via medium M. In the view of , one may consider interface objects I and I as separate interfaces of the same system and one may also consider that objects I and I plus medium M comprise the interface. Although  show bi-directional flow and interfaces on each side of the flow, certain implementations may only have information flow in one direction (or no information flow as described below) or may only have an interface object on one side. By way of example, and not limitation, terms such as application programming interface (API), entry point, method, function, subroutine, remote procedure call, and component object model (COM) interface, are encompassed within the definition of programming interface.","Aspects of such a programming interface may include the method whereby the first code segment transmits information (where \u201cinformation\u201d is used in its broadest sense and includes data, commands, requests, etc.) to the second code segment; the method whereby the second code segment receives the information; and the structure, sequence, syntax, organization, schema, timing and content of the information. In this regard, the underlying transport medium itself may be unimportant to the operation of the interface, whether the medium be wired or wireless, or a combination of both, as long as the information is transported in the manner defined by the interface. In certain situations, information may not be passed in one or both directions in the conventional sense, as the information transfer may be either via another mechanism (e.g. information placed in a buffer, file, etc. separate from information flow between the code segments) or non-existent, as when one code segment simply accesses functionality performed by a second code segment. Any or all of these aspects may be important in a given situation, e.g., depending on whether the code segments are part of a system in a loosely coupled or tightly coupled configuration, and so this list should be considered illustrative and non-limiting.","This notion of a programming interface is known to those skilled in the art and is clear from the foregoing detailed description of the invention. There are, however, other ways to implement a programming interface, and, unless expressly excluded, these too are intended to be encompassed by the claims set forth at the end of this specification. Such other ways may appear to be more sophisticated or complex than the simplistic view of , but they nonetheless perform a similar function to accomplish the same overall result. We will now briefly describe some illustrative alternative implementations of a programming interface.","A. Factoring","A communication from one code segment to another may be accomplished indirectly by breaking the communication into multiple discrete communications. This is depicted schematically in . As shown, some interfaces can be described in terms of divisible sets of functionality. Thus, the interface functionality of  may be factored to achieve the same result, just as one may mathematically provide 24, or 2 times 2 time 3 times 2. Accordingly, as illustrated in , the function provided by interface InterfacA may be subdivided to convert the communications of the interface into multiple interfaces InterfacAA, Interface B, Interface C, etc. while achieving the same result. As illustrated in , the function provided by interface I may be subdivided into multiple interfaces II, I, etc. while achieving the same result. Similarly, interface I of the second code segment which receives information from the first code segment may be factored into multiple interfaces I, I, I, etc. When factoring, the number of interfaces included with the 1code segment need not match the number of interfaces included with the 2code segment. In either of the cases of , the functional spirit of interfaces InterfacA and I remain the same as with , respectively. The factoring of interfaces may also follow associative, commutative, and other mathematical properties such that the factoring may be difficult to recognize. For instance, ordering of operations may be unimportant, and consequently, a function carried out by an interface may be carried out well in advance of reaching the interface, by another piece of code or interface, or performed by a separate component of the system. Moreover, one of ordinary skill in the programming arts can appreciate that there are a variety of ways of making different function calls that achieve the same result.","B. Redefinition","In some cases, it may be possible to ignore, add or redefine certain aspects (e.g., parameters) of a programming interface while still accomplishing the intended result. This is illustrated in . For example, assume interface InterfacA of  includes a function call Square(input, precision, output), a call that includes three parameters, input, precision and output, and which is issued from the 1Code Segment to the 2Code Segment., If the middle parameter precision is of no concern in a given scenario, as shown in , it could just as well be ignored or even replaced with a meaningless (in this situation) parameter. One may also add an additional parameter of no concern. In either event, the functionality of square can be achieved, so long as output is returned after input is squared by the second code segment. Precision may very well be a meaningful parameter to some downstream or other portion of the computing system; however, once it is recognized that precision is not necessary for the narrow purpose of calculating the square, it may be replaced or ignored. For example, instead of passing a valid precision value, a meaningless value such as a birth date could be passed without adversely affecting the result. Similarly, as shown in , interface I is replaced by interface I\u2032, redefined to ignore or add parameters to the interface. Interface I may similarly be redefined as interface I\u2032, redefined to ignore unnecessary parameters, or parameters that may be processed elsewhere. The point here is that in some cases a programming interface may include aspects, such as parameters, that are not needed for some purpose, and so they may be ignored or redefined, or processed elsewhere for other purposes.","C. Inline Coding","It may also be feasible to merge some or all of the functionality of two separate code modules such that the \u201cinterface\u201d between them changes form. For example, the functionality of  may be converted to the functionality of , respectively. In , the previous 1and 2Code Segments of  are merged into a module containing both of them. In this case, the code segments may still be communicating with each other but the interface may be adapted to a form which is more suitable to the single module. Thus, for example, formal Call and Return statements may no longer be necessary, but similar processing or response(s) pursuant to interface InterfacA may still be in effect. Similarly, shown in , part (or all) of interface I from  may be written inline into interface I to form interface I\u2033. As illustrated, interface  is divided into Iand I, and interface portion Ihas been coded in-line with interface I to form interface I\u2033. For a concrete example, consider that the interface I from  performs a function call square (input, output), which is received by interface I, which after processing the value passed with input (to square it) by the second code segment, passes back the squared result with output. In such a case, the processing performed by the second code segment (squaring input) can be performed by the first code segment without a call to the interface.","D. Divorce","A communication from one code segment to another may be accomplished indirectly by breaking the communication into multiple discrete communications. This is depicted schematically in . As shown in , one or more piece(s) of middleware (Divorce Interface(s), since they divorce functionality and\/or interface functions from the original interface) are provided to convert the communications on the first interface, InterfacA, to conform them to a different interface, in this case interfaces InterfacBA, InterfacBB and InterfacBC. This might be done, e.g., where there is an installed base of applications designed to communicate with, say, an operating system in accordance with an InterfacA protocol, but then the operating system is changed to use a different interface, in this case interfaces InterfacBA, InterfacBB and InterfacBC. The point is that the original interface used by the 2Code Segment is changed such that it is no longer compatible with the interface used by the 1Code Segment, and so an intermediary is used to make the old and new interfaces compatible. Similarly, as shown in , a third code segment can be introduced with divorce interface DI to receive the communications from interface I and with divorce interface DI to transmit the interface functionality to, for example, interfaces Iand I redesigned to work with DI, but to provide the same functional result. Similarly, DI and DI may work together to translate the functionality of interfaces I and I of  to a new operating system, while providing the same or similar functional result.","E. Rewriting","Yet another possible variant is to dynamically rewrite the code to replace the interface functionality with something else but which achieves the same overall result. For example, there may be a system in which a code segment presented in an intermediate language (e.g. Microsoft IL, Java ByteCode, etc.) is provided to a Just-in-Time (JIT) compiler or interpreter in an execution environment (such as that provided by the .Net framework, the Java runtime environment, or other similar runtime type environments). The JIT compiler may be written so as to dynamically convert the communications from the 1Code Segment to the 2Code Segment, i.e., to conform them to a different interface as may be required by the 2Code Segment (either the original or a different 2Code Segment). This is depicted in . As can be seen in , this approach is similar to the Divorce scenario described above. It might be done, e.g., where an installed base of applications are designed to communicate with an operating system in accordance with an Interface  protocol, but then the operating system is changed to use a different interface. The JIT Compiler could be used to conform the communications on the fly from the installed-base applications to the new interface of the operating system. As depicted in , this approach of dynamically rewriting the interface(s) may be applied to dynamically factor, or otherwise alter the interface(s) as well.","It is also noted that the above-described scenarios for achieving the same or similar result as an interface via alternative embodiments may also be combined in various ways, serially and\/or in parallel, or with other intervening code. Thus, the alternative embodiments presented above are not mutually exclusive and may be mixed, matched and combined to produce the same or equivalent scenarios to the generic scenarios presented in . It is also noted that, as with most programming constructs, there are other similar ways of achieving the same or similar functionality of an interface which may not be described herein, but nonetheless are represented by the spirit and scope of the invention, i.e., it is noted that it is at least partly the functionality represented by, and the advantageous results enabled by, an interface that underlie the value of an interface.","There are multiple ways of implementing the present invention, e.g., an appropriate API, tool kit, driver code, operating system, control, standalone or downloadable software object, etc. which enables applications and services to use the systems and methods for downloading algorithmic elements to a coprocessor of the invention. The invention contemplates the use of the invention from the standpoint of an API (or other software object), as well as from a software or hardware object that receives a downloaded program in accordance with the invention. Thus, various implementations of the invention described herein may have aspects that are wholly in hardware, partly in hardware and partly in software, as well as in software.","As mentioned above, while exemplary embodiments of the present invention have been described in connection with various computing devices and network architectures, the underlying concepts may be applied to any computing device or system in which it is desirable to download algorithmic elements to a coprocessor. For instance, the algorithm(s) and hardware implementations of the invention may be applied to the operating system of a computing device, provided as a separate object on the device, as part of another object, as a reusable control, as a downloadable object from a server, as a \u201cmiddle man\u201d between a device or object and the network, as a distributed object, as hardware, in memory, a combination of any of the foregoing, etc. While exemplary programming languages, names and examples are chosen herein as representative of various choices, these languages, names and examples are not intended to be limiting. One of ordinary skill in the art will appreciate that there are numerous ways of providing object code and nomenclature that achieves the same, similar or equivalent functionality achieved by the various embodiments of the invention.","As mentioned, the various techniques described herein may be implemented in connection with hardware or software or, where appropriate, with a combination of both. Thus, the methods and apparatus of the present invention, or certain aspects or portions thereof, may take the form of program code (i.e., instructions) embodied in tangible media, such as floppy diskettes, CD-ROMs, hard drives, or any other machine-readable storage medium, wherein, when the program code is loaded into and executed by a machine, such as a computer, the machine becomes an apparatus for practicing the invention. In the case of program code execution on programmable computers, the computing device generally includes a processor, a storage medium readable by the processor (including volatile and non-volatile memory and\/or storage elements), at least one input device, and at least one output device. One or more programs that may implement or utilize the graphics API GAPI of the present invention, e.g., through the use of a data processing API, reusable controls, or the like, are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However, the program(s) can be implemented in assembly or machine language, if desired. In any case, the language may be a compiled or interpreted language, and combined with hardware implementations.","The methods and apparatus of the present invention may also be practiced via communications embodied in the form of program code that is transmitted over some transmission medium, such as over electrical wiring or cabling, through fiber optics, or via any other form of transmission, wherein, when the program code is received and loaded into and executed by a machine, such as an EPROM, a gate array, a programmable logic device (PLD), a client computer, etc., the machine becomes an apparatus for practicing the invention. When implemented on a general-purpose processor, the program code combines with the processor to provide a unique apparatus that operates to invoke the functionality of the present invention. Additionally, any storage techniques used in connection with the present invention may invariably be a combination of hardware and software.","While the present invention has been described in connection with the preferred embodiments of the various figures, it is to be understood that other similar embodiments may be used or modifications and additions may be made to the described embodiment for performing the same function of the present invention without deviating therefrom. For example, while exemplary network environments of the invention are described in the context of a networked environment, such as a peer to peer networked environment, one skilled in the art will recognize that the present invention is not limited thereto, and that the methods, as described in the present application may apply to any computing device or environment, such as a gaming console, handheld computer, portable computer, etc., whether wired or wireless, and may be applied to any number of such computing devices connected via a communications network, and interacting across the network. Furthermore, it should be emphasized that a variety of computer platforms, including handheld device operating systems and other application specific operating systems are contemplated, especially as the number of wireless networked devices continues to proliferate. Gaming consoles, for instance, ever on the cutting edge of graphics rendering are particularly relevant to the flexible and fast coprocessing enabled by the invention.","While exemplary embodiments refer to utilizing the present invention in the context of particular programming language constructs, the invention is not so limited, but rather may be implemented in any language to provide methods for downloading algorithmic elements to a coprocessor. It will be appreciated that while generally vertex shaders have been described herein as operating upon vertex data, and while generally pixel shaders have been described herein as operating upon pixel data, procedural shaders may also be used to process graphics data in other ways where the processing task and associated data can leverage the processing and memory access speed enabled by today's GPUs. Still further, the present invention may be implemented in or across a plurality of processing chips or devices, and storage may similarly be effected across a plurality of devices. Therefore, the present invention should not be limited to any single embodiment, but rather should be construed in breadth and scope in accordance with the appended claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The system and methods for downloading algorithmic elements to a coprocessor and corresponding processing and communication techniques are further described with reference to the accompanying drawings in which:",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIGS. 1A and 1B"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIGS. 2A and 2B"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIGS. 3A and 3B"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIGS. 5A and 5B"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIGS. 6A and 6B"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIGS. 7A and 7B"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIGS. 8A to 8C"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 10A"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 10B"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIGS. 11A and 11B"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIGS. 12A and 12B"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 13A"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 13B"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIGS. 14A to 19B"}]},"DETDESC":[{},{}]}
