---
title: Computer program product and method for sharing information between multiple computer applications using a grafted model network
abstract: A computer program product and method for sharing information between multiple computer applications using a grafted model network. The method includes creating a first model having one or more pre-defined fields, defining one or more application-defined fields, associating the first model with the first application project, associating the one or more application-defined fields with the second application project, grafting the one or more application-defined fields to the first model, building the first and second application projects, and dynamically installing the first and second application projects on a software platform. Building the first application project comprises creating a first database table having one or more table columns corresponding to the pre-defined fields of the first model in a database. Building the second application project comprises adding one or more table columns to the first database table corresponding to the application-defined fields in the database. Dynamically installing the first application project enables the one or more table columns corresponding to the pre-defined fields of the first model to be accessed via the software platform by the first computer application upon execution on a computer, and dynamically installing the second application project enables the one or more table columns corresponding to the pre-defined fields of the first model and the application-defined fields to be accessed via the software platform by the second computer application upon execution on the computer.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08086588&OS=08086588&RS=08086588
owner: 
number: 08086588
owner_city: 
owner_country: 
publication_date: 20090729
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION THE PREFERRED EMBODIMENTS","I. FLOW CHARTS ILLUSTRATING METHOD FOR SHARING INFORMATION","II. GRAFTED APPLICATION-DEFINED FIELDS","III. USER INTERFACES","IV. EXAMPLES","Example 1","Example 2","Example 3"],"p":["1. Field of the Invention","The present invention is generally related to computer networks, and more particularly to a computer program product and method for sharing information between multiple computer applications using a grafted model network.","2. Discussion of the Background","In an increasingly global economy, there is a need for computer networks to share information between computer applications and to better adapt to meet the needs of the business enterprise(s) and computer applications using such networks.","Three arrangements that are known in the prior art for sharing information between computer applications are shown in . According to these arrangements, separate databases -are maintained by computer applications A-A. Databases -contain the respective computer application's A-A version of the information. Information is periodically communicated between the computer applications A-A by means of messaging and\/or other techniques known in the prior art. One or more of the databases -are updated based on the received information. In the first arrangement shown in , the information is directly communicated from one computer application to another computer application. In the second arrangement shown in , the information is indirectly communicated between the computer applications by means of an enterprise service bus . In the third arrangement shown in , master data management (\u201cMDM\u201d)  and business process management (\u201cBPM\u201d)  are utilized, and the information is indirectly communicated between the computer application by means of an enterprise service bus . MDM  comprises a set of processes and tools that manage non-transactional data entities of an organization. BPM  comprises a collection of related, structured activities that produce a service or product that meet the needs of a client.","Each of these arrangements are deficient because the information is typically copied or replicated many times. Further, databases -contain the respective computer application's A-A own version of the information. Information contained within databases -may not be updated on a timely and\/or consistent basis for all databases -and therefore there likely exists inconsistencies in the information. Further, the information contained within databases -is likely to be customized or altered for the particular computer application A-A. As such, different information may be stored in databases -and the information stored in each of the databases -may not be updated to include the most current information. There is therefore no single version of the truth with respect to the information.","Another arrangement that is known in the prior art for sharing information is shown in . According to this arrangement, enterprise resource planning (\u201cERP\u201d)  is in communication with an enterprise service bus . An ERP integrates the data and processes of an organization into one single system. ERP systems will normally include many components, including hardware and software, in order to achieve integration. Most ERP systems use a unified database to store data for various functions found throughout an organization. ERP allows multiple departments or organizations, having different computer applications A-A, within a company to utilize the same computer system and data. Typically, computer applications A-A are provided by a single software vendor to handle the different needs of a company's departments and organizations. For instance, the ERP  may include computer applications A-A to handle manufacturing, financials, human resources, supply chain management, and the like. Because most ERP systems use a unified database, much of the information is available to all of the computer applications A-A in the ERP  using the unified database. However, in situations in which a computer application is utilized that is not a part of the ERP and needs access to the information, such information may be periodically indirectly communicated between the ERP  and the computer applications by means of the enterprise service bus  and messaging and\/or other techniques known in the prior art.","Although this arrangement provides a single version of the truth, and reduced copying and replication, it also includes significant deficiencies. The computer applications utilized in the ERP  are very tightly coupled and typically from a single software vendor. As such, there typically exists a dependency on a single software vendor. Such reliance on a single software vendor generally is problematic. Further, the inability to upgrade different \u201capplications\u201d of ERP  independent of other applications of the ERP  results in long upgrade cycles for the computer applications. Additionally, ERP's are not suited to representing and executing multi-enterprise processes in an optimal way.","ERP known in the prior art included the concept of user-defined fields. However, the user-defined fields known in the prior art do not provide support for the co-existence of multiple independent, independently-developed applications on the ERP. This is because, according to the prior art, user-defined fields names are not scoped by an application, and user-defined fields are not bundled with an application: (a) groups of user-defined fields cannot be separately versioned; (b) cross-model groups of user-defined fields are not packaged as a unit; and (c) cross-model groups of user-defined fields cannot be installed and uninstalled as an atomic unit.","Thus, there currently exist deficiencies in sharing information between multiple computer applications.","Accordingly, one aspect of the present invention is to provide a computer program product embodied on a computer readable medium for sharing information between multiple computer applications using a grafted model network. The computer program product includes a first computer code for creating first and second application projects having a plurality of user-defined application details, a second computer code for creating a first model having one or more pre-defined fields, a third computer code for defining one or more application-defined fields, a fourth computer code for associating the first model with the first application project, a fifth computer code for associating the one or more application-defined fields with the second application project, a sixth computer code for grafting the one or more application-defined fields to the first model, a seventh computer code for building the first application project, an eighth computer code for building the second application project, and a ninth computer code for dynamically installing the first and second application projects on a software platform. The first application project is associated with a first computer application, and the second application project is associated with a second computer application. Building the first application project comprises creating a first database table having one or more table columns corresponding to the pre-defined fields of the first model in a database. Building the second application project comprises adding one or more table columns to the first database table corresponding to the application-defined fields in the database. Dynamically installing the first application project enables the one or more table columns corresponding to the pre-defined fields of the first model to be accessed via the software platform by the first computer application upon execution. Dynamically installing the second application project enables the one or more table columns corresponding to the pre-defined fields of the first model and the application-defined fields to be accessed via the software platform by the second computer application upon execution.","Another aspect of the present invention is to provide a method for sharing information between multiple computer applications using a grafted model network. The method includes creating a first model having one or more pre-defined fields, defining one or more application-defined fields, associating the first model with the first application project, associating the one or more application-defined fields with the second application project, grafting the one or more application-defined fields to the first model, building the first and second application projects, and dynamically installing the first and second application projects on a software platform. Building the first application project comprises creating a first database table having one or more table columns corresponding to the pre-defined fields of the first model in a database. Building the second application project comprises adding one or more table columns to the first database table corresponding to the application-defined fields in the database. Dynamically installing the first application project enables the one or more table columns corresponding to the pre-defined fields of the first model to be accessed via the software platform by the first computer application upon execution on a computer. Dynamically installing the second application project enables the one or more table columns corresponding to the pre-defined fields of the first model and the application-defined fields to be accessed via the software platform by the second computer application upon execution on the computer.","Referring now to the drawings, wherein like reference numerals designate identical or corresponding parts throughout the several views, preferred embodiments of the present invention are described.","In order to provide the most current information between computer applications over a computer network, it is critical to provide the most current information. Information may be shared between computer applications using either (a) a single version of the truth, or (b) multiple versions of the truth. As used herein, a \u201csingle version of the truth\u201d is an arrangement in which the same data in its most current\/updated form is accessible by multiple computer applications and\/or multiple parties. In order to maintain a single version of truth, any single data element is generally represented in a single location. Conversely, multiple versions of the truth are stored in multiple locations. However, in situations where there are multiple versions of the truth, each of the locations must be updateable simultaneously. Otherwise, by definition there is at least temporary inconsistencies with respect to the representation of the data. Therefore, the information may or may not be the most current. In practice, multiple versions of the truth with simultaneous updating is generally not feasible and a non-stale system cannot be built on such a representation.","As used herein, a \u201ccomputer application\u201d is a computer executable software application of any type that executes processing instructions on a computer or embedded in a processor, and an \u201capplication\u201d or \u201capplication project\u201d is are the files, objects, structures, database resources and other resources used in integrating a computer application into the software platform of the present invention.","Referring to , a block diagram illustrating an arrangement for sharing information between multiple computer applications using a grafted model network in accordance with an embodiment of the present invention is shown. According to this arrangement, a single version of truth is utilized by computer applications A-A. Information may be periodically communicated to other computer applications (not shown) by means of messaging and\/or other techniques known in the prior art. There is minimal data replication. Computer applications can be upgrade independent of each other. New computer applications can be easily created or customized by the company.","According to one embodiment of the present invention, an application includes without limitation:\n\n","According to one embodiment, an application includes without limitation an identifier (e.g., \u201cSMP\u201d) and a name (e.g., \u201cSample\u201d). The identifier is used to scope the namespace database-level resources and the name is used to scope the namespace of Java-level resources. Multiple applications can have the same identifier or name, but cannot be deployed on the same software platform","As used herein, a \u201cmodel\u201d is an entity which is represented in a database (as broadly defined and including without limitation anything stored on a computer readable medium or residing in memory) and supports integration, business process variation and visibility. Examples of models include without limitation, \u201cOrder,\u201d \u201cShipment,\u201d \u201cUser,\u201d \u201cItem,\u201d \u201cVendor,\u201d \u201cSite\u201d and the like. A model may be defined in a model file (.model), and includes of without limitation a model name, levels and one or more fields. A model may also include one or more methods. A model name is used to identify the model. Levels represent large portions of a model. For instance, an \u201cOrder\u201d model might include an \u201cOrderHead\u201d and an \u201cOrderLine\u201d as two levels of the model. Fields represent data fields within the model. Each field includes without limitation a name, a type and a key. Types include without limitation Integer, Float, Monetary, DataRange, and the like. According to one embodiment, several resources or objects are generated based on the model file (.model) including without limitation:\n\n","In one embodiment, models include application models and core models. Application models may be standalone or grafted. At runtime, models are fused together into a fused model. Methods on the models are arranged to operate on the root path of the fused model. Fusion occurs when an application is installed on the computer system. Defusion occurs when the application is uninstalled from the computer system. All application models are fused or defused as a unit.","Optionally, application-defined fields may be grafted to the models of certain applications. As used herein, \u201capplication-defined fields\u201d or \u201cADF\u201d represent data fields of an application which are grafted onto existing models of other applications. Application-defined fields may be defined in an ADF file (.adfs), and include without limitation a model name and a field. The model name identifies the model. Fields represent data fields that will be grafted onto a model and become part of a grafted model. As used herein, a \u201cgrafted model\u201d refers to a computer application's view of a model which includes both pre-defined fields defined by an application project, and all of the fields (also referred to as application-defined fields or \u201cADF\u201d) grafted in one or more other applications projects. According to the present invention, pre-defined fields, amongst other things, support the co-existence of multiple independent, independently-developed applications on an ERP. Each field includes without limitation a name and a type. Types include without limitation Integer, Float, Monetary, DataRange, and the like. According to one embodiment, several resources or objects are generated based on the ADF file (.adfs) including without limitation:\n\n","Referring to , block diagrams illustrating exemplary sub-networks used in a supply chain in accordance with an embodiment of the present invention are shown. A common network environment may include a many-to-many network of enterprises in which any enterprise can execute business process with any other enterprise of the network. The common network environment may include multiple sub-networks overlaid.","In other embodiments, application-defined fields and pre-defined fields are mapped into columns on the model table, columns on another related table, fields on object-oriented databases, in-memory fields of in-memory models, or the like.","Referring to , flow charts illustrating a method for sharing information between multiple computer applications using a grafted model network in accordance with an embodiment of the present invention are shown. At block , an application is created. Creating an application may involve several steps as shown in . Application details are provided at block . Optionally, one or more dependencies to other applications (as described further below) are declared at block .","One or more new models are created at block . Creating a model involves several steps as illustrated in . At block , model details are provided. A new model mapping is created at block . Optionally, one or more levels in the model are identified at block . At block , the fields in each level of the model are identified.","One or more new application-defined fields are grafted to one or more existing models at block . Grafting application-defined fields involves several steps as illustrated in . An ADF file (.adfs) is created at block . At block , an XML schema definition (\u201cXSD\u201d) representing the application-defined fields is generated using extensible stylesheet language transformations (\u201cXSLT\u201d). The XSD can be supplied as a child of a parent model at runtime using XSD substitutionGroups. At block , XML binding objects (\u201cJAXB\u201d) are generated. JAXB objects can be used to marshal or unmarshal model data to or from XML. A DDL representing the application-defined fields is generated and using XSLT at block . The DDL may be used to add columns, foreign key constraints, indexes and the like to existing tables in a database. At block , the DDL is applied to a database. At block , introspection of the database occurs and Java data access objects (\u201cDAO\u201d) are re-generated to include the newly added application-defined fields. In one embodiment, steps - are invoked via Microsoft Studio.","An application is built at block . In an embodiment of the present invention, building an application involves several steps as illustrated in . A model mapping (.model) file is created at block . At block , an XML schema definition (\u201cXSD\u201d) representing the model is generated using the model and extensible stylesheet language transformations (\u201cXSLT\u201d). The XSD allows the model to be integrated using XML. At block , XML binding objects (\u201cJAXB\u201d) are generated. JAXB objects can be used to marshal or unmarshal model data to or from XML. A DDL representing the model is generated and using XSLT at block . The DDL may be used to create database tables or foreign key constraints, indexes and the like representing the model in a database. At block , the DDL is applied to a database. At block , introspection of the database occurs and Java data access objects (\u201cDAO\u201d) are generated. DAOs can be used to easily read or write model data to or from the database. In one embodiment, steps - are invoked via Microsoft Studio.","Optionally, creating new models (step ), grafting application-defined fields (step ) and building the application (step ) may be performed iteratively.","At block , the application is installed. Similar to an operating system, an application can be installed on a software platform, such as without limitation the One Network Platform developed by One Network Enterprises, Inc. According to one embodiment, the build process produces an installer. The installer is executed on a computer executing the software platform, such as without limitation the One Network Platform. The installer will apply the DDL and deploy all required Java classes and other resources for the application's models and application-defined fields. According to one embodiment, where an application has declared a dependency to another application's model or application-defined fields, the depended upon application is installed before the application requiring such dependency.","The application may be uninstalled at block . Similar to an operating system, an application can be uninstalled from a software platform, such as without limitation the One Network Platform. According to one embodiment, the installer for the application (as described above with respect to installing an application) includes an uninstaller. The uninstaller will apply the DDL to drop tables and\/or columns, and remove any required Java classes and\/or other resources associated with that application's models and\/or application-defined fields. This effectively ungrafts fields for all models associated with the application. According to one embodiment, where an application has declared a dependency to another application's model or application-defined fields, the application requiring such dependency must be uninstalled before the depended upon application.","Referring to , a block diagram illustrating resources generated using a model definition  in accordance with an embodiment of the present invention is shown. At block , an XML schema definition (\u201cXSD\u201d) is generated using the model definition . The XSD allows the model to be integrated using XML. At block , Java API for XML binding objects (\u201cJAXB\u201d) are generated. JAXB objects can be used to marshal or unmarshal model data to or from XML. A DDL is generated at block . The DDL may be used to create database tables or foreign key constraints, indexes and the like to capture the model in a database . The DDL is applied to the database . At block , Java data access objects (\u201cDAO\u201d) are generated. DAOs can be used to easily read or write model data to or from the database .","Optionally, the present invention may also incorporate messaging between computer applications.","Grafted application-defined fields are added to existing database table(s) for the model being extended. For example, a \u201cUser\u201d model may include \u201cUserName\u201d and \u201cEmailAddress\u201d fields which are each represented in a database table. A \u201cSMP\u201d application may define a \u201cDriversLicenseNumber\u201d application-defined field to be associated with the \u201cUser\u201d model. In one embodiment, given the above example, a new column, such as \u201cSMP_DRIVERS_LICENSE_NUMBER\u201d is appended to the table that represents the \u201cUser\u201d model. If other applications define additional application-defined fields, new columns are also appended to the table. For instance, a \u201cSOC\u201d application may define a SocialSecurityNumber application-defined field to be associated with the \u201cUser\u201d model, and a \u201cHLT\u201d application may define Height and Weight application-defined fields to be associated with the \u201cUser\u201d model resulting in \u201cSOC_SOCIAL_SECURITY_NUMBER,\u201d \u201cHLT_HEIGHT\u201d and \u201cHLT_WEIGHT\u201d columns being appended to the table.","In one possible implementation of the present invention, an application is created (step ) using the user interfaces shown in . Application details may be entered by a user in the creation of the application. Application details include without limitation an application identifier, an application name, an author's domain, a platform location, a platform version, an application version, a value chain identifier, a directory where the projects are created, and a yes or no indication of whether to create a sample dataset. As shown in , the application identifier for the \u201cSample\u201d application is \u201cSMP.\u201d","The exemplary content of an application is shown in . As shown in , the \u201cSample\u201d application includes dwelling and vehicle models represented as \u201cDwelling.model\u201d and \u201cVehicle.model,\u201d respectively, and enterprise and user application-defined fields represented as \u201cEnterprise.adfs\u201d and \u201cUser.adfs,\u201d respectively.","Applications may include one or more dependencies to other applications. Applications shall also have a dependency to the One Network Platform. Applications can use the models of other applications to which they depend. Applications can also graft application-defined fields to the models of application to which they depend. In one possible implementation of the present invention, dependencies are declared (step ) using the user interface shown in . Dependencies to other applications are identified using an application identifier. As shown in , the \u201cSample\u201d application includes dependencies to the applications having application identifiers \u201cSCH\u201d and \u201cTHS.\u201d","In one possible implementation of the present invention, one or more new models are created (step ) using the user interfaces shown in . A model may be defined in a model file (.model), and consists of without limitation a model name, levels and one or more fields. A model name is used to identify the model. Levels represent large portions of a model and may be added using the user interface shown in . For instance, an \u201cOrder\u201d model might include an \u201cOrderHead\u201d and an \u201cOrderLine\u201d as two levels of the model. Fields represent data fields within the model. Each field includes without limitation a name, a type and a key. Types include without limitation Integer, Float, Monetary, DataRange, and the like.","The model may also include one or more methods. The one or more methods may be added to a model using the user interfaces shown in . According to this embodiment, one or more code files (.code) are added to a directory containing java code fragments. The java code fragments may include both state (fields) and behavior (methods). The application is then built and includes the one or more methods. For instance, as shown in , a Vehicle.code file that includes an accelerate method is added to a JAXB injection directory (jaxb.inj). The application may then be built as shown in . Once built, the methods on the generated model class may be reviewed as shown in .","In the field of object-oriented programming, inheritance allows a derived object to add fields and behavior to a base object. However, the present invention is distinct from object-oriented programming and, in particular, multiple inheritance. Unlike object-oriented programming, the present invention provides support for: (a) entire collections of objects and \u201cobject fragments\u201d to be versioned; (b) collections to specify a version dependency on other collections; (c) collections to be installed and uninstalled as a unit; (d) a \u201ccomplete\u201d object to span multiple collections; and (e) collections to contain many artifacts other than objects, such as screens, schema definitions, reports, and the like.","In one possible implementation of the present invention, application-defined fields are grafted to a model (step ) using the user interface shown in . Application-defined fields (\u201cADFs\u201d) allow an application to graft new fields onto existing models of other applications. Application-defined fields are grafted to one or more existing models from other applications, and consist of without limitation a model name and a field. The model name identifies the model. Fields represent data fields that will be grafted onto a model and become part of a grafted model. Each field includes without limitation a name and a type. Types include without limitation Integer, Float, Monetary, DataRange, and the like. Optionally, ADFs may be defined in an ADF file (.adfs) by a developer.","In one possible implementation of the present invention, an application is built (step ) using the user interfaces shown in . The build process takes model and\/or ADF mappings and produces the resources detailed with respect to . The build process builds and deploys all resources as a unit (i.e., Model and\/or ADF definitions are not built piecemeal).","According to one embodiment, all models support the following application programming interfaces (\u201cAPIs\u201d):","ModelList Model.read (ModelReadRequest)","ModelList Model.write (ModelWriteRequest)","The above APIs provide uniform create, read, update and delete (\u201cCRUD\u201d) support for all models, including all grafted models. In one possible implementation of the present invention, information relating to the Model.read and Model.write is defined using the user interfaces shown in , respectively. Such information includes without limitation any filter criteria, retrieval criteria, sort order and\/or actions.","As shown in , a \u201cview\u201d may be defined which describes filter criteria, retrieval criteria and sort order of a model and, thereby, what will be returned upon a Model.read request for that model. For example, the XML shown in  may be passed as a parameter to the Model.read request and the XML shown in  may be returned from the Model.read request.","As shown in , an \u201caction\u201d may be defined which describes the editability of fields and possible workflow to execute upon a Model.write request for that model. For example, the XML shown in  may be passed as a parameter to the Model.write request and the XML shown in  may be returned from the Model.write request.","According to one embodiment, the primary way in which an application interacts with the underlying software platform at runtime is through the model read\/write API. This API provides an application with the ability to read and write models (including grafted models with all associated fields) from the database.","To read models from the database, a ModelList Model.read (ModelReadRequest) API is provided. The Model.read API passes a ModelReadRequest and returns a ModelList. The ModelReadRequest includes:\n\n","The ModelList contains the results of a query and includes:\n\n","The software platform provides a way of specifying views (referenced with respect to ViewRef above). A View includes:\n\n","To write models to the database, a ModelList Model.write (ModelWriteRequest) API is provided. The Model.write API passes a ModelWriteRequest and returns a ModelList. The ModelWriteRequest includes:\n\n","The ModelList that is returned from a ModelWriteRequest contains the results of the write operation and includes:\n\n","The software platform provides a way of specifying the actions referenced by the","ActionName above. An Action includes:\n\n","Additional APIs may be provided by the underlying software platform at runtime. As all models have XML representations, the software platform must provide a mechanism for converting XML representations of models into java representations of the same, and vice versa. This XML marshalling\/unmarshalling must handle all pre-defined fields and application-defined fields for each model, based on their \u201c.model\u201d and \u201c.adfs\u201d metadata. The API unmarshal and marshal includes:\n\n","The software platform may also include support for several buildtime APIs. These are not used by running applications, but are instead used to build\/install or uninstall applications into a software platform instance. The buildtime APIs include:\n\n","Each of the below examples are intended as non-limiting examples.","Referring to , block diagrams illustrating an exemplary grafted model in accordance with an embodiment of the present invention are shown. According to this example, there is only one database table to represent a User model. However, each application may have a different perspective of the table based on its dependencies. For this example, assume the following:\n\n","Based upon the above assumptions: (i) only User_Name  and Email_Address  would be visible to PLT application ; (ii) only User_Name , Email_Address  and SMP_Drivers_License Number  would be visible to SMP application ; (iii) only User_Name , Email_Address , SOC_Social_Security_Number  would be visible to SOC application ; and (iv) only User_Name , Email_Address , SOC_Social_Security_Number , HLT_Height  and HLT_Weight  would be visible to HLT application .","Referring to , a block diagram illustrating an exemplary model fusion in accordance with an embodiment of the present invention is shown. As shown in this example, application \u201cA\u201d  includes grafted modals GMA  and GMA , and stand-alone model SMA . GMA is grafted onto model CM , and GMA  is grafted onto model CM . Based on this, the CM model  is visible to the GMA model  and the CM model  is visible to the GMA model . Application \u201cB\u201d  includes grafted model GMB   and stand-alone model SMB . GMB  is grafted onto model CM . Based on this, the CM model  is visible to the GMB  model . Application \u201cC\u201d  includes grafted model GMC  . GMC  is grafted onto model GMB . Based on this, the GMB  and CM  model are visible to the GMC model .","Application \u201cA\u201d defines model \u201cA\u201d which includes fields A, Aand A. A database table \u201cA\u201d is created which represents model \u201cA\u201d. Database table \u201cA\u201d includes database columns A, Aand Awhich respectively correspond to fields A, Aand Afields in model \u201cA.\u201d Database columns A, Aand Aare visible to application \u201cA.\u201d","Application \u201cB\u201d defines application-defined fields Band Bto model \u201cA\u201d. Additional database columns Aand Awhich respectively correspond to application-defined fields Band B, are added to database table \u201cA\u201d. Database columns A, A, A, Aand Aare visible to application \u201cB.\u201d","Application \u201cC\u201d defines application-defined fields Cand Cto model \u201cA\u201d. Additional database columns Aand A, which respectively correspond to application-defined fields Cand C, are added to database table \u201cA\u201d. Database columns A, A, A, Aand Aare visible to application \u201cC.\u201d","Application \u201cD\u201d depends on model \u201cA\u201d of application \u201cA\u201d. Database columns A, Aand Aare visible to application \u201cD.\u201d","Application \u201cE\u201d defines model \u201cE\u201d which includes fields E, Eand Eat level ELand fields Eand Eat level EL. A database table \u201cEL\u201d is created which represents level model ELof model \u201cE,\u201d and a database table \u201cEL\u201d is created which represents level model ELof model \u201cE\u201d Database table \u201cEL\u201d includes database columns E, Eand Ewhich respectively correspond to fields E, Eand Efields in model \u201cE.\u201d Database table \u201cEL\u201d includes database columns Eand Ewhich respectively correspond to fields Eand Efields in model \u201cE.\u201d Database columns E, E, E, Eand Eare visible to application \u201cE.\u201d","The present invention thus includes a computer program which may be hosted on a storage medium and includes instructions which perform the processes set forth in the present specification. The storage medium can include, but is not limited to, any type of disk including floppy disks, optical disks, CD-ROMs, magneto-optical disks, ROMs, RAMs, EPROMs, EEPROMs, flash memory, magnetic or optical cards, or any type of media suitable for storing electronic instructions.","Obviously, many other modifications and variations of the present invention are possible in light of the above teachings. The specific embodiments discussed herein are merely illustrative, and are not meant to limit the scope of the present invention in any manner. It is therefore to be understood that within the scope of the disclosed concept, the invention may be practiced otherwise then as specifically described."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["A more complete appreciation of the present invention and many of the attendant advantages thereof will be readily obtained as the same becomes better understood by reference to the following detailed description when considered in conjunction with the accompanying drawings, wherein:",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIGS. 1A-1D"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIGS. 3-5"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIGS. 6 and 7"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIGS. 9A-9E"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIGS. 10A-10T"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIGS. 11A-11B"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIGS. 12A-12D"}]},"DETDESC":[{},{}]}
