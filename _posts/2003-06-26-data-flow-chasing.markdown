---
title: Data flow chasing
abstract: Existing systems use interprocedural data flow to analyze the source code of an entire program thereby requiring significant resources. Instead forward and backward chase components reference data structures (e.g., state machines) that identify instructions within a intraprocedural data flow graph. Based on how states of the state machine correspond to instructions in the data flow, the state machines direct the data flow chase to other procedures in a call graph, to instructions indicated in a global reference list, to instructions indicated in a field reference list, to instructions indicated by a pointer dereference, or to another instruction in the present procedure. Then, the chase continues in the data flow graph of the procedure containing the instruction.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07392514&OS=07392514&RS=07392514
owner: Microsoft Corporation
number: 07392514
owner_city: Redmond
owner_country: US
publication_date: 20030626
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","COPYRIGHT AUTHORIZATION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","Overview","Exemplary Data Chase Method","Exemplary Data Flow Graphs (DFG)","Exemplary State Machines","Exemplary Pointer Memory Dereference","Exemplary Field Reference List","Exemplary Global Reference List","Exemplary Pointers into Program","Exemplary Information Representations","Exemplary Application Programming Interface","Exemplary System","Computing Environment","Alternatives"],"p":["The technical field relates to the static analysis of specified data as it flows through different locations within a program.","A portion of the disclosure of this patent document contains material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.","Existing data flow analysis systems use data flow to analyze the source code of an entire program. Typically, an entire program is analyzed to determine where all data is used and where it originates. These methods are called interprocedural data flow analysis, and they utilize significant resources such as memory and execution time.","Additionally these prior methods limit data analysis to the abstract syntax trees derived from the source of a program. They do not analyze the data flow after the program has been transformed into binary code.","The described technologies provide methods and systems for performing data flow analysis on specified data.","On example of a method or system described herein, provides forward and backward chase components that reference data structures that identify instructions within a data flow graph. Based on instructions identified in a data flow graph, the data flow chase is directed to other procedures in a call graph, to instructions indicated in a global reference list, to instruction indicated in a field reference list, to instructions indicated by a pointer dereference, or to a next instruction in the present data flow graph. Other examples described herein discuss many other methods and systems for performing data flow chasing.","Additional features and advantages will be made apparent from the following detailed description, which proceeds with reference to the accompanying drawings.","The following examples describe methods and systems for providing data flow chasing. The described data flow chasing analysis starts focused on a point of interest, without requiring the entire program's data flow analysis. The described data flow chasing is performed with binary code input instead of source code.","Thus, along with the binary code for the program of interest, the user supplies a start state or data point of interest. From the start state, the data is followed forward or backward as directed by the user.","The data point is chased wherever it goes interprocedural or into other binary files within the program. The data is followed through procedure calls, and a tree is built of the one or more data flow paths that the data could travel backward or forward according to wherever that data moves.","Since the described data flow chasing is used for static analysis instead of optimization, a complete answer is not required. Thus, if a data flow path is labeled indeterminate, this is acceptable. If desirable, any indeterminate path is reported as an unknown data flow path.","The described data flow chase methods and systems are useful for many reasons, for example, defect detection, debugging, walking back through crash dumps, and or for analyzing programs to obtain information.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 1"},"At , the method receives an identification of binary code, a start state, and a chase direction. In one example, a start state is represented by an instruction location and the data at that location. Thus, for a \u201cmov eax, 0\u201d assembly statement, the start state would be the address (i.e., instruction location) of the mov instruction, and the data being traced into or out of the eax register (i.e., data location). The binary code would be one or more binary files from a program of interest. The start state is contained within the program.","At , the method creates a program and instruction representation (PIR) from the binary code. The PIR is a data structure (e.g., a list, tree, or graph) holding information about the program such as procedures and instructions. The PIR may also contain translations of the binary code into human comprehendible instructions (i.e., assembly\/source code), that can be shown to the user.","At , the method creates several graphs or lists that include pointers into the PIR. In one example, a control flow graph (CFG) is created to show branches within procedures in the (PIR), and a call graph (CG) is created to show procedures that call, or are called by, other procedures. In another example, a data flow graph (DFG) is created (e.g., def-use chain or single static assignment (SSA)) to show data definition and uses within procedures, and a field reference list (FRL) is created to show where data of a type is referenced within a program. In another example, a global reference list (GRL) is created to show where a global data is referenced within a program. One or more of these graphs or lists include pointers into the PIR, indicating locations where members of the graphs or lists (e.g., procedures and instructions) are located within the PIR.","At , from the start state a data flow instance is chased in the defined direction. The data instance is chased through the data flow graph defined for a procedure (e.g., see Exemplary Data Flow Graph). Once a data of concern is traced forward or backward to a procedure transition instruction (i.e., a procedure call or return in a forward chase, or the first instruction within a procedure in a backward chase), the CG is consulted to determine what procedures are called by, or call this procedure. The CG contains pointers into the PIR where the caller or callee procedures are located. Thus, the CG is used to expand the data flow chase outside and through other procedures. If plural procedure transition instruction paths are relevant to a data flow chase, then each path is followed. A data flow chase tree is created for the plural paths traversed according to the DFG for each procedure.","If an operand with a pointer dereference (i.e., [ptr]) is encountered in a chase (e.g., (mov [ptr], 0) or (add eax, [ptr])) is encountered within a DFG, that pointer is chased backward to determine where it may point. A pointer analysis table is used to determine which backward chase is performed (e.g., see Exemplary Pointer Memory Dereference). By determining where the pointer points, the memory dereference is resolved to a target of the pointer (i.e., a field reference, a global reference, or an immediate reference), so the data flow analysis can continue using the target.","For example, if the target is resolved to a global reference, then a global reference list (GRL) is used to determine all uses of the reference relevant to the present data flow analysis. If the target is resolved to a field reference, then the field reference list (FRL) is used to find all the locations in the program relevant to analysis of that target. For example, if the backward chase determines that a memory dereference pointed at a global variable, then the GRL is used to determine all uses of that global variable within the program. Thus, data flow leaving a procedure is chased not only through procedural calls using the CG, but also through pointer dereferences using a backward chase in conjunction with a GRL, or a FRL. These graphs and lists point into the PIR and indicate where to continue the chase. In one example, as each new instruction is identified within the PIR, a user is presented with the instruction or the state of that instruction so they may determine whether or not to stop the chase. In another example, the input could include a description of a desired stop state, and the chase continues down each path, and presents the user with the location(s) of the end state(s). Optionally, the user is presented with the chase state steps leading to the desired end state(s).","A def-use chain (or SSA) is a common representation for data flow analysis and contains information local to a procedure. It tells where data is defined (def) and where it is used (use) within a procedure.","In compiler terms, the definition (def) of a data element is where data value is assigned (e.g., mov eax, 0), whereas, a use is when the data element is later used. For example, if the value in eax is later incremented (e.g., add eax, 1), that is a use.","Thus, the DFG includes an edge from the operands in the move instruction to the add instruction. The bidirectional edges of the DFG tell within a procedure, all the places where the relevant data could have come from or gone to. By following the DFG, a data flow chase provides a step-by-step data flow within the procedure.","As previously stated, a data flow chase includes a chase start state. Once the start state is established, the DFG for a procedure is examined to determine the data movement interesting for the data in the start state. Within a procedure, the DFG will identify the registers, the locals and parameters (i.e., the valves stored on the stack for the procedure containing the start state), and the temporary variables (i.e., the variables created by the compiler that were not in the source code). Thus, the DFG is useful for following data flow through registers, locals, parameters and temporary variables within the operands of the instructions within a procedure. As shown in , states traversed using the data flow graph are the states where control flow remains within a procedure, and data flow within the procedure is locally identifiable data (LID), such as registers, locals, parameters, and temporary variables , , , .","As an example, programs often create memory dynamically for different purposes using memory allocation functions (e.g., malloc( )). However, if a malloc function returns a null value, then the program must be prepared to exit gracefully since no memory is available. Specifically, it would be desirable to test whether a compare function follows each call to malloc( ), in order to determine if a program has provided for error checking required for a graceful exit. In such a case, data flow chasing is used to verify a program.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 4","FIG. 4"],"b":["400","402","404","406","408","410","200","300","308"]},"Of course, the user could continue walking forward in the PIR in order to verify that the listing included a conditional branch  (i.e., a branch if not equal statement), and even further  if it would be desirable to view the error handling.","So the user picks the point of interest where to begin the chase , and the direction they would like to chase (in this case forward), to find all the places where the data returned from malloc is used -.","In one example, the user (i.e., a tool developer) requests via an application programming interface, the desired stop state and the chase returns the locations that match the desired stop state. Additionally, the data flow chain -, or the ending location , can be returned, based on the user's request.","For example, in error detection, the binary file(s) of a program, a start state, and and an end state description are received as input, and the chase determines all paths from the start state that reach a state matching an end state description. In such a case, the start state could be every malloc call in the program, and the end state description would be to determine whether the compare function followed.",{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 5","b":["500","502"]},"In such a case, the PIR is searched in order to identify calls  to the load library function. The chase backward examines the temporary variable created by the push eax instruction , since that is where the load library function expects to receive the library name. As shown, the DFG shows the data locations , and edges  where the implicit temporary variable is defined and used. Thus, the DFG is used to traverse data flow through the function or procedure. As shown, the described end state is where the global name for the library being loaded is moved into the eax register , so the backward chase never left the procedure. However, if the def-use chain reaches a call or return instruction, the chase will use a different representation (CG, FRL, GRL) to continue the chase when data flow exits the procedure.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 2","FIGS. 6-9"],"b":"200"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 6","b":"600"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIG. 7","FIG. 6"],"b":["700","202","204","302","304","206","208","224","226","228","218","220","222","306","308","318","332","210","216","310","316","219","218","220","222","319","318","320","322","323","330","332"]},"The two diagrams ,  represent state machines used for forward  and backward  data flow chasing. The shaded states (e.g., , ) represent identified next instructions of interest, and the unshaded states (e.g., , ) represent the type of data source encountered in the instruction of interest.","A state includes an instruction address and the data identifier of for the data of interest being chased at that address (i.e., state=(instruction address, data identifier)).","The following is an exemplary forward chase using a state machine . In this example, the pointer \u201cp\u201d  contains the return from a call to malloc, and the user would like to chase p forward to find out what is done with the output from the call to malloc( ) .","The bar( ) and foo( ) functions in the source code might compile to the assembly code shown in , at instruction A through H. Since the results of the call to malloc ( ) at instruction B are placed in the eax register as previously discussed, the forward chase begins as shown in , at state . In this discussion, the states  referred to in , correspond with the labeled states shown in , and the addresses  referred to in , refer to the instruction addresses  referred to in . Finally, the data column  in , refers to the location of the data at the corresponding address locations , in .","A state transition occurs when either data is relocated within an instruction (e.g., eax\u2192[ebp+offset], as shown at ) which is also known as a data instance transformation, or the state machine moves the instruction being examined (e.g., mov\u2192cmp, as shown at ), which is also known as an instruction change.  traces the state changes while either the data moves , or the instruction examined changes .","The state trace begins  at the 202 state. At the start state , the data of interest is returned into the eax register, so the state pair at  is \u201cB, eax\u201d. This start state is supplied by the user, along with the binary code of interest, and an indication that a forward chase is desired. For example, the user may click an assembly language instruction presented (e.g., ) on a graphical user interface.","First, the instruction being examined is moved using the data flow to the push instruction at address \u201cC\u201d. The type of instruction is examined in order to determine what state should be entered. Since eax is locally identifiable data (LID), the \u201cpush LID\u201d instruction causes a state change to state . In this state transition , the instruction being examined has changed from address \u201cB\u201d to address \u201cC\u201d, but as expected, the data remains at \u201ceax\u201d.","The push instruction pushes the eax contents onto the stack. Thus, the push creates a temporary variable on the stack, which is also locally identifiable data (LID), so in the transition  from state  back to state , data moves from the eax register to a temporary variable (i.e., temp) on the stack.","The next instruction \u201cC\u201d is a call to foo( ). In this state transition , the instruction has changed, but the data remains in the stack frame (i.e., temp). The instruction has changed from a push \u201cC\u201d to a call instruction \u201cD\u201d. Call instructions are reflected at state . Since a call instruction is observed in the program listing \u201cD\u201d, the call graph is examined in  in order to determine where the foo( ) function is located in the memory. Since the program under static analysis is being examined by a chase program, the call graph  includes a pointer to where foo( ) is located in memory. Thus, when the call to foo is executed at transition , the data is moved from a temporary on the stack, to an input parameter to foo (i.e., parameter). The dotted line  in , represents the situation where a procedure calls a procedure in another binary file (see also, e.g., , at -). Thus, foo and bar may be in the same or a different binary file.","Next, the instruction being examined changes from the call instruction \u201cD\u201d, to the move instruction \u201cF\u201d in foo( ), at transition  to state .","Next, the data is moved from the stack into the eax register in the transition  to state .","Thus, a call graph is used to transition data flow analysis across procedural boundaries for the program under static analysis. Once the PIR is created and a data flow graph for a present procedure is created, data flow graphs for a next procedure can be created (and discarded) lazily, after a procedure is identified within the CG for a data flow transition.","In this forward chase, had the parameter p been used in another call to procedure top (p) , another branch to the tree would be added with a transition from instruction \u201cD\u201d to the location of top as locatable in memory  at the call graph . This additional path trace would contain its own relevant states and transitions, as discussed in , for the call to foo( ).",{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 10","b":["608","602","300","902"]},"When examining instructions within a DFG for a procedure, a chase may encounter an instruction with a pointer memory dereference ,  operand. For example, these instructions often attempt to assign something pointed to by a pointer (i.e., [ptr]), to a LID (i.e., a local parameter or a temporary). Thus, to continue the forward chase , or the backward chase , the backward chase  is used to determine where the pointer points.","For example, given a function with an input parameter of a pointer to a pointer (e.g., bar (int ** pp)), in order to continue a chase (whether forward or backward), the pointer is chased backward to see where the contents of the input to bar are loaded before bar is called with the input parameter. A call graph is used to see what functions are calling the bar function.",{"@attributes":{"id":"p-0073","num":"0072"},"figref":"FIG. 11","b":["206","306","208","308"]},"Based on the addressing mode , the table tells what type of chase is performed . For a global pointer addressing mode  , the global reference list (GRL) resolves where the pointer points , And the forward or backward chase will enter states  or .","If the addressing mode tells that the global is an array , then the method attempts to determine  which element of the array should be used to begin the chase again. For example, as shown in the table , a global, a scale, and an offset can be determined within the addressing mode itself. Thus, only the register is unknown. If the register (i.e., \u201creg\u201d) value can be determined in a backward chase (e.g., reg=4), then the pointer is dereferencing the fourth element in the array, and the array contents can be used to continue the data flow chase, backward or forward, whichever is relevant. However, if the register value cannot be determined, then all elements in the array can be used to continue the chase, if desired. If the register value was known at compile time, then the addressing mode would have resolved to \u201c[global+imm]\u201d, which is the global plus an offset.","The array addressing modes are better understood with reference to . For a global array declaration , since each integer element requires 4 bytes of memory , the global address for an array element is determined by the array base address \u201cg\u201d, plus 4 bytes  times the desired element offset , as determined by the global addressing form .","For a global array where a call to main , determines the array element of interest, since statically nobody known calls \u201cmain(i)\u201d, a backward chase will not resolve the unknown register contents , or when the element is otherwise indeterminate, all 10 elements of g are chased . However, if bar( ) called foo (5) and passed in 5, then \u201ceax\u201d  can be chased back because it is determinate.","For the register and offset addressing mode , the register could be a pointer, a field, a pointer to a global, pointer to an integer, or a pointer to a type, so the backward chase is performed to determine where it points. If it is a type, the field reference (FRL) is used to determine places used by the reference that are relevant to the chase . Further, the FRL can be used to locate wherever in the binary code, that type\/field is written to dynamically. A forward or backward chase that encounters a pointer to a field will enter states  or .","If the register can be chased to a global , then the static data inside the data structure at the offset is used, and if it is written to dynamically all instructions that write to that location dynamically are determined from the global reference list (GRL). A forward or backward chase that encounters a pointer to a global will enter states  or .","Finally, if the addressing mode contains two registers , , then if the first register can be chased to a global, and the second register can be chased to an immediate, then the data inside the global at the offset is used to resolve the reference. Further, if the global is written dynamically at the offset, then the instructions that store into the global at the offset are used to continue the chase. If the second register cannot be chased to an immediate, then the data inside the global is used to continue the case. If the globals are written to dynamically, the instructions that store into the globals are used to continue the chase, as determined by the GRL. If the first register can be chased to a type, then instructions that store into the field array are determined from the FRL. Thus form  can lead to both the field ,  and global ,  states during a forward or backward chase.","Note that pointer dereferencing analysis is done locally within procedures while building the DFG so that references to locals, parameters, and temporaries are already locally resolved.","A field is a member of a class or data structure (e.g., an array field, a data member, etc.). A field reference list or graph (FRL) includes pointers to places in the program where a defined field is used.",{"@attributes":{"id":"p-0083","num":"0082"},"figref":"FIG. 13","b":["1302","1304","1306","1308","1302","1308","1308","1302"]},"Thus, the FRL is one of the states in the state machines , . So if a store field instruction is encountered , or a load field instruction is encountered , or if a pointer dereference is chased back to a field reference , , the state machines use the FRL ,  to obtain the field reference locations, and the data flow chase resumes forward or backward from there. If a backward chase from a pointer memory dereference , , chases back to a pointer to a type that has fields, the FRL is used.","For example, in a forward chase, if a pointer memory dereference is encountered , and a backward chase resolves to a field in the field reference , then the chase continues wherever the field reference is read , and these point to an instruction  where the forward chase continues.","As previously stated, if the backward chase resolves to a data structure that has fields , , but the field within the data structure cannot otherwise be determined, the FRL is used to determine places within the program where that data structure is written, and plural chases resume from each such address, as the forward or backward chase resumes.",{"@attributes":{"id":"p-0087","num":"0086"},"figref":"FIG. 14","b":["1400","1402","1404","1404","1406","1402","1408","320","220"]},"A global variable is a variable defined outside the scope of a procedure. A global reference list points to locations with the program that refer to the global variable.",{"@attributes":{"id":"p-0089","num":"0088"},"figref":"FIG. 15","b":["1500","1502","1506","1504","1508"]},"When a chase locates a global variable in the program, the GRL , , is useful for resuming the chase (forward or back) wherever the global variable is read , or written to . These instruction pointers  to the global references, allow skipping directly to the instructions in the program where the forward chase , or backward ,  should resume.","A call graph (CG) has pointers to different procedures in the program. The program has instructions in a static order, while the call graph, the data flow graph, the field reference list, and the global reference list have pointers into the program abstraction. These graphs and lists map pointers into the program abstraction (see, e.g., PIR, IR, etc.) for different reasons. State machines walk forward or backward through the program abstraction using the graphs and lists which have pointers into points of interest in the program.","The resulting data flow chase uses the binary input, start state, and direction indication, and the created graphs and lists, to piece together as needed, instead of building all at once in advance, the desired data flow points of interest and step-wise path.","The data flow graph is useful within a procedure because it creates def-use (or SSA) patterns within a procedure, which allows removing or ignoring the clutter of instructions not relevant to the identified data movement within the procedure.",{"@attributes":{"id":"p-0094","num":"0093"},"figref":"FIG. 16","b":["1600","1602","1606","1608","1610","1612","1614","1616","1618"]},"Using such an internal representation (IR) is helpful as a set-up for acquiring the information useful for traversing the state machines described herein. For example, by traversing this IR, the malloc instructions within the program are more easily located as required for the start state described with reference to . In another example, the IR is traversed to create a CG, a FRL, a DFG, or a GRL.",{"@attributes":{"id":"p-0096","num":"0095"},"figref":"FIGS. 17 and 18"},"For example, once a program has been traversed to create an internal representation , an instruction corresponding to load library function call is located within the program . As shown at , a pointer to a load library function  is used to locate a load library operand , which is a parameter  to the call instruction. This parameter  is then used to create a chase object . The chase object is then used as an input parameter , with a description of a chase exit state , to chase back from each such load library call, and enumerate the name of any DLL that is loaded dynamically  within the program.","The described application program interface (API) , , consists of methods and data related to a VChase interface . The Create method  is used to specify the initial start state for the chase. A destroy method  is provided for cleaning up memory after the chase has been used. The chase types  correspond to the states in FIGS.  and \u2014and the current chase type of an object can be determined using the get type API . The chase location is available using the get location APIs , and there is a shortcut for determining if the current location is a call . There are APIs to access the data location of the chase object . Since the chase can diverge into multiple paths, there is an API to access the other paths in the state . There are APIs to chase one step in the state machine , as well as an API to a chase back to a type (or instance of a type) . There are also APIs to chase until a condition is reached  The more advanced chase to a condition  allows specifying several different actions  using a chase done callback interface  , Also provided are some example chase stop conditions .",{"@attributes":{"id":"p-0099","num":"0098"},"figref":"FIG. 20","b":["2000","2024","2012","2002","2004","2010","2014","2022","2012"]},"An internal representation (IR) component  read binary code in one or more binary files - that make up a computer program. The IR component creates an internal representation of the program identifying procedures and instructions in the program, and stores the IR in a data structure such as a list, tree or graph.","A call graph (CG) component  reads the IR and creates a call graph (list or tree) of procedures within the program that call or are called by other procedures.","A field reference (FR) component , creates a data structure (list, tree, or graph) holding field reference definitions and uses within the IR.","A data flow (DF) component , creates a data structure holding the data flow for relevant instructions within a procedure (e.g., def-use or SSA).","A global reference (GR) component , creates a data structure (list, tree, or graph) holding global references and uses within the IR.","Finally, forward  and backward  chase components reference data structures (e.g., state machines) that identify instructions within a DF graph trace. Based on the identified instructions (e.g., operator and operands), the state machines - direct the data flow chase to transition the chase to a DF graph of another procedure in the CG graph, (2) transition the chase to an instruction indicated in the GR list, (3) transition the chase to an instruction indicated in the FR list, (4) chase backwards to locate an instruction indicated by a pointer dereference, and, or (5) continue the chase through the DFG for the present procedure.","An end state can be indicated so that the state machines know when to stop the chase, or as each new state is identified during the chase, the user can decide to end the chase or request the next state in the chase.",{"@attributes":{"id":"p-0107","num":"0106"},"figref":"FIG. 21"},"With reference to , an exemplary system for implementation includes a conventional computer  (such as personal computers, laptops, servers, mainframes, and other variety computers) includes a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The processing unit may be any of various commercially available processors, including Intel x86, Pentium and compatible microprocessors from Intel and others, including Cyrix, AMD and Nexgen; Alpha from Digital; MIPS from MIPS Technology, NEC, IDT, Siemens, and others; and the PowerPC from IBM and Motorola. Dual microprocessors and other multi-processor architectures also can be used as the processing unit .","The system bus may be any of several types of bus structure including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of conventional bus architectures such as PCI, VESA, AGP, Microchannel, ISA and EISA, to name a few. The system memory includes read only memory (ROM)  and random access memory (RAM) . A basic input\/output system (BIOS), containing the basic routines that help to transfer information between elements within the computer , such as during start-up, is stored in ROM .","The computer  further includes a hard disk drive , a magnetic disk drive , e.g., to read from or write to a removable disk , and an optical disk drive , e.g., for reading a CD-ROM disk  or to read from or write to other optical media. The hard disk drive , magnetic disk drive , and optical disk drive  are connected to the system bus  by a hard disk drive interface , a magnetic disk drive interface , and an optical drive interface , respectively. The drives and their associated computer-readable media provide nonvolatile storage of data, data structures, computer-executable instructions, etc. for the computer . Although the description of computer-readable media above refers to a hard disk, a removable magnetic disk and a CD, it should be appreciated by those skilled in the art that other types of media which are readable by a computer, such as magnetic cassettes, flash memory cards, digital video disks, Bernoulli cartridges, and the like, may also be used in the exemplary operating environment.","A number of program modules may be stored in the drives and RAM , including an operating system , one or more application programs , other program modules , and program data ; in addition to an implementation .","A user may enter commands and information into the computer  through a keyboard  and pointing device, such as a mouse . These and other input devices are often connected to the processing unit  through a serial port interface  that is coupled to the system bus, but may be connected by other interfaces, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video adapter . In addition to the monitor, computers typically include other peripheral output devices (not shown), such as speakers and printers.","The computer  operates in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a server, a router, a peer device or other common network node, and typically includes many or all of the elements described relative to the computer , although only a memory storage device  has been illustrated. The logical connections depicted include a local area network (LAN)  and a wide area network (WAN) . Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the local network  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications (e.g., via the LAN  and a gateway or proxy server ) over the wide area network , such as the Internet. The modem , which may be internal or external, is connected to the system bus  via the serial port interface . In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Having described and illustrated the principles of our invention with reference to illustrated examples, it will be recognized that the examples can be modified in arrangement and detail without departing from such principles. It should be understood that the programs, processes, or methods described herein are not related or limited to any particular type of computer apparatus, unless indicated otherwise. Various types of general purpose or specialized computer apparatus may be used with or perform operations in accordance with the teachings described herein. Elements of the illustrated embodiment shown in software may be implemented in hardware and vice versa. Techniques from one example can be incorporated into any of the other examples.","In view of the many possible embodiments to which the principles of our invention may be applied, it should be recognized that the details are illustrative only and should not be taken as limiting the scope of our invention. Rather, we claim as our invention all such embodiments as may come within the scope and spirit of the following claims and equivalents thereto."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 7","FIG. 6"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 21"}]},"DETDESC":[{},{}]}
