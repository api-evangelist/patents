---
title: Imaging system including detector framing node
abstract: An imaging system includes a programmable detector framing node controlling generation of radiation and controlling radioscopic image detection. Radioscopic image data is acquired and communicated independently of a host computer operating system. The detector framing node controls events in real time according to an event instruction sequence and communicates received radioscopic image data to host memory through a computer communication bus. Image data is received from a selected flat panel detector of a plurality of different flat panel detectors. The image data is selectively reordered according to parameters of the selected flat panel detector before communication to host memory.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06975752&OS=06975752&RS=06975752
owner: General Electric Company
number: 06975752
owner_city: Niskayuna
owner_country: US
publication_date: 20010131
---

{"@attributes":{"id":"description"},"GOVINT":[{},{}],"heading":["STATEMENT REGARDING FEDERALLY SPONSORED RESEARCH & DEVELOPMENT","BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["The U.S. Government may have certain rights in this invention pursuant to the Portable Apollo X-Ray System for Military Applications Cooperative Agreement number DAMDD17-00-2-0009, awarded by the United States Army.","The invention relates to a method, system, and apparatus for controlling, acquiring and processing digital radioscopic image data, and in particular to a method, system and apparatus for controlling and communicating acquired digital radioscopic x-ray image data to a computer running a non-real time operating system.","Medical imaging is a specialty that uses radiation, such as gamma rays, x-rays, high-frequency sound waves, magnetic fields, neutrons, or charged particles to produce images of internal body structures. In diagnostic radiology, radiation is used to detect and diagnose disease, while in interventional radiology, radiation is used to treat disease and bodily abnormalities.","Radiography is the technique of producing an image of any opaque specimen by the penetration of radiation, such as gamma rays, x-rays, neutrons, or charged particles. When a beam of radiation is transmitted through any heterogeneous object, the radiation is differentially absorbed depending upon varying object thickness, density, and chemical composition. The radiation emergent from the object forms a radiographic image, which may then be realized on an image detection medium, such as photographic film directly or by using a phosphor to first create a light image. Radiography is a non-destructive technique of testing a gross internal structure of an object, and is conventionally used in medical and industrial applications. Radiography is used to non-destructively detect medical conditions such as tuberculosis and bone fractures, as well as manufacturing imperfections in materials such as cracks, voids, and porosities.","X-ray radiography finds particular usefulness in medical and industrial applications. X-rays are a form of electromagnetic radiation, and were accidentally discovered in 1895 by Wilhelm Conrad Roentgen. X-rays are alternately referred to as roentgen rays. In circa 1895, Roentgen found that x-rays propagate through an internal object such as a hand and expose photographic film, thereby revealing an internal structure. X-rays exhibit different properties than visible light rays, and were designated by Roentgen as \u201cx-rays,\u201d with \u201cx\u201d referring to the unknown. For example, x-rays are not focused with a traditional optical light lens, but rather use sophisticated focusing techniques. Today, x-rays are categorized as electromagnetic radiation having a frequency range extending between 2.4\u00d71016 Hz to 5\u00d71019 Hz. Most x-rays have a wavelength smaller than an atom and therefore interact with matter in a granular fashion, that is, like bullets of photon energy. X-rays are absorbed by materials according to the exponential absorption law\n\n\u2003\u2003(1.0)\n\nwhere Iis the initial intensity of the x-ray beam; Iis the intensity after passage through an object, the object having a thickness x, density \u03c1, linear absorption coefficient \u03bc, and mass absorption coefficient \u03bc\/\u03c1.\n","X-rays are formed through celestial phenomenon, such as internal reactions of stars and quasars, and through electronic x-ray generation devices, such as x-ray tubes. X-ray tubes generally produce x-rays by accelerating a charged particle, such as an electron, through an electrostatic field and then suddenly stopping the x-ray through collision with a solid target. This collision ionizes the solid target by transporting closely held electrons to a higher energy state. As the electrons in the solid target return to their original energy state, x-rays are produced. X-rays are produced within x-ray tubes by accelerating electrons in a vacuum from a cathode toward an anode, with or without particle beam shaping and accelerating through placement of electrodes.","The electronic detection of x-rays is generally referred to as electronic radiography or radioscopy. Prior to electronic detection, radiographic images were captured on photographic film or displayed on a fluorescent screen. Real time visual observation of x-rays on a fluorescent screen is referred to as fluoroscopy. However, as early as the 1930s photo-multiplier tubes (a form of vacuum tube) were developed to produce an electrical signal in response to received light. Photo-multiplier tubes generally respond well to optical range light rays and are therefore often optically coupled with a scintillating material to detect non-optical electromagnetic radiation. The scintillating material converts non-optical radiation, such as gamma rays (emitted by radio-active isotopes used in nuclear medicine) and x-rays into optical radiation. Beginning circa 1980, photo-multiplier\/scintillator detectors are generally being replaced by amorphous silicon based photo-cells.","Radioscopy includes one shot x-ray detection, also known as fluorography, and multiple shot x-ray detection, also known as fluoroscopy. Radio-mammography is a form of radioscopy in which the breast is vigorously compressed prior to exposure to maximize detail and minimize radiation exposure. Computed tomography (\u201cCT\u201d), also called computed axial tomography (\u201cCAT\u201d), is a form of radioscopy in which an x-ray tube is rotated around the body while emitting a narrow x-ray beam. The received x-ray beam information is then combined in a computer to produce a two or three dimensional anatomic medical image. Magnetic resonance imaging (\u201cMRI\u201d) is a diagnostic procedure in which a high strength magnet aligns the spin of nuclei within cells of a body, such that each nuclei acts like a radio, both receiving and transmitting radio signals. External radio frequency signals are then applied to the body to disturb the spinning cellular nuclei. After the radio signal is stopped, the nuclei realign with the applied magnetic field while emitting faint radio signals. These faint radio signals correspond to different body tissues and are detected to produce an anatomical image.","Radioscopy and related medical diagnostic imaging technologies use precision control over penetrating radiation and well as precision timing for detection and processing of resultant image data. Medical diagnostic imaging generally acquires and controls a very large amount of image data, which in turn is communicated to computer processing equipment at a very high data rate. To provide control over the generation, detection, and processing of medical diagnostic imaging, computer workstations employ the use of a real time operating system (\u201cRTOS\u201d) to control operation. A real time operating system, such as VXWORKS\u00ae by Wind River Systems, Inc. of Alameda, Calif., is an operating system that immediately responds to real time signaling events. On the other hand, non-real time operating systems, such as a WINDOWS\u00ae platform or a UNIX\u00ae platform, process operations in the form of tasks until the task is complete. Both WINDOWS\u00ae and UNIX\u00ae are non-real time, multi-task operating systems in which a processor or processors are continuously interrupted to respond to multiple task based system events. Due to the high speed of commercially available processors, multi-tasking operating systems may appear to control a number of simultaneous events. However, a multi-tasking operating system, by design, cannot respond in real time to the high through-put demands of real time processing equipment, such as used in medical diagnostic imaging.","It is therefore desirable to provide an imaging system to control a radiation generation system and an image detection system in real time. The imaging system includes a host computer having a host memory and at least one host processor. The imaging system also includes a detector framing node, which is programmed to receive image data from a plurality of different flat panel detectors. The detector framing node communicates the image data to the at least one host processor over a communication bus independent of a host operating system.","It is further desirable to provide a detector framing node, including a computer communication interface to communicate image data with a host memory of a host computer over a computer communication bus. The host computer includes a host processor running an operating system. The image data is communicated from the computer communication interface to the host memory independently from control of the host processor. The detector framing node also includes a control unit to receive a plurality of event instructions from the host computer through the computer communication interface. The event instructions selectively control a radiation generation system and an image detection system. The event instructions are executed in real time and at predetermined timing intervals.","Referring to , a method, system, and apparatus are illustrated for controlling, acquiring and processing digital radioscopic image data. Imaging system  comprises radiation generation system , image detection system , host computer , and detector framing node . Host computer  includes monitor , host processor  and host memory . According to an embodiment of the present invention, imaging system  is an image detector monitoring system. According to another embodiment of the invention, the components of imaging system  function together as a single apparatus.","Radiation generation system  generates radiation to pass through object  and to be detected by image detection system . According to an embodiment of the present invention, radiation generation system  includes x-ray generation unit  to generate and focus radiation  toward object . According to an embodiment of the present invention, radiation  takes the form of x-rays. According to another embodiment of the present invention, radiation  takes the form of a plurality of sequentially generated radiation bursts. According to an embodiment of the present invention, object  is in the form of the human body. Upon passage through object , x-rays  form radiographic image  for later detection. In general, x-rays are generated by x-ray generation unit  in response to control signals output from x-ray control system . Radiographic image  is received by image detection system  and converted into a digital radiographic image. The digital radiographic image is then output from image detection system  and transmitted to host computer . Host computer  provides electronic control to radiation generation system  and to image detection system .","Image detection system  includes flat panel detector  for receiving radiographic image . Flat panel detector  becomes heated during operation, and is therefore connected to power supply\/chiller  for supplying power and cooling thereto. A digital radiographic image is output from flat panel detector  to host computer .",{"@attributes":{"id":"p-0089","num":"0088"},"figref":"FIG. 2","b":["116","116","116","116","116","126","128"]},{"@attributes":{"id":"p-0090","num":"0089"},"figref":"FIG. 3","b":["116","2","108","126","134","134","134","134","130","108","132","130","134","136","130"],"sub":["2","2"]},"Amorphous silicon panel  is a photo-diode\/transistor array that receives and converts optical radiographic image  into a plurality of representative image data values . Image data values  are received in analog form by interconnect electronics , and output from panel  as analog image data. Scintillating layer , amorphous silicon panel , and interconnect electronics  are formed on silicon glass substrate  through semiconductor technology known in the art. Together, scintillating layer , amorphous silicon panel , interconnect electronics , and glass substrate  form x-ray detection panel .",{"@attributes":{"id":"p-0092","num":"0091"},"figref":["FIG. 4","FIG. 4"],"b":["134","128","136","146","146","148","150","150","148","136","130","136"]},"X-ray detection panel  provides an array of light sensors with a small spacing between elements, and a large number of elements to adequately receive and detect projected x-ray radiographic images. Amorphous silicon panel  is a thin film technology formed on a relatively large glass substrate . Eleven layers of amorphous silicon, various metals, and insulators are deposited by plasma enhanced chemical vapor deposition (\u201cPECVD\u201d), sputtering and meniscus coating to form field effect transistors (\u201cFETs\u201d), diodes, interconnects, and contacts. X-ray detection panel  forms panels for industrial and medical applications, and in particular, a cardiac\/surgical digital x-ray panel, 20\u00d720 cm; a radiography digital x-ray panel, 41\u00d741 cm; and a mammography digital x-ray panel, 19\u00d723 cm. The cardiac\/surgical digital x-ray panel has 1024 columns\u00d71024 rows at 200 \u03bcm pitch; the radiography digital x-ray panel has 2048 columns\u00d72048 rows at 200 \u03bcm pitch; and the mammography digital x-ray panel has 1920 columns\u00d72304 rows at 100 \u03bcm pitch.","Amorphous silicon provides a number of advantages over single crystal silicon for the formation of flat panel detectors, and is particularly distinguishable from single-crystal silicon. Amorphous silicon is characterized by having no definite form, and having no real or apparent crystalline structure. On the other hand, single-crystal silicon is grown as a single crystal, sliced into wafers, then polished for further refinement into integrated circuits. Amorphous silicon allows the formation of much larger panels than single crystal silicon because the formation of a single crystal is not used. However, amorphous silicon finds a 100 to 1000 times increase in defects, and a significant reduction in switching speed, which effect signal lag and signal offset characteristics. Scintillating layer , CsI(Tl), converts x-rays into optical rays and is evaporated onto amorphous silicon panel  to provide intimate contact therewith. CsI(Tl) forms a needle-like structure, which acts like a plurality of light pipes to prevent lateral spread of the light. Moreover, CsI(Tl) provides a transmission spectrum which is well matched to the quantum efficiency of amorphous silicon layer .",{"@attributes":{"id":"p-0095","num":"0094"},"figref":"FIG. 5","b":["152","136","154","154","156","158","156","160","158","158","158","158"]},"X-ray exposure creates electron-hole pairs in photo diodes  of amorphous silicon, x-ray detection panel  causing partial discharge. When field effect transistors  are then turned on, photo diodes  are recharged, and the amount of charge needed to recharge photo diodes  is measured. During operation, all row lines are turned off, i.e. to \u221211 V, during x-ray exposure. The row lines are then sequentially turned on, i.e. to +11 V. Analog to digital conversion of the signals on the appropriate column lines are pipe lined such that the outputs from row \u201cn\u201d are converted from analog information to digital information while row \u201cn+1\u201d is read out. The time period used for analog to digital conversion is on the order of the time used to read out each row line.",{"@attributes":{"id":"p-0097","num":"0096"},"figref":"FIG. 6","b":["116","116","134","164","166","164","166","166","134","122"]},"Reference and regulator board  combines data output from column multi-chip modules  and outputs the same to detector control board . In summary, row multi-chip modules  turn field effect transistors  on and off while column multi-chip modules  read out respective column signals. Reference and regulator board  supplies voltages to the row and column modules, while communicating control and data signals with respect to detector control board .",{"@attributes":{"id":"p-0099","num":"0098"},"figref":"FIG. 7","b":["116","116","116","170","172","174","170","172","174","176","172","178","174","180"]},{"@attributes":{"id":"p-0100","num":"0099"},"figref":"FIG. 8","b":["170","182","182","184","186","0","511","184","186","0","0","1023","184","186","1","184","186","184","186","0","0","1023","184","1024","2047","186"]},{"@attributes":{"id":"p-0101","num":"0100"},"figref":"FIG. 9","b":["178","180","122","178","172","180","174","178","122","188","124","1024","2047","122","122","189","188","189","195"]},"Reference and regulator board  includes first combination unit  for combining the outputs from multi-chip modules , and also second combination unit  for combining the outputs from multi-chip modules  corresponding to columns -. Each multi-chip module  includes eight analog read out chips (\u201cARCs\u201d) , which provide a corresponding output to digital read out chips (\u201cDRCs\u201d) . Thus, the output from the DRCs  are received by reference and regulator board .","Each ARC chip  utilizes a non-linear ramp-compare type analog digital converter. Each ARC chip  also receives 32 analog inputs and converts the data into eight channels of multiplexed twelve bit serial, grey scale encoded, data. Each DRC chip  then receives the multiplexed twelve bit serial grey encoded data from four ARC chips , performs serial to parallel conversion, and converts the grey code into twelve bit binary code. Each ARC chip  performs analog to digital conversion on the received data by comparing the signal from each data line in a comparator with a square root encoded ramp generated by a digital to analog converter in common to all channels of all ARCs . The ramp voltage is increased in steps at a regular clock rate. When a ramp voltage matches a held voltage, a comparator trips, and a ramp counter value is latched. A time to convert each line of data is at least as great as the clock period times the minimum number of clocks used to convert all received column data lines. A voltage step of the ramp is increased as the signal increases. Quantum noise increases as the square root of each signal, and accordingly the step is increased quadratically so that the step size is a fixed proportion of the noise. By way of the foregoing, interface conditioning of control signals bound for row and column modules use a clock signal on the order of 32.5 MHz, for buffering data output between column modules  and  and detector control board .",{"@attributes":{"id":"p-0104","num":"0103"},"figref":"FIG. 10","b":["124","124","188","178","124","180","200","202","200","202","204","206","204","206"]},"Operation of detector control board  is controlled by control unit . Control unit  is formed as a field programmable gate array (\u201cFPGA\u201d). Control unit  receives 16 bit pixel data from decode LUT  and 16 bit pixel data from decode LUT , then combines the pixel data into a 32 bit word. The 32 bit word is then output to image communication interface . According to an embodiment of the invention, image communication interface  is a fiber optic interface. Each 32 bit word is a combination of two 16 bit pixels, which were output separately from detector control board . The two pixels included in each 32 bit word may be side by side, as in a mammography single digital x-ray panel  (set forth in detail below and in reference to  (PRIOR ART)) or may be received from two separate panels, such as output from first panel portion  and second panel portion  of cardiac\/surgical digital x-ray panel . Radiography digital x-ray panel , set forth below and in reference to  (PRIOR ART), also includes two panel portions  and , and therefore follows the pixel format of cardiac\/surgical digital x-ray panel . Split panel detector systems, corresponding to cardiac\/surgical digital x-ray panel  and radiography digital x-ray panel , utilize data \u201creordering\u201d before display on a conventional computer monitor. Data reordering is set forth in more detail below with regard to detector framing node .","Image communication interface  clocks 32 bit words received from control unit  into encoder\/decoder unit . Encoder\/decoder unit  converts each received 32 bit word into four ten bit words, each having error correction. The ten bit words are in turn received by transmitter . Transmitter  converts the received ten bit words into serial data having two bits, namely a clock bit and a signal bit. Transmitter  outputs the two bit data to fiber optic transceiver  for conversion into a fiber optic signal. The fiber optic signal is then transmitted on image detection bus  to a detector framing node, set forth in detail below. According to an embodiment of the present invention, image detection bus  is an optical fiber data link. Likewise, fiber optic transceiver  receives fiber optic signals from the image detection bus  and converts the received optical signals into a two bit data signal for reception by receiver . Receiver , in turn, converts the received two bit data, including a clock and a data signal, into ten bit words having error correction. The ten bit words are then received by encoder\/decoder unit  for conversion into 32 bit words, which are stored in register  before transmission to control unit . An output from fiber optic transceiver  is also received by fiber optic signal detection unit  to maintain timing and protocol in cooperation with control unit . Control unit  is clocked by oscillator . Control unit  provides a control signal to reference and regulator board  by way of control line . Control unit  is a FPGA, Flex 10k50 manufactured by Altec, Inc. of San Jose, Calif.",{"@attributes":{"id":"p-0107","num":"0106"},"figref":"FIG. 11","b":["170","228","228","230","232","228","116","176","180","7","0","2047","230","2048","4095","232","228","182","228","182"]},{"@attributes":{"id":"p-0108","num":"0107"},"figref":"FIG. 12","b":["116","116","236","238","236","240","242","240","242","236","240","224","236","236"]},{"@attributes":{"id":"p-0109","num":"0108"},"figref":"FIG. 13","b":["236","244","244","244","244","244","244"]},"The 128 repair lines included in mammography digital x-ray panel  are used to repair open column address lines caused by manufacturing defects. The repair lines cross over both ends of the address lines and are separated by an insulating layer. A repair connection is facilitated by using a laser to weld an address line to a repair line through the insulating layer. In the case of row address lines, the row address lines are fully repaired using spare lines on flat panel detector , and therefore the readout system is does not account for the repair. In the case of column repairs, data from repair lines is output in a different sequence from flat panel detector  such that the data is sorted by way of post processing.",{"@attributes":{"id":"p-0111","num":"0110"},"figref":"FIG. 14","b":["116","116","248","250","178","180","248","250","172","174"]},"Each embodiment of flat panel detector  set forth above may be formed with redundant row multi-chip modules  to preserve data integrity in case of defects in panel formation.",{"@attributes":{"id":"p-0113","num":"0112"},"figref":"FIG. 15","b":["300","300","300","300","114","301","309","301","304","313","314"]},"System  replaces a prior Image Detection Controller subsystem (\u201cIDC\u201d), which was based upon a TMS320-C80 processor and PC using real time operating system, VXWORKS\u00ae. System  achieves 30 frames\/sec acquisition and processing of 1024\u00d71024 pixel images for fluoroscopy. Image detection bus  provides a 1.25 Gbit\/sec fiber optic communication link between host computer  and detector control board . Image detection bus  particularly communicates between detector control board  of image detection system  and detector framing node (\u201cDFN\u201d) , which is embodied as a peripheral component interconnect (\u201cPCI\u201d) card suitable for connection to computer communication bus . According to an embodiment of the present invention, computer communication bus  is a PCI bus, and more particularly, a PCI bus operating at 33 MHz. According to another embodiment of the present invention, computer communication bus  is a PCI bus operating at 66 MHz. Detector control board  itself is embodied in a prior Apollo Common Detector Control Printed Wiring Assembly (\u201cPWA\u201d), manufactured by General Electric Medical Systems of Milwaukee, Wis. The Apollo Common Detector Control PWA is used in a variety of applications including full field digital mammography (\u201cFFDM\u201d). Use of detector framing node  facilitates use of non-real time host computer  for image processing after image acquisition.","System  provides acquisition and control based on a commercial single or multiple processor PC hardware, such as the PENTIUM\u00ae class processors manufactured by Intel, Inc., of Santa Clara, Calif. System  is a single data acquisition and control system for present and anticipated x-ray modalities, and supports application of the system to both engineering and manufacturing. A flexible architecture is provided to address needs of improved or future technology.","System  supports single and multiple frame acquisition of images with frame to frame control of supported detector parameters. A number of rows and a number of columns in an acquired image are supported as input parameters, while providing control of data acquisition timing from an external frame trigger. System  acquires and views gain and offset corrected images at 30 frames\/sec for a 1024\u00d71024 array or 7.5 frames\/sec for a 2048\u00d72048 image. System  supports a non-real time operating system to test system functionality. According to an operative embodiment, the non-real time operating system is WINDOWS NT 4.0\u00ae supporting C++ language based applications. Modular software is structured to support a combination of applications and more direct hardware access for advanced users and programmers. User-coded test applications and generalized data acquisition routines are provided in separate modules.","System  provides archive capability for both raw, and gain and offset corrected data for single and multiple frames, including regions of single and multiple frames. A high resolution display of single and multiple frames and for regions of single and multiple frames is supported for both freshly acquired and archived data. Control of radiation generation system  or a grid controlled x-ray tube is supported through a real time bus interface. Real time triggering of the x-ray generator with 2 \u03bcsec timing resolution is supported along with programmable time delays of up to 16 seconds.","System  is a real time image data acquisition system in which the image data is acquired at a predetermined frame rate and the number of image frames to be acquired is determined at the time of acquisition. Before acquisition, the event compiler  sets up the frame rate by setting a time for executing a repetitive trigger over the real time bus . Likewise, the event compiler  sets up image acquisition by delaying the image request command to the image detection system  from the repetitive trigger. There is an integration period before scanning of the flat panel detector  is allowed to account for delays in the phosphor and collection of electron-hole pairs in the photodiode array. For real time data acquisition, there is minimal buffering during transfer of the image data from the image detection system  to the detector framing node , such that the image detection system  and the detector framing node  operate in synchronism.","According to an embodiment of the present invention, system  is configured as follows:",{"@attributes":{"id":"p-0119","num":"0118"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Computer:","Single\/multiple PENTIUM\u2009\u00ae class with"]},{"entry":[{},"PCI back-plane"]},{"entry":["Operating System:","WINDOWS NT 4.0\u2009\u00ae"]},{"entry":["Panel Designs:Apollo20:","1024 \u00d7 1024 - Data Reordered"]},{"entry":[{},"Apollo40: 2048 \u00d7 2048 - Data Reordered"]},{"entry":[{},"Mammo3: 2304 \u00d7 2048 - Bad column corrected"]},{"entry":[{},"Smaller regions of interest"]},{"entry":["Acquisition Modes:","Radiographic (isolated frames)"]},{"entry":[{},"Real Time (30 frames\/sec"]},{"entry":[{},"for 1024 \u00d7 1024 image)"]},{"entry":[{},"Cine Loop (30 frames\/sec"]},{"entry":[{},"for 1024 \u00d7 1024 image) Hardware debug"]},{"entry":["Image processing:","Offset, Gain, Bad pixel, Mammography"]},{"entry":[{},"bad column"]},{"entry":["Display Req.:","8 bit gray scale including gamma correction"]},{"entry":[{},"Real time window and level"]},{"entry":[{},"Xia type display applications including zoom"]},{"entry":[{},"and pan"]},{"entry":["X-ray support:","Simple 8 bit parallel real time bus"]},{"entry":["Archive support:","Hard drive and writable CD ROM drive"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"System  provides an improvement over the above prior IDC test system. Real time parameters, which were previously addressed in prior art VXWORKS\u00ae operating system (\u201cOS\u201d), are now captured in detector framing node  operatively embodied as a single PCI card. Detector framing node (\u201cDFN\u201d)  contains fiber channel communication circuitry, a buffer memory, a PCI communications controller, a real time bus to control the x-ray generator and a set of firmware programmable FPGAs for control of all circuits on DFN . An external PCI memory card is used in conjunction with DFN  to expand computer memory and provide storage for raw pixel x-ray image data. Operation of data acquisition and subsequent data processing is through user written applications. A library of functions access hardware functionality and facilitate disparate needs of users in engineering, device repair and manufacturing areas.",{"@attributes":{"id":"p-0121","num":"0120"},"figref":"FIG. 15","b":["300","310","309","310","114","312","377","112","379","109","310","312","114","312","304"]},{"@attributes":{"id":"p-0122","num":"0121"},"figref":"FIG. 15","b":["300","310","309","310","312","312","311","314","302","304","312","312","302","114","312","114"]},"Once event sequence  is complete, host computer  retrieves the acquired data in addition to various diagnostics and responses, which were recorded during execution of the event sequence. Therefore, host computer  is involved in pre- and post processing roles, and is therefore entirely removed from real-time operation.","As illustrated, detector framing node  communicates commands and responses with computer communication bus  by way of acquisition control unit . Event sequence  is communicated to event queue  by way of acquisition control unit . Event instructions are then transmitted to radiation generation system  from event queue . During application of the radiation, event instructions are transmitted to event queue  from image detection system . Radioscopic image data is also received by frame store  from image detection system , then transmitted to acquisition control unit  for transmission to host computer . In host computer , image data  is transferred through DFN device driver  and acquisition dynamic link library (\u201cacquisition DLL\u201d)  before being subject to gain, offset, and bad pixel correction by gain, offset, and bad pixel correction unit . After completion of the correction, the image data is interfaced with test calculation unit  before being sent to disk archive .",{"@attributes":{"id":"p-0125","num":"0124"},"figref":"FIG. 16","b":["328","330","114","301","313","328","313","330","314","314","304","109","112","330","335","336","337"]},"For communication with software system , instructions are prepared in excel user interface , and then translated by translator  before being received by Perl script unit . Event compiler  also outputs information to binary file unit . The output from binary file unit  is then loaded into EAB memory  on EP  under control of user API , Acquisition DLL , and DFN device driver . The binary file contains information to control event sequence . Event sequence  can be debugged on the high resolution display  be creating the timing information in the event simulator .",{"@attributes":{"id":"p-0127","num":"0126"},"figref":"FIG. 17","b":["340","340","340","304","114","115","115","115","117","334","336","340","302","342","302"]},"Hardware system  includes DFN , which is connected to computer communication bus . Computer communication bus  is comprised of first PCI sub bus  and second PCI sub bus , connected by bridge . Second PCI sub bus  interconnects with disk archive  by way of small computer systems interface (\u201cSCSI\u201d) . Second PCI sub bus  also connects to high resolution display  by way of PCI graphics card . Second PCI sub bus  connects to host processor , accelerated graphics port (\u201cAGP\u201d)  and computer RAM  by way of bridge . AGP  is a high speed graphics port for connection of monitor  by way of video card .","In a real time mode, PCI  bus arbitration will slow the data transfer rates on first PCI sub bus  and second PCI sub bus  such that the continuous display rate of 30 frames\/sec will likely be determined by arbitration conflicts. In hardware debug mode, a test of DFN hardware is started from host processor  by sending a Command to DFN . The results of this test (i.e. bad, good) are returned to host computer . This hardware debug mode is used to run the Built-in-self test (\u201cBIST\u201d) described later in the specification. In real time mode, data is sent directly from a buffer memory on the DFN  to computer RAM  and displayed almost simultaneously.",{"@attributes":{"id":"p-0130","num":"0129"},"figref":["FIG. 18","FIG. 10"],"b":["304","376","124","376","380","380","381","381","381","302","381","380","372","372","374","378","378","379","374","377","376","382","384","302","390","376","370"]},"Imaging system  provides support for several different users, including support for different x-ray image panel designs and applications. Accordingly, flexible testing is provided to support different image acquisition modes. The acquisition modes used by imaging system  are described in terms of the target applications and users. For example, support for, at least, four specific modes is presented: Hardware Debug, Panel Setup, Single Frame, and Real Time. However, modal capability of imaging system  is more generically specified in terms of data management and bandwidth considerations.",{"@attributes":{"id":"p-0132","num":"0131"},"figref":"FIG. 19"},"As illustrated in , \u201cgbr\u201d refers to the three particularly supported correction algorithms, namely corresponding to cardiac\/surgical digital x-ray, radiography digital x-ray, and mammography digital x-ray, other than offset correction. These are: gain correction (g), bad-pixel correction (b), and repair line correction (r).",{"@attributes":{"id":"p-0134","num":"0133"},"figref":"FIG. 20","b":["304","304","377","124","379","109"]},"Panel setup mode is used at the beginning of panel test, during panel alignment, where near real time visualization is valuable to ensure proper flex contacts to image detection system . Here, data acquisition occurs with reordering in DFN  as a single processing operation. There is direct transfer of the data to computer RAM , bypassing PCI RAM card . In other applications data is passed to PCI RAM card  or another commercially available image processing card rather than computer RAM . Once the data is in the PCI RAM card , the data is accessible by host processor  at a later time for processing. In the case of a commercially available image processing card, the data is further processed in that card before delivery to host processor  via computer communication bus . As a result, data is displayed at 30 frames\/sec for a 1024\u00d71024 image, or 7.5 frames\/sec for a 2048\u00d72048 image. There is a one or two frame delay between acquisition and display of the image. For those applications where the data is transferred directly to host computer , the available computer RAM  limits the number of frames stored.","A single frame mode provides a typical application including mammography digital x-ray and radiography digital x-ray testers where a relatively small number of frames are acquired. One or more frames are captured and reordered in DFN memory block  on the DFN , transferred to computer RAM , and processed in host processor  to correct gain, offset, bad columns, channels of ARCs  and bad pixels. Corrections to channels of ARCs  include gain and offset correction to correct ARC gain, which varies from channel to channel. After correction, the frames are displayed on high resolution display . The delay between the completion of data acquisition and display is expected to be less than 0.25 sec for a single 2048\u00d72048 image. After acquisition, the small number of frames would still be in computer RAM  and would be available to the application after display.","An embodiment of a real time mode is a cardiac\/surgical digital x-ray tester or a radiography digital x-ray tester having a real time display, such that data is acquired, reordered, processed and displayed sequentially. The delay between data acquisition and display is on the order of 0.03-0.06 secs for a 1024\u00d71024 image. A 1024\u00d71024 image is supported at 30 frames\/sec. In this mode every nth frame is stored and displayed, where n=1 to 10, while having an ability to store the last 60 frames of 1024\u00d71024 data under operator control.",{"@attributes":{"id":"p-0138","num":"0137"},"figref":"FIG. 21","b":["400","400","402","418","404","404","406","337","339","406","412","414","416","400","339","337","339","304"]},"Programming interface library  is a programming interface to assist the writing of a tester application with respect to image acquisition. The programming interface has a well defined subset of functionality whereas the hardware interface accesses the full functionality of the tester. The programming interface library  contains high level functions, which interface between the hardware drivers and the user application, i.e. tester application . This layer contains functions to poll the hardware devices and report back status information. This layer also enables the user to configure the acquisition hardware in a particular acquisition mode and to initiate the acquisition sequence.","The details of the image acquisition are specified by a structure defining the frame sequence. This structure is passed by a user program to an acquisition subroutine provided in the programming interface. The returned object is a pointer to a data and header, which is then available to the user program. Alternatively, the data is directly archived to disk. Convenient interfaces to various possible corrections and options for display are available at this level. Header translation from device specific to descriptive values occur in this layer.","Examples of library functions available for a user programs include:",{"@attributes":{"id":"p-0141","num":"0000"},"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":["1-Get hardware status","2-Configure acquisition system","3-Acquire and display data sequence (raw)","4-Acquire and display data sequence (corrected)","5-Store data sequence to disk"]}}}},"Batch process interface  is a subset of a programming interface from programming interface library , which provides a text based mechanism for image acquisition. Configuration files  and sequence files  are text files, which define all information to carry out acquisition of a sequence of frames. The separation of this information into two files ensures that there is no misunderstanding on which frame-to-frame parameter variation will be supported. In the simplest mode of operation, the user is authorized to alter these files in a common text editor and then initiate the acquisition with a command. The returned header will reflect the acquisition parameters as defined in the configuration and sequence files.","Information which is constant across a sequence is contained in configuration files . Examples include firmware revision numbers, serial numbers, panel type and process stage, tester location. In addition, the information contained in the configuration files  includes reordering, correction, archive, and display options. Calibration files  contain all information to correct data for gain, offset, bad pixel and channel gain of ARCs  on a pixel by pixel basis. In contrast, sequence files  contain the specific acquisition parameters of each frame in the sequence. These specific acquisition parameters include all the detector parameters and event timing.",{"@attributes":{"id":"p-0144","num":"0147"},"figref":"FIG. 22","b":["410","302","410","408","374","304","410","408","409","411","304","338","410","408","370","304"]},"As illustrated in , hardware system  provides hardware and software with window level control for driving a commercial display driver card to view data acquisition results. The display displays both raw and processed archived images. The displayed data is 8 bits including gamma correction for display phosphor non-linearity. At a lowest magnification there is a one to one correlation between the display least significant bit (\u201cLSB\u201d) and the least significant bit received from image detection system . A second monitor  is used to provide a user interface. Image display supports Xia functionality, such as pan, zoom and pixel amplitude display. Row and column numbers of a selected pixel are optionally displayed along with calculation of statistics for a region of interest.","Disk archive  is used for short term storage and is embodied as either a removable disc drive or writable 650 MByte CD ROM. Capability for archiving both raw and processed images along with a header of descriptive information is supported.","Host computer  includes network support and is configured with an 10\/100 Mbit\/sec Ethernet card and software for data transfers via the Ethernet. Other devices are supported, such as LEDs used in panel test or collimators. Such support includes an additional PCI card and driver in the C program to collect or send data to the additional PCI card.","An 8 bit real time parallel I\/ bus  is used to control or receive control from radiation generation system . Timing is provided by DFN control unit . Delays between the x-ray generation and data acquisition on Detector Control Board  are provided under software control. Synchronization of data acquisition with x-ray generation is therefore provided. X-ray generator voltage and current may be set under software control as well as operations to turn the x-ray generation unit  on and off via the tester hardware and software. Pulsed control of x-ray generation unit  with a control grid is provided. Control of current and voltage from pulse to pulse is provided with a 200 msec time resolution. Alternatively a separate interface to x-ray generator  is provided.","The 8 bit real time parallel I\/O bus  is also used to control x-ray generator  of radiation generation system . Timing is provided by DFN control unit  on DFN . Delays between the x-ray generation and data acquisition on Detector Control Board  are provided under software control. The x-ray generator  is triggered as an on\/off signal. Alternatively, generator voltage, current and exposure time are set and measured. Likewise, the 8 bit real time parallel I\/ bus  is used to control an x-ray generator for radiography digital x-ray.",{"@attributes":{"id":"p-0150","num":"0153"},"figref":"FIG. 23","b":["124","304","124","23"]},"Referring to FIG.  and , detector framing node  allows host computer  to interface to radiation generation system  and image detection system . Accordingly, detector framing node  supports a fiber channel interface for communication to detector control board , the RS-485 real time bus interface  for communication to radiation generation system , and the computer communication interface  for communication to host computer . A block diagram of DFN  architecture is shown in FIG.  and illustrates the interfaces just described. In addition to the hardware for interface communication, two FPGAs control the flow of data through the card. The EP  contains a sequencer, which orchestrates detector and x-ray event instructions in real time. EP  also contains a command interpreter which communicates with host computer . The DAP  controls the routing of image data during frame readout and acts as a bridge chip between image detection bus , and local bus  and DFN memory unit .","Detector Framing Node  supports an architecture based upon programmable logic, in the form of DFN control unit . The DFN control unit  is formed from a pair of FPGAs, which are preferable over embedded processors. First, firmware for the FPGAs is written in VHDL hardware description language, which remains largely platform independent, for integration into a single ASIC. Secondly, VHDL simulation of detector framing node  reduces hardware development time. Third, the use of programmable logic devices helps to simplify design of DFN  and allows for custom routing of signals between the various client buses on DFN , namely image detection bus , computer communication bus  and real time bus . Use of configurable logic simplifies design, simulation, and programming.","Detector framing node  uses a 32 bit, 33 MHz computer communication interface  to support a transfer rate of 60 MBytes\/sec. According to an alternate embodiment, computer communication interface  is a 64 bit PCI interface. DFN memory unit  includes five frame buffer memory units  embodied as 2 MByte frame buffers. Each frame buffer memory unit  facilitates sustained (transfer may occur in bursts) data transfer from image detection bus  to computer communication bus  without loss or data interruption. The use of five buffers provides a margin for capture of a single mammography digital x-ray image without loss or data interruption. Real time bus  is an 8 channel full duplex real-time bus interface (RS-485).","Detector framing node  controls radiation generation system  through serial connection. In other words, detector framing node  is in series with external control of the x-ray generation. Detector framing node  supports the following: image detection interface  operating at 1.25 GBaud rate; 32 bit, 33 MHz computer communication interface ; 8 bit RS-485 real-time bus interface ; real-time sequencing, of detector and x-ray event instructions; built in self test (\u201cBIST\u201d); field reconfiguration; power-down capability; sustained data throughput of 60 MBytes\/sec; software reset; and monitoring of key signals. BIST is provided on all five frame buffer memory units , i.e. 10 SRAMs; electrical loopback test on image detection bus ; and electrical loopback test on real time bus .","Major components of detector framing node  are embodied according to Table 1 set forth below:",{"@attributes":{"id":"p-0156","num":"0159"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Name","Part Number","Manufacturer"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Computer 382","PCI 9054","PLX Tech."]},{"entry":["EP 374","EPF10K200EFC600-1","Altera"]},{"entry":["DAP 372","EPF10K200EFC600-1","Altera"]},{"entry":["EEPROM 530, 532","EPC-2","Altera"]},{"entry":["10 SRAM chips","K7M803625M-QC90000","Samsung"]},{"entry":["F.O. transceiver 560","MDX-19-4-1","Methode"]},{"entry":["F.O. transmit unit 562","TQ9501","Tri-Quint"]},{"entry":["F.O. receive unit 564","TQ9502","Tri-Quint"]},{"entry":["Encoder\/decoder unit 566","TQ9303","Tri-Quint"]},{"entry":["PCI eeprom 606","NM93CS66LEN","Fairchild"]},{"entry":["Real time bus interface 378","SN75ALS171DW","Texas Instru-"]},{"entry":["clock buffer 576","49CT3805PYI","ments IDT"]},{"entry":["power on reset unit 534, 536","MAX6306UK29D3-T","Maxim"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"For testing and monitoring, detector framing node  supports self temperature monitoring, unique board ID, layout revision number, JTAG port  for reconfiguration of DFN control unit , JTAG port  for reprogramming of FPGA eeproms, visual diagnostic indicators, connector for access to local bus, connector for access to image detection bus , and a connector for access to DAP\/EP test bus .","EP  is an FPGA 200 K gate Altera Flex family, \u22121 speed grade, supporting a 32 bit local data bus with bus master capability. EP  also supports a 20 bit local address bus, a 32 bit test bus, a 32 bit direct link to DAP , a 32 bit fiber channel receive bus, a 32 bit fiber channel transmit bus, a twelve bit fiber channel control bus, a fiber channel reference clock input \u221231.25 MHz, a local bus clock input \u221236\/33 MHz, a 2.5 V core for low power operation, and a 3.3 V TTL compatible interface. EP  drives eight visual diagnostic indicators, and also interfaces to on-board temperature sensors. Likewise, EP  reads an available 5 bit layout revision code and interfaces to a board ID chip.","DAP  is a 200 K gate Altera Flex family, \u22121 speed grade, supporting a 32 bit local bus, a 20 bit address bus with bus master capability, a 32 bit fiber channel receive bus, fiber channel reference clock input \u22123.25 MHz, local bus clock input \u221236\/33 MHz, local bus arbitration logic, SRAM address bus, SRAM data bus, SRAM control lines, SRAM clocks, JTAG bus controller, 32 bit test bus, 2.5 V core for low power, and 3.3 V I\/O for TTL compatibility.",{"@attributes":{"id":"p-0160","num":"0163"},"figref":"FIG. 18","b":["304","304","114","109","112","304","376","378","370","304","374","374","114","302","372","377","384","380"]},{"@attributes":{"id":"p-0161","num":"0164"},"figref":["FIG. 24","FIG. 24"],"b":["440","304","440","370","440","304","304","442","442","444","444","440"]},{"@attributes":{"id":"p-0162","num":"0165"},"figref":["FIG. 25","FIG. 25"],"b":["374","374","304","374","304"]},"EP control unit  is responsible for overseeing operation of EP  and in coordinating interactions between local bus , fiber channel interface  and event sequencer unit . EP control unit  maintains a plurality of control registers , which parameterize the various operations taking place in EP . EP control unit  also maintains a plurality of error registers , which are used to report any problems in execution to host computer . EP control unit  coordinates interaction between error registers  and control registers  by way of master control unit .","PCI\/local bus interface unit  is responsible for hosting communication between EP  and local bus . Through the local bus connection to computer communication interface , PCI\/local bus interface unit  functions as a main respondent to commands sent over computer communication bus  to DFN . PCI\/local bus interface unit  includes a PCI command interpreter , which processes commands from host computer . Example commands include loading the event queue into EAB memory  in event sequencer unit  with data for an upcoming sequence or processing a begin sequence command.","Event sequencer unit  houses an event queue in EAB memory  and is responsible for decoding and executing event instructions during sequence operation. The event queue is embodied using available on chip EAB memory  on EP . The event queue in EAB memory  is organized byte-wise for most efficient use of memory resources. Sequencing of events and read\/write of the event queue in EAB memory  is controlled by queue control unit . Interpretation of event instructions is performed by event interpreter . As event instructions are read out of the event queue during sequence execution, data to be sent out to the various interfaces is transferred by the event interpreter  to other units on EP  for further processing.","Fiber channel interface  is responsible for maintaining communications with image detection interface . Data is transmitted by the FC EP transmit unit  and received by the EP FC receive unit . The status of the link is monitored by the EP FC control unit , which notifies host computer  if communication is lost or when anomalous conditions occur. Unlike most of EP , which runs off of the 36.0 MHz local bus clock, the EP FC transmit unit  runs off of the 31.25 MHz fiber channel transmit clock . Similarly, the EP FC receive unit  runs off of the fiber channel receive clock . This asynchronous operation is used in order to effect a rate change between image detection bus  and local bus . The units within fiber channel interface  communicate asynchronously with the remainder of EP  using flags for handshaking and double buffered registers.","EP real time bus interface  handles requests for changing the state of real time bus  from the event queue in EAB memory . EP real time bus interface  is also responsible for notifying the event queue and host computer  when external devices (e.g. radiation generation system ) force the state of real time bus .","There are two global clock inputs to EP , namely GCLK input  and GCLK input . These inputs are optimally distributed to all logic on the devices using two dedicated clock trees. On EP , GCLK and GCLK are driven by the 36.0 MHz local clock  and the 31.25 MHz fiber channel transmit clock  respectively.","There are also four additional dedicated global signal lines, which are not optimized for timing. On EP  these are connected to three reset signal triggers . Two reset triggers are generated by computer communication interface  (USERo and LCL_rst), and the third signal comes from a power on reset circuit, set forth in greater detail below.",{"@attributes":{"id":"p-0170","num":"0173"},"figref":"FIG. 26","b":["372","370","372","377","302","372","377","381","381","302","382"]},"As illustrated in , DAP  is comprised of a number of sub units, which are responsible for orchestrating the flow of image data on DFN . Starting with the DAP FC receive unit , 32 bit image data is received at the 31.25 MHz fiber channel receive clock rate. Each 32 bit word comprises two 16 bit pixel values, each read out in parallel by detector control board . The combined 32 bit word is written into DAP first in first out (\u201cFIFO\u201d) unit  using the fiber channel receive clock. At the same time, data is being read asynchronously out of DAP FIFO unit  and into the pixel reorder unit . The reorder function performed by pixel reorder unit  is set forth in greater detail below. This data is now processed at the 36.0 MHz local bus clock rate. From the pixel reorder unit, pixels move to crossbar , which routes the pixels to the currently active frame buffer memory unit .","At the same time that receive data is being stored in the currently active receive frame buffer memory unit , previously stored image data is being read out of the currently active stored frame buffer memory unit  to computer communication bus . Data is again routed through cross bar , but this time is passed on to computer communication interface , then to computer communication bus . The five available frame buffer memory units  in DFN  each provide an incremental timing safe guard against the possibility of dropping communication on computer communication bus . If communication is interrupted, the receive circuitry continues to store the incoming data from image detection system , which might otherwise be lost. Once computer communication bus  is picked up again, transfer of data continues at the local bus clock rate of 36.0 MHz. This provides uninterrupted data transfer and rate translation between image detection bus  and computer communication bus .","As part of the data flow architecture, DAP  also contains a local bus arbitrator , which is responsible for coordinating access to local bus  between EP , computer communication interface  and DAP . The connection between crossbar  and computer communication interface  is in fact bi-directional. This bi-directionality, combined with control of address generator  directly by computer communication bus  allows host computer  to read\/write the frame buffer memory units  directly.","As illustrated in , DAP  is responsible for controlling the address bus and read\/write signals for the frame buffer memory units . Image frame controller  is configured with the details of the type of detector panel being accessed (line length, lines\/image) and keeps track of the incoming pixel data to ensure that proper framing is maintained. In the event of inconsistent line length or frame size, an error is generated and reported to host computer . Line reorder unit  feeds into address generator  to generate proper addresses for the currently active receive and store frame buffer memory units . At the same time, precise timing of the various memory unit control signals is maintained by the read\/write cycle control unit . Detailed information regarding frame buffer memory units  is set forth below.","There are two global clock inputs to DAP , GCLK and GCKL. These inputs are optimally distributed to all logic on the devices using two dedicated clock trees. On DAP , GCLK and GCLK are driven by 36.0 MHz local bus clock and the 31.25 MHz fiber channel receive clock, respectively. There are also four additional dedicated global signal lines. On DAP  the dedicated global signal lines are connected to three reset triggers . Two of the reset triggers are generated by computer communication interface  (USERo and LCL_rst) and the third signal is generated from a power on reset circuit, set forth in greater detail below.","DAP control unit  is responsible for overseeing operation of DAP . DAP control unit  maintains control registers  which parameterize the various operations taking place in the DAP . DAP control unit  also maintains error registers , which are used to report any problems in execution to host computer . RAM BIST  performs a built in self test of the frame buffer memory units  on initial power up and during normal operation on command from host computer . Detailed information is set forth below.",{"@attributes":{"id":"p-0177","num":"0180"},"figref":["FIG. 27","FIG. 27"],"b":["370","535","372","374","329","329","532","530","372","374","1","542","2","544","304","114","372","374","304","372","374","372","374"]},"The programmable control unit  stores initial boot sequence instructions for controlling the detector framing node control unit . The programmable control unit  loads the initial boot sequence instructions for execution by control unit  upon reset or initial application of power to detector framing node . According to an embodiment of the present invention, the initial boot sequence instructions are updated by communicating update instructions from host computer  through the computer communication interface  and into detector framing node memory unit . The update instructions are then communicated from detector framing node memory unit  to the programmable memory unit . The JTAG loop  communicates the update instructions from local bus  and programmable memory unit .","As illustrated in , DAP power on reset (\u201cPOR\u201d) unit  and EP POR unit  are used to hold a reconfig line low for an additional 140 msec after power comes up on DFN  and configuration is complete. This ensures that DAP  and EP  configure in case the power supply rise time of 100 msec is violated. Alternatively, a push button switch is used to force a manual override of each POR circuit and reconfigure the FPGAs without cycling power to the board. All signal lines involved with FPGA configuration are made available on the top layer of the board to facilitate debug of FPGA configuration if a problem is detected during initial test of the board. In addition, jumpers are provided to selectively disable reboot of DAP  or EP  in order to help debug problems during configuration or due to specific devices.","During test and debug of DFN , configuration of the FPGAs and programming of eeprom units  and  are accomplished through the illustrated JTAG ports  and . JTAG is provided for the loop including EP  and DAP . No-populate 0-Ohm resistors are used to allow for either of EP  or DAP  to be taken out of the loop in case a problem arises during debug or firmware development.","JTAG is provided for the loop including the two eeprom units  and , and is used for programming the eeprom units  and . The eeprom units  and  are programmable over their respective JTAG ports using a Byte Blaster cable and MaxPlusII software, by Altera, Inc. of San Jose, Calif. As illustrated in , JTAG is also provided for second JTAG loop , including DAP eeprom unit  and EP eeprom unit , used to program the EP  and DAP .","When DFN  is in the field, the firmware is optionally updated to a different version. For convenience, these updates are performed directly without opening host computer  and swapping eeprom devices for a later revision. The capability for in-system programming of the eeprom units is supported through respective JTAG ports as mentioned above. DFN  allows host computer  to access the JTAG or JTAG directly over computer communication bus  without using the Byte Blaster cable and MaxPlusII software.","As illustrated in , second JTAG loop , which allows eeprom units  and  to be programmed from JTAG port  is also connected to DAP  through user I\/O pins. Once the board FPGAs configure properly with the old version of the firmware, the eeprom units are reprogrammable using a firmware application resident in DAP . Data for the eeprom units is transferred to the frame buffer memory units  over computer communication bus . From the frame buffer memory units , the data is read out by DAP firmware, serialized, and transferred over the respective JTAG bus along with format and command information.","After DAP  has reprogrammed the eeprom units over the corresponding JTAG bus, DAP  issues a JTAG command to cause the eeprom units to automatically reconfigure both of DAP  and EP . There is one try allowed for reprogramming of the EPC2 chips forming EP eeprom unit  and DAP eeprom unit . Error checking is used to ensure that the devices have been programmed correctly, however this will not prevent a user from programming the wrong firmware into the EPC2s. This situation is mitigated using software interlocks and through general precaution. The eeprom units may always be physically replaced on DFN .","DFN  uses ten 9.4 Megabit SRAMs, grouped into five frame buffer memory units . Address and data buses for the SRAMs are connected to DAP , which is responsible for control of these devices and for effecting a pixel data reordering algorithm, set forth in greater detail below. Data reordering for each flat panel detector is achieved by writing data from each row of the detector panel into the SRAM in an order such that when the SRAM is read out sequentially, the data is reordered for correct display on a memory mapped high resolution display . The data is transferred from the SRAMs into computer RAM  of host computer  using computer communication bus  for direct memory access (\u201cDMA\u201d).","Each SRAM is in a 100 pin thin quad flat pack (\u201cTQFP\u201d) packaging. The part is organized as 256K\u00d736 and has a 12 nsec cycle time. Address, data inputs, and all control signals, except output enable and linear burst enable, are true on the rising edge of the clock. Operation of the SRAMs are at 36 MHz, which allows head room. Since the data is typically two 16 bit words, the low order 4 bits of each SRAM are unused and the effective memory capacity is 8.4 Mbits. The TQFP package allows debug since all pins are available for probing. However, the use of a BGA package improves manufacturing yield. Five SRAMs are placed on each physical side of the board on which DFN  is formed to minimize address and data line length. Pairs of SRAMs forming each frame buffer memory unit  are placed on alternate sides of the physical board.","Writing data to frame buffer memory unit , formed as a pair of SRAMs, and reading data from a second frame buffer memory unit , also a pair of SRAMs, occurs in parallel. This is achieved by providing five 32 bit data buses and five 18 bit address buses in DAP , which address and read or write data to the five pairs of 8.4 Mbit SRAMs. Thus, 250 pins of the 600 pin DAP  are used for address and data for the SRAMs.","In addition to the 18 bit address bus and the 32 bit data bus, the SRAM control pins used are write enable (WE#), three chip selects (CS#, CS, CS#) and sleep mode (ZZ). CS # is used to select SRAMs for read or write. CS and CS# are used to implement the data reordering scheme set forth below for the cardiac\/surgical digital x-ray flat panel and the radiography digital x-ray flat panel. Sleep mode may be used for power down. Note that the # indicates the pin is active low.",{"@attributes":{"id":"p-0189","num":"0192"},"figref":"FIG. 28","b":["182","185","184","187","186","185","187","184","186","372","381"]},"In the case of cardiac\/surgical digital x-ray, the data being read out of the cardiac\/surgical digital x-ray panel  is being stored in SRAMs A and A of DFN memory unit  in DFN . SRAMs A and A comprise a single frame buffer memory unit .  represents the correspondence of SRAMs to the data actually being read out, namely into 2 SRAMs. DFN memory unit  has 10 SRAMs.",{"@attributes":{"id":"p-0191","num":"0194"},"figref":["FIG. 29","FIG. 29"],"b":["228","231","230","233","232","231","233","230","232","228","1","1","1","1","2","2","2","2","380","304","1","2","1","2","1","2","1","2","381","380"]},{"@attributes":{"id":"p-0192","num":"0195"},"figref":["FIG. 30","FIG. 30"],"b":["244","245","244","245","244","244","380","304","1","2","1","2","1","2","1","2","381","380"]},{"@attributes":{"id":"p-0193","num":"0196"},"figref":"FIG. 31","b":["1","2","1","2","1","2","1","2","1","2","380","380","182","28","1","2","1","2","1","2","1","2","1","2","182","380","182","1","2"]},"When cardiac\/surgical digital x-ray panel  is used in a fluoroscopy application, to acquire real time moving images of 30 frames\/second, each SRAM pair stores a single frame of the real time moving image. With reference to , each SRAM pair is denoted as a frame buffer memory unit . DFN  allows one frame buffer memory unit  to acquire data simultaneously while a second frame buffer memory unit  reads out data. Each SRAM illustrated in , , and  has a pin labeled chip select #, i.e. CS#, which is used to select a pair of the SRAM chips at any one time.",{"@attributes":{"id":"p-0195","num":"0198"},"figref":["FIG. 32","FIG. 32"],"b":["1","2","1","2","1","2","1","2","1","2","380","380","228","29","1","2","1","2","1","2","1","2","1","2","228","380","228","1","2","1","2","1","2","1","2","380","1","2"]},{"@attributes":{"id":"p-0196","num":"0199"},"figref":["FIG. 33","FIG. 33"],"b":["1","2","1","2","1","2","1","2","1","2","380","380","244","30","244","228","380","244","380"]},{"@attributes":{"id":"p-0197","num":"0200"},"figref":"FIG. 34","b":["334","336","114"]},{"@attributes":{"id":"p-0198","num":"0201"},"figref":"FIG. 35","b":["334","336","114"]},{"@attributes":{"id":"p-0199","num":"0202"},"figref":"FIG. 36","b":["334","336","114"]},{"@attributes":{"id":"p-0200","num":"0203"},"figref":"FIGS. 31-33","b":["380","1","2","18","304","2","2","18","1","2"]},"Data readout from the flat panel detector continues in the above fashion, such that pixel pairs from the top of the flat panel detector are alternately transmitted with respect to pixel pairs from the bottom flat panel across image detection bus. When the SRAM A and SRAM A are full, data is then stored in SRAM B and SRAM B, and so on. By way of example, for image acquisition from cardiac\/surgical digital x-ray panel , when SRAM A and SRAM A are full, the top of the image is stored in SRAM A and the bottom of the image is stored in SRAM A. Data is then stored in the next pair of SRAMs, namely SRAM B and SRAM B. Data is sequentially read out from the SRAMs to accomplish the reordering in traditional left-to-right fashion, such that data is first read out sequentially from SRAM A, and then sequentially read out from SRAM A. Upon readout, the data has been reformatted for display on a monitor.","A pair of SRAMs hold 2 MBytes of data, which corresponds to a single cardiac\/surgical digital x-ray image. For radiography digital x-ray, the image is stored in 4 pairs of memory chips, i.e. 8 MBytes of data. Each pair of SRAM memory chips is viewed as storing a 2 MByte stripe of data from the panel. As a pair of SRAM memory chips fill with data, they are available to be readout over PCI bus . A portion of an entire image frame output from a flat panel detector may be stored on DFN  while another portion is being transferred to host computer . Thus, 4048\u00d74048 or larger panels are supported.","In a configuration for mammography digital x-ray having a single flat panel, no reordering is provided. Data is read out from the single flat panel in sequential pixel order, two bits at a time, and likewise written sequentially to SRAMs A, A, B, . . . , etc. The firmware in DAP  handles mammography digital x-ray without reordering.","As set forth above, digital x-ray image data does not go directly from each flat panel detector into SRAM memory, but rather goes through ARC chips  and through DRC chip  (see FIG. ), is converted to a serial format on detector control board , and is transmitted over image detection bus  serially to DFN , for conversion back to a 32 bit parallel word. The fiber channel clock is set at 31.25 MHz and the 32 bit words are stored in a DAP  register at this rate. One 32 bit word contains two 16 bit pixels, one from the top panel of a split panel detector and one from the bottom panel, for cardiac\/surgical and radiography digital x-ray. Data is written to or read from memory using the 36 MHz clock of computer communication bus . The data transfer over computer communication bus  occurs at the 33 MHz clock rate of computer communication bus . The buffering used to convert the clock rate from image detection bus  to local bus  to computer communication bus  occurs within FIFOs on computer communication interface  or optionally in DAP .",{"@attributes":{"id":"p-0205","num":"0208"},"figref":"FIG. 37","b":["382","382","382","302","384","382","382"]},"DMA is used to transfer images from 2 MByte memory buffers on DFN  directly to computer RAM . Using the DMA engines on computer communication interface  relieves the burden of managing the data transfer from both the computer application and from the processors on DFN . DMA setup has four 32-bit words of data to be written to computer communication interface . The 32-bit words of data include a local base address, a PCI base address, a size of transfer, and a command to initiate the transfer. These four 32 bit words are written by EP  when a memory buffer needs to be transferred to computer RAM .","Direct slave mode of operation is used for all direct computer accesses to DFN . Computer communication interface  is programmed to recognize the address on computer communication bus  where DFN  resides. When a memory access within defined memory space of DFN  is accessed, computer communication interface  responds on computer communication bus  and performs a memory access on the local bus side of DFN . This mode of operation is used to read and write registers on DAP  and EP , to access memory within the memory buffers on DFN , and to send commands to DFN .","Direct master mode of operation is used for sending detector information to host computer . When DFN  receives an acknowledgement from an issued command, DFN  sends this information to a pre-designated buffer in computer RAM . Host computer  sets up the buffer space and authorizes DFN  to transfer data into computer ram  before this mode of communication is used.","Computer communication interface  has a number of mailbox registers, and two doorbell registers used for messaging between DFN  and the computer application. There is a 32-bit outgoing and a 32-bit incoming doorbell register. The mailbox registers are used to buffer the results of commands to DFN . The outgoing doorbell register is used to send interrupts to the host computer . Interrupts originate from a number of sources, including command completion signals and errors.","Computer communication interface  PCI bus side signals are generally set forth in Table 2 below:",{"@attributes":{"id":"p-0211","num":"0214"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Name","Pin Function"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["AD(31:0)","PCI side multiplexed Address\/Data Bus"]},{"entry":["C_BE(3:0)","PCI side byte enables"]},{"entry":["DEVSEL","Device Select"]},{"entry":["ENUM","Enumeration; Hot-swap related"]},{"entry":["FRAME","Cycle Frame; Defines a frame of data"]},{"entry":["GNT","Grant; PCI bus granted to card"]},{"entry":["RST","Reset; PCI reset will reset the computer communication"]},{"entry":[{},"interface 382"]},{"entry":["IDSEL","Initialization Device Select"]},{"entry":["INTA","Interrupt A; PCI interrupt request by DFN to computer"]},{"entry":["IRDY","Initiator Ready"]},{"entry":["LOCK","Lock; Lock computer communication bus 302"]},{"entry":["PAR","Parity; Even parity on AD and CBE"]},{"entry":["PERR","Parity Error; Report data parity errors"]},{"entry":["PME","Power Management Event"]},{"entry":["REQ","Request; Request for computer communication bus 302"]},{"entry":["SERR","System Error; Report Address parity errors"]},{"entry":["STOP","Stop; Request to stop current transaction"]},{"entry":["TRDY","Target Ready"]},{"entry":["PCLK","PCI Clock; 33 MHz"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Table 3 sets forth computer communication interface  local bus side signals.",{"@attributes":{"id":"p-0213","num":"0216"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Name","Pin Function"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["LBA(31:0)","Local Address Bus"]},{"entry":["LBD(31:0)","Local Data Bus"]},{"entry":["ADS","Address Strobe; Indicates start of address cycle"]},{"entry":["BIGEND","Big Endian Select; Unused"]},{"entry":["BLAST","Burst Last; Indicate last transfer in bus access"]},{"entry":["BREQI","Bus Request In; EP uses the bus"]},{"entry":["BREQO","Bus Request Out; computer communication interface 382"]},{"entry":[{},"uses the bus"]},{"entry":["BTERM","Burst Terminate"]},{"entry":["EOT","End Of Transfer; Terminate current DMA"]},{"entry":["DP(3:0)","Data Parity; Unused"]},{"entry":["LBE(3:0)","Byte Enables"]},{"entry":["LHOLD","Local Bus Request; Request the bus from local arbitrator"]},{"entry":["LHOLDA","Local Bus Grant; Local arbitrator grants the bus"]},{"entry":["LSERR","System Error PCI System error interrupt"]},{"entry":["LW_R","Local Write\/Read; Low for reads"]},{"entry":["READY","Ready; Bus Master prepared for transaction"]},{"entry":["L_WATT","Wait; Inserts wait states"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Table 4 sets forth computer communication interface  general signals.",{"@attributes":{"id":"p-0215","num":"0218"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Name","Pin Function"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["CCS","Config Register Select"]},{"entry":["LCLK","Local Bus Clock; 36.0 MHz (max = 50 MHz)"]},{"entry":["LED","Hot-Swap LED, monitor; Unused"]},{"entry":["LINT","Local Bus Interrupt; Used by EP to interrupt PCI Bus"]},{"entry":["LRESET","Local Bus Reset; Reset FPGAs on PCI reset"]},{"entry":["MODE(1:0)","Bus mode; Set to \u201c00\u201d = C Mode"]},{"entry":["USERI","FPGA controllable input signal; Unused"]},{"entry":["USERO","Computer controllable output signal; software reset and"]},{"entry":[{},"pwrdwn mode"]},{"entry":["TEST","Initiate NANDTREE boundary test; Pulled high for test"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0216","num":"0219"},"figref":"FIG. 38","b":["376","304","376","112","374"]},"Transmission over image detection bus  is divided into a hierarchy of layer abstractions, each handling key aspects of a complete Gbit communications system. However, the physical and transmission protocol layers (FC-0 and FC-1 respectively) are relevant because these layers are the layers that have been implemented by image detection system . Electronics in image detection system  implement the FC-0 and FC-1 standards using a set of three custom ICs and a fiber optic transceiver module.",{"@attributes":{"id":"p-0218","num":"0221"},"figref":"FIG. 38","b":["376","304","376","566","562","564","560","568","560","112"]},"As illustrated in , the physical layer is comprised of the fiber optic transmit unit  chip, fiber optic receive unit  and fiber optic transceiver . The fiber optic transmit unit  accepts a ten bit input at 125 MHz and serializes the input up to a 1.25 GHz transmit rate. The transmitter  drives the F\/O module over a differential positive emitter-coupled logic (\u201cPECL\u201d) interface. Similarly, receiver unit  is driven by the PECL outputs of the fiber optic transceiver  at the 1.25 GHz rate. The receiver deserializes the input data stream and produces ten bit data at a rate of 125 MHz. The 1.25 GHz transmit clock is generated by fiber optic transmit unit  by multiplying a 31.25 MHz reference clock by 40 times using an onboard phase lock loop (\u201cPLL\u201d). Similarly, the deserializer recovers the 1.25 GHz clock from the incoming serial data and divides the 1.25 GHz clock by 40 to generate the 31.25 MHz receive clock.","The fiber channel standard is quite strict concerning the need for precise timing of the reference clock to avoid problems related to jitter noise. A high quality crystal oscillator is therefore used on DFN  to ensure a stable a reference clock. Signal integrity for the 1.25 GHz transmit and receive channels is also a potential concern. Transmit and receive chips are placed as close as possible to the fiber optic transceiver module. In addition, these signals are routed on the top layer of the board as micro strip lines to minimize capacitive loading.","The FC-1 layer defines a communications protocol by which packets of data are transmitted and received in 32 bit words at a rate of 31.25 MHz. The FC-1 layer incorporates 8 bit\/10 bit encoding as well as cyclic redundancy check (\u201cCRC\u201d) processing to ensure data integrity. This layer is also responsible for establishing and maintaining coherent data communication with the device on the other end of image detection bus . Each of these functions is discussed further below.","As shown in , the transmission protocol layer in the fiber channel subsystem is comprised of encoder\/decoder unit . Encoder\/decoder unit  interfaces to EP  over two independent 32 bit data buses: one for transmit and one for receive. Both the transmit and receive data buses operate at the 31.25 MHz word rate. Encoder\/decoder unit  takes the input data, performs 8 bit\/10 bit encoding, then outputs ten bit words to the fiber optic transmit unit . Encoder\/decoder unit  also receives ten bit words from fiber optic receive unit  and performs reverse 8 bit\/10 bit encoding to output 32 bit receive data to EP . In addition to these functions, encoder\/decoder unit  monitors the state of image detection bus  and provides status information to EP .","The FC-0 layer transmits and receives data in ten bit words at a rate of 125 MHz. These ten bit words are in fact special characters which are mapped to the 8 bit data that is transmitted and received by EP . The reason for this 8-bit\/10-bit encoding is to mitigate the effects of PLL wander. Each of the ten bit characters contain a number of high to low transitions such that the PLL in the receive circuit continues to accurately recover the 1.25 GHz transmit clock from the incoming serial data. Encoder\/decoder unit  takes the incoming 32 bit word, parses the word to successive bytes, and then performs 8 bit\/10 bit mapping to generate the output for fiber optic transmit unit . Similarly, encoder\/decoder unit  takes the input from fiber optic receive unit , performs decoding, and assembles the resulting bytes into 32 bit words. In addition to the 256 characters that map the 8 bit transmit data, there are a number of utility characters that provide link, framing, and status information. These are discussed in further detail below. In order to further ensure the integrity of the transmitted data, encoder\/decoder unit  performs CRC processing on the incoming and outgoing 32 bit data.","According to protocol of image detection bus , data from EP  is transmitted in packets of 4 or more 32 bit words called data frames. Data frames are comprised of data words and special command words called ordered sets. There are typically three types of data frames encountered when communicating with image detection system .",{"@attributes":{"id":"p-0225","num":"0228"},"figref":"FIGS. 33","b":["34","35","374","372","374","566","374","0","374","112"]},{"@attributes":{"id":"p-0226","num":"0229"},"figref":"FIG. 39","b":["620","620","377","112","620"]},{"@attributes":{"id":"p-0227","num":"0230"},"figref":"FIG. 40","b":["622","622","620"]},{"@attributes":{"id":"p-0228","num":"0231"},"figref":"FIG. 41","b":["624","622","582"]},"When power is applied to image detection interface , the transmitter and receiver chips begin communicating with the system on the other end of image detection bus . Before useful data is transferred across the link, however, synchronization is first established between the two systems. The first step in link synchronization is to properly frame the serial data that is being received by fiber optic receive unit . After encoder\/decoder unit  comes out of reset, encoder\/decoder unit  asserts the SYNCEN line on the fiber optic receive unit , which forces search for a special K28.5 fiber channel \u201ccomma\u201d character, which is being transmitted by the system on the other end of the link. Once this character is located, the fiber optic receive unit  will word align the incoming serial data to the ten bit boundary and notify encoder\/decoder unit  using the SYNC line.","Encoder\/decoder unit  will then monitor the incoming 8 bit data words for known framing characters to determine whether proper communication with the other system has been established. Once the link is good, encoder\/decoder unit  will deassert SYNCEN. In the current system, SYNCEN is connected to a WRDSYNC line. The WRDSYNC line is also connected to EP  and notifies same that link synchronization has been established.","If during typical operation of image detection bus , link synchronization is somehow lost (e.g. image detection bus  becomes unplugged), encoder\/decoder unit  will detect that an anomalous situation exists. In this case, encoder\/decoder unit  will reassert the WRDSYNC lien (\u201cSYNCEN\u201d) simultaneously notifying computer  that there is a problem and will force the receiver to search for word alignment. Image detection interface  will then continue to search for good ten bit characters until synchronization is reestablished.","During the time that the system is attempting to achieve synchronization, EP  monitors progress on receive status lines. EP  also observes unframed data on the receive data bus to look for special data words (such as the IDLE ordered set), which provide status information on the state of image detection bus . If synchronization is not achieved, the control block resets encoder\/decoder unit  and attempts to lock once more. After two tries if synchronization is not established, an error is reported to computer .","Fiber optic transceiver  provides media transition for DFN  and also outputs a SIGDET signal, which goes low when the receive photo diode in fiber optic transceiver  fails to detect optical power for reliable operation. This signal is then output by fiber optic transceiver  to buffer . This situation typically means that the system on the other side of the link is turned off or the cable of image detection bus  has been unplugged. If SIGDET goes low an error is reported to computer  so that the operator optionally reconnects the fiber cable or investigates the problem further.","Image detection interface  includes a number of control transmit signals set forth in Table 5, setting forth transmit signal assignments below:",{"@attributes":{"id":"p-0235","num":"0238"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Name","Pin Function"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["CTXD0","Transmit data bus"]},{"entry":["CTXCLK","Transmit clock; 31.25 MHz"]},{"entry":["CTXC0","Ordered Set; Low = data; high = control word"]},{"entry":["CTXC1","CRC; Low = check CRC; high = generate CRC"]},{"entry":["CTXCERR","CRC Error; High = CRC error detected"]},{"entry":["CTXWREF","Reference word clock"]},{"entry":["RESETN","Reset Endec; Active low"]},{"entry":["LOOPEN","Loop Enable; Loop the Transmitter to the Receiver"]},{"entry":["REFCLK","Reference Clock; Used to lock local PLL"]},{"entry":["SIGDET","Signal Detect; When low indicates no laser input"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Table 6 below sets forth receive signal assignments.",{"@attributes":{"id":"p-0237","num":"0240"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 6"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Name","Pin Function"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["CRXD0","Receive data bus"]},{"entry":["CRXCLK","Receive clock; Recovered 31.25 MHz clock"]},{"entry":["CRXS0","Ordered Set; Low = data; high = control word"]},{"entry":["CRXS1","CRC error flag; High indicates CRC error detected"]},{"entry":["CRXS2,3","Line Status"]},{"entry":["CRXS4,5","Line State ID bits"]},{"entry":["RXERROR","Receive Error; High indicates bad receiver data"]},{"entry":["WRDSYNC","Word Synchronization; Low indicates sync acquired"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0238","num":"0241"},"figref":"FIG. 42","b":["378","304","109","378","379","378","569","378","570","572"]},"Real time bus interface  has three RS-485 channels on one device. Individual control of the transmit output enable line is provided while control of the receive output enable line are ganged together on one pin. The part therefore has a three channel input, output and control bus for a total of 9 basic signals, which is routed to EP . Each channel is capable of driving 60 mA and operates at up to a 10 MHz (30 nsec pulse). Real time bus interface  includes a total of 36 basic signal lines, which are routed from EP  to the transceiver chips to control all 12 channels. Real time bus  is made available external to the DFN  card using a 31 pin female micro miniature D type connector. Voltage suppressors are also included as part of the real time bus interface  to ensure that the transceivers will not be damaged if a connecting cable to radiation generation system  is unplugged with power being applied to DFN  or when undesired transients are generated by radiation generation system .",{"@attributes":{"id":"p-0240","num":"0243"},"figref":"FIG. 43","b":["582","582"]},"As illustrated in , fiber channel transmit clock provides image detection bus  with transmit communication at 31.25 MHz. Fiber channel transmit clock  is used as a reference clock for fiber channel receive and transmit circuit PLLs. A crystal oscillator on DFN  generates fiber channel transmit clock . This clock has a 50% duty cycle with no greater than 10% deviation. The jitter noise on this clock is less than 40 ppm.","Fiber channel transmit clock  is buffered using clock buffer  and is distributed to image detection bus  circuitry as well as to EP , DAP  and a FC test port (not shown). Fiber channel transmit clock  is used in EP  to drive the FC transmit logic directly. Clock  is routed to one of the two available global clock pins on EP . On DAP , fiber channel transmit clock  is routed to one of the dedicated global input signals.","Fiber channel receive clock  is recovered from the incoming fiber channel signal data by a phase lock loop located in fiber optic receive unit . This clock has been generated on the other side of image detection bus  and is a 31.25 MHz clock that is asynchronous to the 31.25 MHz transmit clock. Fiber channel receive clock  is buffered by one of the two clock buffer chips and is then distributed to DAP , EP  and a FC test port. On DAP , fiber channel receive clock  is routed to one of the available global clock inputs. This configuration allows the clock to be used for the on-chip FIFO which facilitates a rate change from image detection bus  to local bus  for storage of data in DFN memory unit .","The local clock  is generated using a crystal oscillator on DFN  and provides a main clock for all devices interacting through the local bus . This clock operates at 36.0 MHz. Computer communication interface  operates up to 50 MHz, and therefore sets an upper limit on local bus clock speed. The local bus clock speed is selected to be slightly higher than computer communication bus  clock speed to improve PCI bus utilization.","The local clock  is buffered by one of the two clock buffer chips and is routed to computer communication interface , DAP , EP  and a local bus test port . Local clock  is routed to one of the two dedicated clock inputs on DAP  and EP  for optimum timing performance. In addition to all of the local bus devices, this clock is buffered and routed to all of SRAM chips on DFN memory unit .","PCI clock  is generated by a PCI bus arbitrator on computer  and is made available to DFN  on the PCI card edge connector. This clock is used exclusively by computer communication interface  and is not buffered for distribution. Each of the above described 31.25 MHz and 36.0 MHz clocks is buffered through one of two clock buffer chips, namely clock buffers .",{"@attributes":{"id":"p-0247","num":"0250"},"figref":"FIG. 44","b":["576","576","382","574","374","574"]},"Reset of DAP  and EP  of DFN  into a known state occurs on power up, during debug, and during normal operation if anomalous behavior occurs. Although some devices are designed to boot to a known state on reconfiguration, there is no way to guarantee that this is the desired initial state for proper operation of DFN . Moreover, initial reset of DFN  over computer communication bus  potentially produces undesirable results because DFN  will most likely configure well ahead of the computer operating system, and also has control of both image detection system  and radiation generation system . Thus, on-board reset circuitry is provided to bring DFN  to a well defined state. DFN  is reset on power-up and through software or hardware as described in this section.",{"@attributes":{"id":"p-0249","num":"0252"},"figref":["FIG. 45","FIG. 45"],"b":["588","304","535","372","374"]},"The reset signal from POR unit  is routed to DAP  and EP , and is connected to one of the four dedicated input lines. These dedicated input lines are accessible to all logic on each FPGA device. The firmware is coded for asynchronous reset based on the state of this global input line.","In addition to reset on power-up, DFN  resets when a computer reset button is pushed. As shown in , this functionality is provided through computer communication interface  using the local bus reset output pin. This pin is held low whenever the PCI RST# line is asserted. When PCI RST# is asserted, computer communication interface  resets to a default configuration as specified by PCI eeprom . In addition, the reset signal propagates out to all devices on local bus  through the local bus reset pin. This signal is routed to EP  and DAP  and is connected to the second of four available dedicated inputs to these devices. As in power on reset, these global inputs are used for asynchronous reset in the firmware for the two devices. These signals are also logically ORed in firmware with the power on reset signal.","Software (USERo) reset is used for debug of DFN  and firmware. Software (USERo) is useful to be able to reset DAP  and EP  circuitry independent of computer communication interface . This capability is provided through the software reset function. Computer communication interface  is programmable to change the state of the USERo dedicated line by writing a bit to a register location. As illustrated in , this line is connected to the third available global input line on DAP  and EP , and is optionally used to reset these devices without resetting computer communication interface . The issuing of a \u201cPCI reset\u201d resets both computer communication interface  and the FPGAs and is undesirable when attempting to debug a complex problem involving both computer communication interface  and the FPGA devices. Additionally, the ability to reset DFN  through software directly is useful if anomalous operation occurs. For test and debug on the bench, any of a number of Test Bus signals are used to reset the FPGA devices together or separately. This functionality is coded into the firmware as asynchronous reset on a user I\/O pin input signal.","There are three different power supply domains on DFN : 5 V, 3.3 V, and 2.5 V. Power for the 5 V devices is taken directly off of the PCI connector. There is one 5 V power plane. The major devices operating off of this supply are the real time bus interface  and fiber channel interface . The supply is decoupled using two 10 V 47 \u03bcF Tantulum and one 0.1 \u03bcF surface mount capacitors at the connector. Power to the fiber optic transceiver module is decoupled using two pi network type filters in order to prevent extraneous coupling from the module back into the supply. Power for the 3.3 V devices on the card is taken directly off of the PCI connector. There is one 3.3 V power plane. The major devices operating off of this supply are computer communication interface , the SRAM Buffer memories, and the two FPGA devices. The supply is decoupled using two 10 V 47 \u03bcF Tantulum and one 0.1 \u03bcF surface mount capacitors at the connector. Power for the 2.5 V devices on DFN  is generated locally using a 2.5 V regulator. There is one 2.5 V power plane. The major devices operating off of this supply are the FPGAs (core logic). The supply is decoupled using two 10 V 47 \u03bcF Tantulum capacitors at the output of the regulator. The sense line on the regulator is connected to the 2.5 V power plane near the center of the FPGA devices in order to accurately monitor the supply voltage. For applications using multiple detector framing nodes in a single chassis or for applications having strict power budgets (e.g. a battery operated PC), DFN  supports a power down mode of operation.","In reset power down mode, the FPGA and image detection bus  devices are held in reset by computer communication interface  USERo signal until such time as computer  updates this signal using a PCI write to computer communication interface . With this method, clock lines to all devices are left toggling, however dynamic logic on these chips is not switching. Computer communication interface  does not contribute significantly to the overall power budget on the card. Thus, computer communication interface  is left fully operational during power down mode. In clock power down mode, the local bus and fiber channel clocks are disabled by asserting the output enable control lines on the clock buffer chips. There are currently unpopulated jumpers on the board that connect these control lines to the USERo signal from computer communication interface . Populating these jumpers selects the clock power down mode as the preferred method for power savings for the card.","In order to verify proper function of key systems on DFN , Built In Self Test (\u201cBIST\u201d) firmware routines are included. These routines are run automatically on power-up and report any errors detected to computer  once communication is established. The tests will also be available to be run through direct commands from computer communication bus .","The fiber channel loopback test is designed to test image detection interface . The test is initiated by EP  by asserting the LOOPEN signal line. This signal line shorts fiber optic transmit unit  outputs to fiber optic receive unit . This closes the loop through encoder\/decoder unit  back to EP . EP  then attempts to send an FC command over the link and monitors the return bus for an expected echo. The format of the command words includes alternating 1 and 0 patterns and is designed to test the transmit and receive bus lines for shorts and opens. If the correct pattern is received, the test passes. The results are reported to computer . This test is does not verify the fiber optic transceiver module but is optionally qualified with a setting that causes the test to run without asserting LOOPEN. In this case, a short length of fiber cable is looped from the module output back to its input to close the loop. This test is available for debugging of DFN .","The real time bus interface  is also tested for integrity of the transceiver chip set electronics. This test is performed by EP  by writing data out to the devices on the transmit bus and then monitoring the receive bus for the same data. Since the chips have their receivers and transmitters for each channel wired together, anything transmitted will automatically be received. The test includes a series of words of alternating 1 and 0 patterns which are designed to check for opens and shorts on the transmit and receive data bus traces and chip pins. If this test is successful, it will also show that the chips themselves are functioning correctly. This test is further augmented to test the traces out to a 31 pin miniature D connector as well as the connector solder joints. A special external test connector shorts all even channels to all odd channels. Data is transmitted on the even channels and monitored on the odd channels and visa versa. This test shows that the entire communication chain out to the connector is working. This test is generally not run automatically and is available for debug of real time bus interface .","A RAM Built In Self Test (\u201cBIST\u201d) is also provided for DFN . DFN memory unit  includes ten 8 Megabit SRAM devices, which together contribute the majority of connections to DAP . There is the possibility that these devices might have been damaged during board handling and therefore they need to be tested using an exhaustive RAM BIST test. RAM BIST includes three related tests, all of which are conducted by firmware in DAP . In the first test, odd and even memory locations are filled with alternating 1 and 0 patterns and then read out and checked. In the second test the odd and even values are reversed. In the third test, the value of the address of a particular location is written into that location. Once the entire DFN memory unit  has been filled, the data is read out and compared to the original. These three tests verify that every bit of SRAM on the card is good and will also check for shorts on traces and between pins on the SRAM chips and on the majority of pins on DAP .","DFN  has built in test and monitoring features. Dedicated test ports, jumpers, test points and temperature monitoring are used for observeability. Test ports facilitate test and debug of DFN , and a large number of test points are routed to miniature test ports for direct access. In particular the local bus , the internal bus connected to image detection bus , and the bus that connects DAP  and EP  have been brought to test ports. Daughter boards, with bus transceivers on them, provide high speed monitoring of signals on these lines without significantly loading them. These buses are used when testing EP  and DAP , which are FPGA devices and therefore not probed directly. The same is true for computer communication interface , which is a fineline surface mount part and difficult to probe. Test clips do exist for some of the devices on the board, but dedicated test ports simplify access.",{"@attributes":{"id":"p-0260","num":"0263"},"figref":"FIG. 46","b":["590","304","590","590"]},"As illustrated in , five SRAM chips  are placed on a single side of physical PCI card . As set forth above, a pair of SRAM chips  are used to form each frame buffer memory unit  (see FIG. ). Thus, for each frame buffer memory unit , one SRAM chip  is placed on a first side of physical PCI card , while another SRAM chip  is placed on a second side. In this manner, most address and data lines are shared thereby minimizing routing on the physical PCI card . Furthermore, DAP eeprom unit  is physically comprised of eeprom chips  and , while EP eeprom unit  is comprised of eeprom chips  and . As illustrated, JTAG port  and JTAG port  are physically located on an edge of physical PCI card . Real time bus interface  is comprised of four interface chips  to implement protocol with the real time bus  through real time bus connector . Computer communication interface  is programmed by PCI eeprom , which is a separate circuit element. As illustrated, each of fiber optic transmit unit  and fiber optic receive unit  are separate circuit elements on physical PCI card .","Fiber channel test port  is placed on physical PCI card  for signal monitoring. All fiber channel transmit and receive data bus signals, as well as the status signals and send and receive clocks, are routed to fiber channel test port . Local bus test port  receives all local data and address bus signals. In addition, all control signals for local bus  have been routed to local bus test port . DAP\/EP\/Test port  includes a total of 50 lines, including dedicated user I\/O pins on DAP  and an additional 50 lines on EP . The lines from DAP  and EP  have been tied together and routed to DAP\/EP\/Test port . These signals provide monitoring of signals internal to the FPGA devices. They also constitute an additional dedicated communications bus between DAP  and EP for integrating additional functionality.","For convenience in board test, a group of test points are also brought out to be readily accessible. These points are identified in this section. These are isolated points which are not related to the test bus ports, and not particularly illustrated.","Temperature monitoring is provided to prevent thermal runaway and for statistical tracking of card operation. Three temperature monitoring devices are incorporated on physical PCI card . These devices sit underneath the FPGAs, image detection bus  and the SRAM memory buffers. The devices are read over an I2C bus and their outputs are available to computer  by way of read out from temperature monitor registers on DFN . Additionally, these devices are monitored directly by the FPGAs themselves at regular intervals. If the temperature is observed to rise above a prescribed limit, DFN  is automatically placed in powerdown mode after a temperature overflow error is communicated to computer .","A board revision code is provided on DFN  for tracking purposes. The board revision code is embedded in the physical board artwork. The code includes 8 user I\/O pins routed to EP  which are either tied high or low directly to yield a revision number. This revision number is then be read directly by computer  by interrogating a board revision number register, which is mapped to revision code pins.","A unique board serial number is also provided for tracking. Every board produced will have a unique serial number. This serial number is generated using a Si Serial Number IC, by Dallas Semi.: DS2401Z. The serial number IC is interrogated on a single line, which is connected to EP . The resulting serial number is stored in a register EP , which is readable directly by computer .",{"@attributes":{"id":"p-0267","num":"0270"},"figref":"FIG. 47","b":["616","304","590","114","304","302","114","304","47","304","374","372","304","374","372","374","374","372","313"]},{"@attributes":{"id":"p-0268","num":"0271"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 7"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["EP_REV_ID","Current revision level of EP 374"]},{"entry":["EP_STATE","Current state of EP state machine (and DFN)"]},{"entry":["DFN_REV","Current revision level of DFN 304"]},{"entry":["EAB_SIZE","EAB memory block size in bytes"]},{"entry":["RT_BUS","Current state of RTB (state of each bit and"]},{"entry":[{},"direction of each bit)"]},{"entry":["STAT05R","RESERVED STATUS REGISTER"]},{"entry":["CUR_QUEUE","Currently executing detector queue command"]},{"entry":["LOOP INDEX","Current state of first nested loop index in"]},{"entry":[{},"event queue"]},{"entry":["SSN_NUM1","Silicon serial number of DFN board"]},{"entry":[{},"(most significant bytes)"]},{"entry":["SSN_NUM2","Silicon serial number of DFN board"]},{"entry":[{},"(least significant bytes)"]},{"entry":["ACK1 HDR1","returned from detector"]},{"entry":["ACK2 HDR2","returned from detector"]},{"entry":["ERRORQUEUE","Errors relating to queue execution"]},{"entry":[{},"(set by DFN cleared by computer)"]},{"entry":["HOST_FLAGS_REG","Queue register to send interrupts to computer"]},{"entry":[{},"(set by DFN learned by computer)"]},{"entry":["ERROR_FC_EP","Fiber channel error register"]},{"entry":[{},"(set by DFN cleared by computer)"]},{"entry":["EP_ENABLE_REG","Enable bit mask for circuits in EP"]},{"entry":[{},"(set by DFN cleared by computer)"]},{"entry":["Cmd_0Par","First DFN command parameter"]},{"entry":["Cmd_1Par","Second DFN command parameter"]},{"entry":["Cmd_2Par","Third DFN command parameter"]},{"entry":["Cmd_3Par","Fourth DFN command parameter"]},{"entry":["RT_BUS_CONFIG","Real time buss configuration"]},{"entry":["RT_BUS_SER_OUT","Data to be serialized and put out"]},{"entry":[{},"on real time bus serial bit"]},{"entry":["HOST_FLAGS_IN","Used to send flags between"]},{"entry":[{},"application and queue"]},{"entry":["AUTOSCRUB_DELAY","Autoscrub delay"]},{"entry":[{},"(2 \u03bcsec intervals)"]},{"entry":["PARAM_BASE","Base address of queue variables in"]},{"entry":[{},"EAB memory"]},{"entry":["DBELL_MASK","Specification of which doorbell types"]},{"entry":[{},"are allowed"]},{"entry":["LED_STATE","Register to control LEDs on DFN"]},{"entry":["CMD_TIMEOUT","Timeout for command executions"]},{"entry":[{},"(2 \u03bcsec intervals)"]},{"entry":["DET_TIMEOUT","Timeout for detector responses"]},{"entry":[{},"(2 \u03bcsec intervals)"]},{"entry":["WAITF_TIMEOUT","Timeout for wait on flag commands in queue"]},{"entry":[{},"(2 \u03bcsec intervals)"]},{"entry":["DMA_CMD","Used to specify some of the parameters"]},{"entry":[{},"for DMA"]},{"entry":["DMA_MODE","Used to specify some of the parameters"]},{"entry":[{},"for DMA"]},{"entry":["CMD_REG","Command register"]},{"entry":[{},"(register on EP for commands)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The DAP  includes the DAP control unit  for maintaining control over the DFN  and also has a plurality of error registers for reporting error conditions to host computer . Table 8 shows the DAP registers and their accompanying description.",{"@attributes":{"id":"p-0270","num":"0273"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 8"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["DAP_REV_ID","Current revision of the DAP processor"]},{"entry":[{},"FPGA code"]},{"entry":["DAP_STATE","Current state of the DAP finite state machine"]},{"entry":["RES_LOG_STAT_A","Status register for response log buffer A"]},{"entry":["RES_LOG_STAT_B","Status register for response log buffer A"]},{"entry":["LAST_WRTN_DFN","Ordinal position pointer of the last buffer"]},{"entry":[{},"written by DFN 304"]},{"entry":["DFN_IMG_STAT","Number of images and detector"]},{"entry":[{},"syncs trapped by firmware"]},{"entry":["IMAGE_NUMBER","32 bit image counter"]},{"entry":["TIMER_COUNT","2 \u03bcsec timer counter"]},{"entry":["NUM_WRAPS","Number of wraps of timer count"]},{"entry":["SEQUENCE_ID","Current sequence (set by computer)"]},{"entry":["DAP_STAT0AR","RESERVED STATUS REGISTER"]},{"entry":["DAP_STAT0BR","RESERVED STATUS REGISTER"]},{"entry":["DAP_ERR0R","Error register (set by DFN,"]},{"entry":[{},"cleared by computer)"]},{"entry":["BIST_ERR BIST","Error register (set by DFN, cleared"]},{"entry":[{},"by computer)"]},{"entry":["RES_LOG_FULL","Response log has been filled by DFN"]},{"entry":[{},"(set by DFN cleared by computer)"]},{"entry":["DAP_ENABLE_REG","Enable bit mask for circuits in DAP 372"]},{"entry":[{},"(set by DFN 304 cleared by host computer 114)"]},{"entry":["SIZE_RES_LOG","Response log buffer memory size in"]},{"entry":[{},"computer memory"]},{"entry":["BASE_LOG_A","Physical address of response log buffer A"]},{"entry":[{},"in computer memory"]},{"entry":["BASE_LOG_B","Physical address of response log buffer B"]},{"entry":[{},"in computer memory"]},{"entry":["TOT_IMG_SIZE","Specifies the size of the detector panel"]},{"entry":["NUM_BUFFERS","Number of entries in image buffer list"]},{"entry":["IMG_BUF_BAS_ADR","Physical address of image buffer address list"]},{"entry":["END_QUEUE_PTR","End of queue pointer (circular queue of image"]},{"entry":[{},"buffers on computer)"]},{"entry":["ROI_ORIGIN","Specifies the upper right hand corner of"]},{"entry":[{},"region of interest"]},{"entry":["ROI_SIZE","Specifies the size of region of interest"]},{"entry":["DMA_CHK","Sets window of allowed DMA addresses"]},{"entry":["PANEL_SIZE","Specifies the panel size"]},{"entry":["GEN_DATA","Specifies the pattern if the system is"]},{"entry":[{},"in generate data mode"]},{"entry":["READOUT_SIZE","Specifies the size of the detector panel"]},{"entry":["RL_GEN_FLAGS","Flags which enable various response log types"]},{"entry":["DMA_CONFIG","DMA configuration register"]},{"entry":["DAP_PARAM15R","RESERVED STATUS REGISTER"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Host computer  issues a plurality of commands to DFN , which are received and interpreted by PCI command interpreter  in EP . All commands to DFN  are executed by writing a 32 bit longword to the single hexadecimal address location xA00200. The command issued is specified by the 8 most significant bits (\u201cMSBs\u201d) of the longword. Supported commands are listed in Table 9 below. Each command has up to 24 bits of parameter space to specify operation of the command. Additionally, four registers on DFN  are reserved for extra parameter space (command parameter registers). If the command parameter registers are used, these parameters are loaded before command execution. The number of parameters used for a specific command is dependent on the command issued. Each command is described hereinafter.","Upon issuance of a command, DFN  will attempt to execute the command. The steps that command interpreter  will take are:","1. The command will be decoded and determined if it is a recognized command.","2. The command will be tested for validity depending on the top-level state of DFN .","3. The command will be issued to the sub-block on either the DAP or the EP responsible for the function.","4. A command timeout counter will be set and started.","5. Command interpreter  will wait until either the executing sub-block executed the command or until the command timeout signal is asserted.","6. The command issued will be copied into mailbox register  on computer communication interface .","7. Results of the command are copied into mailbox registers  through  on computer communication interface .","8. At least one bit in the doorbell register on computer communication interface  will be set indicating that the command execution is complete and the DFN  can be issued another command.","Commands recognized are listed in Table 9 as follows:",{"@attributes":{"id":"p-0282","num":"0285"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 9"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Command","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Get status","Take a snapshot of certain status variables"]},{"entry":["Run BIST","Execute one or more of the Built in self tests"]},{"entry":["Restart DFN","Issue a soft reset to selected functional blocks"]},{"entry":["Download EAB memory","Write between 1 and 16 Bytes to"]},{"entry":[{},"the EAB memory"]},{"entry":["Read back EAB memory","Read between 1 and 16 Bytes of EAB memory"]},{"entry":["Start queue","Begin executing the detector and x-ray"]},{"entry":[{},"event queues"]},{"entry":["Abort queue","Abort the execution of detector and x-ray"]},{"entry":[{},"event queues"]},{"entry":["DIAGNOSTIC mode","Make a state transition to top level"]},{"entry":[{},"state DIAGNOSTIC"]},{"entry":["NORMAL mode","Make a state transition to top level"]},{"entry":[{},"state NORMAL"]},{"entry":["TEST mode","Make a state transition to top level state TEST"]},{"entry":["Reset timer","Reset the timer"]},{"entry":["Abort DMA","Abort currently executing DMA"]},{"entry":["Setup DMA","Setup DMA on DFN 304"]},{"entry":["Access Local Bus","Perform a read or write on DFN 304s local bus"]},{"entry":["Send Command","Send a command directly to the detector"]},{"entry":[{},"control board"]},{"entry":["FC RCV Snapshot","Take a snapshot of the fiber channel"]},{"entry":[{},"receive bus"]},{"entry":["Switch RL buffer","Switch between response log buffer A and B"]},{"entry":["Disable Function","Disable one or more explicitly enabled"]},{"entry":[{},"functions of DFN 304"]},{"entry":["Generate Error","Generate an error to test command processor"]},{"entry":[{},"and driver"]},{"entry":["Host Flag","Computer processor sends a flag to event queue"]},{"entry":["Unimplemented","A dummy command that will not be"]},{"entry":[{},"implemented in DFN 304 to test the"]},{"entry":[{},"command processor"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Each command has a unique command code. They are listed for the individual commands in the tables below. All commands are executed in one or more states of DFN .",{"@attributes":{"id":"p-0284","num":"0287"},"figref":"FIG. 48","b":["304","630","632","632","634","638","634","636","638","640"]},"While DFN control unit  is executing the above operation, other operations are not issued to DFN . When DFN control unit  has completed executing the power up sequence, it transitions to a DIAGNOSTIC state. At this time the card will respond to commands. Normally, a command is issued to DFN  if the issued command is valid for the current state, such that DFN  will execute commands that are valid for that state. If a command is issued to DFN  which is not valid for the state that it is currently in, it will respond with an interrupt message indicating that the command was received and understood, but not executed because of a state error. If a command is issued to DFN  that is not understood, then DFN  responds with an interrupt indicating that a command was received but not understood.","Some commands need to be further specified using one or more of the 24 bits of parameter space argument field and others do not use additional arguments, as set forth below.",{"@attributes":{"id":"p-0287","num":"0290"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"GET STATUS: TAKE A SNAPSHOT OF ONE OR ALL"},{"entry":"OF STATUS FUNCTIONS."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Command Code","0000 0001"]},{"entry":["States where command are executable","DIAGNOSTIC"]},{"entry":["Parameter Space arguments","bits 2 down to 0"]},{"entry":["Command Parameter registers","NONE"]},{"entry":"RUN BIST"},{"entry":["Command Code","0000 0010"]},{"entry":["States where command are executable","DIAGNOSTIC"]},{"entry":["Parameter Space arguments","bits 3 down to 0"]},{"entry":["Command Parameter registers","NONE"]},{"entry":"RESTART DFN"},{"entry":["Command Code","0000 0011"]},{"entry":["States where command are executable","DIAGNOSTIC"]},{"entry":["Parameter Space arguments","NONE"]},{"entry":["Command Parameter registers","NONE"]},{"entry":"DOWNLOAD EAB MEMORY"},{"entry":["Command Code","0000 0101"]},{"entry":["States where command are executable","NORMAL, TEST, RUN,"]},{"entry":[{},"RUN_TEST"]},{"entry":["Parameter Space arguments","bits 3 down to 0"]},{"entry":["Command Parameter registers","CMD_0_PAR[,CMD_1_PAR"]},{"entry":[{},"CMD_2_PAR CMD_3PAR]"]},{"entry":"READ BACK EAB MEMORY"},{"entry":["Command Code","0000 0100"]},{"entry":["States where command are executable","NORMAL, TEST, RUN,"]},{"entry":[{},"RUN_TEST"]},{"entry":["Parameter Space arguments","bits 2 down to 0"]},{"entry":["Command Parameter registers","NONE"]},{"entry":"START QUEUE"},{"entry":["Command Code","0000 0110"]},{"entry":["States where command are executable","NORMAL, TEST"]},{"entry":["Parameter Space arguments","bit 23 down to 0"]},{"entry":["Command Parameter registers","NONE"]},{"entry":"ABORT QUEUE"},{"entry":["Command Code","0000 0111"]},{"entry":["States where command are executable","NORMAL, TEST, RUN,"]},{"entry":[{},"RUN_TEST"]},{"entry":["Parameter Space arguments","NONE"]},{"entry":["Command Parameter registers","NONE"]},{"entry":"DIAGNOSTIC MODE"},{"entry":["Command Code","0000 1000"]},{"entry":["States where command are executable","NORMAL, TEST"]},{"entry":["Parameter Space arguments","NONE"]},{"entry":["Command Parameter registers","NONE"]},{"entry":"NORMAL MODE"},{"entry":["Command Code","0000 1001"]},{"entry":["States where command are executable","DIAGNOSTIC"]},{"entry":["Parameter Space arguments","NONE"]},{"entry":["Command Parameter registers","NONE"]},{"entry":"TEST MODE"},{"entry":["Command Code","0000 1010"]},{"entry":["States where command are executable","DIAGNOSTIC"]},{"entry":["Parameter Space arguments","NONE"]},{"entry":["Command Parameter registers","NONE"]},{"entry":"RESET TIMER"},{"entry":["Command Code","0000 1011"]},{"entry":["States where command are executable","DIAGNOSTIC, NORMAL, TEST"]},{"entry":["Parameter Space arguments","bits 23 down to 0"]},{"entry":["Command Parameter registers","NONE"]},{"entry":"ABORT DMA"},{"entry":["Command Code","0000 1100"]},{"entry":["States where command are executable","DIAGNOSTIC, NORMAL, TEST"]},{"entry":["Parameter Space arguments","NONE"]},{"entry":["Command Parameter registers","NONE"]},{"entry":"SETUP DMA"},{"entry":["Command Code","0000 1101"]},{"entry":["States where command are executable","DIAGNOSTIC"]},{"entry":["Parameter Space arguments","NONE"]},{"entry":["Command Parameter registers","CMD_0_PAR CMD_1_PAR"]},{"entry":[{},"CMD_2_PAR, CMD_3_PAR"]},{"entry":"ACCESS LOCAL BUS"},{"entry":["Command Code","0000 1110"]},{"entry":["States where command are executable","DIAGNOSTIC"]},{"entry":["Parameter Space arguments","bit 23 down to 22"]},{"entry":["Command Parameter registers","CMD_0_PAR, [CMD_1_PAR]"]},{"entry":"SEND COMMAND"},{"entry":["Command Code","0000 1111"]},{"entry":["States where command are executable","DIAGNOSTIC"]},{"entry":["Parameter Space arguments","bit 23"]},{"entry":["Command Parameter registers","CMD_0_PAR, CMD_1_PAR"]},{"entry":"FC RCV SNAPSHOT"},{"entry":["Command Code","0001 0000"]},{"entry":["States where command are executable","DIAGNOSTIC"]},{"entry":["Parameter Space arguments","NONE"]},{"entry":["Command Parameter registers","NONE"]},{"entry":"SWITCH RL BUFFER"},{"entry":["Command Code","0001 0001"]},{"entry":["States where command are executable","DIAGNOSTIC, NORMAL, TEST,"]},{"entry":[{},"RUN, RUN_TEST"]},{"entry":["Parameter Space arguments","NONE"]},{"entry":["Command Parameter registers","NONE"]},{"entry":"DISABLE FUNCTION"},{"entry":["Command Code","0001 0010"]},{"entry":["States where command are executable","DIAGNOSTIC, NORMAL, TEST,"]},{"entry":[{},"RUN, RUN_TEST"]},{"entry":["Parameter Space arguments","bits 1 down to 0"]},{"entry":["Command Parameter registers","NONE"]},{"entry":"GENERATE ERROR"},{"entry":["Command Code","0001 0011"]},{"entry":["States where command are executable","DIAGNOSTIC, NORMAL, TEST,"]},{"entry":[{},"RUN , RUN_TEST"]},{"entry":["Parameter Space arguments","bit 5 down to 0"]},{"entry":["Command Parameter registers","NONE"]},{"entry":"UNIMPLEMENTED"},{"entry":["Command Code","0001 0100"]},{"entry":["States where command are executable","DIAGNOSTIC, NORMAL, TEST,"]},{"entry":[{},"RUN, RUN_TEST"]},{"entry":["Parameter Space arguments","NONE"]},{"entry":["Command Parameter registers","NONE"]},{"entry":"HOST FLAG"},{"entry":["Command Code","0001 0101"]},{"entry":["States where command are executable","NORMAL, RUN"]},{"entry":["Parameter Space arguments","bit 7 down to 0"]},{"entry":["Command Parameter registers","NONE"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"PC buffer management is provided by a plurality of image buffer control registers. The registers on DAP  are used for image buffer control, and are set forth in Table 10 below.",{"@attributes":{"id":"p-0289","num":"0292"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 10"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Register Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["IMG_BUF_BAS_ADR","Base address of list in PC memory (bits 31"]},{"entry":[{},"to 0)"]},{"entry":["NUM_BUFFERS","Number of entries in the list (bits 15 to 0)"]},{"entry":["END_QUEUE_PTR","Last buffer (ordinal) that the computer has"]},{"entry":[{},"processed. (bits 15 to 0)"]},{"entry":["LAST_WRTN_DFN","Last buffer (ordinal) that DFN 304 has trans-"]},{"entry":[{},"ferred Bit 31 flag to indicate that a wrap has"]},{"entry":[{},"occurred. Bits 15 to 0 ordinal of last frame"]},{"entry":[{},"written by DFN."]},{"entry":["DAP_ENABLE_REG","Bit \u201c2\u201d when cleared enables the buffer"]},{"entry":[{},"management circuit (set on power up, and on"]},{"entry":[{},"error)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"In the following discussion, the flag bFULL (a bit in LAST_WRTN_DFN) indicates that the buffers are full and the flag bAllowWrap (a bit in END_QUEUE_PTR) indicates that wrapping is enabled.","The host computer  will allocate memory for the frame buffers and manage them. The number of buffers will be dependent on the X-RAY application and on the amount of memory available to host computer . The buffers are large enough to contain at least 1 frame of image data. The actual size of the image buffer is dependent on the applications. (i.e. 2 MByte for cardiac\/surgical digital x-ray, 8 MBytes for radiography digital x-ray, and 9 MByte for mammography digital x-ray). When the computer wants to capture data, it creates a list of base addresses that are read by DFN . This list includes all or a subset of the N buffers that host computer  is managing.","For continuous operation, the list will wrap. To indicate whether a wrap has occurred, register LAST_WRTN_DFN listed above also has a flag which indicates the occurrence of a wrap. This list is set before the Begin Sequence command or any command where a frame of data will be transferred from DFN . The three registers (IMG_BUF_BAS_ADR, NUM_BUFFERS and END_QUEUE_PTR) listed above are initialized before the \u201cbegin sequence\u201d command. If the number of entries in the list is \u201cN,\u201d then the normal setting for register END_QUEUE_PTR will be \u201cN\u201d indicating that all buffers from 1 to N\u22121 are free to be used by DFN .","The DFN initializes bFull=FALSE and LAST_WRTN_DFN=0, and the driver initializes END_QUEUE_PTR=0. Before acquisition, the Driver sets a \u201cEND_QUUE_PTR\u201d bit to 0 (no wrap) or 1 (wrap).","For the operations below, that flag bit is called \u201cbAllowWrap\u201d.","By way of example, when the DFN  determines that an image is in the DFN memory and needs to be transferred to the host computer , DFN  executes the following operations:",{"@attributes":{"id":"p-0296","num":"0299"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"char"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1.","if (bAllowWrap = TRUE)"]},{"entry":[{},"if (LAST_WRTN_DFN = END_QUEUE_PTR)"]},{"entry":[{},"if(bFull = TRUE)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"ERROR and stop"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"else \/* bAllowWrap = FALSE *\/"]},{"entry":[{},"if (LAST_WRTN_DFN = 0)"]},{"entry":[{},"if(bFull = TRUE)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"ERROR and stop"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["2.","do DMA"]},{"entry":["3.","increment LAST_WRTN_DFN (modulo)"]},{"entry":["4.","if (bAllow Wrap = TRUE)"]},{"entry":[{},"if (LAST_WRTN_DFN = END_QUEUE_PTR)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"bFull = TRUE"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"else \/* bAllowWrap = FALSE *\/"]},{"entry":[{},"if (LAST_WRTN_DFN = 0)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"bFull = TRUE"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["5.","send DMA done interrupt to PC"]},{"entry":["6.","return"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Host computer  will map, then unmap the image(s) and update END_QUEUE_PTR. The firmware takes this action whenever END_QUEUE_PTR is written by host computer :\n\n","The host computer  processes and displays frames after DFN  has transferred data into them. If host computer  is waiting for a frame to be filled by DEN , host computer  does not need to continuously poll DFN . The doorbell message from DFN  optionally indicates that DFN  has filled a buffer because there may be more types of doorbell messages. The doorbell is set after the whole image has been transferred, not after each DMA transfer, if more than one DMA is performed to transfer the entire image. After the doorbell message has been received, the host computer  reads DFN  last buffer count (register ). If the buffer that it wants to process has been filled, it processes and displays that buffer. After host computer  is finished processing the buffer, and it is authorizing wraps, it increments the number in the \u201chost last buffer\u201d count (register ). Upon error in DFN , the buffer management circuit disables itself by setting bit \u201c\u201d in the DAP_ENABLE_REG register. The error condition identified that disables the buffer management circuit occurs when DFN  has a image buffer using transfer to host computer , such that DFN  reads if VAL(register )=(VAL(register )+1) mod N.","The response log acquires image data information. According to an embodiment of the present invention, the image data information includes commands and errors as they occur such that the image data information can be associated with a corresponding captured image. For response log management, response log packets are sent to host computer  as they are generated on DFN . A command sent to the detector while executing the event queue generates a response log packet if enabled. Any command sent to the detector is enabled or disabled from generating a response log packet.","Definition of Response Log (\u201cRL\u201d) Entry Format","The format incorporates a unique Type identifier for each response log (\u201cRL\u201d) entry. This format is to make it easier for applications to sift through RL data for particular types of information. The Type identifier is divided into Class and Subclass sections and includes 4 bits that are reserved for chaining. Chaining is used to create a single RL entry with up to 128 Bytes of data available. The RL entry format includes a 32 bit time stamp which is the elapsed time since the beginning of the sequence. The Sequence ID has a 24 bit unique identifier which is written by a DFN driver using the either the Begin Sequence command or the Reset Timer command; DFN mode reflects the current mode of operation of the card (e.g. Diagnostic, Run, etc. . . . ). There are five 32 bit fields which store the data for the entry. Their use is defined depending on the type of the response log entry. A predefined separator to make it easier to sift through a corrupted RL buffer terminates the structure. A response log entry is organized in little Endian format; that is the least significant byte of a field or object occupies the lower address in the response log  (FIG. ). For example, the response log entry will begin with the Type field bits :, the subclass and reserved chaining information.","Table 11 below sets forth a structure of the response log (\u201cRL\u201d) entry format.",{"@attributes":{"id":"p-0303","num":"0310"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 11"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Object","Bytes","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Type","2","Class(7:0); subclass(11:8)"]},{"entry":["Timestamp","4","Time when data generated"]},{"entry":["Sequence ID","4","Unique identifier(23:0); DFN mode(27:24)"]},{"entry":["Field 1","4","32 bit Data Word 1"]},{"entry":["Field 2","4","32 bit Data Word 2"]},{"entry":["Field 3","4","32 bit Data Word 3"]},{"entry":["Field 4","4","32 bit Data Word 4"]},{"entry":["Field 5","4","32 bit Data Word 5"]},{"entry":["Terminator","2","Separator word (\u201c0xFAFA\u201d)"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Classes of Response Log (\u201cRL\u201d) Entry","A number of specific classes of RL entry are defined to make it easier to sort through the data when looking for particular information. Currently defined classes are shown in the Table 12 and discussed in this section. RL entry reporting for class 0x03 is individually disabled using a bit field in the respective event code. Reporting for classes 0x02, 0x04, and 0x06 is individually disabled using bits in registers on DFN . The class field \u201c-S-\u201d is a 4 bit Subclass place holder; the class field \u201c-N-\u201d is a 4 bit place holder reserved for chaining of RL entries.","Table 12 sets forth currently defined RL entry classes.",{"@attributes":{"id":"p-0307","num":"0314"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 12"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"CLASS","CLASS CODE","Sub-class"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Image Tag","0x01","x0"]},{"entry":[{},"Detector Command","0x02","x0, x1, x2"]},{"entry":[{},"Queue Event","0x03","x0"]},{"entry":[{},"Image Readout","0x04","0, x1"]},{"entry":[{},"Real time bus State","0x05","x0"]},{"entry":[{},"DMA Information","0x06","x0"]},{"entry":[{},"Sequence Transition","0x07","x0, x1, x2, x3"]},{"entry":[{},"Error","0x0E","x0"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"Image Tag","An image tag is generated when the end of frame (SOFn3) is received on the image detection bus  for the respective image. The tag records the exact time at the end beginning of the frame sequence in ticks of the 2 \u03bcsec Frame Sequence counter. It also records the Ordinal Image Number for the particular frame. In addition, it records the image specific register settings which were active when the image data was received. This setting includes the image and block size as well as any additional frame options that control readout of the image. This entry also records data read from the SOFn3 which provides details on the formatting of the image data from the detector.","Table 13 below sets forth a format of image tag RL entry.",{"@attributes":{"id":"p-0311","num":"0318"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 13"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Object","Description","Format"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Identifier","Image Tag","Class(7:0) = 0x01, subclass(11:8) = 0x0"]},{"entry":["Timestamp","Time data","32 bit count in 2 \u03bcsec clk tics"]},{"entry":[{},"generated"]},{"entry":["Sequence ID","Unique","RESERVED(31:28), DFN Mode(27:24);"]},{"entry":[{},"identifier","Sequence ID(23:0)"]},{"entry":["Field 1","Ordinal","32 bit count of current image"]},{"entry":[{},"Image #"]},{"entry":["Field 2","Image Size","\u2014"]},{"entry":["Field 3","Block Size","\u2014"]},{"entry":["Field 4","SOFn3 -","(B3: Number of bits per pixel)"]},{"entry":[{},"HDR1"]},{"entry":["Field 5","SOFn3 -","(B0-1: Pixels per line) (B2-3: Lines per"]},{"entry":[{},"HDR2","image)"]},{"entry":["Terminator","Unique","0xFAFA"]},{"entry":[{},"separator"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Detector Commands","Detector Command RL entry is generated when a command is sent and executed on the detector. The entry is not generated until either the acknowledgment is received from the detector or the fiber channel timeout is exceeded. The entry contains the original command, and the detector response. RL entries are also created for spontaneous detector acknowledgment without DFN initiation for debugging purposes. In this case, fields  and  will be 0xFFFFFFFF indicating an anomalous condition and Fields  and  will hold the detector response.","Table 14 sets forth a format of detector command RL Entry.",{"@attributes":{"id":"p-0315","num":"0322"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 14"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Object","Description","Format"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Identifier","Detector","Class(7:0) = 0x02"]},{"entry":[{},"Command","subclass(11:8) = 0x0: normal"]},{"entry":[{},{},"0x1: Unexpected detector ack received"]},{"entry":[{},{},"0x2: Timeout: Detector did not respond"]},{"entry":["Timestamp","Time data","32 bit count in 2 \u03bcsec clk tics"]},{"entry":[{},"generated"]},{"entry":["Sequence ID","Unique identifier","RESERVED(31:28)"]},{"entry":[{},{},"DFN Mode(27:24); Sequence ID(23:0)"]},{"entry":["Field 1","CMD - HDR1","Type of Detector command"]},{"entry":["Field 2","CMD - HDR2","Argument of command"]},{"entry":["Field 3","ACK - HDR1","Detector response - type"]},{"entry":["Field 4","ACK - HDR2","Detector response - argument"]},{"entry":["Field 5","Reserved","\u2014"]},{"entry":["Terminator","Unique separator","0xFAFA"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Event Queue Information","The Event Queue RL entry is generated whenever a Detector queue event is executed. The entry contains an Event Descriptor which gives the byte code for the event type as well as the current value of the queue pointer into EAB memory for the respective event instruction. The arguments of the event instruction are stored in Fields  and . Additional information, like the current value of the loop pointer on a Loop instruction is stored in Field . Loop entries generate an entry each time through the loop.","Table 15 sets forth a format of event queue response log (\u201cRL\u201d) entry.",{"@attributes":{"id":"p-0319","num":"0326"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 15"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Object","Description","Format"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Identifier","Queue Event","Class(7:0) = 0x03"]},{"entry":[{},{},"subclass(11:8) = 0x0"]},{"entry":["Timestamp","Time when data","32 bit count in 2 \u03bcsec clk tics"]},{"entry":[{},"generated"]},{"entry":["Sequence ID","Unique identifier","RESERVED(31:28)"]},{"entry":[{},{},"DFN Mode(27:24); Sequence"]},{"entry":[{},{},"ID(23:0)"]},{"entry":["Field 1","Event Descriptor","Event Byte code(7:0); Queue"]},{"entry":[{},{},"Pointer(15:8)"]},{"entry":["Field 2","Event Arguments 1","Event arguments B0(7:0); B1(15:8);"]},{"entry":[{},{},"B2(23:16); B3(31:24)"]},{"entry":["Field 3","Event Arguments 2","Event arguments B4(7:0); B5(15:8);"]},{"entry":[{},{},"B6(23:16); B7(31:24)"]},{"entry":["Field 4","Ancillary","Loop event: Current value of the loop"]},{"entry":[{},"Information","counters"]},{"entry":[{},{},"loop2_index(31:16); loop1_index"]},{"entry":[{},{},"(15:0)"]},{"entry":["Field 5","Reserved","\u2014"]},{"entry":["Terminator","Unique separator","0xFAFA"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Image Readout Information","Image readout related information is recorded using these RL entries. This information is embedded in the data received from the detector during image readout and is used for debugging detector readout firmware. This data corresponds to the SOFn2 and SOFn3 commands received during image acquisition. Data for the SOFn1 command is stored in the image tag and discussed above.","Table 16 sets forth a format of image readout RL entry.",{"@attributes":{"id":"p-0323","num":"0330"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 16"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Object","Description","Format"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Identifier","Image Readout","Class(7:0) = 0x04"]},{"entry":[{},{},"subclass(11:8) ="]},{"entry":[{},{},"0x0: Image Packet (SOFn2)"]},{"entry":[{},{},"0x1: Image Done (SOFn3)"]},{"entry":["Timestamp","Time data","32 bit count in 2 \u03bcsec clk tics"]},{"entry":[{},"generated"]},{"entry":["Sequence ID","Unique identifier","RESERVED(31:28)"]},{"entry":[{},{},"DFN Mode(27:24); Sequence ID(23:0)"]},{"entry":["Field 1","Line number","Hdr11 (Image Packet)"]},{"entry":["Field 2","Reserved","\u2014"]},{"entry":["Field 3","Reserved","\u2014"]},{"entry":["Field 4","Reserved","\u2014"]},{"entry":["Field 5","Reserved","\u2014"]},{"entry":["Terminator","Unique separator","0xFAFA"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Real Time Bus State","The Real Time Bus State RL entry is generated when a state change is detected on real time bus . This information will be useful for tracking the actual state of the lines of real time bus  during acquisition.","Table 17 sets forth a format of real time bus state RL entry.",{"@attributes":{"id":"p-0327","num":"0334"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 17"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Object","Description","Format"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Identifier","Real Time Bus","Class(7:0) = 0x05"]},{"entry":[{},"State","subclass(11:8) = 0x0"]},{"entry":["Timestamp","Time data","32 bit count in 2 \u03bcsec clk tics"]},{"entry":[{},"generated"]},{"entry":["Sequence ID","Unique identifier","RESERVED(31:28)"]},{"entry":[{},{},"DFN Mode(27:24); Sequence ID(23:0)"]},{"entry":["Field 1","New State","RESERVED(31:28)"]},{"entry":[{},{},"State after the change: Read state(11:0);"]},{"entry":[{},{},"Drive state (27:16)"]},{"entry":["Field 2","Previous State","RESERVED(31:28)"]},{"entry":[{},{},"State before the change: Read"]},{"entry":[{},{},"state(11:0); Drive state (27:16)"]},{"entry":["Field 3","Reserved","\u2014"]},{"entry":["Field 4","Reserved","\u2014"]},{"entry":["Field 5","Reserved","\u2014"]},{"entry":["Terminator","Unique separator","0xFAFA"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"DMA Information","The DMA Information RL entry is generated when DMA of the current image buffer is initiated. This information will be useful for debugging DMA problems including situations in which third party PCI cards are reducing the available bandwidth on the bus.","Table 18 sets forth a format of DMA RL entry.",{"@attributes":{"id":"p-0331","num":"0338"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 18"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Object","Description","Format"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Identifier","DMA Information","Class(7:0) = 0x06"]},{"entry":[{},{},"subclass(11:8) = 0x0"]},{"entry":["Timestamp","Time data","32 bit count in 2 \u03bcsec clk tics"]},{"entry":[{},"generated"]},{"entry":["Sequence ID","Unique identifier","RESERVED(31:28)"]},{"entry":[{},{},"DFN Mode(27:24); Sequence ID(23:0)"]},{"entry":["Field 1","Image Number","Ordinal image number (31:0)"]},{"entry":["Field 2","Current Buffer","Ordinal buffer number (31:16); Current"]},{"entry":[{},{},"DFN buffer number (15:0)"]},{"entry":["Field 3","Buffer Address","Address of current buffer in computer"]},{"entry":[{},{},"RAM"]},{"entry":["Field 4","DMA Size","Size of the DMA packet (31:0)"]},{"entry":["Field 5","Reserved","\u2014"]},{"entry":["Terminator","Unique separator","0xFAFA"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Sequence Transition","The Sequence Transition RL entry is generated whenever a sequence related transition takes place. Note that the sequence timer is reset whenever an RL entry of this type is generated. When the user mode program begins interaction with the detector outside of an event sequence (\u201cChit-Chat\u201d mode), the driver resets the sequence timer and passes a sequence ID to DFN  to be used for subsequent RL entries. The archive DLL is responsible for keeping track of the absolute time in the system as all RL entries supply relative timing information.","Table 19 sets forth a format of sequence transition RL entry.",{"@attributes":{"id":"p-0335","num":"0342"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 19"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Object","Description","Format"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Identifier","Sequence Transition","Class(7:0) = 0 \u00d7 07"]},{"entry":[{},{},"subclass(11:8) = 0 \u00d7 0"]},{"entry":[{},{},"0 \u00d7 0: Begin Sequence"]},{"entry":[{},{},"0 \u00d7 1: End Sequence"]},{"entry":[{},{},"0 \u00d7 2: Sequence Timer Wrapped"]},{"entry":[{},{},"0 \u00d7 3: Sequence Timer Reset"]},{"entry":["Timestamp","Time data generated","32 bit count in 2 \u03bcsec clk tics"]},{"entry":["Sequence ID","Unique identifier","RESERVED(31:28)"]},{"entry":[{},{},"DFN Mode(27:24); Sequence ID"]},{"entry":[{},{},"(23:0)"]},{"entry":["Field 1","Last Timer Count","State of the sequence timer when"]},{"entry":[{},{},"transition occurred (31:0)"]},{"entry":["Field 2","Wraps since reset","Number of wraps (15:0)"]},{"entry":["Field 3","Reserved","\u2014"]},{"entry":["Field 4","Reserved","\u2014"]},{"entry":["Field 5","Reserved","\u2014"]},{"entry":["Terminator","Unique separator","0 \u00d7 FAFA"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Errors","The Error RL entry records errors which were generated due to problems on DFN  or on the fiber channel link.","Table 20 sets forth a format of error RL entry.",{"@attributes":{"id":"p-0339","num":"0346"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 20"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Object","Description","Format"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Identifier","Error","Class(7:0) = 0 \u00d7 0E"]},{"entry":[{},{},"subclass(11:8) = 0 \u00d7 0"]},{"entry":["Timestamp","Time data generated","32 bit count in 2 \u03bcsec clk tics"]},{"entry":["Sequence ID","Unique identifier","RESERVED(31:28)"]},{"entry":[{},{},"DFN Mode(27:24); Sequence ID"]},{"entry":[{},{},"(23:0)"]},{"entry":["Field 1","EP Error","32 bit error word"]},{"entry":["Field 2","DAP Error","32 bit error word"]},{"entry":["Field 3","Queue Error","32 bit error word"]},{"entry":["Field 4","Fiber Channel Error","32 bit error word"]},{"entry":["Field 5","Reserved","\u2014"]},{"entry":["Terminator","Unique separator","0 \u00d7 FAFA"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Table 21 sets forth registers on DFN  used for response log control.",{"@attributes":{"id":"p-0341","num":"0348"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 21"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Register","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["SIZE_RES_LOG","Size of response log buffers"]},{"entry":["BASE_LOG_A","Base address of response log buffer A,"]},{"entry":[{},"bits(31-12) are used for base address."]},{"entry":["BASE_LOG_B","Base address of response log buffer B,"]},{"entry":[{},"bits(31-12) are used for base address."]},{"entry":["RES_LOG_FULL","Bit YY indicates that response buffer A is"]},{"entry":[{},"filled. Bit YZ indicates that response buffer B"]},{"entry":[{},"is filled. Bit E1 indicates that both response"]},{"entry":[{},"buffers are full and response log circuit is"]},{"entry":[{},"deactivated."]},{"entry":["EP_ENABLE_REG","Bit \u201cY\u201d when cleared enables the response"]},{"entry":[{},"log circuit (set on power up, and on error)"]},{"entry":["RESP_LOG_STAT_A","Status of response log buffer A bits(31-5)"]},{"entry":[{},"contain last written address. Bit(1) indicates if"]},{"entry":[{},"buffer has any data in it. Cleared when"]},{"entry":[{},"response log circuit Enabled, set when first"]},{"entry":[{},"entry is made. Bit(0) when set indicates that"]},{"entry":[{},"last data were transferred to buffer A."]},{"entry":["RESP_LOG_STAT_B","Status of response log buffer B bits(31-5)"]},{"entry":[{},"contain last written address. Bit(1) indicates if"]},{"entry":[{},"buffer has any data in it. Cleared when"]},{"entry":[{},"response log circuit Enabled, set when"]},{"entry":[{},"first entry is made. Bit(0) when set"]},{"entry":[{},"indicates that last data were transferred"]},{"entry":[{},"to buffer B."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"DFN  is initially (on power up and after an error) disabled from sending response log packets. To enable transfer, host computer  configures the response log circuit and then enables the circuit. The computer configures the two response log buffers by writing the size of the response log buffers and the base addresses of the two buffers into the SIZE_RES_LOG register the BASE_LOG_A register and the BASE_LOG_B register. The size of the two response log buffers is identical and is an integral multiple of 32 Bytes. The response log buffers start on a 4K page boundary (i.e. bits - are 0).","Host computer  next enables the response log  by clearing bit Y of the EP_ENABLE_REG. Upon startup, DFN  will use the base address of response buffer A for the first response log entry. The second response log entry will be sent to the base address of response buffer offset by 32 Bytes (10000). Subsequent response log entries will be transferred to the base address of response buffer A offset by 32 (Bytes) times the number of response log entries. When the response buffer A is full (address is beyond BASE_LOG_A+SIZE), DFN  will set bit YY in the RES_LOG_FULL indicating that buffer A is full. Bit ZZ in the doorbell register on the PCI  will also be set, sending an interrupt to the host computer . If bit YZ in the RES_LOG_FULL register is not set, DFN  will then start writing response log entries into response buffer B, starting at the base address and continuing until response log buffer B is filled. When buffer B is filled, DFN  will set bit YZ in the RES_LOG_FULL indicating that buffer B is full and set bit ZZ of the doorbell register on the PCI  sending another interrupt to the computer. Then DFN  will check if bit YY in the RES_LOG_FULL register has been cleared. If this bit has been cleared, then DFN  will reuse response log buffer A. When DFN  switches response log buffers from either A to B or from B to A, it will expect that the response log full flags for the next buffers (either YY or YZ of register RES_LOG_FULL) are cleared. An error condition will have occurred if the computer has not cleared the bit. If this error condition occurs, bits YY and YZ and Bit E of the RES_LOG_FULL register will be set, and DFN  will set bit Y of the EP_ENABLE_REG register, which will disable and reset the response log circuit. Clearing this bit restarts the response log circuit. If the circuit is restarted, DFN  will begin transferring response log entries into the base address of response log buffer A.","Host computer  forces a switch between the two response log buffers by issuing the command Switch RL buffer. If this occurs, then DFN  will immediately switch between buffers A and B. If the switch is forced while response log buffer A is the current active buffer, then bit YY of the register RES_LOG_FULL will be set and a doorbell interrupt will be set to the computer. DFN  will begin sending response log entries to the base address of response log buffer B. If bit YZ of RES_LOG_FULL is set, then an error has occurred and DFN  will set bit Y of the EP_ENABLE_REG register, disabling the response log circuit.","At any time the host computer  reads the two registers RESP_LOG_STAT_A or RESP_LOG_STAT_B to determine the status of the response log circuit. The contents of these status registers contain address of the last response log entry written to response log buffer A and B respectively. They also contain a flag indicating whether response log buffer A or B was the target of the last response log entry. After a forced switch, they are read to determine the number of response log entries that occurred before the switch. They are read after both response-log buffers are filled to determine which buffer contains the older response log entries.","Fiber Channel Loopback","The Fiber channel loopback test is designed to test the Fiber channel chip set. The test is initiated by EP  device by asserting the LOOPEN signal line. This signal line shorts the outputs of the fiber optic transmit unit  to the receive inputs of the fiber optic receive unit . This closes the loop through the encoder\/decoder unit  back to EP . Next, EP  attempts to send a FC command over the link and monitors the return bus for the expected echo. The format of the command words has alternating 1 and 0 patterns and is designed to test the transmit and receive bus lines for shorts and opens. If the correct pattern is received, the test passes. The results are reported to the computer.","This test is incapable of verifying the fiber optic transceiver module but is also qualifiable with a setting that causes the test to run without asserting LOOPEN. In this case, a short length of fiber cable is looped from the module output back to its input to close the loop. The test is generally available for debugging of DFN .","Real Time Bus Loopback","The real time bus  is testable for integrity of the transceiver chip set electronics. The real time bus loopback test is performed by EP  by writing data out to the devices on the transmit bus and then monitoring the receive bus for the same data. Since the chips have their receivers and transmitters for each channel wired together, anything transmitted will automatically be received. The real time bus loopback test has a series of words of alternating 1 and 0 patterns which are designed to check for opens and shorts on the transmit and receive data bus traces and chip pins. A successful real time bus loopback test indicates that the chips themselves are functioning correctly.","The real time bus loopback test is further augmented to test the traces out to the 31 pin miniature D connector as well as the connector solder joints. An external test connector is made up to short all even channels to all odd channels. Data is then transmitted on the even channels and monitored on the odd channels and vise versa. The real time bus loopback test indicates that the entire communication chain out to the connector is working order and is generally not run automatically. The real time bus loopback test is available for debug of real time bus .","RAM Built in Self Test (\u201cBIST\u201d)","DFN  has ten 8 Megabit SRAM devices which together contribute the majority of connections to DAP . There is the possibility that these devices might have been damaged during board handling and therefore they need to be tested using an exhaustive RAM BIST test.","The RAM BIST has three related tests all of which are conducted by firmware in DAP . In the first test, odd and even memory locations are filled with alternating 1 and 0 patterns and then read out and checked. In the second test the odd and even values are reversed. In the third test, the value of the address of a particular location is written into that location. Once the entire RAM has been filled, the data is read out and compared to the original.","These three tests will verify that every bit of RAM on the card is good and will also check for shorts on traces and between pins on the SRAM devices and on the majority of pins on DAP .","Interrupts","DFN  supports generation of interrupts but does not respond to interrupts. The procedure for handing interrupts generated by DFN  is defined here. Interrupts generated on DFN  are not directly issued to the PCI interrupt pin. The computer communication interface  is responsible for issuing and clearing the interrupt on computer communication bus .","The computer communication interface  contains two doorbell registers whose purpose is to generate interrupts on DFN  and on computer communication bus . The doorbell register used to generate interrupts on computer communication bus  is the Local-to-PCI Doorbell Register (L2PDBELL). This register is accessed from the PCI side (i.e. host computer ) at offset x64 from the computer communication interface  base address. The host computer  reads this register to determine which doorbell bit was set. DFN  sets the doorbell by writing a 1 to a particular bit. The host computer  clears a doorbell bit by writing a \u201c1\u201d to that bit position.","The host computer  enables DFN  generated interrupts by setting two bits in the Interrupt Control\/Status Register (INTSCR) on computer communication interface . This register is accessed from the PCI side at offset x68 from the computer communication interface  base address. DFN generated interrupts are enabled by setting both bit , the PCI Interrupt Enable Bit, and bit , the PCI Doorbell Interrupt Enable bit.","The L2PDBELL register is a 32 bit register. A particular type of doorbell denotes a unique interrupt messages. The general method of handling interrupts generated by DFN  is:","Read the L2PDBELL register;","Determine the source(s) of the interrupt by examining the bits which generated the interrupt;","Perform action(s);","Clear the source(s) of the interrupt on DFN ;","Clear the bit in the L2PDBELL register which generated the interrupt; and","Read back the L2PDBELL register to determine that the PCI interrupt has been cleared.","In some cases, depending on the cause of the interrupt, steps 3 and 4 above may not be used.","The specific bit which each specific interrupt type sets in the L2PDBELL register is shown in the following Table 22.",{"@attributes":{"id":"p-0369","num":"0376"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 22"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":[{},"Bit in"]},{"entry":["Cause","L2PDBELL"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Command received and executed normally","0"]},{"entry":["Command received and not understood","1"]},{"entry":["Command received and executed with error","2"]},{"entry":["Command received and not executed (wrong state)","3"]},{"entry":["Command received and not executed (not implemented)","4"]},{"entry":["Command received and executed but timed out","5"]},{"entry":["End of queue reached with no images pending","6"]},{"entry":["End of queue reached with images pending","7"]},{"entry":["Image transfer to computer complete, others are pending","8"]},{"entry":["Image transfer to computer complete and non are pending","9"]},{"entry":["Interrupt to computer generated in queue","10"]},{"entry":["Queue is waiting on signal from computer","11"]},{"entry":["Response Log buffer has been switched","12"]},{"entry":["RESERVED","13"]},{"entry":["RESERVED","14"]},{"entry":["RESERVED","15"]},{"entry":["Error (Read ERR0R to determine source)","16"]},{"entry":["Error (Read ERR1R to determine source)","17"]},{"entry":["Error (Read ERR2R to determine source)","18"]},{"entry":["Error (Read ERR3R to determine source)","19"]},{"entry":["Error (Read DAP_ERR0R determine source)","20"]},{"entry":["Error (Read DAP_ERR1R determine source)","21"]},{"entry":["Error (Read DAP_ERR2R determine source)","22"]},{"entry":["Error (Read DAP_ERR3R determine source)","23"]},{"entry":["RESERVED","24"]},{"entry":["RESERVED","25"]},{"entry":["RESERVED","26"]},{"entry":["RESERVED","27"]},{"entry":["RESERVED","28"]},{"entry":["RESERVED","29"]},{"entry":["RESERVED","30"]},{"entry":["RESERVED","31"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The bits marked \u201cRESERVED\u201d are for future use and will not normally be set by DFN . The bits marked \u201cError\u201d indicate that an error has been trapped in either the DAP or the EP FPGAs on DFN . If DFN  sets one of these bits, the actual source of the error is determinable by reading the appropriate error register as indicated in Table 22. Under normal circumstances, the error is cleared in DFN  before it is cleared in computer communication interface .","The interrupts caused by setting bits  through  on the L2PDBELL register are interrupts that are generated during normal execution.","DAP\/EP Interaction","Information that is sent from EP  to DAP  used for assembly of response logs is communicated to DAP  using bits (:) of the FPGA bus connecting DAP  and EP .","The entire set of information that DAP  needs to assemble response log entries is communicated once for each 2 \u03bcsec interval. Much of the information originates from the event queue within EP . The data is then serialized out of EP  immediately after EP  receives the 2 \u03bcsec pulse. The first word out of the event queue is an instruction word, indicating which response log entries need to be generated corresponding to the current event instruction.","The format of the instruction word is set forth in the following Table 23.",{"@attributes":{"id":"p-0376","num":"0383"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 23"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["bits(15)","Reserved"]},{"entry":["bit(14)","Make a Detector Command class response entry flag."]},{"entry":["bits(13:10)","Detector Command sub-class code"]},{"entry":["bit(9)","Make a Event Queue Information class response entry flag."]},{"entry":["bits(8:5)","Event Queue Information sub-class code"]},{"entry":["bit(4)","Real Time Bus State class response entry flag"]},{"entry":["bits(3:0)","Real Time Bus State sub-class code"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The next 20 words (words  through ) that will be transferred to DAP  also originate from the event queue and will be serialized out in 16 bit words.","The order is as follows in Table 24.",{"@attributes":{"id":"p-0379","num":"0386"},"tables":{"@attributes":{"id":"TABLE-US-00027","num":"00027"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 24"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Name","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"word 1","Detector Commands-field 1 (bits 15:0)"]},{"entry":[{},"word 2","Detector Commands-field 1 (bits 31:16)"]},{"entry":[{},"word 3","Detector Commands-field 2 (bits 15:0)"]},{"entry":[{},"word 4","Detector Commands-field 2 (bits 31:16)"]},{"entry":[{},"word 5","Detector Commands-field 3 (bits 15:0)"]},{"entry":[{},"word 6","Detector Commands-field 3 (bits 31:16)"]},{"entry":[{},"word 7","Detector Commands-field 4 (bits 15:0)"]},{"entry":[{},"word 8","Detector Commands-field 4 (bits 31:16)"]},{"entry":[{},"word 9","Event Queue Information-field 1 (bits 15:0)"]},{"entry":[{},"word 10","Event Queue Information-field 1 (bits 31:16)"]},{"entry":[{},"word 11","Event Queue Information-field 2 (bits 15:0)"]},{"entry":[{},"word 12","Event Queue Information-field 2 (bits 31:16)"]},{"entry":[{},"word 13","Event Queue Information-field 3 (bits 15:0)"]},{"entry":[{},"word 14","Event Queue Information-field 3 (bits 31:16)"]},{"entry":[{},"word 15","Event Queue Information-field 4 (bits 15:0)"]},{"entry":[{},"word 16","Event Queue Information-field 4 (bits 31:16)"]},{"entry":[{},"word 17","RT Bus State-field 1 (bits 15:0)"]},{"entry":[{},"word 18","RT Bus State-field 1 (bits 31:16)"]},{"entry":[{},"word 19","RT Bus State-field 2 (bits 15:0)"]},{"entry":[{},"word 20","RT Bus State-field 2 (bits 31:16)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The next 6 words ( through ) transferred to DAP  are error signals. The next 6 words are transferred in the following order, as set forth in Table 25.",{"@attributes":{"id":"p-0381","num":"0388"},"tables":{"@attributes":{"id":"TABLE-US-00028","num":"00028"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 25"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Name","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"word 21","EP Error - (bits 15:0)"]},{"entry":[{},"word 22","EP Error - (bits 31:16)"]},{"entry":[{},"word 23","Queue Error - (bits 15:0)"]},{"entry":[{},"word 24","Queue Error - (bits 31:16)"]},{"entry":[{},"word 25","Fiber Channel Error - (bits 15:0)"]},{"entry":[{},"word 26","Fiber Channel Error - (bits 31:16)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"System Overview","As shown in , imaging system  provides an upgradeable digital x-ray system, which takes advantage of widely available PC technology for a computer platform. Imaging system  runs under a task based, non-real time operating system. At the same time, imaging system  provides control of the low level events occurring during image acquisition. High level and low level functions are partitioned for best utilization of resources. In particular, all functions which occur in real-time are pushed down into hardware to remove the burden of real-time operation on the computer operating system. These functions are often better suited to hardware implementation because complex data processing operations are not performed. In contrast, image processing functions such as gain and offset correction are often relatively costly to implement in custom purpose hardware.","Therefore, imaging system  uses simple and special purpose hardware for real-time control, and processes image data on host computer .","The Event Sequence","Image acquisition includes a sequence of events, which occur at precisely-timed intervals and involve control of radiation generation system  and image detection system . In most cases, the user knows an exact order in which these events need to occur well in advance of the image acquisition. This sequence will vary from acquisition to acquisition depending on the type of experiment being performed and the type of information the user is seeking to learn through the image acquisition. Therefore, a list or description of the sequence of event instructions to be performed is constructed. This list is not constructed in real-time and is therefore performed on host computer . Once the Event Sequence is known, the details are transmitted to special purpose hardware for execution in real-time.","Returning to , described in greater detail above, a high level description of the image acquisition is generated by acquisition control software, such as test control application . This description includes a sequence of frames to be acquired and optionally includes details such as frame time or amplifier gain to be used during acquisition. This Frame Sequence is then translated to an Event Sequence using a compiler which knows the details of the target control hardware. This event sequence is then sent over computer communication bus  to detector framing node , where it is stored in preparation for execution. Execution of the sequence is initiated by sending a Begin Sequence command over computer communication bus . The extent of real-time control allotted to host computer  is determining when the sequence will begin. Once the Event Sequence is complete, host computer  retrieves the acquired data, in addition to various diagnostics and responses, which were recorded during execution of the event sequence. Therefore, host computer  is involved in pre- and post-processing roles and is entirely relieved of the burden of real-time operation.","The Event Graph",{"@attributes":{"id":"p-0389","num":"0396"},"figref":"FIG. 49","b":["650","650","650","304","0","304","1","2","3","3","4","5","6","7","8"]},"During execution of the sequence shown in , two frames of data are acquired. These frames are transferred directly to computer RAM . In addition, commands sent to detector framing node  to initiate the readout each result in an acknowledgment being returned from detector framing node . This acknowledgment is recorded for each event and stored in computer RAM  in the response log buffer  (set forth in greater detail below). All of this information along with pointers to the frame data in computer RAM  are passed to the top level computer application immediately following completion of the event sequence. The sequence is repeated again by sending another begin sequence command to detector framing node  over computer communication bus .","Standard Event Set","The Standard Event Set for the firmware of detector framing node  contains a minimal number of event instructions to support features of imaging system . These event instructions are grouped roughly by functionality. Each event instruction includes a single Op-Code byte specifying the event, followed by the argument bytes to be used when applicable. All op-code words are one byte long and their arguments are multiple bytes long as indicated. Op-code and argument bytes are packed for optimum utilization of the EAB memory  on detector framing node  in EP . Diagrams illustrating the format of control and data words for each event are set forth below. The diagrams show the exact byte order of data in EAB memory  beginning with the op-code. Multi-byte words show the byte ordering with \u201c(0)\u201d being the most significant byte.",{"@attributes":{"id":"p-0393","num":"0400"},"figref":"FIG. 50","b":["660","474"]},{"@attributes":{"id":"p-0394","num":"0401"},"figref":"FIG. 51","b":["670","1","2","304","737","114","670"],"ul":{"@attributes":{"id":"ul0005","list-style":"none"},"li":{"@attributes":{"id":"ul0005-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0006","list-style":"none"},"li":"Send(0x2001, 1x2);"}}}},"The above example has the format Send(\u201ccommand\u201d, \u201cargument\u201d) such that different numbers may be used. In this example, a DFN Signature Request command is sent to detector control board  in image detection system . The reply from detector control board  is recorded in the response log , and has the exemplary form:s\n\n","As set forth above, ACK=\u201ccommand\u201d and ACK=\u201csignature\u201d. The detector control board  responds with a signature indicating that it is running Cardiac H20 firmware. The send event  is used to send a Store Scan Setup Parameters command to detector control board . In this case S will have the format of the command, \u201c0x00004020\u201d and S will be the 32 bit parameter word to be stored. The send event  is also used for the Read Temperature command. In this case, S is \u201c0x00004100\u201d and S has no effect. After processing this command, detector control board  replies with an acknowledge having two 32 bit words, which are recorded in the response log . The first of these is a copy of the original S word unless the command was not recognized in which case it would be \u201c0x0000FFFF.\u201d The second word will be the requested temperature. Send is executed in a single 2 \u03bcsec tick of the Event Sequence clock. A FC timeout is set with a user programmed register on the card. If this timeout is exceeded without a reply from the device, an error is generated. The timeout for return of Fiber Channel ACKs is set in 28 nsec increments with a timeout of 1024*28 nsec=28.672 msec. The timeout is set to a nominal value (e.g. 256 counts) by the DFN driver. Fiber Channel error conditions are detected by detector framing node  and passed on to host computer  using a PCI interrupt. They are also recorded in response log . The send event  has a time-out on its execution. The return information is monitored by detector framing node  to determine whether the information has been received and processed correctly.",{"@attributes":{"id":"p-0397","num":"0407"},"figref":"FIG. 52","b":"672"},{"@attributes":{"id":"p-0398","num":"0408"},"figref":"FIG. 53","b":"680","ul":{"@attributes":{"id":"ul0009","list-style":"none"},"li":{"@attributes":{"id":"ul0009-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0010","list-style":"none"},"li":"Delay(16500);"}}}},"In the Perl script, the argument to this event instruction is provided in ticks of the 2 \u03bcsec event clock. Therefore the above example measures out a delay of 33 msec which is the frame time for a cardiac image. The Delay event is useful for generating the delay between successive readouts of detector control board . This delay would then constitute part of the entire frame time for the given frame with the remainder of the delay being taken up by the readout operation. This event instruction is also used to account for the delay due to readout of the image data. The Delay T event  is used to insert a delay between the beginning of a light frame and the point at which radiation generation system  is turned on.",{"@attributes":{"id":"p-0400","num":"0411"},"figref":"FIG. 54","b":"684","ul":{"@attributes":{"id":"ul0011","list-style":"none"},"li":{"@attributes":{"id":"ul0011-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0012","list-style":"none"},"li":["Send(0x007000, 0x1);","Delay(16500);","LoopKN(2, 20);"]}}}},"In this example, detector framing node  is read 22 times at a frame rate of 33 msec per frame. This is accomplished by sending the above image request command, e.g. Send(\u201cimage request\u201d), followed by a delay of 16500 2  sec counts, and a LoopKN statement. In the Perl file, the jump distance \u201cK\u201d is provided in terms of number of event instructions, whereas in the binary event compiler output COFF file, the jump distance \u201cK\u201d is specified in terms of actual bytes. The compiler takes care of performing the mapping between these two ways of specifying the event instruction. The Loop KN event is useful for taking a prescribed number of data frames from detector framing node . The loop KN event can encompass a section of the event sequence which includes both dark and light frames. In this way a long series of images may be captured using a relatively short sequence of event instructions.",{"@attributes":{"id":"p-0402","num":"0416"},"figref":["FIG. 55","FIG. 686"],"b":["686","474"],"ul":{"@attributes":{"id":"ul0013","list-style":"none"},"li":{"@attributes":{"id":"ul0013-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0014","list-style":"none"},"li":["Send(\u201cimage request\u201d);","Delay(16500);","LoopKF(2, 0xAAFF01);"]}}}},"In this example, detector framing node  is read indefinitely at a frame rate of 33 msec per frame until a Host Flag is received from the user application (see Wait F for Flag definition). This is accomplished by sending the image request command (\u201cimage request\u201d), followed by a delay of 16500 2 \u03bcsec counts, and a LoopKF statement. In the Perl file, the jump distance \u201cK\u201d is provided in terms of number of event instructions, whereas in the binary event compiler output COFF file, the jump distance \u201cK\u201d is specified in terms of actual bytes. The compiler takes care of performing the mapping between these two ways of specifying the event. The Loop KF event  is used to synchronize the Event queue to an external input for acquisition of a light frame. A sequence of event instructions incorporating a scrub frame are placed in the Loop KF loop with the event waiting for the flag F from the real time bus . Once radiation generation system  is ready, the real time bus  changes state to F, which causes the Event queue to leave the Loop KF loop and proceed on to the next event which is a data frame. Together, the X-ray On and data frame realize a light frame, which is in lock step with the previous detector scrub operations. The Loop KF event is used to generate an infinite loop for debugging of detector operation. The loops are made sensitive to a flag from host computer  indicating that execution is completed.",{"@attributes":{"id":"p-0404","num":"0421"},"figref":["FIG. 56","FIG. 56"],"b":["694","694","474","694","0","379","379","114"],"ul":{"@attributes":{"id":"ul0015","list-style":"none"},"li":{"@attributes":{"id":"ul0015-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0016","list-style":"none"},"li":"Wait(0x0A0F01);"}}}},"In this example, execution is paused at the Wait statement until the pattern \u201cXA\u201d is received from the computer application. In this case, because the MASK is \u201c0F,\u201d the lower nibble of bits of the incoming Host Flag will be tested. In the case of mammography, the operator holds down both a \u201cPrepa\u201d and a \u201cGraphe\u201d button in radiation generation system  to initiate an x-ray exposure, with Graphe actually applying voltage to the x-ray tube. A Wait F event in the X queue is optionally made to look for a signal indicating that the Graphe button on the operator console has been pressed. The Graphe button is interfaced using the real time bus  and is represented by a single bit which is tested against for state effectively corresponding to a flag. Once this flag is received, executions would move on to the next event instruction, which would be a Flag F command to radiation generation system  calling for radiation generation system  to be turned on. The Wait F event is used to synchronize the Event queue operation to host computer . A Wait F event is used to stop execution until the host computer  signals that it is ready to proceed. For example, using a Wait F in an image loop, an operator optionally steps through a series of precisely timed image acquisitions with a keyboard press on host computer  used to tell host computer  to proceed to the next frame in the sequence. After each keyboard key press, host computer  signals the event queue in EAB memory  with Flfag F.",{"@attributes":{"id":"p-0406","num":"0424"},"figref":["FIG. 57","FIG. 57"],"b":["696","474","379","114","379","114"],"ul":{"@attributes":{"id":"ul0017","list-style":"none"},"li":{"@attributes":{"id":"ul0017-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0018","list-style":"none"},"li":"Flag(0xB1F100);"}}}},"In this example, a real time bus flag (TYPE=\u201c00\u201d) is generated. Since the MASK is \u201cF1\u201d the upper four bits are all changed to the state specified \u201cB\u201d, while of the lower four bits, the least significant bit is changed. The Flag F event is used to generate the X-Ray on signal for turning on radiation generation system . This is done by selecting the appropriate bit on the real time bus  and then setting it to the desired level. This bit can later be cleared using another Flag F event. The Flag F event is used for computer-synchronized image acquisition to generate a flag to host computer  indicating that the Graphe button has been detected by a previous Wait F event. Host computer  optionally uses this information to signal image acquisition status.",{"@attributes":{"id":"p-0408","num":"0427"},"figref":"FIG. 58","b":["697","304","114","697"]},"Examples of typical event sequences, which may be implemented, are set forth below. They are intended to demonstrate the flexibility of the architecture proposed herein. Each example includes an event graph illustrating the sequence execution in time. The graph is accompanied by a representation of the Event queue for the sequence.",{"@attributes":{"id":"p-0410","num":"0429"},"figref":"FIG. 59","b":["698","109","379"]},{"@attributes":{"id":"p-0411","num":"0430"},"figref":"FIG. 60","b":["700","114","302","304","1","0","2","1","2","2","1","1","379"]},"The next group of events in the sequence initiate the offset or dark frame acquisition and then provide the synchronization between the start of the light frame and the start of the x-ray exposure. These events correspond to E-E. E is a Send event which sends an Image Request to detector framing node . Note that the readout delay for the image request is accounted for using the Delay event E. Once E completes execution, data has been stored locally on the DFN in a frame buffer. The completed acquisition triggers direct memory access of this frame buffer to host computer  over computer communication bus . X-ray exposure is phased relative to the start of the light frame; E provides this time delay. Following the delay, E sends the X-ray On signal by changing the value of the flag RT corresponding to the X-ray On signal on the real time bus  to radiation generation system . As mentioned previously, the current mammography test system does not have the facility for setting the duration of the X-ray On time. Therefore, this X-ray On signal tells the radiation generation system  when to begin exposure, and X-ray Off is not used. The sequence ends when E terminates the queue. The EndQ event moves DFN from Run mode back to Normal mode to idle and scrub the panel.",{"@attributes":{"id":"p-0413","num":"0432"},"figref":"FIG. 61","b":"702"},{"@attributes":{"id":"p-0414","num":"0433"},"figref":"FIG. 62","b":["704","114","302"]},"At the start of the sequence, the WaitF event E pauses sequence execution until a heart beat is detected on real time bus inputs (RT). When the beat arrives, detector framing node  is scrubbed once (E-E) to begin the panel integration time. The x-ray is then turned on at E. Assuming that the generator turns off automatically after 10 ms, E waits for this period to complete. E-E complete the integration period and readout detector framing node . The entire construct of E-E is looped using E which waits for Host Flag HF from the computer application telling the sequence to exit with the EndQ, E.","The sequence runs continuously and synchronizes with the heart beat until computer application tells it to exit. Alternately with two layers of nested looping it would be possible to scrub the panel at a set rate until the heart beat was detected. One loop would scrub the panel, and the second loop would repeat the entire construct (scrubbing+single image acquire) until the computer application signaled done.","DFN Autoscrub Feature",{"@attributes":{"id":"p-0418","num":"0437"},"figref":"FIG. 63","b":["706","304"]},"Detector Equilibrium","The image detection system  is scanned at a constant rate while images are not being acquired in order to prevent degradation in image quality or damage to flat panel detector . Detector controlled firmware, i.e. firmware controlled by detector control board , is designed to enter an autoscrub mode when sitting idle for a long period of time. In typical operation however, flat panel detector  is scrubbed continuously when images are not being acquired. For this reason, detector framing node  is designed to scrub flat panel detector  while in Normal mode if the user turns on this feature.","Timing Transitions","In order to prevent image artifacts from occurring, a seamless transition is provided from a detector framing node idle state to image acquisition. A detector framing node autoscrub feature scrubs detector framing node  at the user set rate until a BeginSequence request is received. To maintain strict timing, the Event Queue waits until the frame time for the last scrub completes before beginning execution of the event sequence. Therefore, a perfect transition occurs if the first event in the queue is either a detector scrub or an image request. On termination of the event sequence, the event queue immediately begins autoscrub by sending a detector scrub command when the EndQ is encountered. Therefore, a perfect transition on termination occurs, if the last two events in the queue (excepting the EndQ) are a scrub (or image request) followed by a delay time which is identical to the programmed delay in the DFN autoscrub frame time register.","Configuration and Use","Bus Driver Configuration","Real time bus  is bi-directional. Control of the direction of each channel on the bus is accessible to the user using the DFNSetRTBDirection( ) DLL function call (set forth in greater detail below). On power-up, all real time bus channels start out as inputs. Even though the Event Sequence may drive a channel high, in reality, the channel will continue to be in a high-impedance state until its driver is turned on by the user application. Therefore, the direction of all real time bus channels are set prior to the beginning of the event sequence.","Setting the Default State","Detector framing node  maintains a default state for the real time bus drivers. This feature is designed to return the bus to a \u201csafe\u201d condition in the event that a system error occurs. The default state is also set using the DFNSetRTBDirection( ) DLL function call (set forth below). The user application sets the value of the default state prior to the beginning of the event sequence.","Queue Variables\u2014Real-time Sequence Control","Queue Variables provide communication between the computer application and the Event Sequence. They are used to change parameters on the fly and can also be used to setup a generic frame template before beginning an image sequence. This second application removes the requirement for repeated compilation of Perl scripts when changing parameters such as frame time or Common Electrode Voltage between acquisitions.","Queue variables act as ASCII \u201ckeys\u201d identifying numbers in the Perl script which are changed by the user application. The user application uses DLL function calls to pass values for the given keys down to detector framing node . These values are written to an area in EAB memory  which is separate from the event instructions themselves and is referred to as \u201cQueue Variable Space\u201d. When the Event Queue reaches an instruction in the queue which has a Queue Variable in its argument, the queue reads an address which points it to the current value of the Queue Variable in Queue Variable space. The Queue then processes the instruction using the current value of the Queue Variable. The user program can change this value at any time before or during Queue execution since detector framing node  prevents the Queue from reading Queue Variable values while they are being written. When a Queue Variable is changed by host computer , the value of the Queue Variable is updated immediately in EAB memory , however the effect of this updated value appears when the particular event instruction, which uses the particular Queue Variable, is reached by the Event Queue.","Queue Variables\u2014Real-time Sequence Control","Queue variables provide communication between a host application and an event sequence. Queue variables are optionally used to change parameters on the fly, such as during image acquisition, and are optionally used to setup a generic frame template before beginning an image sequence. The use of a generic template removes the requirement for repeated compilation of Perl scripts when changing parameters such as frame time or Common Electrode Voltage between acquisitions.","Queue variables act as ASCII \u201ckeys\u201d identifying numbers in the Perl script which can be changed by the user application. The user application uses DLL function calls to pass updated values for given keys down to DFN . These values are written to an area in EAB memory , which is separate from the Event instructions, and is referred to as \u201cQueue Variable Space.\u201d When the Event Queue reaches an instruction in the queue having a Queue Variable in its argument, the queue reads an address, which points to the current value of the Queue Variable in Queue Variable space. The Queue then processes the instruction using the current value of the Queue Variable. The user program optionally changes this value at any time before or during Queue execution. Conflicts are avoided since DFN  prevents the Queue from reading Queue Variable values while they are being written. When a Queue Variable is changed by the host, the variable value in EAB memory  is updated immediately, however the effect of this updated value appears when the event instruction, which uses the particular Queue Variable, is reached by the Event Queue.","Perl Script Queue Variables Scope, Definition and Use","All arguments to event instructions defined in a Standard Event set (with exception of loop jump distance K) are optionally parameterized using Queue Variables. For example, a Queue variable is optionally defined for the N value of a LoopKN event. Thus, the user application may optionally change the number of repetitions in a frame sequence without recompiling the respective COFF file. By defining a Queue Variable for the Send event, the user optionally parameterizes all detector parameters, since these are set using detector commands initiated by the Send event. Similarly, frame time can be parameterized by defining a Queue variable for the Delay event in a frame.","Defining and Using Queue Variables","In the Perl script, Queue variables are defined in the preamble to frames as well as at the top level of the hierarchy. They are given a default value, which is the value that will be loaded into their memory location when the COFF file is written to EAB memory . The default value can be defined either at the frame level or at the hierarchy level for additional flexibility.",{"@attributes":{"id":"p-0438","num":"0457"},"figref":["FIG. 64","FIG. 65"]},"Using Queue Variables in User Application","In order for the user application to update the values of Queue Variables on DFN , the user application needs a reference to the Queue Variable location in EAB memory . This reference is provided in the form of an ASCII key, which is the same as the name of the Queue Variable as it is defined in the Perl script. A table mapping the ASCII keys to their respective memory locations in DFN memory is stored in the COFF file upon compilation. This table is called the Queue Variable Symbol Table, and is passed to the DLL when the COFF file is read. The DLL uses this table to look up memory locations when provided with ASCII keys for Queue Variables.","Changing a Queue Variable Using DFNChangeQueueVariable( )",{"@attributes":{"id":"p-0442","num":"0461"},"figref":["FIG. 66","FIG. 66"]},"Queue Variables correspond to the arguments of event instructions, and since these have different sizes depending on the type of event, the user specifies the number of bytes to be written using Bufsize.","Integrated Queue Variables Example","When using Queue Variables, the source code of both the user application and the Event Sequence are planned together so that the system functions as an integrated whole.",{"@attributes":{"id":"p-0446","num":"0465"},"figref":"FIG. 67"},{"@attributes":{"id":"p-0447","num":"0466"},"figref":"FIG. 68","b":"2"},"Since the user application and the event sequence run asynchronously with respect to each other, the exact moment that the queue variable is changed is unknown. The exact moment when the value is used, however, is precisely defined because this is the point when the Delay instruction is next evaluated. If the queue variable change is to be synchronized with the event queue execution, this can be accomplished using host flags. The event queue optionally notifies the user application a short time in advance of the point where the variable needs to be updated so that the host will have enough time to make the change.","On the host application side, the host begins by starting a HF.bin coff file running. This file contains the compiled code for frame_type. In the simplified example of , the host application then proceeds to update the queue variable with a value for the delay. Alternatively, the user application waits for a host flag to tell that the sequence has begun running. The user application then polls the keyboard or takes input from a GUI telling it whether the particular variable should be incremented or decremented based on an operator request at the time.","Alternately, the user application takes input from the user prior to running the sequence and updates the queue variable right before issuing the BeginSequence. This is useful, for example, when running a series of tests in which the format of the acquisition is the same but the frame time changed each time the test is run. Using queue variables in this case allows the user application to make changes to the frame time without having to recompile the COFF file.","For complex testing using a C++ program to generate sophisticated variations in acquisition parameters, the user application optionally runs repeatedly synchronized with the event queue. Each time through the loop on the user application side various acquisition parameters are updated. For example, the frame time is optionally varied from 20 msec to 100 msec in 100 \u03bcsec increments, while after each set of frames, the average pixel level is calculated and used to set the Common Electrode voltage for the next image or image group. On the Event Queue side, after each image or group of images, the queue then notifies the host that it was done and waits until the host is ready for the next image acquisition before continuing. When the acquisition is completed, the host then aborts the sequence to exit the loop.","Image Acquisition","A performance goal of image acquisition is to acquire and display images in real-time. For 1k\u00d71k cardiac\/surgical digital x-ray images, acquisition and display rate is 30 frames per second. However, for recorded images, a different rate is optionally used. A display rate of 30 frames per second displays a flicker with a 60 MHz PC. Typically, a review work station will run at 70 MHz. This avoids vertical blanking of the display. For 2k\u00d72k fluoro-radiography digital x-ray images, the acquisition and display rate is 7.5 frames per second. The acquisition and display rate for other image sizes (regions of interest) or other panels may be different.","The choice of operating system influences design of system architecture. The more involved the operating system is in the acquisition of an image the more likely the operating system is to drop an image. Failing to display a small number of frames in a 30 frame per second sequence could go unnoticed. A similar failure at the 7.5 frame per second fluoro-radiography rate would be more noticeable (particularly with a moving phantom), but would be acceptable.","The acquisition process minimizes the involvement of host computer . The available memory is partitioned into a section managed by the operating system and a second section is managed independently of the operating system. Logistically, an option is applied to the boot configuration (boot.ini) that limits the operating system to the lower 256 MBytes (TBD) of physical memory.","The driver for DFN  manages the physical memory above this boundary. At the start of an acquisition, the driver divides the available physical memory into 2 MByte blocks. However, for radiography digital x-ray, multiple 2 MByte blocks are used to make a single image. A list of physical addresses is passed by the DFN driver to the acquisition card. As each image arrives, DFN  copies the image to the next physical address on this list and interrupts host computer . At some time host computer  services this interrupt. An unlikely scenario would be for DFN  to copy an image and interrupt host computer  more than once before host computer  serviced the interrupt. Host computer  can detect this situation because DFN  has a register that allows host computer  to determine how many images have been transferred.","The device driver for DFN  maintains a list of available image buffers. Each time the computer application is ready to process an image, the driver passes an image address to the computer application. The WINDOWS NT\u00ae operating system provides services that allow the driver to map these image buffers outside of the region managed by the operating system. The driver has an option that will let it reuse these buffers after host computer  has displayed their contents. If the computer application determines that it is not keeping up with the input image stream, it can programmatically skip the display of one or more image buffers.",{"@attributes":{"id":"p-0458","num":"0477"},"figref":"FIG. 70","b":["304","334","114","362","114","338"]},"In continuous display mode, an application has allocated some number, \u201cN,\u201d image buffers in DFN memory unit . At any given time the last \u201cN\u201d images are saved in these buffers. If the computer application programmatically skips one or more of these last \u201cN\u201d images, the image data is still available. The other possible operating mode is that the computer application acquire \u201cN\u201d images. In either scenario none of the \u201cN\u201d images that the computer application wanted to keep has been lost, even if the application did not display the image. These buffers are not mapped. There are unavoidable latencies in any data acquisition system. DFN  has 10 MBytes of buffer memory to help absorb latency. Buffering, together with careful system design minimizes the possibility of dropped frames.","There are a number of advantages to this image acquisition strategy: host computer  is not directly tied to acquisition of individual frames. The image buffers are physically contiguous such that DFN  does not manage multiple memory extents. An extent is a physically contiguous block of memory. A 2 MByte cardiac image therefore has 512 memory pages, with a page being 4096 Bytes on PENTIUM\u00ae class processors. There can be as many as 512 extents in this image if no two memory pages are physically contiguous.","The computer application does not address the operation of paging individual memory pages by the operating system from an image. This paging activity affects the time used to process individual images. Image files can be quite large. According to an operative embodiment wherein the operating system is WINDOWS NT\u00ae, a 2 GByte virtual address space is provided. According to an alternative embodiment, WINDOWS NT SERVER, ENTERPRISE EDITION\u00ae, has a 3 GByte virtual address space. During operation, a few images are included in virtual address space at any given time.","According to an operative embodiment, a WINDOWS NT\u00ae driver directly manages DMA. In this case, a computer application passes the virtual address of a buffer to the driver. The driver locks the individual pages of this buffer in memory and builds a list of physical addresses. The resulting list is similar to a scatter-gather list. The operating system provides routines to perform DMA using the list of physical addresses that the driver has created. In this case, host computer  initiates DMA rather than initiation by DFN . This approach is also not preferred because the computer application contends with paging of the image buffers and all the image buffers are subject to the limitation on available virtual address space. Host computer  is involved in each DMA. Buffering on DFN  permits latency caused by host computer . If host processor  is too busy to respond to a DMA done interrupt, it is not going to be able to perform the image processing and display. This technique is optionally used to manage image acquisition.","The action of detector framing node  for image transfer removes host processor  from image acquisitions. With detector framing node , hard-real time requirements are satisfied, such as capturing every image in a sequence, without requiring use of a real-time operating system. Detector framing node  does not perform scatter-gather DMA because the physical address of each buffer is aligned on a host memory page boundary and because each buffer is physically contiguous.","Conventional systems request one or more images from an image acquisition system. Typically, each request is for a single image, but an application may have multiple requests outstanding. Limitations of the host operating system normally prevent an application from queuing requests for an entire sequence. Modern high performance devices, like those used for image acquisition, traditionally use DMA to transfer data to or from host memory. DMA is a relatively complicated procedure to set up. Host processor  becomes involved at several different times to complete the transfer request. The traditional host operating system processes each transfer request individually. If the operating system supports virtual memory, the operating system makes sure that none of the memory pages in the target address range get swapped to disk while the transfer is pending. Different operating systems describe this operation in distinct fashions. Under embodiments of WINDOWS NT\u00ae and WINDOWS 2000\u00ae, pages are optionally locked. There is also an additional probe operation to guarantee that the target pages are accessible. Other operating systems perform similar tests. Neglecting this detail creates security problems and the use of a probe and lock operation is relatively expensive.","A device driver that functions as an extension of an operating system is responsible for communicating with the image acquisition hardware. The operating system normally probes and locks pages before passing the request to the driver. Alternatively, the driver performs the above bookkeeping when the driver receives a transfer request. The embodiment of WINDOWS NT\u00ae supports both techniques. The device driver then allocates resources needed to set up DMA.","Applications typically work with virtual memory addresses. These addresses require access to a memory management unit (\u201cMMU\u201d) of a host processor. The use of the MMU is not available during DMA. However, the device that controls the transfers works with physical addresses. Even though the target addresses are virtually contiguous, they are not physically contiguous. In fact the physical addresses may be very fragmented. Each range of these fragmented physical addresses is called a \u201cmemory extent\u201d or simply \u201cextent.\u201d The driver passes a list of extents to the acquisition device. The list of extents frequently consumes a number of very limited resources. Thus, the driver may not be able to describe the entire image transfer in a single request. Furthermore, the DMA hardware interrupts the host processor each time a transfer having one or more extents has completed.","In the best case scenario using conventional memory management techniques, the host processor is involved in initiating the transfer and in completing the transfer. It is common that the code that completes the transfer actually initiates the next request. The host processor is involved once per transfer. In the worst case scenario, the transfer is split into a number of requests due to resource limitations. Non-real time operating systems cannot bound the interrupt latency (the time used to respond to an interrupt). If the host processor running a non-real time operating system responds too slowly to an interrupt, it will loose image data.","Detector framing node  completely removes host processor  from the acquisition scenario. Prior to beginning image acquisition, the device driver on host processor  passes a list of physical addresses to detector framing node . These addresses are outside of the memory that the host operating system manages. Each address in this list describes a reasonably large physically contiguous block of memory (e.g. enough to hold an entire image). The detector framing node  treats this address list as a circular queue. When an image becomes available, detector framing node  removes an address and initiates DMA to host computer . When the transfer completes, the detector framing node  sends an interrupt to host processor . Host processor  does not have to respond to this interrupt in a fixed time window.","When the next image is available, the detector framing node removes the next address from the address list and initiates another DMA, even if host processor  has not responded to the first interrupt. Because the interrupt request remains asserted until host processor  services the interrupt, the second transfer will not cause a second interrupt. Detector framing node  maintains state information such that the device driver on host processor  determines how many images have been transferred. The list of physical memory addresses that the device driver passes to detector framing node  has N entries. The device driver requests that the detector framing node  stop after acquiring N images, or the device driver optionally requests the detector framing node  to acquire images continuously. In the latter case, the last N images are saved on the host computer  (assuming that N or more images are acquired).","Application software running on host processor  optionally requests successive images. The application can display, archive, or otherwise process the images. If host processor  is not keeping up with the incoming image sequence, host processor  can ignore one or more images. Whether host processor  processes each image or not, images will not be lost outside of a requested save window (i.e., capture and save N images, capture images continuously and save the last N images).","Image Processing","A task based operating system running in imaging system  meets processing requirements to perform offset, gain, and bad pixel correction as well as supporting window-level operations for contrast management. To complete the image processing within the available time, a Pentium class MMX instruction set is utilized. These instructions permit host processor  to operate on four 16-bit values simultaneously. More than four operations may actually be performed at a time because host processor  is super-scalar. Host processor  is capable of issuing two MMX instructions in a single clock. Performance is sustained when host processor  and computer RAM  are integrated such that host processor  can actually can issue two instructions per clock.","Memory is accessed systematically so that most data comes from the cache and host processor  does not wait for a relatively slow memory read to complete. By processing each image in its natural order (i.e. in the order pixels are stored in memory) and observing the recommended 32-byte alignment of all data structures, performance is improved.","Each PENTIUM\u00ae class processor has on chip (L) data cache and on chip instruction cache. In addition to the on chip cache, each PENTIUM\u00ae class processor has a secondary (L) cache. Data and instructions flow from memory to L cache to L cache. Performance is optimized by operating out of L cache and the lesser performance is found operating out of memory.","Processing algorithms are very compact; managing the instruction cache is not significantly involved. The L data cache is 4-way, set associative. The unified L-cache is 4 way, set associative. The lowest five bits of a virtual address specify an offset into a cache line. The next 7 bits of the address specify the cache line. The processor manages the cache ways with a pseudo least-recently-used (algorithm). Each time host processor  fetches a different cache line from memory, host processor  displaces the \u201coldest\u201d of the four candidate lines. Fixed binary arithmetic is used having ten bit integer and 15 bit fraction.",{"@attributes":{"id":"p-0476","num":"0495"},"figref":"FIG. 70","b":"115"},"The high data rates and large volume of data associated with digital imaging makes it difficult to monitor a digital x-ray detector in image detection system  in real-time. However, imaging system  provides a number of monitoring and trace points. These features are useful, as well as flexible and configurable. Capturing a large volume of system diagnostic information degrades system throughput to the point where it is not suitable for its intended application. Failure to provide access to certain data, however, can make diagnosing problems difficult. Further, one cannot predict features and capabilities of different detectors or ways in which one can use existing technology. The problem becomes more difficult if one performs image acquisition on a non real-time computer. As set forth below, monitoring of arbitrary detector functions are provided in a completely configurable manner on a non real-time acquisition computer.","One or more events control x-ray image acquisition. X-ray image acquisition events may produce zero or more digital radioscopic images. Some of events control image detection system , while others control radiation generation system  and synchronize with the external environment. The events are pre-computed and the results are downloaded as resulting byte-code into detector framing node . The detector framing node  controls both radiation generation system  and image detection system . The detector framing node  executes detector and x-ray events on a 2 \u03bcsec clock. Each detector command contains a bit flag designating whether detector framing node  traces the command. Additionally there is a frame parameter register to control generation of this information. Any spontaneous detector acts generate a response log entry.","During image read-out, response log entries include start of image (SOFN1), start of packet (SOFN2), and end of image (SOFN3). Any event queue optionally sends its start time, event name, and argument to response log . A loop command also optionally generates a response log entry for each iteration. DMA completion provides a response log entry that includes a time stamp, an ordinal image number for both the sequence and buffer position, DMA packet size, and the computer memory address of the transfer.","The ability to trace the acquisition at each detector command provides flexibility as set forth below. An engineer enables tracing on a command by command basis and as appropriate for the problem attempting to be solved. In normal operation, tracing is minimized or eliminated to avoid hurting system performance. Each trace is called a response log entry. A response log entry is 32 Bytes in length and includes a time stamp, the two command words sent to the detector framing node , two command acknowledgments received from the detector framing node , an image tag, and acquisition started event.","The resolution of the time stamp is equal to the rate at which DFN  interprets byte code. Host computer  provides DFN  with the physical addresses for two separate PC buffers in computer RAM . Each PC buffer is page aligned, physically contiguous, and an integer multiple of 32 Bytes in length. By making each PC buffer contiguous, computer memory management details are hidden from DFN  and bookkeeping procedures that DFN  performs are greatly simplified. DFN  accesses a selected PC buffer with a simple direct master DMA cycle.","When the one of the two PC buffers is full, DFN  switches to the other buffer and interrupts host processor . The host processor  empties the first selected PC buffer before the second buffer PC fills. The host processor  can configure the size of this selected PC buffer. In normal operation, host processor  will make the selected buffer large enough so that there is very little overhead in servicing response-log buffer-full interrupts. Since the 16 MByte\/sec rate at which the DFN  can fill response log buffers is significantly less than the rate at which the host computer  can copy data from this selected PC buffer, it is very unlikely that host processor  cannot keep up. In the event that DFN  fills up the second PC buffer before host processor  empties the first PC buffer, DFN  stops writing response log entries and generates an error.","Under some circumstances, a computer application might not want to wait for a large response log buffer to fill. In this case, DFN  is able to switch response log buffers on command. Registers on DFN  indicate the amount of data in each PC buffer and indicate the currently active PC buffer. There is a potential race condition that occurs if the computer application requests a buffer switch as DFN  initiates filling a PC buffer. This problem is avoided by ignoring requests to switch when the current response log buffer is empty.",{"@attributes":{"id":"p-0484","num":"0503"},"figref":"FIG. 71","b":["730","314","314","334"]},"As illustrated, interface  includes a plurality of user interfaces , which interfaces with operating system kernel . Operating system kernel  interfaces with device driver , which in turn interfaces with detector framing node . When DFN  receives an image from image detection system , it transfers the data to computer RAM  by DMA. Normally, operating system kernel  controls all memory on host computer . Memory may be fragmented or organized in a way such that performance of DMA operations by DFN  become exceedingly complex. DFN  uses DMA to input an image into a contiguous memory buffer in computer RAM .","To maintain large, contiguous memory buffers that DFN  can use for images, the upper part of computer RAM  is \u201ctaken away\u201d from operating system kernel  by a boot-time parameter called MAXMEM. Memory below MAXMEM is managed by operating system kernel  and memory above MAXMEM is managed by the DFN device driver . For example, in a system with 512 MByte of RAM, MAXMEM may be set to 128 MByte. Addresses from 0-128 MByte are controlled by operating system kernel  and hold the operating system, device drivers (including DFN device driver ), and user programs. Addresses from 128-512 MByte, which operating system kernel  does not manage, are used by the DFN device driver  and the DFN hardware. Registry values help DFN device driver  configure this space.","Organization of Memory Above MAXMEM","The DFN device driver  and DFN  use the space above MAXMEM for three things: 1) response log buffers, 2) a list of physical addresses DFN  will transfer images to during acquisition, and 3) detector images. By its design, DFN  is able to map a section of computer RAM  into its address space. This \u201cshared DFN window\u201d is limited to 2 MByte. DFN  writes response log entries to this space. DFN  also reads a list of physical memory addresses from this space which detector images are transferred to. The list of physical addresses points to buffers which lie above MAXMEM and which are also outside of the 2 MByte shared DFN window.",{"@attributes":{"id":"p-0489","num":"0508"},"figref":"FIG. 72","b":["334","334","734","736"]},"Physical Addresses List","During acquisition, detector images, also called \u201cframes,\u201d are read. Each image goes into a buffer in the \u201cDetector Images\u201d memory range of FIG. . The collection of images is called a \u201csequence\u201d and has a unique identifier. More than one sequence can be in memory at a time, although one can be \u201ccurrent\u201d at a time.","Before acquisition begins, the user tells DFN device driver  to allocate a sequence of some number of frames. DFN device driver  creates a list of addresses, one per frame, in the detector Images area. This list is given to DFN  in the Physical Address List area  of the shared DFN window.",{"@attributes":{"id":"p-0493","num":"0512"},"figref":"FIG. 73","b":["334","304","112","304","334"]},"Converting the physical address to a virtual address suitable for use by a user program, i.e., mapping, consumes WINDOWS NT\u00ae resources called page table entries (\u201cPTEs\u201d). This is a limited resource, which means that a program can use a certain amount before an error occurs. If an unlimited number of simultaneous maps were allowed, DFN device driver  would use all system PTEs and WINDOWS NT\u00ae would crash. To address this, 30 MByte of data is allowed to be mapped at once. This is independent of detector size. So, for cardiac\/surgical digital x-ray, having a 2 MByte image size, 15 images can be mapped at once. For radiography digital x-ray, having an 8 MByte image size, 3 images can be mapped at once. The registry key that controls PTE consumption is PhysicalMemory\/MaximumPageTableEntries. One page table entry is used for each page of memory mapped. A page of memory in WINDOWS NT\u00ae is 4 KByte. Therefore, for 30 MByte of memory, 30 MByte\/4, KByte=7680=0x1E00 PTEs are needed.","The registry setting can be changed to allow for more data to be mapped. However, setting this number too high may crash the system. If the system crashes, the blue screen will show an error condition of \u201cNO MORE PTEs\u201d and this value is manually lowered by changing the registry key. This section deals with the number of images that can be mapped simultaneously. If a user program tries to map too many images at once, DFN device driver  returns an error. The user program then unmaps one or more of its mapped buffers before reissuing a map request. During real-time acquisition, buffers are unmapped in the order they were mapped. This is not true for archive (non-real-time) playback.","If Wrap is disabled for the acquisition, the firmware can transfer up to a set number of buffers. If more images arrive from image detection system , an overwrite error is generated by DFN . If Wrap is enabled for the acquisition, the list of addresses is treated as a circular queue. When a buffer is mapped and then unmapped, DFN device driver  updates a tail pointer to let the firmware know that the user has used the data buffer. The firmware will not overwrite an unused data buffer. If the user code can not map and unmap buffers fast enough, images will arrive faster than they can be consumed, and the firmware will generate an overwrite error. In wrap mode, at most the last \u201cn\u201d buffers will be in memory when acquisition ends, where \u201cn\u201d is the number of frames in the sequence.","Response Log Buffers","DFN  optionally generates response log (\u201cRL\u201d) entries that user programs can use to detect events in image detection system  along with associated timing. The RL entries are stored with image data to give a record of the test and to help interpret image detection system  data. At startup, the DFN device driver  gives the DFN firmware two buffer addresses and a buffer size which will hold RL entries. These buffers lie in the shared DFN window, are each the same size, and are an integral number of RL entries big. An RL entry is 32 Bytes.","During operation, RL entries are written by the firmware into RL buffer A . When the buffer fills up, an interrupt is sent to DFN device driver  and the firmware writes further entries to RL buffer B . DFN device driver  will dispose of the data in buffer A  (based on directions from the user mode program described below) and mark it as empty. When the firmware fills RL buffer B , a buffer full interrupt is sent to DFN device driver  and the firmware flips back to filling RL buffer A. Again, DFN device driver  disposes of the data in buffer B and marks the buffer as empty. DFN device driver  disposes of the data in a full RL buffer and mark it as empty before the firmware fills the alternate buffer and flips back to the full one. If it does not, an overwrite error is generated by the card.","It is up to the user program to handle RL buffers. When the system first boots, the firmware and DFN device driver  are running and RL entries may be occurring. On a buffer full interrupt, DFN device driver  interrupt handler just marks the buffer as empty, effectively throwing away the data.","User programs that want to keep the RL data put DFN device driver  in an \u201cRL save\u201d mode. Then the user program gives DFN device driver  a pointer to a buffer that will get the contents of the full RL buffer. For example, during acquisition, user programs would keep RL data. DFN device driver  knows not to throw a full RL buffer away. The user program issues an RL read request. If a full RL Buffer exists (res. buffer A ), the data is copied from the A buffer into the user buffer and then RL A  is marked as empty. If no full RL buffer exists, the read is marked as pending. Later, when an RL buffer (A) full interrupt occurs, DFN device driver  finds the pending read request. The data of Buffer A is copied into the user buffer and then A  is marked as empty.","If DFN device driver  is in an \u201cRL save\u201d mode and an RL buffer (A) full interrupt occurs with no outstanding user read request, the data is just left in the RL buffer until the user code reads it. If the user code does not try to read RL buffer A before RL buffer B fills up, an overwrite error is generated by the card.","Detector Images","Detector images are written to memory above MAXMEM and also outside the 2 MByte DFN window. The DFN device driver  handles management of this area. Initially, the full region is free. As sequences are allocated, detector-sized buffers are used to hold images. Individual frames or entire sequences can be deleted during playback, which returns the memory to the free list. If a user program tries to allocate a sequence and there is not enough memory, an error is returned by DFN device driver . The user either deletes frames or sequences to free up enough space. If no sequences are allocated, the user either adds more RAM to the system (and increase the PhysicalMemory\/PhysicalMemorySize registry key) or reduces MAXMEM (and decrease the PhysicalMemory\/Maxmem registry key). Reducing MAXMEM will affect WINDOWS NT\u00ae performance. Whenever the registry is modified, the system is rebooted so that DFN device driver  uses the proper values.","Programming DFN ","DFN  controls image detection system  and acquires images from it over the image detection bus  to image detection system . A series of commands can be combined into an Event Queue program that is run by DFN  firmware. These commands are combined into a program called a sequence that is compiled into a common object file format (\u201cCOFF\u201d) file. The COFF file is loaded onto DFN  and a Begin Sequence command is issued to start it running. Several types of data are generated by a COFF file, set forth below.","The main result of a sequence is typically a set of x-ray images from image detection system . The x-ray images are DMA transferred from DFN  to computer RAM  as set forth above. When an image transfer completes, DFN device driver  receives a \u201cDMA-done\u201d interrupt. If the user code has previously issued a map request, the address of this arrived image is returned. The user code can display the image or do calculations on the data. When finished, the user code unmaps the image and asks for the next one. Unmapping an image does not delete it from computer RAM . An image will be destroyed during acquisition if it is overwritten in wrap mode or if a user explicitly deletes it during playback. A user program does not have to map images as they are being acquired. If there are enough frames in the sequence to hold all of the images generated by the COFF file, no errors will occur and the data will be in computer RAM . It can be mapped later during playback.","Response Logs","The DFN firmware generates response log (\u201cRL\u201d) entries during acquisition. RL entries hold information regarding images, DMA operations, the real-time bus, firmware state transitions, and errors. Some classes of RL entries are systematically generated while other classes are selectively turned on and off.","When an RL buffer fills, an \u201cRL-buffer-full\u201d interrupt is sent to DFN device driver . If the user code has previously issued a read request, the contents of the RL buffer are copied to a user memory buffer, which was supplied as an argument to DFN device driver . The user code can store this buffer in a memory list until acquisition completes, write it to disk, or try to parse through it while acquisition is running. The user code then issues another RL read request to wait for the next full RL buffer.","Response log buffers are different from detector images in that they are copied out of the memory above MAXMEM into user space. Images are left in the memory above MAXMEM and are simply mapped into user virtual address space. Therefore, the user is responsible for storing RL buffers or keeping them in memory.","If the user cannot issue RL reads fast enough, an error occurs as described above. It may not be possible to write RL buffers to disk or to parse through them while data is being taken since this may take too much time.","Host Flags","A COFF file may need to notify or synchronize with the user. In this case, host flags are used perform the notification. User programs issue host flag read requests to see these flags. If a host flag has occurred, the host flag is returned on the read request. Otherwise, the read request is left pending until a host flag occurs or until image acquisition completes.","Two different types of host flags are possible: notify and wait. A notify host flag is used to tell a user that an event has happened or a point has been reached in the COFF file. An interrupt is generated and the driver records an 8-bit number associated with the host flag. If a host flag read is pending, this number is returned to the user. Otherwise, the number is stored until a read is issued. No further action is used with a notify host flag.","A wait host flag also tells the user that an event has happened or that a point has been reached in the COFF file, but the event queue is waiting for a response from the user. As with the notify flag, a wait flag generates an interrupt and the driver records an 8-bit number associated with the flag. The number is returned to the user via the host flag read request. The user then replies to the event queue using the same 8-bit number. Wait flags tell the user that some initialization process is finished. The user may, for example, then need to perform an action, such as perform an action on the image detection system  or position a target in some way. The queue does not continue until the user replies with the 8-bit wait host flag pattern. Accordingly, the queue and the user synchronize operations.","Errors","A variety of potential errors can happen during operation of DEN . Broadly, these errors are related to host flags, event queue, response logs, images (including acquisition, storage, and DMA), and fiber channel. More than one of each type of error class can occur at once. For example, if the fiber channel cable is disconnected, a bad receiver data, CRC, and sync loss errors could happen. A single return code is used to inform a user of such error(s). The user then asks the driver for a bitmask that gives a complete (extended) list. Errors of a particular class are returned on calls relating to that class. For example, the user is told that a host flag extended error happened on the Read and Set Host Flags calls to the driver. The software then handles data types and error processing in modular threads.","Acquisition of Data with Radioscopic Imaging System","Referring again to , a user controls imaging system  by writing a computer program, in the C language or equivalent, to control the system and acquire data. The user application loads a binary file, called a common object file format (\u201cCOFF\u201d) file, into the EP EAB memory  using the acquisition DLL  and the DFN device driver . This binary file is created by a software program called event compiler . The binary file is used to generate the event queue. The event queue controls the x-ray generator and the acquisition of data from image detection system  over image detection bus .","Referring to , the event compiler  takes a Perl script as its input. Data from an Excel user interface  can alternatively be used to generate the Perl script with translator . Event simulator  and high resolution display  for event simulator  optionally receive the output from event compiler  for purposes of testing. User API  is a C program that accesses four libraries: 1) acquisition DLL ; 2) display library  3) image process library ; and 4) archive library . All libraries are optionally DLL libraries. Thus, the user application optionally links the libraries and does not recompile when recompiling the application program.","The user acquires images in several modes, which are controlled partly by the event queue (determined by binary file and Perl script ) and partly by the user application program that uses the acquisition DLL , the DFN device driver , and the other libraries. The user can acquire single frames, multiple frames or can acquire frames continuously. This latter mode (called \u201cfluoroscopy\u201d or \u201cwrap\u201d) is optionally used with a cardiac digital x-ray panel, where x-ray generation unit  fires at 30 frames\/sec and data streams to DFN  and computer RAM  continuously. Since computer memory  is limited to, e.g. 1 GByte, computer memory  can hold 500 (16 seconds) of the 2 MByte frames. Hence, in this mode computer memory  is treated as a circular buffer and the last 16 seconds of data is retained in computer memory .","Driver Operating Scenario","By way of example, a user program that tests panels would need to make a series of calls to DFN device driver . This section gives a example of a data acquisition scenario and associated function calls.","1. The user first generates a COFF file that contains a series of commands to be executed on DFN event queue. This file is reused each time an acquisition is done.","2. The DFN  and image detection bus  are reset (IOCTL_DFN_RESET, IOCTL_DFN_RESET_FC).","3. The frame and ROI sizes are read (IOCTL_DFN_GET_ALLOCATION_FRAME_SIZE, IOCTL_DFN_GET_ALLOCATION_ROI_SIZE). If necessary, the frame and desired ROI sizes are set (IOCTL_DFN_SET_ALLOCATION_FRAME_SIZE, IOCTL_DFN_SET_ALLOCATION_ROI_SIZE).","4. The user allocates a sequence with the desired number of frames (IOCTL_DFN_ALLOCATE_IMAGE_BUFFERS).","5. The user makes the allocated sequence the current one (IOCTL_DFN_SET_CURRENT_SEQUENCE).","6. If desired, the user enables wrap mode on the sequence (IOCTL_DFN_SET_SEQUENCE_WRAP).","7. The COFF file is opened using the COFF file library routines.","8. The DFN  is put in NORMAL (or TEST) mode (IOCTL_DFN_SET_MODE).","9. The card is programmed with the COFF file (IOCTL_DFN_PROGRAM_DFN_CARD).","10. The programming can optionally be verified (IOCTL_DFN_VERIFY_DFN_CARD_PROGRAM).","11. The DFN  is told to start COFF file execution (IOCTL_DFN_BEGIN_ACQ_SEQUENCE).","12. Data acquisition has begun at this point.\n\n","14. When a COFF file completes, the original BEGIN_ACQ_SEQUENCE call will return with success. The card is in NORMAL (or TEST) mode.","15. The user can return the card to DIAGNOSTIC mode. The sequence size is read (IOCTL_DFN_QUERY_SEQUENCE_SIZE). Images can be mapped, viewed and\/or archived, and then unmapped nonsequentially now that the system is not in real-time acquisition mode.","16. Unwanted frames can be deleted (IOCTL_DFN_DELETE_FRAME, IOCTL_DFN_IS_FRAME_PRESENT). The sequence can be deleted from memory (IOCTL_DFN_DEALLOCATE_IMAGE_BUFFERS).","The following are function calls which may be made by a computer application to the acquisition DLL  to control detector framing node . Each DLL function call has an associated description.","DFNOpenSystem","Connect to DFN Driver and setup for image acquisition.","DFNCloseSystem","Clean up any loose threads and close the DFN driver connection.","DFNOpenSequence","Open the specified Event Sequence file and allocate image buffers.","DFNCloseSequence","Deallocate image buffers in PC memory.","DFNOpenArchiveSequence","Allocate image buffers but fill PC memory from previous archive.","DFNBeginSequence","Load and run specified Event Sequence COFF file.","DFNBeginSequenceNoMapping","BeginSequence without image mapping.","DFNBeginSequenceNoMappingNoLog","BeginSequence with no response log entries and no buffer maps.","DFNBeginSequenceNoLog","BeginSequence with no response log entries recorded.","DFNWaitForSystemIdle","Block until the end of the currently executing event sequence.","DFNWaitTimeoutForSystemIdle","WaitForSystemIdle until specified timeout has expired.","DFNAbortSequence","Terminate current sequence executing on DFN .","DFNDeleteSequence","Free-up allocated image buffers for the specified sequence.","DFNGetSequenceName","Return ASCII name of the sequence based on sequence ID.","DFNRenameSequence","Change the name of the sequence based on the sequence ID.","DFNGetSequenceLengthAllocated","Return number of image buffers allocated for the given sequence.","DFNGetSequenceLengthAcquired","Return actual number of images acquired for the given sequence.","DFNGetSequenceFrameSize","Return the actual frame size used for the given sequence ID.","DFNGetBeginSequenceTimeStamp","Return date and time when the given sequence was begun.","DFNGetCurrentSequenceID","Return the ID of the sequence currently selected.","DFNFindSequenceID","Return sequence ID corresponding to the ASCII string name.","DFNGetBeginSequenceTime","Return exact time (in seconds) that given sequence was started.","DFNSetArchiveSequenceTime","Set start time for previously archived sequence that is reloaded.","DFNGetExtendedErrorInformation","Returns extended error information for reported driver errors.","DFNHardReset","Unimplemented on DFN .","DFNSoftReset","Perform a state reset on DFN .","DFNDetectorHardwarePresentSpecification","Turn on special driver mode to test DLL without DFN  present.","DFNGetBoardVersionInfo","Return DFN board revision, serial number, and firmware revisions.","DFNGetDriverAndDLLVersions","Return software revision strings for DLL and Driver.","DFNSelfTest","Request that DFN  perform a hardware Built In Self Test.","DFNSendDetectorCommand","Send the specified Fiber Channel command to the detector.","DFNResetFC","Reset the Fiber Channel chip-set directly.","DFNAccessLocalBus","Read or Write to DFN local bus  directly.","DFNGetResponseLogSizeForSequence","Return number of response logs entries for given sequence ID.","DFNGetResponseLogForSequence","Return all response log entries for the given sequence ID.","DFNGetResponseLogSizeForFrame","Return number of response log entries for the given frame.","DFNBeginResponseLogChitchat","Start recording response log entries in Diagnostic Mode.","DFNEndResponseLogChitchat","Stop recording response log entries in Diagnostic Mode.","DFNForceRLBufferFlip","Force driver to return current active RL buffer and switch buffers.","DFNGetResponseLogForFrame","Return all response log entries for the given frame.","DFNGetResponseLogOfRunningSequence","Return specified section of currently active RL buffer.","DFNOpenSequentialPlaybackSequence","Open previously acquired sequence for sequential playback.","DFNOpenRandomPlaybackSequence","Select a sequence for random access using GetSpecificFrame.","DFNGetSpecificFrame","Return specified frame when in Random Playback Mode.","DFNGetNextFrame","Return most recent image and update the frame pointer.","DFNDeleteFrame","Remove specified frame from memory.","DFNIsFramePresent","Return whether or not specified frame exists in memory.","DFNGetFreeFrameCount","Return number of available empty frames in memory.","DFNGetSequenceFrameRange","Return Min. and Max. frame numbers still present in memory.","DFNSetWrapMode","Turn on\/off wrapping of the circular image buffer.","DFNIsWrapModeSet","Check if Wrap mode is on or off.","DFNIsWordSwapModeSet","Returns state of WordSwap bit: 1=words swapped, 0=not swapped.","DFNImageWordSwap","Turn WordSwap on or off for mammography digital x-ray acquisition.","DFNSetROI","Unimplemented on DFN.","DFNGetAllocationROI","Unimplemented on DFN.","DFNGetSequenceROI","Unimplemented on DFN","DFNGetAllocationFrameSize","Return the frame size used to allocate memory for next acquisition.","DFNSetFrameSize","Set the detector frame size for use by the DFN during acquisition.","DFNImageReorder","Turn image reordering on\/off. Applies to radiography digital x-ray panel  and cardiac\/surgical digital x-ray panel .","DFNIsReorderModeSet","Check whether image reorder is turned on or off.","The following are EAB memory  (Event Queue) memory read\/write function calls.","DFNLoadEvents","Download COFF file event instructions to DFN  directly.","DFNGetEventsFromEAB","Return Event Queue data from DFN EAB memory.","DFNGetEABMemSizes","Return the size in bytes of the DFN EAB(Event Queue) memory.","DFNWriteEABMemory","Write to specific address in DFN EAB memory.","DFNReadEABMemory","Read from a specific address in DFN EAB memory.","DFNSetAutoscrubDelay","Set the delay between autoscrub commands in \u03bcsec counts.","DFNGetAutoscrubDelay","Return the currently programmed autoscrub delay from the DFN.","DFNEnableAutoscrub","Turn on DFN-controlled autoscrub function.","DFNDisableAutoscrub","Turn off DFN-controlled autoscrub function.","DFNReadRTBState","Return snapshot of current state of real time bus lines.","DFNSetRTBDirection","Set direction of the real time bus lines independently.","DFNSetRTBLine","Force high or low values onto the real time bus lines independently.","The following are Host Flag Function Calls.","DFNGetNextHostFlag","Wait for next Host Flag from DFN Event Queue.","DFNGetNextHostFlagTimeout","GetNextHostFlag with timeout if Host Flag is not received.","DFNSetWaitTypeHostFlag","Signal DFN  using specified Host Flag.","The following are Queue Variable Function Calls.","DFNChangeQueueVariable","Change queue variable at specified address to specified value.","DFNReadQueueVariable","Returns the current value of queue variable at specified address.","The following are DFN Driver Function Calls.","IOCTL_DFN_GET_EXT_ERROR_INFO","Returns extended error information for DFN errors.","IOCTL_DFN_CLR_EXT_ERROR_INFO","Clears bits in the driver copies of the hardware error registers on DFN .","IOCTL_DFN_BEGIN_RL_CHITCHAT_MODE","Begin recording response log data for asynchronous detector communication.","IOCTL_DFN_END_RL_CHITCHAT_MODE","End recording response log data for asynchronous detector communication. IOCTL_DFN_GET_RL_BUFFER_SIZE","Returns the size in bytes of a response log buffer.","IOCTL_DFN_GET_RESPONSE_LOG","Returns the next available full response log buffer.","IOCTL_DFN_FORCE_RL_BUFFER_FLIP","Causes DFN  to switch its current RL destination buffer.","IOCTL_DFN_GET_RL_CLASS_ENABLE_MASK","Returns the response log class entry mask showing which class(es) are currently reported.","IOCTL_DFN_SET_RL_CLASS_ENABLE_MASK","Modify the response log class entry mask which determines which classes are recorded.","IOCTL_DFN_ABORT_RLREAD_REQUESTS","Clears all response log read requests.","IOCTL_DFN_GET_FRAME_SIZE","Returns the frame size for a sequence.","IOCTL_DFN_GET_ALLOCATION_FRAME_SIZE","Returns the frame size that will be used in the next sequence allocation.","IOCTL_DFN_SET_ALLOCATION_FRAME_SIZE","Sets the frame size for future sequences.","IOCTL_DFN_GET_ROI_SIZE","Returns the ROI size for a sequence.","IOCTL_DFN_GET_ALLOCATION_ROI_SIZE","Returns the ROI size that will be used in the next sequence allocation.","IOCTL_DFN_SET_ALLOCATION_ROI_SIZE","Sets the ROI size for future sequences.","IOCTL_DFN_ALLOCATE_IMAGE_BUFFERS","Attempts creation of an image sequence with specified number of buffers.","IOCTL_DFN_SET_CURRENT_SEQUENCE","Makes the sequence corresponding to the sequence identifier the current sequence.","IOCTL_DFN_DEALLOCATE_IMAGE_BUFFERS","Frees all image buffers and sequence information associated with an allocated sequence.","IOCTL_DFN_SET_IMAGE_REORDER","Forces reordering on a sequence regardless of registry default.","IOCTL_DFN_CLR_IMAGE_REORDER","Forces no reordering on a sequence regardless of registry default.","IOCTL_DFN_QUERY_SEQUENCE_SIZE","Returns number of frames in the sequence and other information of the sequence.","IOCTL_DFN_DELETE_FRAME","Deletes frame specified by the ordinal frame number from the current sequence.","IOCTL_DFN_IS_FRAME_PRESENT","Reports whether specified frame number is present in the current sequence.","IOCTL_DFN_GET_FREE_FRAME_CNT","Returns the number of frames of specified size available in free memory.","IOCTL_DFN_MARK_ARCHIVE_SEQUENCE","Force immediate map request completion when filling a sequence from an archive.","IOCTL_DFN_SET_SEQUENCE_WRAP","Define a sequence to be operable in wrap mode.","IOCTL_DFN_GET_CURRENT_SEQUENCE_ID","Returns the sequence identifier of the current sequence.","IOCTL_DFN_MAP_BUFFER","Returns an address for the image buffer specified in the current sequence.","IOCTL_DFN_UNMAP_BUFFER","Unmaps the specified image buffer in the current sequence.","IOCTL_DFN_DELETE_ALL_SEQUENCES","Deletes all sequences allocated by the driver.","IOCTL_DFN_SET_DETECTOR_WORDSWAP","Forces pixel word swapping on a sequence regardless of the default.","IOCTL_DFN_CLR_DETECTOR_WORDSWAP","Forces no pixel word swapping on a sequence regardless of the default.","IOCTL_DFN_RESET","Resets the DFN board firmware.","IOCTL_DFN_RESET_FC","Resets the Fiber Channel hardware.","IOCTL_DFN_GET_VERSION_INFO","Returns DFN  version and S\/N, as well as firmware revision numbers for EP  and DAP .","IOCTL_DFN_GET_EAB_MEM_SIZES","Returns the size of EAB memory and of the individual queue areas within it.","IOCTL_DFN_WRITE_EAB _MEMORY","Data can be written to EAB memory  with this command.","IOCTL_DFN_READ_EAB_MEMORY","Data can be read from the EAB memory on EP  with this command.","IOCTL_DFN_PROGRAM_DFN_CARD","Programs EAB memory  with code from the user generated COFF file.","IOCTL_DFN_VERIFY_DFN_CARD_PROGRAM","Returns the code in EAB memory  that was programmed previously.","IOCTL_DFN_GET_GEN_DATA_CFG","Returns configuration settings for the Test Image Generator circuit on DFN .","IOCTL_DFN_SET_GEN_DATA_CFG","Sets specified configuration settings for the Test Image Generator on DFN .","IOCTL_DFN_BEGIN_ACQ_SEQUENCE Starts the event queue and begins data acquisition.","IOCTL_DFN_ABORT_SEQUENCE","Stops the currently running DFN acquisition before an EndQ is received.","IOCTL_DFN_SET_AUTOSCRUB_DELAY","Sets the delay between consecutive autoscrub requests in 2 \u03bcsec clock ticks.","IOCTL_DFN_GET_AUTOSCRUB_DELAY","Returns the delay between consecutive autoscrub requests in 2 \u03bcsec clock ticks.","IOCTL_DFN_ENABLE_AUTOSCRUB","Turns on the autoscrub circuit on DFN .","IOCTL_DFN_DISABLE_AUTOSCRUB","Turns off the autoscrub circuit on DFN .","IOCTL_DFN_CONFIG_RTB","Sets the default state and driver direction for the real time bus on DFN .","IOCTL_DFN_READ_RTB","Returns the current state of the real time bus lines including the default and direction settings.","IOCTL_DFN_WRITE_RTB","Writes data to the real time bus  in the State\/Mask format used by the Event Queue.","IOCTL_DFN_GET_MODE","Returns the current state (Normal, Run, Diagnostic) of EP state machine.","IOCTL_DFN_SET_MODE","Sets the current state (Normal, Run, Diagnostic) of EP state machine.","IOCTL_DFN_GET_HOST_FLAGS","Reads host flags from the event queue.","IOCTL_DFN_SET_WAIT_HOST_FLAG","Block while waiting for the specified Host Flag from the event queue.","IOCTL_DFN_CLR_ALL_HOST_FLAGS","Clears any outstanding Host Flags or Host Flag requests.","IOCTL_DFN_ACCESS_LOCAL_BUS","Read or write the DFN local bus is while the card is in Diagnostic mode.","IOCTL_DFN_SEND_DETECTOR_CMD","Send commands directly to the detector while in Diagnostic mode.","IOCTL_DFN_SEND_DFN_CMD","Bypass the driver to Execute a DFN command directly in Diagnostic mode.","IOCTL_DFN_SET_TRACE_LEVEL","Sets the debug trace level which controls printing of trace messages by the kernel debugger.","IOCTL_DFN_GET_TRACE_LEVEL","Returns the debug trace level controlling printing of trace messages by the kernel debugger.","IOCTL_DFN_BUGCHECK","Force a system crash in order to generate a crash dump for analysis.","IOCTL_DFN_SET_BREAK_FLAG","Causes driver checked version to break on entry to every function.","IOCTL_DFN_CLEAR_BREAK_FLAG","Causes driver checked version to NOT break on entry to every function.","IOCTL_DFN_DUMP_HEAP_LIST","Dumps information of free memory heap and sequence memory usage to an output file.","IOCTL_DFN_SET_LEDS","Turns DFN LEDs on or off independently according to the specified state.","IOCTL_DFN_GET_BASE_ADDRESSES","Returns kernel virtual addresses so user application can access DFN memory space directly.","IOCTL_DFN_FREE_BASE_ADDRESSES","Releases the specified kernel virtual addresses.","IOCTL_DFN_DUMP_DFN_MEMORY","Writes a section of DFN memory to a file.","IOCTL_DFN_MAP_PHYS_ADDR","Maps a physical address to a user virtual address; used to access RAM above MAXMEM.","IOCTL_DFN_UNMAP_PHYS_ADDR","Release the specified user virtual address.","IOCTL_DFN_READ_DFN_ADDR","Attempts to read the DFN board at the offset given in the input argument.","IOCTL_DFN_WRITE_DFN_ADDR","Attempts to write a value to the DFN board at the offset given in the input argument.","IOCTL_DFN_GET_FC_LOOPBACK","Returns the state of Fiber Channel loopback; 0=loopback disabled, 1=loopback enabled.","IOCTL_DFN_SET_FC_LOOPBACK","Enables or disables Fiber Channel loopback; 0=loopback disabled, 1=loopback enabled.","As this invention may be embodied in several forms without departing from the spirit or principal characteristics thereof, the present embodiments are therefore illustrative and not restrictive. Those skilled in the art will appreciate that changes may be made to these embodiments without departing from the principles and spirit of the invention. Accordingly, the scope of the invention is defined by the appended claims rather than by the description preceding them, and all changes that fall within the metes and bounds of the claims, or equivalents of such metes and bounds thereof, are therefore intended to be embraced by the claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 32"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 33"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 34"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 35"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 36"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 37"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 38"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 39"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 40"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 41"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 42"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 43"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 44"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 45"},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 46"},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 47"},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 48"},{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 49"},{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 50"},{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 51"},{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 52"},{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 53"},{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 54"},{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 55"},{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 56"},{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 57"},{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 58"},{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIG. 59"},{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 60"},{"@attributes":{"id":"p-0073","num":"0072"},"figref":"FIG. 61"},{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 62"},{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIG. 63"},{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 64"},{"@attributes":{"id":"p-0077","num":"0076"},"figref":"FIG. 65"},{"@attributes":{"id":"p-0078","num":"0077"},"figref":"FIG. 66"},{"@attributes":{"id":"p-0079","num":"0078"},"figref":"FIG. 67"},{"@attributes":{"id":"p-0080","num":"0079"},"figref":"FIG. 68"},{"@attributes":{"id":"p-0081","num":"0080"},"figref":"FIG. 69"},{"@attributes":{"id":"p-0082","num":"0081"},"figref":"FIG. 70"},{"@attributes":{"id":"p-0083","num":"0082"},"figref":"FIG. 71"},{"@attributes":{"id":"p-0084","num":"0083"},"figref":"FIG. 72"},{"@attributes":{"id":"p-0085","num":"0084"},"figref":"FIG. 73"}]},"DETDESC":[{},{}]}
