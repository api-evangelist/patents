---
title: Fast matching for content-based addressing
abstract: Disclosed are systems and methods for efficient matching for content-based addressing wherein the systems and methods may: accept, at a receiver machine, a query; generate, at the receiver machine, a tree structure ordered by one or more fields of the query; analyze, at the receiver machine, a message from the sender machine; search, by the receiver machine, the tree structure using content from one or more fields of the message; determine, by the receiver machine, if the content values of the message match a content value of the query stored in the tree structure; and accept, by the receiver machine, the message if the content value of the message matches one or more content values of the query.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08694536&OS=08694536&RS=08694536
owner: TIBCO Software Inc.
number: 08694536
owner_city: Palo Alto
owner_country: US
publication_date: 20111116
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application relates and claims priority to U.S. Provisional Patent Application No. 61\/414,327 entitled \u201cFast matching for content-based addressing,\u201d filed on Nov. 16, 2010, which is hereby incorporated by reference in its entirety.","The disclosed embodiments relate generally to content-based addressing and, more specifically, relate to processes and systems for efficient matching for content-based addressing in the context of a message-oriented middleware system.","Known content-based addressing allows receivers in a message-oriented middleware system to specify their interests as a query against the content of a message from senders. The content of a message may include a field name, a field type of string, field value, and many other fields. A receiver might specify interest in any messages in which certain fields match certain values. A sender may send a content-based addressed message, and a middleware system may resolve which receivers have specified queries that match the content of the message. Typically, content-based matching, as represented by numerous field types (e.g., integer, float, string, Boolean enumerations, etc.), and in which queries may use wildcards (e.g., an asterisk to match substrings) or regular expressions that are computationally expensive to compute and slow to determine if a match exists. The need has arisen to provide a system and method to perform fast, efficient matching for content-based matching.","Disclosed are systems and methods for efficient matching for content-based addressing. The systems and methods may accept, at a receiver machine, a query, wherein the query comprises one or more fields and one or more values, wherein the one or more fields are associated with a category of content, and wherein the one or more values are associated with a particular type of content. The systems and methods may generate, at the receiver machine, a tree structure ordered by the one or more fields of the query, wherein the tree structure comprises one or more tree nodes and the one or more tree nodes comprise one or more query nodes. The systems and methods may analyze, at the receiver machine, a message from the sender machine, wherein the message comprises a content field associated with a content value. The systems and methods may search, by the receiver machine, the tree structure using the content field of the message. The systems and methods may determine, by the receiver machine, if the content value of the message matches a content value of the query stored in the tree structure. The systems and methods may accept, by the receiver machine, the message if the content value of the message matches one or more content values of the query.","The present disclosure provides several important technical advantages. In certain embodiments, the present disclosure provides limiting the data types and query syntax in content-based addressing, which may result in more highly efficient content-based matching. Furthermore, sorting each query into canonical order allows for fields to be searched in the same order, thereby improving the performance by allowing for one path in the tree for any particular match. Other technical advantages of the present disclosure will be readily apparent to one skilled in the art from the following figures, descriptions, and claims. Moreover, while specific advantages have been enumerated above, various embodiments may include all, some, or none of the enumerated advantages.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 1","FIG. 1"],"b":["100","100","101","103","100","107","100","109","107","100","107","101","103","109","101","103"]},"For purposes of example and explanation, the present disclosure describes the type of ordering as canonical, but any appropriate type of ordering may be used to achieve the results of the present disclosure. The queries may be sorted in numerical order, reverse numerical order, alphabetical order, reverse alphabetical order, or any other ordering system that may allow for fields to be searched in the same order.","Sender machine  may include a message application  for generating a message with certain content to be sent to message-based middleware server . Message-based middleware server  may evaluate the content-based addressing to determine whether to send the message to receiver machine . Message application  may include a message processing engine  for processing content-based addressing data, content, fields, and formatting information for a message to be sent to receiver machine . Message application  may also include an application programming interface (\u201cAPI\u201d)  as an interface for message-based middleware server .","While illustrated as a single sender machine  in , system  may comprise more than one sender machine  in communication with message-based middleware server  or receiver machine . Although described as sender machine  in , sender machine  may receive and process queries in some embodiments.","Receiver machine  may include a query application  for generating a query to be sent to message-based middleware  for matching against messages sent by sender machine . A query may be a request originating from query application  such as, by way of example, a request to return all content-based addressing messages that include a field A with a value of 1 and a field of B with a value of 4. Query application  may further include a query processing engine  for processing query information, data, fields, and formatting information for a given query or set of queries. Using format limitations for the incoming messages and queries, a tree structure may be built from the queries, and then matched against incoming data in an efficient manner. Query processing engine  may add or remove queries at any time. The tree structure may be modified to reflect this and incoming message may be matched against the modified tree structure. Query processing engine  may be configured to build a matching tree structure, as described in more detail in . Query processing engine  may also be configured to search for matching field nodes within a matching tree, as described in more detail in . Query application  may also include an application programming interface (\u201cAPI\u201d)  as an interface to message-based middleware server .","While illustrated as a single receiver machine  in , system  may comprise more than one receiver machine  in communication with message-based middleware server  or sender machine . Although described as receiver machine  in , receiver machine  may generate and send messages in some embodiments.","Sender machine  and receiver machine  may be in communication with message-based middleware server  via a network . In an embodiment, message-based middleware server  may also be in communication with format server  via network . Thus, in an embodiment, sender machine  and receiver machine  are in communication with format server  via message-based middleware server . Format server  may communicate format information to sender machine  and receiver machine  and may comprise a format engine  for formatting the format information. Format information includes, but is not limited to, formatting information for content-based addressing data types, operators, fields, query formation information, etc. to enhance highly efficient messaging within the system . Format server  may determine the format rules for each of the fields of each tree node, as described in more detail in , and may format each tree node according to those format rules.","Format server  may also be in communication with a data store element  via network . Format server  may access data, format information, data and operator restriction settings, query formation information, etc. from data store element . Data store element  may also include a format library for storing message format information. In an embodiment, an administrator machine  may be in communication with format server  allowing for an administrator to interact with system  via network .","In an embodiment, sender machine  and receiver machine  may communicate through peer-to-peer (P2P) communications over network . In a P2P configuration, sender machine  may comprise a query-processing router located within sender machine . While only one sender machine  and one receiver machine  are shown, system  may comprise any number of sender machines  and any number of receiver machines  in direct communication with each other over P2P network . Many sender machines  may be in contact with many receiver machines .","Network  may represent any form of communication network supporting circuit-switched, packet-based, and\/or any other suitable type of communications between sender machine , receiver machine , message-based middleware server , format server , and any other elements in . Network  may additionally include any other nodes of system  capable of transmitting and\/or receiving information over a communication network. Although shown in  as a single element, network  may represent one or more separate networks (including all or parts of various different networks) that are separated and serve different respective elements illustrated in . Network  may include routers, hubs, switches, firewalls, content switches, gateways, call controllers, and\/or any other suitable components in any suitable form or arrangement. Network  may include, in whole or in part, one or more secured and\/or encrypted Virtual Private Networks (VPNs) operable to couple one or more network elements together by operating or communicating over elements of a public or external communication network. In general, network  may comprise any combination of public or private communication equipment such as elements of the public switched telephone network (PSTN), a global computer network such as the Internet, a local area network (LAN), a wide area network (WAN), or other appropriate communication equipment. In some embodiments, network  may not be used if all of the components are located on the same machine.","System  may comprise sender machine , receiver machine , message-based middleware server , and format server , each of which may be any suitable computing device comprising a processor and a memory to perform the described functionality. Sender machine , receiver machine , message-based middleware server , and format server  may comprise one or more machines, workstations, laptops, blade servers, server farms, and\/or stand-alone servers. Sender machine , receiver machine , message-based middleware server , and format server  may include any hardware and\/or controlling logic used to communicate information to and from one or more elements illustrated in . For example, sender machine , receiver machine , message-based middleware server , and format server  may be operable to receive and process data of different types that may be transmitted via different protocols or formats. Other elements in  may also comprise hardware and\/or controlling logic to communicate information to and from one or more elements illustrated in .","Memory may store any suitable information. Memory may comprise any collection and arrangement of volatile and\/or non-volatile components suitable for storing data. For example, memory may comprise random access memory (RAM) devices, read only memory (ROM) devices, magnetic storage devices, optical storage devices, and\/or any other suitable data storage devices. In particular embodiments, memory may represent, in part, computer-readable storage media on which computer instructions and\/or logic are encoded. Memory may represent any number of memory components within, local to, and\/or accessible by processor. Processor may represent and\/or include any form of processing component, including general purpose computers, dedicated microprocessors, or other processing devices capable of processing electronic information. Examples of processor include digital signal processors (DSPs), application-specific integrated circuits (ASICs), field-programmable gate arrays (FPGAs), and any other suitable specific or general purpose processors.","Fast Matching for Content-based Addressing","Content-based addressing typically allows receivers in a message-oriented middleware system to specify their interests as a query against the content of a message. For example, a message may include a field named \u201cTicker,\u201d a field type of string, and a field value of \u201cTIBX,\u201d and a receiver might specify interest in any messages in which \u201cTicker=TIBX.\u201d The sender may send the message described above, and the middleware resolves which receivers have specified queries that match the content. Thus, the receiver specifying interest in messages in which \u201cTicker =TIBX\u201d should receive the message described above.","Generalized content-based matching, in which numerous field types (e.g., integer, float, string, Boolean enumerations, etc.) are represented, and in which queries can use wildcards (e.g., an asterisk to match substrings) or regular expressions, are useful but expensive to compute. By limiting the data types and query syntax, more highly efficient content-based matching may be performed.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 2","FIG. 2"],"b":["200","103","133","135","103","135","107","101"]},"In operation, at action , query processing engine  may accept a query from query application  through API . The query may comprise one or more fields and one or more values, wherein the one or more fields are associated with an operand representing a category of content and the one or more values are associated with content.","In order to efficiently match content-based addressing, system  may impose restrictions on queries initiated at receiver machine  to ensure that the queries are properly formatted. For example, the following restrictions are imposed on the data and queries: (1) data fields may only be integers or strings; (2) queries may only use strict equality (e.g., \u201cTicker=TIBX\u201d); (3) queries may only use conjunction (e.g., \u201cTicker=TIBX and Value=32\u201d); and (4) fields may only appear at most once within a data message. In this embodiment, disjunction may be implied by using multiple queries.","At action , system  may generate, at receiver machine , a tree structure ordered by one or more fields of the query, wherein the tree structure comprises one or more tree nodes and the one or more tree nodes comprise one or more query nodes. At action , receiver machine  may receive and analyze a message from sender machine . The message may comprise one or more content fields associated with one or more content values. At action , receiver machine  may search the tree structure using the one or more content fields of the message.","At action , receiver machine  may determine if the content value of the message matches a content value of the query stored in the tree structure. At action , receiver machine  may accept the message from sender machine  if the content value of the message matches one or more content values of the query stored in the tree structure.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 3","FIG. 2"],"b":["300","103","301","301","200"]},"To build a tree, the queries may be processed one-at-a-time, creating tree nodes that contain one or more field nodes, each of which is associated with one or more values. The first query (e.g., A=1) is analyzed at action . For the first query, a linear 1-ary tree is built at action  in which each tree node may represent one operand in the query (and, thus, contains one field node), and the tree nodes are arranged at action  such that the first operand is the root, the last operand is the leaf, and the intermediate operands are arranged from first to last (root to leaf).",{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 4","FIG. 4"],"b":["400","405","405","407","411","413","415","417","419","421"]},"In an embodiment, if a tree node contains queries A=1, A=2, and B=3, then logically separate field nodes for A and B may be present within that tree node. Query A's field node may contain two value entries, 1 and 2, and query B's field node may contain a single value entry, 3. Each field node query value entry (1, 2, and 3 in this example) has an edge pointing at a child tree node.","As depicted in , tree nodes, as represented by the dashed lines, may contain one or more field nodes once other queries are added to the tree. The field nodes, as represented by the solid line and containing an ordered operand (i.e., A, B, C, etc.), may also contain more than one value per field name. The field node combined with the value may together constitute a query node (i.e., A and 1 when the query is \u2018A=1\u2019). To add another query to the tree, the new query's operands are iterated through and existing field nodes may be re-used (adding new value entries as needed) as long as possible. When a tree node does not contain a matching field node, a new field node may be added to continue to build a new sub-tree. Each query node contains logically separate entries for the field name and value, and tree edges may connect the value entry of a query node to leaf (child) tree node.",{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 5","b":["500","135","501","500","503","505","135","507","505","509"]},"If a matching field node does not exist for the current query at decision , then a new field node is added at action  and a new sub-tree is built at action  based on the new field node. If a matching field node does exist for the current query at decision , the current query is set to the next query in the set of queries at action  and the process starts over at action .","As shown in the following figures, and by way of example only, a set of four queries: A=1 and B=4 and C=3; A=2 and C=3; A=1 and C=6; and B=7 and E=2 are processed and the resulting tree is built in four stages by query processing engine . The tree is built one query at a time (stage by stage), starting with the first query A=1 and B=4 and C=3, as interest is expressed by receiver machine .",{"@attributes":{"id":"p-0048","num":"0047"},"figref":["FIG. 6","FIGS. 3 and 4"],"b":["600","600","601","603","605","602","604","606","607","608","609","601","605","603","601","603","605","602","604","606"]},{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 7","FIG. 5","FIG. 7"],"b":["700","600","501","503","505","602","702","507","601","607","702","702","703","705","707","605","603"]},{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 8","FIG. 5","FIG. 8"],"b":["800","600","700","501","503","505","602","603","603","801","604","801","603","604","801","803","603"]},{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 9","FIG. 5","FIG. 9"],"b":["900","600","700","800","501","503","505","901","903","509","511","901","601","601","901","601","905","907","909"]},"Optimizing a Matching Tree Data Structure","In some embodiments, nodes of a matching tree may be augmented with additional data to improve the performance of the matching phase. The augmenting may take place at the time the matching tree is created. A tree node may include a list of fields in field nodes, a hash list of the tree node's leaf (child) nodes, where each child node may be represented as a combination of its field name and field value, and a list of queries that terminate at this tree node. Having this information stored at each tree node allows a matching process to quickly determine whether incoming data matches a query encoded in the tree, and allows the matching to optimize whether the matching tree is matched to the incoming data or the incoming data is matched to the matching tree. Referring back to , the optimal strategy depends on the size and\/or height of the tree and the length of the incoming data, and can be chosen on-the-fly as data is presented for matching by the query processing engine  with query application  on a node-by-node basis. Having a list of queries that terminate at the tree node allows the tree to represent a query that may be prefix of another query. For example, in the tree of , the query A=1 and B=4 and C=3 may be represented in the tree by virtue of the tree root  being marked as a query leaf in addition to its role in the longer query.","Matching Against the Tree","In some embodiments, after query processing engine  has built the matching tree based on receiver machine's  query, query processing engine  may match an incoming data message to a query if any subset of the fields and values in the message match all of the fields and values in the query. Thus, the message \u201cA=1 and B=4 and F=9\u201d is a match for query \u201cA=1 and B=4,\u201d but message \u201cA=1 and B=4\u201d is not a match for query \u201cA=1 and B=4 and G=12\u201d because the \u2018G=12\u2019 query node of the query is unmatched in the message.","To match an incoming data message, query processing engine  may sort the fields of the message in canonical order and the process either iterates through the fields of the message and walks the matching tree from its root, or walks the matching tree from its root and tracks whether an on-going match within the message is found. Like the queries discussed earlier, the messages may be sorted in numerical order, reverse numerical order, alphabetical order, reverse alphabetical order, or any other ordering system that may allow for fields to be searched in the same order as the matching tree comprising the similarly sorted queries. The details of these methods are discussed below.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 10","b":["1000","1001","1000","1000"]},"Process  recursively walks the tree, attempting at each tree node to find a matching field node. Thus, at action , the process may search for a matching field node in the matching tree for the current message field (for the first iteration, the current message field is the first message field). If a matching field node is found at decision , the search may continue recursively with the node's child at action . At action , the process attempts to match the remainder of the message's data fields. If the remainder of the message's data fields is not matched at decision , then a new current message field may be determined at action  and the process may start over at action . If the remainder of the message's data fields are matched at decision , then a match may be declared at action .","If a matching node is not found at decision , then the current message field is not a match and the process  may repeat with a new message field by determining a new current message field at action  and starting the process over at action . If a matching field node is not found the search may continue by eliminating the current message field and continuing with the tail of the message because a query may match a subset of fields in a message (it is not necessary to match all fields).",{"@attributes":{"id":"p-0060","num":"0059"},"figref":["FIG. 11","FIG. 11"],"b":"1100"},"One embodiment not addressed by the simple pseudo-code of findmatch( ) is an instance in which one query is a prefix of another. The tree data structure may be augmented to mark interior tree nodes that constitute the end of a query. For example, in matching tree  from , adding a query A=1 and B=4, which is a prefix of the existing query A=1 and B=4 and C=3, would not cause any structural changes to the matching tree , but the second-level node representing B=4 should be marked as the terminal of a query, even though it is not a leaf.","The pseudo code from  recognizes a match when it reaches a physical tree leaf, but it may be modified to also recognize matches when the process reaches an internally marked terminal.",{"@attributes":{"id":"p-0063","num":"0062"},"figref":["FIG. 12","FIG. 11","FIG. 10"],"b":["1200","1000","1011","1009"]},"Additional modifications to the matching pseudo code may also be included. In an embodiment, the pseudo code includes a routine for reporting a match found (rather than just reporting an absence of a match). In another embodiment, the pseudo code includes a routine to find all query matches for a particular message input.",{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 13","b":["1300","103","1300","1301","1302","1302","1304","1302","1310","1302","1308","1306","1306","1310","1302"]},"In an embodiment, the time to match a field node to a query may be optimized in cases where the field node is associated with multiple values, such as the A field node  in , which is associated with the values ,  of 1 and 2, respectively. To optimize performance, the field node's  name may be matched to a query, and, if there is a match, the message's field name and\/or value combination may be matched to the field node. In other embodiments, this latter comparison may be improved through the use of hashing data structures. When the field node has many associated values, this may be significantly faster than simply comparing each field name\/value from the field node to the message.","Depending on the number of field nodes within a tree node and the number of field\/value pairs in the message (or whatever tail thereof remains), it may be more efficient to use one or the other of the above matching processes. A hybrid process may be used to evaluate a balance at each level of recursion and use the more efficient comparison. Referring back to , query processing engine  within query application  of receiver machine  may perform this decision on a node-by-node basis during message matching evaluation. Alternatively, the decision may be performed over network  and may perform this decision on a node-by-node basis during message matching evaluation.","While various embodiments have been described above, it should be understood that they have been presented by way of example only, and not limitation. Thus, the breadth and scope of a preferred embodiment should not be limited by any of the above described exemplary embodiments, but should be defined only in accordance with the claims and their equivalents for any patent that issues claiming priority from the present provisional patent application.","For example, as referred to herein, a machine or engine may be a virtual machine, computer, node, instance, host, or machine in a networked computing environment. Also as referred to herein, a networked computing environment is a collection of machines connected by communication channels that facilitate communications between machines and allow for machines to share resources. Also as referred to herein, a server is a machine deployed to execute a program operating as a socket listener and may include software instances.","Resources may encompass any types of resources for running instances including hardware (such as servers, clients, mainframe computers, networks, network storage, data sources, memory, central processing unit time, scientific instruments, and other computing devices), as well as software, software licenses, available network services, and other non-hardware resources, or a combination thereof.","A networked computing environment may include, but is not limited to, computing grid systems, distributed computing environments, cloud computing environment, etc. Such networked computing environments include hardware and software infrastructures configured to form a virtual organization comprised of multiple resources which may be in geographically disperse locations.","While communication protocols may be described herein, the coverage of the present application and any patents issuing there from may extend to other local-area network, wide-area network, or other network operating using other communications protocols.","Services and applications are described in this application using those alternative terms. Services can be java services or other instances of operating code. A service\/application is a program running on a machine or a cluster of machines in a networked computing environment. Services may be transportable and may be run on multiple machines and\/or migrated from one machine to another.","Various terms used herein have special meanings within the present technical field. Whether a particular term should be construed as such a \u201cterm of art,\u201d depends on the context in which that term is used. \u201cConnected to,\u201d \u201cin communication with,\u201d or other similar terms should generally be construed broadly to include situations both where communications and connections are direct between referenced elements or through one or more intermediaries between the referenced elements, including through the Internet or some other communicating network. \u201cNetwork,\u201d \u201csystem,\u201d \u201cenvironment,\u201d and other similar terms generally refer to networked computing systems that embody one or more aspects of the present disclosure. These and other terms are to be construed in light of the context in which they are used in the present disclosure and as those terms would be understood by one of ordinary skill in the art would understand those terms in the disclosed context. The above definitions are not exclusive of other meanings that might be imparted to those terms based on the disclosed context.","Words of comparison, measurement, and timing such as \u201cat the time,\u201d \u201cequivalent,\u201d \u201cduring,\u201d \u201ccomplete,\u201d and the like should be understood to mean \u201csubstantially at the time,\u201d \u201csubstantially equivalent,\u201d \u201csubstantially during,\u201d \u201csubstantially complete,\u201d etc., where \u201csubstantially\u201d means that such comparisons, measurements, and timings are practicable to accomplish the implicitly or expressly stated desired result.","Additionally, the section headings herein are provided for consistency with the suggestions under 37 CFR 1.77 or otherwise to provide organizational cues. These headings shall not limit or characterize the invention(s) set out in any claims that may issue from this disclosure. Specifically and by way of example, although the headings refer to a \u201cTechnical Field,\u201d such claims should not be limited by the language chosen under this heading to describe the so-called technical field. Further, a description of a technology in the \u201cBackground\u201d is not to be construed as an admission that technology is prior art to any invention(s) in this disclosure. Neither is the \u201cBrief Summary\u201d to be considered as a characterization of the invention(s) set forth in issued claims. Furthermore, any reference in this disclosure to \u201cinvention\u201d in the singular should not be used to argue that there is only a single point of novelty in this disclosure. Multiple inventions may be set forth according to the limitations of the multiple claims issuing from this disclosure, and such claims accordingly define the invention(s), and their equivalents, that are protected thereby. In all instances, the scope of such claims shall be considered on their own merits in light of this disclosure, but should not be constrained by the headings set forth herein."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 13"}]},"DETDESC":[{},{}]}
