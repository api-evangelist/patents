---
title: Instantiating an interface or abstract class in application code
abstract: Mechanisms for instantiating an interface or abstract class in application code are provided. An object-oriented programming language is extended such that interfaces and abstract classes can be instantiated in application code without a concrete class specified. Metadata is defined which maps each interface or abstract class instantiation in the application code to a concrete class to be used either by the compiler at build time, or the virtual machine at runtime. Once the appropriate concrete class is determined from the metadata, the class is instantiated with a conventional class loader. The metadata may be provided, for example, as a separate file, such as a markup language file, defined with a virtual machine switch, as annotations in the application code, or the like.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08214811&OS=08214811&RS=08214811
owner: International Business Machines Corporation
number: 08214811
owner_city: Armonk
owner_country: US
publication_date: 20061023
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF THE ILLUSTRATIVE EMBODIMENTS"],"p":["1. Technical Field","The present application relates generally to an improved data processing system and method. More specifically, the present application is directed to a system and method for instantiating an interface or abstract class in application code.","2. Description of Related Art","In object-oriented programming, classes are used to group related variables and functions. A class describes a collection of encapsulated instance variables and methods (functions), possibly with implementation of those types together with a constructor function that can be used to create objects of the class.","A class is a cohesive package that consists of a particular kind of compile-time metadata. A class describes the rules by which objects, i.e. instances of the class, behave. The class specifies the structure of data which each instance of the class, i.e. an object, contains as well as the methods which manipulate the data of the object and perform tasks. A method is a function with a special property that it has access to data stored in an object.","Instances of a class, i.e. objects, will have certain aspects, i.e. features, attributes or properties, in common. One of the benefits of programming with classes is that all instances of a particular class will follow the defined behavior of the class they instantiate.","A class can \u201cimplement\u201d (or \u201crealize\u201d) multiple interfaces, each of which specify one or more abstract method signatures (name and type of the method and its parameters) which must be defined in that class. Unlike multiple inheritance where actual code is inherited (along with naming and logical conflicts) interfacing allows one to define a behavior-interface (methods) that all classes implementing the interface should be able to fulfill.","Interfaces are a type of abstract class. Abstract classes, or abstract base classes (ABCs), are classes that are designed only as a parent class and from which child classes may be derived, and which is not itself suitable for instantiation. Concrete classes, on the other hand, are classes for which instances, i.e. objects, may be created. Abstract classes are often used to represent abstract concepts or entities. The incomplete features of the abstract class are then shared by a group of sibling sub-classes which add different variations of the missing pieces.","Interfaces and abstract classes allow for separation of concerns and inter-operability when architecting and developing applications. The interfaces and abstract classes must be implemented in concrete classes when generating such applications. Such implementation of interfaces and abstract classes requires \u201chard coding\u201d of the interface or abstract class implementation in the concrete class. As a result, if the interface or abstract class implementation is to be replaced, a source code update and recompilation would be necessary.","Consider the following example where an AudioDevice interface is provided and two concrete classes \u201cRadio\u201d and \u201cMP3Player\u201d implementing the AudioDevice interface are provided:",{"@attributes":{"id":"p-0012","num":"0011"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public interface AudioDevice {"]},{"entry":[{},"\u2003\u2003public void play( ) throws playbackException;"]},{"entry":[{},"\u2003\u2003public void stop( ) throws discontinuationException;"]},{"entry":[{},"}"]},{"entry":[{},"public class Radio implements AudioDevice {"]},{"entry":[{},"\u2003\u2003public void play( ) throws playbackException {...}"]},{"entry":[{},"\u2003\u2003public void stop( ) throws discontinuationException{...}"]},{"entry":[{},"}"]},{"entry":[{},"public class MP3Player implements AudioDevice {"]},{"entry":[{},"\u2003\u2003public void play( ) throws playbackException{...}"]},{"entry":[{},"\u2003\u2003public void stop( ) throws discontinuationException{...}"]},{"entry":[{},"\u2003\u2003public void shuffle( ) {...}"]},{"entry":[{},"}"]},{"entry":[{},"Consider also the following snippet of application source"]},{"entry":[{},"code:"]},{"entry":[{},"..."]},{"entry":[{},"[36] AudioDevice myStereo = new MP3Player( );"]},{"entry":[{},"[37] myStereo.play( );"]},{"entry":[{},"..."]},{"entry":[{},"[52] myStereo.stop( );"]},{"entry":[{},"..."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"As shown in the example, the instantiation of the AudioDevice interface requires the specification in the application source code of a concrete class that implements the interface. As a result, if a programmer later wishes to switch to alternate implementations of the AudioDevice interface, the programmer must modify the application source code itself to change the concrete class implementation of the interface. For example, if a new MP3 PDA combination device is to be utilized, a new concrete class for the MP3 PDA combination device must be provided and the application source code must be modified as follows to implement the AudioDevice interface using the new MP3PDA concrete class:","[36] AudioDevice myStereo=new MP3PDA( );","Even a single application source code change, such as the one above, still requires new development of application source code and a recompilation of the application source code. Such development and recompilation takes time, effort, and resources to accomplish. This is made even more troublesome when considered in light of modern applications where there may be thousands of lines of application source code.","The illustrative embodiments provide a system and method for instantiating an interface or abstract class in application code. With the mechanisms of the illustrative embodiments, an object-oriented programming language is extended such that interfaces and abstract classes can be instantiated in application code without a concrete class specified. Metadata is defined which maps each interface or abstract class instantiation in the application code to a concrete class to be used either by the compiler at build time, or the virtual machine at runtime. Once the appropriate concrete class is determined from the metadata, the class is instantiated with a conventional class loader. The metadata may be provided, for example, as a separate file, such as a markup language file, defined with a virtual machine switch, as annotations in the application code, or the like.","In one illustrative embodiment, a method for instantiating an abstract class is provided. The method may comprise providing mapping metadata for mapping an abstract class to a corresponding concrete class implementing the abstract class. The method may further comprise encountering an instantiation statement for the abstract class during processing of application code, the instantiation statement not specifying a concrete class implementing the abstract class. The method may also comprise converting the instantiation statement to specify the concrete class implementing the abstract class based on the mapping metadata. The abstract class may be an interface class. The mapping metadata may be provided as part of a mapping metadata file data structure separate from the application code.","The mapping metadata may be provided as annotations within the application code. The annotations may be provided at one of a class-level, a method-level, a declaration-level, or a package-level.","The encountering and converting operations may be performed by a compiler at build-time of the application code. Alternatively, the encountering and converting operations may be performed at runtime by a virtual machine interpreting byte code instructions.","The application code may be application source code and the mapping metadata may be provided as both annotation metadata provided in the application source code and as mapping metadata provided in a separate mapping metadata file. Conflicts between annotation metadata provided in the application source code and mapping metadata provided in a separate mapping metadata file may be resolved in favor of the mapping metadata provided in the separate mapping metadata file.","The encountering and converting operations may be performed as part of context checking by a compiler. Moreover, the converting operation may comprise checking for a concrete class mapping in a separate mapping metadata file and checking for a concrete class mapping in application source code annotations if a concrete class mapping is not found in the separate metadata file. The converting operation may be performed using a concrete class mapping found in either the separate mapping metadata file or the application source code annotation.","In other illustrative embodiments, a computer program product comprising a computer useable medium having a computer readable program is provided. The computer readable program, when executed on a computing device, causes the computing device to perform various ones, and combinations of, the operations outlined above with regard to the method illustrative embodiment.","In yet another illustrative embodiment, a system is provided. The system may comprise a processor and a memory coupled to the processor. The memory may comprise instructions which, when executed by the processor, cause the processor to perform various ones, and combinations of, the operations outlined above with regard to the method illustrative embodiment","These and other features and advantages of the present invention will be described in, or will become apparent to those of ordinary skill in the art in view of, the following detailed description of the exemplary embodiments of the present invention.","The illustrative embodiments provide mechanisms for extending the functionality of object-oriented programming languages to enable the instantiation of interfaces and abstract classes in application code without having to specify a concrete class. As such, the mechanisms of the illustrative embodiments may be used to generate application code that may be implemented in distributed data processing systems, stand-alone data processing systems, and the like. Moreover, a distributed application development mechanism, in which portions of the application development mechanism are provided on different data processing devices connected by one or more communication networks, may be utilized for actually developing the application code using the mechanisms of the illustrative embodiments.","In view of this,  are provided hereafter as exemplary diagrams of possible data processing environments in which aspects of the illustrative embodiments may be implemented.  are only exemplary and are not intended to state or imply any limitation with regard to the types or configurations of data processing systems in which the mechanisms of the illustrative embodiments may be implemented. Many modifications to the depicted data processing systems may be made without departing from the spirit and scope of the present invention.","With reference now to the figures,  depicts a pictorial representation of an exemplary distributed data processing system in which aspects of the illustrative embodiments may be implemented. Distributed data processing system  may include a network of computers in which aspects of the illustrative embodiments may be implemented. The distributed data processing system  contains at least one network , which is the medium used to provide communication links between various devices and computers connected together within distributed data processing system . The network  may include connections, such as wire, wireless communication links, or fiber optic cables.","In the depicted example, server  and server  are connected to network  along with storage unit . In addition, clients , , and  are also connected to network . These clients , , and  may be, for example, personal computers, network computers, or the like. In the depicted example, server  provides data, such as boot files, operating system images, and applications to the clients , , and . Clients , , and  are clients to server  in the depicted example. Distributed data processing system  may include additional servers, clients, and other devices not shown.","In the depicted example, distributed data processing system  is the Internet with network  representing a worldwide collection of networks and gateways that use the Transmission Control Protocol\/Internet Protocol (TCP\/IP) suite of protocols to communicate with one another. At the heart of the Internet is a backbone of high-speed data communication lines between major nodes or host computers, consisting of thousands of commercial, governmental, educational and other computer systems that route data and messages. Of course, the distributed data processing system  may also be implemented to include a number of different types of networks, such as for example, an intranet, a local area network (LAN), a wide area network (WAN), or the like. As stated above,  is intended as an example, not as an architectural limitation for different embodiments of the present invention, and therefore, the particular elements shown in  should not be considered limiting with regard to the environments in which the illustrative embodiments of the present invention may be implemented.","With reference now to , a block diagram of an exemplary data processing system is shown in which aspects of the illustrative embodiments may be implemented. Data processing system  is an example of a computer, such as hosts  in , in which computer usable code or instructions implementing the processes for illustrative embodiments of the present invention may be located.","In the depicted example, data processing system  employs a hub architecture including north bridge and memory controller hub (NB\/MCH)  and south bridge and input\/output (I\/O) controller hub (SB\/ICH) . Processing unit , main memory , and graphics processor  are connected to NB\/MCH . Graphics processor  may be connected to NB\/MCH  through an accelerated graphics port (AGP).","In the depicted example, local area network (LAN) adapter  connects to SB\/ICH . Audio adapter , keyboard and mouse adapter , modem , read only memory (ROM) , hard disk drive (HDD) , CD-ROM drive , universal serial bus (USB) ports and other communication ports , and PCI\/PCIe devices  connect to SB\/ICH  through bus  and bus . PCI\/PCIe devices may include, for example, Ethernet adapters, add-in cards, and PC cards for notebook computers. PCI uses a card bus controller, while PCIe does not. ROM  may be, for example, a flash binary input\/output system (BIOS).","HDD  and CD-ROM drive  connect to SB\/ICH  through bus . HDD  and CD-ROM drive  may use, for example, an integrated drive electronics (IDE) or serial advanced technology attachment (SATA) interface. Super I\/O (SIO) device  may be connected to SB\/ICH .","An operating system runs on processing unit . The operating system coordinates and provides control of various components within the data processing system  in . As a client, the operating system may be a commercially available operating system such as Microsoft\u00ae Windows\u00ae XP (Microsoft and Windows are trademarks of Microsoft Corporation in the United States, other countries, or both). An object-oriented programming system, such as the Java\u2122 programming system, may run in conjunction with the operating system and provides calls to the operating system from Java\u2122 programs or applications executing on data processing system  (Java is a trademark of Sun Microsystems, Inc. in the United States, other countries, or both).","As a server, data processing system  may be, for example, an IBM\u00ae eServer\u2122 pSeries\u00ae computer system, running the Advanced Interactive Executive (AIX\u00ae) operating system or the LINUX\u00ae operating system (eServer, pSeries and AIX are trademarks of International Business Machines Corporation in the United States, other countries, or both while LINUX is a trademark of Linus Torvalds in the United States, other countries, or both). Data processing system  may be a symmetric multiprocessor (SMP) system including a plurality of processors in processing unit . Alternatively, a single processor system may be employed.","Instructions for the operating system, the object-oriented programming system, and applications or programs are located on storage devices, such as HDD , and may be loaded into main memory  for execution by processing unit . The processes for illustrative embodiments of the present invention may be performed by processing unit  using computer usable program code, which may be located in a memory such as, for example, main memory , ROM , or in one or more peripheral devices  and , for example.","A bus system, such as bus  or bus  as shown in , may be comprised of one or more buses. Of course, the bus system may be implemented using any type of communication fabric or architecture that provides for a transfer of data between different components or devices attached to the fabric or architecture. A communication unit, such as modem  or network adapter  of , may include one or more devices used to transmit and receive data. A memory may be, for example, main memory , ROM , or a cache such as found in NB\/MCH  in .","Those of ordinary skill in the art will appreciate that the hardware in  may vary depending on the implementation. Other internal hardware or peripheral devices, such as flash memory, equivalent non-volatile memory, or optical disk drives and the like, may be used in addition to or in place of the hardware depicted in . Also, the processes of the illustrative embodiments may be applied to a multiprocessor data processing system, other than the SMP system mentioned previously, without departing from the spirit and scope of the present invention.","Moreover, the data processing system  may take the form of any of a number of different data processing systems including client computing devices, server computing devices, a tablet computer, laptop computer, telephone or other communication device, a personal digital assistant (PDA), or the like. In some illustrative examples, data processing system  may be a portable computing device which is configured with flash memory to provide non-volatile memory for storing operating system files and\/or user-generated data, for example. Essentially, data processing system  may be any known or later developed data processing system without architectural limitation.","The illustrative embodiments may operate on a variety of computer platforms and operating systems. In one illustrative embodiment, the computer platform provides an interpretive environment, such as a REXX, Smalltalk, Java runtime environment, or the like. For example, the illustrative embodiments may operate in conjunction with a Java Virtual Machine (JVM) yet within the boundaries of a JVM as defined by Java standard specifications. While the following description of the illustrative embodiments will assume implementations using the Java object-oriented programming language, the illustrative embodiments and the present invention are not limited to such. Rather, the mechanisms of the illustrative embodiments and present invention are applicable to any object-oriented programming language that may be presently available or later developed.","In order to provide a context for the description of the illustrative embodiments herein, an exemplary interpretive environment in which the illustrative embodiments are employed will be assumed to be a Java interpretive environment. Thus, the following description provides an explanation of portions of the operation of a JVM according to Java specifications.","With reference now to , a block diagram illustrates the relationship of software components operating within a computer system that may implement the illustrative embodiments. Java-based system  contains platform specific operating system  that provides hardware and system support to software executing on a specific hardware platform. JVM  is one software application that may execute in conjunction with the operating system. Alternatively, JVM  may be embedded inside a Java enabled browser application such as Microsoft Internet Explorer\u2122 or Netscape Communicator\u2122. JVM  provides a Java run-time environment with the ability to execute Java application or applet , which is a program, servlet, or software component written in the Java programming language. The computer system in which JVM  operates may be similar to data processing system  or computer  described above. However, JVM  may be implemented in dedicated hardware on a so-called Java chip, Java-on-silicon, or Java processor with an embedded picoJava core. At the center of a Java run-time environment is the JVM , which supports all aspects of Java's environment, including its architecture, security features, mobility across networks, and platform independence.","The JVM  is a virtual computer, i.e. a computer that is specified abstractly. The specification defines certain features that every JVM must implement, with some range of design choices that may depend upon the platform on which the JVM is designed to execute. For example, all JVMs must execute Java bytecodes and may use a range of techniques to execute the instructions represented by the bytecodes. A JVM may be implemented completely in software or somewhat in hardware. This flexibility allows different JVMs to be designed for mainframe computers and PDAs.","The JVM  is the virtual computer component that actually executes Java programs. Java programs are not run directly by the central processor but instead by the JVM , which is itself a piece of software running on the processor. The JVM  allows Java programs to be executed on a different platform as opposed to only the one platform for which the code was compiled. Java programs are compiled for the JVM . In this manner, Java is able to support applications for many types of data processing systems, which may contain a variety of central processing units and operating systems architectures. To enable a Java application to execute on different types of data processing systems, a compiler typically generates an architecture-neutral file format\u2014the compiled code is executable on many processors, given the presence of the Java run-time system.","The Java compiler generates bytecode instructions that are nonspecific to a particular computer architecture. A bytecode is a machine independent code generated by the Java compiler and executed by a Java interpreter. A Java interpreter is part of the JVM that alternately decodes and interprets a bytecode or bytecodes. These bytecode instructions are designed to be easy to interpret on any computer and easily translated on the fly into native machine code.","The JVM  must load class files and execute the bytecodes within them. The JVM  contains a class loader, which loads class files from an application and the class files from the Java application programming interfaces (APIs) which are needed by the application. The execution engine that executes the bytecodes may vary across platforms and implementations. The execution engine may also be implemented in hardware and embedded on a chip so that the Java bytecodes are executed natively. JVMs usually interpret bytecodes, but JVMs may also use other techniques, such as just-in-time compiling, to execute bytecodes.","When an application is executed on a JVM  that is implemented in software on a platform-specific operating system, a Java application may interact with the host operating system by invoking native methods. A Java method is written in the Java language, compiled to bytecodes, and stored in class files. A native method is written in some other language and compiled to the native machine code of a particular processor. Native methods are stored in a dynamically linked library whose exact form is platform specific.","With the above computing environment, the illustrative embodiments provide mechanisms for defining implementations of interfaces and\/or abstract classes without having to hard-code the implementations with a particular concrete class. Implementations of interfaces and abstract classes may be specified in the application source code with regard to a generic object instantiation. For example, an instantiation statement may be:","AudioDevice myStereo=new AudioDevice( )","where \u201cAudioDevice\u201d is the interface, \u201cmyStereo\u201d is an instance variable, and \u201cnew AudioDevice( )\u201d is a generic object instantiation.","Metadata specifying mappings of the generic class specified in the interface or abstract class implementation statements to specific concrete classes may be made using a separate file or annotations provided in the application source code. These mappings may be utilized at build time to generate bytecode as if the original implementation statements specified a concrete class. Alternatively, these mappings may be used to bind specific concrete classes to interfaces or abstract classes at runtime.","In one illustrative embodiment, the metadata for mapping of a generic class specified in implementation statements may be provided as annotations in the actual application source code. The term \u201cannotation,\u201d in the context of the present description, means metadata appended to the source code of an attribute, method, class, or package, that can be used by the program itself, a compiler, or a virtual machine in processing the source code. The metadata may be provided at various levels of the application source code including at a class or method level, at a declaration level, or at a package level. Consider the following example for an AudioDevice interface:",{"@attributes":{"id":"p-0059","num":"0058"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"@MapInterface (class = org.audio.device.Radio)"]},{"entry":[{},"class AudioApplication {"]},{"entry":[{},"\u2003\u2003..."]},{"entry":[{},"\u2003\u2003AudioDevice myStereo = new AudioDevice( );"]},{"entry":[{},"\u2003\u2003..."]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In this example, the metadata \u201c@MapInterface (class=org.audo.device.Radio)\u201d is provided at a class level. At this level, all statements in the \u201cAudioApplication\u201d class that instantiate the AudioDevice interface will use the \u201corg.audio.device.Radio\u201d concrete class. Thus, by specifying the mapping metadata at a class level, one can apply the mapping to all statements the class that instantiate the corresponding interface.","The following is an example in which the mapping metadata is provided at a method level:",{"@attributes":{"id":"p-0062","num":"0061"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Class AudioApplication {"]},{"entry":[{},"\u2003\u2003@MapInterface (class = org.audio.device.MP3Player)"]},{"entry":[{},"\u2003\u2003void initStereo( ) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003AudioDevice myStereo = new AudioDevice( );"]},{"entry":[{},"\u2003\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In this example, the mapping metadata that maps a concrete class to a particular interface is provided within the \u201cAudioApplication\u201d class definition. As such, the mapping metadata is applied to a method associated with that mapping metadata. For example, in the above example, the mapping metadata is associated with the method immediately following it in the class definition. At compile time, the annotation actually becomes part of the method immediately following the annotation. The compiler or virtual machine uses an annotation reflection application program interface (API) to extract the annotation information from the method and then inserts concrete classes as necessary within the method scope.","The mapping metadata may further be provided at a declaration level, as illustrated in the following example:",{"@attributes":{"id":"p-0065","num":"0064"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Class AudioApplication {"]},{"entry":[{},"\u2003\u2003void initStereo( ) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003@MapInterface (class = org.audio.device.MP3PDA)"]},{"entry":[{},"\u2003\u2003\u2003\u2003AudioDevice myStereo = new AudioDevice( );"]},{"entry":[{},"\u2003\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"In addition to the above, the mapping metadata may also be provided at a package level, i.e. in association with a Java package that identifies classes that are part of the same namespace. At the package level, a standard \u201cpackage-info.java\u201d class within a Java package may be specified for example, in accordance with Java SE 5.0. Within this package-info.java class, the mapping metadata may be provided:",{"@attributes":{"id":"p-0067","num":"0066"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public class package-info {"]},{"entry":[{},"\u2003\u2003@MapInterface (class = org.audio.device.MP3Player)"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"As a result, the mapping metadata specified in the package-info.java class may be applied to all of the classes that are part of the same package namespace. Hence, rather than just being applicable to one class, as in the class level implementation described above, the package level specification of mapping metadata allows multiple classes to use the same interface-concrete class mapping information. With the annotation implemented mapping metadata embodiments, the package level provides a greatest scope of application of the specified mappings and thus, is likely to be the one that is most widely used in practice.","The mapping metadata may further be provided externally from the application source code, such as in a separate file that is accessible by a JVM or compiler. For example, the mapping metadata may be provided in an Extensible Markup Language (XML) file that is processed by the compiler when generating bytecode or the JVM when interpreting the application code. While an XML file will be used to describe illustrative embodiments, it should be appreciated that other types of files may be used in addition to, or in replacement of, the XML files. For example, other types of markup language files may be utilized without departing from the spirit and scope of the present invention.","The use of external files, e.g., XML files, may be made either as an alternative to annotations in the application source code or in conjunction with annotations in the application source code. In cases where both annotations and external files are utilized, one or the other may be chosen, depending upon the implementation, to override the other in cases of conflicts. For example, in one illustrative embodiment, any conflicts between annotation metadata and an XML metadata file's metadata is resolved in favor of the XML metadata file's metadata such that the XML metadata file's metadata overrides the annotation metadata. This allows for administration outside of the application source code.","With the XML metadata file, the XML metadata file's metadata may govern functionality for all application classes in a given package. Alternatively, a global XML metadata file may be defined for the entire application. For example, in one illustrative embodiment, an XML metadata file called \u201cinstantiation-map.xml\u201d may be added to a package of compiled code for which the compiler or JVM automatically detects. A file called \u201cglobal-instantiation-map.xml\u201d may be added either as a javac compiler argument or a JVM argument which overrides all other metadata and governs the mapping of the entire application.","The following is one example of an XML metadata file that may be utilized with the illustrative embodiments:",{"@attributes":{"id":"p-0073","num":"0072"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<instantiation-map>"},{"entry":"\u2003\u2003<map scope=\u201dglobal\u201d>"},{"entry":"\u2003\u2003\u2003\u2003<entry interface=\u201dAudioDevice\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003class=\u201dorg.audio.device.Radio\u201d\/>"},{"entry":"\u2003\u2003<\/map>"},{"entry":"\u2003\u2003<map scope=\u201dclass\u201d class=\u201dorg.audio.app.AudioApplication\u201d>"},{"entry":"\u2003\u2003<entry interface=\u201dAudioDevice\u201d"},{"entry":"\u2003\u2003\u2003\u2003class=\u201dorg.audio.device.MP3Player\u201d\/>"},{"entry":"\u2003\u2003<\/map>"},{"entry":"\u2003\u2003<map scope=\u201dmethod\u201d class=\u201dorg.audio.app.AudioApplication\u201d"},{"entry":"\u2003\u2003\u2003\u2003method=\u201dplayRadio\u201d>"},{"entry":"\u2003\u2003<entry abstractClass=\u201dRadioStation\u201d"},{"entry":"\u2003\u2003\u2003\u2003class=\u201dorg.audio.stations.W3KM\u201d\/>"},{"entry":"\u2003\u2003<\/map>"},{"entry":"<\/instantiation-map>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In the above example, the XML metadata file defines various scopes of mapping metadata applicability including global mappings, class-level mappings, method-level mappings, and the like. Statement level mapping is not provided in the XML metadata file but may be done using application source code annotation metadata, as previously described above, for example. Within the XML metadata file itself, more specific scoped mapping metadata entries always override wider scoped mapping metadata entries. Thus, for example, in the above example, all interfaces in the AudioApplication class are bound to the MP3Player class rather than the Radio class by virtue of this override methodology.","The mapping metadata provided by the illustrative embodiments, whether provided as annotation metadata or separate external metadata files, may be used by either a compiler at build-time or a JVM at runtime. Both uses will now be described.","With regard to the use of mapping metadata at build-time, a compiler switch, e.g., a javac compiler switch, may be used to specify that the compiler should replace all interface and abstract class instantiation statements with the proper concrete class defined in the mapping metadata. For example, a javac compiler switch such as the following may be utilized:",{"@attributes":{"id":"p-0077","num":"0076"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"javac \u2003-cp org.audio.app;global-instantiation-map.xml"]},{"entry":[{},"\u2003\u2003-bindConcrete *.java"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"With such a javac compiler switch, if the javac compiler encounters an interface or abstract class instantiation statement in the application source code during its context checking operation, it searches the appropriate metadata, either or both of annotation metadata or external metadata file metadata, to determine which concrete class to bind to the interface or abstract class. The result is bytecode that is exactly the same as if the application source code had the hardcoded bindings in place in the interface and abstract class instantiation statements, as in the prior art. Thus, the same result as the prior art is obtained but with the additional flexibility of providing the concrete class bindings in metadata that may be easily modified without tedious application source code modifications.",{"@attributes":{"id":"p-0079","num":"0078"},"figref":["FIG. 4","FIG. 4"],"b":["410","420","410","410"]},"As part of this context checking, the compiler  identifies one or more interface or abstract class instantiation statements in the application source code file . In response to identifying an interface or abstract class instantiation statement in the application source code file , the compiler  searches the mapping metadata file(s) , e.g., XML metadata file(s), for any concrete class mapping metadata for the interface or abstract class. If no mapping metadata is found in the mapping metadata file(s) , the compiler  searches the application source code file  for any defined mapping metadata annotations.","If the proper mapping metadata is not found by the compiler  in the annotations, then a compilation error may be generated and output. If the compiler  finds proper mapping metadata in either the mapping metadata file(s)  or the annotations in the application source code file , the compiler  generates byte code  using the corresponding concrete class specified in the found mapping metadata. The resulting byte code  is the same as if the concrete class were specified in a hard-coded manner as the implementation class in the application source code's implementation statement.","In order to provide additional functionality in the compiler , a static analysis dependency tool  may be provided as part of the compiler . This tool serves to perform static analysis on the additional dependencies of the mapping metadata and various concrete classes for the application. The static analysis dependency tool  may be run by the compiler  on the application source code file  to determine if all dependencies of the mapping metadata and the concrete classes are met or if there are dependencies that are not met. This tool  may be run by the compiler  as a preliminary step in the context checking before performing the operations outlined above to replace interface and abstract class instantiation statements with concrete class mappings.","The static analysis dependency tool  may determine if dependencies are met or not met by scanning through each class looking for instantiation statements. The mapping metadata file(s) and annotation information may be loaded into a running lookup table. If an instantiation statement is found that does not have a corresponding mapping in the lookup table, this is reported to the user with valuable information such as the package, class, line number, and interface of the instantiation statement.","For example, if all dependencies are met, the static analysis dependency tool  may return a statement such as:\n\n",{"@attributes":{"id":"p-0085","num":"0085"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Interface dependencies not met:"]},{"entry":[{},"\u2003\u2003Java Interface: org.audio.device.AudioDevice"]},{"entry":[{},"\u2003\u2003[Line 36] org.audio.app.AudioApplication.java"]},{"entry":[{},"\u2003\u2003AudioDevice myStereo = new AudioDevice( );"]},{"entry":[{},"Abstract class verification complete."]},{"entry":[{},"Not all dependencies are met."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"It should be appreciated that while the above description assumes that the compiler  performs the modification of interface and abstract class instantiation statements in the application source code file  as part of its context checking, the illustrative embodiments are not limited to such. Rather, the modification of interface and abstract class instantiation statements may be performed by a pre-compiler utility (not shown) that operates prior to the compiler  operating on the application source code file . In this way, the compiler's operation need not be modified from prior art compilers since the application source code is modified to be essentially the same as if the concrete classes were hard coded in the original instantiation statements of the application source code.","In addition to utilizing the mechanisms of the illustrative embodiments at build-time, the illustrative embodiments may be employed at runtime by allowing the virtual machine, e.g., a Java Virtual Machine (JVM), to bind implementation concrete classes at runtime. With such an embodiment, when an abstract class or interface class is encountered at runtime, the JVM may use the mapping metadata information to determine which class should be loaded. The JVM may then utilize class loaders, such as a bootstrap class loader, to load the class specified in the metadata. Subclasses of \u201cClassNotFoundException\u201d called \u201cInterfaceInstantiationException\u201d and \u201cAbstractClassInstantiationException\u201d may be thrown if the metadata does not provide the appropriate implementation class.","Similar to the build-time implementation, a JVM switch may be used to inform the JVM that it can instantiate abstract classes and interfaces using the mapping metadata of the illustrative embodiments. For example, the JVM switch may take the following form:",{"@attributes":{"id":"p-0089","num":"0089"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"java -bindConcrete -cp org.audio.bin;global-"]},{"entry":[{},"instantiation-map.xml AudioApplication"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0090","num":"0090"},"figref":["FIG. 5","FIG. 5"],"b":["510","522","520","530","522","530","510","524","520"]},"If proper mapping information is not found in the annotations , a runtime exception is thrown. If a proper mapping is found in either the mapping metadata file(s)  or the annotations , the JVM  uses a class loader , in a conventional manner, to load the concrete class  specified in the mapping metadata information found by the JVM .","At startup, the default behavior of the JVM  is to do \u201clazy loading\u201d of XML mapping information from the mapping metadata file(s)  into memory where it is cached for future use. How much memory is allocated for the in-memory mapping metadata is chosen by the JVM  provider. However, the amount of memory may be set with \u201c-bindConcreteSize.\u201d","In addition, two more options are available when XML metadata is used: \u201c-bindConcrete greedy\u201d and \u201c-bindConcrete minimal.\u201d The \u201cgreedy\u201d strategy parses all the XML information (package-level and global) at JVM  startup. If there is not enough memory available, caching is conducted as in the \u201clazy loading\u201d strategy described above. The \u201cminimal\u201d strategy conserves as much memory as possible by parsing the XML metadata each time it is required. Thus, no mapping metadata information is cached. It should be noted that the annotation metadata may use a \u201c@Retention (RUNTIME)\u201d meta-annotation in order for the mapping metadata to be \u201cvisible\u201d to the JVM  at runtime, as specified in the Java SE 5.0 specification.","For concrete classes to be bound at runtime, the compiler is given valid syntax for there to be runtime code in the first place. A pre-compiler utility may be provided that is run on the application source code and which replaces the interface and abstract class instantiation statements with a placeholder class. One approach is for the pre-compiler utility to create an empty class with the current time as the name:",{"@attributes":{"id":"p-0095","num":"0095"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public class MyInterface_113529609327 extends"]},{"entry":[{},"\u2003\u2003MyInterface{ }"]},{"entry":[{},"public class AudioDevice_113529609327 extends"]},{"entry":[{},"\u2003\u2003AudioDevice{ }"]},{"entry":[{},"The pre-compiler utility may then replace statements as"]},{"entry":[{},"follows:"]},{"entry":[{},"MyInterface mi = new MyInterface( ); MyInterface mi = new"]},{"entry":[{},"MyInterface_113529609327( );"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"At runtime, class-level \u201cBindConcrete\u201d annotations serve as callbacks to replace the placeholder class with the correct concrete class using the appropriate metadata. For example, the source code may look like:",{"@attributes":{"id":"p-0097","num":"0097"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"@BindConcrete"]},{"entry":[{},"Docket No. AUS920060736US1"]},{"entry":[{},"public class AudioApplication {"]},{"entry":[{},"\u2003\u2003..."]},{"entry":[{},"\u2003\u2003Interface AudioDevice = new AudioDevice( );"]},{"entry":[{},"\u2003\u2003..."]},{"entry":[{},"\u2003\u2003Interface AudioDevice = new AudioDevice( );"]},{"entry":[{},"\u2003\u2003..."]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0098","num":"0098"},"figref":"FIGS. 6 and 7"},"Accordingly, blocks of the flowchart illustrations support combinations of means for performing the specified functions, combinations of steps for performing the specified functions and program instruction means for performing the specified functions. It will also be understood that each block of the flowchart illustrations, and combinations of blocks in the flowchart illustrations, can be implemented by special purpose hardware-based computer systems which perform the specified functions or steps, or by combinations of special purpose hardware and computer instructions.",{"@attributes":{"id":"p-0100","num":"0100"},"figref":["FIG. 6","FIG. 6"],"b":["605","610"]},"As part of the context checking, the compiler determines if an interface or abstract class instantiation is encountered (step ). If not, a determination is made as to whether the context checking has completed (step ). If the context checking has completed, the operation terminates. If context checking has not completed, the operation returns to step .","If an interface or abstract class instantiation is encountered, the compiler searches one or more mapping metadata file(s), e.g., XML metadata file(s), for any concrete class mapping metadata for the interface or abstract class (step ). The compiler determines if concrete class mapping metadata is found for the interface or abstract class (step ). If no mapping metadata is found in the mapping metadata file(s), the compiler searches the application source code file for any defined mapping metadata annotations (step ).","The compiler determines if proper mapping metadata for the interface or abstract class is found in the annotations (step ). If proper mapping metadata is not found by the compiler in the annotations, then the compiler generates and outputs a compilation error (step ). If the compiler finds proper mapping metadata in either the mapping metadata file(s) or the annotations in the application source code file, the compiler generates byte code using the corresponding concrete class specified in the found mapping metadata (step ). The resulting byte code is the same as if the concrete class were specified in a hard-coded manner as the implementation class in the application source code's implementation statement. The operation then terminates.",{"@attributes":{"id":"p-0104","num":"0104"},"figref":["FIG. 7","FIG. 7"],"b":["710","720"]},"The virtual machine determines if such mapping metadata is found (step ). If mapping metadata is not found for the interface or abstract class instantiation, the virtual machine searches the byte code instruction stack for any annotations specifying mapping metadata for the interface of abstract class instantiation (step ). The virtual machine determines if appropriate mapping metadata is present in the annotations (step ). If not, a runtime exception is thrown (step ). If proper mapping metadata is found in either the mapping metadata file of the annotations, the virtual machine instructs a class loader to load the corresponding concrete class found in the mapping metadata (step ). The runtime execution of the application byte code is then continued in a normal manner by the virtual machine (step ) and the operation terminates. It should be appreciated that the operation of  may be repeated each time an interface or abstract class instantiation is encountered during runtime in the byte code instruction stack.","Thus, the mechanisms of the illustrative embodiments allow for instantiating an interface or abstract class in application code without having to hard code the binding of the interface or abstract class to a particular implementing concrete class in the instantiation statement. To the contrary, the concrete class may be specified using mapping metadata provided as either annotations in the application source code, in a separate metadata file, or both.","The mechanisms of the illustrative embodiments may be used for various purposes with the benefits of the illustrative embodiments being apparent to those who develop application source code using object-oriented programming languages. One example of a use for the mechanisms of the illustrative embodiments is in performance testing. Performance testing often seeks to target specific components of an application. Take for example, a performance test that seeks to compare a Java Database Connectivity (JDBC) backend of a J2EE application to an Enterprise Java Bean (EJB) entity bean backend. A natural approach would be to write an interface for which both backend implementations must conform. In this way, both implementations share the same presentation layer, business logic, transaction services, etc. The illustrative embodiments may be utilized to switch between which implementation is used to instantiation the interface and thereby, compare the two implementations.","It should be appreciated that the illustrative embodiments may take the form of an entirely hardware embodiment, an entirely software embodiment or an embodiment containing both hardware and software elements. In one exemplary embodiment, the mechanisms of the illustrative embodiments are implemented in software, which includes but is not limited to firmware, resident software, microcode, etc.","Furthermore, the illustrative embodiments may take the form of a computer program product accessible from a computer-usable or computer-readable medium providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description, a computer-usable or computer-readable medium can be any apparatus that can contain, store, communicate, propagate, or transport the program for use by or in connection with the instruction execution system, apparatus, or device.","The medium may be an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system (or apparatus or device) or a propagation medium. Examples of a computer-readable medium include a semiconductor or solid state memory, magnetic tape, a removable computer diskette, a random access memory (RAM), a read-only memory (ROM), a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk\u2014read only memory (CD-ROM), compact disk\u2014read\/write (CD-R\/W) and DVD.","A data processing system suitable for storing and\/or executing program code will include at least one processor coupled directly or indirectly to memory elements through a system bus. The memory elements can include local memory employed during actual execution of the program code, bulk storage, and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.","Input\/output or I\/O devices (including but not limited to keyboards, displays, pointing devices, etc.) can be coupled to the system either directly or through intervening I\/O controllers. Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems, cable modem and Ethernet cards are just a few of the currently available types of network adapters.","The description of the present invention has been presented for purposes of illustration and description, and is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain the principles of the invention, the practical application, and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The invention, as well as a preferred mode of use and further objectives and advantages thereof, will best be understood by reference to the following detailed description of illustrative embodiments when read in conjunction with the accompanying drawings, wherein:",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
