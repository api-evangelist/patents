---
title: Component statistics for application profiling
abstract: Implementations of the present disclosure provide methods including executing an application using one or more processors, generating a plurality of method call stacks, each method call stack comprising a plurality of methods invoked by the application, providing a component call stack based on a method call stack of the plurality of method call stacks, the component call stack comprising a plurality of components, each component being defined by one or more methods of the plurality of methods, and generating component statistics based on the component call stack and profiling data collected during the executing.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08584098&OS=08584098&RS=08584098
owner: SAP AG
number: 08584098
owner_city: Walldorf
owner_country: DE
publication_date: 20091204
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["Software applications running in a distributed application server environment may have a plurality of concurrent users accessing the servers and applications. This can result in performance and scalability problems with the servers and applications running on the servers. Performance monitoring, profiling and debugging tools can monitor software applications running on the servers to determine resource consumption information.","Software profiling is a technique for measuring where software application programs consume resources (e.g., central processing unit (CPU) computation times, memory accesses). A profiling tool or profiler can analyze the resource consumption of an application running on a server and provide profiling data based thereon. For example, a Java profiler can support a broad set of Java virtual machines (JVMs). The Java profiler can provide comprehensive profiling of a Java application running on the JVM.","Implementations of the present disclosure provide computer-implemented methods for providing profiling data at a component level. In some implementations, a method includes executing an application using one or more processors, generating a plurality of method call stacks, each method call stack comprising a plurality of methods invoked by the application, providing a component call stack based on a method call stack of the plurality of method call stacks, the component call stack comprising a plurality of components, each component being defined by one or more methods of the plurality of methods, and generating component statistics based on the component call stack and profiling data collected during the executing.","In some implementations, generating component statistics includes providing profiling data corresponding to each method of the plurality of methods, and for each component, aggregating profiling data of the one or more methods that defines a particular component, a component statistic for a particular component comprising the aggregate profiling data of the one or more methods that define the particular component.","In some implementations, the method further includes defining an entry method for each component of the plurality of components to provide a plurality of defined entry methods, and grouping one or more methods based on the entry methods to provide one or more method groups, each method group corresponding to a component. Grouping can include identifying a first method as an entry method, identifying a second method as an entry method, and grouping the first method and subsequent consecutive methods into a group, the subsequent consecutive methods being prior to the second method in the method call stack. In some implementations, the first method and subsequent consecutive methods are grouped until another entry method is encountered in the consecutive methods.","In some implementations, the method further includes defining the plurality of methods invoked by the application as methods to be traced, monitoring the plurality of methods during execution of the application, and collecting the profiling data, the profiling data corresponding to each method of the plurality of methods.","In some implementations, the method further includes receiving user input identifying one or more components of interest, and identifying one or more components to be included in the plurality of components of the component call stack based on the user input.","In some implementations, the method further includes sending the component statistics for display on a client device.","The present disclosure also provides a computer-readable storage medium coupled to one or more processors and having instructions stored thereon which, when executed by the one or more processors, cause the one or more processors to perform operations in accordance with implementations of the methods provided herein.","The present disclosure further provides a system for implementing the methods provided herein. The system includes a computing device including one or more processors, and a computer-readable storage medium coupled to the one or more processors having instructions stored thereon which, when executed by the one or more processors, cause the one or more processors to perform operations in accordance with implementations of the methods provided herein.","It is appreciated that methods in accordance with the present disclosure can include any combination of the aspects and features described herein. That is to say that methods in accordance with the present disclosure are not limited to the combinations of aspects and features specifically described herein, but also include any combination of the aspects and features provided.","The details of one or more implementations of the present disclosure are set forth in the accompanying drawings and the description below. Other features and advantages of the present disclosure will be apparent from the description and drawings, and from the claims.","Like reference symbols in the various drawings indicate like elements.","Implementations of the present disclosure are generally directed to component statistics that provide a broader view of profiling data for a profiled application. More specifically, implementations of the present disclosure relate to aggregating profiling results in component views. In some implementations, navigation or selections within the component statistics is described in a meaningful way so that further selections may be calculated based on prior selection results without requiring a new calculation based on the original profiling data. The component statistics enable a profiler to present a coarser overview of the profiling data. In this manner, complex application execution scenarios and their resultant effect on resource consumption can be clearly presented.","Referring now to , a schematic illustration of an exemplar system  in accordance with implementations of the present disclosure can include a plurality of clients , , and a computer system . The computer system  can include a server  and a database . In some implementations, the system  may represent a client\/server system supporting multiple computer systems (e.g., computer system ) including one or more clients (e.g., clients , ) and\/or one or more servers (e.g., server ) that are connectively coupled for communication with one another over a network . In some implementations, the clients (e.g., clients , ) may be directly connected to the one or more servers (e.g., server ) (without connecting by way of network ).","The clients ,  can represent various forms of processing devices including, but not limited to, a desktop computer, a laptop computer, a handheld computer, a personal digital assistant (PDA), a cellular telephone, a network appliance, a camera, a smart phone, an enhanced general packet radio service (EGPRS) mobile phone, a media player, a navigation device, an email device, a game console, or a combination of any two or more of these data processing devices or other data processing devices. Each client ,  may access application software on the server .","The server  can represent various forms of servers including, but not limited to a web server, an application server, a proxy server, a network server, or a server farm. For example, the server  can be an application server that executes software accessed by clients , . In operation, multiple clients (e.g., clients , ) can communicate with the server  by way of network . In some implementations, a user can invoke applications available on the server  in a web browser running on a client (e.g., clients , ). Each application can individually access data from one or more repository resources (e.g., database ). For example, the server  can access database .","In some implementations, the client devices ,  may communicate wirelessly through a communication interface (not shown), which may include digital signal processing circuitry where necessary. The communication interface may provide for communications under various modes or protocols, such as GSM voice calls, SMS, EMS, or MMS messaging, CDMA, TDMA, PDC, WCDMA, CDMA2000, or GPRS, among others. For example, the communication may occur through a radio-frequency transceiver (not shown). In addition, short-range communication may occur, such as using a Bluetooth, WiFi, or other such transceiver.","In some implementations, the system  can be a distributed client\/server system that spans one or more networks such as network . The network  can be a large computer network, such as a local area network (LAN), wide area network (WAN), the Internet, a cellular network, or a combination thereof connecting any number of mobile clients, fixed clients, and servers. In some implementations, each client (e.g., clients , ) can communicate with the server  via a virtual private network (VPN), Secure Shell (SSH) tunnel, or other secure network connection. In some implementations, the network  can include the Internet, a wireless service network and may include the Public Switched Telephone Network (PSTN). In other implementations, the network  may include a corporate network (e.g., an intranet) and one or more wireless access points.","Each client (e.g., clients , ) can establish its own session with the server . Each session can be semi-permanent as it can be established at one point in time and torn down at another. Each session can involve two-way information exchange between the computer system  and each individual client , . For example, a Hypertext Transfer Protocol (HTTP) session enables the association of information with individual users. A session can be stateful where at least one of the communicating parts (e.g., the server  or the client (e.g., clients , )) can save information about the session history in order to be able to communicate. Alternatively, stateless communication includes independent requests with associated responses.","Multiple clients (e.g., clients , ) can communicate via network  with the server . In order to run an application each client (e.g., clients , ) can establish a corresponding session with the application server . In some implementations, a user can initiate a profiling session for an application running on the server  using the client . The client  can establish the profiling session with the server . The profiling session can profile an application running on a Java virtual machine (JVM) on the server . For example, a profiler, included on the server , can record and store profiling data for a profiling session in the database  for analysis by the user running the profiling session from the client . In some implementations, the profiling data can be stored in a file system on the server . The profiler can also send the profiling data to the client  for analysis by the user. The client  can display the profiling data recorded for the application running on the JVM in a graphical user interface (GUI) displayed on display device on the client .","As used herein, the term profiling data generally refers to map data and event data. Map data can include a mapping between numeric identifiers and VM structure entities such as stack traces, thread names, classes, methods, and class loaders, for example. Event data directly relates to profiled actions occurring in a VM. Exemplar actions can include the start of threads, object allocations (e.g., for the allocation trace), method enter events, method exit events, and the actual method parameters (e.g., for the method parameter trace), sampled thread stack traces (e.g., for the performance trace), and\/or garbage collection events. The map data can be referenced in the event data. Consequently, instead of writing explicit class specifications, method specifications, and complete stack traces within the event data, only the corresponding numeric identifier need be written. In this manner, the amount of event information (from a memory perspective) can be drastically reduced.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 2","FIG. 1"],"b":["200","200","100","200","108","106","114","102","104"]},"For example, the profiler can analyze the resource consumption of an application running on a JVM. In some implementations, the application can be a standalone Java application. In some implementations, the application can be a complex enterprise application that can utilize a plurality of resources. For example, the profiler can be the JVM Profiler provided by SAP AG.","The profiler can include two components: a profiler front-end component (front-end profiler ) and a profiler back-end component (back-end profiler ). The back-end profiler can be integrated into a back-end virtual machine (VM) . In some implementations, a native application can be provided as a front-end, the native application understanding the profiling protocol of the back-end. In some implementations, the front-end profiler can be integrated into a front-end VM . For example, the back-end VM and the front-end VM can each be a JVM provided by SAP AG. The JVM can run one or more applications integrated with the back-end profiler in the back-end VM  and provides for connection to the front-end profiler . The back-end profiler can provide profiling data for one or more applications running on the back-end VM . The front-end profiler can provide a visual representation of the profiling data provided by the back-end profiler (e.g., client  can include front-end profiler and display device can display the profiling data to a user in a GUI).","For example, a back-end profiler for a JVM can expose profiling data from a Java application executing on a back-end VM. The back-end profiler can use a Java Virtual Machine Tool Interface (JVMTI) to collect profiling data from the JVM. In some implementations, the JVM can provide an interface to load the back-end profiler (e.g., as an agent) into the JVM process. In some scenarios, a proprietary implementation can directly integrate the back-end profiler into the JVM. For example, the SAP\u00ae JVM can include a proprietary back-end profiler directly integrated into the back-end VM.","In some implementations, during a profiling session, a user can directly connect to the VM that includes the profiler (e.g., back-end VM  that includes back-end profiler ). The user can interactively request profiling data be sent from the back-end profiler to the front-end profiler . Profilers , can communicate with each other using client application programming interface (API)  and server API , respectively. For example, computer system  can establish a socket connection between the back-end profiler and front-end profiler . The profilers , can be located on physically different machines (e.g., client  and server , respectively). The profiling data can be transferred from the back-end profiler to the front-end profiler (e.g., by way of a socket connection or the transfer of one or more files). The front-end profiler can receive the profiling data and prepare it for analysis and display to a user. For example, the front-end profiler can display the profiling data in a GUI on display device . In some implementations, the profiling data can be transferred using a file transfer.","In some implementations, the computer system  may directly connect to client  without the use of network . In some implementations, the front-end VM  and back-end VM  including profiler and profiler , respectively, may run on the same machine where client , server  and database  are included on the same physical machine.","The front-end profiler can be a stand alone application that can communicate with the back-end profiler included in the back-end VM  without the need for a front-end VM. More specifically, a front-end profiler may be a stand-alone program or application that is compatible with a back-end profiler. In some implementations, the front-end VM  can run the front-end profiler stand-alone application. The front-end profiler stand-alone application can analyze additional stand-alone applications running on the front-end VM . The front-end profiler stand-alone application can also analyze applications running on the back-end VM .","In some implementations, the profilers , can be integral parts of VMs , , respectively. This can allow for \u201con-demand\u201d examination of applications running on the back-end VM . Because the VMs ,  include profilers , , respectively, profiling can occur during runtime without the need to restart the VMs , . Including a profiler in a VM reduces the memory usage typically required, thereby minimizing the memory overhead of the computer system (e.g., computer system ).","The server API  can start and stop the VM included in the back-end VM  that includes the application for profiling. The back-end profiler can record the profiling data for the application running on the back-end VM . In some implementations, the back-end profiler can store the profiling data as one or more profiling files in the database . In some implementations, the back-end profiler can send the profiling data to the front-end profiler for further processing. For example, an SAP\u00ae JVM's debug connection can connect the client  to the server  to communicate profiling data from the back-end profiler to the front-end profiler using server API  and client API , respectively.","In some implementations, a developer can use a multi-language software development environment to implement, test and debug a software project. The software development environment can be an open architecture software development platform that includes an integrated development environment (IDE) and a plug-in system. The plug-in system can allow extensions to the IDE with the ability to integrate custom tools. The plug-in system can provide a framework for integrating user-made applications and infrastructure components. For example, a front-end profiler that includes a user interface can be provided as a plug-in to the software development platform. For example, the front-end profiler can be an Eclipse plug-in that can be integrated into an Eclipse platform. The Eclipse platform can provide an IDE for implementing, testing and debugging Java based software development projects. An Eclipse platform that includes a front-end profiler plug-in can additionally provide profiling of Java based software development projects. For example, the front-end profiler can be a plug-in to a software development platform running on the front-end VM .","A remote profiling session can occur when a host or server (e.g., server ) that includes the application for profiling is remotely located from the client (e.g., client ) running the application that initiates the profiling session. For example, system  shows an exemplar remote profiling session where the back-end VM  is running an application that includes the back-end profiler and the client  initiates the profiling session from the front-end VM , which includes front-end profiler . In a remote profiling session, opening a debugging port to the back-end VM  can switch the back-end VM  into a profiling mode. Using client , a user can connect to the back-end VM  for profiling by connecting to the debugging port. As shown in , the back-end profiler is an integral part of the back-end VM . As described above, this can allow the back-end VM  to be switched into a profiling mode \u201con demand\u201d during execution of the back-end VM application without the need to restart the back-end VM application.","In some implementations, a local profiling session can occur when the application for profiling and the application that initiates the profiling session are located on the same host or server (e.g., the same physical machine). The local profiling session can perform simultaneous source code implementation, testing, debugging and profiling. The host can include a local display device that displays a GUI to a user. The GUI can allow the user the ability to control and configure the profiling session.","In some implementations, a user can perform a remote or local profiling session in an online or interactive mode. In an online profiling session, a front-end profiler (e.g., front-end profiler ) can initiate a profiling session with a back-end profiler (e.g., back-end profiler ). For example, a user interacting with a GUI displayed on display device can start and stop the profiling session as well as interact with the back-end profiler during the profiling session. The interaction can include configuring and controlling the profiling session as well as receiving profiling data. The user can request the resultant profiling data from the back-end profiler for display on the display device . The back-end profiler can open a debugging port to the back-end VM  when the front-end profiler initiates an online profiling session with the back-end profiler . The back-end VM  can then wait for a connection. The front-end VM  that includes the front-end profiler can connect to the debugging port using client API  and server API  by way of network .","In some implementations, in an online profiling session, a user may optionally store the profiling data received from the back-end VM in a local file (e.g., a file located on the client  as part of a local file system or repository). The user can access the locally stored profiling data file at any time after the completion of the profiling session.","In some implementations, a user can perform a remote or local profiling session in an offline or non-interactive mode. In an offline profiling session, a front-end profiler (e.g., front-end profiler ) can initiate a profiling session with a back-end profiler (e.g., back-end profiler ) but there is no interaction between the front-end profiler (e.g., front-end profiler ) and the back-end profiler (e.g., back-end profiler ) during the profiling session. For example, the system  can provide an interface to couple the front-end VM  to the back-end VM  using the server API  in order to start and stop the profiling session. The back-end VM  that includes the back-end profiler can store the profiling data in the database , and\/or a file. For example, a user interacting with a GUI displayed on the display device can start and stop the profiling session. Once complete, the user can request the profiling data stored in the file in the database  from the computer system  (e.g., the user can interact with a GUI displayed on display device to initiate the request). The client  can receive the profiling data file and display its contents to the user on display device ","In an offline profiling session, storing profiling data for the profiling session in a profiling file on database  can enable a user to retrieve profiling data for a back-end VM (e.g., back-end VM ) at any point after the profiling session is complete. For example, the stored profiling data can be retrieved from the database  whether or not the back-end VM (e.g., back-end VM ) is running.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 3","b":["212","218","212","212","316","324","322"],"i":["b","b ","b "]},"The back-end profiler can include a controller framework . In some implementations, the controller framework  can start and stop profiling sessions as well as traces during a profiling session. The controller framework  can allow a user to select specific back-end profiler options and settings for a profiling session. For example, the front-end profiler can display a GUI to the user on display device that displays the options and settings for the back-end profiler . The user, interacting with the GUI, can select specific back-end profiler options and settings for a profiling session.","The back-end profiler settings can include functional settings and filter settings. Functional profiler settings can determine the functional area of the application code to profile. For example, a functional profiler setting can specify the types of traces to perform for the profiling session (e.g., an allocation trace, a method parameter trace, and\/or a performance trace). Filter profiler settings can define a validity scope (e.g., user, session, thread, VM, etc.) for the functional profiler setting for the profiling session. For example, referring to , a user, operating client , can start an allocation trace in the back-end profiler . The validity scope of the profiling session can be for the user.","The profiler options can include specific monitoring, debugging and analysis functions. For example, profiler options can include memory debugging (e.g., memory leak detection), performance analysis (e.g., hotspot identification), synchronization monitoring, and application debugging (e.g., called method detection). By way of non-limiting example, the profiling functions can include one or more sub-functions (e.g., heap dump, time-based sampling, memory-based sampling, allocation trace, method parameter trace, garbage collection trace, etc.). Allocation analysis can identify and isolate memory related problems in an application. Allocation analysis can be used for memory debugging.","Performance analysis can monitor an application's behavior using information gathered as the application executes. Performance analysis can determine which parts of an application can be optimized for speed. In some implementations, performance analysis can indicate where within the application spent its time during execution thereof. Performance analysis can indicate which methods called other methods while the application executes. The profiling data gathered during a performance analysis can indicate which areas of the application are slower than expected. Performance hotspots (or bottlenecks) can be code segments in the application that can contribute significantly to overall application execution time. In some implementations, a performance hotspot can slow down or halt application execution. Identification of performance hot spots enables improvement of the code segment to improve the overall performance of the code at runtime.","In some implementations, the controller framework  may include a profiler evaluation module for analyzing profiling data. The server API  can obtain the complete profiling data for a profiling session. The profiler evaluation module can analyze the complete profiling data for the profiling session and generate problem oriented, condensed profiling data for the profiling session. The server API  can also obtain the condensed profiling data from the back-end VM . A user may use the condensed profiling data to identify one or more problematic areas in a profiled application. For example, a profiling session can perform a performance analysis on an application using a time-based sampling approach. The time-based sampling approach for performance analysis can be referred to as a statistical analysis. In some implementations, a profiling session can perform a performance analysis on an application using one or more actual events in the application (e.g., a method call) as indicators for tracing the execution path of the application.","In some implementations, the back-end provides low-level profiling data to the front-end for higher-level evaluation of the profiling data at the front-end. For example, the server  can provide the raw profiling data to the client . The client  can process the raw profiling data to provide a high-level evaluation thereof. In other implementations, the profiler evaluation module can analyze the complete profiling data for a profiling session. The profiler evaluation module can generate condensed profiling data directed towards the identified time-consuming methods within the profiled application. The server API  can enable the client  by way of network  and client API  to receive the condensed profiling data from the back-end VM . The client  can display the condensed profiling data to a user in a GUI on the display device ","In some implementations, a user can use the controller framework  to start and stop profiling sessions, and to enable profiler traces for a session. For example, the user can determine one or more profiler traces to enable during a profiling session. In a single profiling session, the user may enable an allocation trace that uses the allocation trace module  and a method parameter trace that uses the method parameter trace module .","In some implementations, the controller framework  can enable the server  to specify a thread filter . The thread filter  can include names and identifiers associated with a profiling session for a particular thread (e.g., a thread executing on the back-end VM ) and can indicate the existence of one or more profiler traces for the profiling session. For example, the names and identifiers can be a client identifier, a user identifier, a profiling session identifier, a request identifier, an application name and a component name. By way of non-limiting example, the thread filter  can filter out specific events in the profiling data (e.g., all allocations from a specified thread). In some implementations, the controller framework  can \u201ctag\u201d the names and identifiers to the thread. The server can set the current thread state using the information in the thread filter .","Class filters  can limit the recording of profiling data for a particular trace to a designated method within a class included in the class filters . For example, when enabling an allocation trace in a profiling session, a user can enable a profiler to record allocation trace data for Java object allocations, which refer to instances of the java.lang.HashMap class. The java.lang.HashMap class can be included in the class filter .","A buffer framework  can compress or decompress profiling data. The compressed or decompressed profiling data can be communicated (e.g., sent to the client ) or stored (e.g., placed in a profiling file and stored in database ). For example, in an offline profiling session, the buffer framework  can compress profiling data for storage as a profiling file in database . When requested by a client (e.g., client ), the buffer framework  can decompress the profiling data in the profiling file for communication back to the client (e.g., client ) and subsequent viewing of the profiling data by a user in a GUI on a display device (e.g., display device ).","Communication framework  can facilitate the communication of profiling data and information between and within various components (e.g., elements, modules, systems, servers, VMs, etc.) included in the computer system . Additionally, the communication framework  can determine and facilitate the storing of profiling data (e.g., profiling data in a profiling file stored in database ).","An identification (ID) service  can assign a numerical identifier to an alphanumeric name. For example, the ID service  can assign a numeric identification value to a class name (e.g., java.lang.HashMap class can be assigned the number \u201c101\u201d) creating a numeric ID tag for the class. A numerical identifier can also be assigned to a method, a class and\/or a class loader. For example, because a class, a method and\/or class loader are not just specified by their name (e.g., there can be more classes of the same name, if they are loaded by different class loaders), using just a name to ID mapping would not allow to differentiate between different class, method or class loader of the same name. In some implementations, a mapping packet can map and group classes, methods and\/or class loaders according to their numerical ID tags (e.g., their assigned numerical values). In some implementations, the ID service  can assign numeric IDs to threads. An object identification (ID) service  can assign numeric IDs to objects. The use of numeric IDs can result in improved efficiency and speed during a profiling session as objects, threads, methods and classes can be sorted, grouped and compared using the numeric IDs instead of an alphanumeric name. The use of numeric IDs can also result in decreased memory consumption during a profiling session.","A method parameter trace module  can trace the values of method parameters. For example, a method parameter trace can check if specific parameter values used in a method lead to excessively long execution times for the method. Additionally, a method parameter trace can provide an overview of the parameter values used by the method during the execution of the application in a profiling session.","In some implementations, and as noted above, the raw profiling data can be provided to the front-end from the back-end for higher-level processing. For example, the front-end can process the profiling data to group one or more consecutive methods in a stack trace into a component, and categorize the trace data at the stack level. For example, when a profiling session includes a time-based sampled allocation trace, the memory allocation quantity can be attributed to a stack trace. In other implementations, the higher-level processing can occur at the back-end. For example, a component statistic module  can group one or more consecutive methods in a stack trace into a component. A component can be a specific application programming interface (API) used by the application. Examples of components can be Java components that can include, but are not limited to, a persistence API, a security API, a portal API and a servlet API. The methods in the stack trace can be grouped into components based on a defined \u201centry method\u201d for the component. The component statistic module  can then categorize the trace data at the stack level. The stack trace including methods can be grouped into components, where one or more consecutive methods can be placed into one component group. Each component group can provide allocation statistics for the API associated with the component.","A garbage collection trace module  can trace garbage collection (GC) events in an application. For example, a Java runtime environment can use a garbage collector to perform garbage collection to reclaim no longer needed memory allocated to an object. Once the garbage collector determines that the object is no longer accessible (e.g., when there is no longer any references to it stored in any variables, the fields of objects, or the elements of any arrays), the garbage collector can reclaim the allocated memory. For example, when a Java application no longer references a particular object, a heap space occupied by the object can be recycled so that the heap space can be made available for subsequently created objects.","As discussed in further detail below, the profiling data into sub-regions or snapshots. A snapshot can be a specific timeframe or interval where profiling data was collected. For example, a user can create a snapshot by selecting a corresponding entry within a context menu of a profiling trace entry in a profile view. As another example, the profiling data can be read at the front-end (e.g., after finishing a dialog step) and the user can input a command to create a snapshot. In response, the front-end can send a command to the back-end to create a snapshot of the profiling data. Consequently, the back-end inserts a snapshot marker into the original profiling data. In the case where the user would like to create a sub-snapshot (e.g., a snapshot within a snapshot), or the user would like to create a snapshot from an arbitrary time period, the front-end can identify the corresponding sections, or sub-regions in the original profiling data, and can read the profiling data for that section.","Analysis of profiling data can identify the impact on system performance of individual software modules in an application. For example, profiling data can indicate the percentage of overall runtime for a software module in an application. Optimization of the software modules that contribute a large percentage of the overall runtime can result in marked system improvements with minimal changes. Profiling data can also indicate where within the software module optimization can be performed to improve the module's overall performance in the system.","For example, time-based sampling can provide an overview of methods in an application that consume the most CPU resources. Time-based sampling can provide a stack trace of the currently active thread at regular intervals. Analysis of time-based sampling can identify a method that consumes a large number of CPU or system resources. For example, the consumption of a large number of system resources by the method can be the result of an expensive method call. For example, the consumption of a large number of system resources by the method can also be the result of calling the method often. A method statistic trace, which can be included in a module with trace modules , for example, can determine the number of times a particular method is called. The method statistic trace together with time-based sampling can provide a time method trace that can calculate the average runtime of a specific method (e.g., the \u201ccumulative time\u201d divided by the method count).","For example, memory-based sampling can provide an overview of methods in an application that consume the most memory resources. Memory-based sampling can provide a stack trace after memory is allocated on a memory heap. Memory-based sampling can identify the methods that allocate the largest number of bytes on the memory heap.","Input\/output (I\/O) based sampling can provide an overview of I\/O operations performed and I\/O resources used by methods in an application. For example, operating a network connection at its maximum bandwidth can consume a large percentage of I\/O resources. An I\/O trace, which can be included in a module with trace modules , for example, can trace the timing of I\/O operations in a method. The I\/O trace can provide data about I\/O operations, as well as data about a file being written and\/or the network address\/port being used. Analysis of the I\/O trace data can provide information about I\/O operations that can include, but is not limited to, the amount of data transmitted by an I\/O operation, the amount of CPU resources used by an I\/O operation, and the number of I\/O operations performed by a method. The analysis of the I\/O trace data can identify I\/O operations that transmit an excessive amount of data. The analysis of the I\/O trace data can identify I\/O operations that consume an excessive number of CPU resources. The analysis of the I\/O trace data can identify if a method performs an excessive number of I\/O operations.","Synchronization monitoring of a software application can provide information related to multithreading and concurrency. For example, problems associated with multithreading and concurrency can include, but are limited to, deadlocks, race conditions, thread starvation and scalability. In some implementations, a monitor trace, which can be included in a module with trace modules , for example, can identify deadlock and scalability issues in an application by acquiring information about the locks used in a VM. Synchronization monitoring can provide an overview of the most contented locks within an application. In this manner, a user can be made aware of which threads are waiting (e.g., threads that explicitly call wait( ) on a Java object\/monitor) and which threads are blocked (e.g., threads that want to enter a monitor section), as well as how long the threads are typically waiting and\/or blocked. Further information can be provided with regard to the waiting and\/or blocked threads. For example, culprit threads can be identified, a culprit thread being a thread that is holding the desired locks.","In some implementations, software profiling can provide additional application debugging functionality. For example, a method count trace, which can be included in a module with trace modules , for example, can provide the number of calls to a particular method. An execution line trace, which can be included in a module with trace modules , for example, can provide information regarding the number of lines of executed and unexecuted application source code. A method call trace, which can be included in a module with trace modules , for example, can provide the methods called by an application.","In some implementations, a method trace can be implemented to trace an application debugging process. The method trace, which can be included in a module with trace modules , for example, can trace the application program flow to a designated point in the source code. The method trace can provide information as to how the application program reached the designated point in the source code.","Referring to , the client  can provide a GUI to a user for display on display device that can allow the user to start, stop and control profiling sessions in the back-end profiler using the client API  in communication with the server API  by way of network . Additionally, the server API  can provide the client API  by way of network  profiling data to display to the user in a GUI on the display device . The user can access and evaluate the displayed profiling data. In some implementations, a guided mode can identify problem areas indicated by the profiling data. In some implementations, the profiling data can be stored as a profiling file in the database  in the computer system . In some implementations, the profiling data can be stored as a file in a file system included on the client . Storing of the profiling data can allow for subsequent retrieval and analysis.","The client  and the client  can connect to the computer system  by way of the network . In some implementations, the back-end profiler can perform in compliance with both the client  and the client , simultaneously, while remaining multiple client compliant. The back-end profiler can restrict profiling sessions to particular clients, while the server  can assign the current client information to its respective thread.",{"@attributes":{"id":"p-0080","num":"0079"},"figref":["FIG. 4","FIG. 2"],"b":["400","212","108","402","404","405","406","404","407"],"i":"a "},"If, in step , if it is determined that the profiling session is not an online profiling session, offline (e.g., non-interactive) profiling is performed in step . The offline profiling session continues until stopped. In step , it is determined whether the offline profiling session is to be stopped. Whether the offline profiling session is to be stopped can be determined based on a user input at the front-end. If the offline profiling session is not to be stopped, the offline profiling session continues in step . If the offline profiling session is to be stopped, the front-end profiler requests the profiling data in step . In step , the profiling data can be analyzed by the front-end profiler. In step , which can be provided as an option, the profiling data can be stored locally in the client for future use by the front-end profiler (e.g., front-end profiler ).","In some implementations, a front-end profiler can provide a user with tools for analyzing profiling data (e.g., resource consumption information) gathered by a back-end profiler. The tools can be included in the front-end profiler. The tools can provide a GUI to the user (e.g., referring to , a GUI can be displayed on display device ). The GUI can allow the user to select criteria for grouping and managing the profiling data in an efficient and meaningful way in order to simplify the analysis of the profiling data.","For example, the IDE of the software development platform (e.g., Eclipse) can be structured into a plurality of perspectives. As used herein, the term perspective refers to a visual container for a set of views and editors for the associated development task that can properly structure and arrange the views, and can be analogous to a page within a book, for example. Examples of perspectives can include, but are not limited to, a perspective for implementing a software application, a debug perspective for debugging functionality, a test perspective for implementing software application testing, and a profiler perspective for profiling functionality. The platform can associate a development task (e.g., source code implementation, debugging, testing, profiling) with a dedicated perspective. The development framework can provide an interface for combining user-made perspectives together with their related content. For example, the development framework can provide a GUI to display to a user on a display device that can combine a profiler perspective with profiling data.","The IDE of the software development platform (e.g., Eclipse) can provide the functionality to execute or debug a software application by providing one configuration framework for executing the application and another configuration framework for debugging the application. Both configuration frameworks can describe the selected application (e.g., a main class to start, start-up parameters, etc.). Another configuration framework can be included to profile an application, and provides a user interface framework that can start a profiling session.","In some implementations, multiple configuration framework types can be provided. Example configuration framework types can include an application configuration framework, a profiling file analysis configuration framework, and a remote profiling configuration framework. The application configuration framework can specify an application (e.g., a Java application) for profiling together with profiling parameters. For example, the application configuration framework can enable a user to execute an application with a profiling session already started. A user can profile the application directly from the start of execution of the application.","Referring now to , a screen-shot  illustrates an exemplar profiler perspective for a VM. As described above, a development framework can provide a GUI to display to a user on a display device, as illustrated by the screen-shot of , for example, that can combine a profiler perspective with profiling data. The screen-shot of  illustrates a portion of an exemplar profiling lifecycle , for which a snapshot is provided between a starting point  (e.g., at 1 minute, 40 seconds) and an ending point  (e.g., at 5 minutes). The snapshot functionality is described in further detail below. The profiler perspective can include a profiler view  for a profiling session (e.g., the Example profiling session).","Referring again to , the profiling file analysis configuration framework can provide a user with a GUI on a display device (e.g., display device ) in order for the user to specify a profiling file for display. As previously described, a profiling file can include collected profiling data. The profiling file can be in a database on a server (e.g., database ) or in a file system on a client (e.g., client ). For example, the IDE can save profiling data from an interactive profiling session in a profiling file on the client that includes the IDE (e.g., client ). For example, profiling data from a non-interactive profiling session can be saved in a profiling file included in a database (e.g., database ) included on a server (e.g., server ). For example, the front-end profiler can provide the back-end profiler specific profiling parameters that enable traces to begin directly on the start-up of the application for profiling in the back-end VM . The profiling data can be stored in a profiling file on database . A user on a client (e.g., client ) can view the profiling file on a display device (e.g., display device ) by generating a profiling file analysis configuration framework.","With further reference to , the remote profiling configuration framework can allow a user to specify a connection (e.g., a host name and port number) to the VM (e.g., back-end VM ) for profiling. For example, as previously described, a back-end profiler (e.g., back-end profiler ) can open a debugging port to a back-end VM (e.g., back-end VM ) when a front-end profiler (e.g., front-end profiler ) initiates an online profiling session with the back-end profiler (e.g., back-end profiler ).","Referring now to , a screen-shot  illustrates an exemplar GUI that can be used to configure a profiler and start a profiling session. For example, and with co-reference to , a user can select to profile an application (e.g., Java application: Example ) running on the back-end VM  using back-end profiler . The user can select to analyze the performance behavior of the application (e.g., the user can select Performance Hotspot Analysis ). The performance behavior of the application can involve method calls and execution paths, which can consume the majority of the CPU resources. The profiling data can include the method calls and execution paths used by the application. In order to profile the application, a user can create an application configuration framework in an IDE running on a client (e.g., client ). As described, the application configuration framework can allow the user to execute the application with a profiling session already started. The user can profile the application directly from the start of execution of the application. Within the application configuration framework, a user can specify a class containing the main method of the application and enable a performance hotspot analysis profiling trace. The performance hotspot analysis profiling trace can provide the user with information that can indicate performance hotspots within the application.","Analysis options  can include information such as a user name or identifier option , a session name or identifier option , a request name or identifier option and an application name or identifier option . For example, the analysis options  can indicate the user, session, requester or application that can start a profiling session. A server (e.g., server ) can tag one or more threads running on a VM (e.g., back-end VM ) with the analysis options . When a profiling session is started (e.g., a user on client  interfaces with a GUI on display device to enable the front-end profiler to initiate a profiling session), a thread filer (e.g., thread filter  in ) included in the a back-end profiler (e.g., back-end profiler ) can process the analysis options . The thread filter (e.g., thread filter ) and the back-end profiler (e.g., back-end profiler ) can determine, for example, if the user name or identifier option matches the user of the client .","In some implementations, the analysis options  can be alphanumeric names associated with each option (e.g., options -). In some implementations, an abbreviated numeric identifier can be used for each option (e.g., options -) where each abbreviated numeric entry corresponds to a longer alphanumeric entry for the options -","Referring again to , once a server (e.g., server ) begins the execution of an application in a VM (e.g., back-end VM ), a back-end profiler (e.g., back-end profiler ) can monitor at regular intervals what the application is executing. For example, back-end profiler can record profiling data that includes a complete stack trace for all threads running in the application on the back-end VM . The server API  by way of network  and client API  can transfer the profiling data to the front-end profiler . For example, in order to obtain an accurate view of the performance behavior of the application, the back-end profiler can perform and record a stack trace computation every ten milliseconds. This can result in the back-end profiler recording and transferring a large amount of profiling data to the front-end profiler especially when the application is large and executes for a prolonged period.","In some implementations, the front-end profiler can maintain profiling data it receives in main memory on the client . In some implementations, if the front-end profiler receives a large amount of profiling data compared to the available amount of main memory on the client , the front-end profiler may store the profiling data in a file on the file system of the client . In this case, some statistical or aggregated profiling data values (e.g., the profiling session duration time) may be presented to the user on a real-time basis in a dedicated profile view (e.g., profile view  in ) included in the IDE of the software development environment on the client . The remaining profiling data can be stored in a file on the file system of the client  for later viewing and analysis by the user in a GUI on display device ","Referring now to , a screen-shot  illustrates an exemplar method statistic view  included in a profiler perspective. The method statistic view  can be used to identify performance hotspots, and provides an overview of the methods that consume the most CPU resources of an application. As described above, a performance hotspot analysis can dump a stack trace of the currently active threads at regular intervals (e.g., every 10 milliseconds). For each method, the front-end profiler (e.g., front-end profiler ) can calculate the percentage of how often a method appears on the top of the stack trace. This percentage can be the self-time for the method. The front-end profiler (e.g., front-end profiler ) can use the method self-time to estimate the amount of time the application spends processing the method. Additionally, for each method, the front-end profiler (e.g., front-end profiler ) can calculate the percentage of how often a method appears at any location in the stack trace. This percentage can be the total time for the method and can denote the amount of time the application spends processing the method, which includes any calls the method made to other methods.","In the example of , a user can select a called methods (hierarchical) entry point. A profiler perspective on a front-end profiler (e.g., front-end profiler ) can open the method statistic view . The method statistic view  can include a hierarchical list of methods called during the snapshot of the performance analysis (e.g., a method statistic of a performance hotspot statistic). The method statistic view  can list the called methods based on the total run time of each of the called methods during the snapshot of the performance analysis.","For example, a profiler can create a statistic view for each entry point. The profiler can determine the statistics for display in the statistic view by parsing original profiling data included in a profiling file. For example, a profiling file can be stored on a file system of a client (e.g., client ) running a front-end profiler (e.g., front-end profiler ). A front-end profiler (e.g., front-end profiler ) can parse original profiling data in the profiling file, determine requested data for display in a statistic view based on the entry point for the snapshot, and provide the requested data for the statistic view. The requested data for the statistic view can be stored in main memory for use by the front-end profiler (e.g., front-end profiler ) and can be stored in a file on the file system. When the front-end profiler (e.g., front-end profiler ) closes the statistic view, the front-end profiler (e.g., front-end profiler ) can delete the profiling data for the statistic view from the main memory of the client, leaving the stored data for the statistic view in a file on the file system. If the front-end profiler (e.g., front-end profiler ) reopens the statistic view, the front-end profiler (e.g., front-end profiler ) can read the data for the statistic view from the stored file without the need to parse the original profiling file.","For example, original profiling data received by a front-end profiler (e.g., front-end profiler ) from a back-end profiler (e.g., back-end profiler ) can include stack trace information for all threads running on a VM (e.g., back-end VM ). The back-end profiler (e.g., back-end profiler ) can sample and record the stack thread information for a stack trace at pre-defined intervals (e.g., every 10 msecs). More specifically, a stack trace includes several stack frames, each stack frame including the individual methods and corresponding line numbers. When the states of the threads are sampled, a complete stack trace is determined for each individual thread. This occurs at the pre-defined interval (e.g., every 10 msecs) depending on the underlying operating system. In order to determine the runtimes of the individual methods, the pre-defined interval is accounted to each stack frame (e.g., the actual method and corresponding line number) of a stack trace. More specifically, the runtime of a method is separated into a self time and a total time. The self time indicates the time spent directly within a specific method, whereas the total time indicates the time spent within a specific method plus the time spent in called methods. Accordingly, if a sampled stack trace is determined, the pre-defined interval (e.g., every 10 msecs) is accounted to the total runtimes of each individual stack frame. The method at the top of the stack trace includes the pre-defined interval added to its self time.","The above-described process can be time consuming dependent on the amount of profiling data. The amount of profiling data can depend on the size of the application running on the VM (e.g., back-end VM ) along with the amount of time the application is running while being profiled. However, the amount of memory required for storing the resultant method statistic can be significantly smaller than the amount of memory required for storing the original profiling data.","The original profiling data provides the complete stack trace for each individual thread. The method statistic can include aggregated data from the original profiling data. The method statistic can provide an overview of the total runtime for each method. Referring again to , an exemplary method statistic view  in a profiler perspective is shown. For example, a front-end profiler (e.g., front-end profiler ) can display to a user the method statistic view  on a display device (e.g., display device ) on a client (e.g., client ). The front-end profiler (e.g., front-end profiler ) can store the aggregated data of the method statistic in main memory to a file located on the client (e.g., client ). When the user closes the method statistic view , the aggregated data of the method statistic can be removed from main memory on the client (e.g., client ) but can still remain on the client (e.g., client ) in a file on the file system of the client (e.g., client ). When the user selects the method statistic entry point, the front-end profiler (e.g., front-end profiler ) can display the method statistic view  on the display device (e.g., display device ) to the user. The front-end profiler (e.g., front-end profiler ) can obtain the aggregated data of the method statistic from the stored file on the file system of the client (e.g., client ) without the need to recreate the method statistic from the data included in the original profiling file. This can save the front-end profiler (e.g., front-end profiler ) a significant amount of processing time.","In some implementations, the front-end profiler (e.g., front-end profiler ) can store the aggregated data for the method statistic along with the method statistic view. Storing the method statistic view can include storing the last state of the view prior to the user closing the view (e.g., storing the sort directions, the selection state, the expanded state of trees, etc.). When the user selects the method statistic entry point, the front-end profiler (e.g., front-end profiler ) can display the method statistic view (e.g., method statistic view ) on the display device (e.g., display device ) to the user in the state that the view was in when the user previously closed the view.","In some implementations, a front-end profiler (e.g., front-end profiler ) can store profiling data for a profiling session in a file system on a client (e.g., client ). When a user closes the IDE of the software development platform (e.g., Eclipse), the profiling data can remain in the file on the file system. Additionally, the state of the IDE when closed can also be saved. When the user reopens the IDE, the complete state of the GUI for the IDE can be restored (e.g., profiling sessions, opened views, view states, available statistics, etc.) along with the profiling data for the profiling session.","Referring now to , a screen-shot  illustrates an exemplar graphical user interface (GUI) used to configure a profiler and start an alternative profiling session. For example, and with co-reference to , a user can select to profile an application (e.g., Java application: Example ) running on the back-end VM  using back-end profiler . The user can select to analyze application execution to identify memory related problems (e.g., the user can select Allocation Analysis ). In order to profile the application, the user can create an application configuration framework in an IDE running on a client (e.g. client ). As described, the application configuration framework can allow the user to execute the application with a profiling session already started. The user can profile the application directly from the start of execution of the application. Within the application configuration framework, a user can specify a class containing the main method of the application and enable an allocation analysis profiling trace. The allocation analysis profiling trace can provide the user with information related to the memory consumption by the application.","Referring now to , a screen-shot  illustrates an alternative exemplar method statistic view  included in a profiler perspective is shown. Once the profiling session is complete, a user can select a view for a method statistic. A profiler perspective on a front-end profiler (e.g., front-end profiler ) can open the method statistic view . The method statistic view  can display the methods in an application that performed memory allocations during the profiling session.","In some implementations, a profiler perspective can present a plurality of views to a user. Each view can include specific statistics about a profiling session. A front-end profiler (e.g., front-end profiler ) can uniquely identify and describe the statistics in the view. The unique identification of the statistics can allow a user to navigate from one statistic to other statistics.","For example, using an arbitrary number of navigation steps, a user can start at a first statistic in a first view. The front-end profiler (e.g., front-end profiler ) can generate the first statistic from a first set of first profiling events identified in the profiling data. The user can select an arbitrary number of displayed entries for the first statistic from the first view. The user can navigate to a second statistic in a second view. The front-end profiler (e.g., front-end profiler ) can generate the second statistic for the second view from a second set of second profiling events. The second set of second profiling events can include the first profiling events minus the constraints introduced by the selection of the items from the first statistic in the first view. A user can continue to select an arbitrary number of displayed entries from one view and navigate to a next view. The front-end profiler (e.g., front-end profiler ) can efficiently describe the statistic for each view in an abstract and unique manner to reflect the path to the statistic.","In some implementations, a resource name can uniquely describe a statistic for a profiler in an abstract manner. The resource name can include one or more resource name elements. A resource name element can describe a constraint or filter used to determine the set of profiling events.","For example, a profiling session can produce profiling data that refers to memory allocation events. The front-end profiler (e.g., front-end profiler ) can generate a method statistic from a first set of first profiling events identified in the profiling data. A view for the method statistic can display to a user all methods in which memory allocations occurred.  shows an exemplar method statistic view . The front-end profiler (e.g., front-end profiler ) can apply a type of filter to the profiling data that filters out all methods in which memory allocations occurred. The resource name for the method statistic can include a single resource name element (e.g., \u201cMethod Statistic\u201d). The user can select a method from the method statistic view (e.g., java.util.AbstractList.Iterator( )) and navigate to a view for an allocated object statistic for the selected method. The allocated object statistic view can show the type (e.g., class) of allocated objects created by the selected method as well as allocated objects created by one or more methods called from the selected method. The resource name for the allocated object statistic can include the resource name elements of the parent statistic plus additional resource name elements. For example, the resource name for the allocated object statistic can include the resource name element for the method statistic (e.g., \u201cMethod Statistic\u201d), a filter resource name element for the selected methods (e.g., \u201cjava.util.AbstractList.Iterator( )\u201d), and a resource name element for the allocated object statistic (e.g., \u201cAllocated Object Statistic\u201d).","The user can select one or more allocated object types from the allocated object statistic view (e.g., allocated objects for string functions) and navigate to a view for a thread statistic. The thread statistic view can show the threads where the objects selected from the allocated object statistic are allocated. For example, the resource name for the thread statistic can begin with the resource name elements of the parent statistic (the view that the user selections originated from (e.g., the allocated object statistic)). Additionally, a filter resource name element for the allocated object statistic (e.g., \u201cString Functions\u201d) and a resource name element for the thread statistic (e.g., \u201cThread Statistic\u201d)) can be appended to the resource name elements of the parent statistic.","As shown in the above examples, a naming scheme for a resource name can directly reflect the navigation steps of the user (e.g., resource name: Method Statistic_java.util.AbstractList.Iterator( )_Allocated Object Statistic_String Functions_Thread Statistic). The resource name can uniquely describe a statistic. For example, a user can compare profiling statistics by comparing the resource elements in their resource names. In this manner, a user can identify identical profiling statistics.","For example, a front-end profiler (e.g., front-end profiler ) can create a third profiling statistic from a selection within a second profiling statistic where the second profiling statistic was created by a selection from within a first profiling statistic. In some implementations, the front-end profiler (e.g., front-end profiler ) can create the third profiling statistic by starting with the original profiling data and creating the first profiling statistic by applying a first filter for the first profiling statistic to the original profiling data. Applying the first filter for the first profiling statistic to the original profiling data can filter out profiling events in the original profiling data that do not meet the requirement for selection for the first profiling statistic. This results in a first set of profiling events. The front-end profiler (e.g., front-end profiler ) can create a second profiling statistic from the first profiling statistic by applying a second filter for the second profiling statistic to the first set of profiling events resulting in a second set of profiling events. The front-end profiler (e.g., front-end profiler ) can create the third profiling statistic from the second profiling statistic by applying a third filter for the third profiling statistic to the second set of profiling events resulting in a third set of profiling events. If a user chooses a navigation depth through the profiling data of n times, the profiling data and resultant profiling events are parsed n times. This can consume a large amount of system resources.","In some implementations, a software component for creating profiling statistics can be included in a front-end profiler (e.g., front-end profiler ). The profiling statistic creator software component can parse a resource name to compute the filter constraints used to create a view for a statistic described by the resource name. For example, a resource name can include one or more resource name elements for filtering threads. The profiling statistic creator software component can parse the resource name, extract all filter elements from the resource name and create a single thread filter. Additionally, the profiling statistic creator software component can parse the resource name and group resource name elements of the same type to create a single filter. In this case, if a user has chosen a navigation depth through the profiling data of n times, the profiling statistic creator software component can parse the profiling events once, check each profiling event and determine if all of the filter types apply to the profiling event. Additionally, the profiling statistic creator software component can group resource name elements of the same type to create a single filter for each type in order to create the profiling statistic.","In some implementations, a JVM profiler can profile a Java application running on a local or remote host. Within a remote profiling session, a user can directly connect to the JVM. The user can interactively configure the profiling session and request profiling data. For example, the user can request a class statistic and directly see a view of the class statistic on a display device on the local host that includes a front-end profiler (which can be a plug-in to a software development environment (e.g., Eclipse)). As previously described, the profiling events for a statistic can be used as an input for additional requests for statistics.","Referring again to , and as discussed above, a profiler can be implemented to track the resource consumption and collect corresponding profiling data for an executing application. The profiling data can be collected at the method level (e.g., data regarding memory usage and CPU load corresponding to each method called in an executing application can be collected). In some implementations, an allocation trace is provided, in which a profiler (e.g.,) tracks every allocation in the profiled application, including a method call stack. The method call stack is a stack data structure that stores information about the active methods of an application. More specifically, the method call stack includes active methods of a thread, which thread can be a thread used by a particular application. The allocation trace enables direct and indirect profiling data (e.g., memory consumption) to be attributed on a method-by-method basis at the method level. An exemplar flat representation of memory consumption profiling data is illustrated in .","As seen in the exemplar memory consumption profiling data of , the top-most methods include those doing the most memory allocations during one click in an application server, for example, and are called by a component involved in a request generated upon activation of the component. A component can include an object having a graphical representation that can be displayed on a screen, and through which a user can interact with the executing application. Examples of components include buttons, checkboxes, and scrollbars of a GUI. The exemplar illustration of  provides a fine, method-by-method view of the profiling data. The illustration of , however, does not provide more coarse profiling data information (e.g., how much memory was used for database queries, a cache, or a web container).","With particular reference to , the present disclosure provides component statistics that enable a more coarse view of profiling data. More specifically, instead of viewing the profiling data at the method level, implementations of the present disclosure enable the profiling data to be viewed at the component level (e.g., on a component-by-component basis). Starting from the exemplar illustration of , a user may be interested in splitting the profiling data, in this case memory allocation, between a web container, a database, and the like, for example. This cannot be accomplished by categorizing the allocating methods in one category, because not all of the called methods can be attributed to one component.","The component statistic of the present disclosure works at the stack level, and not the method level. More specifically, and in the exemplar case of the allocation trace or time-based sampling, the measured quantity can be attributed to a method call stack. Using the method call stack, a statistic can be generated on a method-by-method basis, as illustrated in . Implementations of the present disclosure enable the method call stack to be transformed to a component call stack, wherein each component in the stack includes one or more of the called methods. In this manner, the profiling data can be attributed to one or more components by grouping a set of methods in the method call stack into one component. Consequently, each component includes the aggregate profiling data of one or more methods that are assigned to the component.","With particular reference to , an exemplar method call stack  is illustrated and includes a plurality of methods  that are called during the execution of a corresponding exemplar application. The exemplar methods  include Method  to Method , where Method  is the first called method during execution of the application, and Method  is the last called method. Accordingly, the exemplar method call stack  of  is read in sequential order from the bottom up, with the bottom-most method being the earliest called method , and the top-most method being the latest called method .","As discussed in detail herein, a component call stack  can be provided based on the method call stack . More specifically, the component call stack  can be generated based on the method call stack , or the method call stack  can be transformed into the component call stack . The component stack trace  includes a plurality of components  (e.g., Component X, Component Y), and a special component \u2032 (e.g., Other). Beginning with the method call stack , consecutive methods  are grouped based on a corresponding component , as discussed in further detail below into a group. In the exemplar illustration of , there is no component corresponding to Method  through Method . Consequently, Method  through Method  are grouped in Other \u2032. Method  through Method  correspond to Component X , and Method  and Method  correspond to Component Y .","To group the methods  into components , it is first determined which components of a particular application are of interested. For example, an application can include a plurality of components, only a sub-set of which are deemed to be components of interest. Exemplar components can include, but are not limited to, a servlet, an XML parser, a logging framework and a database connectivity driver (e.g., JDBC driver). In some applications, a component can use other components. By way of non-limiting example, a servlet container can use a JDBC driver and\/or an XML parser. A user may be interested in partitioning the complete application. Consequently, a set of components can be selected that do not greatly overlap (e.g., are not all sub-components of a component). In some implementations, for example, a user can partition an application into servlet components and web service components, and another application into XML parsing components, logging components and database access components.","For each component identified as a component of interest, an entry method \u2032 is defined. An entry method is a method by which a component is assumed to be entered. More plainly, an entry method is the first called method for a particular component. By way of one non-limiting example, a servlet component can be entered by a doPost( ) method. In this example, the doPost( ) method is defined as an entry method. The definition of the entry methods defines the quality by which the components can be subsequently determined. In the example illustration of , Method  and Method  are defined as entry methods \u2032.","An entry method can be identified in one of several non-limiting manners. In some implementations, entry methods can be identified by reviewing the specification of well specified components (e.g., in the case of servlets, the standard specifies the methods by which a servlet is entered). In some implementations, entry methods can be identified as all of the methods of a class or package of interest. This can be done if the number of entry methods may be large or there is no clear specification (e.g., in the case of an XML parser, several methods can be considered as entry methods). In such instances, the entry methods can be specified using a filter. For example, the filter can indicate that all methods of classes that are in the javax.xml or one of its sub-packages are considered to be entry methods. Entry methods can also be identified by inspecting the source code of the application, and\/or by inspecting the method tree of an allocation or method trace.","To provide a component call stack from a method call stack, the methods are examined in the order called. In the exemplar case of , the methods are examined from the bottom up. If the currently considered method is defined as an entry method, it is assumed that a corresponding component begins with that method. In this case, every method above the entry method in the method call stack is assigned to the particular component until a subsequent entry method is encountered. In the exemplar illustration of , Method  is the first encountered entry method, and Method  is the next encountered entry method. Consequently, Component X includes Method  through Method , and Component Y includes Method  and Method . In this exemplar case, Method  is the last called method in the application. Accordingly, a method called immediately prior to an entry method is implicitly provided as an exit method (i.e., the last called method of a particular component). Because none of Method  through Method  is defined as an entry method, these methods are assigned to the special component (i.e., Other). If, however, no method in the method call stack is identified as an entry method, the entire method call stack is assigned to the special component (i.e., Other).","The benefit of using only a set of entry methods to define a component is that only a limited number of methods is required. This is substantial, considering that the overall number of methods for an application can include hundreds, thousand or even millions of methods). By using only a set of entry methods, it is feasible to define a component. In accordance with some implementations, utility methods are automatically assigned to the component calling them. In some implementations, exit methods can be explicitly defined, each exit method being the last method to be called when a component ends. The granularity of the components can be changed by adding or deleting components that describe more specific uses. For example, in the case of an HTTP servlet component, one definition can include the \u2018doPost\u2019 and \u2018doGet\u2019 method calls. If, however, only the \u2018doPost\u2019 method is included in the definition, the component would only include servlets called by a POST HTTP request, and not by a GET HTTP request.","Referring now to , the component call stack can be used to generate flat and\/or hierarchical component statistics.  is an exemplar screen-shot  illustrating a flat component statistic view, and  is an exemplar screen-shot  illustrating a hierarchical component statistic view. To generate the component statistic views, the collected profiling data can be parsed on a component-by-component basis, wherein the profiling data of a particular component corresponds to the aggregate profiling data of the methods that make up that component. Because the component call stack is based on an original method call stack, it is always possible to go from the component call stack back to the method call stack to provide a method-by-method statistic view, such as that illustrated in .","Referring now to , exemplar steps that can be executed in accordance with implementations of the present disclosure will be described. The exemplar steps of  can be executed using one or more processors coupled to a computer-readable storage medium at a computer system (e.g., the computer system  including server ) and\/or a client device (e.g., the client devices , ). In step , an application is executed. For example, the application can be run on the back-end VM  on the computer system . In step , profiling data is collected. The profiling data can be collected using the profiler running on the back-end VM , for example. A method call stack is generated in step . The method call stack can be generated by the profiler running on the back-end VM , for example.","In step , the component call stack is generated based on the method call stack. Exemplar steps that can be implemented to perform this generation will be described with reference to . In step , component statistics are generated based on the component call stack and the profiling. More specifically, and as discussed above, the component statistics provide profiling data on a component-by-component basis. The profiling data of each component includes aggregates of the profiling data of the methods that make up the particular component. In step , the component statistics are provided for display and the steps end. For example, the component statistics can be transmitted from the computer system  to a client device ,  for display to a user. The component statistics can be transmitted in response to receiving a user input indicating a request for the component statistics.","Referring now to , exemplar steps that can be executed to generate a component call stack based on a method call stack will be described. It is contemplated that steps of  can be performed by the front-end (e.g., client device , ). In some implementations, however, one or more steps of  can be performed by the back-end (e.g., computer system ) for example, and can be based on user input provided to the computer system  from the client device , .","In step , components of interest can be determined. More specifically, a particular component of interest can be identified based on a user input. For example, a user can provide user input to the client device , , which user input can be sent to the computer system . In this manner, the computer system  is made aware of one or more components that the user is interested in obtaining profiling data for. In step , an entry method is defined for each component of interest. For example, a user can provide user input to the client device , , which user input can be sent to the computer system . In this manner, the computer system  is made aware of the entry method for each component of interest. Step  can be provided as an alternative step. In step , an exit method can be defined for each of component of interest. For example, a user can provide user input to the client device , , which user input can be sent to the computer system . In this manner, the computer system  is made aware of the exit method for each component of interest.","In step , a counter n is set equal to zero (i.e., n=0). The counter n indicates a particular method in a method call stack that includes up to N methods. In step , the counter n is incremented by one (i.e., n=n+1). In step , it is determined whether a particular method, method, is an entry method. For example, if n is equal to one (i.e., n=1), it is determined whether the first method in the method call stack is an entry method in step . As another example, if n is equal to five (i.e., n=5), it is determined whether the fifth method in the method call stack is an entry method in step . If the methodis an entry method, the steps continue in step . If the methodis not an entry method, the steps continue in step .","In step , m is set equal to the index of the component, for which methodis defined as the entry method. For example, and with reference to , if n is equal to six (i.e., n=6) methodwould be identified as an entry method of Component X. Consequently, m would be set equal to X in step . In step , methodis assigned to component. In step , it is determined whether n is equal to N. More specifically, it is determined whether n indicates the last method in the method call stack. If n is not equal to N, the steps continue in step . If n is not equal to N, the steps end.","In step , the counter n is incremented by one (i.e., n=n+1). In step , it is determined whether methodis an exit method. If methodis not an exit method, the steps continue in step . If methodis an exit method, the steps continue in step . In step , it is determined whether methodis an entry method of a component that is not the component of index m (e.g., not the currently considered component). If methodis an entry method of another component, the steps continue in step . If methodis not an entry method of another component, the steps continue in step .","In step , methodis assigned to \u201cother\u201d and the steps continue in step . In step , methodis assigned to componentand the steps continue in step . In step , it is determined whether n is equal to N. More specifically, it is determined whether n indicates the last method in the method call stack. If n is not equal to N, the steps loop back to step . If n is not equal to N, the steps end.","Referring now to , a schematic illustration of exemplar hardware components  that can be used to execute implementations of the present disclosure is provided. The system  can be used for the operations described in association with the methods described in accordance with implementations of the present disclosure. For example, the system  may be included in the application server . The system  includes a processor , a memory , a storage device , and an input\/output device . Each of the components , , , and  are interconnected using a system bus . The processor  is capable of processing instructions for execution within the system . In one implementation, the processor  is a single-threaded processor. In another implementation, the processor  is a multi-threaded processor. The processor  is capable of processing instructions stored in the memory  or on the storage device  to display graphical information for a user interface on the input\/output device .","The memory  stores information within the system . In one implementation, the memory  is a computer-readable medium. In one implementation, the memory  is a volatile memory unit. In another implementation, the memory  is a non-volatile memory unit. The storage device  is capable of providing mass storage for the system . In one implementation, the storage device  is a computer-readable medium. In various different implementations, the storage device  may be a floppy disk device, a hard disk device, an optical disk device, or a tape device. The input\/output device  provides input\/output operations for the system . In one implementation, the input\/output device  includes a keyboard and\/or pointing device. In another implementation, the input\/output device  includes a display unit for displaying graphical user interfaces.","The features described can be implemented in digital electronic circuitry, or in computer hardware, firmware, software, or in combinations of them. The apparatus can be implemented in a computer program product tangibly embodied in an information carrier, e.g., in a machine-readable storage device, for execution by a programmable processor; and method steps can be performed by a programmable processor executing a program of instructions to perform functions of the described implementations by operating on input data and generating output. The described features can be implemented advantageously in one or more computer programs that are executable on a programmable system including at least one programmable processor coupled to receive data and instructions from, and to transmit data and instructions to, a data storage system, at least one input device, and at least one output device. A computer program is a set of instructions that can be used, directly or indirectly, in a computer to perform a certain activity or bring about a certain result. A computer program can be written in any form of programming language, including compiled or interpreted languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment.","Suitable processors for the execution of a program of instructions include, by way of example, both general and special purpose microprocessors, and the sole processor or one of multiple processors of any kind of computer. Generally, a processor will receive instructions and data from a read-only memory or a random access memory or both. The essential elements of a computer are a processor for executing instructions and one or more memories for storing instructions and data. Generally, a computer will also include, or be operatively coupled to communicate with, one or more mass storage devices for storing data files; such devices include magnetic disks, such as internal hard disks and removable disks; magneto-optical disks; and optical disks. Storage devices suitable for tangibly embodying computer program instructions and data include all forms of non-volatile memory, including by way of example semiconductor memory devices, such as EPROM, EEPROM, and flash memory devices; magnetic disks such as internal hard disks and removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, ASICs (application-specific integrated circuits).","To provide for interaction with a user, the features can be implemented on a computer having a display device such as a CRT (cathode ray tube) or LCD (liquid crystal display) monitor for displaying information to the user and a keyboard and a pointing device such as a mouse or a trackball by which the user can provide input to the computer.","The features can be implemented in a computer system that includes a back-end component, such as a data server, or that includes a middleware component, such as an application server or an Internet server, or that includes a front-end component, such as a client computer having a graphical user interface or an Internet browser, or any combination of them. The components of the system can be connected by any form or medium of digital data communication such as a communication network. Examples of communication networks include, e.g., a LAN, a WAN, and the computers and networks forming the Internet.","The computer system can include clients and servers. A client and server are generally remote from each other and typically interact through a network, such as the described one. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.","In addition, the logic flows depicted in the figures do not require the particular order shown, or sequential order, to achieve desirable results. In addition, other steps may be provided, or steps may be eliminated, from the described flows, and other components may be added to, or removed from, the described systems. Accordingly, other implementations are within the scope of the following claims.","A number of implementations of the present disclosure have been described. Nevertheless, it will be understood that various modifications may be made without departing from the spirit and scope of the present disclosure. Accordingly, other implementations are within the scope of the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIGS. 13A and 13B"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 14"}]},"DETDESC":[{},{}]}
