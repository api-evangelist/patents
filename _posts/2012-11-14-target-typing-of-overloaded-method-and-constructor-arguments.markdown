---
title: Target typing of overloaded method and constructor arguments
abstract: Methods and apparatus for target typing of overloaded method and constructor arguments are described. A method comprises determining whether source code of a program includes, as an argument to an overloaded operation invocation, an expression whose type is context-dependent. The method further comprises, if the source code includes such an argument, providing the expression as an input to an overload resolver, and determining at the overload resolver whether (a) each argument of the invocation is compatible with types of corresponding parameters in one or more declarations and (b) whether a particular declaration among such a set of declarations can be identified as the most specific. If both conditions are met, the method comprises generating executable instructions for the invocation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09524175&OS=09524175&RS=09524175
owner: Oracle International Corporation
number: 09524175
owner_city: Redwood City
owner_country: US
publication_date: 20121114
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF EMBODIMENTS"],"p":["In recent years, object-oriented programming languages such as Java\u2122 have become increasingly popular for a wide variety of applications running on many different types of platforms. Many such programming languages support overloading of invocable operations such as methods and constructors, allowing programmers to create several methods with the same name within a given class, or several constructors for a given class. Within a given set of overloaded invocable operations, the individual operations may differ from one another in various ways\u2014e.g., in the number of parameters, the types of the parameters, or the return types in the case of methods. Support for overloading relieves programmers of the burden of having to make up different names for methods or constructors that provide similar functionality, and therefore should ideally not be forced to have different names. Compilers (or other tools that perform type checking, such as certain kinds of interpreters) for programming languages that support overloading have to perform overload resolution, i.e., they have to determine, for a given invocation, which among a set of overloaded methods or constructors is the appropriate or intended one for which executable code should be generated.","Historically, it is common for many such programming languages to require that the arguments to an invocation (e.g., an invocation of an overloaded method) be completely typed (i.e., that the types of all the arguments be determined) before the invocation can itself be typed by the compiler. However, the type of many constructs that are of increasing interest to programmers, and are therefore being considered for inclusion in various programming languages, such as lambda expressions, may be context-dependent\u2014that is, the type of the construct may differ, depending on the surrounding context in which the construct is used. For example, the same lambda expression \u201c( )\u2192\u201cdone\u201d\u201d has different types in the following two contexts:",{"@attributes":{"id":"p-0004","num":"0003"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"1.","Callable<String> c = ( ) \u2192 \u201cdone\u201d;"]},{"entry":[{},"2.","PrivilegedAction<String> a = ( ) \u2192 \u201cdone\u201d;"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"This may present difficulties when a programming language is to support the use of such constructs as arguments to methods or constructors. Traditionally, the overload resolution component of a compiler relied upon being provided the types of the arguments to an invocation, but such argument type information may not be available when expressions whose type is context-dependent are used as arguments.","Various embodiments of apparatus and methods for target typing of overloaded method and constructor arguments are described. The term \u201ctarget typing\u201d may be used herein to refer to the process of inferring the type of an expression whose type may vary depending on the surrounding context; the type expected in a particular context may be referred to as the \u201ctarget type\u201d. More broadly, in at least some embodiments, the \u201ctarget type\u201d may be considered as the source of type information that allows the type of such an expression to be inferred. For example, using the latter broader definition, if E is the expression being considered, and T is a target type, the equation typeof(E)=f(T) may be generally applicable, where f is some function of the target type (f may be the identity function in some, but not all, cases). According to one embodiment, a system may include one or more computing devices configured to determine, for an overloaded operation invocation (such as an invocation of an overloaded method or an invocation of an overloaded constructor) identified in source code for a computer program, whether the source code includes, as an argument to the invocation, an expression whose type is context-dependent. If the invocation does have such an argument, the expression itself (rather than the type of the expression) may be provided as input to an overload resolver implemented at the computing device(s) in such an embodiment. The overload resolver may then determine whether at least the following two conditions hold: (a) whether each of the arguments of the invocation, including the expression, is compatible with a type of a corresponding parameter indicated in one or more invocable operation declarations (e.g., among the set of overloaded method declarations corresponding to the invocation) identified from the source code and (b) whether a particular invocable operation declaration of the one or more invocable operation declarations is identifiable as the most specific invocable operation declaration for the invocation, based at least in part on one or more specificity criteria defined for the language. Thus, in checking the first condition, the overload resolver may attempt to find a set of candidate method or constructor declarations whose parameter types are compatible with the expression, and in checking the second condition, the overload resolver attempts to select one of the candidate declarations (if any were found) as the most specific declaration (and therefore the declaration inferred to be the intended declaration) to be used to resolve the overloading in such an embodiment.","If both conditions hold, overload resolution may be deemed to have succeeded in such an embodiment, and the computing devices may generate executable instructions for the overloaded operation invocation in accordance with the particular declaration identified as the most specific declaration. If either condition does not hold, the overloading cannot be resolved, and an error indication may be generated in at least some embodiments. If multiple compatible candidate declarations are found (i.e., the first condition holds) in one embodiment, but the overload resolver cannot narrow down the multiple candidates to one most suitable candidate (where the relative suitability of the candidates may have to be determined based on language-dependent specificity criteria), the overload resolution fails, and an error indication (such as an \u201cAmbiguous argument\u201d error message) may be generated. Several different kinds of arguments whose type is context-dependent may be supported in various embodiments\u2014e.g., lambda expressions may be used as arguments, or method references may be used.","In various embodiments, the computing devices may implement a tool such as a compiler or an interpreter, which may be responsible for generating executable instructions corresponding to the source code program. In order to check the first condition, e.g., to find candidate compatible method or constructor declarations, in some embodiments the tool may perform speculative typing analysis. Such speculative typing may involve using one or more potentially complex tests for assignability of an expression, rather than relatively simple tests for assignability of just a type. As part of the analysis, the tool may type an expression as if it appeared in a particular context, and then decide if an error would have occurred. Portions or branches of a parse tree for the source code may be generated speculatively for various candidate target declarations, discarded if found inapplicable, and retained if found applicable. Using this approach, the tool may check, for each of a set of overloaded method or constructor declarations, whether an assignment of the expression to a corresponding parameter of the declaration would fail or succeed. If the assignment would fail, the declaration may be discarded as incompatible. If all the arguments to the invocation can be assigned to corresponding parameters of the declaration without encountering errors, the declaration may be deemed compatible in such an embodiment.","In some embodiments, if a plurality of compatible declarations are found by the tool, further analysis may be conducted in accordance with rules or criteria specified for the language in use, e.g., criteria defined in the programming language specification or in other standards-related documents associated with the language. In one such embodiment, the plurality of candidates may be examined in pairs, with the intent of determining which of a given pair is more \u201cspecific\u201d according to the criteria, and discarding the other declaration of the pair. In cases where the parameters of the declarations can be represented using function descriptors, for example, the tests may first compare the parameter types of the pair of declarations, and if the comparison of the parameter types is insufficient to indicate that one declaration of the pair is more specific than the other, the return types of the function descriptors may be compared. If the tests succeed in identifying a single declaration as the most specific, that declaration may be used for generation of executable code.","It is noted that, while much of the following description refers to the use of a compiler for various operations, similar operations may be performed in some embodiments by a different tool, such as an interpreter, that is also responsible for type checking and overload resolution. For example, an interpreter may consume source code as input (just as a compiler does) and generate executable instructions using similar logic as described below with respect to a compiler. In cases where an interpreter is being used, the generated instructions may be executed forthwith, and may not be stored in a persistent form (e.g., as an executable version of the source program) as they typically would be if a compiler were used. The kinds of errors thrown when overload resolution fails, and the error messages provided, may differ in some cases between the compiler and the interpreter. It is also noted that, while for purposes of illustration, the following description is provided largely in the context of using the Java\u2122 programming language (or a language closely related to Java\u2122), the techniques described may be used for any programming language that supports overloading of invocation operations such as methods, constructors, or functions. The techniques may be used for object-oriented languages in some embodiments, or for non-object-oriented languages (such as various procedural languages) in other embodiments. The term \u201cinvocable operation\u201d may be used herein to refer to methods, constructors, or to methods and constructors collectively. Method invocations, constructor invocations, or method invocations and constructor invocations collectively may be termed \u201coperation invocations\u201d, or simply \u201cinvocations\u201d, herein.",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1","b":["120","110","110","110"]},"The compiler  may analyze the source code  to produce an executable version of the program, such as bytecode files  (e.g., .class files or .jar files in the case of Java\u2122) in the depicted embodiment. Different types of executable code formats may be used in various embodiments; for example, binary machine language may be used instead of bytecodes. In some scenarios, parts of the executable code  may be in bytecode while others are in a native binary machine language. As part of compiling program source code  into executable code , the compiler  may perform a sequence of analysis operations and generate various intermediate data structures before generating the executable version, as described below in further detail with reference to . The compiler  may, for example, identify various method and constructor invocations, analyze the invocations based on the corresponding declarations, and decide, based on the information that can be determined at compile-time, whether a compile-time error should be generated. If a given invocation is determined to be acceptable for compilation, appropriate code may be generated for it.","As illustrated in , executable code  may be passed to an execution environment, such as run-time environment , which executes the code on an execution platform , thereby creating various output data and\/or behavior. In various embodiments, the run-time environment  may include a virtual machine  (e.g., a Java\u2122 Virtual Machine or JVM). The virtual machine  may in turn comprise a number of different components, such as a memory manager  (which may include a garbage collector), a bytecode verifier  to check the validity of the executable code, an interpreter and\/or a just-in-time (JIT) compiler  such as the HotSpot compiler. The JIT compiler may in some embodiments be responsible for translating some or all of the bytecode (for example, heavily-used portions of bytecode) into platform-specific machine code to improve performance of the program execution. A run-time environment , such as the Java\u2122 Runtime Environment or JRE, may also include code to implement a number of application programming interface (API) libraries  in some embodiments. The run-time environment  may run on top of lower-level software such as an operating system  in some embodiments. In embodiments where virtualized compute resources are being used as the execution platform, virtualization software such as a hypervisor may be used to configure the execution platform  for the operating system  (i.e., the operating system may run as an application on top of the hypervisor).","In different embodiments, the output or behavior produced as a result of the execution of the compiled code may include data stored in various levels of system memory (e.g., in-memory objects and\/or data structures), on persistent storage (e.g., files on a file system), etc. The behavior may also include various program functionalities, such as displaying output on a screen, sending messages over a network, and\/or otherwise interacting with various users and\/or components.","In at least some embodiments, a compiler  or a similar tool may support target typing of overloaded method and constructor arguments. The term \u201ctarget typing\u201d may be used herein to refer to the process of inferring a type of an expression whose type may vary depending on the surrounding context (e.g., on the tokens that surround the expression in the source code); the type expected in a particular context may be referred to as the \u201ctarget type\u201d. Expressions whose type is context-dependent may be referred to herein as \u201cpoly expressions\u201d. For an example of a poly expression, consider the constructor expression \u201cnew ArrayList< >( )\u201d in Source Code Example 1 below:","Source Code Example 1",{"@attributes":{"id":"p-0022","num":"0021"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"1.1.","List<String> ls = new ArrayList< >( );"]},{"entry":[{},"1.2.","List<Integer> li = new ArrayList< >( );"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"In the first context (line 1.1), the expression returns a List of Strings; in the second context, it returns a List of Integers. Thus, the type of the expression cannot be determined by examining the expression alone; instead, the context in which the expression appears has to be taken into account.","Some programming languages may support \u201clambda expressions\u201d. Lambda expressions are a lightweight way to describe functions that can be treated as values by a programming language. In the case of some object-oriented programming languages, lambda expressions may be used as a lightweight mechanism for defining objects that have just one method and no state. In at least some embodiments, lambda expressions may be expressed using syntax such as the following:","(argument list)\u2192body","Lambda expressions may be considered examples of poly expressions in at least some languages; in other languages, lambda expressions may simply be normal expressions with a functional (or arrow) type S\u2192T. Source Code Example 2 illustrates three lambda expressions according to one embodiment.","Source Code Example 2",{"@attributes":{"id":"p-0026","num":"0025"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"2.1.","(int x, int y) \u2192 x + y"]},{"entry":[{},"2.2.","( ) \u2192 42"]},{"entry":[{},"2.3.","(String s) \u2192 {System.out.println(s);}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"In line 2.1, the arguments of the lambda expression comprise two integer values, and the body computes the sum of the two values as the return value. In line 2.2, the lambda expression takes no arguments and returns the integer 42. In line 2.3, the lambda expression takes a single String argument, prints it out to the system output, and returns nothing. Note that lambda expression are \u201canonymous\u201d in the depicted embodiment, in that they are not named. Next, consider an example of a lambda expression whose type is context-dependent, according to one embodiment:","Source Code Example 3",{"@attributes":{"id":"p-0028","num":"0027"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"3.1.","Callable<String> c = ( ) \u2192 \u201cdone\u201d;"]},{"entry":[{},"3.2.","PrivilegedAction<String> a = ( ) \u2192 \u201cdone\u201d;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The same lambda expression, ( )\u2192\u201cdone\u201d, can thus have different types depending on the surrounding context. There are at least two ways in which lambda expressions may be context-dependent in at least some programming languages used in various embodiments. First, lambda expressions may produce objects that implement a particular interface, and the interface (and thus the expression) may be context-dependent. Second, in some cases, lambda expressions may have parameters that do not have declared types (e.g., \u201c(x, y)\u2192x+y\u201d). In this latter scenario, the types of the body expressions may also be context-dependent. Lambda expressions are often expected to be used in nested contexts, such as arguments to method invocations or as results of other lambda expressions. The task of target typing for lambda expressions in nested contexts may be somewhat harder than in un-nested contexts such as straightforward assignments.","Lambda expressions enable definition of anonymous methods, and enable treating such anonymous methods as instances of functional interfaces. A similar approach may be used with existing methods as well, using a construct called \u201cmethod references\u201d. According to one embodiment, a method reference may be treated in the same way as a lambda expression, but instead of providing a method body, a reference to an existing method of a class or object may be indicated, e.g., using the following syntax: <ClassName>::<ExistingMethodName>. Source Code Example 4 illustrates one example of a method reference:","Source Code Example 4",{"@attributes":{"id":"p-0031","num":"0030"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"4.1.","class Person {"]},{"entry":[{},"4.2.","\u2003private final String name;"]},{"entry":[{},"4.3.","\u2003private final int age;"]},{"entry":[{},"4.4.","\u2003public static int compareByAge(Person a, Person b) { ... }"]},{"entry":[{},"4.5. ","\u2003public static int compareByName(Person a, Person b) { ... }"]},{"entry":[{},"4.6 ","}"]},{"entry":[{},"4.7.","Person[ ] people = ..."]},{"entry":[{},"4.8.","Arrays.sort(people, Person::compareByAge);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The Arrays.sort call in line 4.8 includes, as an argument, the method reference \u201cPerson::compareByAge\u201d. The method reference in this example may be considered shorthand for a lambda expression whose parameter list is copied from Comparator<String>.compare and whose body calls Person.compareByAge. As with lambda expressions, therefore, a compiler may have to perform target typing for method references passed as arguments in at least some embodiments. Given the similarities in the treatment of lambda expressions and method references, the techniques described for various embodiments below with respect to lambda expressions may also be applied to method references in various embodiments.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 2","FIG. 1","FIG. 2"],"b":["120","110"]},"According to the illustrated embodiment, compiler  may include lexical analyzer , which may be configured to break the input source code into tokens, such as tokens . Each token  may correspond to a single atomic unit of the given language, such as keywords, identifiers, etc. In various embodiments, the token syntax may be represented as a regular language. Compiler  may include preprocessor  in the depicted embodiment, which may be used to support macro substitution in some languages. In some embodiments, preprocessor  may modify various ones of tokens , which may result in a set of modified tokens, such as .","Compiler  may also include a syntactic analyzer  in some embodiments, which may be configured to parse the modified tokens  to identify syntactic structure of the input program. The syntactic analyzer may be configured to build a parse tree, such as parse tree , which may organize the tokens  into a tree structure according to the formal grammar of the programming language of the source code.","In the depicted embodiment, the compiler  may further include a semantic analyzer , which may be configured to add semantic information to parse tree  to create an annotated internal representation of the program, such as intermediate representation . In some embodiments, a code generator, such as code generator , may convert the intermediate representation  into an executable program, such as . Executable program  may be encoded in binary and\/or bytecode and may correspond to executable code  in .","In some embodiments, semantic analyzer  may also build and\/or maintain a symbol table, such as symbol table , which maps various symbols in the source code to associated information, such as the location, scope, and\/or type. The semantic analyzer  may also include an overload resolution module, such as module , to determine which among an overloaded set of methods or constructors is the one for which code should be generated for a given overloaded invocation. In some embodiments, the overload resolution module , which may also be referred to herein as an \u201coverload resolver\u201d, may be a subcomponent of a type checker module of the semantic analyzer. If an overloaded invocation cannot be resolved, a compile-time error may be generated (such as the logical equivalent of \u201cAmbiguous invocation\u201d), and at least in some embodiments the compilation may fail. In some instances, warnings may be generated for certain invocations, instead of or in addition to compile-time errors. In various embodiments, different components of compiler  shown in  may be combined or further deconstructed into multiple components. The compiler may also implement various additional types of functions, such as optimization, line reconstruction, and the like, not shown explicitly in , in some embodiments.","The following example of overload resolution according to one embodiment, in which method arguments do not include expressions with context-dependent types, is provided as a preliminary to the subsequent discussion of the target typing for argument expressions with context-dependent types that may be performed by a compiler  or another similar tool in various embodiments. Consider the following overloaded declarations for a method in one embodiment, followed by an invocation:","Source Code Example 5",{"@attributes":{"id":"p-0039","num":"0038"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"5.1.","void foo(String arg); \/\/ declaration 5.1"]},{"entry":[{},"5.2.","void foo(Integer arg); \/\/ declaration 5.2"]},{"entry":[{},"5.3.","void foo(Number arg); \/\/ declaration 5.3"]},{"entry":[{},"5.4.","void foo(Object arg); \/\/ declaration 5.4"]},{"entry":[{},"5.5.","foo(23); \/\/invocation"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"In this example, the type of the invocation argument (the integer or int ) is not context-dependent. The overload resolver is provided the type of the argument (integer), and tries to find method signatures among the overloaded methods for which the argument type is a subtype, e.g., in accordance to the programming language's type hierarchy (for predefined types and libraries of the language) or in accordance with the source code (for programmer-generated classes). In this case, declarations 5.2, 5.3, and 5.4 have such signatures (foo(Integer), foo(Number), and foo(Object)), so these three are chosen as candidates from which a further selection may be performed to disambiguate the invocation in this embodiment. The first declaration, which has a String argument, is rejected as a candidate because the type of the argument (int) is incompatible with the type of the parameter (String) in the first declaration. From among the compatible candidate signatures, the compiler may select the one that is most \u201cspecific\u201d (where specificity may be defined in the programming language specification or associated documentation, e.g., the method whose parameter type is lower in a type hierarchy than any of the other candidate methods' parameters may be deemed the most specific in some embodiments). In this case, assuming that subtype hierarchy depth is used as the criterion for specificity, since an Integer is a subtype of a Number, and a Number is a subtype of Object, the foo(Integer) declaration may be deemed the most specific and hence the result of the overload resolution process, so executable code corresponding to the foo(Integer) declaration may be generated.","It is noted that while, for simplicity, the majority of the source code examples provided herein cover methods and constructors with a single parameter, the techniques described may be extended to invocable operations with any number of parameters in various embodiments. Thus, for example, the approach described as being taken for target typing a single argument may be repeated N times for target typing of N arguments in some embodiments. In some implementations, overload resolution for different parameters may be performed in parallel.","In contrast to the relatively straightforward example of the overloaded foo method above, where the invocation argument's type was not context-dependent, consider the following example involving an argument to an overloaded method foo2 that is a poly expression.","Source Code Example 6",{"@attributes":{"id":"p-0043","num":"0042"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"6.1.","void foo2(ArrayList<Integer> arg); \/\/ declaration 6.1"]},{"entry":[{},"6.2.","void foo2(Set<Object> arg); \/\/ declaration 6.2"]},{"entry":[{},"6.3.","foo2(new ArrayList < >( )); \/\/invocation"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Here, unlike in the case where \u201c23\u201d was passed as an argument in Source Code Example 5, the type of the argument expression (new ArrayList< >( )) cannot be determined simply by examining the expression. As a result, at least in some embodiments, the overload resolver component of a tool such as a compiler or interpreter may be provided the argument expression itself as input (instead of, for example, being provided the type of the argument as input). The overload resolver may examine the poly expression argument speculatively, testing for compatibility with the different parameter types of the overloaded declarations, as described in more detail below. Such an approach may be termed \u201cspeculative typing\u201d herein.","Generally speaking, type checking may be considered a routine that progressively attaches type information to the nodes of a parse tree that is internally used by a compiler or similar tool to store information about a source program. Such a tree may be initially blank\u2014i.e., no type information may be contained within it; type checking may be thought of as \u201ccoloring\u201d this tree with the appropriate type information. After type information is added to the tree for a given expression, it can later be used to perform other useful checks without re-examining the entire expression. In a simple scenario like the foo(23) example above, the parse tree would be colored with the type information (int) for \u201c23\u201d. This would mean that checking as to whether a method is applicable or not may simply amount to checking whether the type information associated with the expression \u201c23\u201d is compatible with the type information associated with a formal parameter of the method. The type information (int in this case) would itself be passed to the overload resolution module of the type checker. In a more complex example such as foo2(new ArrayList < >( ));, speculative typing may be required in some embodiments. During speculative typing, a target type T may be selected from one of the method declarations, and a copy of the initially-blank parse tree for the expression may be colored under the assumption that the target type is T. That is, type checking may be speculatively performed for the statement T t=new ArrayList < >( ); This may be done in some implementations by passing the argument expression itself (not the type of the argument) as well as the type T as parameters for overload resolution. One significant difference between the two examples is that in the first example, \u201c23\u201d is type checked only once, regardless of the number of overloads. In the second example, in at least some embodiments, \u201cnew ArrayList< >( )\u201d may have to be type checked once for each overloaded method\u2014hence the term \u201cspeculative typing\u201d. (It is noted that in some implementations, optimizations to reduce the number of speculative type checks may be feasible). Several passes on the parse tree may thus be performed in such embodiments without knowing exactly which version of the tree will be retained at the end of the resolution process.","In some embodiments, separate branches of a parse tree representation of the program may be generated in the manner described above for speculative typing, corresponding to each overloaded declaration. In such embodiments, the branches corresponding to the declarations found incompatible may be discarded, while the branches corresponding to the declarations found compatible may be retained for a subsequent phase of overload resolution. The test for compatibility may be considered logically equivalent to determining whether an assignment of the expression to the parameter would result in an error: e.g., in this example, would the assignments \u201cArrayList<Integer> arg=new ArrayList< >( );\u201d and \u201cSet<Object> arg=new ArrayList< >( );\u201d succeed, or result in an error. If the assignment would not result in an error, the corresponding declaration may be deemed a candidate for the next phase of overload resolution (in which, if more than one candidate is found, one particular candidate is selected as the most specific declaration or the inferred intended declaration). If the assignment would result in an error, the corresponding declaration may be rejected as a candidate for further consideration. In the above example of method foo2, declaration 6.2 would be rejected (as the corresponding assignment would not succeed), while declaration 6.1 would be selected as a candidate. If only one candidate declaration were found, that declaration would be selected as the most specific or most appropriate declaration, and the process of target typing of the argument would conclude, in at least some embodiments. If no candidate were found, overload resolution would fail, and an error indication may be generated (e.g., an \u201cIncompatible argument\u201d message or similar error message may be provided) at least in some embodiments.","The process of selecting candidate declarations is described in more detail below with respect to the description of . If more than one candidate declaration is found, a second phase of overload resolution may be initiated in some embodiments, in which an attempt to identify the single most specific or most appropriate candidate from among the set of candidates is made, e.g., using one or more specificity criteria. Further details regarding this phase for specific kinds of argument expressions are provided below in conjunction with the description of . It may be the case that no single most specific candidate may be found, in which case the second phase of the overload resolution may end in failure, and in some embodiments an error indication may be provided (e.g., a message such as \u201cAmbiguous invocation detected\u201d may be generated). Source Code Example 7, a slight variation on Source Code Example 6, illustrates one such scenario.","Source Code Example 7",{"@attributes":{"id":"p-0048","num":"0047"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"7.1.","void foo3(ArrayList<Integer> arg); \/\/ declaration 7.1"]},{"entry":[{},"7.2.","void foo3(Set<Object> arg); \/\/ declaration 7.2"]},{"entry":[{},"7.3.","void foo3(List<String> arg); \/\/ declaration 7.3"]},{"entry":[{},"7.4.","foo3 (new ArrayList < >( )); \/\/invocation"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"In this example, the List<String> declaration would be rejected using similar reasoning as in the case of Source Code Example 6. The remaining two declarations (7.1 and 7.3) would be deemed compatible with the invocation. However, based on the specificity criteria being used, it may be impossible to choose one of the two candidates as being more specific than the other, and as a result, a compile-time error may occur.","Source Code Example 8 illustrates a scenario in which a lambda expression is used as a method argument, according to one embodiment.","Source Code Example 8",{"@attributes":{"id":"p-0051","num":"0050"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["8.1.","void foo4(Callable<String> c); \/\/ declaration 8.1"]},{"entry":["8.2.","void foo4(PrivilegedAction<Integer> a); \/\/ declaration 8.2"]},{"entry":["8.3","void foo4(ActionListener al); \/\/ declaration 8.3"]},{"entry":["8.4.","foo4(( ) \u2192 \u201cdone\u201d); \/\/invocation"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"In order to perform target typing for the lambda expression (( )\u2192\u201cdone\u201d in this example) in such a scenario where the overloaded declarations have function types (e.g., Callable<String>) as parameters, the \u201cfunction descriptors\u201d of the parameters in the foo4 declarations may have to be analyzed in the embodiment illustrated. (A \u201cfunction type\u201d represents a set of invocable operation definitions with a given signature\u2014i.e., the invocable operations that have the same formal parameter types and return types. Function types may be represented in some object-oriented programming languages using functional interfaces, as illustrated in Source Code Example 9 below for one embodiment.) A \u201cfunction descriptor\u201d for a function type such as Callable<String> may comprise a representation of the combination of at least the list of parameter types and return type in at least some embodiments. (In one embodiment, the function descriptor may also include a representation of the thrown types.) For example, in the illustrated embodiment, the function descriptor for Callable<String> may be represented as \u201c( )\u2192String\u201d, indicating that it has no arguments and returns a String. Similarly, the function descriptor for PrivilegedAction<Integer> may be represented as \u201c( )\u2192Integer\u201d, indicating that PrivilegedAction has no parameters and returns an Integer. The function descriptor for ActionListener may be represented as \u201c(ActionEvent)\u2192void\u201d indicating that it has one parameter of type ActionEvent and does not return anything. Upon analyzing the source code of Example 8 and the corresponding function descriptors, a compiler in some embodiments may determine the lambda expression (( )\u2192\u201cdone\u201d) is incompatible with the ActionListener parameter of declaration 8.3, since the lambda expression has no parameters while the ActionListener has one parameter. The lambda expression may also be found incompatible with declaration 8.2, since the lambda expression returns a String rather than an Integer. However, the lambda expression may be found compatible with declaration 8.1, since the number (zero) of parameters for Callable<String> matches the number of parameters of the lambda expression, the types of the parameters are not an issue as there are no parameters, and the return type (String) matches as well. As a result, in the illustrated embodiment, declaration 8.1 may be deemed the result of the overload resolution, and executable instructions may be generated accordingly. If multiple declarations were found compatible on the basis of the analysis of their function descriptors, a determination for the most specific declaration among them may be conducted in the illustrated embodiment, e.g., using the kind of logic illustrated below with respect to . The term \u201cdescriptors\u201d may be used to refer to \u201cfunction descriptors\u201d herein.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 3","FIG. 3"],"b":["301","304"]},"The argument expression may be provided as input to the overload resolver (element ). The overload resolver may determine whether the following two conditions hold (one corresponding to the candidate declaration determination phase described above, and one corresponding to the selection of a best or most specific candidate among the candidates) in the depicted embodiment (element ). The first condition is that each of the arguments of the invocation, including the argument expression, be compatible with the type of a corresponding parameter indicated in one or more invocable operation declarations (e.g., using the equivalent of the speculative typing based on assignment tests described above).","If the argument list of the invocation comprises more than one expression (including, potentially, more than one poly expression), each of the expressions may have to meet the compatibility criteria in such an embodiment. For each poly expression among the parameters, the speculative typing approach may be used in turn (or in parallel with the analysis of other parameters in some embodiments). For expressions whose type is not content-dependent, subtyping analysis of the kind illustrated in Source Code Example 4 above may be used. If even one argument expression is found incompatible with the corresponding parameter (i.e., the parameter in the same relative position within the list of parameters) in a declaration, the declaration may be deemed incompatible. For example, consider a declaration foo5(Type1 p1, Type2 p2, Type3 p3) with three parameters, and an invocation foo5 (arg1, arg2, arg3). For this declaration of foo5 to be found compatible in one embodiment and to be considered a candidate for the next phase of overload resolution, arg1 has to be compatible with p1, arg2 has to be compatible with p2, and arg3 has to be compatible with p3.","The second condition in the embodiment depicted in  is that, using one or more specificity criteria defined to narrow down the set of candidates to a single candidate, a particular invocable operation declaration of the compatible declarations in the earlier analysis be identifiable as the most specific operation declaration for the invocation. (Of course, in the trivial case that only one compatible declaration is found, the second condition would hold, since the only compatible declaration would by default be the \u201cmost\u201d specific declaration). If both conditions hold, overload resolution and target typing may be deemed to have succeeded, and executable instructions corresponding to the invocation may be generated (element ). If either condition does not hold, an error indication may be generated.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":["FIG. 4","FIG. 4","FIG. 4"],"b":["401","404"]},"As shown in element , a determination may be made, e.g., using the speculative parse tree branch generation operations discussed earlier, as to whether an assignment of the argument to the corresponding parameter (i.e., the parameter that appears in the same position in the list of parameters as the poly expression argument appears in the list of arguments) would succeed or fail. If the assignment would fail (as in the case of declaration 6.2 in Source Code Example 6 above), the declaration may be rejected as a candidate for further analysis in the depicted embodiment (element ). If the assignment would succeed, as also determined in element , the declaration may be added to a compatible set of declarations (element ) (as in the case of declaration 6.1 of Source Code Example 6).","If more declarations remain to be examined, as determined in element , the next declaration to be considered may be identified and the operations corresponding to elements  onwards may be repeated. If no more declarations remain, the size of the compatible set may be examined. If the size is zero (i.e., no compatible declarations were found) (as determined in element ), an error may be indicated (element ) since no suitable declaration can be used for executable code generation. If the size is one (as determined in element ), no ambiguity regarding overload resolution remains, and the single compatible declaration may be used for code generation purposes (element ). If more than one compatible declaration is found, further analysis to determine the most specific declaration among them may be required in the depicted embodiment (element ). Such further analysis may comprise, in at least some embodiments, a pairwise comparison of the candidates, similar to that illustrated in .","Source Code Example 9 provides examples of the kinds of scenarios in which specificity analysis among a candidate set of compatible overloaded declarations may have to be performed in some embodiments.","Source Code Example 9",{"@attributes":{"id":"p-0061","num":"0060"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"9.1. ","interface Runnable { void run( ); }"]},{"entry":[{},"9.2. ","interface StringGetter { String get( ); }"]},{"entry":[{},"9.3.","interface ObjectGetter { Object get( ); }"]},{"entry":[{},"9.4. ","interface IntMapper { int map(int arg); }"]},{"entry":[{},"9.5.","interface StringMapper { String map(String arg); }"]},{"entry":[{},"9.6.","interface ToInteger { Integer get(int arg); }"]},{"entry":[{},"9.7.","interface ToNumber { Number get(int arg); }"]},{"entry":[{},"9.8.",{}]},{"entry":[{},"9.9. ","void m(Runnable r);"]},{"entry":[{},"9.10.","void m(StringGetter g);"]},{"entry":[{},"9.11.","void m(ObjectGetter g);"]},{"entry":[{},"9.12.","void m(IntMapper m);"]},{"entry":[{},"9.13.","void m(StringMapper m);"]},{"entry":[{},"9.14.","void m(ToInteger t);"]},{"entry":[{},"9.15.","void m(ToNumber t);"]},{"entry":[{},"9.16.",{}]},{"entry":[{},"9.17.","m([lambda expression]);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"In Source Code Example 9, lines 9.9 through 9.15 show example overloaded declarations of method m whose (single) parameter in each case is one of the function types represented by the functional interfaces of lines 9.1 through 9.7. The invocation of m with a lambda expression as an argument (shown in line 9.17) is assumed to result in the determination (e.g., using the speculative typing approach described earlier) of a compatible candidate set that includes several of the declarations of lines 9.9 through 9.15. In such a scenario, a compiler or similar tool may be required to determine which among the compatible declarations is the most specific. Such analysis may include comparisons of the function descriptors corresponding to the declarations, taken two at a time, (pairwise comparisons) using a set of specificity rules or criteria defined for the language being used in some embodiments. In one embodiment, based on a particular set of such specificity criteria, some of the results of the comparisons may include the following:","\u201cm(StringGetter)\u201d is more specific than \u201cm(ObjectGetter)\u201d because the parameter type String is a subtype of the parameter type Object.","\u201cm(ToInteger)\u201d is more specific than \u201cm(ToNumber)\u201d because the return type Integer is a subtype of the return type Number.","\u201cm(StringMapper)\u201d and \u201cm(IntMapper)\u201d conflict, i.e., neither is more specific than the other, because their function descriptors have different parameter types. As a result, an error may be indicated in some embodiments if these two declarations are being analyzed for relative specificity.","\u201cm(IntMapper)\u201d is more specific than \u201cm(ToInteger)\u201d if the lambda body returns only primitives. Primitive types may be predefined by the language specification, and may be named using reserved keywords, such as int or float; in contrast to primitives, a data type for which, when an object of that data type is instantiated, a reference (in effect, a pointer) to a heap location storing the value of the instantiated object is created, may be called a reference type. Additional details regarding primitive types, reference types, and associated type conversion operations are provided below with reference to . It is noted that some programming languages may automatically convert expressions of a certain type to expressions of a different type, but the overload resolution mechanisms used may prefer to avoid these kinds of conversions if a candidate does not require them.","\u201cm(ToInteger)\u201d is more specific than \u201cm(IntMapper)\u201d if the lambda body returns only references.","\u201cm(StringGetter)\u201d is more specific than \u201cm(Runnable)\u201d, because StringGetter returns a String while Runnable returns void.","Using the results of such pairwise comparisons, a single declaration that is more specific than all the other candidates may eventually be found in some embodiments. If such a single most specific declaration is found, that declaration may be used for code generation; otherwise, an error may be indicated.",{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 5","b":["501","504"]},"As shown in element , a determination may be made as to whether Decl1's parameter types are subtypes of the corresponding Decl2 parameter types. If Decl1's parameter types are subtypes of Decl2's parameter types, Decl1 may be deemed more specific than Decl2 (element ). If there are other declarations that are yet to be examined (as determined in element , the next pair (which may include Decl1 and one of the remaining declarations) may be examined, starting with the operations of element  onwards.","If Decl1's parameter types are not subtypes of Decl2's parameter types (as determined in element ), the compiler or interpreter may check whether D1 and D2 have the same parameter types (element ). If they do not have the same parameter types, an error may be indicated (element ), since the overload cannot be resolved, as in the case of comparing \u201cm(StringMapper)\u201d and \u201cm(IntMapper)\u201d in Source Code Example 9.","If D1 and D2 have the same parameter types (as also determined in element ), further analysis may begin based on their respective return types. The four conditions illustrated in element  may be checked. If D1's return type is a subtype of D2's return type, Decl1 may be deemed more specific than Decl2, as in the case of the comparison of \u201cm(ToInteger)\u201d to \u201cm(ToNumber)\u201d above. If D1's return type is not \u201cvoid\u201d, while D2's is \u201cvoid\u201d, Decl1 may be deemed more specific (as in the case of \u201cm(StringGetter)\u201d being deemed more specific than \u201cm(Runnable)\u201d in Source Code Example 9).","In at least some programming languages that support primitive and reference types, a set of \u201cwrapper\u201d reference types may be defined for the primitive types: for example, the wrapper type Integer may be defined for the primitive type int in one embodiment. Conversion of a primitive value to an object of the corresponding wrapper type may be referred to as \u201cboxing\u201d the primitive value (with the result of the conversion being termed the \u201cboxed\u201d form of the value), and the extraction of the primitive value from an object of the corresponding wrapper class may be referred to as \u201cunboxing\u201d the wrapper (with the result being termed the \u201cunboxed\u201d form of the object). If the D1 return type is an unboxed form of D2's return type, and all of the lambda expression's return values are unboxed, Decl1 may also be deemed more specific than Decl2 (see the discussion of the comparison of \u201cm(IntMapper)\u201d and \u201cm(ToInteger)\u201d in Source Code Example 9). If the D1 return type is a boxed form of D2's return type, and if the returns from the lambda expression are all boxed, then Decl1 may also de determined to be more specific than Decl2.","If any of the conditions listed in element  are found to be true, a specificity ordering between Decl1 and decl2 may be made (element ); otherwise, an error may be indicated. Similar analysis may be repeated for other unexamined pairs of declarations, until either an error is indicated because the overload cannot be resolved, or all the declarations have been examined and one declaration is found that is more specific than all the rest. If such a single most specific declaration is identified (element ), it may be used to resolve the overload and generate the executable instructions for the invocation (element ). It is noted that the rules or criteria used for specificity ordering may differ in different embodiments, e.g., the order in which the parameter types and return types are analyzed may differ in some embodiments from that shown in . It is also noted that some of the operations illustrated in  may be performed in a different order, in parallel rather than sequentially, or may be omitted in different embodiments. The operations illustrated in  with respect to lambda expressions and\/or method references may be applied to other kinds of argument expressions whose type is context-dependent in various embodiments.",{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 6","b":["3000","3000","3000","3010","3010","3010","3010","3020","3030","3000","3040","3030"],"i":["a","b","n"]},"In various embodiments, computing device  may be a uniprocessor system including one processor , or a multiprocessor system including several cores or processors  (e.g., two, four, eight, or another suitable number). Processors  may be any suitable processors capable of executing instructions. For example, in various embodiments, processors  may be general-purpose or embedded processors implementing any of a variety of instruction set architectures (ISAs), such as the SPARC, x86, PowerPC, or MIPS ISAs, or any other suitable ISA. In multiprocessor systems, each of processors  may commonly, but not necessarily, implement the same ISA.","System memory  may be configured to store program instructions implementing a compiler , an interpreter , source code  of various programs to be compiled, executable code  generated by the compiler or other compilers, and an execution environment  similar to runtime environment  of . System memory may also include program instructions and\/or data for various other applications. Program instructions may be encoded in platform native binary, any interpreted language such as Java\u2122 bytecode, or in any other language such as C\/C++, Java\u2122, etc or in any combination thereof. In various embodiments, system memory  may be implemented using any suitable memory technology, such as static random access memory (SRAM), synchronous dynamic RAM (SDRAM), nonvolatile\/Flash-type memory, or any other type of memory.","In one embodiment, I\/O interface  may be configured to coordinate I\/O traffic between processor , system memory , and any peripheral devices in the device, including network interface  or other peripheral interfaces. In some embodiments, I\/O interface  may perform any necessary protocol, timing or other data transformations to convert data signals from one component (e.g., system memory ) into a format suitable for use by another component (e.g., processor ). In some embodiments, I\/O interface  may include support for devices attached through various types of peripheral buses, such as a variant of the Peripheral Component Interconnect (PCI) bus standard or the Universal Serial Bus (USB) standard, for example. In some embodiments, the function of I\/O interface  may be split into two or more separate components, such as a north bridge and a south bridge, for example. Also, in some embodiments some or all of the functionality of I\/O interface , such as an interface to system memory , may be incorporated directly into processor .","Network interface  may be configured to allow data to be exchanged between computing device  and other devices  attached to a network or networks , for example. In various embodiments, network interface  may support communication via any suitable wired or wireless general data networks, such as types of Ethernet network, for example. Additionally, network interface  may support communication via telecommunications\/telephony networks such as analog voice networks or digital fiber communications networks, via storage area networks such as Fibre Channel SANs, or via any other suitable type of network and\/or protocol.","In some embodiments, system memory  may be one embodiment of a computer-accessible medium configured to store program instructions and data as described above for  through  for implementing embodiments of the corresponding methods and apparatus. However, in other embodiments, program instructions and\/or data may be received, sent or stored upon different types of computer-accessible media. Generally speaking, a computer-accessible medium may include non-transitory storage media or memory media such as magnetic or optical media, e.g., disk or DVD\/CD coupled to computing device  via I\/O interface . A non-transitory computer-accessible storage medium may also include any volatile or non-volatile media such as RAM (e.g. SDRAM, DDR SDRAM, RDRAM, SRAM, etc.), ROM, etc, that may be included in some embodiments of computing device  as system memory  or another type of memory. Further, a computer-accessible medium may include transmission media or signals such as electrical, electromagnetic, or digital signals, conveyed via a communication medium such as a network and\/or a wireless link, such as may be implemented via network interface . Portions or all of multiple computing devices such as that illustrated in  may be used to implement the described functionality in various embodiments; for example, software components running on a variety of different devices and servers may collaborate to provide the functionality. In some embodiments, portions of the described functionality may be implemented using storage devices, network devices, or special-purpose computer systems, in addition to or instead of being implemented using general-purpose computer systems. The term \u201ccomputing device\u201d, as used herein, refers to at least all these types of devices, and is not limited to these types of devices.","Various embodiments may further include receiving, sending or storing instructions and\/or data implemented in accordance with the foregoing description upon a computer-accessible medium. Generally speaking, a computer-accessible medium may include storage media or memory media such as magnetic or optical media, e.g., disk or DVD\/CD-ROM, volatile or non-volatile media such as RAM (e.g. SDRAM, DDR, RDRAM, SRAM, etc.), ROM, etc, as well as transmission media or signals such as electrical, electromagnetic, or digital signals, conveyed via a communication medium such as network and\/or a wireless link.","The various methods as illustrated in the Figures and described herein represent example embodiments of methods. The methods may be implemented in software, hardware, or a combination thereof. The order of method may be changed, and various elements may be added, reordered, combined, omitted, modified, etc.","Various modifications and changes may be made as would be obvious to a person skilled in the art having the benefit of this disclosure. It is intended that the invention embrace all such modifications and changes and, accordingly, the above description to be regarded in an illustrative rather than a restrictive sense."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
